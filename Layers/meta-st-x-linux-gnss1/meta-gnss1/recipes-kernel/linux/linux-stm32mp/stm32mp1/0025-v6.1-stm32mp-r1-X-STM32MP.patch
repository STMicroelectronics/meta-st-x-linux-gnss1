From 81dc820bb2f608a6081b3810f603e6e171188696 Mon Sep 17 00:00:00 2001
From: Mario Tesi <mario.tesi@st.com>
Date: Fri, 10 Mar 2023 13:21:34 +0100
Subject: Add STM sensors drivers to build system

Signed-off-by: Mario Tesi <mario.tesi@st.com>
---
 drivers/iio/Kconfig  | 1 +
 drivers/iio/Makefile | 1 +
 2 files changed, 2 insertions(+)

diff --git a/drivers/iio/Kconfig b/drivers/iio/Kconfig
index b190846c3..77aa36ffd 100644
--- a/drivers/iio/Kconfig
+++ b/drivers/iio/Kconfig
@@ -99,5 +99,6 @@ source "drivers/iio/pressure/Kconfig"
 source "drivers/iio/proximity/Kconfig"
 source "drivers/iio/resolver/Kconfig"
 source "drivers/iio/temperature/Kconfig"
+source "drivers/iio/stm/Kconfig"
 
 endif # IIO
diff --git a/drivers/iio/Makefile b/drivers/iio/Makefile
index 3be08cdad..b6e13e086 100644
--- a/drivers/iio/Makefile
+++ b/drivers/iio/Makefile
@@ -43,3 +43,4 @@ obj-y += resolver/
 obj-y += temperature/
 obj-y += test/
 obj-y += trigger/
+obj-y += stm/
-- 
2.25.1


From f80ca82eb7d78f587ec6eb1e4f10721d8fa76aab Mon Sep 17 00:00:00 2001
From: Mario Tesi <mario.tesi@st.com>
Date: Mon, 9 Oct 2023 16:15:33 +0200
Subject: drivers:iio:stm: Add common sensor types for STMEMS

STMEMS extends the IIO types with new custom
type used by the SensorHAL.

Signed-off-by: Mario Tesi <mario.tesi@st.com>
---
 drivers/iio/stm/common/stm_iio_types.h | 38 ++++++++++++++++++++++++++
 1 file changed, 38 insertions(+)
 create mode 100644 drivers/iio/stm/common/stm_iio_types.h

diff --git a/drivers/iio/stm/common/stm_iio_types.h b/drivers/iio/stm/common/stm_iio_types.h
new file mode 100644
index 000000000..17aba1469
--- /dev/null
+++ b/drivers/iio/stm/common/stm_iio_types.h
@@ -0,0 +1,38 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * STMicroelectronics IIO custom types
+ *
+ * MEMS Software Solutions Team
+ *
+ * Copyright 2023 STMicroelectronics Inc.
+ */
+
+#ifndef __STM_IIO_CUSTOM_TYPE__
+#define __STM_IIO_CUSTOM_TYPE__
+
+/* Linux IIO driver custom types */
+enum {
+	STM_IIO_LAST = 0x3f,
+	STM_IIO_SIGN_MOTION = STM_IIO_LAST - 6,
+	STM_IIO_STEP_COUNTER = STM_IIO_LAST - 5,
+	STM_IIO_TILT = STM_IIO_LAST - 4,
+	STM_IIO_TAP = STM_IIO_LAST - 3,
+	STM_IIO_TAP_TAP = STM_IIO_LAST - 2,
+	STM_IIO_WRIST_TILT_GESTURE = STM_IIO_LAST - 1,
+	STM_IIO_GESTURE = STM_IIO_LAST,
+};
+
+enum {
+	STM_IIO_EV_DIR_LAST = 0x1f,
+	STM_IIO_EV_DIR_FIFO_EMPTY = STM_IIO_EV_DIR_LAST - 1,
+	STM_IIO_EV_DIR_FIFO_DATA = STM_IIO_EV_DIR_LAST,
+};
+
+enum {
+	STM_IIO_EV_TYPE_LAST = 0x1f,
+	STM_IIO_EV_TYPE_FIFO_FLUSH = STM_IIO_EV_TYPE_LAST - 1,
+	STM_IIO_EV_TYPE_TIME_SYNC = STM_IIO_EV_TYPE_LAST,
+};
+
+#endif /* __STM_IIO_CUSTOM_TYPE__ */
+
-- 
2.25.1


From d3ddedeee7bff2b3a1cfbcef8e2f7bc5ca46e9a9 Mon Sep 17 00:00:00 2001
From: Mario Tesi <mario.tesi@st.com>
Date: Mon, 9 Oct 2023 16:25:45 +0200
Subject: drivers:iio:stm:imu:st_ism330dhcx: Add support to STMEMS IMU
 ism330dhcx

Added STMEMS IMU ism330dhcx sensor support.

Signed-off-by: Mario Tesi <mario.tesi@st.com>
---
 .../bindings/iio/stm/imu/st_ism330dhcx.txt    |   52 +
 drivers/iio/stm/Kconfig                       |   15 +
 drivers/iio/stm/Makefile                      |    7 +
 drivers/iio/stm/imu/Kconfig                   |   11 +
 drivers/iio/stm/imu/Makefile                  |    7 +
 drivers/iio/stm/imu/st_ism330dhcx/Kconfig     |   22 +
 drivers/iio/stm/imu/st_ism330dhcx/Makefile    |    7 +
 .../iio/stm/imu/st_ism330dhcx/st_ism330dhcx.h |  585 +++++
 .../imu/st_ism330dhcx/st_ism330dhcx_buffer.c  | 1035 +++++++++
 .../imu/st_ism330dhcx/st_ism330dhcx_core.c    | 1912 +++++++++++++++++
 .../imu/st_ism330dhcx/st_ism330dhcx_embfunc.c |  620 ++++++
 .../stm/imu/st_ism330dhcx/st_ism330dhcx_i2c.c |   97 +
 .../imu/st_ism330dhcx/st_ism330dhcx_shub.c    | 1006 +++++++++
 .../stm/imu/st_ism330dhcx/st_ism330dhcx_spi.c |  107 +
 14 files changed, 5483 insertions(+)
 create mode 100644 Documentation/devicetree/bindings/iio/stm/imu/st_ism330dhcx.txt
 create mode 100644 drivers/iio/stm/Kconfig
 create mode 100644 drivers/iio/stm/Makefile
 create mode 100644 drivers/iio/stm/imu/Kconfig
 create mode 100644 drivers/iio/stm/imu/Makefile
 create mode 100644 drivers/iio/stm/imu/st_ism330dhcx/Kconfig
 create mode 100644 drivers/iio/stm/imu/st_ism330dhcx/Makefile
 create mode 100644 drivers/iio/stm/imu/st_ism330dhcx/st_ism330dhcx.h
 create mode 100644 drivers/iio/stm/imu/st_ism330dhcx/st_ism330dhcx_buffer.c
 create mode 100644 drivers/iio/stm/imu/st_ism330dhcx/st_ism330dhcx_core.c
 create mode 100644 drivers/iio/stm/imu/st_ism330dhcx/st_ism330dhcx_embfunc.c
 create mode 100644 drivers/iio/stm/imu/st_ism330dhcx/st_ism330dhcx_i2c.c
 create mode 100644 drivers/iio/stm/imu/st_ism330dhcx/st_ism330dhcx_shub.c
 create mode 100644 drivers/iio/stm/imu/st_ism330dhcx/st_ism330dhcx_spi.c

diff --git a/Documentation/devicetree/bindings/iio/stm/imu/st_ism330dhcx.txt b/Documentation/devicetree/bindings/iio/stm/imu/st_ism330dhcx.txt
new file mode 100644
index 000000000..63d3f1b68
--- /dev/null
+++ b/Documentation/devicetree/bindings/iio/stm/imu/st_ism330dhcx.txt
@@ -0,0 +1,52 @@
+* st_ism330dhcx driver for imu MEMS sensors
+
+Required properties for all bus drivers:
+- compatible: must be one of:
+              "st,ism330dhcx"
+
+Required properties for the i2c bindings:
+- reg: i2c slave address
+
+Required properties for the spi bindings:
+- reg:               the chipselect index
+- spi-max-frequency: maximal bus speed, should be set to 1000000 unless
+                     constrained by external circuitry
+
+Optional properties for all bus drivers:
+- st,int-pin:       the pin on the package that will be used to signal
+                    "data ready" (valid values: 1 or 2, default: 1).
+
+- drive-open-drain: the interrupt/data ready line will be configured as open drain,
+                    which is useful if several sensors share the same interrupt line.
+
+- interrupts:       interrupt mapping for IRQ. It should be configured with
+                    flags IRQ_TYPE_LEVEL_HIGH, IRQ_TYPE_EDGE_RISING,
+                    IRQ_TYPE_LEVEL_LOW or IRQ_TYPE_EDGE_FALLING.
+
+                    Refer to interrupt-controller/interrupts.txt for generic interrupt
+                    client node bindings.
+
+- st,module_id:     module identifier.
+                    This is used by user-space to identify which devices
+                    are part of the same module (particularly important for
+                    supporting multiple sensors of the same type).
+
+- wakeup-source:    https://www.kernel.org/doc/Documentation/devicetree/bindings/power/wakeup-source.txt
+
+Example for an i2c device node:
+
+&i2c5 {
+        status = "okay";
+        st_ism330dhcx_X_STM32MP_MSP01@6b {
+                compatible = "st,ism330dhcx";
+
+                reg =<0x6b>;
+                st,int-pin = <2>;
+
+                /* uses GPIO PB12 on X-STM32MP-MSP01 */
+                interrupt-parent = <&gpiob>;
+                interrupts = <12 IRQ_TYPE_LEVEL_HIGH>;
+
+                status = "okay";
+        };
+}
diff --git a/drivers/iio/stm/Kconfig b/drivers/iio/stm/Kconfig
new file mode 100644
index 000000000..8e0e9c6ba
--- /dev/null
+++ b/drivers/iio/stm/Kconfig
@@ -0,0 +1,15 @@
+# SPDX-License-Identifier: GPL-2.0-only
+#
+# STM Industrial I/O drivers configuration
+#
+# When adding new entries keep the list in alphabetical order
+
+menuconfig IIO_STM
+           tristate "STM MEMS Device Drivers"
+
+if IIO_STM
+
+source "drivers/iio/stm/imu/Kconfig"
+
+endif # IIO_STM
+
diff --git a/drivers/iio/stm/Makefile b/drivers/iio/stm/Makefile
new file mode 100644
index 000000000..b39010a49
--- /dev/null
+++ b/drivers/iio/stm/Makefile
@@ -0,0 +1,7 @@
+# SPDX-License-Identifier: GPL-2.0-only
+#
+# STM Makefile for Industrial I/O drivers
+#
+# When adding new entries keep the list in alphabetical order
+
+obj-$(CONFIG_IIO_STM) += imu/
diff --git a/drivers/iio/stm/imu/Kconfig b/drivers/iio/stm/imu/Kconfig
new file mode 100644
index 000000000..ef20e252d
--- /dev/null
+++ b/drivers/iio/stm/imu/Kconfig
@@ -0,0 +1,11 @@
+# SPDX-License-Identifier: GPL-2.0-only
+#
+# IIO imu drivers configuration
+#
+# When adding new entries keep the list in alphabetical order
+
+menu "Inertial measurement units"
+
+source "drivers/iio/stm/imu/st_ism330dhcx/Kconfig"
+
+endmenu
diff --git a/drivers/iio/stm/imu/Makefile b/drivers/iio/stm/imu/Makefile
new file mode 100644
index 000000000..e54b59dea
--- /dev/null
+++ b/drivers/iio/stm/imu/Makefile
@@ -0,0 +1,7 @@
+# SPDX-License-Identifier: GPL-2.0
+#
+# Makefile for Inertial Measurement Units
+#
+
+# When adding new entries keep the list in alphabetical order
+obj-y += st_ism330dhcx/
diff --git a/drivers/iio/stm/imu/st_ism330dhcx/Kconfig b/drivers/iio/stm/imu/st_ism330dhcx/Kconfig
new file mode 100644
index 000000000..da3123bfa
--- /dev/null
+++ b/drivers/iio/stm/imu/st_ism330dhcx/Kconfig
@@ -0,0 +1,22 @@
+# SPDX-License-Identifier: GPL-2.0-only
+config IIO_ST_ISM330DHCX
+	tristate "STMicroelectronics ISM330DHCX sensor"
+	depends on (I2C || SPI)
+	select IIO_BUFFER
+	select IIO_TRIGGERED_BUFFER
+	select IIO_ST_ISM330DHCX_I2C if (I2C)
+	select IIO_ST_ISM330DHCX_SPI if (SPI_MASTER)
+	help
+	  Say yes here to build support for STMicroelectronics ISM330DHCX imu
+	  sensor.
+
+	  To compile this driver as a module, choose M here: the module
+	  will be called st_ism330dhcx.
+
+config IIO_ST_ISM330DHCX_I2C
+	tristate
+	depends on IIO_ST_ISM330DHCX
+
+config IIO_ST_ISM330DHCX_SPI
+	tristate
+	depends on IIO_ST_ISM330DHCX
diff --git a/drivers/iio/stm/imu/st_ism330dhcx/Makefile b/drivers/iio/stm/imu/st_ism330dhcx/Makefile
new file mode 100644
index 000000000..dc9748534
--- /dev/null
+++ b/drivers/iio/stm/imu/st_ism330dhcx/Makefile
@@ -0,0 +1,7 @@
+# SPDX-License-Identifier: GPL-2.0-only
+st_ism330dhcx-y := st_ism330dhcx_core.o st_ism330dhcx_buffer.o \
+		st_ism330dhcx_shub.o st_ism330dhcx_embfunc.o
+
+obj-$(CONFIG_IIO_ST_ISM330DHCX) += st_ism330dhcx.o
+obj-$(CONFIG_IIO_ST_ISM330DHCX_I2C) += st_ism330dhcx_i2c.o
+obj-$(CONFIG_IIO_ST_ISM330DHCX_SPI) += st_ism330dhcx_spi.o
diff --git a/drivers/iio/stm/imu/st_ism330dhcx/st_ism330dhcx.h b/drivers/iio/stm/imu/st_ism330dhcx/st_ism330dhcx.h
new file mode 100644
index 000000000..9f6f83957
--- /dev/null
+++ b/drivers/iio/stm/imu/st_ism330dhcx/st_ism330dhcx.h
@@ -0,0 +1,585 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * STMicroelectronics st_ism330dhcx sensor driver
+ *
+ * MEMS Software Solutions Team
+ *
+ * Copyright 2020 STMicroelectronics Inc.
+ */
+
+#ifndef ST_ISM330DHCX_H
+#define ST_ISM330DHCX_H
+
+#include <linux/device.h>
+#include <linux/iio/iio.h>
+#include <linux/of_device.h>
+#include <linux/delay.h>
+
+#include "../../common/stm_iio_types.h"
+
+#define ST_ISM330DHCX_MAX_ODR			833
+#define ST_ISM330DHCX_ODR_LIST_SIZE		8
+#define ST_ISM330DHCX_ODR_EXPAND(odr, uodr)	((odr * 1000000) + uodr)
+
+#define ST_ISM330DHCX_DEV_NAME			"ism330dhcx"
+
+#define ST_ISM330DHCX_REG_FUNC_CFG_ACCESS_ADDR	0x01
+#define ST_ISM330DHCX_REG_SHUB_REG_MASK		BIT(6)
+#define ST_ISM330DHCX_REG_FUNC_CFG_MASK		BIT(7)
+
+#define ST_ISM330DHCX_REG_FIFO_CTRL1_ADDR		0x07
+#define ST_ISM330DHCX_REG_FIFO_CTRL2_ADDR		0x08
+#define ST_ISM330DHCX_REG_FIFO_WTM_MASK		GENMASK(8, 0)
+#define ST_ISM330DHCX_REG_FIFO_WTM8_MASK		BIT(0)
+
+#define ST_ISM330DHCX_REG_FIFO_CTRL3_ADDR		0x09
+#define ST_ISM330DHCX_REG_BDR_XL_MASK		GENMASK(3, 0)
+#define ST_ISM330DHCX_REG_BDR_GY_MASK		GENMASK(7, 4)
+
+#define ST_ISM330DHCX_REG_FIFO_CTRL4_ADDR		0x0a
+#define ST_ISM330DHCX_REG_FIFO_MODE_MASK		GENMASK(2, 0)
+#define ST_ISM330DHCX_REG_ODR_T_BATCH_MASK		GENMASK(5, 4)
+#define ST_ISM330DHCX_REG_DEC_TS_MASK		GENMASK(7, 6)
+
+#define ST_ISM330DHCX_REG_INT1_CTRL_ADDR		0x0d
+#define ST_ISM330DHCX_REG_INT2_CTRL_ADDR		0x0e
+#define ST_ISM330DHCX_REG_INT_FIFO_TH_MASK		BIT(3)
+
+#define ST_ISM330DHCX_REG_WHOAMI_ADDR		0x0f
+#define ST_ISM330DHCX_WHOAMI_VAL			0x6b
+
+#define ST_ISM330DHCX_CTRL1_XL_ADDR		0x10
+#define ST_ISM330DHCX_CTRL2_G_ADDR			0x11
+#define ST_ISM330DHCX_REG_CTRL3_C_ADDR		0x12
+#define ST_ISM330DHCX_REG_SW_RESET_MASK		BIT(0)
+#define ST_ISM330DHCX_REG_PP_OD_MASK		BIT(4)
+#define ST_ISM330DHCX_REG_H_LACTIVE_MASK		BIT(5)
+#define ST_ISM330DHCX_REG_BDU_MASK			BIT(6)
+#define ST_ISM330DHCX_REG_BOOT_MASK		BIT(7)
+
+#define ST_ISM330DHCX_REG_CTRL4_C_ADDR		0x13
+#define ST_ISM330DHCX_REG_DRDY_MASK		BIT(3)
+
+#define ST_ISM330DHCX_REG_CTRL5_C_ADDR		0x14
+#define ST_ISM330DHCX_REG_ROUNDING_MASK		GENMASK(6, 5)
+
+#define ST_ISM330DHCX_REG_CTRL9_XL_ADDR		0x18
+#define ST_ISM330DHCX_REG_I3C_DISABLE_MASK		BIT(1)
+
+#define ST_ISM330DHCX_REG_CTRL10_C_ADDR		0x19
+#define ST_ISM330DHCX_REG_TIMESTAMP_EN_MASK	BIT(5)
+
+#define ST_ISM330DHCX_REG_OUT_TEMP_L_ADDR		0x20
+
+#define ST_ISM330DHCX_REG_OUTX_L_G_ADDR		0x22
+#define ST_ISM330DHCX_REG_OUTY_L_G_ADDR		0x24
+#define ST_ISM330DHCX_REG_OUTZ_L_G_ADDR		0x26
+
+#define ST_ISM330DHCX_REG_OUTX_L_A_ADDR		0x28
+#define ST_ISM330DHCX_REG_OUTY_L_A_ADDR		0x2a
+#define ST_ISM330DHCX_REG_OUTZ_L_A_ADDR		0x2c
+
+#define ST_ISM330DHCX_REG_FIFO_STATUS1_ADDR	0x3a
+#define ST_ISM330DHCX_REG_FIFO_STATUS_DIFF		GENMASK(9, 0)
+
+#define ST_ISM330DHCX_REG_TIMESTAMP0_ADDR		0x40
+#define ST_ISM330DHCX_REG_TIMESTAMP2_ADDR		0x42
+
+#define ST_ISM330DHCX_REG_TAP_CFG0_ADDR		0x56
+#define ST_ISM330DHCX_REG_TAP_X_EN_MASK		BIT(3)
+#define ST_ISM330DHCX_REG_TAP_Y_EN_MASK		BIT(2)
+#define ST_ISM330DHCX_REG_TAP_Z_EN_MASK		BIT(1)
+#define ST_ISM330DHCX_REG_LIR_MASK			BIT(0)
+
+#define ST_ISM330DHCX_REG_MD1_CFG_ADDR		0x5e
+#define ST_ISM330DHCX_REG_MD2_CFG_ADDR		0x5f
+#define ST_ISM330DHCX_REG_INT2_TIMESTAMP_MASK	BIT(0)
+#define ST_ISM330DHCX_REG_INT_EMB_FUNC_MASK	BIT(1)
+
+#define ST_ISM330DHCX_INTERNAL_FREQ_FINE		0x63
+
+#define ST_ISM330DHCX_REG_FIFO_DATA_OUT_TAG_ADDR	0x78
+
+/* embedded registers */
+#define ST_ISM330DHCX_REG_EMB_FUNC_INT1_ADDR	0x0a
+#define ST_ISM330DHCX_REG_EMB_FUNC_INT2_ADDR	0x0e
+
+/* Timestamp Tick 25us/LSB */
+#define ST_ISM330DHCX_TS_DELTA_NS			25000ULL
+
+#define ST_ISM330DHCX_TEMP_GAIN			256
+#define ST_ISM330DHCX_TEMP_FS_GAIN			(1000000 / ST_ISM330DHCX_TEMP_GAIN)
+#define ST_ISM330DHCX_TEMP_OFFSET			6400
+
+#define ST_ISM330DHCX_SAMPLE_SIZE			6
+#define ST_ISM330DHCX_TS_SAMPLE_SIZE		4
+#define ST_ISM330DHCX_TAG_SIZE			1
+#define ST_ISM330DHCX_FIFO_SAMPLE_SIZE		(ST_ISM330DHCX_SAMPLE_SIZE + \
+						 ST_ISM330DHCX_TAG_SIZE)
+#define ST_ISM330DHCX_MAX_FIFO_DEPTH		416
+
+#define ST_ISM330DHCX_DATA_CHANNEL(chan_type, addr, mod, ch2, scan_idx,	\
+				rb, sb, sg)				\
+{									\
+	.type = chan_type,						\
+	.address = addr,						\
+	.modified = mod,						\
+	.channel2 = ch2,						\
+	.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) |			\
+			      BIT(IIO_CHAN_INFO_SCALE),			\
+	.info_mask_shared_by_all = BIT(IIO_CHAN_INFO_SAMP_FREQ),	\
+	.scan_index = scan_idx,						\
+	.scan_type = {							\
+		.sign = sg,						\
+		.realbits = rb,						\
+		.storagebits = sb,					\
+		.endianness = IIO_LE,					\
+	},								\
+}
+
+static const struct iio_event_spec st_ism330dhcx_flush_event = {
+	.type = STM_IIO_EV_TYPE_FIFO_FLUSH,
+	.dir = IIO_EV_DIR_EITHER,
+};
+
+static const struct iio_event_spec st_ism330dhcx_thr_event = {
+	.type = IIO_EV_TYPE_THRESH,
+	.dir = IIO_EV_DIR_RISING,
+	.mask_separate = BIT(IIO_EV_INFO_ENABLE),
+};
+
+#define ST_ISM330DHCX_EVENT_CHANNEL(ctype, etype)		\
+{							\
+	.type = ctype,					\
+	.modified = 0,					\
+	.scan_index = -1,				\
+	.indexed = -1,					\
+	.event_spec = &st_ism330dhcx_##etype##_event,	\
+	.num_event_specs = 1,				\
+}
+
+#define ST_ISM330DHCX_RX_MAX_LENGTH		64
+#define ST_ISM330DHCX_TX_MAX_LENGTH		16
+
+/**
+ * @struct st_ism330dhcx_transfer_buffer
+ * @brief Buffer support for data transfer
+ *
+ * rx_buf: Data receive buffer.
+ * tx_buf: Data transmit buffer.
+ */
+struct st_ism330dhcx_transfer_buffer {
+	u8 rx_buf[ST_ISM330DHCX_RX_MAX_LENGTH];
+	u8 tx_buf[ST_ISM330DHCX_TX_MAX_LENGTH] ____cacheline_aligned;
+};
+
+/**
+ * @struct st_ism330dhcx_transfer_function
+ * @brief Bus Transfer Function
+ *
+ * read: Bus read function to get register value from sensor.
+ * write: Bus write function to set register value to sensor.
+ */
+struct st_ism330dhcx_transfer_function {
+	int (*read)(struct device *dev, u8 addr, int len, u8 *data);
+	int (*write)(struct device *dev, u8 addr, int len, const u8 *data);
+};
+
+/**
+ * @struct st_ism330dhcx_reg
+ * @brief Generic sensor register description
+ *
+ * addr: Register arress value.
+ * mask: Register bitmask.
+ */
+struct st_ism330dhcx_reg {
+	u8 addr;
+	u8 mask;
+};
+
+enum st_ism330dhcx_suspend_resume_register {
+	ST_ISM330DHCX_CTRL1_XL_REG = 0,
+	ST_ISM330DHCX_CTRL2_G_REG,
+	ST_ISM330DHCX_REG_CTRL3_C_REG,
+	ST_ISM330DHCX_REG_CTRL4_C_REG,
+	ST_ISM330DHCX_REG_CTRL5_C_REG,
+	ST_ISM330DHCX_REG_CTRL10_C_REG,
+	ST_ISM330DHCX_REG_TAP_CFG0_REG,
+	ST_ISM330DHCX_REG_INT1_CTRL_REG,
+	ST_ISM330DHCX_REG_INT2_CTRL_REG,
+	ST_ISM330DHCX_REG_FIFO_CTRL1_REG,
+	ST_ISM330DHCX_REG_FIFO_CTRL2_REG,
+	ST_ISM330DHCX_REG_FIFO_CTRL3_REG,
+	ST_ISM330DHCX_REG_FIFO_CTRL4_REG,
+	ST_ISM330DHCX_SUSPEND_RESUME_REGS,
+};
+
+struct st_ism330dhcx_suspend_resume_entry {
+	u8 addr;
+	u8 val;
+	u8 mask;
+};
+
+/**
+ * @struct st_ism330dhcx_odr
+ * @brief ODR sensor table entry
+ *
+ * In the ODR table the possible ODR supported by sensor can be defined in the
+ * following format:
+ *    .odr_avl[0] = {   0, 0,       0x00 },
+ *    .odr_avl[1] = {  12, 500000,  0x01 }, ..... it means 12.5 Hz
+ *    .odr_avl[2] = {  26, 0,       0x02 }, ..... it means 26.0 Hz
+ *
+ * hz: Most significant part of ODR value (in Hz).
+ * uhz: Least significant part of ODR value (in micro Hz).
+ * val: Register value tu set ODR.
+ */
+struct st_ism330dhcx_odr {
+	int hz;
+	int uhz;
+	u8 val;
+};
+
+/**
+ * @struct st_ism330dhcx_odr_table_entry
+ * @brief ODR sensor table
+ *
+ * odr_size: ODR table size.
+ * reg: Sensor register description for ODR (address and mask).
+ * odr_avl: All supported ODR values.
+ */
+struct st_ism330dhcx_odr_table_entry {
+	u8 odr_size;
+	struct st_ism330dhcx_reg reg;
+	struct st_ism330dhcx_odr odr_avl[ST_ISM330DHCX_ODR_LIST_SIZE];
+};
+
+/**
+ * @struct st_ism330dhcx_fs
+ * @brief Full scale entry
+ *
+ * reg: Sensor register description for FS (address and mask).
+ * gain: The gain to obtain data value from raw data (LSB).
+ * val: Register value.
+ */
+struct st_ism330dhcx_fs {
+	struct st_ism330dhcx_reg reg;
+	u32 gain;
+	u8 val;
+};
+
+/**
+ * @struct st_ism330dhcx_fs_table_entry
+ * @brief Full scale table
+ *
+ * size: Full scale number of entry.
+ * fs_avl: Full scale entry.
+ */
+#define ST_ISM330DHCX_FS_LIST_SIZE			5
+#define ST_ISM330DHCX_FS_ACC_LIST_SIZE		4
+#define ST_ISM330DHCX_FS_GYRO_LIST_SIZE		5
+#define ST_ISM330DHCX_FS_TEMP_LIST_SIZE		1
+struct st_ism330dhcx_fs_table_entry {
+	u8 size;
+	struct st_ism330dhcx_fs fs_avl[ST_ISM330DHCX_FS_LIST_SIZE];
+};
+
+#define ST_ISM330DHCX_ACC_FS_2G_GAIN	IIO_G_TO_M_S_2(61000)
+#define ST_ISM330DHCX_ACC_FS_4G_GAIN	IIO_G_TO_M_S_2(122000)
+#define ST_ISM330DHCX_ACC_FS_8G_GAIN	IIO_G_TO_M_S_2(244000)
+#define ST_ISM330DHCX_ACC_FS_16G_GAIN	IIO_G_TO_M_S_2(488000)
+
+#define ST_ISM330DHCX_GYRO_FS_250_GAIN	IIO_DEGREE_TO_RAD(8750000)
+#define ST_ISM330DHCX_GYRO_FS_500_GAIN	IIO_DEGREE_TO_RAD(17500000)
+#define ST_ISM330DHCX_GYRO_FS_1000_GAIN	IIO_DEGREE_TO_RAD(35000000)
+#define ST_ISM330DHCX_GYRO_FS_2000_GAIN	IIO_DEGREE_TO_RAD(70000000)
+#define ST_ISM330DHCX_GYRO_FS_4000_GAIN	IIO_DEGREE_TO_RAD(140000000)
+
+struct st_ism330dhcx_ext_dev_info {
+	const struct st_ism330dhcx_ext_dev_settings *ext_dev_settings;
+	u8 ext_dev_i2c_addr;
+};
+
+/**
+ * @enum st_ism330dhcx_sensor_id
+ * @brief Sensor Identifier
+ */
+enum st_ism330dhcx_sensor_id {
+	ST_ISM330DHCX_ID_GYRO,
+	ST_ISM330DHCX_ID_ACC,
+	ST_ISM330DHCX_ID_TEMP,
+	ST_ISM330DHCX_ID_EXT0,
+	ST_ISM330DHCX_ID_EXT1,
+	ST_ISM330DHCX_ID_STEP_COUNTER,
+	ST_ISM330DHCX_ID_STEP_DETECTOR,
+	ST_ISM330DHCX_ID_SIGN_MOTION,
+	ST_ISM330DHCX_ID_GLANCE,
+	ST_ISM330DHCX_ID_MOTION,
+	ST_ISM330DHCX_ID_NO_MOTION,
+	ST_ISM330DHCX_ID_WAKEUP,
+	ST_ISM330DHCX_ID_PICKUP,
+	ST_ISM330DHCX_ID_ORIENTATION,
+	ST_ISM330DHCX_ID_WRIST_TILT,
+	ST_ISM330DHCX_ID_TILT,
+	ST_ISM330DHCX_ID_MAX,
+};
+
+/**
+ * @enum st_ism330dhcx_sensor_id
+ * @brief Sensor Table Identifier
+ */
+static const enum st_ism330dhcx_sensor_id st_ism330dhcx_main_sensor_list[] = {
+	 [0] = ST_ISM330DHCX_ID_GYRO,
+	 [1] = ST_ISM330DHCX_ID_ACC,
+	 [2] = ST_ISM330DHCX_ID_TEMP,
+	 [3] = ST_ISM330DHCX_ID_STEP_COUNTER,
+	 [4] = ST_ISM330DHCX_ID_STEP_DETECTOR,
+	 [5] = ST_ISM330DHCX_ID_SIGN_MOTION,
+	 [6] = ST_ISM330DHCX_ID_GLANCE,
+	 [7] = ST_ISM330DHCX_ID_MOTION,
+	 [8] = ST_ISM330DHCX_ID_NO_MOTION,
+	 [9] = ST_ISM330DHCX_ID_WAKEUP,
+	[10] = ST_ISM330DHCX_ID_PICKUP,
+	[11] = ST_ISM330DHCX_ID_ORIENTATION,
+	[12] = ST_ISM330DHCX_ID_WRIST_TILT,
+	[13] = ST_ISM330DHCX_ID_TILT,
+};
+
+/**
+ * @enum st_ism330dhcx_fifo_mode
+ * @brief FIFO Modes
+ */
+enum st_ism330dhcx_fifo_mode {
+	ST_ISM330DHCX_FIFO_BYPASS = 0x0,
+	ST_ISM330DHCX_FIFO_CONT = 0x6,
+};
+
+/**
+ * @enum st_ism330dhcx_fifo_mode - FIFO Buffer Status
+ */
+enum st_ism330dhcx_fifo_status {
+	ST_ISM330DHCX_HW_FLUSH,
+	ST_ISM330DHCX_HW_OPERATIONAL,
+};
+
+/**
+ * @struct st_ism330dhcx_sensor
+ * @brief ST IMU sensor instance
+ *
+ * id: Sensor identifier
+ * hw: Pointer to instance of struct st_ism330dhcx_hw
+ * ext_dev_info: Sensor hub i2c slave settings.
+ * trig: Sensor iio trigger.
+ * gain: Configured sensor sensitivity
+ * odr: Output data rate of the sensor [Hz]
+ * uodr: Output data rate of the sensor [uHz]
+ * offset: Sensor data offset
+ * decimator: Sensor decimator
+ * dec_counter: Sensor decimator counter
+ * old_data: Saved sensor data
+ * max_watermark: Max supported watermark level
+ * watermark: Sensor watermark level
+ * batch_reg: Sensor reg/mask for FIFO batching register
+ * last_fifo_timestamp: Store last sample timestamp in FIFO, used by flush
+ */
+struct st_ism330dhcx_sensor {
+	enum st_ism330dhcx_sensor_id id;
+	struct st_ism330dhcx_hw *hw;
+
+	struct st_ism330dhcx_ext_dev_info ext_dev_info;
+
+	struct iio_trigger *trig;
+
+	u32 gain;
+	int odr;
+	int uodr;
+
+	u32 offset;
+	u8 decimator;
+	u8 dec_counter;
+
+	u16 max_watermark;
+	u16 watermark;
+
+	struct st_ism330dhcx_reg batch_reg;
+	s64 last_fifo_timestamp;
+};
+
+/**
+ * @struct st_ism330dhcx_hw
+ * @brief ST IMU MEMS hw instance
+ *
+ * dev: Pointer to instance of struct device (I2C or SPI).
+ * irq: Device interrupt line (I2C or SPI).
+ * lock: Mutex to protect read and write operations.
+ * fifo_lock: Mutex to prevent concurrent access to the hw FIFO.
+ * page_lock: Mutex to prevent concurrent memory page configuration.
+ * fifo_mode: FIFO operating mode supported by the device.
+ * state: hw operational state.
+ * enable_mask: Enabled sensor bitmask.
+ * fsm_enable_mask: FSM Enabled sensor bitmask.
+ * embfunc_pg0_irq_reg: Embedded function irq configuration register (page 0).
+ * embfunc_irq_reg: Embedded function irq configuration register (other).
+ * ext_data_len: Number of i2c slave devices connected to I2C master.
+ * odr: Timestamp sample ODR [Hz]
+ * uodr: Timestamp sample ODR [uHz]
+ * ts_offset: Hw timestamp offset.
+ * hw_ts: Latest hw timestamp from the sensor.
+ * hw_ts_high: Manage timestamp rollover
+ * tsample:
+ * hw_ts_old:
+ * delta_ts: Delta time between two consecutive interrupts.
+ * delta_hw_ts:
+ * ts: Latest timestamp from irq handler.
+ * @module_id: identify iio devices of the same sensor module.
+ * iio_devs: Pointers to acc/gyro iio_dev instances.
+ * tf: Transfer function structure used by I/O operations.
+ * tb: Transfer buffers used by SPI I/O operations.
+ */
+struct st_ism330dhcx_hw {
+	struct device *dev;
+	int irq;
+
+	struct mutex lock;
+	struct mutex fifo_lock;
+	struct mutex page_lock;
+
+	enum st_ism330dhcx_fifo_mode fifo_mode;
+	unsigned long state;
+	u32 enable_mask;
+	u32 requested_mask;
+
+	u16 fsm_enable_mask;
+	u8 embfunc_irq_reg;
+	u8 embfunc_pg0_irq_reg;
+
+	u8 ext_data_len;
+
+	int odr;
+	int uodr;
+
+	s64 ts_offset;
+	u64 ts_delta_ns;
+	s64 hw_ts;
+	u32 val_ts_old;
+	u32 hw_ts_high;
+	s64 tsample;
+	s64 delta_ts;
+	s64 ts;
+	u32 module_id;
+
+	struct iio_dev *iio_devs[ST_ISM330DHCX_ID_MAX];
+
+	const struct st_ism330dhcx_transfer_function *tf;
+	struct st_ism330dhcx_transfer_buffer tb;
+};
+
+/**
+ * @struct dev_pm_ops
+ * @brief Power mamagement callback function structure
+ */
+extern const struct dev_pm_ops st_ism330dhcx_pm_ops;
+
+static inline int st_ism330dhcx_read_atomic(struct st_ism330dhcx_hw *hw, u8 addr,
+					 int len, u8 *data)
+{
+	int err;
+
+	mutex_lock(&hw->page_lock);
+	err = hw->tf->read(hw->dev, addr, len, data);
+	mutex_unlock(&hw->page_lock);
+
+	return err;
+}
+
+static inline int st_ism330dhcx_write_atomic(struct st_ism330dhcx_hw *hw, u8 addr,
+					  int len, u8 *data)
+{
+	int err;
+
+	mutex_lock(&hw->page_lock);
+	err = hw->tf->write(hw->dev, addr, len, data);
+	mutex_unlock(&hw->page_lock);
+
+	return err;
+}
+
+int __st_ism330dhcx_write_with_mask(struct st_ism330dhcx_hw *hw, u8 addr, u8 mask,
+				 u8 val);
+static inline int st_ism330dhcx_write_with_mask(struct st_ism330dhcx_hw *hw, u8 addr,
+					     u8 mask, u8 val)
+{
+	int err;
+
+	mutex_lock(&hw->page_lock);
+	err = __st_ism330dhcx_write_with_mask(hw, addr, mask, val);
+	mutex_unlock(&hw->page_lock);
+
+	return err;
+}
+
+static inline int st_ism330dhcx_set_page_access(struct st_ism330dhcx_hw *hw,
+					     u8 mask, u8 data)
+{
+	int err;
+
+	err = __st_ism330dhcx_write_with_mask(hw,
+					   ST_ISM330DHCX_REG_FUNC_CFG_ACCESS_ADDR,
+					   mask, data);
+	usleep_range(100, 150);
+
+	return err;
+}
+
+static inline bool st_ism330dhcx_is_fifo_enabled(struct st_ism330dhcx_hw *hw)
+{
+	return hw->enable_mask & (BIT(ST_ISM330DHCX_ID_STEP_COUNTER) |
+				  BIT(ST_ISM330DHCX_ID_GYRO)	  |
+				  BIT(ST_ISM330DHCX_ID_ACC)	  |
+				  BIT(ST_ISM330DHCX_ID_EXT0)	  |
+				  BIT(ST_ISM330DHCX_ID_EXT1));
+}
+
+int st_ism330dhcx_probe(struct device *dev, int irq,
+		     const struct st_ism330dhcx_transfer_function *tf_ops);
+int st_ism330dhcx_shub_set_enable(struct st_ism330dhcx_sensor *sensor, bool enable);
+int st_ism330dhcx_shub_probe(struct st_ism330dhcx_hw *hw);
+int st_ism330dhcx_sensor_set_enable(struct st_ism330dhcx_sensor *sensor,
+				 bool enable);
+int st_ism330dhcx_buffers_setup(struct st_ism330dhcx_hw *hw);
+int st_ism330dhcx_get_odr_val(enum st_ism330dhcx_sensor_id id, int odr, int uodr,
+			   int *podr, int *puodr, u8 *val);
+int st_ism330dhcx_update_watermark(struct st_ism330dhcx_sensor *sensor,
+				u16 watermark);
+ssize_t st_ism330dhcx_flush_fifo(struct device *dev,
+			      struct device_attribute *attr,
+			      const char *buf, size_t size);
+ssize_t st_ism330dhcx_get_max_watermark(struct device *dev,
+				     struct device_attribute *attr,
+				     char *buf);
+ssize_t st_ism330dhcx_get_watermark(struct device *dev,
+				 struct device_attribute *attr,
+				 char *buf);
+ssize_t st_ism330dhcx_set_watermark(struct device *dev,
+				 struct device_attribute *attr,
+				 const char *buf, size_t size);
+ssize_t st_ism330dhcx_get_module_id(struct device *dev,
+				    struct device_attribute *attr,
+				    char *buf);
+
+int st_ism330dhcx_set_page_access(struct st_ism330dhcx_hw *hw, u8 mask, u8 data);
+int st_ism330dhcx_suspend_fifo(struct st_ism330dhcx_hw *hw);
+int st_ism330dhcx_set_fifo_mode(struct st_ism330dhcx_hw *hw,
+			     enum st_ism330dhcx_fifo_mode fifo_mode);
+int __st_ism330dhcx_set_sensor_batching_odr(struct st_ism330dhcx_sensor *sensor,
+					 bool enable);
+int st_ism330dhcx_fsm_init(struct st_ism330dhcx_hw *hw);
+int st_ism330dhcx_fsm_get_orientation(struct st_ism330dhcx_hw *hw, u8 *data);
+int st_ism330dhcx_embfunc_sensor_set_enable(struct st_ism330dhcx_sensor *sensor,
+					 bool enable);
+int st_ism330dhcx_step_counter_set_enable(struct st_ism330dhcx_sensor *sensor,
+				       bool enable);
+int st_ism330dhcx_reset_step_counter(struct iio_dev *iio_dev);
+int st_ism330dhcx_update_batching(struct iio_dev *iio_dev, bool enable);
+int st_ism330dhcx_reset_hwts(struct st_ism330dhcx_hw *hw);
+#endif /* ST_ISM330DHCX_H */
diff --git a/drivers/iio/stm/imu/st_ism330dhcx/st_ism330dhcx_buffer.c b/drivers/iio/stm/imu/st_ism330dhcx/st_ism330dhcx_buffer.c
new file mode 100644
index 000000000..bfd305ec3
--- /dev/null
+++ b/drivers/iio/stm/imu/st_ism330dhcx/st_ism330dhcx_buffer.c
@@ -0,0 +1,1035 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * STMicroelectronics st_ism330dhcx FIFO buffer library driver
+ *
+ * MEMS Software Solutions Team
+ *
+ * Copyright 2020 STMicroelectronics Inc.
+ */
+#include <linux/module.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/iio/iio.h>
+#include <linux/iio/kfifo_buf.h>
+#include <linux/iio/events.h>
+#include <asm/unaligned.h>
+#include <linux/iio/trigger_consumer.h>
+#include <linux/iio/triggered_buffer.h>
+#include <linux/iio/trigger.h>
+#include <linux/iio/buffer.h>
+#include <linux/version.h>
+
+#include "st_ism330dhcx.h"
+
+#define ST_ISM330DHCX_REG_EMB_FUNC_STATUS_MAINPAGE		0x35
+#define ST_ISM330DHCX_REG_INT_STEP_DET_MASK		BIT(3)
+#define ST_ISM330DHCX_REG_INT_TILT_MASK			BIT(4)
+#define ST_ISM330DHCX_REG_INT_SIGMOT_MASK			BIT(5)
+#define ST_ISM330DHCX_REG_INT_GLANCE_MASK			BIT(0)
+#define ST_ISM330DHCX_REG_INT_MOTION_MASK			BIT(1)
+#define ST_ISM330DHCX_REG_INT_NO_MOTION_MASK		BIT(2)
+#define ST_ISM330DHCX_REG_INT_WAKEUP_MASK			BIT(3)
+#define ST_ISM330DHCX_REG_INT_PICKUP_MASK			BIT(4)
+#define ST_ISM330DHCX_REG_INT_ORIENTATION_MASK		BIT(5)
+#define ST_ISM330DHCX_REG_INT_WRIST_MASK			BIT(6)
+
+#define ST_ISM330DHCX_SAMPLE_DISCHARD			0x7ffd
+
+#define ST_ISM330DHCX_EWMA_LEVEL				120
+#define ST_ISM330DHCX_EWMA_DIV				128
+
+enum {
+	ST_ISM330DHCX_GYRO_TAG = 0x01,
+	ST_ISM330DHCX_ACC_TAG = 0x02,
+	ST_ISM330DHCX_TEMP_TAG = 0x03,
+	ST_ISM330DHCX_TS_TAG = 0x04,
+	ST_ISM330DHCX_EXT0_TAG = 0x0f,
+	ST_ISM330DHCX_EXT1_TAG = 0x10,
+	ST_ISM330DHCX_SC_TAG = 0x12,
+};
+
+/**
+ * Get Linux timestamp (SW)
+ *
+ * @return  timestamp in ns
+ */
+static inline s64 st_ism330dhcx_get_time_ns(struct st_ism330dhcx_hw *hw)
+{
+	return iio_get_time_ns(hw->iio_devs[ST_ISM330DHCX_ID_GYRO]);
+}
+
+/**
+ * Timestamp low pass filter
+ *
+ * @param  old: ST IMU MEMS hw instance
+ * @param  new: ST IMU MEMS hw instance
+ * @param  weight: ST IMU MEMS hw instance
+ * @return  estimation of the timestamp average
+ */
+static inline s64 st_ism330dhcx_ewma(s64 old, s64 new, int weight)
+{
+	s64 diff, incr;
+
+	diff = new - old;
+	incr = div_s64((ST_ISM330DHCX_EWMA_DIV - weight) * diff,
+			ST_ISM330DHCX_EWMA_DIV);
+
+	return old + incr;
+}
+
+/**
+ * Reset HW Timestamp counter and clear timestamp data structure
+ *
+ * @param  hw: ST IMU MEMS hw instance
+ * @return  < 0 if error, 0 otherwise
+ */
+inline int st_ism330dhcx_reset_hwts(struct st_ism330dhcx_hw *hw)
+{
+	u8 data = 0xaa;
+
+	hw->ts = st_ism330dhcx_get_time_ns(hw);
+	hw->ts_offset = hw->ts;
+	hw->val_ts_old = 0;
+	hw->hw_ts_high = 0;
+	hw->tsample = 0ull;
+
+	return st_ism330dhcx_write_atomic(hw, ST_ISM330DHCX_REG_TIMESTAMP2_ADDR,
+				       sizeof(data), &data);
+}
+
+/**
+ * Setting FIFO mode
+ *
+ * @param  hw: ST IMU MEMS hw instance
+ * @param  fifo_mode: ST_ISM330DHCX_FIFO_BYPASS or ST_ISM330DHCX_FIFO_CONT
+ * @return  0 FIFO configured accordingly, non zero otherwise
+ */
+int st_ism330dhcx_set_fifo_mode(struct st_ism330dhcx_hw *hw,
+			     enum st_ism330dhcx_fifo_mode fifo_mode)
+{
+	int err;
+
+	err = st_ism330dhcx_write_with_mask(hw, ST_ISM330DHCX_REG_FIFO_CTRL4_ADDR,
+					 ST_ISM330DHCX_REG_FIFO_MODE_MASK,
+					 fifo_mode);
+	if (err < 0)
+		return err;
+
+	hw->fifo_mode = fifo_mode;
+
+	return 0;
+}
+
+/**
+ * Setting sensor ODR in batching mode
+ *
+ * @param  sensor: ST IMU sensor instance
+ * @param  enable: enable or disable batching mode
+ * @return  0 FIFO configured accordingly, non zero otherwise
+ */
+int __st_ism330dhcx_set_sensor_batching_odr(struct st_ism330dhcx_sensor *sensor,
+					 bool enable)
+{
+	struct st_ism330dhcx_hw *hw = sensor->hw;
+	u8 data = 0;
+	int err;
+	int podr, puodr;
+
+	if (enable) {
+		err = st_ism330dhcx_get_odr_val(sensor->id, sensor->odr,
+					     sensor->uodr, &podr, &puodr,
+					     &data);
+		if (err < 0)
+			return err;
+	}
+
+	err = __st_ism330dhcx_write_with_mask(hw, sensor->batch_reg.addr,
+					   sensor->batch_reg.mask, data);
+	return err < 0 ? err : 0;
+}
+
+/**
+ * Setting timestamp ODR in batching mode
+ *
+ * @param  hw: ST IMU MEMS hw instance
+ * @return  Timestamp ODR
+ */
+static int st_ism330dhcx_ts_odr(struct st_ism330dhcx_hw *hw)
+{
+	struct st_ism330dhcx_sensor *sensor;
+	int odr = 0;
+	u8 i;
+
+	for (i = ST_ISM330DHCX_ID_GYRO; i <= ST_ISM330DHCX_ID_EXT1; i++) {
+		if (!hw->iio_devs[i])
+			continue;
+
+		sensor = iio_priv(hw->iio_devs[i]);
+		if (hw->enable_mask & BIT(sensor->id))
+			odr = max_t(int, odr, sensor->odr);
+	}
+
+	return odr;
+}
+
+/**
+ * Setting sensor ODR in batching mode
+ *
+ * @param  sensor: ST IMU sensor instance
+ * @param  enable: enable or disable batching mode
+ * @return  0 FIFO configured accordingly, non zero otherwise
+ */
+static inline int
+st_ism330dhcx_set_sensor_batching_odr(struct st_ism330dhcx_sensor *sensor,
+				   bool enable)
+{
+	struct st_ism330dhcx_hw *hw = sensor->hw;
+	int err;
+
+	mutex_lock(&hw->page_lock);
+	err = __st_ism330dhcx_set_sensor_batching_odr(sensor, enable);
+	mutex_unlock(&hw->page_lock);
+
+	return err;
+}
+
+/**
+ * Update watermark level in FIFO
+ *
+ * @param  sensor: ST IMU sensor instance
+ * @param  watermark: New watermark level
+ * @return  0 if FIFO configured, non zero for error
+ */
+int st_ism330dhcx_update_watermark(struct st_ism330dhcx_sensor *sensor,
+				u16 watermark)
+{
+	u16 fifo_watermark = ST_ISM330DHCX_MAX_FIFO_DEPTH, cur_watermark = 0;
+	struct st_ism330dhcx_hw *hw = sensor->hw;
+	struct st_ism330dhcx_sensor *cur_sensor;
+	__le16 wdata;
+	int i, err;
+	u8 data;
+
+	for (i = ST_ISM330DHCX_ID_GYRO; i <= ST_ISM330DHCX_ID_STEP_COUNTER; i++) {
+		if (!hw->iio_devs[i])
+			continue;
+
+		cur_sensor = iio_priv(hw->iio_devs[i]);
+
+		if (!(hw->enable_mask & BIT(cur_sensor->id)))
+			continue;
+
+		cur_watermark = (cur_sensor == sensor) ? watermark :
+							 cur_sensor->watermark;
+
+		fifo_watermark = min_t(u16, fifo_watermark, cur_watermark);
+	}
+
+	fifo_watermark = max_t(u16, fifo_watermark, 2);
+
+	mutex_lock(&hw->lock);
+
+	err = st_ism330dhcx_read_atomic(hw, ST_ISM330DHCX_REG_FIFO_CTRL1_ADDR + 1,
+				     sizeof(data), &data);
+	if (err < 0)
+		goto out;
+
+	fifo_watermark = ((data << 8) & ~ST_ISM330DHCX_REG_FIFO_WTM_MASK) |
+			 (fifo_watermark & ST_ISM330DHCX_REG_FIFO_WTM_MASK);
+	wdata = cpu_to_le16(fifo_watermark);
+	err = st_ism330dhcx_write_atomic(hw, ST_ISM330DHCX_REG_FIFO_CTRL1_ADDR,
+				      sizeof(wdata), (u8 *)&wdata);
+out:
+	mutex_unlock(&hw->lock);
+
+	return err < 0 ? err : 0;
+}
+
+/**
+ * Timestamp correlation finction
+ *
+ * @param  hw: ST IMU MEMS hw instance
+ * @param  ts: New timestamp
+ */
+static inline void st_ism330dhcx_sync_hw_ts(struct st_ism330dhcx_hw *hw, s64 ts)
+{
+	s64 delta = ts - hw->hw_ts;
+
+	hw->ts_offset = st_ism330dhcx_ewma(hw->ts_offset, delta,
+					ST_ISM330DHCX_EWMA_LEVEL);
+}
+
+/**
+ * Return the iio device structure based on FIFO TAG ID
+ *
+ * @param  hw: ST IMU MEMS hw instance
+ * @param  tag: FIFO sample TAG ID
+ * @return  0 if FIFO configured, non zero for error
+ */
+static struct
+iio_dev *st_ism330dhcx_get_iiodev_from_tag(struct st_ism330dhcx_hw *hw,
+					u8 tag)
+{
+	struct iio_dev *iio_dev;
+
+	switch (tag) {
+	case ST_ISM330DHCX_GYRO_TAG:
+		iio_dev = hw->iio_devs[ST_ISM330DHCX_ID_GYRO];
+		break;
+	case ST_ISM330DHCX_ACC_TAG:
+		iio_dev = hw->iio_devs[ST_ISM330DHCX_ID_ACC];
+		break;
+	case ST_ISM330DHCX_TEMP_TAG:
+		iio_dev = hw->iio_devs[ST_ISM330DHCX_ID_TEMP];
+		break;
+	case ST_ISM330DHCX_EXT0_TAG:
+		if (hw->enable_mask & BIT(ST_ISM330DHCX_ID_EXT0))
+			iio_dev = hw->iio_devs[ST_ISM330DHCX_ID_EXT0];
+		else
+			iio_dev = hw->iio_devs[ST_ISM330DHCX_ID_EXT1];
+		break;
+	case ST_ISM330DHCX_EXT1_TAG:
+		iio_dev = hw->iio_devs[ST_ISM330DHCX_ID_EXT1];
+		break;
+	case ST_ISM330DHCX_SC_TAG:
+		iio_dev = hw->iio_devs[ST_ISM330DHCX_ID_STEP_COUNTER];
+		break;
+	default:
+		iio_dev = NULL;
+		break;
+	}
+
+	return iio_dev;
+}
+
+/**
+ * Read all FIFO data stored after WTM FIFO irq fired interrupt
+ *
+ * @param hw: ST IMU MEMS hw instance
+ * @return Number of read bytes in FIFO or error if negative
+ */
+static int st_ism330dhcx_read_fifo(struct st_ism330dhcx_hw *hw)
+{
+	u8 iio_buf[ALIGN(ST_ISM330DHCX_SAMPLE_SIZE, sizeof(s64)) + sizeof(s64)];
+	/* acc + gyro + 2 ext + ts + sc */
+	u8 buf[6 * ST_ISM330DHCX_FIFO_SAMPLE_SIZE], tag, *ptr;
+	int i, err, word_len, fifo_len, read_len;
+	struct st_ism330dhcx_sensor *sensor;
+	struct iio_dev *iio_dev;
+	s64 ts_irq, hw_ts_old;
+	__le16 fifo_status;
+	u16 fifo_depth;
+	s16 drdymask;
+	u32 val;
+
+	ts_irq = hw->ts - hw->delta_ts;
+
+	err = st_ism330dhcx_read_atomic(hw, ST_ISM330DHCX_REG_FIFO_STATUS1_ADDR,
+				     sizeof(fifo_status), (u8 *)&fifo_status);
+	if (err < 0)
+		return err;
+
+	fifo_depth = le16_to_cpu(fifo_status) & ST_ISM330DHCX_REG_FIFO_STATUS_DIFF;
+	if (!fifo_depth)
+		return 0;
+
+	fifo_len = fifo_depth * ST_ISM330DHCX_FIFO_SAMPLE_SIZE;
+	read_len = 0;
+
+	while (read_len < fifo_len) {
+		word_len = min_t(int, fifo_len - read_len, sizeof(buf));
+		err = st_ism330dhcx_read_atomic(hw,
+					ST_ISM330DHCX_REG_FIFO_DATA_OUT_TAG_ADDR,
+					word_len, buf);
+		if (err < 0)
+			return err;
+
+		for (i = 0; i < word_len; i += ST_ISM330DHCX_FIFO_SAMPLE_SIZE) {
+			ptr = &buf[i + ST_ISM330DHCX_TAG_SIZE];
+			tag = buf[i] >> 3;
+
+			if (tag == ST_ISM330DHCX_TS_TAG) {
+				val = get_unaligned_le32(ptr);
+
+				if (hw->val_ts_old > val)
+					hw->hw_ts_high++;
+
+				hw_ts_old = hw->hw_ts;
+
+				/* check hw rollover */
+				hw->val_ts_old = val;
+				hw->hw_ts = (val +
+					     ((s64)hw->hw_ts_high << 32)) *
+					     hw->ts_delta_ns;
+				hw->ts_offset = st_ism330dhcx_ewma(hw->ts_offset,
+						ts_irq - hw->hw_ts,
+						ST_ISM330DHCX_EWMA_LEVEL);
+
+				if (!test_bit(ST_ISM330DHCX_HW_FLUSH, &hw->state))
+					/* sync ap timestamp and sensor one */
+					st_ism330dhcx_sync_hw_ts(hw, ts_irq);
+
+				ts_irq += hw->hw_ts;
+
+				if (!hw->tsample)
+					hw->tsample = hw->ts_offset + hw->hw_ts;
+				else
+					hw->tsample = hw->tsample +
+						      hw->hw_ts - hw_ts_old;
+			} else {
+				iio_dev =
+					st_ism330dhcx_get_iiodev_from_tag(hw, tag);
+				if (!iio_dev)
+					continue;
+
+				sensor = iio_priv(iio_dev);
+
+				/* skip samples if not ready */
+				drdymask =
+				      (s16)le16_to_cpu(get_unaligned_le16(ptr));
+				if (unlikely(drdymask >=
+						ST_ISM330DHCX_SAMPLE_DISCHARD)) {
+					continue;
+				}
+
+				/*
+				 * hw ts in not queued in FIFO if only step
+				 * counter enabled
+				 */
+				if (sensor->id == ST_ISM330DHCX_ID_STEP_COUNTER) {
+					val = get_unaligned_le32(ptr + 2);
+					hw->tsample = (val +
+						((s64)hw->hw_ts_high << 32)) *
+						hw->ts_delta_ns;
+				}
+
+				memcpy(iio_buf, ptr, ST_ISM330DHCX_SAMPLE_SIZE);
+
+				/* avoid samples in the future */
+				hw->tsample = min_t(s64,
+						    st_ism330dhcx_get_time_ns(hw),
+						    hw->tsample);
+
+				sensor->last_fifo_timestamp = hw->tsample;
+
+				/* support decimation for ODR < 12.5 Hz */
+				if (sensor->dec_counter > 0) {
+					sensor->dec_counter--;
+				} else {
+					sensor->dec_counter = sensor->decimator;
+					iio_push_to_buffers_with_timestamp(iio_dev,
+								   iio_buf,
+								   hw->tsample);
+				}
+			}
+		}
+		read_len += word_len;
+	}
+
+	return read_len;
+}
+
+/**
+ * Return the max FIFO watermark level accepted
+ *
+ * @param  dev: Linux Device
+ * @param  attr: Device Attribute
+ * @param  buf: User Buffer
+ * @return  Number of chars printed into the buffer
+ */
+ssize_t st_ism330dhcx_get_max_watermark(struct device *dev,
+				     struct device_attribute *attr,
+				     char *buf)
+{
+	struct iio_dev *iio_dev = dev_to_iio_dev(dev);
+	struct st_ism330dhcx_sensor *sensor = iio_priv(iio_dev);
+
+	return sprintf(buf, "%d\n", sensor->max_watermark);
+}
+
+/**
+ * Return the FIFO watermark level
+ *
+ * @param  dev: Linux Device
+ * @param  attr: Device Attribute
+ * @param  buf: User Buffer
+ * @return  Number of chars printed into the buffer
+ */
+ssize_t st_ism330dhcx_get_watermark(struct device *dev,
+				 struct device_attribute *attr,
+				 char *buf)
+{
+	struct iio_dev *iio_dev = dev_to_iio_dev(dev);
+	struct st_ism330dhcx_sensor *sensor = iio_priv(iio_dev);
+
+	return sprintf(buf, "%d\n", sensor->watermark);
+}
+
+/**
+ * Set the FIFO watermark level
+ *
+ * @param  dev: Linux Device
+ * @param  attr: Device Attribute
+ * @param  buf: User Buffer
+ * @param  size: New FIFO watermark level
+ * @return  Watermark level if >= 0, error otherwise
+ */
+ssize_t st_ism330dhcx_set_watermark(struct device *dev,
+				 struct device_attribute *attr,
+				 const char *buf, size_t size)
+{
+	struct iio_dev *iio_dev = dev_to_iio_dev(dev);
+	struct st_ism330dhcx_sensor *sensor = iio_priv(iio_dev);
+	int err, val;
+
+	mutex_lock(&iio_dev->mlock);
+	if (iio_buffer_enabled(iio_dev)) {
+		err = -EBUSY;
+		goto out;
+	}
+
+	err = kstrtoint(buf, 10, &val);
+	if (err < 0)
+		goto out;
+
+	err = st_ism330dhcx_update_watermark(sensor, val);
+	if (err < 0)
+		goto out;
+
+	sensor->watermark = val;
+
+out:
+	mutex_unlock(&iio_dev->mlock);
+
+	return err < 0 ? err : size;
+}
+
+/**
+ * Flush internal HW FIFO
+ *
+ * @param  dev: Linux Device
+ * @param  attr: Device Attribute
+ * @param  buf: User Buffer
+ * @param  size: unused
+ * @return  Watermark level if >= 0, error otherwise
+ */
+ssize_t st_ism330dhcx_flush_fifo(struct device *dev,
+			      struct device_attribute *attr,
+			      const char *buf, size_t size)
+{
+	struct iio_dev *iio_dev = dev_to_iio_dev(dev);
+	struct st_ism330dhcx_sensor *sensor = iio_priv(iio_dev);
+	struct st_ism330dhcx_hw *hw = sensor->hw;
+	s64 type;
+	s64 event;
+	int count;
+	s64 fts;
+	s64 ts;
+
+	mutex_lock(&hw->fifo_lock);
+	ts = st_ism330dhcx_get_time_ns(hw);
+	hw->delta_ts = ts - hw->ts;
+	hw->ts = ts;
+	set_bit(ST_ISM330DHCX_HW_FLUSH, &hw->state);
+	count = st_ism330dhcx_read_fifo(hw);
+	sensor->dec_counter = 0;
+	mutex_unlock(&hw->fifo_lock);
+	if (count > 0)
+		fts = sensor->last_fifo_timestamp;
+	else
+		fts = ts;
+
+	type = count > 0 ? STM_IIO_EV_DIR_FIFO_DATA : STM_IIO_EV_DIR_FIFO_EMPTY;
+	event = IIO_UNMOD_EVENT_CODE(iio_dev->channels[0].type, -1,
+				     STM_IIO_EV_TYPE_FIFO_FLUSH, type);
+	iio_push_event(iio_dev, event, fts);
+
+	return size;
+}
+
+/**
+ * Empty FIFO and set HW FIFO in Bypass mode
+ *
+ * @param  hw: ST IMU MEMS hw instance
+ * @return  Watermark level if >= 0, error otherwise
+ */
+int st_ism330dhcx_suspend_fifo(struct st_ism330dhcx_hw *hw)
+{
+	int err;
+
+	mutex_lock(&hw->fifo_lock);
+	st_ism330dhcx_read_fifo(hw);
+	err = st_ism330dhcx_set_fifo_mode(hw, ST_ISM330DHCX_FIFO_BYPASS);
+	mutex_unlock(&hw->fifo_lock);
+
+	return err;
+}
+
+/**
+ * Update ODR batching in FIFO and Timestamp
+ *
+ * @param  iio_dev: Linux IIO device
+ * @param  enable: enable/disable batcing in FIFO
+ * @return  < 0 if error, 0 otherwise
+ */
+int st_ism330dhcx_update_batching(struct iio_dev *iio_dev, bool enable)
+{
+	struct st_ism330dhcx_sensor *sensor = iio_priv(iio_dev);
+	struct st_ism330dhcx_hw *hw = sensor->hw;
+	int err;
+
+	disable_irq(hw->irq);
+
+	err = st_ism330dhcx_set_sensor_batching_odr(sensor, enable);
+	if (err < 0)
+		goto out;
+
+	/* Calc TS ODR */
+	hw->odr = st_ism330dhcx_ts_odr(hw);
+
+out:
+	enable_irq(hw->irq);
+
+	return err;
+}
+
+/**
+ * Update FIFO watermark value based to the enabled sensors
+ *
+ * @param  iio_dev: Linux IIO device
+ * @param  enable: enable/disable batcing in FIFO
+ * @return  < 0 if error, 0 otherwise
+ */
+static int st_ism330dhcx_update_fifo(struct iio_dev *iio_dev, bool enable)
+{
+	struct st_ism330dhcx_sensor *sensor = iio_priv(iio_dev);
+	struct st_ism330dhcx_hw *hw = sensor->hw;
+	int err;
+	int podr, puodr;
+
+	disable_irq(hw->irq);
+
+	if (sensor->id == ST_ISM330DHCX_ID_EXT0 ||
+	    sensor->id == ST_ISM330DHCX_ID_EXT1) {
+		err = st_ism330dhcx_shub_set_enable(sensor, enable);
+		if (err < 0)
+			goto out;
+	} else {
+		if (sensor->id == ST_ISM330DHCX_ID_STEP_COUNTER) {
+			err = st_ism330dhcx_step_counter_set_enable(sensor,
+								 enable);
+			if (err < 0)
+				goto out;
+		} else {
+			err = st_ism330dhcx_sensor_set_enable(sensor, enable);
+			if (err < 0)
+				goto out;
+
+			err = st_ism330dhcx_set_sensor_batching_odr(sensor,
+								 enable);
+			if (err < 0)
+				goto out;
+		}
+	}
+
+	/*
+	 * this is an auxiliary sensor, it need to get batched
+	 * toghether at least with a primary sensor (Acc/Gyro)
+	 */
+	if (sensor->id == ST_ISM330DHCX_ID_TEMP) {
+		if (!(hw->enable_mask & (BIT(ST_ISM330DHCX_ID_ACC) |
+					 BIT(ST_ISM330DHCX_ID_GYRO)))) {
+			struct st_ism330dhcx_sensor *acc_sensor;
+			u8 data = 0;
+
+			acc_sensor = iio_priv(hw->iio_devs[ST_ISM330DHCX_ID_ACC]);
+			if (enable) {
+				err = st_ism330dhcx_get_odr_val(ST_ISM330DHCX_ID_ACC,
+						sensor->odr, sensor->uodr,
+						&podr, &puodr, &data);
+				if (err < 0)
+					goto out;
+			}
+
+			err = st_ism330dhcx_write_with_mask(hw,
+					acc_sensor->batch_reg.addr,
+					acc_sensor->batch_reg.mask,
+					data);
+			if (err < 0)
+				goto out;
+		}
+	}
+
+	err = st_ism330dhcx_update_watermark(sensor, sensor->watermark);
+	if (err < 0)
+		goto out;
+
+	/* Calc TS ODR */
+	hw->odr = st_ism330dhcx_ts_odr(hw);
+
+	if (enable && hw->fifo_mode == ST_ISM330DHCX_FIFO_BYPASS) {
+		st_ism330dhcx_reset_hwts(hw);
+		err = st_ism330dhcx_set_fifo_mode(hw, ST_ISM330DHCX_FIFO_CONT);
+	} else if (!hw->enable_mask) {
+		err = st_ism330dhcx_set_fifo_mode(hw, ST_ISM330DHCX_FIFO_BYPASS);
+	}
+
+out:
+	enable_irq(hw->irq);
+
+	return err;
+}
+
+/**
+ * Bottom handler for FSM Orientation sensor event generation
+ *
+ * @param  irq: IIO trigger irq number
+ * @param  p: iio poll function environment
+ * @return  IRQ_HANDLED or < 0 for error
+ */
+static irqreturn_t st_ism330dhcx_buffer_handler_thread(int irq, void *p)
+{
+	struct iio_poll_func *pf = p;
+	struct iio_dev *iio_dev = pf->indio_dev;
+	struct st_ism330dhcx_sensor *sensor = iio_priv(iio_dev);
+	u8 buffer[sizeof(u8) + sizeof(s64)];
+	int err;
+
+	err = st_ism330dhcx_fsm_get_orientation(sensor->hw, buffer);
+	if (err < 0)
+		goto out;
+
+	iio_push_to_buffers_with_timestamp(iio_dev, buffer,
+					   st_ism330dhcx_get_time_ns(sensor->hw));
+out:
+	iio_trigger_notify_done(sensor->trig);
+
+	return IRQ_HANDLED;
+}
+
+/**
+ * Top handler for sensor event generation + FIFO management
+ *
+ * @param  irq: IIO trigger irq number
+ * @param  private: iio poll function environment
+ * @return  IRQ_HANDLED or < 0 for error
+ */
+static irqreturn_t st_ism330dhcx_handler_irq(int irq, void *private)
+{
+	struct st_ism330dhcx_hw *hw = (struct st_ism330dhcx_hw *)private;
+	s64 ts = st_ism330dhcx_get_time_ns(hw);
+
+	hw->delta_ts = ts - hw->ts;
+	hw->ts = ts;
+
+	return IRQ_WAKE_THREAD;
+}
+
+/**
+ * Bottom handler for sensor event generation + FIFO management
+ *
+ * @param  irq: irq line number
+ * @param  private: device private environment pointer
+ * @return  IRQ_HANDLED or < 0 for error
+ */
+static irqreturn_t st_ism330dhcx_handler_thread(int irq, void *private)
+{
+	struct st_ism330dhcx_hw *hw = (struct st_ism330dhcx_hw *)private;
+
+	mutex_lock(&hw->fifo_lock);
+	st_ism330dhcx_read_fifo(hw);
+	clear_bit(ST_ISM330DHCX_HW_FLUSH, &hw->state);
+	mutex_unlock(&hw->fifo_lock);
+
+	if (hw->enable_mask & (BIT(ST_ISM330DHCX_ID_STEP_DETECTOR) |
+			       BIT(ST_ISM330DHCX_ID_SIGN_MOTION) |
+			       BIT(ST_ISM330DHCX_ID_TILT) |
+			       BIT(ST_ISM330DHCX_ID_MOTION) |
+			       BIT(ST_ISM330DHCX_ID_NO_MOTION) |
+			       BIT(ST_ISM330DHCX_ID_WAKEUP) |
+			       BIT(ST_ISM330DHCX_ID_PICKUP) |
+			       BIT(ST_ISM330DHCX_ID_ORIENTATION) |
+			       BIT(ST_ISM330DHCX_ID_WRIST_TILT) |
+			       BIT(ST_ISM330DHCX_ID_GLANCE))) {
+		struct iio_dev *iio_dev;
+		u8 status[3];
+		s64 event;
+		int err;
+
+		err = hw->tf->read(hw->dev,
+				   ST_ISM330DHCX_REG_EMB_FUNC_STATUS_MAINPAGE,
+				   sizeof(status), status);
+		if (err < 0)
+			return IRQ_HANDLED;
+
+		/* embedded function sensors */
+		if (status[0] & ST_ISM330DHCX_REG_INT_STEP_DET_MASK) {
+			iio_dev = hw->iio_devs[ST_ISM330DHCX_ID_STEP_DETECTOR];
+			event = IIO_UNMOD_EVENT_CODE(IIO_STEPS, -1,
+						     IIO_EV_TYPE_THRESH,
+						     IIO_EV_DIR_RISING);
+			iio_push_event(iio_dev, event,
+				       st_ism330dhcx_get_time_ns(hw));
+		}
+		if (status[0] & ST_ISM330DHCX_REG_INT_SIGMOT_MASK) {
+			iio_dev = hw->iio_devs[ST_ISM330DHCX_ID_SIGN_MOTION];
+			event = IIO_UNMOD_EVENT_CODE(STM_IIO_SIGN_MOTION, -1,
+						     IIO_EV_TYPE_THRESH,
+						     IIO_EV_DIR_RISING);
+			iio_push_event(iio_dev, event,
+				       st_ism330dhcx_get_time_ns(hw));
+		}
+		if (status[0] & ST_ISM330DHCX_REG_INT_TILT_MASK) {
+			iio_dev = hw->iio_devs[ST_ISM330DHCX_ID_TILT];
+			event = IIO_UNMOD_EVENT_CODE(STM_IIO_TILT, -1,
+						     IIO_EV_TYPE_THRESH,
+						     IIO_EV_DIR_RISING);
+			iio_push_event(iio_dev, event,
+				       st_ism330dhcx_get_time_ns(hw));
+		}
+		/*  fsm sensors */
+		if (status[1] & ST_ISM330DHCX_REG_INT_GLANCE_MASK) {
+			iio_dev = hw->iio_devs[ST_ISM330DHCX_ID_GLANCE];
+			event = IIO_UNMOD_EVENT_CODE(STM_IIO_GESTURE, -1,
+						     IIO_EV_TYPE_THRESH,
+						     IIO_EV_DIR_RISING);
+			iio_push_event(iio_dev, event,
+				       st_ism330dhcx_get_time_ns(hw));
+		}
+		if (status[1] & ST_ISM330DHCX_REG_INT_MOTION_MASK) {
+			iio_dev = hw->iio_devs[ST_ISM330DHCX_ID_MOTION];
+			event = IIO_UNMOD_EVENT_CODE(STM_IIO_GESTURE, -1,
+						     IIO_EV_TYPE_THRESH,
+						     IIO_EV_DIR_RISING);
+			iio_push_event(iio_dev, event,
+				       st_ism330dhcx_get_time_ns(hw));
+		}
+		if (status[1] & ST_ISM330DHCX_REG_INT_NO_MOTION_MASK) {
+			iio_dev = hw->iio_devs[ST_ISM330DHCX_ID_NO_MOTION];
+			event = IIO_UNMOD_EVENT_CODE(STM_IIO_GESTURE, -1,
+						     IIO_EV_TYPE_THRESH,
+						     IIO_EV_DIR_RISING);
+			iio_push_event(iio_dev, event,
+				       st_ism330dhcx_get_time_ns(hw));
+		}
+		if (status[1] & ST_ISM330DHCX_REG_INT_WAKEUP_MASK) {
+			iio_dev = hw->iio_devs[ST_ISM330DHCX_ID_WAKEUP];
+			event = IIO_UNMOD_EVENT_CODE(STM_IIO_GESTURE, -1,
+						     IIO_EV_TYPE_THRESH,
+						     IIO_EV_DIR_RISING);
+			iio_push_event(iio_dev, event,
+				       st_ism330dhcx_get_time_ns(hw));
+		}
+		if (status[1] & ST_ISM330DHCX_REG_INT_PICKUP_MASK) {
+			iio_dev = hw->iio_devs[ST_ISM330DHCX_ID_PICKUP];
+			event = IIO_UNMOD_EVENT_CODE(STM_IIO_GESTURE, -1,
+						     IIO_EV_TYPE_THRESH,
+						     IIO_EV_DIR_RISING);
+			iio_push_event(iio_dev, event,
+				       st_ism330dhcx_get_time_ns(hw));
+		}
+		if (status[1] & ST_ISM330DHCX_REG_INT_ORIENTATION_MASK) {
+			struct st_ism330dhcx_sensor *sensor;
+
+			iio_dev = hw->iio_devs[ST_ISM330DHCX_ID_ORIENTATION];
+			sensor = iio_priv(iio_dev);
+			iio_trigger_poll_chained(sensor->trig);
+		}
+		if (status[1] & ST_ISM330DHCX_REG_INT_WRIST_MASK) {
+			iio_dev = hw->iio_devs[ST_ISM330DHCX_ID_WRIST_TILT];
+			event = IIO_UNMOD_EVENT_CODE(STM_IIO_GESTURE, -1,
+						     IIO_EV_TYPE_THRESH,
+						     IIO_EV_DIR_RISING);
+			iio_push_event(iio_dev, event,
+				       st_ism330dhcx_get_time_ns(hw));
+		}
+	}
+
+	return IRQ_HANDLED;
+}
+
+/**
+ * IIO fifo pre enabled callback function
+ *
+ * @param  iio_dev: IIO device
+ * @return  < 0 if error, 0 otherwise
+ */
+static int st_ism330dhcx_fifo_preenable(struct iio_dev *iio_dev)
+{
+	return st_ism330dhcx_update_fifo(iio_dev, true);
+}
+
+/**
+ * IIO fifo post disable callback function
+ *
+ * @param  iio_dev: IIO device
+ * @return  < 0 if error, 0 otherwise
+ */
+static int st_ism330dhcx_fifo_postdisable(struct iio_dev *iio_dev)
+{
+	return st_ism330dhcx_update_fifo(iio_dev, false);
+}
+
+/**
+ * IIO fifo callback registruction structure
+ */
+static const struct iio_buffer_setup_ops st_ism330dhcx_fifo_ops = {
+	.preenable = st_ism330dhcx_fifo_preenable,
+	.postdisable = st_ism330dhcx_fifo_postdisable,
+};
+
+/**
+ * Enable HW FIFO
+ *
+ * @param  hw: ST IMU MEMS hw instance
+ * @return  < 0 if error, 0 otherwise
+ */
+static int st_ism330dhcx_fifo_init(struct st_ism330dhcx_hw *hw)
+{
+	return st_ism330dhcx_write_with_mask(hw,
+					  ST_ISM330DHCX_REG_FIFO_CTRL4_ADDR,
+					  ST_ISM330DHCX_REG_DEC_TS_MASK, 1);
+}
+
+static const struct iio_trigger_ops st_ism330dhcx_trigger_ops = {
+	NULL
+};
+
+static int st_ism330dhcx_buffer_preenable(struct iio_dev *iio_dev)
+{
+	return st_ism330dhcx_embfunc_sensor_set_enable(iio_priv(iio_dev), true);
+}
+
+static int st_ism330dhcx_buffer_postdisable(struct iio_dev *iio_dev)
+{
+	return st_ism330dhcx_embfunc_sensor_set_enable(iio_priv(iio_dev), false);
+}
+
+static const struct iio_buffer_setup_ops st_ism330dhcx_buffer_ops = {
+	.preenable = st_ism330dhcx_buffer_preenable,
+	.postdisable = st_ism330dhcx_buffer_postdisable,
+};
+
+/**
+ * Init IIO buffers and triggers
+ *
+ * @param  hw: ST IMU MEMS hw instance
+ * @return  < 0 if error, 0 otherwise
+ */
+int st_ism330dhcx_buffers_setup(struct st_ism330dhcx_hw *hw)
+{
+	struct device_node *np = hw->dev->of_node;
+	struct st_ism330dhcx_sensor *sensor;
+#if KERNEL_VERSION(5, 13, 0) > LINUX_VERSION_CODE
+	struct iio_buffer *buffer;
+#endif /* LINUX_VERSION_CODE */
+	struct iio_dev *iio_dev;
+	unsigned long irq_type;
+	bool irq_active_low;
+	int i, err;
+
+	irq_type = irqd_get_trigger_type(irq_get_irq_data(hw->irq));
+	if (irq_type == IRQF_TRIGGER_NONE)
+		irq_type = IRQF_TRIGGER_HIGH;
+
+	switch (irq_type) {
+	case IRQF_TRIGGER_HIGH:
+	case IRQF_TRIGGER_RISING:
+		irq_active_low = false;
+		break;
+	case IRQF_TRIGGER_LOW:
+	case IRQF_TRIGGER_FALLING:
+		irq_active_low = true;
+		break;
+	default:
+		dev_info(hw->dev, "mode %lx unsupported\n", irq_type);
+		return -EINVAL;
+	}
+
+	err = st_ism330dhcx_write_with_mask(hw, ST_ISM330DHCX_REG_CTRL3_C_ADDR,
+					 ST_ISM330DHCX_REG_H_LACTIVE_MASK,
+					 irq_active_low);
+	if (err < 0)
+		return err;
+
+	if (np && of_property_read_bool(np, "drive-open-drain")) {
+		err = st_ism330dhcx_write_with_mask(hw,
+						 ST_ISM330DHCX_REG_CTRL3_C_ADDR,
+						 ST_ISM330DHCX_REG_PP_OD_MASK, 1);
+		if (err < 0)
+			return err;
+
+		irq_type |= IRQF_SHARED;
+	}
+
+	err = devm_request_threaded_irq(hw->dev, hw->irq,
+					st_ism330dhcx_handler_irq,
+					st_ism330dhcx_handler_thread,
+					irq_type | IRQF_ONESHOT,
+					"ism330dhcx", hw);
+	if (err) {
+		dev_err(hw->dev, "failed to request trigger irq %d\n",
+			hw->irq);
+		return err;
+	}
+
+	for (i = ST_ISM330DHCX_ID_GYRO; i <= ST_ISM330DHCX_ID_STEP_COUNTER; i++) {
+		if (!hw->iio_devs[i])
+			continue;
+
+#if KERNEL_VERSION(5, 19, 0) <= LINUX_VERSION_CODE
+		err = devm_iio_kfifo_buffer_setup(hw->dev, hw->iio_devs[i],
+						  &st_ism330dhcx_fifo_ops);
+		if (err)
+			return err;
+#elif KERNEL_VERSION(5, 13, 0) <= LINUX_VERSION_CODE
+		err = devm_iio_kfifo_buffer_setup(hw->dev, hw->iio_devs[i],
+						  INDIO_BUFFER_SOFTWARE,
+						  &st_ism330dhcx_fifo_ops);
+		if (err)
+			return err;
+#else /* LINUX_VERSION_CODE */
+		buffer = devm_iio_kfifo_allocate(hw->dev);
+		if (!buffer)
+			return -ENOMEM;
+
+		iio_device_attach_buffer(hw->iio_devs[i], buffer);
+		hw->iio_devs[i]->modes |= INDIO_BUFFER_SOFTWARE;
+		hw->iio_devs[i]->setup_ops = &st_ism330dhcx_fifo_ops;
+#endif /* LINUX_VERSION_CODE */
+
+	}
+
+	err = st_ism330dhcx_fifo_init(hw);
+	if (err < 0)
+		return err;
+
+	iio_dev = hw->iio_devs[ST_ISM330DHCX_ID_ORIENTATION];
+	sensor = iio_priv(iio_dev);
+
+	err = devm_iio_triggered_buffer_setup(hw->dev, iio_dev,
+				NULL, st_ism330dhcx_buffer_handler_thread,
+				&st_ism330dhcx_buffer_ops);
+	if (err < 0)
+		return err;
+
+	sensor->trig = devm_iio_trigger_alloc(hw->dev, "%s-trigger",
+					      iio_dev->name);
+	if (!sensor->trig)
+		return -ENOMEM;
+
+	iio_trigger_set_drvdata(sensor->trig, iio_dev);
+	sensor->trig->ops = &st_ism330dhcx_trigger_ops;
+	sensor->trig->dev.parent = hw->dev;
+
+	err = devm_iio_trigger_register(hw->dev, sensor->trig);
+	if (err < 0) {
+		dev_err(hw->dev, "failed to register iio trigger.\n");
+
+		return err;
+	}
+
+	iio_dev->trig = iio_trigger_get(sensor->trig);
+
+	return 0;
+}
diff --git a/drivers/iio/stm/imu/st_ism330dhcx/st_ism330dhcx_core.c b/drivers/iio/stm/imu/st_ism330dhcx/st_ism330dhcx_core.c
new file mode 100644
index 000000000..ecba2409d
--- /dev/null
+++ b/drivers/iio/stm/imu/st_ism330dhcx/st_ism330dhcx_core.c
@@ -0,0 +1,1912 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * STMicroelectronics st_ism330dhcx sensor driver
+ *
+ * MEMS Software Solutions Team
+ *
+ * Copyright 2020 STMicroelectronics Inc.
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/iio/iio.h>
+#include <linux/iio/sysfs.h>
+#include <linux/interrupt.h>
+#include <linux/pm.h>
+#include <linux/property.h>
+
+#include <linux/platform_data/st_sensors_pdata.h>
+
+#include "st_ism330dhcx.h"
+
+static struct st_ism330dhcx_suspend_resume_entry
+	st_ism330dhcx_suspend_resume[ST_ISM330DHCX_SUSPEND_RESUME_REGS] = {
+		[ST_ISM330DHCX_CTRL1_XL_REG] = {
+			.addr = ST_ISM330DHCX_CTRL1_XL_ADDR,
+			.mask = GENMASK(3, 2),
+		},
+		[ST_ISM330DHCX_CTRL2_G_REG] = {
+			.addr = ST_ISM330DHCX_CTRL2_G_ADDR,
+			.mask = GENMASK(3, 2),
+		},
+		[ST_ISM330DHCX_REG_CTRL3_C_REG] = {
+			.addr = ST_ISM330DHCX_REG_CTRL3_C_ADDR,
+			.mask = ST_ISM330DHCX_REG_BDU_MASK       |
+				ST_ISM330DHCX_REG_PP_OD_MASK     |
+				ST_ISM330DHCX_REG_H_LACTIVE_MASK,
+		},
+		[ST_ISM330DHCX_REG_CTRL4_C_REG] = {
+			.addr = ST_ISM330DHCX_REG_CTRL4_C_ADDR,
+			.mask = ST_ISM330DHCX_REG_DRDY_MASK,
+		},
+		[ST_ISM330DHCX_REG_CTRL5_C_REG] = {
+			.addr = ST_ISM330DHCX_REG_CTRL5_C_ADDR,
+			.mask = ST_ISM330DHCX_REG_ROUNDING_MASK,
+		},
+		[ST_ISM330DHCX_REG_CTRL10_C_REG] = {
+			.addr = ST_ISM330DHCX_REG_CTRL10_C_ADDR,
+			.mask = ST_ISM330DHCX_REG_TIMESTAMP_EN_MASK,
+		},
+		[ST_ISM330DHCX_REG_TAP_CFG0_REG] = {
+			.addr = ST_ISM330DHCX_REG_TAP_CFG0_ADDR,
+			.mask = ST_ISM330DHCX_REG_LIR_MASK,
+		},
+		[ST_ISM330DHCX_REG_INT1_CTRL_REG] = {
+			.addr = ST_ISM330DHCX_REG_INT1_CTRL_ADDR,
+			.mask = ST_ISM330DHCX_REG_INT_FIFO_TH_MASK,
+		},
+		[ST_ISM330DHCX_REG_INT2_CTRL_REG] = {
+			.addr = ST_ISM330DHCX_REG_INT2_CTRL_ADDR,
+			.mask = ST_ISM330DHCX_REG_INT_FIFO_TH_MASK,
+		},
+		[ST_ISM330DHCX_REG_FIFO_CTRL1_REG] = {
+			.addr = ST_ISM330DHCX_REG_FIFO_CTRL1_ADDR,
+			.mask = GENMASK(7, 0),
+		},
+		[ST_ISM330DHCX_REG_FIFO_CTRL2_REG] = {
+			.addr = ST_ISM330DHCX_REG_FIFO_CTRL2_ADDR,
+			.mask = ST_ISM330DHCX_REG_FIFO_WTM8_MASK,
+		},
+		[ST_ISM330DHCX_REG_FIFO_CTRL3_REG] = {
+			.addr = ST_ISM330DHCX_REG_FIFO_CTRL3_ADDR,
+			.mask = ST_ISM330DHCX_REG_BDR_XL_MASK |
+				ST_ISM330DHCX_REG_BDR_GY_MASK,
+		},
+		[ST_ISM330DHCX_REG_FIFO_CTRL4_REG] = {
+			.addr = ST_ISM330DHCX_REG_FIFO_CTRL4_ADDR,
+			.mask = ST_ISM330DHCX_REG_DEC_TS_MASK |
+				ST_ISM330DHCX_REG_ODR_T_BATCH_MASK,
+		},
+	};
+
+/**
+ * List of supported ODR
+ *
+ * The following table is complete list of supported ODR by Acc, Gyro and Temp
+ * sensors. ODR value can be also decimal (i.e 12.5 Hz)
+ */
+static const struct st_ism330dhcx_odr_table_entry st_ism330dhcx_odr_table[] = {
+	[ST_ISM330DHCX_ID_ACC] = {
+		.odr_size = 8,
+		.reg = {
+			.addr = ST_ISM330DHCX_CTRL1_XL_ADDR,
+			.mask = GENMASK(7, 4),
+		},
+		.odr_avl[0] = {   0, 0,       0x00 },
+		.odr_avl[1] = {  12, 500000,  0x01 },
+		.odr_avl[2] = {  26, 0,       0x02 },
+		.odr_avl[3] = {  52, 0,       0x03 },
+		.odr_avl[4] = { 104, 0,       0x04 },
+		.odr_avl[5] = { 208, 0,       0x05 },
+		.odr_avl[6] = { 416, 0,       0x06 },
+		.odr_avl[7] = { 833, 0,       0x07 },
+	},
+	[ST_ISM330DHCX_ID_GYRO] = {
+		.odr_size = 8,
+		.reg = {
+			.addr = ST_ISM330DHCX_CTRL2_G_ADDR,
+			.mask = GENMASK(7, 4),
+		},
+		.odr_avl[0] = {   0, 0,       0x00 },
+		.odr_avl[1] = {  12, 500000,  0x01 },
+		.odr_avl[2] = {  26, 0,       0x02 },
+		.odr_avl[3] = {  52, 0,       0x03 },
+		.odr_avl[4] = { 104, 0,       0x04 },
+		.odr_avl[5] = { 208, 0,       0x05 },
+		.odr_avl[6] = { 416, 0,       0x06 },
+		.odr_avl[7] = { 833, 0,       0x07 },
+	},
+	[ST_ISM330DHCX_ID_TEMP] = {
+		.odr_size = 2,
+		.odr_avl[0] = {  0, 0,        0x00 },
+		.odr_avl[1] = { 12, 500000,   0x02 },
+	},
+};
+
+/**
+ * List of supported Full Scale Value
+ *
+ * The following table is complete list of supported Full Scale by Acc, Gyro
+ * and Temp sensors.
+ */
+static const struct st_ism330dhcx_fs_table_entry st_ism330dhcx_fs_table[] = {
+	[ST_ISM330DHCX_ID_ACC] = {
+		.size = ST_ISM330DHCX_FS_ACC_LIST_SIZE,
+		.fs_avl[0] = {
+			.reg = {
+				.addr = ST_ISM330DHCX_CTRL1_XL_ADDR,
+				.mask = GENMASK(3, 2),
+			},
+			.gain = ST_ISM330DHCX_ACC_FS_2G_GAIN,
+			.val = 0x0,
+		},
+		.fs_avl[1] = {
+			.reg = {
+				.addr = ST_ISM330DHCX_CTRL1_XL_ADDR,
+				.mask = GENMASK(3, 2),
+			},
+			.gain = ST_ISM330DHCX_ACC_FS_4G_GAIN,
+			.val = 0x2,
+		},
+		.fs_avl[2] = {
+			.reg = {
+				.addr = ST_ISM330DHCX_CTRL1_XL_ADDR,
+				.mask = GENMASK(3, 2),
+			},
+			.gain = ST_ISM330DHCX_ACC_FS_8G_GAIN,
+			.val = 0x3,
+		},
+		.fs_avl[3] = {
+			.reg = {
+				.addr = ST_ISM330DHCX_CTRL1_XL_ADDR,
+				.mask = GENMASK(3, 2),
+			},
+			.gain = ST_ISM330DHCX_ACC_FS_16G_GAIN,
+			.val = 0x1,
+		},
+	},
+	[ST_ISM330DHCX_ID_GYRO] = {
+		.size = ST_ISM330DHCX_FS_GYRO_LIST_SIZE,
+		.fs_avl[0] = {
+			.reg = {
+				.addr = ST_ISM330DHCX_CTRL2_G_ADDR,
+				.mask = GENMASK(3, 0),
+			},
+			.gain = ST_ISM330DHCX_GYRO_FS_250_GAIN,
+			.val = 0x0,
+		},
+		.fs_avl[1] = {
+			.reg = {
+				.addr = ST_ISM330DHCX_CTRL2_G_ADDR,
+				.mask = GENMASK(3, 0),
+			},
+			.gain = ST_ISM330DHCX_GYRO_FS_500_GAIN,
+			.val = 0x4,
+		},
+		.fs_avl[2] = {
+			.reg = {
+				.addr = ST_ISM330DHCX_CTRL2_G_ADDR,
+				.mask = GENMASK(3, 0),
+			},
+			.gain = ST_ISM330DHCX_GYRO_FS_1000_GAIN,
+			.val = 0x8,
+		},
+		.fs_avl[3] = {
+			.reg = {
+				.addr = ST_ISM330DHCX_CTRL2_G_ADDR,
+				.mask = GENMASK(3, 0),
+			},
+			.gain = ST_ISM330DHCX_GYRO_FS_2000_GAIN,
+			.val = 0x0C,
+		},
+		.fs_avl[4] = {
+			.reg = {
+				.addr = ST_ISM330DHCX_CTRL2_G_ADDR,
+				.mask = GENMASK(3, 0),
+			},
+			.gain = ST_ISM330DHCX_GYRO_FS_4000_GAIN,
+			.val = 0x1,
+		},
+	},
+	[ST_ISM330DHCX_ID_TEMP] = {
+		.size = ST_ISM330DHCX_FS_TEMP_LIST_SIZE,
+		.fs_avl[0] = {
+			.reg = { 0 },
+			.gain = ST_ISM330DHCX_TEMP_FS_GAIN,
+			.val = 0x0
+		},
+	},
+};
+
+/**
+ * Accelerometer IIO channels description
+ *
+ * Accelerometer exports to IIO framework the following data channels:
+ * X Axis (16 bit signed in little endian)
+ * Y Axis (16 bit signed in little endian)
+ * Z Axis (16 bit signed in little endian)
+ * Timestamp (64 bit signed in little endian)
+ * Accelerometer exports to IIO framework the following event channels:
+ * Flush event done
+ */
+static const struct iio_chan_spec st_ism330dhcx_acc_channels[] = {
+	ST_ISM330DHCX_DATA_CHANNEL(IIO_ACCEL, ST_ISM330DHCX_REG_OUTX_L_A_ADDR,
+				1, IIO_MOD_X, 0, 16, 16, 's'),
+	ST_ISM330DHCX_DATA_CHANNEL(IIO_ACCEL, ST_ISM330DHCX_REG_OUTY_L_A_ADDR,
+				1, IIO_MOD_Y, 1, 16, 16, 's'),
+	ST_ISM330DHCX_DATA_CHANNEL(IIO_ACCEL, ST_ISM330DHCX_REG_OUTZ_L_A_ADDR,
+				1, IIO_MOD_Z, 2, 16, 16, 's'),
+	ST_ISM330DHCX_EVENT_CHANNEL(IIO_ACCEL, flush),
+	IIO_CHAN_SOFT_TIMESTAMP(3),
+};
+
+/**
+ * Gyro IIO channels description
+ *
+ * Gyro exports to IIO framework the following data channels:
+ * X Axis (16 bit signed in little endian)
+ * Y Axis (16 bit signed in little endian)
+ * Z Axis (16 bit signed in little endian)
+ * Timestamp (64 bit signed in little endian)
+ * Gyro exports to IIO framework the following event channels:
+ * Flush event done
+ */
+static const struct iio_chan_spec st_ism330dhcx_gyro_channels[] = {
+	ST_ISM330DHCX_DATA_CHANNEL(IIO_ANGL_VEL, ST_ISM330DHCX_REG_OUTX_L_G_ADDR,
+				1, IIO_MOD_X, 0, 16, 16, 's'),
+	ST_ISM330DHCX_DATA_CHANNEL(IIO_ANGL_VEL, ST_ISM330DHCX_REG_OUTY_L_G_ADDR,
+				1, IIO_MOD_Y, 1, 16, 16, 's'),
+	ST_ISM330DHCX_DATA_CHANNEL(IIO_ANGL_VEL, ST_ISM330DHCX_REG_OUTZ_L_G_ADDR,
+				1, IIO_MOD_Z, 2, 16, 16, 's'),
+	ST_ISM330DHCX_EVENT_CHANNEL(IIO_ANGL_VEL, flush),
+	IIO_CHAN_SOFT_TIMESTAMP(3),
+};
+
+/**
+ * Step Counter IIO channels description
+ *
+ * Step Counter exports to IIO framework the following data channels:
+ * Step Counters (16 bit unsigned in little endian)
+ * Timestamp (64 bit signed in little endian)
+ * Step Counter exports to IIO framework the following event channels:
+ * Flush event done
+ */
+static const struct iio_chan_spec st_ism330dhcx_step_counter_channels[] = {
+	{
+		.type = STM_IIO_STEP_COUNTER,
+		.scan_index = 0,
+		.scan_type = {
+			.sign = 'u',
+			.realbits = 16,
+			.storagebits = 16,
+			.endianness = IIO_LE,
+		},
+	},
+	ST_ISM330DHCX_EVENT_CHANNEL(STM_IIO_STEP_COUNTER, flush),
+	IIO_CHAN_SOFT_TIMESTAMP(1),
+};
+
+/**
+ * @brief  Step Detector IIO channels description
+ *
+ * Step Detector exports to IIO framework the following event channels:
+ * Step detection event detection
+ */
+static const struct iio_chan_spec st_ism330dhcx_step_detector_channels[] = {
+	ST_ISM330DHCX_EVENT_CHANNEL(IIO_STEPS, thr),
+};
+
+/**
+ * Significant Motion IIO channels description
+ *
+ * Significant Motion exports to IIO framework the following event channels:
+ * Significant Motion event detection
+ */
+static const struct iio_chan_spec st_ism330dhcx_sign_motion_channels[] = {
+	ST_ISM330DHCX_EVENT_CHANNEL(STM_IIO_SIGN_MOTION, thr),
+};
+
+/**
+ * Tilt IIO channels description
+ *
+ * Tilt exports to IIO framework the following event channels:
+ * Tilt event detection
+ */
+static const struct iio_chan_spec st_ism330dhcx_tilt_channels[] = {
+	ST_ISM330DHCX_EVENT_CHANNEL(STM_IIO_TILT, thr),
+};
+
+/**
+ * Temperature IIO channels description
+ *
+ * Temperature exports to IIO framework the following data channels:
+ * Temperature (16 bit signed in little endian)
+ * Temperature exports to IIO framework the following event channels:
+ * Temperature event threshold
+ */
+static const struct iio_chan_spec st_ism330dhcx_temp_channels[] = {
+	{
+		.type = IIO_TEMP,
+		.address = ST_ISM330DHCX_REG_OUT_TEMP_L_ADDR,
+		.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) |
+				      BIT(IIO_CHAN_INFO_OFFSET) |
+				      BIT(IIO_CHAN_INFO_SCALE),
+		.info_mask_shared_by_all = BIT(IIO_CHAN_INFO_SAMP_FREQ),
+		.scan_index = 0,
+		.scan_type = {
+			.sign = 's',
+			.realbits = 16,
+			.storagebits = 16,
+			.endianness = IIO_LE,
+		}
+	},
+	ST_ISM330DHCX_EVENT_CHANNEL(IIO_TEMP, flush),
+	IIO_CHAN_SOFT_TIMESTAMP(1),
+};
+
+/**
+ * Glance IIO channels description
+ *
+ * Glance exports to IIO framework the following event channels:
+ * Glance event detection
+ */
+static const struct iio_chan_spec st_ism330dhcx_glance_channels[] = {
+	ST_ISM330DHCX_EVENT_CHANNEL(STM_IIO_GESTURE, thr),
+};
+
+/**
+ * Motion IIO channels description
+ *
+ * Motion exports to IIO framework the following event channels:
+ * Motion event detection
+ */
+static const struct iio_chan_spec st_ism330dhcx_motion_channels[] = {
+	ST_ISM330DHCX_EVENT_CHANNEL(STM_IIO_GESTURE, thr),
+};
+
+/**
+ * No Motion IIO channels description
+ *
+ * No Motion exports to IIO framework the following event channels:
+ * No Motion event detection
+ */
+static const struct iio_chan_spec st_ism330dhcx_no_motion_channels[] = {
+	ST_ISM330DHCX_EVENT_CHANNEL(STM_IIO_GESTURE, thr),
+};
+
+/**
+ * Wakeup IIO channels description
+ *
+ * Wakeup exports to IIO framework the following event channels:
+ * Wakeup event detection
+ */
+static const struct iio_chan_spec st_ism330dhcx_wakeup_channels[] = {
+	ST_ISM330DHCX_EVENT_CHANNEL(STM_IIO_GESTURE, thr),
+};
+
+/**
+ * Pickup IIO channels description
+ *
+ * Pickup exports to IIO framework the following event channels:
+ * Pickup event detection
+ */
+static const struct iio_chan_spec st_ism330dhcx_pickup_channels[] = {
+	ST_ISM330DHCX_EVENT_CHANNEL(STM_IIO_GESTURE, thr),
+};
+
+/**
+ * Orientation IIO channels description
+ *
+ * Orientation exports to IIO framework the following data channels:
+ * Orientation (8 bit unsigned in little endian)
+ * Timestamp (64 bit signed in little endian)
+ */
+static const struct iio_chan_spec st_ism330dhcx_orientation_channels[] = {
+	{
+		.type = STM_IIO_GESTURE,
+		.scan_index = 0,
+		.scan_type = {
+			.sign = 'u',
+			.realbits = 8,
+			.storagebits = 8,
+		},
+	},
+	IIO_CHAN_SOFT_TIMESTAMP(1),
+};
+
+/**
+ * Wrist IIO channels description
+ *
+ * Wrist exports to IIO framework the following event channels:
+ * Wrist event detection
+ */
+static const struct iio_chan_spec st_ism330dhcx_wrist_channels[] = {
+	ST_ISM330DHCX_EVENT_CHANNEL(STM_IIO_GESTURE, thr),
+};
+
+int __st_ism330dhcx_write_with_mask(struct st_ism330dhcx_hw *hw, u8 addr, u8 mask,
+				 u8 val)
+{
+	u8 data;
+	int err;
+
+	mutex_lock(&hw->lock);
+
+	err = hw->tf->read(hw->dev, addr, sizeof(data), &data);
+	if (err < 0) {
+		dev_err(hw->dev, "failed to read %02x register\n", addr);
+		goto out;
+	}
+
+	data = (data & ~mask) | ((val << __ffs(mask)) & mask);
+
+	err = hw->tf->write(hw->dev, addr, sizeof(data), &data);
+	if (err < 0)
+		dev_err(hw->dev, "failed to write %02x register\n", addr);
+
+out:
+	mutex_unlock(&hw->lock);
+
+	return err;
+}
+
+/**
+ * Detect device ID
+ *
+ * Check the value of the Device ID if valid
+ *
+ * @param  hw: ST IMU MEMS hw instance
+ * @return  0 if OK, negative value for ERROR
+ */
+static int st_ism330dhcx_check_whoami(struct st_ism330dhcx_hw *hw)
+{
+	int err;
+	u8 data;
+
+	err = hw->tf->read(hw->dev, ST_ISM330DHCX_REG_WHOAMI_ADDR, sizeof(data),
+			   &data);
+	if (err < 0) {
+		dev_err(hw->dev, "failed to read whoami register\n");
+		return err;
+	}
+
+	if (data != ST_ISM330DHCX_WHOAMI_VAL) {
+		dev_err(hw->dev, "unsupported whoami [%02x]\n", data);
+		return -ENODEV;
+	}
+
+	return 0;
+}
+
+/**
+ * Get timestamp calibration
+ *
+ * Read timestamp calibration data and trim delta time
+ *
+ * @param  hw: ST IMU MEMS hw instance
+ * @return  0 if OK, negative value for ERROR
+ */
+static int st_ism330dhcx_get_odr_calibration(struct st_ism330dhcx_hw *hw)
+{
+	int err;
+	s8 data;
+	s64 odr_calib;
+
+	err = hw->tf->read(hw->dev, ST_ISM330DHCX_INTERNAL_FREQ_FINE, sizeof(data),
+			   (u8 *)&data);
+	if (err < 0) {
+		dev_err(hw->dev, "failed to read %d register\n",
+				ST_ISM330DHCX_INTERNAL_FREQ_FINE);
+		return err;
+	}
+
+	odr_calib = (data * 37500) / 1000;
+	hw->ts_delta_ns = ST_ISM330DHCX_TS_DELTA_NS - odr_calib;
+
+	dev_info(hw->dev, "Freq Fine %lld (ts %lld)\n",
+		 odr_calib, hw->ts_delta_ns);
+
+	return 0;
+}
+
+/**
+ * Set sensor Full Scale
+ *
+ * Set new Full Scale value for a specific sensor
+ *
+ * @param  sensor: ST IMU sensor instance
+ * @param  gain: New gain value
+ * @return  0 if OK, negative value for ERROR
+ */
+static int st_ism330dhcx_set_full_scale(struct st_ism330dhcx_sensor *sensor, u32 gain)
+{
+	enum st_ism330dhcx_sensor_id id = sensor->id;
+	int i, err;
+	u8 val;
+
+	for (i = 0; i < st_ism330dhcx_fs_table[id].size; i++)
+		if (st_ism330dhcx_fs_table[id].fs_avl[i].gain == gain)
+			break;
+
+	if (i == st_ism330dhcx_fs_table[id].size)
+		return -EINVAL;
+
+	val = st_ism330dhcx_fs_table[id].fs_avl[i].val;
+	err = st_ism330dhcx_write_with_mask(sensor->hw,
+				st_ism330dhcx_fs_table[id].fs_avl[i].reg.addr,
+				st_ism330dhcx_fs_table[id].fs_avl[i].reg.mask,
+				val);
+	if (err < 0)
+		return err;
+
+	sensor->gain = gain;
+
+	return 0;
+}
+
+/**
+ * Get a valid ODR
+ *
+ * Check a valid ODR closest to the passed value
+ *
+ * @param  id: Sensor Identifier
+ * @param  odr: Most significant part of ODR value (in Hz).
+ * @param  uodr: Least significant part of ODR value (in micro Hz).
+ * @param  podr: User data pointer.
+ * @param  puodr: User data pointer.
+ * @param  val: ODR register value data pointer.
+ * @return  0 if OK, negative value for ERROR
+ */
+int st_ism330dhcx_get_odr_val(enum st_ism330dhcx_sensor_id id, int odr, int uodr,
+			   int *podr, int *puodr, u8 *val)
+{
+	int i;
+	int sensor_odr;
+	int all_odr = ST_ISM330DHCX_ODR_EXPAND(odr, uodr);
+
+	for (i = 0; i < st_ism330dhcx_odr_table[id].odr_size; i++) {
+		sensor_odr =
+		   ST_ISM330DHCX_ODR_EXPAND(st_ism330dhcx_odr_table[id].odr_avl[i].hz,
+		   st_ism330dhcx_odr_table[id].odr_avl[i].uhz);
+		if (sensor_odr >= all_odr)
+			break;
+	}
+
+	if (i == st_ism330dhcx_odr_table[id].odr_size)
+		return -EINVAL;
+
+	*val = st_ism330dhcx_odr_table[id].odr_avl[i].val;
+	*podr = st_ism330dhcx_odr_table[id].odr_avl[i].hz;
+	*puodr = st_ism330dhcx_odr_table[id].odr_avl[i].uhz;
+
+	return 0;
+}
+
+static u16 st_ism330dhcx_check_odr_dependency(struct st_ism330dhcx_hw *hw,
+					   int odr, int uodr,
+					   enum st_ism330dhcx_sensor_id ref_id)
+{
+	struct st_ism330dhcx_sensor *ref = iio_priv(hw->iio_devs[ref_id]);
+	bool enable = odr > 0;
+	u16 ret;
+
+	if (enable) {
+		/* uodr not used */
+		if (hw->enable_mask & BIT(ref_id))
+			ret = max_t(int, ref->odr, odr);
+		else
+			ret = odr;
+	} else {
+		ret = (hw->enable_mask & BIT(ref_id)) ? ref->odr : 0;
+	}
+
+	return ret;
+}
+
+/**
+ * Set new ODR to sensor
+ * Set a valid ODR closest to the passed value
+ *
+ * @param  sensor: ST IMU sensor instance
+ * @param  req_odr: Most significant part of ODR value (in Hz).
+ * @param  req_uodr: Least significant part of ODR value (in micro Hz).
+ * @return  0 if OK, negative value for ERROR
+ */
+static int st_ism330dhcx_set_odr(struct st_ism330dhcx_sensor *sensor, int req_odr,
+			      int req_uodr)
+{
+	struct st_ism330dhcx_hw *hw = sensor->hw;
+	enum st_ism330dhcx_sensor_id id = sensor->id;
+	int err;
+	u8 val;
+
+	switch (id) {
+	case ST_ISM330DHCX_ID_STEP_COUNTER:
+	case ST_ISM330DHCX_ID_STEP_DETECTOR:
+	case ST_ISM330DHCX_ID_SIGN_MOTION:
+	case ST_ISM330DHCX_ID_TILT:
+	case ST_ISM330DHCX_ID_NO_MOTION:
+	case ST_ISM330DHCX_ID_MOTION:
+	case ST_ISM330DHCX_ID_GLANCE:
+	case ST_ISM330DHCX_ID_WAKEUP:
+	case ST_ISM330DHCX_ID_PICKUP:
+	case ST_ISM330DHCX_ID_ORIENTATION:
+	case ST_ISM330DHCX_ID_WRIST_TILT:
+	case ST_ISM330DHCX_ID_TEMP:
+	case ST_ISM330DHCX_ID_EXT0:
+	case ST_ISM330DHCX_ID_EXT1:
+	case ST_ISM330DHCX_ID_ACC: {
+		int odr;
+		int i;
+
+		id = ST_ISM330DHCX_ID_ACC;
+		for (i = ST_ISM330DHCX_ID_ACC; i <= ST_ISM330DHCX_ID_TILT; i++) {
+			if (!hw->iio_devs[i])
+				continue;
+
+			if (i == sensor->id)
+				continue;
+
+			/* req_uodr not used */
+			odr = st_ism330dhcx_check_odr_dependency(hw, req_odr,
+							      req_uodr, i);
+			if (odr != req_odr)
+				/* device already configured */
+				return 0;
+		}
+		break;
+	}
+	default:
+		break;
+	}
+
+	err = st_ism330dhcx_get_odr_val(id, req_odr, req_uodr, &req_odr,
+				       &req_uodr, &val);
+	if (err < 0)
+		return err;
+
+	return st_ism330dhcx_write_with_mask(hw, st_ism330dhcx_odr_table[id].reg.addr,
+					  st_ism330dhcx_odr_table[id].reg.mask,
+					  val);
+}
+
+/**
+ * Enable or Disable sensor
+ *
+ * @param  sensor: ST IMU sensor instance
+ * @param  enable: Enable or disable the sensor [true,false].
+ * @return  0 if OK, negative value for ERROR
+ */
+int st_ism330dhcx_sensor_set_enable(struct st_ism330dhcx_sensor *sensor,
+				 bool enable)
+{
+	int uodr = 0;
+	int odr = 0;
+	int err;
+
+	if (enable) {
+		odr = sensor->odr;
+		uodr = sensor->uodr;
+	}
+
+	err = st_ism330dhcx_set_odr(sensor, odr, uodr);
+	if (err < 0)
+		return err;
+
+	if (enable)
+		sensor->hw->enable_mask |= BIT(sensor->id);
+	else
+		sensor->hw->enable_mask &= ~BIT(sensor->id);
+
+	return 0;
+}
+
+/**
+ * Single sensor read operation
+ *
+ * @param  sensor: ST IMU sensor instance
+ * @param  addr: Output data register value.
+ * @param  val: Output data buffer.
+ * @return  IIO_VAL_INT if OK, negative value for ERROR
+ */
+static int st_ism330dhcx_read_oneshot(struct st_ism330dhcx_sensor *sensor,
+				   u8 addr, int *val)
+{
+	int err, delay;
+	__le16 data;
+
+	err = st_ism330dhcx_sensor_set_enable(sensor, true);
+	if (err < 0)
+		return err;
+
+	delay = 1000000 / sensor->odr;
+	usleep_range(delay, 2 * delay);
+
+	err = st_ism330dhcx_read_atomic(sensor->hw, addr, sizeof(data),
+				     (u8 *)&data);
+	if (err < 0)
+		return err;
+
+	st_ism330dhcx_sensor_set_enable(sensor, false);
+
+	*val = (s16)le16_to_cpu(data);
+
+	return IIO_VAL_INT;
+}
+
+/**
+ * Read Sensor data configuration
+ *
+ * @param  iio_dev: IIO Device.
+ * @param  ch: IIO Channel.
+ * @param  val: Data Buffer (MSB).
+ * @param  val2: Data Buffer (LSB).
+ * @param  mask: Data Mask.
+ * @return  0 if OK, -EINVAL value for ERROR
+ */
+static int st_ism330dhcx_read_raw(struct iio_dev *iio_dev,
+			       struct iio_chan_spec const *ch,
+			       int *val, int *val2, long mask)
+{
+	struct st_ism330dhcx_sensor *sensor = iio_priv(iio_dev);
+	int ret;
+
+	switch (mask) {
+	case IIO_CHAN_INFO_RAW:
+		mutex_lock(&iio_dev->mlock);
+		if (iio_buffer_enabled(iio_dev)) {
+			ret = -EBUSY;
+			mutex_unlock(&iio_dev->mlock);
+			break;
+		}
+		ret = st_ism330dhcx_read_oneshot(sensor, ch->address, val);
+		mutex_unlock(&iio_dev->mlock);
+		break;
+	case IIO_CHAN_INFO_OFFSET:
+		switch (ch->type) {
+		case IIO_TEMP:
+			*val = sensor->offset;
+			ret = IIO_VAL_INT;
+			break;
+		default:
+			return -EINVAL;
+		}
+		break;
+	case IIO_CHAN_INFO_SAMP_FREQ:
+		*val = (int)sensor->odr;
+		*val2 = (int)sensor->uodr;
+		ret = IIO_VAL_INT_PLUS_MICRO;
+		break;
+	case IIO_CHAN_INFO_SCALE:
+		switch (ch->type) {
+		case IIO_TEMP:
+			*val = 1000;
+			*val2 = ST_ISM330DHCX_TEMP_GAIN;
+			ret = IIO_VAL_FRACTIONAL;
+			break;
+		case IIO_ACCEL:
+		case IIO_ANGL_VEL: {
+			*val = 0;
+			*val2 = sensor->gain;
+			ret = IIO_VAL_INT_PLUS_NANO;
+			}
+			break;
+		default:
+			return -EINVAL;
+		}
+		break;
+	default:
+		ret = -EINVAL;
+		break;
+	}
+
+	return ret;
+}
+
+/**
+ * Write Sensor data configuration
+ *
+ * @param  iio_dev: IIO Device.
+ * @param  chan: IIO Channel.
+ * @param  val: Data Buffer (MSB).
+ * @param  val2: Data Buffer (LSB).
+ * @param  mask: Data Mask.
+ * @return  0 if OK, -EINVAL value for ERROR
+ */
+static int st_ism330dhcx_write_raw(struct iio_dev *iio_dev,
+				struct iio_chan_spec const *chan,
+				int val, int val2, long mask)
+{
+	struct st_ism330dhcx_sensor *sensor = iio_priv(iio_dev);
+	int err;
+
+	mutex_lock(&iio_dev->mlock);
+
+	switch (mask) {
+	case IIO_CHAN_INFO_SCALE:
+		err = st_ism330dhcx_set_full_scale(sensor, val2);
+		break;
+	case IIO_CHAN_INFO_SAMP_FREQ: {
+		u8 data;
+		int todr, tuodr;
+
+		err = st_ism330dhcx_get_odr_val(sensor->id, val, val2, &todr,
+					     &tuodr, &data);
+		if (!err) {
+			sensor->odr = todr;
+			sensor->uodr = tuodr;
+		}
+
+		/*
+		 * VTS test testSamplingRateHotSwitchOperation not toggle the
+		 * enable status of sensor after changing the ODR -> force it
+		 */
+		if (sensor->hw->enable_mask & BIT(sensor->id)) {
+			switch (sensor->id) {
+			case ST_ISM330DHCX_ID_GYRO:
+			case ST_ISM330DHCX_ID_ACC:
+				err = st_ism330dhcx_set_odr(sensor, sensor->odr,
+							 sensor->uodr);
+				/* I2C interface err can be positive */
+				if (err < 0)
+					break;
+
+				err = st_ism330dhcx_update_batching(iio_dev, 1);
+				break;
+			default:
+				break;
+			}
+		}
+		break;
+	}
+	default:
+		err = -EINVAL;
+		break;
+	}
+
+	mutex_unlock(&iio_dev->mlock);
+
+	return err;
+}
+
+#ifdef CONFIG_DEBUG_FS
+static int st_ism330dhcx_reg_access(struct iio_dev *iio_dev, unsigned int reg,
+				 unsigned int writeval, unsigned int *readval)
+{
+	struct st_ism330dhcx_sensor *sensor = iio_priv(iio_dev);
+	int ret;
+
+	mutex_lock(&iio_dev->mlock);
+	if (readval == NULL) {
+		ret = sensor->hw->tf->write(sensor->hw->dev, reg, 1,
+					    (u8 *)&writeval);
+	} else {
+		sensor->hw->tf->read(sensor->hw->dev, reg, 1,
+				     (u8 *)readval);
+		ret = 0;
+	}
+	mutex_unlock(&iio_dev->mlock);
+
+	return ret;
+}
+#endif /* CONFIG_DEBUG_FS */
+
+/**
+ * Read sensor event configuration
+ *
+ * @param  iio_dev: IIO Device.
+ * @param  chan: IIO Channel.
+ * @param  type: Event Type.
+ * @param  dir: Event Direction.
+ * @return  1 if Enabled, 0 Disabled
+ */
+static int st_ism330dhcx_read_event_config(struct iio_dev *iio_dev,
+					const struct iio_chan_spec *chan,
+					enum iio_event_type type,
+					enum iio_event_direction dir)
+{
+	struct st_ism330dhcx_sensor *sensor = iio_priv(iio_dev);
+	struct st_ism330dhcx_hw *hw = sensor->hw;
+
+	return !!(hw->enable_mask & BIT(sensor->id));
+}
+
+/**
+ * Write sensor event configuration
+ *
+ * @param  iio_dev: IIO Device.
+ * @param  chan: IIO Channel.
+ * @param  type: Event Type.
+ * @param  dir: Event Direction.
+ * @param  state: New event state.
+ * @return  0 if OK, negative for ERROR
+ */
+static int st_ism330dhcx_write_event_config(struct iio_dev *iio_dev,
+					 const struct iio_chan_spec *chan,
+					 enum iio_event_type type,
+					 enum iio_event_direction dir,
+					 int state)
+{
+	struct st_ism330dhcx_sensor *sensor = iio_priv(iio_dev);
+	int err;
+
+	mutex_lock(&iio_dev->mlock);
+	err = st_ism330dhcx_embfunc_sensor_set_enable(sensor, state);
+	mutex_unlock(&iio_dev->mlock);
+
+	return err;
+}
+
+/**
+ * Get a list of available sensor ODR
+ *
+ * List of available ODR returned separated by commas
+ *
+ * @param  dev: IIO Device.
+ * @param  attr: IIO Channel attribute.
+ * @param  buf: User buffer.
+ * @return  buffer len
+ */
+static ssize_t
+st_ism330dhcx_sysfs_sampling_frequency_avail(struct device *dev,
+					  struct device_attribute *attr,
+					  char *buf)
+{
+	struct st_ism330dhcx_sensor *sensor = iio_priv(dev_to_iio_dev(dev));
+	enum st_ism330dhcx_sensor_id id = sensor->id;
+	int i, len = 0;
+
+	for (i = 0; i < ST_ISM330DHCX_ODR_LIST_SIZE; i++) {
+		if (!st_ism330dhcx_odr_table[id].odr_avl[i].hz)
+			continue;
+
+		if (st_ism330dhcx_odr_table[id].odr_avl[i].uhz == 0)
+			len += scnprintf(buf + len, PAGE_SIZE - len, "%d ",
+				st_ism330dhcx_odr_table[id].odr_avl[i].hz);
+		else
+			len += scnprintf(buf + len, PAGE_SIZE - len, "%d.%d ",
+				st_ism330dhcx_odr_table[id].odr_avl[i].hz,
+				st_ism330dhcx_odr_table[id].odr_avl[i].uhz);
+	}
+
+	buf[len - 1] = '\n';
+
+	return len;
+}
+
+/**
+ * Get a list of available sensor Full Scale
+ *
+ * List of available Full Scale returned separated by commas
+ *
+ * @param  dev: IIO Device.
+ * @param  attr: IIO Channel attribute.
+ * @param  buf: User buffer.
+ * @return  buffer len
+ */
+static ssize_t st_ism330dhcx_sysfs_scale_avail(struct device *dev,
+					    struct device_attribute *attr,
+					    char *buf)
+{
+	struct st_ism330dhcx_sensor *sensor = iio_priv(dev_to_iio_dev(dev));
+	enum st_ism330dhcx_sensor_id id = sensor->id;
+	int i, len = 0;
+
+	for (i = 0; i < st_ism330dhcx_fs_table[id].size; i++)
+		len += scnprintf(buf + len, PAGE_SIZE - len, "0.%09u ",
+				 st_ism330dhcx_fs_table[id].fs_avl[i].gain);
+	buf[len - 1] = '\n';
+
+	return len;
+}
+
+/**
+ * Reset step counter value
+ *
+ * @param  dev: IIO Device.
+ * @param  attr: IIO Channel attribute.
+ * @param  buf: User buffer.
+ * @param  size: User buffer size.
+ * @return  buffer len, negative for ERROR
+ */
+static ssize_t
+st_ism330dhcx_sysfs_reset_step_counter(struct device *dev,
+				    struct device_attribute *attr,
+				    const char *buf, size_t size)
+{
+	struct iio_dev *iio_dev = dev_to_iio_dev(dev);
+	int err;
+
+	err = st_ism330dhcx_reset_step_counter(iio_dev);
+
+	return err < 0 ? err : size;
+}
+
+static int st_ism330dhcx_write_raw_get_fmt(struct iio_dev *indio_dev,
+					   struct iio_chan_spec const *chan,
+					   long mask)
+{
+	switch (mask) {
+	case IIO_CHAN_INFO_SCALE:
+		switch (chan->type) {
+		case IIO_ANGL_VEL:
+		case IIO_ACCEL:
+			return IIO_VAL_INT_PLUS_NANO;
+		case IIO_TEMP:
+			return IIO_VAL_FRACTIONAL;
+		default:
+			return IIO_VAL_INT_PLUS_MICRO;
+		}
+	default:
+		return IIO_VAL_INT_PLUS_MICRO;
+	}
+
+	return -EINVAL;
+}
+
+ssize_t st_ism330dhcx_get_module_id(struct device *dev,
+				    struct device_attribute *attr,
+				    char *buf)
+{
+	struct iio_dev *iio_dev = dev_to_iio_dev(dev);
+	struct st_ism330dhcx_sensor *sensor = iio_priv(iio_dev);
+	struct st_ism330dhcx_hw *hw = sensor->hw;
+
+	return scnprintf(buf, PAGE_SIZE, "%u\n", hw->module_id);
+}
+
+static IIO_DEV_ATTR_SAMP_FREQ_AVAIL(st_ism330dhcx_sysfs_sampling_frequency_avail);
+static IIO_DEVICE_ATTR(in_accel_scale_available, 0444,
+		       st_ism330dhcx_sysfs_scale_avail, NULL, 0);
+static IIO_DEVICE_ATTR(in_anglvel_scale_available, 0444,
+		       st_ism330dhcx_sysfs_scale_avail, NULL, 0);
+static IIO_DEVICE_ATTR(in_temp_scale_available, 0444,
+		       st_ism330dhcx_sysfs_scale_avail, NULL, 0);
+static IIO_DEVICE_ATTR(hwfifo_watermark_max, 0444,
+		       st_ism330dhcx_get_max_watermark, NULL, 0);
+static IIO_DEVICE_ATTR(hwfifo_flush, 0200, NULL, st_ism330dhcx_flush_fifo, 0);
+static IIO_DEVICE_ATTR(hwfifo_watermark, 0644, st_ism330dhcx_get_watermark,
+		       st_ism330dhcx_set_watermark, 0);
+static IIO_DEVICE_ATTR(reset_counter, 0200, NULL,
+		       st_ism330dhcx_sysfs_reset_step_counter, 0);
+static IIO_DEVICE_ATTR(module_id, 0444, st_ism330dhcx_get_module_id, NULL, 0);
+
+static struct attribute *st_ism330dhcx_acc_attributes[] = {
+	&iio_dev_attr_sampling_frequency_available.dev_attr.attr,
+	&iio_dev_attr_in_accel_scale_available.dev_attr.attr,
+	&iio_dev_attr_hwfifo_watermark_max.dev_attr.attr,
+	&iio_dev_attr_hwfifo_watermark.dev_attr.attr,
+	&iio_dev_attr_hwfifo_flush.dev_attr.attr,
+	&iio_dev_attr_module_id.dev_attr.attr,
+	NULL,
+};
+
+static const struct attribute_group st_ism330dhcx_acc_attribute_group = {
+	.attrs = st_ism330dhcx_acc_attributes,
+};
+
+static const struct iio_info st_ism330dhcx_acc_info = {
+	.attrs = &st_ism330dhcx_acc_attribute_group,
+	.read_raw = st_ism330dhcx_read_raw,
+	.write_raw = st_ism330dhcx_write_raw,
+	.write_raw_get_fmt = st_ism330dhcx_write_raw_get_fmt,
+#ifdef CONFIG_DEBUG_FS
+	/* connect debug info to first device */
+	.debugfs_reg_access = st_ism330dhcx_reg_access,
+#endif /* CONFIG_DEBUG_FS */
+};
+
+static struct attribute *st_ism330dhcx_gyro_attributes[] = {
+	&iio_dev_attr_sampling_frequency_available.dev_attr.attr,
+	&iio_dev_attr_in_anglvel_scale_available.dev_attr.attr,
+	&iio_dev_attr_hwfifo_watermark_max.dev_attr.attr,
+	&iio_dev_attr_hwfifo_watermark.dev_attr.attr,
+	&iio_dev_attr_hwfifo_flush.dev_attr.attr,
+	&iio_dev_attr_module_id.dev_attr.attr,
+	NULL,
+};
+
+static const struct attribute_group st_ism330dhcx_gyro_attribute_group = {
+	.attrs = st_ism330dhcx_gyro_attributes,
+};
+
+static const struct iio_info st_ism330dhcx_gyro_info = {
+	.attrs = &st_ism330dhcx_gyro_attribute_group,
+	.read_raw = st_ism330dhcx_read_raw,
+	.write_raw = st_ism330dhcx_write_raw,
+	.write_raw_get_fmt = st_ism330dhcx_write_raw_get_fmt,
+};
+
+static struct attribute *st_ism330dhcx_temp_attributes[] = {
+	&iio_dev_attr_sampling_frequency_available.dev_attr.attr,
+	&iio_dev_attr_in_temp_scale_available.dev_attr.attr,
+	&iio_dev_attr_hwfifo_watermark_max.dev_attr.attr,
+	&iio_dev_attr_hwfifo_watermark.dev_attr.attr,
+	&iio_dev_attr_hwfifo_flush.dev_attr.attr,
+	&iio_dev_attr_module_id.dev_attr.attr,
+	NULL,
+};
+
+static const struct attribute_group st_ism330dhcx_temp_attribute_group = {
+	.attrs = st_ism330dhcx_temp_attributes,
+};
+
+static const struct iio_info st_ism330dhcx_temp_info = {
+	.attrs = &st_ism330dhcx_temp_attribute_group,
+	.read_raw = st_ism330dhcx_read_raw,
+	.write_raw = st_ism330dhcx_write_raw,
+	.write_raw_get_fmt = st_ism330dhcx_write_raw_get_fmt,
+};
+
+static struct attribute *st_ism330dhcx_step_counter_attributes[] = {
+	&iio_dev_attr_hwfifo_watermark_max.dev_attr.attr,
+	&iio_dev_attr_hwfifo_watermark.dev_attr.attr,
+	&iio_dev_attr_reset_counter.dev_attr.attr,
+	&iio_dev_attr_hwfifo_flush.dev_attr.attr,
+	&iio_dev_attr_module_id.dev_attr.attr,
+	NULL,
+};
+
+static const struct attribute_group st_ism330dhcx_step_counter_attribute_group = {
+	.attrs = st_ism330dhcx_step_counter_attributes,
+};
+
+static const struct iio_info st_ism330dhcx_step_counter_info = {
+	.attrs = &st_ism330dhcx_step_counter_attribute_group,
+};
+
+static struct attribute *st_ism330dhcx_step_detector_attributes[] = {
+	&iio_dev_attr_module_id.dev_attr.attr,
+	NULL,
+};
+
+static const struct attribute_group st_ism330dhcx_step_detector_attribute_group = {
+	.attrs = st_ism330dhcx_step_detector_attributes,
+};
+
+static const struct iio_info st_ism330dhcx_step_detector_info = {
+	.attrs = &st_ism330dhcx_step_detector_attribute_group,
+	.read_event_config = st_ism330dhcx_read_event_config,
+	.write_event_config = st_ism330dhcx_write_event_config,
+};
+
+static struct attribute *st_ism330dhcx_sign_motion_attributes[] = {
+	&iio_dev_attr_module_id.dev_attr.attr,
+	NULL,
+};
+
+static const struct attribute_group st_ism330dhcx_sign_motion_attribute_group = {
+	.attrs = st_ism330dhcx_sign_motion_attributes,
+};
+
+static const struct iio_info st_ism330dhcx_sign_motion_info = {
+	.attrs = &st_ism330dhcx_sign_motion_attribute_group,
+	.read_event_config = st_ism330dhcx_read_event_config,
+	.write_event_config = st_ism330dhcx_write_event_config,
+};
+
+static struct attribute *st_ism330dhcx_tilt_attributes[] = {
+	&iio_dev_attr_module_id.dev_attr.attr,
+	NULL,
+};
+
+static const struct attribute_group st_ism330dhcx_tilt_attribute_group = {
+	.attrs = st_ism330dhcx_tilt_attributes,
+};
+
+static const struct iio_info st_ism330dhcx_tilt_info = {
+	.attrs = &st_ism330dhcx_tilt_attribute_group,
+	.read_event_config = st_ism330dhcx_read_event_config,
+	.write_event_config = st_ism330dhcx_write_event_config,
+};
+
+static struct attribute *st_ism330dhcx_glance_attributes[] = {
+	&iio_dev_attr_module_id.dev_attr.attr,
+	NULL,
+};
+
+static const struct attribute_group st_ism330dhcx_glance_attribute_group = {
+	.attrs = st_ism330dhcx_glance_attributes,
+};
+
+static const struct iio_info st_ism330dhcx_glance_info = {
+	.attrs = &st_ism330dhcx_glance_attribute_group,
+	.read_event_config = st_ism330dhcx_read_event_config,
+	.write_event_config = st_ism330dhcx_write_event_config,
+};
+
+static struct attribute *st_ism330dhcx_motion_attributes[] = {
+	&iio_dev_attr_module_id.dev_attr.attr,
+	NULL,
+};
+
+static const struct attribute_group st_ism330dhcx_motion_attribute_group = {
+	.attrs = st_ism330dhcx_motion_attributes,
+};
+
+static const struct iio_info st_ism330dhcx_motion_info = {
+	.attrs = &st_ism330dhcx_motion_attribute_group,
+	.read_event_config = st_ism330dhcx_read_event_config,
+	.write_event_config = st_ism330dhcx_write_event_config,
+};
+
+static struct attribute *st_ism330dhcx_no_motion_attributes[] = {
+	&iio_dev_attr_module_id.dev_attr.attr,
+	NULL,
+};
+
+static const struct attribute_group st_ism330dhcx_no_motion_attribute_group = {
+	.attrs = st_ism330dhcx_no_motion_attributes,
+};
+
+static const struct iio_info st_ism330dhcx_no_motion_info = {
+	.attrs = &st_ism330dhcx_no_motion_attribute_group,
+	.read_event_config = st_ism330dhcx_read_event_config,
+	.write_event_config = st_ism330dhcx_write_event_config,
+};
+
+static struct attribute *st_ism330dhcx_wakeup_attributes[] = {
+	&iio_dev_attr_module_id.dev_attr.attr,
+	NULL,
+};
+
+static const struct attribute_group st_ism330dhcx_wakeup_attribute_group = {
+	.attrs = st_ism330dhcx_wakeup_attributes,
+};
+
+static const struct iio_info st_ism330dhcx_wakeup_info = {
+	.attrs = &st_ism330dhcx_wakeup_attribute_group,
+	.read_event_config = st_ism330dhcx_read_event_config,
+	.write_event_config = st_ism330dhcx_write_event_config,
+};
+
+static struct attribute *st_ism330dhcx_pickup_attributes[] = {
+	&iio_dev_attr_module_id.dev_attr.attr,
+	NULL,
+};
+
+static const struct attribute_group st_ism330dhcx_pickup_attribute_group = {
+	.attrs = st_ism330dhcx_pickup_attributes,
+};
+
+static const struct iio_info st_ism330dhcx_pickup_info = {
+	.attrs = &st_ism330dhcx_pickup_attribute_group,
+	.read_event_config = st_ism330dhcx_read_event_config,
+	.write_event_config = st_ism330dhcx_write_event_config,
+};
+
+static struct attribute *st_ism330dhcx_orientation_attributes[] = {
+	&iio_dev_attr_module_id.dev_attr.attr,
+	NULL,
+};
+
+static const struct attribute_group st_ism330dhcx_orientation_attribute_group = {
+	.attrs = st_ism330dhcx_orientation_attributes,
+};
+
+static const struct iio_info st_ism330dhcx_orientation_info = {
+	.attrs = &st_ism330dhcx_orientation_attribute_group,
+};
+
+static struct attribute *st_ism330dhcx_wrist_attributes[] = {
+	&iio_dev_attr_module_id.dev_attr.attr,
+	NULL,
+};
+
+static const struct attribute_group st_ism330dhcx_wrist_attribute_group = {
+	.attrs = st_ism330dhcx_wrist_attributes,
+};
+
+static const struct iio_info st_ism330dhcx_wrist_info = {
+	.attrs = &st_ism330dhcx_wrist_attribute_group,
+	.read_event_config = st_ism330dhcx_read_event_config,
+	.write_event_config = st_ism330dhcx_write_event_config,
+};
+
+static const unsigned long st_ism330dhcx_available_scan_masks[] = { 0x7, 0x0 };
+static const unsigned long st_ism330dhcx_sc_available_scan_masks[] = { 0x1, 0x0 };
+
+static int st_ism330dhcx_of_get_pin(struct st_ism330dhcx_hw *hw, int *pin)
+{
+	struct device_node *np = hw->dev->of_node;
+
+	if (!np)
+		return -EINVAL;
+
+	return of_property_read_u32(np, "st,int-pin", pin);
+}
+
+static int st_ism330dhcx_get_int_reg(struct st_ism330dhcx_hw *hw, u8 *drdy_reg,
+				  u8 *ef_irq_reg)
+{
+	int err = 0, int_pin;
+
+	if (st_ism330dhcx_of_get_pin(hw, &int_pin) < 0) {
+		struct st_sensors_platform_data *pdata;
+		struct device *dev = hw->dev;
+
+		pdata = (struct st_sensors_platform_data *)dev->platform_data;
+		int_pin = pdata ? pdata->drdy_int_pin : 1;
+	}
+
+	switch (int_pin) {
+	case 1:
+		hw->embfunc_pg0_irq_reg = ST_ISM330DHCX_REG_MD1_CFG_ADDR;
+		hw->embfunc_irq_reg = ST_ISM330DHCX_REG_EMB_FUNC_INT1_ADDR;
+		*ef_irq_reg = ST_ISM330DHCX_REG_MD1_CFG_ADDR;
+		*drdy_reg = ST_ISM330DHCX_REG_INT1_CTRL_ADDR;
+		break;
+	case 2:
+		hw->embfunc_pg0_irq_reg = ST_ISM330DHCX_REG_MD2_CFG_ADDR;
+		hw->embfunc_irq_reg = ST_ISM330DHCX_REG_EMB_FUNC_INT2_ADDR;
+		*ef_irq_reg = ST_ISM330DHCX_REG_MD2_CFG_ADDR;
+		*drdy_reg = ST_ISM330DHCX_REG_INT2_CTRL_ADDR;
+		break;
+	default:
+		dev_err(hw->dev, "unsupported interrupt pin\n");
+		err = -EINVAL;
+		break;
+	}
+
+	return err;
+}
+
+static int st_ism330dhcx_reset_device(struct st_ism330dhcx_hw *hw)
+{
+	int err;
+
+	/* disable I3C */
+	err = st_ism330dhcx_write_with_mask(hw, ST_ISM330DHCX_REG_CTRL9_XL_ADDR,
+					 ST_ISM330DHCX_REG_I3C_DISABLE_MASK, 1);
+	if (err < 0)
+		return err;
+
+	/* sw reset */
+	err = st_ism330dhcx_write_with_mask(hw,
+					 ST_ISM330DHCX_REG_CTRL3_C_ADDR,
+					 ST_ISM330DHCX_REG_SW_RESET_MASK, 1);
+	if (err < 0)
+		return err;
+
+	usleep_range(15, 20);
+
+	/* boot */
+	err = st_ism330dhcx_write_with_mask(hw,
+					 ST_ISM330DHCX_REG_CTRL3_C_ADDR,
+					 ST_ISM330DHCX_REG_BOOT_MASK, 1);
+
+	msleep(20);
+
+	return err;
+}
+
+static int st_ism330dhcx_init_device(struct st_ism330dhcx_hw *hw)
+{
+	u8 drdy_reg, ef_irq_reg;
+	int err;
+
+	/* configure latch interrupts enabled */
+	err = st_ism330dhcx_write_with_mask(hw,
+					 ST_ISM330DHCX_REG_TAP_CFG0_ADDR,
+					 ST_ISM330DHCX_REG_LIR_MASK, 1);
+	if (err < 0)
+		return err;
+
+	/* enable Block Data Update */
+	err = st_ism330dhcx_write_with_mask(hw,
+					 ST_ISM330DHCX_REG_CTRL3_C_ADDR,
+					 ST_ISM330DHCX_REG_BDU_MASK, 1);
+	if (err < 0)
+		return err;
+
+	/* enable rouding for fast FIFO reading */
+	err = st_ism330dhcx_write_with_mask(hw,
+					 ST_ISM330DHCX_REG_CTRL5_C_ADDR,
+					 ST_ISM330DHCX_REG_ROUNDING_MASK, 3);
+	if (err < 0)
+		return err;
+
+	/* init timestamp engine */
+	err = st_ism330dhcx_write_with_mask(hw,
+					 ST_ISM330DHCX_REG_CTRL10_C_ADDR,
+					 ST_ISM330DHCX_REG_TIMESTAMP_EN_MASK, 1);
+	if (err < 0)
+		return err;
+
+	/* configure interrupt registers */
+	err = st_ism330dhcx_get_int_reg(hw, &drdy_reg, &ef_irq_reg);
+	if (err < 0)
+		return err;
+
+	/* Enable DRDY MASK for filters settling time */
+	err = st_ism330dhcx_write_with_mask(hw, ST_ISM330DHCX_REG_CTRL4_C_ADDR,
+					 ST_ISM330DHCX_REG_DRDY_MASK, 1);
+	if (err < 0)
+		return err;
+
+	/* enable FIFO watermak interrupt */
+	err = st_ism330dhcx_write_with_mask(hw, drdy_reg,
+					 ST_ISM330DHCX_REG_INT_FIFO_TH_MASK, 1);
+	if (err < 0)
+		return err;
+
+	/* enable enbedded function interrupts */
+	err = st_ism330dhcx_write_with_mask(hw, ef_irq_reg,
+					 ST_ISM330DHCX_REG_INT_EMB_FUNC_MASK, 1);
+	if (err < 0)
+		return err;
+
+	/* init finite state machine */
+	return st_ism330dhcx_fsm_init(hw);
+}
+
+/**
+ * Allocate IIO device
+ *
+ * @param  hw: ST IMU MEMS hw instance.
+ * @param  id: Sensor Identifier.
+ * @retval  struct iio_dev *, NULL if ERROR
+ */
+static struct iio_dev *st_ism330dhcx_alloc_iiodev(struct st_ism330dhcx_hw *hw,
+					       enum st_ism330dhcx_sensor_id id)
+{
+	struct st_ism330dhcx_sensor *sensor;
+	struct iio_dev *iio_dev;
+
+	iio_dev = devm_iio_device_alloc(hw->dev, sizeof(*sensor));
+	if (!iio_dev)
+		return NULL;
+
+	iio_dev->modes = INDIO_DIRECT_MODE;
+	iio_dev->dev.parent = hw->dev;
+
+	sensor = iio_priv(iio_dev);
+	sensor->id = id;
+	sensor->hw = hw;
+	sensor->watermark = 1;
+
+	sensor->decimator = 0;
+	sensor->dec_counter = 0;
+
+	switch (id) {
+	case ST_ISM330DHCX_ID_ACC:
+		iio_dev->channels = st_ism330dhcx_acc_channels;
+		iio_dev->num_channels = ARRAY_SIZE(st_ism330dhcx_acc_channels);
+		iio_dev->name = "ism330dhcx_accel";
+		iio_dev->info = &st_ism330dhcx_acc_info;
+		iio_dev->available_scan_masks = st_ism330dhcx_available_scan_masks;
+
+		sensor->batch_reg.addr = ST_ISM330DHCX_REG_FIFO_CTRL3_ADDR;
+		sensor->batch_reg.mask = ST_ISM330DHCX_REG_BDR_XL_MASK;
+		sensor->max_watermark = ST_ISM330DHCX_MAX_FIFO_DEPTH;
+		sensor->odr = st_ism330dhcx_odr_table[id].odr_avl[1].hz;
+		sensor->uodr = st_ism330dhcx_odr_table[id].odr_avl[1].uhz;
+		st_ism330dhcx_set_full_scale(sensor,
+				st_ism330dhcx_fs_table[id].fs_avl[1].gain);
+		break;
+	case ST_ISM330DHCX_ID_GYRO:
+		iio_dev->channels = st_ism330dhcx_gyro_channels;
+		iio_dev->num_channels = ARRAY_SIZE(st_ism330dhcx_gyro_channels);
+		iio_dev->name = "ism330dhcx_gyro";
+		iio_dev->info = &st_ism330dhcx_gyro_info;
+		iio_dev->available_scan_masks = st_ism330dhcx_available_scan_masks;
+
+		sensor->batch_reg.addr = ST_ISM330DHCX_REG_FIFO_CTRL3_ADDR;
+		sensor->batch_reg.mask = ST_ISM330DHCX_REG_BDR_GY_MASK;
+		sensor->max_watermark = ST_ISM330DHCX_MAX_FIFO_DEPTH;
+		sensor->odr = st_ism330dhcx_odr_table[id].odr_avl[1].hz;
+		sensor->uodr = st_ism330dhcx_odr_table[id].odr_avl[1].uhz;
+		st_ism330dhcx_set_full_scale(sensor,
+				st_ism330dhcx_fs_table[id].fs_avl[2].gain);
+		break;
+	case ST_ISM330DHCX_ID_TEMP:
+		iio_dev->channels = st_ism330dhcx_temp_channels;
+		iio_dev->num_channels = ARRAY_SIZE(st_ism330dhcx_temp_channels);
+		iio_dev->name = "ism330dhcx_temp";
+		iio_dev->info = &st_ism330dhcx_temp_info;
+
+		sensor->batch_reg.addr = ST_ISM330DHCX_REG_FIFO_CTRL4_ADDR;
+		sensor->batch_reg.mask = ST_ISM330DHCX_REG_ODR_T_BATCH_MASK;
+		sensor->max_watermark = ST_ISM330DHCX_MAX_FIFO_DEPTH;
+		sensor->odr = st_ism330dhcx_odr_table[id].odr_avl[1].hz;
+		sensor->uodr = st_ism330dhcx_odr_table[id].odr_avl[1].uhz;
+		sensor->gain = st_ism330dhcx_fs_table[id].fs_avl[0].gain;
+		sensor->offset = ST_ISM330DHCX_TEMP_OFFSET;
+		break;
+	case ST_ISM330DHCX_ID_STEP_COUNTER:
+		iio_dev->channels = st_ism330dhcx_step_counter_channels;
+		iio_dev->num_channels =
+			ARRAY_SIZE(st_ism330dhcx_step_counter_channels);
+		iio_dev->name = "ism330dhcx_step_c";
+		iio_dev->info = &st_ism330dhcx_step_counter_info;
+		iio_dev->available_scan_masks =
+					st_ism330dhcx_sc_available_scan_masks;
+
+		sensor->max_watermark = 1;
+		sensor->odr =
+			st_ism330dhcx_odr_table[ST_ISM330DHCX_ID_ACC].odr_avl[2].hz;
+		sensor->uodr =
+			st_ism330dhcx_odr_table[ST_ISM330DHCX_ID_ACC].odr_avl[2].uhz;
+		break;
+	case ST_ISM330DHCX_ID_STEP_DETECTOR:
+		iio_dev->channels = st_ism330dhcx_step_detector_channels;
+		iio_dev->num_channels =
+			ARRAY_SIZE(st_ism330dhcx_step_detector_channels);
+		iio_dev->name = "ism330dhcx_step_d";
+		iio_dev->info = &st_ism330dhcx_step_detector_info;
+		iio_dev->available_scan_masks =
+					st_ism330dhcx_sc_available_scan_masks;
+
+		sensor->odr =
+			st_ism330dhcx_odr_table[ST_ISM330DHCX_ID_ACC].odr_avl[2].hz;
+		sensor->uodr =
+			st_ism330dhcx_odr_table[ST_ISM330DHCX_ID_ACC].odr_avl[2].uhz;
+		break;
+	case ST_ISM330DHCX_ID_SIGN_MOTION:
+		iio_dev->channels = st_ism330dhcx_sign_motion_channels;
+		iio_dev->num_channels =
+			ARRAY_SIZE(st_ism330dhcx_sign_motion_channels);
+		iio_dev->name = "ism330dhcx_sign_motion";
+		iio_dev->info = &st_ism330dhcx_sign_motion_info;
+		iio_dev->available_scan_masks =
+					st_ism330dhcx_sc_available_scan_masks;
+
+		sensor->odr =
+			st_ism330dhcx_odr_table[ST_ISM330DHCX_ID_ACC].odr_avl[2].hz;
+		sensor->uodr =
+			st_ism330dhcx_odr_table[ST_ISM330DHCX_ID_ACC].odr_avl[2].uhz;
+		break;
+	case ST_ISM330DHCX_ID_TILT:
+		iio_dev->channels = st_ism330dhcx_tilt_channels;
+		iio_dev->num_channels = ARRAY_SIZE(st_ism330dhcx_tilt_channels);
+		iio_dev->name = "ism330dhcx_tilt";
+		iio_dev->info = &st_ism330dhcx_tilt_info;
+		iio_dev->available_scan_masks =
+					st_ism330dhcx_sc_available_scan_masks;
+
+		sensor->odr =
+			st_ism330dhcx_odr_table[ST_ISM330DHCX_ID_ACC].odr_avl[2].hz;
+		sensor->uodr =
+			st_ism330dhcx_odr_table[ST_ISM330DHCX_ID_ACC].odr_avl[2].uhz;
+		break;
+	case ST_ISM330DHCX_ID_GLANCE:
+		iio_dev->channels = st_ism330dhcx_glance_channels;
+		iio_dev->num_channels = ARRAY_SIZE(st_ism330dhcx_glance_channels);
+		iio_dev->name = "ism330dhcx_glance";
+		iio_dev->info = &st_ism330dhcx_glance_info;
+		iio_dev->available_scan_masks =
+					st_ism330dhcx_sc_available_scan_masks;
+
+		sensor->odr =
+			st_ism330dhcx_odr_table[ST_ISM330DHCX_ID_ACC].odr_avl[2].hz;
+		sensor->uodr =
+			st_ism330dhcx_odr_table[ST_ISM330DHCX_ID_ACC].odr_avl[2].uhz;
+		break;
+	case ST_ISM330DHCX_ID_MOTION:
+		iio_dev->channels = st_ism330dhcx_motion_channels;
+		iio_dev->num_channels = ARRAY_SIZE(st_ism330dhcx_motion_channels);
+		iio_dev->name = "ism330dhcx_motion";
+		iio_dev->info = &st_ism330dhcx_motion_info;
+		iio_dev->available_scan_masks =
+					st_ism330dhcx_sc_available_scan_masks;
+
+		sensor->odr =
+			st_ism330dhcx_odr_table[ST_ISM330DHCX_ID_ACC].odr_avl[2].hz;
+		sensor->uodr =
+			st_ism330dhcx_odr_table[ST_ISM330DHCX_ID_ACC].odr_avl[2].uhz;
+		break;
+	case ST_ISM330DHCX_ID_NO_MOTION:
+		iio_dev->channels = st_ism330dhcx_no_motion_channels;
+		iio_dev->num_channels =
+				ARRAY_SIZE(st_ism330dhcx_no_motion_channels);
+		iio_dev->name = "ism330dhcx_no_motion";
+		iio_dev->info = &st_ism330dhcx_no_motion_info;
+		iio_dev->available_scan_masks =
+					st_ism330dhcx_sc_available_scan_masks;
+
+		sensor->odr =
+			st_ism330dhcx_odr_table[ST_ISM330DHCX_ID_ACC].odr_avl[2].hz;
+		sensor->uodr =
+			st_ism330dhcx_odr_table[ST_ISM330DHCX_ID_ACC].odr_avl[2].uhz;
+		break;
+	case ST_ISM330DHCX_ID_WAKEUP:
+		iio_dev->channels = st_ism330dhcx_wakeup_channels;
+		iio_dev->num_channels = ARRAY_SIZE(st_ism330dhcx_wakeup_channels);
+		iio_dev->name = "ism330dhcx_wk";
+		iio_dev->info = &st_ism330dhcx_wakeup_info;
+		iio_dev->available_scan_masks =
+					st_ism330dhcx_sc_available_scan_masks;
+
+		sensor->odr =
+			st_ism330dhcx_odr_table[ST_ISM330DHCX_ID_ACC].odr_avl[2].hz;
+		sensor->uodr =
+			st_ism330dhcx_odr_table[ST_ISM330DHCX_ID_ACC].odr_avl[2].uhz;
+		break;
+	case ST_ISM330DHCX_ID_PICKUP:
+		iio_dev->channels = st_ism330dhcx_pickup_channels;
+		iio_dev->num_channels = ARRAY_SIZE(st_ism330dhcx_pickup_channels);
+		iio_dev->name = "ism330dhcx_pickup";
+		iio_dev->info = &st_ism330dhcx_pickup_info;
+		iio_dev->available_scan_masks =
+					st_ism330dhcx_sc_available_scan_masks;
+
+		sensor->odr =
+			st_ism330dhcx_odr_table[ST_ISM330DHCX_ID_ACC].odr_avl[2].hz;
+		sensor->uodr =
+			st_ism330dhcx_odr_table[ST_ISM330DHCX_ID_ACC].odr_avl[2].uhz;
+		break;
+	case ST_ISM330DHCX_ID_ORIENTATION:
+		iio_dev->channels = st_ism330dhcx_orientation_channels;
+		iio_dev->num_channels =
+				ARRAY_SIZE(st_ism330dhcx_orientation_channels);
+		iio_dev->name = "ism330dhcx_dev_orientation";
+		iio_dev->info = &st_ism330dhcx_orientation_info;
+		iio_dev->available_scan_masks =
+					st_ism330dhcx_sc_available_scan_masks;
+
+		sensor->odr =
+			st_ism330dhcx_odr_table[ST_ISM330DHCX_ID_ACC].odr_avl[2].hz;
+		sensor->uodr =
+			st_ism330dhcx_odr_table[ST_ISM330DHCX_ID_ACC].odr_avl[2].uhz;
+		break;
+	case ST_ISM330DHCX_ID_WRIST_TILT:
+		iio_dev->channels = st_ism330dhcx_wrist_channels;
+		iio_dev->num_channels = ARRAY_SIZE(st_ism330dhcx_wrist_channels);
+		iio_dev->name = "ism330dhcx_wrist";
+		iio_dev->info = &st_ism330dhcx_wrist_info;
+		iio_dev->available_scan_masks =
+					st_ism330dhcx_sc_available_scan_masks;
+
+		sensor->odr =
+			st_ism330dhcx_odr_table[ST_ISM330DHCX_ID_ACC].odr_avl[2].hz;
+		sensor->uodr =
+			st_ism330dhcx_odr_table[ST_ISM330DHCX_ID_ACC].odr_avl[2].uhz;
+		break;
+	default:
+		return NULL;
+	}
+
+	return iio_dev;
+}
+
+static void st_ism330dhcx_get_properties(struct st_ism330dhcx_hw *hw)
+{
+	if (device_property_read_u32(hw->dev, "st,module_id",
+				     &hw->module_id)) {
+		hw->module_id = 1;
+	}
+}
+
+/**
+ * Probe device function
+ * Implements [MODULE] feature for Power Management
+ *
+ * @param  dev: Device pointer.
+ * @param  irq: I2C/SPI client irq.
+ * @param  tf_ops: Bus Transfer Function pointer.
+ * @retval  struct iio_dev *, NULL if ERROR
+ */
+int st_ism330dhcx_probe(struct device *dev, int irq,
+		     const struct st_ism330dhcx_transfer_function *tf_ops)
+{
+	struct st_ism330dhcx_hw *hw;
+	int i, err;
+
+	hw = devm_kzalloc(dev, sizeof(*hw), GFP_KERNEL);
+	if (!hw)
+		return -ENOMEM;
+
+	dev_set_drvdata(dev, (void *)hw);
+
+	mutex_init(&hw->lock);
+	mutex_init(&hw->fifo_lock);
+	mutex_init(&hw->page_lock);
+
+	hw->dev = dev;
+	hw->irq = irq;
+	hw->tf = tf_ops;
+
+	err = st_ism330dhcx_check_whoami(hw);
+	if (err < 0)
+		return err;
+
+	st_ism330dhcx_get_properties(hw);
+
+	err = st_ism330dhcx_get_odr_calibration(hw);
+	if (err < 0)
+		return err;
+
+	err = st_ism330dhcx_reset_device(hw);
+	if (err < 0)
+		return err;
+
+	err = st_ism330dhcx_init_device(hw);
+	if (err < 0)
+		return err;
+
+	for (i = 0; i < ARRAY_SIZE(st_ism330dhcx_main_sensor_list); i++) {
+		enum st_ism330dhcx_sensor_id id = st_ism330dhcx_main_sensor_list[i];
+
+		hw->iio_devs[id] = st_ism330dhcx_alloc_iiodev(hw, id);
+		if (!hw->iio_devs[id])
+			return -ENOMEM;
+	}
+
+	err = st_ism330dhcx_shub_probe(hw);
+	if (err < 0)
+		return err;
+
+	if (hw->irq > 0) {
+		err = st_ism330dhcx_buffers_setup(hw);
+		if (err < 0)
+			return err;
+	}
+
+	for (i = 0; i < ST_ISM330DHCX_ID_MAX; i++) {
+		if (!hw->iio_devs[i])
+			continue;
+
+		err = devm_iio_device_register(hw->dev, hw->iio_devs[i]);
+		if (err)
+			return err;
+	}
+
+	device_init_wakeup(dev,
+			   device_property_read_bool(dev, "wakeup-source"));
+
+	dev_info(dev, "Device probed\n");
+
+	return 0;
+}
+EXPORT_SYMBOL(st_ism330dhcx_probe);
+
+static int __maybe_unused st_ism330dhcx_bk_regs(struct st_ism330dhcx_hw *hw)
+{
+	int i, err = 0;
+	u8 data, addr;
+
+	mutex_lock(&hw->page_lock);
+	for (i = 0; i < ST_ISM330DHCX_SUSPEND_RESUME_REGS; i++) {
+		addr = st_ism330dhcx_suspend_resume[i].addr;
+		err = hw->tf->read(hw->dev, addr, sizeof(data), &data);
+		if (err < 0) {
+			dev_err(hw->dev, "failed to read whoami register\n");
+			goto out_lock;
+		}
+
+	st_ism330dhcx_suspend_resume[i].val = data;
+	}
+
+out_lock:
+	mutex_unlock(&hw->page_lock);
+
+	return err;
+}
+
+static int __maybe_unused st_ism330dhcx_restore_regs(struct st_ism330dhcx_hw *hw)
+{
+	int i, err = 0;
+	u8 data, addr;
+
+	mutex_lock(&hw->page_lock);
+	for (i = 0; i < ST_ISM330DHCX_SUSPEND_RESUME_REGS; i++) {
+		addr = st_ism330dhcx_suspend_resume[i].addr;
+		err = hw->tf->read(hw->dev, addr, sizeof(data), &data);
+		if (err < 0) {
+			dev_err(hw->dev, "failed to read %02x reg\n", addr);
+			goto out_lock;
+		}
+
+		data &= ~st_ism330dhcx_suspend_resume[i].mask;
+		data |= (st_ism330dhcx_suspend_resume[i].val &
+			 st_ism330dhcx_suspend_resume[i].mask);
+
+		err = hw->tf->write(hw->dev, addr, sizeof(data), &data);
+		if (err < 0) {
+			dev_err(hw->dev, "failed to write %02x reg\n", addr);
+			goto out_lock;
+		}
+	}
+
+out_lock:
+	mutex_unlock(&hw->page_lock);
+
+	return err;
+}
+
+/**
+ * Power Management suspend callback [MODULE]
+ * Implements [MODULE] feature for Power Management
+ *
+ * @param  dev: Device pointer.
+ * @retval  0 is OK, negative value if ERROR
+ */
+static int __maybe_unused st_ism330dhcx_suspend(struct device *dev)
+{
+	struct st_ism330dhcx_hw *hw = dev_get_drvdata(dev);
+	struct st_ism330dhcx_sensor *sensor;
+	int i, err = 0;
+
+	dev_info(dev, "Suspending device\n");
+
+	for (i = 0; i < ST_ISM330DHCX_ID_MAX; i++) {
+		if (!hw->iio_devs[i])
+			continue;
+
+		sensor = iio_priv(hw->iio_devs[i]);
+		if (!(hw->enable_mask & BIT(sensor->id)))
+			continue;
+
+		/* power off enabled sensors */
+		err = st_ism330dhcx_set_odr(sensor, 0, 0);
+		if (err < 0)
+			return err;
+	}
+
+	if (st_ism330dhcx_is_fifo_enabled(hw)) {
+		err = st_ism330dhcx_suspend_fifo(hw);
+		if (err < 0)
+			return err;
+	}
+
+	err = st_ism330dhcx_bk_regs(hw);
+
+	if (device_may_wakeup(dev))
+		enable_irq_wake(hw->irq);
+
+	return err < 0 ? err : 0;
+}
+
+/**
+ * Power Management resume callback [MODULE]
+ * Implements [MODULE] feature for Power Management
+ *
+ * @param  dev: Device pointer.
+ * @retval  0 is OK, negative value if ERROR
+ */
+static int __maybe_unused st_ism330dhcx_resume(struct device *dev)
+{
+	struct st_ism330dhcx_hw *hw = dev_get_drvdata(dev);
+	struct st_ism330dhcx_sensor *sensor;
+	int i, err = 0;
+
+	dev_info(dev, "Resuming device\n");
+
+	if (device_may_wakeup(dev))
+		disable_irq_wake(hw->irq);
+
+	err = st_ism330dhcx_restore_regs(hw);
+	if (err < 0)
+		return err;
+
+	for (i = 0; i < ST_ISM330DHCX_ID_MAX; i++) {
+		if (!hw->iio_devs[i])
+			continue;
+
+		sensor = iio_priv(hw->iio_devs[i]);
+		if (!(hw->enable_mask & BIT(sensor->id)))
+			continue;
+
+		err = st_ism330dhcx_set_odr(sensor, sensor->odr, sensor->uodr);
+		if (err < 0)
+			return err;
+	}
+
+	err = st_ism330dhcx_reset_hwts(hw);
+	if (err < 0)
+		return err;
+
+	if (st_ism330dhcx_is_fifo_enabled(hw))
+		err = st_ism330dhcx_set_fifo_mode(hw, ST_ISM330DHCX_FIFO_CONT);
+
+	return err < 0 ? err : 0;
+}
+
+const struct dev_pm_ops st_ism330dhcx_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(st_ism330dhcx_suspend, st_ism330dhcx_resume)
+};
+EXPORT_SYMBOL(st_ism330dhcx_pm_ops);
+
+MODULE_AUTHOR("MEMS Software Solutions Team");
+MODULE_DESCRIPTION("STMicroelectronics st_ism330dhcx driver");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/iio/stm/imu/st_ism330dhcx/st_ism330dhcx_embfunc.c b/drivers/iio/stm/imu/st_ism330dhcx/st_ism330dhcx_embfunc.c
new file mode 100644
index 000000000..a15134b40
--- /dev/null
+++ b/drivers/iio/stm/imu/st_ism330dhcx/st_ism330dhcx_embfunc.c
@@ -0,0 +1,620 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * STMicroelectronics st_ism330dhcx embedded function sensor driver
+ *
+ * MEMS Software Solutions Team
+ *
+ * Copyright 2019 STMicroelectronics Inc.
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/iio/iio.h>
+
+#include "st_ism330dhcx.h"
+
+#define ST_ISM330DHCX_REG_PAGE_SEL_ADDR			0x02
+#define ST_ISM330DHCX_REG_PAGE_SEL_RST_MASK		BIT(0)
+
+#define ST_ISM330DHCX_REG_EMB_FUNC_EN_A_ADDR		0x04
+#define ST_ISM330DHCX_REG_PAGE_ADDRESS			0x08
+#define ST_ISM330DHCX_REG_PAGE_VALUE			0x09
+#define ST_ISM330DHCX_FSM_BASE_ADDRESS			0x2da
+
+#define ST_ISM330DHCX_REG_PEDO_EN_MASK			BIT(3)
+#define ST_ISM330DHCX_REG_TILT_EN_MASK			BIT(4)
+#define ST_ISM330DHCX_REG_SIGN_MOTION_EN_MASK		BIT(5)
+
+#define ST_ISM330DHCX_REG_INT_DTAP_MASK			BIT(3)
+#define ST_ISM330DHCX_REG_INT_STAP_MASK			BIT(6)
+
+#define ST_ISM330DHCX_REG_EMB_FUNC_EN_B_ADDR		0x05
+#define ST_ISM330DHCX_REG_FSM_EN_MASK			BIT(0)
+#define ST_ISM330DHCX_REG_INT_STEP_DET_MASK		BIT(3)
+#define ST_ISM330DHCX_REG_INT_TILT_MASK			BIT(4)
+#define ST_ISM330DHCX_REG_INT_SIGMOT_MASK			BIT(5)
+
+#define ST_ISM330DHCX_PAGE_RW_ADDR				0x17
+#define ST_ISM330DHCX_REG_WR_MASK				GENMASK(6, 5)
+#define ST_ISM330DHCX_REG_EMB_FUNC_LIR_MASK		BIT(7)
+
+#define ST_ISM330DHCX_REG_EMB_FUNC_FIFO_CFG_ADDR		0x44
+#define ST_ISM330DHCX_REG_PEDO_FIFO_EN_MASK		BIT(6)
+
+#define ST_ISM330DHCX_REG_FSM_ENABLE_A_ADDR		0x46
+#define ST_ISM330DHCX_REG_FSM_OUTS6_ADDR			0x51
+#define ST_ISM330DHCX_REG_ORIENTATION_0_MASK		BIT(5)
+#define ST_ISM330DHCX_REG_ORIENTATION_90_MASK		BIT(7)
+#define ST_ISM330DHCX_REG_ORIENTATION_180_MASK		BIT(4)
+#define ST_ISM330DHCX_REG_ORIENTATION_270_MASK		BIT(6)
+
+/* Finite State Machine ODR configuration */
+#define ST_ISM330DHCX_REG_EMB_FUNC_ODR_CFG_B_ADDR		0x5f
+#define ST_ISM330DHCX_REG_FSM_ODR_MASK			GENMASK(5, 3)
+#define ST_ISM330DHCX_FSM_ODR_12_5				0
+#define ST_ISM330DHCX_FSM_ODR_26				1
+#define ST_ISM330DHCX_FSM_ODR_52				2
+#define ST_ISM330DHCX_FSM_ODR_104				3
+#define ST_ISM330DHCX_FSM_ODR_208				4
+#define ST_ISM330DHCX_FSM_ODR_416				5
+
+#define ST_ISM330DHCX_REG_STEP_COUNTER_L_ADDR		0x62
+#define ST_ISM330DHCX_REG_EMB_FUNC_SRC_ADDR		0x64
+#define ST_ISM330DHCX_REG_PEDO_RST_STEP_MASK		BIT(7)
+
+#define ST_ISM330DHCX_FSM_MAX_SIZE				255
+
+/**
+ * @struct st_ism330dhcx_fsm_sensor
+ * @brief Single FSM description entry
+ *
+ * Implements #595543 Feature
+ *
+ * The following FSM state machine ISM330DHCX features listed in EX_FUN_FSM_SENSOR:
+ *
+ * SENSOR_TYPE_GLANCE_GESTURE
+ * SENSOR_TYPE_MOTION_DETECT
+ * SENSOR_TYPE_STATIONARY_DETECT
+ * SENSOR_TYPE_WAKE_GESTURE
+ * SENSOR_TYPE_PICK_UP_GESTURE
+ * SENSOR_TYPE_WRIST_TILT_GESTURE
+ *
+ * will be managed as event sensors
+ *
+ * data: FSM binary data block.
+ * id: Sensor Identifier.
+ * FSM binary data block len.
+ */
+struct st_ism330dhcx_fsm_sensor {
+	u8 data[ST_ISM330DHCX_FSM_MAX_SIZE];
+	enum st_ism330dhcx_sensor_id id;
+	u16 len;
+};
+
+static const struct st_ism330dhcx_fsm_sensor st_ism330dhcx_fsm_sensor_list[] = {
+	/* glance */
+	{
+		.id = ST_ISM330DHCX_ID_GLANCE,
+		.data = {
+			0xb2, 0x10, 0x24, 0x20, 0x17, 0x17, 0x66, 0x32,
+			0x66, 0x3c, 0x20, 0x20, 0x02, 0x02, 0x08, 0x08,
+			0x00, 0x04, 0x0c, 0x00, 0xc7, 0x66, 0x33, 0x73,
+			0x77, 0x64, 0x88, 0x75, 0x99, 0x66, 0x33, 0x53,
+			0x44, 0xf5, 0x22, 0x00,
+		},
+		.len = 36,
+	},
+	/* motion */
+	{
+		.id = ST_ISM330DHCX_ID_MOTION,
+		.data = {
+			0x51, 0x10, 0x16, 0x00, 0x00, 0x00, 0x66, 0x3c,
+			0x02, 0x00, 0x00, 0x7d, 0x00, 0xc7, 0x05, 0x99,
+			0x33, 0x53, 0x44, 0xf5, 0x22, 0x00,
+		},
+		.len = 22,
+	},
+	/* no motion */
+	{
+		.id = ST_ISM330DHCX_ID_NO_MOTION,
+		.data = {
+			0x51, 0x00, 0x10, 0x00, 0x00, 0x00, 0x66, 0x3c,
+			0x02, 0x00, 0x00, 0x7d, 0xff, 0x53, 0x99, 0x50,
+		},
+		.len = 16,
+	},
+	/* wakeup */
+	{
+		.id = ST_ISM330DHCX_ID_WAKEUP,
+		.data = {
+			0xe2, 0x00, 0x1e, 0x20, 0x13, 0x15, 0x66, 0x3e,
+			0x66, 0xbe, 0xcd, 0x3c, 0xc0, 0xc0, 0x02, 0x02,
+			0x0b, 0x10, 0x05, 0x66, 0xcc, 0x35, 0x38, 0x35,
+			0x77, 0xdd, 0x03, 0x54, 0x22, 0x00,
+		},
+		.len = 30,
+	},
+	/* pickup */
+	{
+		.id = ST_ISM330DHCX_ID_PICKUP,
+		.data = {
+			0x51, 0x00, 0x10, 0x00, 0x00, 0x00, 0x33, 0x3c,
+			0x02, 0x00, 0x00, 0x05, 0x05, 0x99, 0x30, 0x00,
+		},
+		.len = 16,
+	},
+	/* orientation */
+	{
+		.id = ST_ISM330DHCX_ID_ORIENTATION,
+		.data = {
+			0x91, 0x10, 0x16, 0x00, 0x00, 0x00, 0x66, 0x3a,
+			0x66, 0x32, 0xf0, 0x00, 0x00, 0x0d, 0x00, 0xc7,
+			0x05, 0x73, 0x99, 0x08, 0xf5, 0x22,
+		},
+		.len = 22,
+	},
+	/* wrist tilt */
+	{
+		.id = ST_ISM330DHCX_ID_WRIST_TILT,
+		.data = {
+			0x52, 0x00, 0x14, 0x00, 0x00, 0x00, 0xae, 0xb7,
+			0x80, 0x00, 0x00, 0x06, 0x0f, 0x05, 0x73, 0x33,
+			0x07, 0x54, 0x44, 0x22,
+		},
+		.len = 20,
+	},
+};
+
+struct st_ism330dhcx_fsm_fs {
+	u32 gain;
+	__le16 val;
+};
+
+static const struct st_ism330dhcx_fsm_fs st_ism330dhcx_fsm_fs_table[] = {
+	{  ST_ISM330DHCX_ACC_FS_2G_GAIN, 0x03ff },
+	{  ST_ISM330DHCX_ACC_FS_4G_GAIN, 0x07fe },
+	{  ST_ISM330DHCX_ACC_FS_8G_GAIN, 0x0bfe },
+	{ ST_ISM330DHCX_ACC_FS_16G_GAIN, 0x0ffe },
+};
+
+static inline
+int st_ism330dhcx_fsm_set_access(struct st_ism330dhcx_hw *hw, bool enable)
+{
+	u8 val = enable ? 2 : 0;
+
+	return __st_ism330dhcx_write_with_mask(hw,
+					    ST_ISM330DHCX_PAGE_RW_ADDR,
+					    ST_ISM330DHCX_REG_WR_MASK,
+					    val);
+}
+
+static int st_ism330dhcx_fsm_write(struct st_ism330dhcx_hw *hw, u16 base_addr,
+				int len, const u8 *data)
+{
+	u8 msb, lsb;
+	int i, err;
+
+	msb = (((base_addr >> 8) & 0xf) << 4) | 1;
+	lsb = base_addr & 0xff;
+
+	err = hw->tf->write(hw->dev,
+			    ST_ISM330DHCX_REG_PAGE_ADDRESS,
+			    sizeof(lsb),
+			    &lsb);
+	if (err < 0)
+		return err;
+
+	err = hw->tf->write(hw->dev,
+			    ST_ISM330DHCX_REG_PAGE_SEL_ADDR,
+			    sizeof(msb),
+			    &msb);
+	if (err < 0)
+		return err;
+
+	for (i = 0; i < len; i++) {
+		err = hw->tf->write(hw->dev,
+				    ST_ISM330DHCX_REG_PAGE_VALUE,
+				    sizeof(u8),
+				    &data[i]);
+		if (err < 0)
+			return err;
+
+		if (++lsb == 0) {
+			msb += (1 << 4);
+			err = hw->tf->write(hw->dev,
+					    ST_ISM330DHCX_REG_PAGE_SEL_ADDR,
+					    sizeof(msb),
+					    &msb);
+			if (err < 0)
+				return err;
+		}
+	}
+
+	return err;
+}
+
+static int st_ism330dhcx_ef_pg1_sensor_set_enable(struct st_ism330dhcx_sensor *sensor,
+					       u8 mask, u8 irq_mask,
+					       bool enable)
+{
+	struct st_ism330dhcx_hw *hw = sensor->hw;
+	int err;
+
+	err = st_ism330dhcx_sensor_set_enable(sensor, enable);
+	if (err < 0)
+		return err;
+
+	mutex_lock(&hw->page_lock);
+	err = st_ism330dhcx_set_page_access(hw, ST_ISM330DHCX_REG_FUNC_CFG_MASK,
+					 true);
+	if (err < 0)
+		goto unlock;
+
+	err = __st_ism330dhcx_write_with_mask(hw,
+					   ST_ISM330DHCX_REG_EMB_FUNC_EN_A_ADDR,
+					   mask, enable);
+	if (err < 0)
+		goto reset_page;
+
+	err = __st_ism330dhcx_write_with_mask(hw, hw->embfunc_irq_reg, irq_mask,
+					   enable);
+reset_page:
+	st_ism330dhcx_set_page_access(hw, ST_ISM330DHCX_REG_FUNC_CFG_MASK, false);
+unlock:
+	mutex_unlock(&hw->page_lock);
+
+	return err;
+}
+
+/**
+ * FSM Function sensor [FSM_FUN]
+ *
+ * @param  sensor: ST IMU sensor instance
+ * @param  enable: Enable/Disable sensor
+ * @return  < 0 if error, 0 otherwise
+ */
+static int st_ism330dhcx_fsm_set_enable(struct st_ism330dhcx_sensor *sensor,
+				     bool enable)
+{
+	struct st_ism330dhcx_hw *hw = sensor->hw;
+	u16 enable_mask = hw->fsm_enable_mask;
+	int err, i;
+
+	for (i = 0; i < ARRAY_SIZE(st_ism330dhcx_fsm_sensor_list); i++)
+		if (st_ism330dhcx_fsm_sensor_list[i].id == sensor->id)
+			break;
+
+	if (i == ARRAY_SIZE(st_ism330dhcx_fsm_sensor_list))
+		return -EINVAL;
+
+	err = st_ism330dhcx_sensor_set_enable(sensor, enable);
+	if (err < 0)
+		return err;
+
+	mutex_lock(&hw->page_lock);
+	err = st_ism330dhcx_set_page_access(hw, ST_ISM330DHCX_REG_FUNC_CFG_MASK,
+					 true);
+	if (err < 0)
+		goto unlock;
+
+	if (enable)
+		enable_mask |= BIT(i);
+	else
+		enable_mask &= ~BIT(i);
+
+	err = hw->tf->write(hw->dev, ST_ISM330DHCX_REG_FSM_ENABLE_A_ADDR,
+			    sizeof(enable_mask), (u8 *)&enable_mask);
+	if (err < 0)
+		goto reset_page;
+
+	hw->fsm_enable_mask = enable_mask;
+
+reset_page:
+	st_ism330dhcx_set_page_access(hw, ST_ISM330DHCX_REG_FUNC_CFG_MASK, false);
+unlock:
+	mutex_unlock(&hw->page_lock);
+
+	return err;
+}
+
+/**
+ * Enable Embedded Function sensor [EMB_FUN]
+ *
+ * @param  sensor: ST IMU sensor instance
+ * @param  enable: Enable/Disable sensor
+ * @return  < 0 if error, 0 otherwise
+ */
+int st_ism330dhcx_embfunc_sensor_set_enable(struct st_ism330dhcx_sensor *sensor,
+					 bool enable)
+{
+	int err;
+
+	switch (sensor->id) {
+	case ST_ISM330DHCX_ID_STEP_DETECTOR:
+		err = st_ism330dhcx_ef_pg1_sensor_set_enable(sensor,
+					ST_ISM330DHCX_REG_PEDO_EN_MASK,
+					ST_ISM330DHCX_REG_INT_STEP_DET_MASK,
+					enable);
+		break;
+	case ST_ISM330DHCX_ID_SIGN_MOTION:
+		err = st_ism330dhcx_ef_pg1_sensor_set_enable(sensor,
+					ST_ISM330DHCX_REG_SIGN_MOTION_EN_MASK,
+					ST_ISM330DHCX_REG_INT_SIGMOT_MASK,
+					enable);
+		break;
+	case ST_ISM330DHCX_ID_TILT:
+		err = st_ism330dhcx_ef_pg1_sensor_set_enable(sensor,
+						ST_ISM330DHCX_REG_TILT_EN_MASK,
+						ST_ISM330DHCX_REG_TILT_EN_MASK,
+						enable);
+		break;
+	case ST_ISM330DHCX_ID_NO_MOTION:
+	case ST_ISM330DHCX_ID_MOTION:
+	case ST_ISM330DHCX_ID_WAKEUP:
+	case ST_ISM330DHCX_ID_PICKUP:
+	case ST_ISM330DHCX_ID_ORIENTATION:
+	case ST_ISM330DHCX_ID_WRIST_TILT:
+	case ST_ISM330DHCX_ID_GLANCE:
+		err = st_ism330dhcx_fsm_set_enable(sensor, enable);
+		break;
+	default:
+		err = -EINVAL;
+		break;
+	}
+
+	return err;
+}
+
+/**
+ * Enable Step Counter Sensor [EMB_FUN]
+ *
+ * @param  sensor: ST IMU sensor instance
+ * @param  enable: Enable/Disable sensor
+ * @return  < 0 if error, 0 otherwise
+ */
+int st_ism330dhcx_step_counter_set_enable(struct st_ism330dhcx_sensor *sensor,
+				       bool enable)
+{
+	struct st_ism330dhcx_hw *hw = sensor->hw;
+	int err;
+
+	err = st_ism330dhcx_sensor_set_enable(sensor, enable);
+	if (err < 0)
+		return err;
+
+	mutex_lock(&hw->page_lock);
+	err = st_ism330dhcx_set_page_access(hw, ST_ISM330DHCX_REG_FUNC_CFG_MASK,
+					 true);
+	if (err < 0)
+		goto unlock;
+
+	err = __st_ism330dhcx_write_with_mask(hw,
+					   ST_ISM330DHCX_REG_EMB_FUNC_EN_A_ADDR,
+					   ST_ISM330DHCX_REG_PEDO_EN_MASK,
+					   enable);
+	if (err < 0)
+		goto reset_page;
+
+	err = __st_ism330dhcx_write_with_mask(hw,
+					ST_ISM330DHCX_REG_EMB_FUNC_FIFO_CFG_ADDR,
+					ST_ISM330DHCX_REG_PEDO_FIFO_EN_MASK,
+					enable);
+
+reset_page:
+	st_ism330dhcx_set_page_access(hw, ST_ISM330DHCX_REG_FUNC_CFG_MASK, false);
+unlock:
+	mutex_unlock(&hw->page_lock);
+
+	return err;
+}
+
+/**
+ * Reset Step Counter value [EMB_FUN]
+ *
+ * @param  iio_dev: IIO device
+ * @return  < 0 if error, 0 otherwise
+ */
+int st_ism330dhcx_reset_step_counter(struct iio_dev *iio_dev)
+{
+	struct st_ism330dhcx_sensor *sensor = iio_priv(iio_dev);
+	struct st_ism330dhcx_hw *hw = sensor->hw;
+	u16 prev_val, val = 0;
+	__le16 data;
+	int err;
+
+	mutex_lock(&iio_dev->mlock);
+	if (iio_buffer_enabled(iio_dev)) {
+		err = -EBUSY;
+		goto unlock_iio_dev;
+	}
+
+	err = st_ism330dhcx_step_counter_set_enable(sensor, true);
+	if (err < 0)
+		goto unlock_iio_dev;
+
+	mutex_lock(&hw->page_lock);
+	err = st_ism330dhcx_set_page_access(hw, ST_ISM330DHCX_REG_FUNC_CFG_MASK,
+					 true);
+	if (err < 0)
+		goto unlock_page;
+
+	do {
+		prev_val = val;
+		err = __st_ism330dhcx_write_with_mask(hw,
+					ST_ISM330DHCX_REG_EMB_FUNC_SRC_ADDR,
+					ST_ISM330DHCX_REG_PEDO_RST_STEP_MASK, 1);
+		if (err < 0)
+			goto reset_page;
+
+		msleep(100);
+
+		err = hw->tf->read(hw->dev,
+				   ST_ISM330DHCX_REG_STEP_COUNTER_L_ADDR,
+				   sizeof(data), (u8 *)&data);
+		if (err < 0)
+			goto reset_page;
+
+		val = le16_to_cpu(data);
+	} while (val && val >= prev_val);
+
+reset_page:
+	st_ism330dhcx_set_page_access(hw, ST_ISM330DHCX_REG_FUNC_CFG_MASK, false);
+unlock_page:
+	mutex_unlock(&hw->page_lock);
+
+	err = st_ism330dhcx_step_counter_set_enable(sensor, false);
+unlock_iio_dev:
+	mutex_unlock(&iio_dev->mlock);
+
+	return err;
+}
+
+/**
+ * Read Orientation data sensor [EMB_FUN]
+ *
+ * @param  hw: ST IMU MEMS hw instance.
+ * @param  out: Out data buffer.
+ * @return  < 0 if error, 0 otherwise
+ */
+int st_ism330dhcx_fsm_get_orientation(struct st_ism330dhcx_hw *hw, u8 *out)
+{
+	int err;
+	u8 data;
+
+	mutex_lock(&hw->page_lock);
+	err = st_ism330dhcx_set_page_access(hw, ST_ISM330DHCX_REG_FUNC_CFG_MASK,
+					 true);
+	if (err < 0)
+		goto unlock;
+
+	err = hw->tf->read(hw->dev, ST_ISM330DHCX_REG_FSM_OUTS6_ADDR,
+			   sizeof(data), &data);
+	if (err < 0)
+		goto reset_page;
+
+	switch (data) {
+	case ST_ISM330DHCX_REG_ORIENTATION_0_MASK:
+		*out = 0;
+		break;
+	case ST_ISM330DHCX_REG_ORIENTATION_90_MASK:
+		*out = 1;
+		break;
+	case ST_ISM330DHCX_REG_ORIENTATION_180_MASK:
+		*out = 2;
+		break;
+	case ST_ISM330DHCX_REG_ORIENTATION_270_MASK:
+		*out = 3;
+		break;
+	default:
+		err = -EINVAL;
+		break;
+	}
+
+reset_page:
+	st_ism330dhcx_set_page_access(hw, ST_ISM330DHCX_REG_FUNC_CFG_MASK, false);
+unlock:
+	mutex_unlock(&hw->page_lock);
+
+	return err;
+}
+
+
+/**
+ * Initialize Finite State Machine HW block [FSM_FUN]
+ *
+ * @param  hw: ST IMU MEMS hw instance
+ * @return  < 0 if error, 0 otherwise
+ */
+int st_ism330dhcx_fsm_init(struct st_ism330dhcx_hw *hw)
+{
+	u8 nfsm[] = {
+		ARRAY_SIZE(st_ism330dhcx_fsm_sensor_list),
+		ARRAY_SIZE(st_ism330dhcx_fsm_sensor_list)
+	};
+	__le16 irq_mask, fsm_addr = ST_ISM330DHCX_FSM_BASE_ADDRESS;
+	u8 val[2] = {};
+	int i, err;
+
+	mutex_lock(&hw->page_lock);
+	err = st_ism330dhcx_set_page_access(hw, ST_ISM330DHCX_REG_FUNC_CFG_MASK,
+					 true);
+	if (err < 0)
+		goto unlock;
+
+	/* enable gesture rec */
+	err = __st_ism330dhcx_write_with_mask(hw,
+					   ST_ISM330DHCX_REG_EMB_FUNC_EN_B_ADDR,
+					   ST_ISM330DHCX_REG_FSM_EN_MASK,
+					   1);
+	if (err < 0)
+		goto reset_page;
+
+	/* gest rec ODR 52Hz */
+	err = __st_ism330dhcx_write_with_mask(hw,
+					ST_ISM330DHCX_REG_EMB_FUNC_ODR_CFG_B_ADDR,
+					ST_ISM330DHCX_REG_FSM_ODR_MASK,
+					ST_ISM330DHCX_FSM_ODR_52);
+	if (err < 0)
+		goto reset_page;
+
+	/* disable all fsm sensors */
+	err = hw->tf->write(hw->dev, ST_ISM330DHCX_REG_FSM_ENABLE_A_ADDR,
+			    sizeof(val), val);
+	if (err < 0)
+		goto reset_page;
+
+	/* enable fsm interrupt */
+	irq_mask = (1 << ARRAY_SIZE(st_ism330dhcx_fsm_sensor_list)) - 1;
+	err = hw->tf->write(hw->dev, hw->embfunc_irq_reg + 1,
+			    sizeof(irq_mask),
+			    (u8 *)&irq_mask);
+	if (err < 0)
+		goto reset_page;
+
+	/* enable latched interrupts */
+	err  = __st_ism330dhcx_write_with_mask(hw,
+					    ST_ISM330DHCX_PAGE_RW_ADDR,
+					    ST_ISM330DHCX_REG_EMB_FUNC_LIR_MASK,
+					    1);
+	if (err < 0)
+		goto reset_page;
+
+	/* enable access */
+	err = st_ism330dhcx_fsm_set_access(hw, true);
+	if (err < 0)
+		return err;
+
+	/* # of configured fsm */
+	err = st_ism330dhcx_fsm_write(hw, 0x17c, sizeof(nfsm), nfsm);
+	if (err < 0)
+		goto reset_access;
+
+	err = st_ism330dhcx_fsm_write(hw, 0x17e, sizeof(fsm_addr), (u8 *)
+				   &fsm_addr);
+	if (err < 0)
+		goto reset_access;
+
+	/* configure fsm */
+	for (i = 0; i < ARRAY_SIZE(st_ism330dhcx_fsm_sensor_list); i++) {
+		err = st_ism330dhcx_fsm_write(hw, fsm_addr,
+					st_ism330dhcx_fsm_sensor_list[i].len,
+					st_ism330dhcx_fsm_sensor_list[i].data);
+		if (err < 0)
+			goto reset_access;
+
+		fsm_addr += st_ism330dhcx_fsm_sensor_list[i].len;
+	}
+
+reset_access:
+	st_ism330dhcx_fsm_set_access(hw, false);
+
+	__st_ism330dhcx_write_with_mask(hw,
+				     ST_ISM330DHCX_REG_PAGE_SEL_ADDR,
+				     ST_ISM330DHCX_REG_PAGE_SEL_RST_MASK, 1);
+reset_page:
+	st_ism330dhcx_set_page_access(hw, ST_ISM330DHCX_REG_FUNC_CFG_MASK, false);
+unlock:
+	mutex_unlock(&hw->page_lock);
+
+	return err;
+}
diff --git a/drivers/iio/stm/imu/st_ism330dhcx/st_ism330dhcx_i2c.c b/drivers/iio/stm/imu/st_ism330dhcx/st_ism330dhcx_i2c.c
new file mode 100644
index 000000000..522425049
--- /dev/null
+++ b/drivers/iio/stm/imu/st_ism330dhcx/st_ism330dhcx_i2c.c
@@ -0,0 +1,97 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * STMicroelectronics st_ism330dhcx i2c driver
+ *
+ * MEMS Software Solutions Team
+ *
+ * Copyright 2020 STMicroelectronics Inc.
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/i2c.h>
+#include <linux/slab.h>
+#include <linux/of.h>
+
+#include "st_ism330dhcx.h"
+
+static int st_ism330dhcx_i2c_read(struct device *dev, u8 addr,
+			       int len, u8 *data)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct i2c_msg msg[2];
+
+	msg[0].addr = client->addr;
+	msg[0].flags = client->flags;
+	msg[0].len = 1;
+	msg[0].buf = &addr;
+
+	msg[1].addr = client->addr;
+	msg[1].flags = client->flags | I2C_M_RD;
+	msg[1].len = len;
+	msg[1].buf = data;
+
+	return i2c_transfer(client->adapter, msg, 2);
+}
+
+static int st_ism330dhcx_i2c_write(struct device *dev, u8 addr, int len,
+				const u8 *data)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct i2c_msg msg;
+	u8 send[8];
+
+	if (len >= ARRAY_SIZE(send))
+		return -ENOMEM;
+
+	send[0] = addr;
+	memcpy(&send[1], data, len * sizeof(u8));
+
+	msg.addr = client->addr;
+	msg.flags = client->flags;
+	msg.len = len + 1;
+	msg.buf = send;
+
+	return i2c_transfer(client->adapter, &msg, 1);
+}
+
+static const struct st_ism330dhcx_transfer_function st_ism330dhcx_transfer_fn = {
+	.read = st_ism330dhcx_i2c_read,
+	.write = st_ism330dhcx_i2c_write,
+};
+
+static int st_ism330dhcx_i2c_probe(struct i2c_client *client,
+				const struct i2c_device_id *id)
+{
+	return st_ism330dhcx_probe(&client->dev, client->irq,
+				&st_ism330dhcx_transfer_fn);
+}
+
+static const struct of_device_id st_ism330dhcx_i2c_of_match[] = {
+	{
+		.compatible = "st,ism330dhcx",
+	},
+	{},
+};
+MODULE_DEVICE_TABLE(of, st_ism330dhcx_i2c_of_match);
+
+static const struct i2c_device_id st_ism330dhcx_i2c_id_table[] = {
+	{ ST_ISM330DHCX_DEV_NAME },
+	{},
+};
+MODULE_DEVICE_TABLE(i2c, st_ism330dhcx_i2c_id_table);
+
+static struct i2c_driver st_ism330dhcx_driver = {
+	.driver = {
+		.name = "st_ism330dhcx_i2c",
+		.pm = &st_ism330dhcx_pm_ops,
+		.of_match_table = of_match_ptr(st_ism330dhcx_i2c_of_match),
+	},
+	.probe = st_ism330dhcx_i2c_probe,
+	.id_table = st_ism330dhcx_i2c_id_table,
+};
+module_i2c_driver(st_ism330dhcx_driver);
+
+MODULE_AUTHOR("MEMS Software Solutions Team");
+MODULE_DESCRIPTION("STMicroelectronics st_ism330dhcx i2c driver");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/iio/stm/imu/st_ism330dhcx/st_ism330dhcx_shub.c b/drivers/iio/stm/imu/st_ism330dhcx/st_ism330dhcx_shub.c
new file mode 100644
index 000000000..875ad1f23
--- /dev/null
+++ b/drivers/iio/stm/imu/st_ism330dhcx/st_ism330dhcx_shub.c
@@ -0,0 +1,1006 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * STMicroelectronics st_ism330dhcx sensor hub library driver
+ *
+ * MEMS Software Solutions Team
+ *
+ * Copyright 2020 STMicroelectronics Inc.
+ */
+
+#include <linux/module.h>
+#include <linux/delay.h>
+#include <linux/iio/iio.h>
+#include <linux/iio/sysfs.h>
+#include <asm/unaligned.h>
+
+#include "st_ism330dhcx.h"
+
+#define ST_ISM330DHCX_REG_MASTER_CONFIG_ADDR	0x14
+#define ST_ISM330DHCX_REG_WRITE_ONCE_MASK		BIT(6)
+#define ST_ISM330DHCX_REG_MASTER_ON_MASK		BIT(2)
+
+#define ST_ISM330DHCX_REG_SLV0_ADDR		0x15
+#define ST_ISM330DHCX_REG_SLV0_CFG			0x17
+#define ST_ISM330DHCX_REG_SLV1_ADDR		0x18
+#define ST_ISM330DHCX_REG_SLV2_ADDR		0x1b
+#define ST_ISM330DHCX_REG_SLV3_ADDR		0x1e
+#define ST_ISM330DHCX_REG_DATAWRITE_SLV0_ADDR	0x21
+#define ST_ISM330DHCX_REG_BATCH_EXT_SENS_EN_MASK	BIT(3)
+#define ST_ISM330DHCX_REG_SLAVE_NUMOP_MASK		GENMASK(2, 0)
+
+#define ST_ISM330DHCX_REG_SLV0_OUT_ADDR		0x02
+#define ST_ISM330DHCX_MAX_SLV_NUM			2
+
+/**
+ * @struct  st_ism330dhcx_ext_pwr
+ * @brief  External device Power Management description
+ * reg: Generic sensor register description.
+ * off_val: Value to write into register to power off external sensor.
+ * on_val: Value to write into register for power on external sensor.
+ */
+struct st_ism330dhcx_ext_pwr {
+	struct st_ism330dhcx_reg reg;
+	u8 off_val;
+	u8 on_val;
+};
+
+/**
+ * @struct  st_ism330dhcx_ext_dev_settings
+ * @brief  External sensor descritor entry
+ * i2c_addr: External I2C device address (max two).
+ * wai_addr: Device ID address.
+ * wai_val: Device ID value.
+ * odr_table: ODR sensor table.
+ * fs_table: Full scale table.
+ * temp_comp_reg: Temperature compensation registers.
+ * pwr_table: External device Power Management description.
+ * off_canc_reg: Offset cancellation registers.
+ * bdu_reg: Block Data Update registers.
+ * ext_available_scan_masks: IIO device scan mask.
+ * ext_channels:IIO device channel specifications.
+ * ext_chan_depth: Max number of IIO device channel specifications.
+ * data_len: Sensor output data len.
+ */
+struct st_ism330dhcx_ext_dev_settings {
+	u8 i2c_addr[2];
+	u8 wai_addr;
+	u8 wai_val;
+	struct st_ism330dhcx_odr_table_entry odr_table;
+	struct st_ism330dhcx_fs_table_entry fs_table;
+	struct st_ism330dhcx_reg temp_comp_reg;
+	struct st_ism330dhcx_ext_pwr pwr_table;
+	struct st_ism330dhcx_reg off_canc_reg;
+	struct st_ism330dhcx_reg bdu_reg;
+	unsigned long ext_available_scan_masks[2];
+	const struct iio_chan_spec ext_channels[5];
+	u8 ext_chan_depth;
+	u8 data_len;
+};
+
+static const struct st_ism330dhcx_ext_dev_settings st_ism330dhcx_ext_dev_table[] = {
+	/* LIS2MDL */
+	{
+		.i2c_addr = { 0x1e },
+		.wai_addr = 0x4f,
+		.wai_val = 0x40,
+		.odr_table = {
+			.odr_size = 5,
+			.reg = {
+				.addr = 0x60,
+				.mask = GENMASK(3, 2),
+			},
+			/*
+			 * added 5Hz for CTS coverage, reg value is the same
+			 * for 5 and 10 Hz
+			 */
+			.odr_avl[0] = {   5,  1,  0x0 },
+			.odr_avl[1] = {  10,  0,  0x0 },
+			.odr_avl[2] = {  20,  0,  0x1 },
+			.odr_avl[3] = {  50,  0,  0x2 },
+			.odr_avl[4] = { 100,  0,  0x3 },
+		},
+		.fs_table = {
+			.size = 1,
+			.fs_avl[0] = {
+				.gain = 1500,
+				.val = 0x0,
+			}, /* 1500 uG/LSB */
+		},
+		.temp_comp_reg = {
+			.addr = 0x60,
+			.mask = BIT(7),
+		},
+		.pwr_table = {
+			.reg = {
+				.addr = 0x60,
+				.mask = GENMASK(1, 0),
+			},
+			.off_val = 0x2,
+			.on_val = 0x0,
+		},
+		.off_canc_reg = {
+			.addr = 0x61,
+			.mask = BIT(1),
+		},
+		.bdu_reg = {
+			.addr = 0x62,
+			.mask = BIT(4),
+		},
+		.ext_available_scan_masks = { 0x7, 0x0 },
+		.ext_channels[0] = ST_ISM330DHCX_DATA_CHANNEL(IIO_MAGN, 0x68,
+							   1, IIO_MOD_X, 0,
+							   16, 16, 's'),
+		.ext_channels[1] = ST_ISM330DHCX_DATA_CHANNEL(IIO_MAGN, 0x6a,
+							   1, IIO_MOD_Y, 1,
+							   16, 16, 's'),
+		.ext_channels[2] = ST_ISM330DHCX_DATA_CHANNEL(IIO_MAGN, 0x6c,
+							   1, IIO_MOD_Z, 2,
+							   16, 16, 's'),
+		.ext_channels[3] = ST_ISM330DHCX_EVENT_CHANNEL(IIO_MAGN, flush),
+		.ext_channels[4] = IIO_CHAN_SOFT_TIMESTAMP(3),
+		.ext_chan_depth = 5,
+		.data_len = 6,
+	},
+	/* LPS22HB */
+	{
+		.i2c_addr = { 0x5c, 0x5d },
+		.wai_addr = 0x0f,
+		.wai_val = 0xb1,
+		.odr_table = {
+			.odr_size = 4,
+			.reg = {
+				.addr = 0x10,
+				.mask = GENMASK(6, 4),
+			},
+			.odr_avl[0] = {  1,  0,  0x1 },
+			.odr_avl[1] = { 10,  0,  0x2 },
+			.odr_avl[2] = { 25,  0,  0x3 },
+			.odr_avl[3] = { 50,  0,  0x4 },
+		},
+		.fs_table = {
+			.size = 1,
+			/* hPa miscro scale */
+			.fs_avl[0] = {
+				.gain = 1000000UL/4096UL,
+				.val = 0x0,
+			},
+		},
+		.bdu_reg = {
+			.addr = 0x10,
+			.mask = BIT(1),
+		},
+		.ext_available_scan_masks = { 0x1, 0x0 },
+		.ext_channels[0] = ST_ISM330DHCX_DATA_CHANNEL(IIO_PRESSURE, 0x28,
+							   0, IIO_NO_MOD, 0,
+							   24, 32, 'u'),
+		.ext_channels[1] = ST_ISM330DHCX_EVENT_CHANNEL(IIO_PRESSURE,
+							    flush),
+		.ext_channels[2] = IIO_CHAN_SOFT_TIMESTAMP(1),
+		.ext_chan_depth = 3,
+		.data_len = 3,
+	},
+	/* LPS22HH */
+	{
+		.i2c_addr = { 0x5c, 0x5d },
+		.wai_addr = 0x0f,
+		.wai_val = 0xb4,
+		.odr_table = {
+			.odr_size = 5,
+			.reg = {
+				.addr = 0x10,
+				.mask = GENMASK(6, 4),
+			},
+			.odr_avl[0] = {   1,  0,  0x1 },
+			.odr_avl[1] = {  10,  0,  0x2 },
+			.odr_avl[2] = {  25,  0,  0x3 },
+			.odr_avl[3] = {  50,  0,  0x4 },
+			.odr_avl[4] = { 100,  0,  0x6 },
+		},
+		.fs_table = {
+			.size = 1,
+			/* hPa miscro scale */
+			.fs_avl[0] = {
+				.gain = 1000000UL/4096UL,
+				.val = 0x0,
+			},
+		},
+		.bdu_reg = {
+			.addr = 0x10,
+			.mask = BIT(1),
+		},
+		.ext_available_scan_masks = { 0x1, 0x0 },
+		.ext_channels[0] = ST_ISM330DHCX_DATA_CHANNEL(IIO_PRESSURE, 0x28,
+							   0, IIO_NO_MOD, 0,
+							   24, 32, 'u'),
+		.ext_channels[1] = ST_ISM330DHCX_EVENT_CHANNEL(IIO_PRESSURE,
+							    flush),
+		.ext_channels[2] = IIO_CHAN_SOFT_TIMESTAMP(1),
+		.ext_chan_depth = 3,
+		.data_len = 3,
+	},
+};
+
+/**
+ * Wait write trigger [SHUB]
+ *
+ * In write on external deivice register, each operation is triggered
+ * by accel/gyro data ready, this means that wait time depends on ODR
+ * plus i2c time
+ * NOTE: Be sure to enable Acc or Gyro before this operation
+ *
+ * @param  hw: ST IMU MEMS hw instance.
+ */
+static inline void st_ism330dhcx_shub_wait_complete(struct st_ism330dhcx_hw *hw)
+{
+	struct st_ism330dhcx_sensor *sensor;
+	u16 odr;
+
+	sensor = iio_priv(hw->iio_devs[ST_ISM330DHCX_ID_ACC]);
+	/* check if acc is enabled */
+	odr = (hw->enable_mask & BIT(ST_ISM330DHCX_ID_ACC)) ? sensor->odr : 13;
+	msleep((2000U / odr) + 1);
+}
+
+/**
+ * Read from sensor hub bank register [SHUB]
+ *
+ * NOTE: uses page_lock
+ *
+ * @param  hw: ST IMU MEMS hw instance.
+ * @param  addr: Remote address register.
+ * @param  data: Data buffer.
+ * @param  len: Data read len.
+ * @return  0 if OK, < 0 if ERROR
+ */
+static int st_ism330dhcx_shub_read_reg(struct st_ism330dhcx_hw *hw, u8 addr,
+				    u8 *data, int len)
+{
+	int err;
+
+	mutex_lock(&hw->page_lock);
+	err = st_ism330dhcx_set_page_access(hw, ST_ISM330DHCX_REG_SHUB_REG_MASK,
+					 true);
+	if (err < 0)
+		goto out;
+
+	err = hw->tf->read(hw->dev, addr, len, data);
+
+	st_ism330dhcx_set_page_access(hw, ST_ISM330DHCX_REG_SHUB_REG_MASK, false);
+out:
+	mutex_unlock(&hw->page_lock);
+
+	return err;
+}
+
+/**
+ * Write to sensor hub bank register [SHUB]
+ *
+ * NOTE: uses page_lock
+ *
+ * @param  hw: ST IMU MEMS hw instance.
+ * @param  addr: Remote address register.
+ * @param  data: Data buffer.
+ * @param  len: Data read len.
+ * @return  0 if OK, < 0 if ERROR
+ */
+static int st_ism330dhcx_shub_write_reg(struct st_ism330dhcx_hw *hw, u8 addr,
+				     u8 *data, int len)
+{
+	int err;
+
+	mutex_lock(&hw->page_lock);
+	err = st_ism330dhcx_set_page_access(hw, ST_ISM330DHCX_REG_SHUB_REG_MASK,
+					 true);
+	if (err < 0)
+		goto out;
+
+	err = hw->tf->write(hw->dev, addr, len, data);
+
+	st_ism330dhcx_set_page_access(hw, ST_ISM330DHCX_REG_SHUB_REG_MASK, false);
+out:
+	mutex_unlock(&hw->page_lock);
+
+	return err;
+}
+
+/**
+ * Enable sensor hub interface [SHUB]
+ *
+ * NOTE: uses page_lock
+ *
+ * @param  sensor: ST IMU sensor instance
+ * @param  enable: Master Enable/Disable.
+ * @return  0 if OK, < 0 if ERROR
+ */
+static int st_ism330dhcx_shub_master_enable(struct st_ism330dhcx_sensor *sensor,
+					 bool enable)
+{
+	struct st_ism330dhcx_hw *hw = sensor->hw;
+	int err;
+
+	/* enable acc sensor as trigger */
+	err = st_ism330dhcx_sensor_set_enable(sensor, enable);
+	if (err < 0)
+		return err;
+
+	mutex_lock(&hw->page_lock);
+	err = st_ism330dhcx_set_page_access(hw, ST_ISM330DHCX_REG_SHUB_REG_MASK,
+					 true);
+	if (err < 0)
+		goto out;
+
+	err = __st_ism330dhcx_write_with_mask(hw,
+				ST_ISM330DHCX_REG_MASTER_CONFIG_ADDR,
+				ST_ISM330DHCX_REG_MASTER_ON_MASK,
+				enable);
+
+	st_ism330dhcx_set_page_access(hw, ST_ISM330DHCX_REG_SHUB_REG_MASK, false);
+
+out:
+	mutex_unlock(&hw->page_lock);
+
+	return err;
+}
+
+/**
+ * Read sensor data register from shub interface
+ *
+ * NOTE: use SLV3 i2c slave for one-shot read operation
+ *
+ * @param  sensor: ST IMU sensor instance
+ * @param  addr: Remote address register.
+ * @param  data: Data buffer.
+ * @param  len: Data read len.
+ * @return  0 if OK, < 0 if ERROR
+ */
+static int st_ism330dhcx_shub_read(struct st_ism330dhcx_sensor *sensor, u8 addr,
+				u8 *data, int len)
+{
+	struct st_ism330dhcx_ext_dev_info *ext_info = &sensor->ext_dev_info;
+	struct st_ism330dhcx_hw *hw = sensor->hw;
+	u8 out_addr = ST_ISM330DHCX_REG_SLV0_OUT_ADDR + hw->ext_data_len;
+	u8 config[3];
+	int err;
+
+	config[0] = (ext_info->ext_dev_i2c_addr << 1) | 1;
+	config[1] = addr;
+	config[2] = len & 0x7;
+
+	err = st_ism330dhcx_shub_write_reg(hw, ST_ISM330DHCX_REG_SLV3_ADDR,
+					config, sizeof(config));
+	if (err < 0)
+		return err;
+
+	err = st_ism330dhcx_shub_master_enable(sensor, true);
+	if (err < 0)
+		return err;
+
+	st_ism330dhcx_shub_wait_complete(hw);
+
+	err = st_ism330dhcx_shub_read_reg(hw, out_addr, data, len & 0x7);
+
+	st_ism330dhcx_shub_master_enable(sensor, false);
+
+	memset(config, 0, sizeof(config));
+	return st_ism330dhcx_shub_write_reg(hw, ST_ISM330DHCX_REG_SLV3_ADDR,
+					 config, sizeof(config));
+}
+
+/**
+ * Write sensor data register from shub interface
+ *
+ * NOTE: use SLV0 i2c slave for write operation
+ *
+ * @param  sensor: ST IMU sensor instance
+ * @param  addr: Remote address register.
+ * @param  data: Data buffer.
+ * @param  len: Data read len.
+ * @return  0 if OK, < 0 if ERROR
+ */
+static int st_ism330dhcx_shub_write(struct st_ism330dhcx_sensor *sensor, u8 addr,
+				 u8 *data, int len)
+{
+	struct st_ism330dhcx_ext_dev_info *ext_info = &sensor->ext_dev_info;
+	struct st_ism330dhcx_hw *hw = sensor->hw;
+	u8 mconfig = ST_ISM330DHCX_REG_WRITE_ONCE_MASK | 3;
+	u8 config[3] = {};
+	int err, i;
+
+	/* AuxSens = 3 + wr once */
+	err = st_ism330dhcx_shub_write_reg(hw, ST_ISM330DHCX_REG_MASTER_CONFIG_ADDR,
+					&mconfig, sizeof(mconfig));
+	if (err < 0)
+		return err;
+
+	config[0] = ext_info->ext_dev_i2c_addr << 1;
+	for (i = 0; i < len; i++) {
+		config[1] = addr + i;
+
+		err = st_ism330dhcx_shub_write_reg(hw, ST_ISM330DHCX_REG_SLV0_ADDR,
+						config, sizeof(config));
+		if (err < 0)
+			return err;
+
+		err = st_ism330dhcx_shub_write_reg(hw,
+					ST_ISM330DHCX_REG_DATAWRITE_SLV0_ADDR,
+					&data[i], 1);
+		if (err < 0)
+			return err;
+
+		err = st_ism330dhcx_shub_master_enable(sensor, true);
+		if (err < 0)
+			return err;
+
+		st_ism330dhcx_shub_wait_complete(hw);
+
+		st_ism330dhcx_shub_master_enable(sensor, false);
+	}
+
+	return st_ism330dhcx_shub_write_reg(hw, ST_ISM330DHCX_REG_SLV0_ADDR,
+					 config, sizeof(config));
+}
+
+/**
+ * Write sensor data register from shub interface using register bitmask
+ *
+ * @param  sensor: ST IMU sensor instance
+ * @param  addr: Remote address register.
+ * @param  mask: Register bitmask.
+ * @param  val: Data buffer.
+ * @return  0 if OK, < 0 if ERROR
+ */
+static int st_ism330dhcx_shub_write_with_mask(struct st_ism330dhcx_sensor *sensor,
+					   u8 addr, u8 mask, u8 val)
+{
+	int err;
+	u8 data;
+
+	err = st_ism330dhcx_shub_read(sensor, addr, &data, sizeof(data));
+	if (err < 0)
+		return err;
+
+	data = ((data & ~mask) | (val << __ffs(mask) & mask));
+
+	return st_ism330dhcx_shub_write(sensor, addr, &data, sizeof(data));
+}
+
+/**
+ * Configure external sensor connected on master I2C interface
+ *
+ * NOTE: use SLV1/SLV2 i2c slave for FIFO read operation
+ *
+ * @param  sensor: ST IMU sensor instance
+ * @param  enable: Enable/Disable sensor.
+ * @return  0 if OK, < 0 if ERROR
+ */
+static int st_ism330dhcx_shub_config_channels(struct st_ism330dhcx_sensor *sensor,
+					   bool enable)
+{
+	struct st_ism330dhcx_ext_dev_info *ext_info;
+	struct st_ism330dhcx_hw *hw = sensor->hw;
+	struct st_ism330dhcx_sensor *cur_sensor;
+	u8 config[6] = {}, enable_mask;
+	int i, j = 0;
+
+	enable_mask = enable ? hw->enable_mask | BIT(sensor->id)
+			     : hw->enable_mask & ~BIT(sensor->id);
+
+	for (i = ST_ISM330DHCX_ID_EXT0; i <= ST_ISM330DHCX_ID_EXT1; i++) {
+		if (!hw->iio_devs[i])
+			continue;
+
+		cur_sensor = iio_priv(hw->iio_devs[i]);
+		if (!(enable_mask & BIT(cur_sensor->id)))
+			continue;
+
+		ext_info = &cur_sensor->ext_dev_info;
+		config[j] = (ext_info->ext_dev_i2c_addr << 1) | 1;
+		config[j + 1] =
+			ext_info->ext_dev_settings->ext_channels[0].address;
+		config[j + 2] = ST_ISM330DHCX_REG_BATCH_EXT_SENS_EN_MASK |
+				(ext_info->ext_dev_settings->data_len &
+				 ST_ISM330DHCX_REG_SLAVE_NUMOP_MASK);
+		j += 3;
+	}
+
+	return st_ism330dhcx_shub_write_reg(hw, ST_ISM330DHCX_REG_SLV1_ADDR,
+					 config, sizeof(config));
+}
+
+/**
+ * Get a valid ODR [SHUB]
+ *
+ * Check a valid ODR closest to the passed value
+ *
+ * @param  sensor: SST IMU sensor instance.
+ * @param  odr: ODR value (in Hz).
+ * @param  val: ODR register value data pointer.
+ * @return  0 if OK, negative value for ERROR
+ */
+static int st_ism330dhcx_shub_get_odr_val(struct st_ism330dhcx_sensor *sensor,
+				       u16 odr, u8 *val)
+{
+	struct st_ism330dhcx_ext_dev_info *ext_info = &sensor->ext_dev_info;
+	int i;
+
+	for (i = 0; i < ext_info->ext_dev_settings->odr_table.odr_size; i++)
+		if (ext_info->ext_dev_settings->odr_table.odr_avl[i].hz >= odr)
+			break;
+
+	if (i == ext_info->ext_dev_settings->odr_table.odr_size)
+		return -EINVAL;
+
+	*val = ext_info->ext_dev_settings->odr_table.odr_avl[i].val;
+
+	/* set decimator for low ODR */
+	sensor->decimator =
+		ext_info->ext_dev_settings->odr_table.odr_avl[i].uhz;
+	sensor->dec_counter = 0;
+
+	return 0;
+}
+
+/**
+ * Set new ODR to sensor [SHUB]
+ *
+ * Set a valid ODR closest to the passed value
+ *
+ * @param  sensor: ST IMU sensor instance
+ * @param  odr: ODR value (in Hz).
+ * @return  0 if OK, negative value for ERROR
+ */
+static int st_ism330dhcx_shub_set_odr(struct st_ism330dhcx_sensor *sensor, u16 odr)
+{
+	struct st_ism330dhcx_ext_dev_info *ext_info = &sensor->ext_dev_info;
+	struct st_ism330dhcx_hw *hw = sensor->hw;
+	u8 odr_val;
+	int err;
+
+	err = st_ism330dhcx_shub_get_odr_val(sensor, odr, &odr_val);
+	if (err < 0)
+		return err;
+
+	if (sensor->odr == odr && (hw->enable_mask & BIT(sensor->id)))
+		return 0;
+
+	return st_ism330dhcx_shub_write_with_mask(sensor,
+				ext_info->ext_dev_settings->odr_table.reg.addr,
+				ext_info->ext_dev_settings->odr_table.reg.mask,
+				odr_val);
+}
+
+/**
+ * Enable or Disable sensor [SHUB]
+ *
+ * @param  sensor: ST IMU sensor instance
+ * @param  enable: Enable or disable the sensor [true,false].
+ * @return  0 if OK, negative value for ERROR
+ */
+int st_ism330dhcx_shub_set_enable(struct st_ism330dhcx_sensor *sensor, bool enable)
+{
+	struct st_ism330dhcx_ext_dev_info *ext_info = &sensor->ext_dev_info;
+	int err;
+
+	err = st_ism330dhcx_shub_config_channels(sensor, enable);
+	if (err < 0)
+		return err;
+
+	if (enable) {
+		err = st_ism330dhcx_shub_set_odr(sensor, sensor->odr);
+		if (err < 0)
+			return err;
+	} else {
+		err = st_ism330dhcx_shub_write_with_mask(sensor,
+				ext_info->ext_dev_settings->odr_table.reg.addr,
+				ext_info->ext_dev_settings->odr_table.reg.mask,
+				0);
+		if (err < 0)
+			return err;
+	}
+
+	if (ext_info->ext_dev_settings->pwr_table.reg.addr) {
+		u8 val;
+
+		val = enable ? ext_info->ext_dev_settings->pwr_table.on_val
+			     : ext_info->ext_dev_settings->pwr_table.off_val;
+		err = st_ism330dhcx_shub_write_with_mask(sensor,
+				ext_info->ext_dev_settings->pwr_table.reg.addr,
+				ext_info->ext_dev_settings->pwr_table.reg.mask,
+				val);
+		if (err < 0)
+			return err;
+	}
+
+	return st_ism330dhcx_shub_master_enable(sensor, enable);
+}
+
+static inline u32 st_ism330dhcx_get_unaligned_le24(const u8 *p)
+{
+	return (s32)((p[0] | p[1] << 8 | p[2] << 16) << 8) >> 8;
+}
+
+/**
+ * Single sensor read operation [SHUB]
+ *
+ * @param  sensor: ST IMU sensor instance
+ * @param  ch: IIO Channel.
+ * @param  val: Output data register value.
+ * @return  IIO_VAL_INT if OK, negative value for ERROR
+ */
+static int st_ism330dhcx_shub_read_oneshot(struct st_ism330dhcx_sensor *sensor,
+					struct iio_chan_spec const *ch,
+					int *val)
+{
+	int err, delay, len = ch->scan_type.realbits >> 3;
+	u8 data[4];
+
+	if (len > ARRAY_SIZE(data))
+		return -ENOMEM;
+
+	err = st_ism330dhcx_shub_set_enable(sensor, true);
+	if (err < 0)
+		return err;
+
+	delay = 1000000 / sensor->odr;
+	usleep_range(delay, 2 * delay);
+
+	err = st_ism330dhcx_shub_read(sensor, ch->address, data, len);
+	if (err < 0)
+		return err;
+
+	st_ism330dhcx_shub_set_enable(sensor, false);
+
+	switch (len) {
+	case 3:
+		*val = (s32)st_ism330dhcx_get_unaligned_le24(data);
+		break;
+	case 2:
+		*val = (s16)get_unaligned_le16(data);
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return IIO_VAL_INT;
+}
+
+/**
+ * Read Sensor data configuration [SHUB]
+ *
+ * @param  iio_dev: IIO Device.
+ * @param  ch: IIO Channel.
+ * @param  val: Data Buffer (MSB).
+ * @param  val2: Data Buffer (LSB).
+ * @param  mask: Data Mask.
+ * @return  0 if OK, -EINVAL value for ERROR
+ */
+static int st_ism330dhcx_shub_read_raw(struct iio_dev *iio_dev,
+				    struct iio_chan_spec const *ch,
+				    int *val, int *val2, long mask)
+{
+	struct st_ism330dhcx_sensor *sensor = iio_priv(iio_dev);
+	int ret;
+
+	switch (mask) {
+	case IIO_CHAN_INFO_RAW:
+		mutex_lock(&iio_dev->mlock);
+		if (iio_buffer_enabled(iio_dev)) {
+			ret = -EBUSY;
+			mutex_unlock(&iio_dev->mlock);
+			break;
+		}
+		ret = st_ism330dhcx_shub_read_oneshot(sensor, ch, val);
+		mutex_unlock(&iio_dev->mlock);
+		break;
+	case IIO_CHAN_INFO_SAMP_FREQ:
+		*val = sensor->odr;
+		ret = IIO_VAL_INT;
+		break;
+	case IIO_CHAN_INFO_SCALE:
+		*val = 0;
+		*val2 = sensor->gain;
+		ret = IIO_VAL_INT_PLUS_MICRO;
+		break;
+	default:
+		ret = -EINVAL;
+		break;
+	}
+
+	return ret;
+}
+
+/**
+ * Write Sensor data configuration [SHUB]
+ *
+ * @param  iio_dev: IIO Device.
+ * @param  chan: IIO Channel.
+ * @param  val: Data Buffer (MSB).
+ * @param  val2: Data Buffer (LSB).
+ * @param  mask: Data Mask.
+ * @return  0 if OK, -EINVAL value for ERROR
+ */
+static int st_ism330dhcx_shub_write_raw(struct iio_dev *iio_dev,
+				     struct iio_chan_spec const *chan,
+				     int val, int val2, long mask)
+{
+	struct st_ism330dhcx_sensor *sensor = iio_priv(iio_dev);
+	int err;
+
+	mutex_lock(&iio_dev->mlock);
+
+	switch (mask) {
+	case IIO_CHAN_INFO_SAMP_FREQ: {
+		u8 data;
+
+		err = st_ism330dhcx_shub_get_odr_val(sensor, val, &data);
+		if (!err)
+			sensor->odr = val;
+		break;
+	}
+	case IIO_CHAN_INFO_SCALE:
+		err = 0;
+		break;
+	default:
+		err = -EINVAL;
+		break;
+	}
+
+	mutex_unlock(&iio_dev->mlock);
+
+	return err;
+}
+
+/**
+ * Get a list of available sensor ODR [SHUB]
+ *
+ * List of available ODR returned separated by commas
+ *
+ * @param  dev: IIO Device.
+ * @param  attr: IIO Channel attribute.
+ * @param  buf: User buffer.
+ * @return  buffer len
+ */
+static ssize_t
+st_ism330dhcx_sysfs_shub_sampling_freq_avail(struct device *dev,
+					  struct device_attribute *attr,
+					  char *buf)
+{
+	struct st_ism330dhcx_sensor *sensor = iio_priv(dev_to_iio_dev(dev));
+	struct st_ism330dhcx_ext_dev_info *ext_info = &sensor->ext_dev_info;
+	int i, len = 0;
+
+	for (i = 0; i < ST_ISM330DHCX_ODR_LIST_SIZE; i++) {
+		u16 val = ext_info->ext_dev_settings->odr_table.odr_avl[i].hz;
+
+		if (val > 0)
+			len += scnprintf(buf + len, PAGE_SIZE - len, "%d ",
+					 val);
+	}
+	buf[len - 1] = '\n';
+
+	return len;
+}
+
+/**
+ * Get a list of available sensor Full Scale [SHUB]
+ *
+ * List of available Full Scale returned separated by commas
+ *
+ * @param  dev: IIO Device.
+ * @param  attr: IIO Channel attribute.
+ * @param  buf: User buffer.
+ * @return  buffer len
+ */
+static ssize_t st_ism330dhcx_sysfs_shub_scale_avail(struct device *dev,
+						 struct device_attribute *attr,
+						 char *buf)
+{
+	struct st_ism330dhcx_sensor *sensor = iio_priv(dev_to_iio_dev(dev));
+	struct st_ism330dhcx_ext_dev_info *ext_info = &sensor->ext_dev_info;
+	int i, len = 0;
+
+	for (i = 0; i < ext_info->ext_dev_settings->fs_table.size; i++) {
+		u16 val = ext_info->ext_dev_settings->fs_table.fs_avl[i].gain;
+
+		if (val > 0)
+			len += scnprintf(buf + len, PAGE_SIZE - len, "0.%06u ",
+					 val);
+	}
+	buf[len - 1] = '\n';
+
+	return len;
+}
+
+static IIO_DEV_ATTR_SAMP_FREQ_AVAIL(st_ism330dhcx_sysfs_shub_sampling_freq_avail);
+static IIO_DEVICE_ATTR(in_ext_scale_available, 0444,
+		       st_ism330dhcx_sysfs_shub_scale_avail, NULL, 0);
+static IIO_DEVICE_ATTR(hwfifo_watermark_max, 0444,
+		       st_ism330dhcx_get_max_watermark, NULL, 0);
+static IIO_DEVICE_ATTR(hwfifo_flush, 0200, NULL, st_ism330dhcx_flush_fifo, 0);
+static IIO_DEVICE_ATTR(hwfifo_watermark, 0644, st_ism330dhcx_get_watermark,
+		       st_ism330dhcx_set_watermark, 0);
+static IIO_DEVICE_ATTR(module_id, 0444, st_ism330dhcx_get_module_id, NULL, 0);
+
+static struct attribute *st_ism330dhcx_ext_attributes[] = {
+	&iio_dev_attr_sampling_frequency_available.dev_attr.attr,
+	&iio_dev_attr_in_ext_scale_available.dev_attr.attr,
+	&iio_dev_attr_hwfifo_watermark_max.dev_attr.attr,
+	&iio_dev_attr_hwfifo_watermark.dev_attr.attr,
+	&iio_dev_attr_hwfifo_flush.dev_attr.attr,
+	&iio_dev_attr_module_id.dev_attr.attr,
+	NULL,
+};
+
+static const struct attribute_group st_ism330dhcx_ext_attribute_group = {
+	.attrs = st_ism330dhcx_ext_attributes,
+};
+
+static const struct iio_info st_ism330dhcx_ext_info = {
+	.attrs = &st_ism330dhcx_ext_attribute_group,
+	.read_raw = st_ism330dhcx_shub_read_raw,
+	.write_raw = st_ism330dhcx_shub_write_raw,
+};
+
+/**
+ * Allocate IIO device [SHUB]
+ *
+ * @param  hw: ST IMU MEMS hw instance.
+ * @param  ext_settings: xternal sensor descritor entry.
+ * @param  id: Sensor Identifier.
+ * @param  i2c_addr: external I2C address on master bus.
+ * @return  struct iio_dev *, NULL if ERROR
+ */
+static struct iio_dev *st_ism330dhcx_shub_alloc_iio_dev(struct st_ism330dhcx_hw *hw,
+			const struct st_ism330dhcx_ext_dev_settings *ext_settings,
+			enum st_ism330dhcx_sensor_id id, u8 i2c_addr)
+{
+	struct st_ism330dhcx_sensor *sensor;
+	struct iio_dev *iio_dev;
+
+	iio_dev = devm_iio_device_alloc(hw->dev, sizeof(*sensor));
+	if (!iio_dev)
+		return NULL;
+
+	iio_dev->modes = INDIO_DIRECT_MODE;
+	iio_dev->dev.parent = hw->dev;
+	iio_dev->available_scan_masks = ext_settings->ext_available_scan_masks;
+	iio_dev->info = &st_ism330dhcx_ext_info;
+	iio_dev->channels = ext_settings->ext_channels;
+	iio_dev->num_channels = ext_settings->ext_chan_depth;
+
+	switch (iio_dev->channels[0].type) {
+	case IIO_MAGN:
+		iio_dev->name = "ism330dhcx_magn";
+		break;
+	case IIO_PRESSURE:
+		iio_dev->name = "ism330dhcx_press";
+		break;
+	default:
+		iio_dev->name = "ism330dhcx_ext";
+		break;
+	}
+
+	sensor = iio_priv(iio_dev);
+	sensor->id = id;
+	sensor->hw = hw;
+	sensor->odr = ext_settings->odr_table.odr_avl[0].hz;
+	sensor->gain = ext_settings->fs_table.fs_avl[0].gain;
+	sensor->max_watermark = ST_ISM330DHCX_MAX_FIFO_DEPTH;
+	sensor->watermark = 1;
+	sensor->ext_dev_info.ext_dev_i2c_addr = i2c_addr;
+	sensor->ext_dev_info.ext_dev_settings = ext_settings;
+	sensor->decimator = 0;
+	sensor->dec_counter = 0;
+
+	return iio_dev;
+}
+
+static int st_ism330dhcx_shub_init_remote_sensor(struct st_ism330dhcx_sensor *sensor)
+{
+	struct st_ism330dhcx_ext_dev_info *ext_info = &sensor->ext_dev_info;
+	int err = 0;
+
+	if (ext_info->ext_dev_settings->bdu_reg.addr)
+		err = st_ism330dhcx_shub_write_with_mask(sensor,
+				ext_info->ext_dev_settings->bdu_reg.addr,
+				ext_info->ext_dev_settings->bdu_reg.mask, 1);
+
+	if (ext_info->ext_dev_settings->temp_comp_reg.addr)
+		err = st_ism330dhcx_shub_write_with_mask(sensor,
+			ext_info->ext_dev_settings->temp_comp_reg.addr,
+			ext_info->ext_dev_settings->temp_comp_reg.mask, 1);
+
+	if (ext_info->ext_dev_settings->off_canc_reg.addr)
+		err = st_ism330dhcx_shub_write_with_mask(sensor,
+			ext_info->ext_dev_settings->off_canc_reg.addr,
+			ext_info->ext_dev_settings->off_canc_reg.mask, 1);
+
+	return err;
+}
+
+/**
+ * Probe device function [SHUB]
+ *
+ * @param  hw: ST IMU MEMS hw instance.
+ * @return  0 if OK, negative for ERROR
+ */
+int st_ism330dhcx_shub_probe(struct st_ism330dhcx_hw *hw)
+{
+	const struct st_ism330dhcx_ext_dev_settings *settings;
+	struct st_ism330dhcx_sensor *acc_sensor, *sensor;
+	u8 config[3], data, num_ext_dev = 0;
+	enum st_ism330dhcx_sensor_id id;
+	int err, i = 0, j;
+
+	acc_sensor = iio_priv(hw->iio_devs[ST_ISM330DHCX_ID_ACC]);
+	while (i < ARRAY_SIZE(st_ism330dhcx_ext_dev_table) &&
+	       num_ext_dev < ST_ISM330DHCX_MAX_SLV_NUM) {
+		settings = &st_ism330dhcx_ext_dev_table[i];
+
+		for (j = 0; j < ARRAY_SIZE(settings->i2c_addr); j++) {
+			if (!settings->i2c_addr[j])
+				continue;
+
+			/* read wai slave register */
+			config[0] = (settings->i2c_addr[j] << 1) | 1;
+			config[1] = settings->wai_addr;
+			config[2] = 1;
+
+			err = st_ism330dhcx_shub_write_reg(hw,
+						ST_ISM330DHCX_REG_SLV0_ADDR,
+						config, sizeof(config));
+			if (err < 0)
+				return err;
+
+			err = st_ism330dhcx_shub_master_enable(acc_sensor, true);
+			if (err < 0)
+				return err;
+
+			st_ism330dhcx_shub_wait_complete(hw);
+
+			err = st_ism330dhcx_shub_read_reg(hw,
+						ST_ISM330DHCX_REG_SLV0_OUT_ADDR,
+						&data, sizeof(data));
+
+			st_ism330dhcx_shub_master_enable(acc_sensor, false);
+
+			if (err < 0)
+				return err;
+
+			if (data != settings->wai_val)
+				continue;
+
+			id = ST_ISM330DHCX_ID_EXT0 + num_ext_dev;
+			hw->iio_devs[id] = st_ism330dhcx_shub_alloc_iio_dev(hw,
+							settings, id,
+							settings->i2c_addr[j]);
+			if (!hw->iio_devs[id])
+				return -ENOMEM;
+
+			sensor = iio_priv(hw->iio_devs[id]);
+			err = st_ism330dhcx_shub_init_remote_sensor(sensor);
+			if (err < 0)
+				return err;
+
+			num_ext_dev++;
+			hw->ext_data_len += settings->data_len;
+			break;
+		}
+
+		i++;
+	}
+
+	if (!num_ext_dev)
+		return 0;
+
+	memset(config, 0, sizeof(config));
+	err = st_ism330dhcx_shub_write_reg(hw, ST_ISM330DHCX_REG_SLV0_ADDR,
+					config, sizeof(config));
+	if (err < 0)
+		return err;
+
+	/* AuxSens = 3 + wr once */
+	data = ST_ISM330DHCX_REG_WRITE_ONCE_MASK | 3;
+	return st_ism330dhcx_shub_write_reg(hw, ST_ISM330DHCX_REG_MASTER_CONFIG_ADDR,
+					 &data, sizeof(data));
+}
diff --git a/drivers/iio/stm/imu/st_ism330dhcx/st_ism330dhcx_spi.c b/drivers/iio/stm/imu/st_ism330dhcx/st_ism330dhcx_spi.c
new file mode 100644
index 000000000..64f6492df
--- /dev/null
+++ b/drivers/iio/stm/imu/st_ism330dhcx/st_ism330dhcx_spi.c
@@ -0,0 +1,107 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * STMicroelectronics st_ism330dhcx spi driver
+ *
+ * MEMS Software Solutions Team
+ *
+ * Copyright 2020 STMicroelectronics Inc.
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/spi/spi.h>
+#include <linux/slab.h>
+#include <linux/of.h>
+
+#include "st_ism330dhcx.h"
+
+#define SENSORS_SPI_READ	BIT(7)
+
+static int st_ism330dhcx_spi_read(struct device *dev, u8 addr, int len,
+			       u8 *data)
+{
+	struct spi_device *spi = to_spi_device(dev);
+	struct st_ism330dhcx_hw *hw = spi_get_drvdata(spi);
+	int err;
+
+	struct spi_transfer xfers[] = {
+		{
+			.tx_buf = hw->tb.tx_buf,
+			.bits_per_word = 8,
+			.len = 1,
+		},
+		{
+			.rx_buf = hw->tb.rx_buf,
+			.bits_per_word = 8,
+			.len = len,
+		}
+	};
+
+	hw->tb.tx_buf[0] = addr | SENSORS_SPI_READ;
+
+	err = spi_sync_transfer(spi, xfers,  ARRAY_SIZE(xfers));
+	if (err < 0)
+		return err;
+
+	memcpy(data, hw->tb.rx_buf, len * sizeof(u8));
+
+	return len;
+}
+
+static int st_ism330dhcx_spi_write(struct device *dev, u8 addr, int len,
+				const u8 *data)
+{
+	struct st_ism330dhcx_hw *hw;
+	struct spi_device *spi;
+
+	if (len >= ST_ISM330DHCX_TX_MAX_LENGTH)
+		return -ENOMEM;
+
+	spi = to_spi_device(dev);
+	hw = spi_get_drvdata(spi);
+
+	hw->tb.tx_buf[0] = addr;
+	memcpy(&hw->tb.tx_buf[1], data, len);
+
+	return spi_write(spi, hw->tb.tx_buf, len + 1);
+}
+
+static const struct st_ism330dhcx_transfer_function st_ism330dhcx_transfer_fn = {
+	.read = st_ism330dhcx_spi_read,
+	.write = st_ism330dhcx_spi_write,
+};
+
+static int st_ism330dhcx_spi_probe(struct spi_device *spi)
+{
+	return st_ism330dhcx_probe(&spi->dev, spi->irq,
+				&st_ism330dhcx_transfer_fn);
+}
+
+static const struct of_device_id st_ism330dhcx_spi_of_match[] = {
+	{
+		.compatible = "st,ism330dhcx",
+	},
+	{},
+};
+MODULE_DEVICE_TABLE(of, st_ism330dhcx_spi_of_match);
+
+static const struct spi_device_id st_ism330dhcx_spi_id_table[] = {
+	{ ST_ISM330DHCX_DEV_NAME },
+	{},
+};
+MODULE_DEVICE_TABLE(spi, st_ism330dhcx_spi_id_table);
+
+static struct spi_driver st_ism330dhcx_driver = {
+	.driver = {
+		.name = "st_ism330dhcx_spi",
+		.pm = &st_ism330dhcx_pm_ops,
+		.of_match_table = of_match_ptr(st_ism330dhcx_spi_of_match),
+	},
+	.probe = st_ism330dhcx_spi_probe,
+	.id_table = st_ism330dhcx_spi_id_table,
+};
+module_spi_driver(st_ism330dhcx_driver);
+
+MODULE_AUTHOR("MEMS Software Solutions Team");
+MODULE_DESCRIPTION("STMicroelectronics st_ism330dhcx spi driver");
+MODULE_LICENSE("GPL v2");
-- 
2.25.1


From f96d6737762f05fc21fba516c35e68565c95e64d Mon Sep 17 00:00:00 2001
From: Mario Tesi <mario.tesi@st.com>
Date: Mon, 9 Oct 2023 17:22:08 +0200
Subject: drivers:iio:stm:accel:st_lis2dw12: Add support to STMEMS accel
 lis2dw12

Added support to STMEMS driver for lis2dw12, iis2dlpc and ais2ih
compatible accelerometer sensors.

Signed-off-by: Mario Tesi <mario.tesi@st.com>
---
 .../bindings/iio/stm/accel/st_lis2dw12.txt    |   43 +
 drivers/iio/stm/Kconfig                       |    1 +
 drivers/iio/stm/Makefile                      |    1 +
 drivers/iio/stm/accel/Kconfig                 |   37 +
 drivers/iio/stm/accel/Makefile                |   10 +
 drivers/iio/stm/accel/st_lis2dw12.h           |  106 ++
 drivers/iio/stm/accel/st_lis2dw12_buffer.c    |  333 ++++++
 drivers/iio/stm/accel/st_lis2dw12_core.c      | 1048 +++++++++++++++++
 drivers/iio/stm/accel/st_lis2dw12_i2c.c       |  103 ++
 drivers/iio/stm/accel/st_lis2dw12_spi.c       |  111 ++
 10 files changed, 1793 insertions(+)
 create mode 100644 Documentation/devicetree/bindings/iio/stm/accel/st_lis2dw12.txt
 create mode 100644 drivers/iio/stm/accel/Kconfig
 create mode 100644 drivers/iio/stm/accel/Makefile
 create mode 100644 drivers/iio/stm/accel/st_lis2dw12.h
 create mode 100644 drivers/iio/stm/accel/st_lis2dw12_buffer.c
 create mode 100644 drivers/iio/stm/accel/st_lis2dw12_core.c
 create mode 100644 drivers/iio/stm/accel/st_lis2dw12_i2c.c
 create mode 100644 drivers/iio/stm/accel/st_lis2dw12_spi.c

diff --git a/Documentation/devicetree/bindings/iio/stm/accel/st_lis2dw12.txt b/Documentation/devicetree/bindings/iio/stm/accel/st_lis2dw12.txt
new file mode 100644
index 000000000..5df0a88f2
--- /dev/null
+++ b/Documentation/devicetree/bindings/iio/stm/accel/st_lis2dw12.txt
@@ -0,0 +1,43 @@
+* lis2dw12 driver for accel MEMS sensors
+
+Required properties for all bus drivers:
+- compatible: must be one of:
+              "st,lis2dw12"
+              "st,iis2dlpc"
+              "st,ais2ih"
+
+Required properties for the i2c bindings:
+- reg: i2c slave address
+
+Required properties for the spi bindings:
+- reg:               the chipselect index
+- spi-max-frequency: maximal bus speed, should be set to 1000000 unless
+                     constrained by external circuitry
+
+Optional properties for all bus drivers:
+- st,drdy-int-pin: the pin on the package that will be used to signal
+                   "data ready" (valid values: 1 or 2, default: 1).
+
+- interrupts:      interrupt mapping for IRQ. It should be configured with
+                   flags IRQ_TYPE_LEVEL_HIGH.
+
+                   Refer to interrupt-controller/interrupts.txt for generic
+                   interrupt client node bindings.
+
+Example for an i2c device node:
+
+&i2c5 {
+    status = "okay";
+
+    iis2dlpc_X_STM32MP_MSP01@19 {
+        compatible = "st,iis2dlpc";
+        reg = <0x19>;
+
+        /* STM32MP1 - X-STM32MP-MSP0: IIS2DLPC_INT1 (PF3) */
+        st,drdy-int-pin = <1>;
+        interrupt-parent = <&gpiof>;
+        interrupts = <3 IRQ_TYPE_EDGE_RISING>;
+
+        status = "okay";
+    };
+}
diff --git a/drivers/iio/stm/Kconfig b/drivers/iio/stm/Kconfig
index 8e0e9c6ba..9afd0faef 100644
--- a/drivers/iio/stm/Kconfig
+++ b/drivers/iio/stm/Kconfig
@@ -9,6 +9,7 @@ menuconfig IIO_STM
 
 if IIO_STM
 
+source "drivers/iio/stm/accel/Kconfig"
 source "drivers/iio/stm/imu/Kconfig"
 
 endif # IIO_STM
diff --git a/drivers/iio/stm/Makefile b/drivers/iio/stm/Makefile
index b39010a49..18559f9c3 100644
--- a/drivers/iio/stm/Makefile
+++ b/drivers/iio/stm/Makefile
@@ -4,4 +4,5 @@
 #
 # When adding new entries keep the list in alphabetical order
 
+obj-$(CONFIG_IIO_STM) += accel/
 obj-$(CONFIG_IIO_STM) += imu/
diff --git a/drivers/iio/stm/accel/Kconfig b/drivers/iio/stm/accel/Kconfig
new file mode 100644
index 000000000..ad0fa8c9e
--- /dev/null
+++ b/drivers/iio/stm/accel/Kconfig
@@ -0,0 +1,37 @@
+# SPDX-License-Identifier: GPL-2.0-only
+#
+# Accelerometer drivers
+#
+# When adding new entries keep the list in alphabetical order
+
+menu "Accelerometers"
+
+config IIO_ST_LIS2DW12
+	tristate "STMicroelectronics LIS2DW12/IIS2DLPC Accelerometer Driver"
+	depends on (I2C || SPI)
+	select IIO_BUFFER
+	select IIO_KFIFO_BUF
+	select IIO_ST_LIS2DW12_I2C if (I2C)
+	select IIO_ST_LIS2DW12_SPI if (SPI)
+	help
+	  Say yes here to build support for the LIS2DW12 and IIS2DLPC accelerometer.
+
+	  This driver can also be built as a module. If so, will be created
+	  these modules:
+	  - st_lisdw12 (core functions for the driver [it is mandatory]);
+	  - st_lisdw12_i2c (necessary for the I2C devices [optional*]);
+	  - st_lisdw12_spi (necessary for the SPI devices [optional*]);
+
+	  (*) one of these is necessary to do something.
+
+config IIO_ST_LIS2DW12_I2C
+	tristate
+	depends on IIO_ST_LIS2DW12
+	depends on I2C
+
+config IIO_ST_LIS2DW12_SPI
+	tristate
+	depends on IIO_ST_LIS2DW12
+	depends on SPI
+
+endmenu
diff --git a/drivers/iio/stm/accel/Makefile b/drivers/iio/stm/accel/Makefile
new file mode 100644
index 000000000..3d205e8ed
--- /dev/null
+++ b/drivers/iio/stm/accel/Makefile
@@ -0,0 +1,10 @@
+# SPDX-License-Identifier: GPL-2.0
+#
+# Makefile for industrial I/O accelerometer drivers
+#
+
+# When adding new entries keep the list in alphabetical order
+st_lis2dw12-y:= st_lis2dw12_core.o st_lis2dw12_buffer.o
+obj-$(CONFIG_IIO_ST_LIS2DW12) += st_lis2dw12.o
+obj-$(CONFIG_IIO_ST_LIS2DW12_I2C) += st_lis2dw12_i2c.o
+obj-$(CONFIG_IIO_ST_LIS2DW12_SPI) += st_lis2dw12_spi.o
diff --git a/drivers/iio/stm/accel/st_lis2dw12.h b/drivers/iio/stm/accel/st_lis2dw12.h
new file mode 100644
index 000000000..a1f2b5338
--- /dev/null
+++ b/drivers/iio/stm/accel/st_lis2dw12.h
@@ -0,0 +1,106 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * STMicroelectronics lis2dw12 driver
+ *
+ * MEMS Software Solutions Team
+ *
+ * Copyright 2016 STMicroelectronics Inc.
+ */
+
+#ifndef ST_LIS2DW12_H
+#define ST_LIS2DW12_H
+
+#include <linux/device.h>
+#include <linux/iio/events.h>
+#include <linux/iio/iio.h>
+#include <linux/of_device.h>
+
+#include "../common/stm_iio_types.h"
+
+#define ST_LIS2DW12_DEV_NAME		"lis2dw12"
+#define ST_IIS2DLPC_DEV_NAME		"iis2dlpc"
+#define ST_AIS2IH_DEV_NAME		"ais2ih"
+#define ST_LIS2DW12_MAX_WATERMARK	31
+#define ST_LIS2DW12_DATA_SIZE		6
+
+struct st_lis2dw12_transfer_function {
+	int (*read)(struct device *dev, u8 addr, int len, u8 *data);
+	int (*write)(struct device *dev, u8 addr, int len, u8 *data);
+};
+
+#define ST_LIS2DW12_RX_MAX_LENGTH	96
+#define ST_LIS2DW12_TX_MAX_LENGTH	8
+
+struct st_lis2dw12_transfer_buffer {
+	u8 rx_buf[ST_LIS2DW12_RX_MAX_LENGTH];
+	u8 tx_buf[ST_LIS2DW12_TX_MAX_LENGTH] ____cacheline_aligned;
+};
+
+enum st_lis2dw12_fifo_mode {
+	ST_LIS2DW12_FIFO_BYPASS = 0x0,
+	ST_LIS2DW12_FIFO_CONTINUOUS = 0x6,
+};
+
+enum st_lis2dw12_selftest_status {
+	ST_LIS2DW12_ST_RESET,
+	ST_LIS2DW12_ST_PASS,
+	ST_LIS2DW12_ST_FAIL,
+};
+
+enum st_lis2dw12_sensor_id {
+	ST_LIS2DW12_ID_ACC,
+	ST_LIS2DW12_ID_TAP_TAP,
+	ST_LIS2DW12_ID_TAP,
+	ST_LIS2DW12_ID_WU,
+	ST_LIS2DW12_ID_MAX,
+};
+
+struct st_lis2dw12_sensor {
+	enum st_lis2dw12_sensor_id id;
+	struct st_lis2dw12_hw *hw;
+
+	u16 gain;
+	u16 odr;
+};
+
+struct st_lis2dw12_hw {
+	struct device *dev;
+	int irq;
+
+	struct mutex fifo_lock;
+	struct mutex lock;
+
+	struct iio_dev *iio_devs[ST_LIS2DW12_ID_MAX];
+
+	enum st_lis2dw12_selftest_status st_status;
+	u16 enable_mask;
+
+	u8 watermark;
+	u8 std_level;
+	u64 samples;
+
+	s64 delta_ts;
+	s64 ts_irq;
+	s64 ts;
+
+	const struct st_lis2dw12_transfer_function *tf;
+	struct st_lis2dw12_transfer_buffer tb;
+};
+
+int st_lis2dw12_probe(struct device *dev, int irq,
+		      const struct st_lis2dw12_transfer_function *tf_ops);
+int st_lis2dw12_fifo_setup(struct st_lis2dw12_hw *hw);
+int st_lis2dw12_update_fifo_watermark(struct st_lis2dw12_hw *hw, u8 watermark);
+int st_lis2dw12_write_with_mask(struct st_lis2dw12_hw *hw, u8 addr, u8 mask,
+				u8 val);
+ssize_t st_lis2dw12_flush_fifo(struct device *dev,
+			       struct device_attribute *attr,
+			       const char *buf, size_t size);
+ssize_t st_lis2dw12_set_hwfifo_watermark(struct device *device,
+					 struct device_attribute *attr,
+					 const char *buf, size_t size);
+int st_lis2dw12_sensor_set_enable(struct st_lis2dw12_sensor *sensor,
+				  bool enable);
+
+#endif /* ST_LIS2DW12_H */
+
diff --git a/drivers/iio/stm/accel/st_lis2dw12_buffer.c b/drivers/iio/stm/accel/st_lis2dw12_buffer.c
new file mode 100644
index 000000000..5a7309b4d
--- /dev/null
+++ b/drivers/iio/stm/accel/st_lis2dw12_buffer.c
@@ -0,0 +1,333 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * STMicroelectronics lis2dw12 fifo driver
+ *
+ * MEMS Software Solutions Team
+ *
+ * Copyright 2016 STMicroelectronics Inc.
+ */
+
+#include <linux/module.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/iio/kfifo_buf.h>
+#include <linux/iio/events.h>
+#include <linux/iio/iio.h>
+#include <linux/iio/buffer.h>
+#include <linux/version.h>
+
+#include "st_lis2dw12.h"
+
+#define ST_LIS2DW12_STATUS_ADDR			0x27
+#define ST_LIS2DW12_STATUS_FF_MASK		BIT(0)
+#define ST_LIS2DW12_STATUS_TAP_TAP_MASK		BIT(4)
+#define ST_LIS2DW12_STATUS_TAP_MASK		BIT(3)
+#define ST_LIS2DW12_STATUS_WU_MASK		BIT(6)
+#define ST_LIS2DW12_STATUS_FTH_MASK		BIT(7)
+#define ST_LIS2DW12_FIFO_CTRL_ADDR		0x2e
+#define ST_LIS2DW12_FIFOMODE_MASK		GENMASK(7, 5)
+#define ST_LIS2DW12_FTH_MASK			GENMASK(4, 0)
+#define ST_LIS2DW12_FIFO_SAMPLES_ADDR		0x2f
+#define ST_LIS2DW12_FIFO_SAMPLES_FTH_MASK	BIT(7)
+#define ST_LIS2DW12_FIFO_SAMPLES_OVR_MASK	BIT(6)
+#define ST_LIS2DW12_WU_SRC_ADDR			0x38
+#define ST_LIS2DW12_TAP_SRC_ADDR		0x39
+#define ST_LIS2DW12_STAP_SRC_MASK		BIT(5)
+#define ST_LIS2DW12_DTAP_SRC_MASK		BIT(4)
+#define ST_LIS2DW12_TAP_EVT_MASK		GENMASK(2, 0)
+#define ST_LIS2DW12_FIFO_SAMPLES_DIFF_MASK	GENMASK(5, 0)
+
+static inline s64 st_lis2dw12_get_timestamp(struct st_lis2dw12_hw *hw)
+{
+	return iio_get_time_ns(hw->iio_devs[ST_LIS2DW12_ID_ACC]);
+}
+
+#define ST_LIS2DW12_EWMA_LEVEL			120
+#define ST_LIS2DW12_EWMA_DIV			128
+static inline s64 st_lis2dw12_ewma(s64 old, s64 new, int weight)
+{
+	s64 diff, incr;
+
+	diff = new - old;
+	incr = div_s64((ST_LIS2DW12_EWMA_DIV - weight) * diff,
+		       ST_LIS2DW12_EWMA_DIV);
+
+	return old + incr;
+}
+
+static int st_lis2dw12_update_fifo(struct iio_dev *iio_dev, bool enable)
+{
+	struct st_lis2dw12_sensor *sensor = iio_priv(iio_dev);
+	struct st_lis2dw12_hw *hw = sensor->hw;
+	enum st_lis2dw12_fifo_mode mode;
+	int err;
+
+	if (enable) {
+		hw->ts_irq = hw->ts = st_lis2dw12_get_timestamp(hw);
+		hw->delta_ts = div_s64(1000000000LL, sensor->odr) *
+			       hw->watermark;
+		hw->samples = 0;
+	}
+
+	mode = enable ? ST_LIS2DW12_FIFO_CONTINUOUS : ST_LIS2DW12_FIFO_BYPASS;
+	err = st_lis2dw12_write_with_mask(hw, ST_LIS2DW12_FIFO_CTRL_ADDR,
+					  ST_LIS2DW12_FIFOMODE_MASK, mode);
+	if (err < 0)
+		return err;
+
+	return st_lis2dw12_sensor_set_enable(sensor, enable);
+}
+
+int st_lis2dw12_update_fifo_watermark(struct st_lis2dw12_hw *hw, u8 watermark)
+{
+	return st_lis2dw12_write_with_mask(hw, ST_LIS2DW12_FIFO_CTRL_ADDR,
+					   ST_LIS2DW12_FTH_MASK, watermark);
+}
+
+ssize_t st_lis2dw12_set_hwfifo_watermark(struct device *dev,
+					 struct device_attribute *attr,
+					 const char *buf, size_t size)
+{
+	struct iio_dev *iio_dev = dev_to_iio_dev(dev);
+	struct st_lis2dw12_sensor *sensor = iio_priv(iio_dev);
+	struct st_lis2dw12_hw *hw = sensor->hw;
+	int err, val;
+
+	mutex_lock(&iio_dev->mlock);
+	if (iio_buffer_enabled(iio_dev)) {
+		err = -EBUSY;
+		goto unlock;
+	}
+
+	err = kstrtoint(buf, 10, &val);
+	if (err < 0)
+		goto unlock;
+
+	if (val < 1 || val > ST_LIS2DW12_MAX_WATERMARK) {
+		err = -EINVAL;
+		goto unlock;
+	}
+
+	err = st_lis2dw12_update_fifo_watermark(hw, val);
+	if (err < 0)
+		goto unlock;
+
+	hw->watermark = val;
+
+unlock:
+	mutex_unlock(&iio_dev->mlock);
+
+	return err < 0 ? err : size;
+}
+
+static int st_lis2dw12_buffer_preenable(struct iio_dev *iio_dev)
+{
+	return st_lis2dw12_update_fifo(iio_dev, true);
+}
+
+static int st_lis2dw12_buffer_postdisable(struct iio_dev *iio_dev)
+{
+	return st_lis2dw12_update_fifo(iio_dev, false);
+}
+
+static const struct iio_buffer_setup_ops st_lis2dw12_acc_buffer_setup_ops = {
+	.preenable = st_lis2dw12_buffer_preenable,
+	.postdisable = st_lis2dw12_buffer_postdisable,
+};
+
+static int st_lis2dw12_read_fifo(struct st_lis2dw12_hw *hw)
+{
+	u8 iio_buff[ALIGN(ST_LIS2DW12_DATA_SIZE, sizeof(s64)) + sizeof(s64)];
+	u8 buff[ST_LIS2DW12_RX_MAX_LENGTH], status, samples;
+	struct iio_dev *iio_dev = hw->iio_devs[ST_LIS2DW12_ID_ACC];
+	struct iio_chan_spec const *ch = iio_dev->channels;
+	int i, err, word_len, fifo_len, read_len = 0;
+	s64 delta_ts;
+
+	err = hw->tf->read(hw->dev, ST_LIS2DW12_FIFO_SAMPLES_ADDR,
+			   sizeof(status), &status);
+	if (err < 0)
+		return err;
+
+	samples = status & ST_LIS2DW12_FIFO_SAMPLES_DIFF_MASK;
+	delta_ts = div_s64(hw->delta_ts, hw->watermark);
+	fifo_len = samples * ST_LIS2DW12_DATA_SIZE;
+
+	while (read_len < fifo_len) {
+		word_len = min_t(int, fifo_len - read_len, sizeof(buff));
+		err = hw->tf->read(hw->dev, ch[0].address, word_len, buff);
+		if (err < 0)
+			return err;
+
+		for (i = 0; i < word_len; i += ST_LIS2DW12_DATA_SIZE) {
+			if (unlikely(++hw->samples < hw->std_level)) {
+				hw->ts += delta_ts;
+				continue;
+			}
+
+			hw->ts = min_t(s64, st_lis2dw12_get_timestamp(hw),
+				       hw->ts);
+			memcpy(iio_buff, &buff[i], ST_LIS2DW12_DATA_SIZE);
+			iio_push_to_buffers_with_timestamp(iio_dev, iio_buff,
+							   hw->ts);
+			hw->ts += delta_ts;
+		}
+		read_len += word_len;
+	}
+
+	return read_len;
+}
+
+ssize_t st_lis2dw12_flush_fifo(struct device *dev,
+			       struct device_attribute *attr,
+			       const char *buf, size_t size)
+{
+	struct iio_dev *iio_dev = dev_to_iio_dev(dev);
+	struct st_lis2dw12_sensor *sensor = iio_priv(iio_dev);
+	struct st_lis2dw12_hw *hw = sensor->hw;
+	s64 code;
+	int err;
+
+	mutex_lock(&hw->fifo_lock);
+
+	err = st_lis2dw12_read_fifo(hw);
+	hw->ts_irq = st_lis2dw12_get_timestamp(hw);
+
+	mutex_unlock(&hw->fifo_lock);
+
+	code = IIO_UNMOD_EVENT_CODE(IIO_ACCEL, -1,
+				    STM_IIO_EV_TYPE_FIFO_FLUSH,
+				    IIO_EV_DIR_EITHER);
+	iio_push_event(iio_dev, code, hw->ts_irq);
+
+	return err < 0 ? err : size;
+}
+
+
+static irqreturn_t st_lis2dw12_handler_irq(int irq, void *private)
+{
+	struct st_lis2dw12_hw *hw = private;
+	s64 ts;
+
+	ts = st_lis2dw12_get_timestamp(hw);
+	hw->delta_ts = st_lis2dw12_ewma(hw->delta_ts, ts - hw->ts_irq,
+					ST_LIS2DW12_EWMA_LEVEL);
+	hw->ts_irq = ts;
+
+	return IRQ_WAKE_THREAD;
+}
+
+static irqreturn_t st_lis2dw12_handler_thread(int irq, void *private)
+{
+	struct st_lis2dw12_hw *hw = private;
+	u8 status;
+	s64 code;
+	int err;
+
+	err = hw->tf->read(hw->dev, ST_LIS2DW12_STATUS_ADDR, sizeof(status),
+			   &status);
+	if (err < 0)
+		return IRQ_HANDLED;
+
+	if (status & ST_LIS2DW12_STATUS_FTH_MASK) {
+		mutex_lock(&hw->fifo_lock);
+		st_lis2dw12_read_fifo(hw);
+		mutex_unlock(&hw->fifo_lock);
+	}
+
+	if (((status & ST_LIS2DW12_STATUS_TAP_MASK) &&
+	     (hw->enable_mask & BIT(ST_LIS2DW12_ID_TAP))) ||
+	    ((status & ST_LIS2DW12_STATUS_TAP_TAP_MASK) &&
+	     (hw->enable_mask & BIT(ST_LIS2DW12_ID_TAP_TAP)))) {
+		struct iio_dev *iio_dev;
+		enum iio_chan_type type;
+		u8 source;
+
+		err = hw->tf->read(hw->dev, ST_LIS2DW12_TAP_SRC_ADDR,
+				   sizeof(source), &source);
+		if (err < 0)
+			return IRQ_HANDLED;
+
+		/* Consider can have Tap and Double Tap events contemporarely */
+		if (source & ST_LIS2DW12_DTAP_SRC_MASK) {
+			iio_dev = hw->iio_devs[ST_LIS2DW12_ID_TAP_TAP];
+			type = STM_IIO_TAP_TAP;
+			code = IIO_UNMOD_EVENT_CODE(type, -1,
+						    IIO_EV_TYPE_THRESH,
+						    IIO_EV_DIR_RISING);
+			iio_push_event(iio_dev, code,
+				       st_lis2dw12_get_timestamp(hw));
+		}
+
+		if (source & ST_LIS2DW12_STAP_SRC_MASK) {
+			iio_dev = hw->iio_devs[ST_LIS2DW12_ID_TAP];
+			type = STM_IIO_TAP;
+			code = IIO_UNMOD_EVENT_CODE(type, -1,
+						    IIO_EV_TYPE_THRESH,
+						    IIO_EV_DIR_RISING);
+			iio_push_event(iio_dev, code,
+				       st_lis2dw12_get_timestamp(hw));
+		}
+	}
+
+	if (status & ST_LIS2DW12_STATUS_WU_MASK) {
+		u8 wu_src;
+
+		err = hw->tf->read(hw->dev, ST_LIS2DW12_WU_SRC_ADDR,
+				   sizeof(wu_src), &wu_src);
+		if (err < 0)
+			return IRQ_HANDLED;
+
+		code = IIO_UNMOD_EVENT_CODE(STM_IIO_TAP_TAP, -1,
+					    IIO_EV_TYPE_THRESH,
+					    IIO_EV_DIR_RISING);
+		iio_push_event(hw->iio_devs[ST_LIS2DW12_ID_WU], STM_IIO_GESTURE,
+			       st_lis2dw12_get_timestamp(hw));
+	}
+
+	return IRQ_HANDLED;
+}
+
+int st_lis2dw12_fifo_setup(struct st_lis2dw12_hw *hw)
+{
+	struct iio_dev *iio_dev = hw->iio_devs[ST_LIS2DW12_ID_ACC];
+#if KERNEL_VERSION(5, 13, 0) > LINUX_VERSION_CODE
+	struct iio_buffer *buffer;
+#endif /* LINUX_VERSION_CODE */
+	int ret;
+
+	ret = devm_request_threaded_irq(hw->dev, hw->irq,
+					st_lis2dw12_handler_irq,
+					st_lis2dw12_handler_thread,
+					IRQF_TRIGGER_HIGH | IRQF_ONESHOT,
+					"st_lis2dw12", hw);
+	if (ret) {
+		dev_err(hw->dev, "failed to request trigger irq %d\n",
+			hw->irq);
+		return ret;
+	}
+
+#if KERNEL_VERSION(5, 19, 0) <= LINUX_VERSION_CODE
+	ret = devm_iio_kfifo_buffer_setup(hw->dev, iio_dev,
+					  &st_lis2dw12_acc_buffer_setup_ops);
+	if (ret)
+		return ret;
+#elif KERNEL_VERSION(5, 13, 0) <= LINUX_VERSION_CODE
+	ret = devm_iio_kfifo_buffer_setup(hw->dev, iio_dev,
+					  INDIO_BUFFER_SOFTWARE,
+					  &st_lis2dw12_acc_buffer_setup_ops);
+	if (ret)
+		return ret;
+#else /* LINUX_VERSION_CODE */
+	buffer = devm_iio_kfifo_allocate(hw->dev);
+	if (!buffer)
+		return -ENOMEM;
+
+	iio_device_attach_buffer(iio_dev, buffer);
+	iio_dev->setup_ops = &st_lis2dw12_acc_buffer_setup_ops;
+	iio_dev->modes |= INDIO_BUFFER_SOFTWARE;
+#endif /* LINUX_VERSION_CODE */
+
+	return 0;
+}
+
diff --git a/drivers/iio/stm/accel/st_lis2dw12_core.c b/drivers/iio/stm/accel/st_lis2dw12_core.c
new file mode 100644
index 000000000..802ae431c
--- /dev/null
+++ b/drivers/iio/stm/accel/st_lis2dw12_core.c
@@ -0,0 +1,1048 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * STMicroelectronics lis2dw12 driver
+ *
+ * MEMS Software Solutions Team
+ *
+ * Copyright 2016 STMicroelectronics Inc.
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/device.h>
+#include <linux/delay.h>
+#include <linux/iio/sysfs.h>
+#include <linux/interrupt.h>
+#include <asm/unaligned.h>
+
+#include <linux/platform_data/st_sensors_pdata.h>
+
+#include "st_lis2dw12.h"
+
+#define ST_LIS2DW12_WHOAMI_ADDR			0x0f
+#define ST_LIS2DW12_WHOAMI_VAL			0x44
+
+#define ST_LIS2DW12_CTRL1_ADDR			0x20
+#define ST_LIS2DW12_ODR_MASK			GENMASK(7, 4)
+#define ST_LIS2DW12_MODE_MASK			GENMASK(3, 2)
+#define ST_LIS2DW12_LP_MODE_MASK		GENMASK(1, 0)
+
+#define ST_LIS2DW12_CTRL2_ADDR			0x21
+#define ST_LIS2DW12_BDU_MASK			BIT(3)
+#define ST_LIS2DW12_RESET_MASK			BIT(6)
+
+#define ST_LIS2DW12_CTRL3_ADDR			0x22
+#define ST_LIS2DW12_LIR_MASK			BIT(4)
+#define ST_LIS2DW12_ST_MASK			GENMASK(7, 6)
+
+#define ST_LIS2DW12_CTRL4_INT1_CTRL_ADDR	0x23
+#define ST_LIS2DW12_DRDY_MASK			BIT(0)
+#define ST_LIS2DW12_FTH_INT_MASK		BIT(1)
+#define ST_LIS2DW12_TAP_INT1_MASK		BIT(6)
+#define ST_LIS2DW12_TAP_TAP_INT1_MASK		BIT(3)
+#define ST_LIS2DW12_FF_INT1_MASK		BIT(4)
+#define ST_LIS2DW12_WU_INT1_MASK		BIT(5)
+
+#define ST_LIS2DW12_CTRL5_INT2_CTRL_ADDR	0x24
+
+#define ST_LIS2DW12_CTRL6_ADDR			0x25
+#define ST_LIS2DW12_LN_MASK			BIT(2)
+#define ST_LIS2DW12_FS_MASK			GENMASK(5, 4)
+#define ST_LIS2DW12_BW_MASK			GENMASK(7, 6)
+
+#define ST_LIS2DW12_OUT_X_L_ADDR		0x28
+#define ST_LIS2DW12_OUT_Y_L_ADDR		0x2a
+#define ST_LIS2DW12_OUT_Z_L_ADDR		0x2c
+
+#define ST_LIS2DW12_TAP_THS_X_ADDR		0x30
+#define ST_LIS2DW12_TAP_THS_Y_ADDR		0x31
+#define ST_LIS2DW12_TAP_THS_Z_ADDR		0x32
+
+#define ST_LIS2DW12_TAP_AXIS_MASK		GENMASK(7, 5)
+#define ST_LIS2DW12_TAP_THS_MAK			GENMASK(4, 0)
+
+#define ST_LIS2DW12_INT_DUR_ADDR		0x33
+
+#define ST_LIS2DW12_WAKE_UP_THS_ADDR		0x34
+#define ST_LIS2DW12_WAKE_UP_THS_MAK		GENMASK(5, 0)
+#define ST_LIS2DW12_SINGLE_DOUBLE_TAP_MAK	BIT(7)
+
+#define ST_LIS2DW12_FREE_FALL_ADDR		0x36
+#define ST_LIS2DW12_FREE_FALL_THS_MASK		GENMASK(2, 0)
+#define ST_LIS2DW12_FREE_FALL_DUR_MASK		GENMASK(7, 3)
+
+#define ST_LIS2DW12_ABS_INT_CFG_ADDR		0x3f
+#define ST_LIS2DW12_ALL_INT_MASK		BIT(5)
+#define ST_LIS2DW12_INT2_ON_INT1_MASK		BIT(6)
+#define ST_LIS2DW12_DRDY_PULSED_MASK		BIT(7)
+
+#define ST_LIS2DW12_FS_2G_GAIN			IIO_G_TO_M_S_2(244)
+#define ST_LIS2DW12_FS_4G_GAIN			IIO_G_TO_M_S_2(488)
+#define ST_LIS2DW12_FS_8G_GAIN			IIO_G_TO_M_S_2(976)
+#define ST_LIS2DW12_FS_16G_GAIN			IIO_G_TO_M_S_2(1952)
+
+#define ST_LIS2DW12_SELFTEST_MIN		285
+#define ST_LIS2DW12_SELFTEST_MAX		6150
+
+struct st_lis2dw12_std_entry {
+	u16 odr;
+	u8 val;
+};
+
+struct st_lis2dw12_std_entry st_lis2dw12_std_table[] = {
+	{   12, 12 },
+	{   25, 18 },
+	{   50, 24 },
+	{  100, 24 },
+	{  200, 32 },
+	{  400, 48 },
+	{  800, 64 },
+	{ 1600, 64 },
+};
+
+struct st_lis2dw12_odr {
+	u16 hz;
+	u8 val;
+};
+
+static const struct st_lis2dw12_odr st_lis2dw12_odr_table[] = {
+	{    0, 0x0 }, /* power-down */
+	{   12, 0x2 }, /* LP 12.5Hz */
+	{   25, 0x3 }, /* LP 25Hz*/
+	{   50, 0x4 }, /* LP 50Hz*/
+	{  100, 0x5 }, /* LP 100Hz*/
+	{  200, 0x6 }, /* LP 200Hz*/
+	{  400, 0x7 }, /* HP 400Hz*/
+	{  800, 0x8 }, /* HP 800Hz*/
+	{ 1600, 0x9 }, /* HP 1600Hz*/
+};
+
+struct st_lis2dw12_fs {
+	u32 gain;
+	u8 val;
+};
+
+static const struct st_lis2dw12_fs st_lis2dw12_fs_table[] = {
+	{  ST_LIS2DW12_FS_2G_GAIN, 0x0 },
+	{  ST_LIS2DW12_FS_4G_GAIN, 0x1 },
+	{  ST_LIS2DW12_FS_8G_GAIN, 0x2 },
+	{ ST_LIS2DW12_FS_16G_GAIN, 0x3 },
+};
+
+struct st_lis2dw12_selftest_req {
+	char *mode;
+	u8 val;
+};
+
+struct st_lis2dw12_selftest_req st_lis2dw12_selftest_table[] = {
+	{ "disabled", 0x0 },
+	{ "positive-sign", 0x1 },
+	{ "negative-sign", 0x2 },
+};
+
+#define ST_LIS2DW12_ACC_CHAN(addr, ch2, idx)				\
+{									\
+	.type = IIO_ACCEL,						\
+	.address = addr,						\
+	.modified = 1,							\
+	.channel2 = ch2,						\
+	.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) |			\
+			      BIT(IIO_CHAN_INFO_SCALE),			\
+	.info_mask_shared_by_all = BIT(IIO_CHAN_INFO_SAMP_FREQ),	\
+	.scan_index = idx,						\
+	.scan_type = {							\
+		.sign = 's',						\
+		.realbits = 14,						\
+		.storagebits = 16,					\
+		.shift = 2,						\
+		.endianness = IIO_LE,					\
+	},								\
+}
+
+const struct iio_event_spec st_lis2dw12_fifo_flush_event = {
+	.type = STM_IIO_EV_TYPE_FIFO_FLUSH,
+	.dir = IIO_EV_DIR_EITHER,
+};
+
+const struct iio_event_spec st_lis2dw12_rthr_event = {
+	.type = IIO_EV_TYPE_THRESH,
+	.dir = IIO_EV_DIR_RISING,
+	.mask_separate = BIT(IIO_EV_INFO_ENABLE),
+};
+
+#define ST_LIS2DW12_EVENT_CHANNEL(chan_type, evt_spec)	\
+{							\
+	.type = chan_type,				\
+	.modified = 0,					\
+	.scan_index = -1,				\
+	.indexed = -1,					\
+	.event_spec = evt_spec,				\
+	.num_event_specs = 1,				\
+}
+
+static const struct iio_chan_spec st_lis2dw12_acc_channels[] = {
+	ST_LIS2DW12_ACC_CHAN(ST_LIS2DW12_OUT_X_L_ADDR, IIO_MOD_X, 0),
+	ST_LIS2DW12_ACC_CHAN(ST_LIS2DW12_OUT_Y_L_ADDR, IIO_MOD_Y, 1),
+	ST_LIS2DW12_ACC_CHAN(ST_LIS2DW12_OUT_Z_L_ADDR, IIO_MOD_Z, 2),
+	ST_LIS2DW12_EVENT_CHANNEL(IIO_ACCEL, &st_lis2dw12_fifo_flush_event),
+	IIO_CHAN_SOFT_TIMESTAMP(3),
+};
+
+static const struct iio_chan_spec st_lis2dw12_tap_tap_channels[] = {
+	ST_LIS2DW12_EVENT_CHANNEL(STM_IIO_TAP_TAP, &st_lis2dw12_rthr_event),
+};
+
+static const struct iio_chan_spec st_lis2dw12_tap_channels[] = {
+	ST_LIS2DW12_EVENT_CHANNEL(STM_IIO_TAP, &st_lis2dw12_rthr_event),
+};
+
+static const struct iio_chan_spec st_lis2dw12_wu_channels[] = {
+	ST_LIS2DW12_EVENT_CHANNEL(STM_IIO_GESTURE, &st_lis2dw12_rthr_event),
+};
+
+int st_lis2dw12_write_with_mask(struct st_lis2dw12_hw *hw, u8 addr, u8 mask,
+				u8 val)
+{
+	u8 data;
+	int err;
+
+	mutex_lock(&hw->lock);
+
+	err = hw->tf->read(hw->dev, addr, sizeof(data), &data);
+	if (err < 0) {
+		dev_err(hw->dev, "failed to read %02x register\n", addr);
+		goto unlock;
+	}
+
+	data = (data & ~mask) | ((val << __ffs(mask)) & mask);
+
+	err = hw->tf->write(hw->dev, addr, sizeof(data), &data);
+	if (err < 0)
+		dev_err(hw->dev, "failed to write %02x register\n", addr);
+
+unlock:
+	mutex_unlock(&hw->lock);
+
+	return err;
+}
+
+static int st_lis2dw12_set_fs(struct st_lis2dw12_sensor *sensor, u16 gain)
+{
+	int i, err;
+
+	for (i = 0; i < ARRAY_SIZE(st_lis2dw12_fs_table); i++)
+		if (st_lis2dw12_fs_table[i].gain == gain)
+			break;
+
+	if (i == ARRAY_SIZE(st_lis2dw12_fs_table))
+		return -EINVAL;
+
+	err = st_lis2dw12_write_with_mask(sensor->hw, ST_LIS2DW12_CTRL6_ADDR,
+					  ST_LIS2DW12_FS_MASK,
+					  st_lis2dw12_fs_table[i].val);
+	if (err < 0)
+		return err;
+
+	sensor->gain = gain;
+
+	return 0;
+}
+
+static inline int st_lis2dw12_get_odr_idx(u16 odr, u8 *idx)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(st_lis2dw12_odr_table); i++)
+		if (st_lis2dw12_odr_table[i].hz == odr)
+			break;
+
+	if (i == ARRAY_SIZE(st_lis2dw12_odr_table))
+		return -EINVAL;
+
+	*idx = i;
+
+	return 0;
+}
+
+static int st_lis2dw12_set_std_level(struct st_lis2dw12_hw *hw, u16 odr)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(st_lis2dw12_std_table); i++)
+		if (st_lis2dw12_std_table[i].odr == odr)
+			break;
+
+	if (i == ARRAY_SIZE(st_lis2dw12_std_table))
+		return -EINVAL;
+
+	hw->std_level = st_lis2dw12_std_table[i].val;
+
+	return 0;
+}
+
+static u16 st_lis2dw12_check_odr_dependency(struct st_lis2dw12_hw *hw, u16 odr,
+					    enum st_lis2dw12_sensor_id ref_id)
+{
+	struct st_lis2dw12_sensor *ref = iio_priv(hw->iio_devs[ref_id]);
+	bool enable = odr > 0;
+	u16 ret;
+
+	if (enable) {
+		if (hw->enable_mask & BIT(ref_id))
+			ret = (ref->odr < odr) ? odr : ref->odr;
+		else
+			ret = odr;
+	} else {
+		ret = (hw->enable_mask & BIT(ref_id)) ? ref->odr : 0;
+	}
+
+	return ret;
+}
+
+static int st_lis2dw12_set_odr(struct st_lis2dw12_sensor *sensor, u16 req_odr)
+{
+	struct st_lis2dw12_hw *hw = sensor->hw;
+	u8 mode, val, i;
+	int err, odr;
+
+	for (i = 0; i < ST_LIS2DW12_ID_MAX; i++) {
+		if (i == sensor->id)
+			continue;
+
+		odr = st_lis2dw12_check_odr_dependency(hw, req_odr, i);
+		if (odr != req_odr)
+			/* devince already configured */
+			return 0;
+	}
+
+	err = st_lis2dw12_get_odr_idx(req_odr, &i);
+	if (err < 0)
+		return err;
+
+	mode = req_odr > 200 ? 0x1 : 0x0;
+	val = (st_lis2dw12_odr_table[i].val << __ffs(ST_LIS2DW12_ODR_MASK)) |
+	      (mode << __ffs(ST_LIS2DW12_MODE_MASK)) | 0x01;
+
+	err = hw->tf->write(hw->dev, ST_LIS2DW12_CTRL1_ADDR, sizeof(val),
+			    &val);
+
+	return err < 0 ? err : 0;
+}
+
+static int st_lis2dw12_check_whoami(struct st_lis2dw12_hw *hw)
+{
+	int err;
+	u8 data;
+
+	err = hw->tf->read(hw->dev, ST_LIS2DW12_WHOAMI_ADDR, sizeof(data),
+			   &data);
+	if (err < 0) {
+		dev_err(hw->dev, "failed to read whoami register\n");
+		return err;
+	}
+
+	if (data != ST_LIS2DW12_WHOAMI_VAL) {
+		dev_err(hw->dev, "wrong whoami %02x vs %02x\n",
+			data, ST_LIS2DW12_WHOAMI_VAL);
+		return -ENODEV;
+	}
+
+	return 0;
+}
+
+static int st_lis2dw12_of_get_drdy_pin(struct st_lis2dw12_hw *hw,
+				       int *drdy_pin)
+{
+	struct device_node *np = hw->dev->of_node;
+
+	if (!np)
+		return -EINVAL;
+
+	return of_property_read_u32(np, "st,drdy-int-pin", drdy_pin);
+}
+
+static int st_lis2dw12_get_drdy_pin(struct st_lis2dw12_hw *hw, u8 *drdy_reg)
+{
+	int err = 0, drdy_pin;
+
+	if (st_lis2dw12_of_get_drdy_pin(hw, &drdy_pin) < 0) {
+		struct st_sensors_platform_data *pdata;
+		struct device *dev = hw->dev;
+
+		pdata = (struct st_sensors_platform_data *)dev->platform_data;
+		drdy_pin = pdata ? pdata->drdy_int_pin : 1;
+	}
+
+	switch (drdy_pin) {
+	case 1:
+		*drdy_reg = ST_LIS2DW12_CTRL4_INT1_CTRL_ADDR;
+		break;
+	case 2:
+		*drdy_reg = ST_LIS2DW12_CTRL5_INT2_CTRL_ADDR;
+		break;
+	default:
+		dev_err(hw->dev, "unsupported interrupt pin\n");
+		err = -EINVAL;
+		break;
+	}
+
+	return err;
+}
+
+static int st_lis2dw12_init_hw(struct st_lis2dw12_hw *hw)
+{
+	u8 drdy_reg;
+	int err;
+
+	/* soft reset the device */
+	err = st_lis2dw12_write_with_mask(hw, ST_LIS2DW12_CTRL2_ADDR,
+					  ST_LIS2DW12_RESET_MASK, 1);
+	if (err < 0)
+		return err;
+
+	/* enable BDU */
+	err = st_lis2dw12_write_with_mask(hw, ST_LIS2DW12_CTRL2_ADDR,
+					  ST_LIS2DW12_BDU_MASK, 1);
+	if (err < 0)
+		return err;
+
+	/* enable all interrupts */
+	err = st_lis2dw12_write_with_mask(hw, ST_LIS2DW12_ABS_INT_CFG_ADDR,
+					  ST_LIS2DW12_ALL_INT_MASK, 1);
+	if (err < 0)
+		return err;
+
+	/* configure fifo watermark */
+	err = st_lis2dw12_update_fifo_watermark(hw, hw->watermark);
+	if (err < 0)
+		return err;
+
+	/* configure default free fall event threshold */
+	err = st_lis2dw12_write_with_mask(hw, ST_LIS2DW12_FREE_FALL_ADDR,
+					  ST_LIS2DW12_FREE_FALL_THS_MASK, 1);
+	if (err < 0)
+		return err;
+
+	/* configure default free fall event duration */
+	err = st_lis2dw12_write_with_mask(hw, ST_LIS2DW12_FREE_FALL_ADDR,
+					  ST_LIS2DW12_FREE_FALL_DUR_MASK, 1);
+	if (err < 0)
+		return err;
+
+	/* enable tap event on all axes */
+	err = st_lis2dw12_write_with_mask(hw, ST_LIS2DW12_TAP_THS_Z_ADDR,
+					  ST_LIS2DW12_TAP_AXIS_MASK, 0x7);
+	if (err < 0)
+		return err;
+
+	/* configure default threshold for Tap event recognition */
+	err = st_lis2dw12_write_with_mask(hw, ST_LIS2DW12_TAP_THS_X_ADDR,
+					  ST_LIS2DW12_TAP_THS_MAK, 9);
+	if (err < 0)
+		return err;
+
+	err = st_lis2dw12_write_with_mask(hw, ST_LIS2DW12_TAP_THS_Y_ADDR,
+					  ST_LIS2DW12_TAP_THS_MAK, 9);
+	if (err < 0)
+		return err;
+
+	err = st_lis2dw12_write_with_mask(hw, ST_LIS2DW12_TAP_THS_Z_ADDR,
+					  ST_LIS2DW12_TAP_THS_MAK, 9);
+	if (err < 0)
+		return err;
+
+	/* low noise enabled by default */
+	err = st_lis2dw12_write_with_mask(hw, ST_LIS2DW12_CTRL6_ADDR,
+					  ST_LIS2DW12_LN_MASK, 1);
+	if (err < 0)
+		return err;
+
+	/* BW = ODR/4 */
+	err = st_lis2dw12_write_with_mask(hw, ST_LIS2DW12_CTRL6_ADDR,
+					  ST_LIS2DW12_BW_MASK, 1);
+	if (err < 0)
+		return err;
+
+	/* configure interrupt pin */
+	err = st_lis2dw12_get_drdy_pin(hw, &drdy_reg);
+	if (err < 0)
+		return err;
+
+	return st_lis2dw12_write_with_mask(hw, drdy_reg,
+					   ST_LIS2DW12_FTH_INT_MASK, 1);
+}
+
+static ssize_t
+st_lis2dw12_sysfs_sampling_frequency_avl(struct device *dev,
+					 struct device_attribute *attr,
+					 char *buf)
+{
+	int i, len = 0;
+
+	for (i = 1; i < ARRAY_SIZE(st_lis2dw12_odr_table); i++)
+		len += scnprintf(buf + len, PAGE_SIZE - len, "%d ",
+				 st_lis2dw12_odr_table[i].hz);
+	buf[len - 1] = '\n';
+
+	return len;
+}
+
+static ssize_t st_lis2dw12_sysfs_scale_avail(struct device *dev,
+					     struct device_attribute *attr,
+					     char *buf)
+{
+	int i, len = 0;
+
+	for (i = 0; i < ARRAY_SIZE(st_lis2dw12_fs_table); i++)
+		len += scnprintf(buf + len, PAGE_SIZE - len, "0.%06u ",
+				 st_lis2dw12_fs_table[i].gain);
+	buf[len - 1] = '\n';
+
+	return len;
+}
+
+int st_lis2dw12_sensor_set_enable(struct st_lis2dw12_sensor *sensor,
+				  bool enable)
+{
+	struct st_lis2dw12_hw *hw = sensor->hw;
+	u16 val = enable ? sensor->odr : 0;
+	int err;
+
+	err = st_lis2dw12_set_odr(sensor, val);
+	if (err < 0)
+		return err;
+
+	if (enable)
+		hw->enable_mask |= BIT(sensor->id);
+	else
+		hw->enable_mask &= ~BIT(sensor->id);
+
+	return 0;
+}
+
+static int st_lis2dw12_read_oneshot(struct st_lis2dw12_sensor *sensor,
+				    u8 addr, int *val)
+{
+	struct st_lis2dw12_hw *hw = sensor->hw;
+	int err, delay;
+	u8 data[2];
+
+	err = st_lis2dw12_sensor_set_enable(sensor, true);
+	if (err < 0)
+		return err;
+
+	/* sample to discard, 3 * odr us */
+	delay = 3000000 / sensor->odr;
+	usleep_range(delay, delay + 1);
+
+	err = hw->tf->read(hw->dev, addr, sizeof(data), data);
+	if (err < 0)
+		return err;
+
+	st_lis2dw12_sensor_set_enable(sensor, false);
+
+	*val = (s16)get_unaligned_le16(data);
+
+	return IIO_VAL_INT;
+}
+
+static int st_lis2dw12_read_raw(struct iio_dev *iio_dev,
+				struct iio_chan_spec const *ch,
+				int *val, int *val2, long mask)
+{
+	struct st_lis2dw12_sensor *sensor = iio_priv(iio_dev);
+	int ret;
+
+	switch (mask) {
+	case IIO_CHAN_INFO_RAW:
+		mutex_lock(&iio_dev->mlock);
+		if (iio_buffer_enabled(iio_dev)) {
+			ret = -EBUSY;
+			mutex_unlock(&iio_dev->mlock);
+			break;
+		}
+		ret = st_lis2dw12_read_oneshot(sensor, ch->address, val);
+		mutex_unlock(&iio_dev->mlock);
+		break;
+	case IIO_CHAN_INFO_SCALE:
+		*val = 0;
+		*val2 = sensor->gain;
+		ret = IIO_VAL_INT_PLUS_MICRO;
+		break;
+	case IIO_CHAN_INFO_SAMP_FREQ:
+		*val = sensor->odr;
+		ret = IIO_VAL_INT;
+		break;
+	default:
+		ret = -EINVAL;
+		break;
+	}
+
+	return ret;
+}
+
+static int st_lis2dw12_write_raw(struct iio_dev *iio_dev,
+				 struct iio_chan_spec const *chan,
+				 int val, int val2, long mask)
+{
+	struct st_lis2dw12_sensor *sensor = iio_priv(iio_dev);
+	int err;
+
+	mutex_lock(&iio_dev->mlock);
+
+	switch (mask) {
+	case IIO_CHAN_INFO_SCALE:
+		err = st_lis2dw12_set_fs(sensor, val2);
+		break;
+	case IIO_CHAN_INFO_SAMP_FREQ: {
+		u8 data;
+
+		err = st_lis2dw12_set_std_level(sensor->hw, val);
+		if (err < 0)
+			break;
+
+		err = st_lis2dw12_get_odr_idx(val, &data);
+		if (!err)
+			sensor->odr = val;
+		break;
+	}
+	default:
+		err = -EINVAL;
+		break;
+	}
+
+	mutex_unlock(&iio_dev->mlock);
+
+	return err;
+}
+
+static int st_lis2dw12_read_event_config(struct iio_dev *iio_dev,
+					 const struct iio_chan_spec *chan,
+					 enum iio_event_type type,
+					 enum iio_event_direction dir)
+{
+	struct st_lis2dw12_sensor *sensor = iio_priv(iio_dev);
+	struct st_lis2dw12_hw *hw = sensor->hw;
+
+	return !!(hw->enable_mask & BIT(sensor->id));
+}
+
+static int st_lis2dw12_write_event_config(struct iio_dev *iio_dev,
+					  const struct iio_chan_spec *chan,
+					  enum iio_event_type type,
+					  enum iio_event_direction dir,
+					  int state)
+{
+	struct st_lis2dw12_sensor *sensor = iio_priv(iio_dev);
+	struct st_lis2dw12_hw *hw = sensor->hw;
+	u8 data[2] = {}, drdy_val, drdy_mask;
+	int err;
+
+	/* Read initial configuration data */
+	err = hw->tf->read(hw->dev, ST_LIS2DW12_INT_DUR_ADDR,
+				   sizeof(data), data);
+	if (err < 0)
+		return -EINVAL;
+
+	switch (sensor->id) {
+	case ST_LIS2DW12_ID_WU:
+		drdy_mask = ST_LIS2DW12_WU_INT1_MASK;
+		drdy_val = state ? 1 : 0;
+		data[1] = state ? 0x02 : 0;
+		break;
+	case ST_LIS2DW12_ID_TAP_TAP:
+		drdy_mask = ST_LIS2DW12_TAP_TAP_INT1_MASK;
+		drdy_val = state ? 1 : 0;
+		if (state) {
+			data[0] |= 0x7f;
+			data[1] |= 0x80;
+		} else {
+			data[0] &= ~0x7f;
+			data[1] &= ~0x80;
+		}
+		break;
+	case ST_LIS2DW12_ID_TAP:
+		drdy_mask = ST_LIS2DW12_TAP_INT1_MASK;
+		drdy_val = state ? 1 : 0;
+		if (state)
+			data[0] |= 6;
+		else
+			data[0] &= ~6;
+
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	err = hw->tf->write(hw->dev, ST_LIS2DW12_INT_DUR_ADDR,
+			    sizeof(data), data);
+	if (err < 0)
+		return err;
+
+	err = st_lis2dw12_write_with_mask(hw, ST_LIS2DW12_CTRL4_INT1_CTRL_ADDR,
+					  drdy_mask, drdy_val);
+	if (err < 0)
+		return err;
+
+	return st_lis2dw12_sensor_set_enable(sensor, state);
+}
+
+static ssize_t st_lis2dw12_get_hwfifo_watermark(struct device *dev,
+						struct device_attribute *attr,
+						char *buf)
+{
+	struct iio_dev *iio_dev = dev_to_iio_dev(dev);
+	struct st_lis2dw12_sensor *sensor = iio_priv(iio_dev);
+	struct st_lis2dw12_hw *hw = sensor->hw;
+
+	return sprintf(buf, "%d\n", hw->watermark);
+}
+
+static ssize_t
+st_lis2dw12_get_max_hwfifo_watermark(struct device *dev,
+				     struct device_attribute *attr,
+				     char *buf)
+{
+	return sprintf(buf, "%d\n", ST_LIS2DW12_MAX_WATERMARK);
+}
+
+static ssize_t st_lis2dw12_get_selftest_avail(struct device *dev,
+					      struct device_attribute *attr,
+					      char *buf)
+{
+	return sprintf(buf, "%s, %s\n", st_lis2dw12_selftest_table[1].mode,
+		       st_lis2dw12_selftest_table[2].mode);
+}
+
+static ssize_t st_lis2dw12_get_selftest_status(struct device *dev,
+					       struct device_attribute *attr,
+					       char *buf)
+{
+	struct iio_dev *iio_dev = dev_to_iio_dev(dev);
+	struct st_lis2dw12_sensor *sensor = iio_priv(iio_dev);
+	struct st_lis2dw12_hw *hw = sensor->hw;
+	char *ret;
+
+	switch (hw->st_status) {
+	case ST_LIS2DW12_ST_PASS:
+		ret = "pass";
+		break;
+	case ST_LIS2DW12_ST_FAIL:
+		ret = "fail";
+		break;
+	default:
+	case ST_LIS2DW12_ST_RESET:
+		ret = "na";
+		break;
+	}
+
+	return sprintf(buf, "%s\n", ret);
+}
+
+static ssize_t st_lis2dw12_enable_selftest(struct device *dev,
+					   struct device_attribute *attr,
+					   const char *buf, size_t size)
+{
+	struct iio_dev *iio_dev = dev_to_iio_dev(dev);
+	struct st_lis2dw12_sensor *sensor = iio_priv(iio_dev);
+	struct st_lis2dw12_hw *hw = sensor->hw;
+	s16 acc_st_x = 0, acc_st_y = 0, acc_st_z = 0;
+	s16 acc_x = 0, acc_y = 0, acc_z = 0;
+	u8 data[ST_LIS2DW12_DATA_SIZE], val;
+	int i, err, gain;
+
+	mutex_lock(&iio_dev->mlock);
+
+	if (iio_buffer_enabled(iio_dev)) {
+		err = -EBUSY;
+		goto unlock;
+	}
+
+	for (i = 0; i < ARRAY_SIZE(st_lis2dw12_selftest_table); i++)
+		if (!strncmp(buf, st_lis2dw12_selftest_table[i].mode,
+			     size - 2))
+			break;
+
+	if (i == ARRAY_SIZE(st_lis2dw12_selftest_table)) {
+		err = -EINVAL;
+		goto unlock;
+	}
+
+	hw->st_status = ST_LIS2DW12_ST_RESET;
+	val = st_lis2dw12_selftest_table[i].val;
+	gain = sensor->gain;
+
+	/* fs = 2g, odr = 50Hz */
+	err = st_lis2dw12_set_fs(sensor, ST_LIS2DW12_FS_2G_GAIN);
+	if (err < 0)
+		goto unlock;
+
+	err = st_lis2dw12_set_odr(sensor, 50);
+	if (err < 0)
+		goto unlock;
+
+	msleep(200);
+
+	for (i = 0; i < 5; i++) {
+		err = hw->tf->read(hw->dev, ST_LIS2DW12_OUT_X_L_ADDR,
+				   sizeof(data), data);
+		if (err < 0)
+			goto unlock;
+
+		acc_x += ((s16)get_unaligned_le16(&data[0]) >> 2) / 5;
+		acc_y += ((s16)get_unaligned_le16(&data[2]) >> 2) / 5;
+		acc_z += ((s16)get_unaligned_le16(&data[4]) >> 2) / 5;
+
+		msleep(10);
+	}
+
+	/* enable self test */
+	err = st_lis2dw12_write_with_mask(hw, ST_LIS2DW12_CTRL3_ADDR,
+					  ST_LIS2DW12_ST_MASK, val);
+	if (err < 0)
+		goto unlock;
+
+	msleep(200);
+
+	for (i = 0; i < 5; i++) {
+		err = hw->tf->read(hw->dev, ST_LIS2DW12_OUT_X_L_ADDR,
+				   sizeof(data), data);
+		if (err < 0)
+			goto unlock;
+
+		acc_st_x += ((s16)get_unaligned_le16(&data[0]) >> 2) / 5;
+		acc_st_y += ((s16)get_unaligned_le16(&data[2]) >> 2) / 5;
+		acc_st_z += ((s16)get_unaligned_le16(&data[4]) >> 2) / 5;
+
+		msleep(10);
+	}
+
+	if (abs(acc_st_x - acc_x) >= ST_LIS2DW12_SELFTEST_MIN &&
+	    abs(acc_st_x - acc_x) <= ST_LIS2DW12_SELFTEST_MAX &&
+	    abs(acc_st_y - acc_y) >= ST_LIS2DW12_SELFTEST_MIN &&
+	    abs(acc_st_y - acc_y) >= ST_LIS2DW12_SELFTEST_MIN &&
+	    abs(acc_st_z - acc_z) >= ST_LIS2DW12_SELFTEST_MIN &&
+	    abs(acc_st_z - acc_z) >= ST_LIS2DW12_SELFTEST_MIN)
+		hw->st_status = ST_LIS2DW12_ST_PASS;
+	else
+		hw->st_status = ST_LIS2DW12_ST_FAIL;
+
+	/* disable self test */
+	err = st_lis2dw12_write_with_mask(hw, ST_LIS2DW12_CTRL3_ADDR,
+					  ST_LIS2DW12_ST_MASK, 0);
+	if (err < 0)
+		goto unlock;
+
+	err = st_lis2dw12_set_fs(sensor, gain);
+	if (err < 0)
+		goto unlock;
+
+	err = st_lis2dw12_sensor_set_enable(sensor, false);
+
+unlock:
+	mutex_unlock(&iio_dev->mlock);
+
+	return err < 0 ? err : size;
+}
+
+static IIO_DEV_ATTR_SAMP_FREQ_AVAIL(st_lis2dw12_sysfs_sampling_frequency_avl);
+static IIO_DEVICE_ATTR(in_accel_scale_available, 0444,
+		       st_lis2dw12_sysfs_scale_avail, NULL, 0);
+static IIO_DEVICE_ATTR(hwfifo_watermark, 0644,
+		       st_lis2dw12_get_hwfifo_watermark,
+		       st_lis2dw12_set_hwfifo_watermark, 0);
+static IIO_DEVICE_ATTR(hwfifo_watermark_max, 0444,
+		       st_lis2dw12_get_max_hwfifo_watermark, NULL, 0);
+static IIO_DEVICE_ATTR(hwfifo_flush, 0200, NULL,
+		       st_lis2dw12_flush_fifo, 0);
+static IIO_DEVICE_ATTR(selftest_available, 0444,
+		       st_lis2dw12_get_selftest_avail, NULL, 0);
+static IIO_DEVICE_ATTR(selftest, 0644, st_lis2dw12_get_selftest_status,
+		       st_lis2dw12_enable_selftest, 0);
+
+static struct attribute *st_lis2dw12_acc_attributes[] = {
+	&iio_dev_attr_sampling_frequency_available.dev_attr.attr,
+	&iio_dev_attr_in_accel_scale_available.dev_attr.attr,
+	&iio_dev_attr_hwfifo_watermark.dev_attr.attr,
+	&iio_dev_attr_hwfifo_watermark_max.dev_attr.attr,
+	&iio_dev_attr_hwfifo_flush.dev_attr.attr,
+	&iio_dev_attr_selftest_available.dev_attr.attr,
+	&iio_dev_attr_selftest.dev_attr.attr,
+	NULL,
+};
+
+static const struct attribute_group st_lis2dw12_acc_attribute_group = {
+	.attrs = st_lis2dw12_acc_attributes,
+};
+
+static const struct iio_info st_lis2dw12_acc_info = {
+	.attrs = &st_lis2dw12_acc_attribute_group,
+	.read_raw = st_lis2dw12_read_raw,
+	.write_raw = st_lis2dw12_write_raw,
+};
+
+static struct attribute *st_lis2dw12_wu_attributes[] = {
+	NULL,
+};
+
+static const struct attribute_group st_lis2dw12_wu_attribute_group = {
+	.attrs = st_lis2dw12_wu_attributes,
+};
+
+static const struct iio_info st_lis2dw12_wu_info = {
+	.attrs = &st_lis2dw12_wu_attribute_group,
+	.read_event_config = st_lis2dw12_read_event_config,
+	.write_event_config = st_lis2dw12_write_event_config,
+};
+
+static struct attribute *st_lis2dw12_tap_tap_attributes[] = {
+	NULL,
+};
+
+static const struct attribute_group st_lis2dw12_tap_tap_attribute_group = {
+	.attrs = st_lis2dw12_tap_tap_attributes,
+};
+
+static const struct iio_info st_lis2dw12_tap_tap_info = {
+	.attrs = &st_lis2dw12_tap_tap_attribute_group,
+	.read_event_config = st_lis2dw12_read_event_config,
+	.write_event_config = st_lis2dw12_write_event_config,
+};
+
+static struct attribute *st_lis2dw12_tap_attributes[] = {
+	NULL,
+};
+
+static const struct attribute_group st_lis2dw12_tap_attribute_group = {
+	.attrs = st_lis2dw12_tap_attributes,
+};
+
+static const struct iio_info st_lis2dw12_tap_info = {
+	.attrs = &st_lis2dw12_tap_attribute_group,
+	.read_event_config = st_lis2dw12_read_event_config,
+	.write_event_config = st_lis2dw12_write_event_config,
+};
+
+static const unsigned long st_lis2dw12_avail_scan_masks[] = { 0x7, 0x0 };
+static const unsigned long st_lis2dw12_event_avail_scan_masks[] = { 0x1, 0x0 };
+
+static struct iio_dev *st_lis2dw12_alloc_iiodev(struct st_lis2dw12_hw *hw,
+						enum st_lis2dw12_sensor_id id)
+{
+	struct st_lis2dw12_sensor *sensor;
+	struct iio_dev *iio_dev;
+
+	iio_dev = devm_iio_device_alloc(hw->dev, sizeof(*sensor));
+	if (!iio_dev)
+		return NULL;
+
+	iio_dev->modes = INDIO_DIRECT_MODE;
+	iio_dev->dev.parent = hw->dev;
+
+	sensor = iio_priv(iio_dev);
+	sensor->id = id;
+	sensor->hw = hw;
+
+	switch (id) {
+	case ST_LIS2DW12_ID_ACC:
+		iio_dev->channels = st_lis2dw12_acc_channels;
+		iio_dev->num_channels = ARRAY_SIZE(st_lis2dw12_acc_channels);
+		iio_dev->name = "lis2dw12_accel";
+		iio_dev->info = &st_lis2dw12_acc_info;
+		iio_dev->available_scan_masks = st_lis2dw12_avail_scan_masks;
+
+		sensor->odr = st_lis2dw12_odr_table[1].hz;
+		sensor->gain = st_lis2dw12_fs_table[0].gain;
+		break;
+	case ST_LIS2DW12_ID_WU:
+		iio_dev->channels = st_lis2dw12_wu_channels;
+		iio_dev->num_channels = ARRAY_SIZE(st_lis2dw12_wu_channels);
+		iio_dev->name = "lis2dw12_wk";
+		iio_dev->info = &st_lis2dw12_wu_info;
+		iio_dev->available_scan_masks =
+				st_lis2dw12_event_avail_scan_masks;
+
+		sensor->odr = st_lis2dw12_odr_table[7].hz;
+		break;
+	case ST_LIS2DW12_ID_TAP_TAP:
+		iio_dev->channels = st_lis2dw12_tap_tap_channels;
+		iio_dev->num_channels =
+			ARRAY_SIZE(st_lis2dw12_tap_tap_channels);
+		iio_dev->name = "lis2dw12_tap_tap";
+		iio_dev->info = &st_lis2dw12_tap_tap_info;
+		iio_dev->available_scan_masks =
+				st_lis2dw12_event_avail_scan_masks;
+
+		sensor->odr = st_lis2dw12_odr_table[7].hz;
+		break;
+	case ST_LIS2DW12_ID_TAP:
+		iio_dev->channels = st_lis2dw12_tap_channels;
+		iio_dev->num_channels = ARRAY_SIZE(st_lis2dw12_tap_channels);
+		iio_dev->name = "lis2dw12_tap";
+		iio_dev->info = &st_lis2dw12_tap_info;
+		iio_dev->available_scan_masks =
+				st_lis2dw12_event_avail_scan_masks;
+
+		sensor->odr = st_lis2dw12_odr_table[7].hz;
+		break;
+	default:
+		return NULL;
+	}
+
+	return iio_dev;
+}
+
+int st_lis2dw12_probe(struct device *dev, int irq,
+		      const struct st_lis2dw12_transfer_function *tf_ops)
+{
+	struct st_lis2dw12_hw *hw;
+	int i, err;
+
+	hw = devm_kzalloc(dev, sizeof(*hw), GFP_KERNEL);
+	if (!hw)
+		return -ENOMEM;
+
+	dev_set_drvdata(dev, (void *)hw);
+
+	mutex_init(&hw->fifo_lock);
+	mutex_init(&hw->lock);
+
+	hw->dev = dev;
+	hw->irq = irq;
+	hw->tf = tf_ops;
+	hw->watermark = 1;
+
+	err = st_lis2dw12_check_whoami(hw);
+	if (err < 0)
+		return err;
+
+	err = st_lis2dw12_init_hw(hw);
+	if (err < 0)
+		return err;
+
+	for (i = 0; i < ST_LIS2DW12_ID_MAX; i++) {
+		hw->iio_devs[i] = st_lis2dw12_alloc_iiodev(hw, i);
+		if (!hw->iio_devs[i])
+			return -ENOMEM;
+	}
+
+	if (hw->irq > 0) {
+		err = st_lis2dw12_fifo_setup(hw);
+		if (err)
+			return err;
+	}
+
+	for (i = 0; i < ST_LIS2DW12_ID_MAX; i++) {
+		err = devm_iio_device_register(hw->dev, hw->iio_devs[i]);
+		if (err)
+			return err;
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(st_lis2dw12_probe);
+
+MODULE_AUTHOR("MEMS Software Solutions Team");
+MODULE_DESCRIPTION("STMicroelectronics st_lis2dw12 driver");
+MODULE_LICENSE("GPL v2");
+
diff --git a/drivers/iio/stm/accel/st_lis2dw12_i2c.c b/drivers/iio/stm/accel/st_lis2dw12_i2c.c
new file mode 100644
index 000000000..43fd7ec41
--- /dev/null
+++ b/drivers/iio/stm/accel/st_lis2dw12_i2c.c
@@ -0,0 +1,103 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * STMicroelectronics lis2dw12 i2c driver
+ *
+ * MEMS Software Solutions Team
+ *
+ * Copyright 2016 STMicroelectronics Inc.
+ */
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/i2c.h>
+#include <linux/slab.h>
+#include <linux/of.h>
+
+#include "st_lis2dw12.h"
+
+static int st_lis2dw12_i2c_read(struct device *dev, u8 addr, int len, u8 *data)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct i2c_msg msg[2];
+
+	msg[0].addr = client->addr;
+	msg[0].flags = client->flags;
+	msg[0].len = 1;
+	msg[0].buf = &addr;
+
+	msg[1].addr = client->addr;
+	msg[1].flags = client->flags | I2C_M_RD;
+	msg[1].len = len;
+	msg[1].buf = data;
+
+	return i2c_transfer(client->adapter, msg, 2);
+}
+
+static int st_lis2dw12_i2c_write(struct device *dev, u8 addr, int len, u8 *data)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct i2c_msg msg;
+	u8 send[4];
+
+	if (len >= ARRAY_SIZE(send))
+		return -ENOMEM;
+
+	send[0] = addr;
+	memcpy(&send[1], data, len * sizeof(u8));
+
+	msg.addr = client->addr;
+	msg.flags = client->flags;
+	msg.len = len + 1;
+	msg.buf = send;
+
+	return i2c_transfer(client->adapter, &msg, 1);
+}
+
+static const struct st_lis2dw12_transfer_function st_lis2dw12_transfer_fn = {
+	.read = st_lis2dw12_i2c_read,
+	.write = st_lis2dw12_i2c_write,
+};
+
+static int st_lis2dw12_i2c_probe(struct i2c_client *client,
+				 const struct i2c_device_id *id)
+{
+	return st_lis2dw12_probe(&client->dev, client->irq,
+				 &st_lis2dw12_transfer_fn);
+}
+
+static const struct of_device_id st_lis2dw12_i2c_of_match[] = {
+	{
+		.compatible = "st,lis2dw12",
+		.data = ST_LIS2DW12_DEV_NAME,
+	},
+	{
+		.compatible = "st,iis2dlpc",
+		.data = ST_IIS2DLPC_DEV_NAME,
+	},
+	{
+		.compatible = "st,ais2ih",
+		.data = ST_AIS2IH_DEV_NAME,
+	},
+	{},
+};
+MODULE_DEVICE_TABLE(of, st_lis2dw12_i2c_of_match);
+
+static const struct i2c_device_id st_lis2dw12_i2c_id_table[] = {
+	{ ST_LIS2DW12_DEV_NAME },
+	{ ST_AIS2IH_DEV_NAME },
+	{},
+};
+MODULE_DEVICE_TABLE(i2c, st_lis2dw12_i2c_id_table);
+
+static struct i2c_driver st_lis2dw12_driver = {
+	.driver = {
+		.name = "st_lis2dw12_i2c",
+		.of_match_table = of_match_ptr(st_lis2dw12_i2c_of_match),
+	},
+	.probe = st_lis2dw12_i2c_probe,
+	.id_table = st_lis2dw12_i2c_id_table,
+};
+module_i2c_driver(st_lis2dw12_driver);
+
+MODULE_AUTHOR("MEMS Software Solutions Team");
+MODULE_DESCRIPTION("STMicroelectronics st_lis2dw12 i2c driver");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/iio/stm/accel/st_lis2dw12_spi.c b/drivers/iio/stm/accel/st_lis2dw12_spi.c
new file mode 100644
index 000000000..77c5d286c
--- /dev/null
+++ b/drivers/iio/stm/accel/st_lis2dw12_spi.c
@@ -0,0 +1,111 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * STMicroelectronics lis2dw12 spi driver
+ *
+ * MEMS Software Solutions Team
+ *
+ * Copyright 2016 STMicroelectronics Inc.
+ */
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/spi/spi.h>
+#include <linux/slab.h>
+#include <linux/of.h>
+
+#include "st_lis2dw12.h"
+
+#define SENSORS_SPI_READ	BIT(7)
+
+static int st_lis2dw12_spi_read(struct device *dev, u8 addr, int len, u8 *data)
+{
+	struct spi_device *spi = to_spi_device(dev);
+	struct st_lis2dw12_hw *hw = spi_get_drvdata(spi);
+	int err;
+
+	struct spi_transfer xfers[] = {
+		{
+			.tx_buf = hw->tb.tx_buf,
+			.bits_per_word = 8,
+			.len = 1,
+		},
+		{
+			.rx_buf = hw->tb.rx_buf,
+			.bits_per_word = 8,
+			.len = len,
+		}
+	};
+
+	hw->tb.tx_buf[0] = addr | SENSORS_SPI_READ;
+
+	err = spi_sync_transfer(spi, xfers,  ARRAY_SIZE(xfers));
+	if (err < 0)
+		return err;
+
+	memcpy(data, hw->tb.rx_buf, len * sizeof(u8));
+
+	return len;
+}
+
+static int st_lis2dw12_spi_write(struct device *dev, u8 addr, int len,
+				 u8 *data)
+{
+	struct spi_device *spi = to_spi_device(dev);
+	struct st_lis2dw12_hw *hw = spi_get_drvdata(spi);
+
+	if (len >= ST_LIS2DW12_TX_MAX_LENGTH)
+		return -ENOMEM;
+
+	hw->tb.tx_buf[0] = addr;
+	memcpy(&hw->tb.tx_buf[1], data, len);
+
+	return spi_write(spi, hw->tb.tx_buf, len + 1);
+}
+
+static const struct st_lis2dw12_transfer_function st_lis2dw12_transfer_fn = {
+	.read = st_lis2dw12_spi_read,
+	.write = st_lis2dw12_spi_write,
+};
+
+static int st_lis2dw12_spi_probe(struct spi_device *spi)
+{
+	return st_lis2dw12_probe(&spi->dev, spi->irq,
+				 &st_lis2dw12_transfer_fn);
+}
+
+static const struct of_device_id st_lis2dw12_spi_of_match[] = {
+	{
+		.compatible = "st,lis2dw12",
+		.data = ST_LIS2DW12_DEV_NAME,
+	},
+	{
+		.compatible = "st,iis2dlpc",
+		.data = ST_IIS2DLPC_DEV_NAME,
+	},
+	{
+		.compatible = "st,ais2ih",
+		.data = ST_AIS2IH_DEV_NAME,
+	},
+	{},
+};
+MODULE_DEVICE_TABLE(of, st_lis2dw12_spi_of_match);
+
+static const struct spi_device_id st_lis2dw12_spi_id_table[] = {
+	{ ST_LIS2DW12_DEV_NAME },
+	{ ST_AIS2IH_DEV_NAME },
+	{},
+};
+MODULE_DEVICE_TABLE(spi, st_lis2dw12_spi_id_table);
+
+static struct spi_driver st_lis2dw12_driver = {
+	.driver = {
+		.name = "st_lis2dw12_spi",
+		.of_match_table = of_match_ptr(st_lis2dw12_spi_of_match),
+	},
+	.probe = st_lis2dw12_spi_probe,
+	.id_table = st_lis2dw12_spi_id_table,
+};
+module_spi_driver(st_lis2dw12_driver);
+
+MODULE_AUTHOR("MEMS Software Solutions Team");
+MODULE_DESCRIPTION("STMicroelectronics st_lis2dw12 spi driver");
+MODULE_LICENSE("GPL v2");
-- 
2.25.1


From 7d0af2ed2fba3c537907e60ae3c33296d93535cf Mon Sep 17 00:00:00 2001
From: Mario Tesi <mario.tesi@st.com>
Date: Mon, 9 Oct 2023 17:39:59 +0200
Subject: drivers:iio:stm:magnetometer: Add support to STMEMS magnetometer
 st_mag40

Added support to STMEMS driver for lsm303ah, lsm303agr, lis2mdl,
ism303dac and iis2mdc compatible magnetometer sensors.

Signed-off-by: Mario Tesi <mario.tesi@st.com>
---
 .../iio/stm/magnetometer/st_mag40.txt         |  49 +++
 drivers/iio/stm/Kconfig                       |   1 +
 drivers/iio/stm/Makefile                      |   1 +
 drivers/iio/stm/magnetometer/Kconfig          |  33 ++
 drivers/iio/stm/magnetometer/Makefile         |  10 +
 .../iio/stm/magnetometer/st_mag40_buffer.c    | 185 ++++++++
 drivers/iio/stm/magnetometer/st_mag40_core.c  | 396 ++++++++++++++++++
 drivers/iio/stm/magnetometer/st_mag40_core.h  | 136 ++++++
 drivers/iio/stm/magnetometer/st_mag40_i2c.c   | 189 +++++++++
 drivers/iio/stm/magnetometer/st_mag40_spi.c   | 194 +++++++++
 10 files changed, 1194 insertions(+)
 create mode 100644 Documentation/devicetree/bindings/iio/stm/magnetometer/st_mag40.txt
 create mode 100644 drivers/iio/stm/magnetometer/Kconfig
 create mode 100644 drivers/iio/stm/magnetometer/Makefile
 create mode 100644 drivers/iio/stm/magnetometer/st_mag40_buffer.c
 create mode 100644 drivers/iio/stm/magnetometer/st_mag40_core.c
 create mode 100644 drivers/iio/stm/magnetometer/st_mag40_core.h
 create mode 100644 drivers/iio/stm/magnetometer/st_mag40_i2c.c
 create mode 100644 drivers/iio/stm/magnetometer/st_mag40_spi.c

diff --git a/Documentation/devicetree/bindings/iio/stm/magnetometer/st_mag40.txt b/Documentation/devicetree/bindings/iio/stm/magnetometer/st_mag40.txt
new file mode 100644
index 000000000..332430c8b
--- /dev/null
+++ b/Documentation/devicetree/bindings/iio/stm/magnetometer/st_mag40.txt
@@ -0,0 +1,49 @@
+* st_mag40 driver for magnetometer MEMS sensors
+
+Required properties for all bus drivers:
+- compatible: must be one of:
+              "st,lsm303ah_magn"
+              "st,lsm303agr_magn"
+              "st,lis2mdl_magn"
+              "st,ism303dac_magn"
+              "st,iis2mdc_magn"
+
+Required properties for the i2c bindings:
+- reg: i2c slave address
+
+Required properties for the spi bindings:
+- reg:               the chipselect index
+- spi-max-frequency: maximal bus speed, should be set to 1000000 unless
+                     constrained by external circuitry
+
+Optional properties for all bus drivers:
+- interrupts:   interrupt mapping for IRQ. It should be configured with
+                flags IRQ_TYPE_LEVEL_HIGH.
+
+                Refer to interrupt-controller/interrupts.txt for generic
+                interrupt client node bindings.
+
+- st,module_id: module identifier.
+                If a sensor is supported by two different drivers (for example
+                accel by this driver and magn by mag40 driver), module_id
+                should be used by both drivers and should have the same id.
+                This is used by user-space to identify which devices
+                are part of the same module (particularly important for
+                supporting multiple sensors of the same type).
+
+Example for an i2c device node:
+
+&i2c5 {
+    status = "okay";
+
+    iis2mdc_X_STM32MP_MSP01@1e {
+        compatible = "st,iis2mdc_magn";
+        reg = <0x1e>;
+
+        /* STM32MP1 - X-STM32MP-MSP0: IIS2MDC_INT_DRDY (PA8) */
+        interrupt-parent = <&gpioa>;
+        interrupts = <8 IRQ_TYPE_EDGE_RISING>;
+
+        status = "okay";
+    };
+}
diff --git a/drivers/iio/stm/Kconfig b/drivers/iio/stm/Kconfig
index 9afd0faef..17ca57867 100644
--- a/drivers/iio/stm/Kconfig
+++ b/drivers/iio/stm/Kconfig
@@ -11,6 +11,7 @@ if IIO_STM
 
 source "drivers/iio/stm/accel/Kconfig"
 source "drivers/iio/stm/imu/Kconfig"
+source "drivers/iio/stm/magnetometer/Kconfig"
 
 endif # IIO_STM
 
diff --git a/drivers/iio/stm/Makefile b/drivers/iio/stm/Makefile
index 18559f9c3..6f8535318 100644
--- a/drivers/iio/stm/Makefile
+++ b/drivers/iio/stm/Makefile
@@ -6,3 +6,4 @@
 
 obj-$(CONFIG_IIO_STM) += accel/
 obj-$(CONFIG_IIO_STM) += imu/
+obj-$(CONFIG_IIO_STM) += magnetometer/
diff --git a/drivers/iio/stm/magnetometer/Kconfig b/drivers/iio/stm/magnetometer/Kconfig
new file mode 100644
index 000000000..e2fa81f3e
--- /dev/null
+++ b/drivers/iio/stm/magnetometer/Kconfig
@@ -0,0 +1,33 @@
+# SPDX-License-Identifier: GPL-2.0-only
+#
+# Magnetometer sensors
+#
+# When adding new entries keep the list in alphabetical order
+
+menu "Magnetometer sensors"
+
+config ST_MAG40_IIO
+	tristate "STMicroelectronics LIS2MDL/LSM303AH/LSM303AGR/ISM303DAC/IIS2MDC sensor"
+	depends on (I2C || SPI) && SYSFS
+	select IIO_BUFFER
+	select IIO_TRIGGERED_BUFFER
+	select ST_MAG40_I2C_IIO if (I2C)
+	select ST_MAG40_SPI_IIO if (SPI)
+	help
+	  Say yes here to build support for STMicroelectronics magnetometers:
+	  LIS2MDL, LSM303AH, LSM303AGR, ISM303DAC, IIS2MDC.
+
+	  To compile this driver as a module, choose M here. The module
+	  will be called st_mag40.
+
+config ST_MAG40_I2C_IIO
+	tristate
+	depends on ST_MAG40_IIO
+	depends on I2C
+
+config ST_MAG40_SPI_IIO
+	tristate
+	depends on ST_MAG40_IIO
+	depends on SPI
+
+endmenu
diff --git a/drivers/iio/stm/magnetometer/Makefile b/drivers/iio/stm/magnetometer/Makefile
new file mode 100644
index 000000000..bc982f632
--- /dev/null
+++ b/drivers/iio/stm/magnetometer/Makefile
@@ -0,0 +1,10 @@
+# SPDX-License-Identifier: GPL-2.0
+#
+# Makefile for industrial I/O Magnetometer sensor drivers
+#
+
+# When adding new entries keep the list in alphabetical order
+st_mag40-y += st_mag40_buffer.o st_mag40_core.o
+obj-$(CONFIG_ST_MAG40_IIO) += st_mag40.o
+obj-$(CONFIG_ST_MAG40_I2C_IIO) += st_mag40_i2c.o
+obj-$(CONFIG_ST_MAG40_SPI_IIO) += st_mag40_spi.o
diff --git a/drivers/iio/stm/magnetometer/st_mag40_buffer.c b/drivers/iio/stm/magnetometer/st_mag40_buffer.c
new file mode 100644
index 000000000..7af009a71
--- /dev/null
+++ b/drivers/iio/stm/magnetometer/st_mag40_buffer.c
@@ -0,0 +1,185 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * STMicroelectronics st_mag40 driver
+ *
+ * MEMS Software Solutions Team
+ *
+ * Copyright 2016 STMicroelectronics Inc.
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/stat.h>
+#include <linux/interrupt.h>
+#include <linux/delay.h>
+#include <linux/iio/iio.h>
+#include <linux/iio/buffer.h>
+#include <linux/iio/trigger_consumer.h>
+#include <linux/iio/triggered_buffer.h>
+
+#include "st_mag40_core.h"
+
+#define ST_MAG40_EWMA_DIV			128
+static inline s64 st_mag40_ewma(s64 old, s64 new, int weight)
+{
+	s64 diff, incr;
+
+	diff = new - old;
+	incr = div_s64((ST_MAG40_EWMA_DIV - weight) * diff,
+			ST_MAG40_EWMA_DIV);
+
+	return old + incr;
+}
+
+static irqreturn_t st_mag40_trigger_irq_handler(int irq, void *private)
+{
+	struct st_mag40_data *cdata = private;
+	struct iio_dev *iio_dev = dev_get_drvdata(cdata->dev);
+	s64 ts;
+	u8 weight = (cdata->odr >= 50) ? 96 : 0;
+
+	ts = st_mag40_get_timestamp(iio_dev);
+	cdata->delta_ts = st_mag40_ewma(cdata->delta_ts, ts - cdata->ts_irq, weight);
+	cdata->ts_irq = ts;
+
+	return IRQ_WAKE_THREAD;
+}
+
+static irqreturn_t st_mag40_trigger_thread_handler(int irq, void *private)
+{
+	struct st_mag40_data *cdata = private;
+	u8 status;
+	int err;
+
+	err = cdata->tf->read(cdata, ST_MAG40_STATUS_ADDR,
+			      sizeof(status), &status);
+	if (err < 0)
+		return IRQ_HANDLED;
+
+	if (!(status & ST_MAG40_AVL_DATA_MASK))
+		return IRQ_NONE;
+
+	iio_trigger_poll_chained(cdata->iio_trig);
+
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t st_mag40_buffer_thread_handler(int irq, void *p)
+{
+	u8 buffer[ALIGN(ST_MAG40_OUT_LEN, sizeof(s64)) + sizeof(s64)];
+	struct iio_poll_func *pf = p;
+	struct iio_dev *iio_dev = pf->indio_dev;
+	struct st_mag40_data *cdata = iio_priv(iio_dev);
+	int err;
+
+	err = cdata->tf->read(cdata, ST_MAG40_OUTX_L_ADDR,
+			      ST_MAG40_OUT_LEN, buffer);
+	if (err < 0)
+		goto out;
+
+	/* discard samples generated during the turn-on time */
+	if (cdata->samples_to_discard > 0) {
+		cdata->samples_to_discard--;
+		goto out;
+	}
+
+	iio_push_to_buffers_with_timestamp(iio_dev, buffer, cdata->ts);
+	cdata->ts += cdata->delta_ts;
+
+out:
+	iio_trigger_notify_done(cdata->iio_trig);
+
+	return IRQ_HANDLED;
+}
+
+static int st_mag40_buffer_preenable(struct iio_dev *indio_dev)
+{
+	struct st_mag40_data *cdata = iio_priv(indio_dev);
+
+	return st_mag40_set_enable(cdata, true);
+}
+
+static int st_mag40_buffer_postdisable(struct iio_dev *indio_dev)
+{
+	struct st_mag40_data *cdata = iio_priv(indio_dev);
+	int err;
+
+	err = st_mag40_set_enable(cdata, false);
+
+	return err < 0 ? err : 0;
+}
+
+static const struct iio_buffer_setup_ops st_mag40_buffer_setup_ops = {
+	.preenable = st_mag40_buffer_preenable,
+	.postdisable = st_mag40_buffer_postdisable,
+};
+
+int st_mag40_trig_set_state(struct iio_trigger *trig, bool state)
+{
+	//struct st_mag40_data *cdata = iio_priv(iio_trigger_get_drvdata(trig));
+	int err = 0;
+
+	/*
+	 * This configuration should be applied immediately during the
+	 * st_mag40_init_sensors otherwise the drdy pin remains floating on
+	 * some boards (on STM32MP1 + IKS01A3 drdy is high)
+	 * err = st_mag40_write_register(cdata, ST_MAG40_INT_DRDY_ADDR,
+	 * 			         ST_MAG40_INT_DRDY_MASK, state);
+	 */
+	return err < 0 ? err : 0;
+}
+
+int st_mag40_allocate_ring(struct iio_dev *iio_dev)
+{
+	return  iio_triggered_buffer_setup(iio_dev, NULL,
+					   st_mag40_buffer_thread_handler,
+					   &st_mag40_buffer_setup_ops);
+}
+
+void st_mag40_deallocate_ring(struct iio_dev *iio_dev)
+{
+	iio_triggered_buffer_cleanup(iio_dev);
+}
+
+static const struct iio_trigger_ops st_mag40_trigger_ops = {
+	.set_trigger_state = st_mag40_trig_set_state,
+};
+
+int st_mag40_allocate_trigger(struct iio_dev *iio_dev)
+{
+	struct st_mag40_data *cdata = iio_priv(iio_dev);
+	int err;
+
+	err = devm_request_threaded_irq(cdata->dev, cdata->irq,
+					st_mag40_trigger_irq_handler,
+					st_mag40_trigger_thread_handler,
+					IRQF_TRIGGER_HIGH | IRQF_ONESHOT,
+					cdata->name, cdata);
+	if (err)
+		return err;
+
+	cdata->iio_trig = devm_iio_trigger_alloc(cdata->dev, "%s-trigger",
+						 iio_dev->name);
+	if (!cdata->iio_trig) {
+		dev_err(cdata->dev, "failed to allocate iio trigger.\n");
+		return -ENOMEM;
+	}
+	iio_trigger_set_drvdata(cdata->iio_trig, iio_dev);
+	cdata->iio_trig->ops = &st_mag40_trigger_ops;
+	cdata->iio_trig->dev.parent = cdata->dev;
+
+	err = iio_trigger_register(cdata->iio_trig);
+	if (err < 0) {
+		dev_err(cdata->dev, "failed to register iio trigger.\n");
+		return err;
+	}
+	iio_dev->trig = cdata->iio_trig;
+
+	return 0;
+}
+
+void st_mag40_deallocate_trigger(struct st_mag40_data *cdata)
+{
+	iio_trigger_unregister(cdata->iio_trig);
+}
diff --git a/drivers/iio/stm/magnetometer/st_mag40_core.c b/drivers/iio/stm/magnetometer/st_mag40_core.c
new file mode 100644
index 000000000..370ba91e3
--- /dev/null
+++ b/drivers/iio/stm/magnetometer/st_mag40_core.c
@@ -0,0 +1,396 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * STMicroelectronics st_mag40 driver
+ *
+ * MEMS Software Solutions Team
+ *
+ * Copyright 2016 STMicroelectronics Inc.
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/errno.h>
+#include <linux/types.h>
+#include <linux/mutex.h>
+#include <linux/interrupt.h>
+#include <linux/gpio.h>
+#include <linux/irq.h>
+#include <linux/iio/iio.h>
+#include <linux/iio/sysfs.h>
+#include <linux/iio/trigger.h>
+#include <linux/delay.h>
+#include <linux/iio/buffer.h>
+#include <linux/iio/events.h>
+#include <linux/of_device.h>
+#include <asm/unaligned.h>
+
+#include "st_mag40_core.h"
+
+struct st_mag40_odr_reg {
+	u32 hz;
+	u8 value;
+};
+
+#define ST_MAG40_ODR_TABLE_SIZE		4
+static const struct st_mag40_odr_table_t {
+	u8 addr;
+	u8 mask;
+	struct st_mag40_odr_reg odr_avl[ST_MAG40_ODR_TABLE_SIZE];
+} st_mag40_odr_table = {
+	.addr = ST_MAG40_ODR_ADDR,
+	.mask = ST_MAG40_ODR_MASK,
+	.odr_avl[0] = { .hz = 10, .value = ST_MAG40_CFG_REG_A_ODR_10Hz, },
+	.odr_avl[1] = { .hz = 20, .value = ST_MAG40_CFG_REG_A_ODR_20Hz, },
+	.odr_avl[2] = { .hz = 50, .value = ST_MAG40_CFG_REG_A_ODR_50Hz, },
+	.odr_avl[3] = { .hz = 100, .value = ST_MAG40_CFG_REG_A_ODR_100Hz, },
+};
+
+#define ST_MAG40_ADD_CHANNEL(device_type, modif, index, mod,	\
+			     endian, sbits, rbits, addr, s)	\
+{								\
+	.type = device_type,					\
+	.modified = modif,					\
+	.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) |		\
+			      BIT(IIO_CHAN_INFO_SCALE),		\
+	.scan_index = index,					\
+	.channel2 = mod,					\
+	.address = addr,					\
+	.scan_type = {						\
+		.sign = s,					\
+		.realbits = rbits,				\
+		.shift = sbits - rbits,				\
+		.storagebits = sbits,				\
+		.endianness = endian,				\
+	},							\
+}
+
+static const struct iio_chan_spec st_mag40_channels[] = {
+	ST_MAG40_ADD_CHANNEL(IIO_MAGN, 1, 0, IIO_MOD_X, IIO_LE, 16, 16,
+				ST_MAG40_OUTX_L_ADDR, 's'),
+	ST_MAG40_ADD_CHANNEL(IIO_MAGN, 1, 1, IIO_MOD_Y, IIO_LE, 16, 16,
+				ST_MAG40_OUTY_L_ADDR, 's'),
+	ST_MAG40_ADD_CHANNEL(IIO_MAGN, 1, 2, IIO_MOD_Z, IIO_LE, 16, 16,
+				ST_MAG40_OUTZ_L_ADDR, 's'),
+	IIO_CHAN_SOFT_TIMESTAMP(3),
+};
+
+int st_mag40_write_register(struct st_mag40_data *cdata, u8 reg_addr,
+			    u8 mask, u8 data)
+{
+	int err;
+	u8 val;
+
+	mutex_lock(&cdata->lock);
+
+	err = cdata->tf->read(cdata, reg_addr, sizeof(val), &val);
+	if (err < 0)
+		goto unlock;
+
+	val = ((val & ~mask) | ((data << __ffs(mask)) & mask));
+
+	err = cdata->tf->write(cdata, reg_addr, sizeof(val), &val);
+
+unlock:
+	mutex_unlock(&cdata->lock);
+
+	return err < 0 ? err : 0;
+}
+
+static int st_mag40_write_odr(struct st_mag40_data *cdata, uint32_t odr)
+{
+	int err, i;
+
+	for (i = 0; i < ST_MAG40_ODR_TABLE_SIZE; i++)
+		if (st_mag40_odr_table.odr_avl[i].hz >= odr)
+			break;
+
+	if (i == ST_MAG40_ODR_TABLE_SIZE)
+		return -EINVAL;
+
+	err = st_mag40_write_register(cdata, st_mag40_odr_table.addr,
+				      st_mag40_odr_table.mask,
+				      st_mag40_odr_table.odr_avl[i].value);
+	if (err < 0)
+		return err;
+
+	cdata->odr = odr;
+	cdata->samples_to_discard = ST_MAG40_TURNON_TIME_SAMPLES_NUM;
+
+	return 0;
+}
+
+int st_mag40_set_enable(struct st_mag40_data *cdata, bool state)
+{
+	struct iio_dev *iio_dev = dev_get_drvdata(cdata->dev);
+	u8 mode;
+
+	mode = state ? ST_MAG40_CFG_REG_A_MD_CONT : ST_MAG40_CFG_REG_A_MD_IDLE;
+
+	if (state) {
+		cdata->ts = cdata->ts_irq = st_mag40_get_timestamp(iio_dev);
+		cdata->delta_ts = div_s64(1000000000LL, cdata->odr);
+	}
+
+	return st_mag40_write_register(cdata, ST_MAG40_EN_ADDR,
+				       ST_MAG40_EN_MASK, mode);
+}
+
+int st_mag40_init_sensors(struct st_mag40_data *cdata)
+{
+	int err;
+
+	/*
+	 * Enable block data update feature.
+	 */
+	err = st_mag40_write_register(cdata, ST_MAG40_CFG_REG_C_ADDR,
+				      ST_MAG40_CFG_REG_C_BDU_MASK, 1);
+	if (err < 0)
+		return err;
+
+	/*
+	 * Enable the temperature compensation feature
+	 */
+	err = st_mag40_write_register(cdata, ST_MAG40_CFG_REG_A_ADDR,
+				      ST_MAG40_TEMP_COMP_EN, 1);
+	if (err < 0)
+		return err;
+
+	/* the drdy pin remains floating on some boards */
+	err = st_mag40_write_register(cdata, ST_MAG40_INT_DRDY_ADDR,
+				      ST_MAG40_INT_DRDY_MASK, 1);
+	if (err < 0)
+		return err;
+
+	err = st_mag40_write_register(cdata, ST_MAG40_CFG_REG_B_ADDR,
+				      ST_MAG40_CFG_REG_B_OFF_CANC_MASK, 1);
+
+	return err < 0 ? err : 0;
+}
+
+static ssize_t st_mag40_get_sampling_frequency(struct device *dev,
+					       struct device_attribute *attr,
+					       char *buf)
+{
+	struct st_mag40_data *cdata = iio_priv(dev_get_drvdata(dev));
+
+	return sprintf(buf, "%d\n", cdata->odr);
+}
+
+static ssize_t st_mag40_set_sampling_frequency(struct device *dev,
+					       struct device_attribute *attr,
+					       const char *buf, size_t count)
+{
+	struct iio_dev *iio_dev = dev_get_drvdata(dev);
+	struct st_mag40_data *cdata = iio_priv(iio_dev);
+	unsigned int odr;
+	int err;
+
+	err = kstrtoint(buf, 10, &odr);
+	if (err < 0)
+		return err;
+
+	err = st_mag40_write_odr(cdata, odr);
+
+	return err < 0 ? err : count;
+}
+
+static ssize_t
+st_mag40_get_sampling_frequency_avail(struct device *dev,
+				      struct device_attribute *attr,
+				      char *buf)
+{
+	int i, len = 0;
+
+	for (i = 0; i < ST_MAG40_ODR_TABLE_SIZE; i++)
+		len += scnprintf(buf + len, PAGE_SIZE - len, "%d ",
+				 st_mag40_odr_table.odr_avl[i].hz);
+	buf[len - 1] = '\n';
+
+	return len;
+}
+
+static int st_mag40_read_oneshot(struct st_mag40_data *cdata,
+				 u8 addr, int *val)
+{
+	u8 data[2];
+	int err;
+
+	err = st_mag40_set_enable(cdata, true);
+	if (err < 0)
+		return err;
+
+	msleep(40);
+
+	err = cdata->tf->read(cdata, addr, sizeof(data), data);
+	if (err < 0)
+		return err;
+
+	*val = (s16)get_unaligned_le16(data);
+
+	err = st_mag40_set_enable(cdata, false);
+
+	return err < 0 ? err : IIO_VAL_INT;
+}
+
+static int st_mag40_read_raw(struct iio_dev *iio_dev,
+			     struct iio_chan_spec const *ch,
+			     int *val, int *val2, long mask)
+{
+	struct st_mag40_data *cdata = iio_priv(iio_dev);
+	int ret;
+
+	mutex_lock(&iio_dev->mlock);
+
+	if (iio_buffer_enabled(iio_dev)) {
+		mutex_unlock(&iio_dev->mlock);
+		return -EBUSY;
+	}
+
+	switch (mask) {
+	case IIO_CHAN_INFO_RAW:
+		ret = st_mag40_read_oneshot(cdata, ch->address, val);
+		break;
+	case IIO_CHAN_INFO_SCALE:
+		*val = 0;
+		*val2 = 1500;
+		ret = IIO_VAL_INT_PLUS_MICRO;
+		break;
+	default:
+		ret = -EINVAL;
+		break;
+	}
+
+	mutex_unlock(&iio_dev->mlock);
+
+	return ret;
+}
+
+static ssize_t st_mag40_get_module_id(struct device *dev,
+				      struct device_attribute *attr,
+				      char *buf)
+{
+	struct iio_dev *iio_dev = dev_get_drvdata(dev);
+	struct st_mag40_data *cdata = iio_priv(iio_dev);
+
+	return scnprintf(buf, PAGE_SIZE, "%u\n", cdata->module_id);
+}
+
+static IIO_DEV_ATTR_SAMP_FREQ(0644,
+			      st_mag40_get_sampling_frequency,
+			      st_mag40_set_sampling_frequency);
+static IIO_DEV_ATTR_SAMP_FREQ_AVAIL(st_mag40_get_sampling_frequency_avail);
+static IIO_DEVICE_ATTR(module_id, 0444, st_mag40_get_module_id, NULL, 0);
+
+static struct attribute *st_mag40_attributes[] = {
+	&iio_dev_attr_sampling_frequency_available.dev_attr.attr,
+	&iio_dev_attr_sampling_frequency.dev_attr.attr,
+	&iio_dev_attr_module_id.dev_attr.attr,
+	NULL,
+};
+
+static const struct attribute_group st_mag40_attribute_group = {
+	.attrs = st_mag40_attributes,
+};
+
+static const struct iio_info st_mag40_info = {
+	.attrs = &st_mag40_attribute_group,
+	.read_raw = &st_mag40_read_raw,
+};
+
+static void st_mag40_get_properties(struct st_mag40_data *cdata)
+{
+	if (device_property_read_u32(cdata->dev, "st,module_id",
+				     &cdata->module_id)) {
+		cdata->module_id = 1;
+	}
+}
+
+int st_mag40_common_probe(struct iio_dev *iio_dev)
+{
+	struct st_mag40_data *cdata = iio_priv(iio_dev);
+	int32_t err;
+	u8 wai;
+
+	mutex_init(&cdata->lock);
+
+	err = cdata->tf->read(cdata, ST_MAG40_WHO_AM_I_ADDR,
+			      sizeof(wai), &wai);
+	if (err < 0) {
+		dev_err(cdata->dev, "failed to read Who-Am-I register.\n");
+
+		return err;
+	}
+
+	if (wai != ST_MAG40_WHO_AM_I_DEF) {
+		dev_err(cdata->dev, "Who-Am-I value not valid. (%02x)\n", wai);
+		return -ENODEV;
+	}
+
+	cdata->odr = st_mag40_odr_table.odr_avl[0].hz;
+
+	iio_dev->channels = st_mag40_channels;
+	iio_dev->num_channels = ARRAY_SIZE(st_mag40_channels);
+	iio_dev->info = &st_mag40_info;
+	iio_dev->modes = INDIO_DIRECT_MODE;
+
+	st_mag40_get_properties(cdata);
+
+	err = st_mag40_init_sensors(cdata);
+	if (err < 0)
+		return err;
+
+	if (cdata->irq > 0) {
+		err = st_mag40_allocate_ring(iio_dev);
+		if (err < 0)
+			return err;
+
+		err = st_mag40_allocate_trigger(iio_dev);
+		if (err < 0)
+			goto deallocate_ring;
+	}
+
+	err = devm_iio_device_register(cdata->dev, iio_dev);
+	if (err)
+		goto iio_trigger_deallocate;
+
+	return 0;
+
+iio_trigger_deallocate:
+	st_mag40_deallocate_trigger(cdata);
+
+deallocate_ring:
+	st_mag40_deallocate_ring(iio_dev);
+
+	return err;
+}
+EXPORT_SYMBOL(st_mag40_common_probe);
+
+void st_mag40_common_remove(struct iio_dev *iio_dev)
+{
+	struct st_mag40_data *cdata = iio_priv(iio_dev);
+
+	if (cdata->irq > 0) {
+		st_mag40_deallocate_trigger(cdata);
+		st_mag40_deallocate_ring(iio_dev);
+	}
+}
+EXPORT_SYMBOL(st_mag40_common_remove);
+
+#ifdef CONFIG_PM
+int st_mag40_common_suspend(struct st_mag40_data *cdata)
+{
+	return 0;
+}
+EXPORT_SYMBOL(st_mag40_common_suspend);
+
+int st_mag40_common_resume(struct st_mag40_data *cdata)
+{
+	return 0;
+}
+EXPORT_SYMBOL(st_mag40_common_resume);
+#endif /* CONFIG_PM */
+
+MODULE_DESCRIPTION("STMicroelectronics st_mag40 driver");
+MODULE_AUTHOR("MEMS Software Solutions Team");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/iio/stm/magnetometer/st_mag40_core.h b/drivers/iio/stm/magnetometer/st_mag40_core.h
new file mode 100644
index 000000000..a06f83529
--- /dev/null
+++ b/drivers/iio/stm/magnetometer/st_mag40_core.h
@@ -0,0 +1,136 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * STMicroelectronics st_mag40 driver
+ *
+ * MEMS Software Solutions Team
+ *
+ * Copyright 2016 STMicroelectronics Inc.
+ */
+
+#ifndef __ST_MAG40_H
+#define __ST_MAG40_H
+
+#include <linux/types.h>
+#include <linux/iio/iio.h>
+#include <linux/iio/trigger.h>
+#include <linux/version.h>
+
+#define ST_MAG40_DEV_NAME			"st_mag40"
+#define LIS2MDL_DEV_NAME			"lis2mdl_magn"
+#define LSM303AH_DEV_NAME			"lsm303ah_magn"
+#define LSM303AGR_DEV_NAME			"lsm303agr_magn"
+#define ISM303DAC_DEV_NAME			"ism303dac_magn"
+#define IIS2MDC_DEV_NAME			"iis2mdc_magn"
+
+/* Power Modes */
+enum {
+	ST_MAG40_LWC_MODE = 0,
+	ST_MAG40_NORMAL_MODE,
+	ST_MAG40_MODE_COUNT,
+};
+
+#define ST_MAG40_WHO_AM_I_ADDR				0x4f
+#define ST_MAG40_WHO_AM_I_DEF				0x40
+
+/* Magnetometer control registers */
+#define ST_MAG40_CFG_REG_A_ADDR				0x60
+#define ST_MAG40_TEMP_COMP_EN				0x80
+#define ST_MAG40_CFG_REG_A_ODR_MASK			0x0c
+#define ST_MAG40_CFG_REG_A_ODR_10Hz			0x00
+#define ST_MAG40_CFG_REG_A_ODR_20Hz			0x01
+#define ST_MAG40_CFG_REG_A_ODR_50Hz			0x02
+#define ST_MAG40_CFG_REG_A_ODR_100Hz			0x03
+#define ST_MAG40_CFG_REG_A_ODR_COUNT			4
+#define ST_MAG40_CFG_REG_A_MD_MASK			0x03
+#define ST_MAG40_CFG_REG_A_MD_CONT			0x00
+#define ST_MAG40_CFG_REG_A_MD_IDLE			0x03
+
+#define ST_MAG40_ODR_ADDR				ST_MAG40_CFG_REG_A_ADDR
+#define ST_MAG40_ODR_MASK				ST_MAG40_CFG_REG_A_ODR_MASK
+
+#define ST_MAG40_EN_ADDR				ST_MAG40_CFG_REG_A_ADDR
+#define ST_MAG40_EN_MASK				ST_MAG40_CFG_REG_A_MD_MASK
+
+#define ST_MAG40_CFG_REG_B_ADDR				0x61
+#define ST_MAG40_CFG_REG_B_OFF_CANC_MASK		0x02
+
+#define ST_MAG40_CFG_REG_C_ADDR				0x62
+#define ST_MAG40_CFG_REG_C_BDU_MASK			0x10
+#define ST_MAG40_CFG_REG_C_INT_MASK			0x01
+
+#define ST_MAG40_INT_DRDY_ADDR				ST_MAG40_CFG_REG_C_ADDR
+#define ST_MAG40_INT_DRDY_MASK				ST_MAG40_CFG_REG_C_INT_MASK
+
+#define ST_MAG40_STATUS_ADDR				0x67
+#define ST_MAG40_AVL_DATA_MASK				0x7
+
+/* Magnetometer output registers */
+#define ST_MAG40_OUTX_L_ADDR				0x68
+#define ST_MAG40_OUTY_L_ADDR				0x6A
+#define ST_MAG40_OUTZ_L_ADDR				0x6C
+
+#define ST_MAG40_BDU_ADDR				ST_MAG40_CTRL1_ADDR
+#define ST_MAG40_BDU_MASK				0x02
+
+#define ST_MAG40_TURNON_TIME_SAMPLES_NUM	2
+
+/* 3 axis of 16 bit each */
+#define ST_MAG40_OUT_LEN				6
+
+#define ST_MAG40_TX_MAX_LENGTH				16
+#define ST_MAG40_RX_MAX_LENGTH				16
+
+struct st_mag40_transfer_buffer {
+	u8 rx_buf[ST_MAG40_RX_MAX_LENGTH];
+	u8 tx_buf[ST_MAG40_TX_MAX_LENGTH] ____cacheline_aligned;
+};
+
+struct st_mag40_data;
+
+struct st_mag40_transfer_function {
+	int (*write)(struct st_mag40_data *cdata, u8 reg_addr, int len, u8 *data);
+	int (*read)(struct st_mag40_data *cdata, u8 reg_addr, int len, u8 *data);
+};
+
+struct st_mag40_data {
+	const char *name;
+	struct mutex lock;
+	u8 drdy_int_pin;
+	int irq;
+	s64 ts;
+	s64 ts_irq;
+	s64 delta_ts;
+
+	u32 module_id;
+
+	u16 odr;
+	u8 samples_to_discard;
+
+	struct device *dev;
+	struct iio_trigger *iio_trig;
+	const struct st_mag40_transfer_function *tf;
+	struct st_mag40_transfer_buffer tb;
+};
+
+static inline s64 st_mag40_get_timestamp(struct iio_dev *iio_dev)
+{
+	return iio_get_time_ns(iio_dev);
+}
+
+int st_mag40_common_probe(struct iio_dev *iio_dev);
+void st_mag40_common_remove(struct iio_dev *iio_dev);
+
+#ifdef CONFIG_PM
+int st_mag40_common_suspend(struct st_mag40_data *cdata);
+int st_mag40_common_resume(struct st_mag40_data *cdata);
+#endif /* CONFIG_PM */
+
+int st_mag40_allocate_ring(struct iio_dev *iio_dev);
+int st_mag40_allocate_trigger(struct iio_dev *iio_dev);
+int st_mag40_trig_set_state(struct iio_trigger *trig, bool state);
+int st_mag40_set_enable(struct st_mag40_data *cdata, bool enable);
+void st_mag40_deallocate_ring(struct iio_dev *iio_dev);
+void st_mag40_deallocate_trigger(struct st_mag40_data *cdata);
+int st_mag40_write_register(struct st_mag40_data *cdata, u8 reg_addr, u8 mask, u8 data);
+
+#endif /* __ST_MAG40_H */
diff --git a/drivers/iio/stm/magnetometer/st_mag40_i2c.c b/drivers/iio/stm/magnetometer/st_mag40_i2c.c
new file mode 100644
index 000000000..9763173f0
--- /dev/null
+++ b/drivers/iio/stm/magnetometer/st_mag40_i2c.c
@@ -0,0 +1,189 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * STMicroelectronics st_mag40 driver
+ *
+ * MEMS Software Solutions Team
+ *
+ * Copyright 2016 STMicroelectronics Inc.
+ */
+
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/i2c.h>
+#include <linux/types.h>
+
+#include "st_mag40_core.h"
+
+#define I2C_AUTO_INCREMENT	0x80
+
+static int st_mag40_i2c_read(struct st_mag40_data *cdata, u8 reg_addr,
+			     int len, u8 *data)
+{
+	struct i2c_client *client = to_i2c_client(cdata->dev);
+	struct i2c_msg msg[2];
+
+	if (len > 1)
+		reg_addr |= I2C_AUTO_INCREMENT;
+
+	msg[0].addr = client->addr;
+	msg[0].flags = client->flags;
+	msg[0].len = 1;
+	msg[0].buf = &reg_addr;
+
+	msg[1].addr = client->addr;
+	msg[1].flags = client->flags | I2C_M_RD;
+	msg[1].len = len;
+	msg[1].buf = data;
+
+	return i2c_transfer(client->adapter, msg, 2);
+}
+
+static int st_mag40_i2c_write(struct st_mag40_data *cdata, u8 reg_addr,
+			      int len, u8 *data)
+{
+	struct i2c_client *client = to_i2c_client(cdata->dev);
+	struct i2c_msg msg;
+	u8 send[4];
+
+	if (len >= ARRAY_SIZE(send))
+		return -ENOMEM;
+
+	send[0] = reg_addr;
+	memcpy(&send[1], data, len * sizeof(u8));
+	len++;
+
+	msg.addr = client->addr;
+	msg.flags = client->flags;
+	msg.len = len;
+	msg.buf = send;
+
+	return i2c_transfer(client->adapter, &msg, 1);
+}
+
+static const struct st_mag40_transfer_function st_mag40_tf_i2c = {
+	.write = st_mag40_i2c_write,
+	.read = st_mag40_i2c_read,
+};
+
+static int st_mag40_i2c_probe(struct i2c_client *client,
+			      const struct i2c_device_id *id)
+{
+	struct st_mag40_data *cdata;
+	struct iio_dev *iio_dev;
+
+	iio_dev = devm_iio_device_alloc(&client->dev, sizeof(*cdata));
+	if (!iio_dev)
+		return -ENOMEM;
+
+	i2c_set_clientdata(client, iio_dev);
+	iio_dev->dev.parent = &client->dev;
+	iio_dev->name = client->name;
+
+	cdata = iio_priv(iio_dev);
+	cdata->dev = &client->dev;
+	cdata->name = client->name;
+	cdata->tf = &st_mag40_tf_i2c;
+	cdata->irq = client->irq;
+
+	return st_mag40_common_probe(iio_dev);
+}
+
+#if KERNEL_VERSION(6, 1, 0) <= LINUX_VERSION_CODE
+static void st_mag40_i2c_remove(struct i2c_client *client)
+{
+	struct iio_dev *iio_dev = i2c_get_clientdata(client);
+
+	st_mag40_common_remove(iio_dev);
+}
+#else /* LINUX_VERSION_CODE */
+static int st_mag40_i2c_remove(struct i2c_client *client)
+{
+	struct iio_dev *iio_dev = i2c_get_clientdata(client);
+
+	st_mag40_common_remove(iio_dev);
+
+	return 0;
+}
+#endif /* LINUX_VERSION_CODE */
+
+#ifdef CONFIG_PM
+static int __maybe_unused st_mag40_i2c_suspend(struct device *dev)
+{
+	struct iio_dev *iio_dev = dev_get_drvdata(dev);
+	struct st_mag40_data *cdata = iio_priv(iio_dev);
+
+	return st_mag40_common_suspend(cdata);
+}
+
+static int __maybe_unused st_mag40_i2c_resume(struct device *dev)
+{
+	struct iio_dev *iio_dev = dev_get_drvdata(dev);
+	struct st_mag40_data *cdata = iio_priv(iio_dev);
+
+	return st_mag40_common_resume(cdata);
+}
+
+static const struct dev_pm_ops st_mag40_i2c_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(st_mag40_i2c_suspend, st_mag40_i2c_resume)
+};
+#define ST_MAG40_PM_OPS		(&st_mag40_i2c_pm_ops)
+#else /* CONFIG_PM */
+#define ST_MAG40_PM_OPS		NULL
+#endif /* CONFIG_PM */
+
+static const struct i2c_device_id st_mag40_ids[] = {
+	{ LSM303AH_DEV_NAME, 0 },
+	{ LSM303AGR_DEV_NAME, 0 },
+	{ LIS2MDL_DEV_NAME, 0 },
+	{ ISM303DAC_DEV_NAME, 0 },
+	{ IIS2MDC_DEV_NAME, 0 },
+	{}
+};
+MODULE_DEVICE_TABLE(i2c, st_mag40_ids);
+
+#ifdef CONFIG_OF
+static const struct of_device_id st_mag40_id_table[] = {
+	{
+		.compatible = "st,lsm303ah_magn",
+		.data = LSM303AH_DEV_NAME,
+	},
+	{
+		.compatible = "st,lsm303agr_magn",
+		.data = LSM303AGR_DEV_NAME,
+	},
+	{
+		.compatible = "st,lis2mdl_magn",
+		.data = LSM303AGR_DEV_NAME,
+	},
+	{
+		.compatible = "st,ism303dac_magn",
+		.data = ISM303DAC_DEV_NAME,
+	},
+	{
+		.compatible = "st,iis2mdc_magn",
+		.data = IIS2MDC_DEV_NAME,
+	},
+	{},
+};
+
+MODULE_DEVICE_TABLE(of, st_mag40_id_table);
+#endif /* CONFIG_OF */
+
+static struct i2c_driver st_mag40_i2c_driver = {
+	.driver = {
+		   .owner = THIS_MODULE,
+		   .name = ST_MAG40_DEV_NAME,
+		   .pm = ST_MAG40_PM_OPS,
+#ifdef CONFIG_OF
+		   .of_match_table = st_mag40_id_table,
+#endif /* CONFIG_OF */
+		   },
+	.probe = st_mag40_i2c_probe,
+	.remove = st_mag40_i2c_remove,
+	.id_table = st_mag40_ids,
+};
+module_i2c_driver(st_mag40_i2c_driver);
+
+MODULE_DESCRIPTION("STMicroelectronics st_mag40 i2c driver");
+MODULE_AUTHOR("MEMS Software Solutions Team");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/iio/stm/magnetometer/st_mag40_spi.c b/drivers/iio/stm/magnetometer/st_mag40_spi.c
new file mode 100644
index 000000000..84f60476c
--- /dev/null
+++ b/drivers/iio/stm/magnetometer/st_mag40_spi.c
@@ -0,0 +1,194 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * STMicroelectronics st_mag40 driver
+ *
+ * MEMS Software Solutions Team
+ *
+ * Copyright 2016 STMicroelectronics Inc.
+ */
+
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/spi/spi.h>
+#include <linux/types.h>
+
+#include "st_mag40_core.h"
+
+#define ST_SENSORS_SPI_READ	0x80
+
+static int st_mag40_spi_read(struct st_mag40_data *cdata,
+			     u8 reg_addr, int len, u8 *data)
+{
+	int err;
+
+	struct spi_transfer xfers[] = {
+		{
+			.tx_buf = cdata->tb.tx_buf,
+			.bits_per_word = 8,
+			.len = 1,
+		},
+		{
+			.rx_buf = cdata->tb.rx_buf,
+			.bits_per_word = 8,
+			.len = len,
+		}
+	};
+
+	cdata->tb.tx_buf[0] = reg_addr | ST_SENSORS_SPI_READ;
+
+	err = spi_sync_transfer(to_spi_device(cdata->dev),
+						xfers, ARRAY_SIZE(xfers));
+	if (err)
+		return err;
+
+	memcpy(data, cdata->tb.rx_buf, len*sizeof(u8));
+
+	return len;
+}
+
+static int st_mag40_spi_write(struct st_mag40_data *cdata,
+			      u8 reg_addr, int len, u8 *data)
+{
+	struct spi_transfer xfers = {
+		.tx_buf = cdata->tb.tx_buf,
+		.bits_per_word = 8,
+		.len = len + 1,
+	};
+
+	if (len >= ST_MAG40_RX_MAX_LENGTH)
+		return -ENOMEM;
+
+	cdata->tb.tx_buf[0] = reg_addr;
+
+	memcpy(&cdata->tb.tx_buf[1], data, len);
+
+	return spi_sync_transfer(to_spi_device(cdata->dev), &xfers, 1);
+}
+
+static const struct st_mag40_transfer_function st_mag40_tf_spi = {
+	.write = st_mag40_spi_write,
+	.read = st_mag40_spi_read,
+};
+
+static int st_mag40_spi_probe(struct spi_device *spi)
+{
+	struct st_mag40_data *cdata;
+	struct iio_dev *iio_dev;
+
+	iio_dev = devm_iio_device_alloc(&spi->dev, sizeof(*cdata));
+	if (!iio_dev)
+		return -ENOMEM;
+
+	spi_set_drvdata(spi, iio_dev);
+	iio_dev->dev.parent = &spi->dev;
+	iio_dev->name = spi->modalias;
+
+	cdata = iio_priv(iio_dev);
+	cdata->dev = &spi->dev;
+	cdata->name = spi->modalias;
+	cdata->tf = &st_mag40_tf_spi;
+	cdata->irq = spi->irq;
+
+	return st_mag40_common_probe(iio_dev);
+}
+
+#if KERNEL_VERSION(5, 18, 0) <= LINUX_VERSION_CODE
+static void st_mag40_spi_remove(struct spi_device *spi)
+{
+	struct iio_dev *iio_dev = spi_get_drvdata(spi);
+
+	st_mag40_common_remove(iio_dev);
+}
+#else /* LINUX_VERSION_CODE */
+static int st_mag40_spi_remove(struct spi_device *spi)
+{
+	struct iio_dev *iio_dev = spi_get_drvdata(spi);
+
+	st_mag40_common_remove(iio_dev);
+
+	return 0;
+}
+#endif /* LINUX_VERSION_CODE */
+
+#ifdef CONFIG_PM
+static int __maybe_unused st_mag40_spi_suspend(struct device *dev)
+{
+	struct iio_dev *iio_dev = dev_get_drvdata(dev);
+	struct st_mag40_data *cdata = iio_priv(iio_dev);
+
+	return st_mag40_common_suspend(cdata);
+}
+
+static int __maybe_unused st_mag40_spi_resume(struct device *dev)
+{
+	struct iio_dev *iio_dev = dev_get_drvdata(dev);
+	struct st_mag40_data *cdata = iio_priv(iio_dev);
+
+	return st_mag40_common_resume(cdata);
+}
+
+static const struct dev_pm_ops st_mag40_spi_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(st_mag40_spi_suspend, st_mag40_spi_resume)
+};
+#define ST_MAG40_PM_OPS		(&st_mag40_spi_pm_ops)
+#else /* CONFIG_PM */
+#define ST_MAG40_PM_OPS		NULL
+#endif /* CONFIG_PM */
+
+static const struct spi_device_id st_mag40_ids[] = {
+	{ LSM303AH_DEV_NAME, 0 },
+	{ LSM303AGR_DEV_NAME, 0 },
+	{ LIS2MDL_DEV_NAME, 0 },
+	{ ISM303DAC_DEV_NAME, 0 },
+	{ IIS2MDC_DEV_NAME, 0 },
+	{}
+};
+
+MODULE_DEVICE_TABLE(spi, st_mag40_ids);
+
+#ifdef CONFIG_OF
+static const struct of_device_id st_mag40_id_table[] = {
+	{
+		.compatible = "st,lsm303ah_magn",
+		.data = LSM303AH_DEV_NAME,
+	},
+	{
+		.compatible = "st,lsm303agr_magn",
+		.data = LSM303AGR_DEV_NAME,
+	},
+	{
+		.compatible = "st,lis2mdl_magn",
+		.data = LSM303AGR_DEV_NAME,
+	},
+	{
+		.compatible = "st,ism303dac_magn",
+		.data = ISM303DAC_DEV_NAME,
+	},
+	{
+		.compatible = "st,iis2mdc_magn",
+		.data = IIS2MDC_DEV_NAME,
+	},
+	{},
+};
+
+MODULE_DEVICE_TABLE(of, st_mag40_id_table);
+#endif /* CONFIG_OF */
+
+static struct spi_driver st_mag40_spi_driver = {
+	.driver = {
+		   .owner = THIS_MODULE,
+		   .name = ST_MAG40_DEV_NAME,
+		   .pm = ST_MAG40_PM_OPS,
+#ifdef CONFIG_OF
+		   .of_match_table = st_mag40_id_table,
+#endif /* CONFIG_OF */
+		   },
+	.probe = st_mag40_spi_probe,
+	.remove = st_mag40_spi_remove,
+	.id_table = st_mag40_ids,
+};
+module_spi_driver(st_mag40_spi_driver);
+
+MODULE_DESCRIPTION("STMicroelectronics st_mag40 spi driver");
+MODULE_AUTHOR("MEMS Software Solutions Team");
+MODULE_LICENSE("GPL v2");
-- 
2.25.1


From c107e7f07b801a6a6332b5164b92b62f40c7b083 Mon Sep 17 00:00:00 2001
From: Mario Tesi <mario.tesi@st.com>
Date: Mon, 9 Oct 2023 18:01:12 +0200
Subject: drivers:iio:stm:pressure:st_lps22hh: Add support to STMEMS pressure
 lps22hh

Added support to STMEMS driver for lps22ch, lps22hh and lps27hhw
compatible pressure sensors.

Signed-off-by: Mario Tesi <mario.tesi@st.com>
---
 .../bindings/iio/stm/pressure/st_lps22hh.txt  |  41 ++
 drivers/iio/stm/Kconfig                       |   1 +
 drivers/iio/stm/Makefile                      |   1 +
 drivers/iio/stm/pressure/Kconfig              |  28 +
 drivers/iio/stm/pressure/Makefile             |  11 +
 drivers/iio/stm/pressure/st_lps22hh.h         | 112 ++++
 drivers/iio/stm/pressure/st_lps22hh_buffer.c  | 314 +++++++++++
 drivers/iio/stm/pressure/st_lps22hh_core.c    | 492 ++++++++++++++++++
 drivers/iio/stm/pressure/st_lps22hh_i2c.c     |  94 ++++
 drivers/iio/stm/pressure/st_lps22hh_spi.c     | 101 ++++
 10 files changed, 1195 insertions(+)
 create mode 100644 Documentation/devicetree/bindings/iio/stm/pressure/st_lps22hh.txt
 create mode 100644 drivers/iio/stm/pressure/Kconfig
 create mode 100644 drivers/iio/stm/pressure/Makefile
 create mode 100644 drivers/iio/stm/pressure/st_lps22hh.h
 create mode 100644 drivers/iio/stm/pressure/st_lps22hh_buffer.c
 create mode 100644 drivers/iio/stm/pressure/st_lps22hh_core.c
 create mode 100644 drivers/iio/stm/pressure/st_lps22hh_i2c.c
 create mode 100644 drivers/iio/stm/pressure/st_lps22hh_spi.c

diff --git a/Documentation/devicetree/bindings/iio/stm/pressure/st_lps22hh.txt b/Documentation/devicetree/bindings/iio/stm/pressure/st_lps22hh.txt
new file mode 100644
index 000000000..b36911f97
--- /dev/null
+++ b/Documentation/devicetree/bindings/iio/stm/pressure/st_lps22hh.txt
@@ -0,0 +1,41 @@
+* st_lps22hh driver for pressure MEMS sensors
+
+Required properties for all bus drivers:
+- compatible: must be one of:
+              "st,lps22ch"
+              "st,lps22hh"
+              "st,lps27hhw"
+
+Required properties for the i2c bindings:
+- reg: i2c slave address
+
+Required properties for the spi bindings:
+- reg:               the chipselect index
+- spi-max-frequency: maximal bus speed, should be set to 1000000 unless
+                     constrained by external circuitry
+
+Optional properties for all bus drivers:
+- interrupts: interrupt mapping for IRQ. It should be configured with
+              flags IRQ_TYPE_LEVEL_HIGH, IRQ_TYPE_EDGE_RISING,
+              IRQ_TYPE_LEVEL_LOW or IRQ_TYPE_EDGE_FALLING.
+
+              Refer to interrupt-controller/interrupts.txt for generic interrupt
+              client node bindings.
+
+Example for an i2c device node:
+
+&i2c5 {
+    status = "okay";
+
+    lps22hh_X_STM32MP_MSP01@5d {
+        compatible = "st,lps22hh";
+        reg = <0x5d>;
+
+        /* STM32MP1 - X-STM32MP-MSP0: LPS22HH_INT_DRDY (PG8) */
+        interrupt-parent = <&gpiog>;
+        interrupts = <8 IRQ_TYPE_EDGE_RISING>;
+
+        status = "okay";
+    };
+}
+
diff --git a/drivers/iio/stm/Kconfig b/drivers/iio/stm/Kconfig
index 17ca57867..3469ccf88 100644
--- a/drivers/iio/stm/Kconfig
+++ b/drivers/iio/stm/Kconfig
@@ -12,6 +12,7 @@ if IIO_STM
 source "drivers/iio/stm/accel/Kconfig"
 source "drivers/iio/stm/imu/Kconfig"
 source "drivers/iio/stm/magnetometer/Kconfig"
+source "drivers/iio/stm/pressure/Kconfig"
 
 endif # IIO_STM
 
diff --git a/drivers/iio/stm/Makefile b/drivers/iio/stm/Makefile
index 6f8535318..9c24fa254 100644
--- a/drivers/iio/stm/Makefile
+++ b/drivers/iio/stm/Makefile
@@ -7,3 +7,4 @@
 obj-$(CONFIG_IIO_STM) += accel/
 obj-$(CONFIG_IIO_STM) += imu/
 obj-$(CONFIG_IIO_STM) += magnetometer/
+obj-$(CONFIG_IIO_STM) += pressure/
diff --git a/drivers/iio/stm/pressure/Kconfig b/drivers/iio/stm/pressure/Kconfig
new file mode 100644
index 000000000..246303faa
--- /dev/null
+++ b/drivers/iio/stm/pressure/Kconfig
@@ -0,0 +1,28 @@
+# SPDX-License-Identifier: GPL-2.0-only
+#
+# Pressure drivers
+#
+# When adding new entries keep the list in alphabetical order
+
+menu "Pressure sensors"
+
+config ST_LPS22HH_IIO
+	tristate "STMicroelectronics LPS22CH/LPS22HH/LPS27HHW sensor"
+	depends on (I2C || SPI_MASTER) && SYSFS
+	select IIO_BUFFER
+	select IIO_KFIFO_BUF
+	select ST_LPS22HH_I2C_IIO if (I2C)
+	select ST_LPS22HH_SPI_IIO if (SPI)
+	help
+	  This driver supports LPS22HH sensors. This driver can be
+	  built as a module. The module will be called st-lps22hh.
+
+config ST_LPS22HH_I2C_IIO
+	tristate
+	depends on ST_LPS22HH_IIO
+
+config ST_LPS22HH_SPI_IIO
+	tristate
+	depends on ST_LPS22HH_IIO
+
+endmenu
diff --git a/drivers/iio/stm/pressure/Makefile b/drivers/iio/stm/pressure/Makefile
new file mode 100644
index 000000000..9884e39d2
--- /dev/null
+++ b/drivers/iio/stm/pressure/Makefile
@@ -0,0 +1,11 @@
+# SPDX-License-Identifier: GPL-2.0
+#
+# Makefile for industrial I/O pressure drivers
+#
+
+# When adding new entries keep the list in alphabetical order
+obj-$(CONFIG_ST_LPS22HH_IIO) += st_lps22hh.o
+obj-$(CONFIG_ST_LPS22HH_I2C_IIO) += st_lps22hh_i2c.o
+obj-$(CONFIG_ST_LPS22HH_SPI_IIO) += st_lps22hh_spi.o
+
+st_lps22hh-y += st_lps22hh_core.o st_lps22hh_buffer.o
diff --git a/drivers/iio/stm/pressure/st_lps22hh.h b/drivers/iio/stm/pressure/st_lps22hh.h
new file mode 100644
index 000000000..2bc189a67
--- /dev/null
+++ b/drivers/iio/stm/pressure/st_lps22hh.h
@@ -0,0 +1,112 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * STMicroelectronics lps22hh driver
+ *
+ * MEMS Software Solutions Team
+ *
+ * Copyright 2017 STMicroelectronics Inc.
+ */
+
+#ifndef __ST_LPS22HH_H
+#define __ST_LPS22HH_H
+
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/iio/iio.h>
+#include <linux/iio/trigger.h>
+
+#include "../common/stm_iio_types.h"
+
+#define ST_LPS22HH_MAX_FIFO_LENGTH		127
+
+#define ST_LPS22HH_LIR_ADDR			0x0b
+#define ST_LPS22HH_LIR_MASK			0x04
+
+#define ST_LPS22HH_WHO_AM_I_ADDR		0x0f
+#define ST_LPS22HH_WHO_AM_I_DEF			0xb4
+
+#define ST_LPS22HH_CTRL1_ADDR			0x10
+#define ST_LPS22HH_BDU_MASK			0x02
+
+#define ST_LPS22HH_CTRL2_ADDR			0x11
+#define ST_LPS22HH_LOW_NOISE_EN_MASK		0x02
+#define ST_LPS22HH_SOFT_RESET_MASK		0x04
+#define ST_LPS22HH_INT_ACTIVE_MASK		0x40
+#define ST_LPS22HH_BOOT_MASK			0x80
+
+#define ST_LPS22HH_CTRL3_ADDR			0x12
+#define ST_LPS22HH_INT_FTH_MASK			0x10
+
+enum st_lps22hh_sensor_type {
+	ST_LPS22HH_PRESS = 0,
+	ST_LPS22HH_TEMP,
+	ST_LPS22HH_SENSORS_NUMB,
+};
+
+enum st_lps22hh_fifo_mode {
+	ST_LPS22HH_BYPASS = 0x0,
+	ST_LPS22HH_STREAM = 0x2,
+};
+
+#define ST_LPS22HH_PRESS_SAMPLE_LEN		3
+#define ST_LPS22HH_TEMP_SAMPLE_LEN		2
+#define ST_LPS22HH_FIFO_SAMPLE_LEN		((ST_LPS22HH_PRESS_SAMPLE_LEN + \
+						 ST_LPS22HH_TEMP_SAMPLE_LEN))
+
+#define ST_LPS22HH_TX_MAX_LENGTH		8
+#define ST_LPS22HH_RX_MAX_LENGTH		((ST_LPS22HH_MAX_FIFO_LENGTH + 1) * \
+						 ST_LPS22HH_FIFO_SAMPLE_LEN)
+
+struct st_lps22hh_transfer_buffer {
+	u8 rx_buf[ST_LPS22HH_RX_MAX_LENGTH];
+	u8 tx_buf[ST_LPS22HH_TX_MAX_LENGTH] ____cacheline_aligned;
+};
+
+struct st_lps22hh_transfer_function {
+	int (*write)(struct device *dev, u8 addr, int len, u8 *data);
+	int (*read)(struct device *dev, u8 addr, int len, u8 *data);
+};
+
+struct st_lps22hh_hw {
+	struct device *dev;
+	int irq;
+
+	struct mutex fifo_lock;
+	struct mutex lock;
+	u8 watermark;
+
+	struct iio_dev *iio_devs[ST_LPS22HH_SENSORS_NUMB];
+	u8 enable_mask;
+	u8 odr;
+
+	s64 delta_ts;
+	s64 ts_irq;
+	s64 ts;
+
+	const struct st_lps22hh_transfer_function *tf;
+	struct st_lps22hh_transfer_buffer tb;
+};
+
+struct st_lps22hh_sensor {
+	struct st_lps22hh_hw *hw;
+	enum st_lps22hh_sensor_type type;
+	char name[32];
+
+	u32 gain;
+	u8 odr;
+};
+
+int st_lps22hh_common_probe(struct device *dev, int irq, const char *name,
+			    const struct st_lps22hh_transfer_function *tf_ops);
+int st_lps22hh_write_with_mask(struct st_lps22hh_hw *hw, u8 addr, u8 mask,
+			       u8 data);
+int st_lps22hh_allocate_buffers(struct st_lps22hh_hw *hw);
+int st_lps22hh_set_enable(struct st_lps22hh_sensor *sensor, bool enable);
+ssize_t st_lps22hh_sysfs_set_hwfifo_watermark(struct device *dev,
+					      struct device_attribute *attr,
+					      const char *buf, size_t count);
+ssize_t st_lps22hh_sysfs_flush_fifo(struct device *dev,
+				    struct device_attribute *attr,
+				    const char *buf, size_t size);
+
+#endif /* __ST_LPS22HH_H */
diff --git a/drivers/iio/stm/pressure/st_lps22hh_buffer.c b/drivers/iio/stm/pressure/st_lps22hh_buffer.c
new file mode 100644
index 000000000..602c045a0
--- /dev/null
+++ b/drivers/iio/stm/pressure/st_lps22hh_buffer.c
@@ -0,0 +1,314 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * STMicroelectronics lps22hh buffer driver
+ *
+ * MEMS Software Solutions Team
+ *
+ * Copyright 2017 STMicroelectronics Inc.
+ */
+
+#include <linux/interrupt.h>
+#include <linux/iio/iio.h>
+#include <linux/iio/buffer.h>
+#include <linux/iio/kfifo_buf.h>
+#include <linux/iio/events.h>
+#include <linux/version.h>
+
+#include "st_lps22hh.h"
+
+#define ST_LPS22HH_FIFO_CTRL_ADDR		0x13
+#define ST_LPS22HH_FIFO_MODE_MASK		0x03
+
+#define ST_LPS22HH_FIFO_WTM_ADDR		0x14
+#define ST_LPS22HH_FIFO_THS_MASK		0x7f
+
+#define ST_LPS22HH_FIFO_SRC_ADDR		0x25
+#define ST_LPS22HH_FIFO_SRC_DIFF_MASK		0xff
+
+#define ST_LPS22HH_FIFO_DATA_OUT_PRESS_XL_ADDR	0x78
+
+static inline s64 st_lps22hh_get_time_ns(struct st_lps22hh_hw *hw)
+{
+	return iio_get_time_ns(hw->iio_devs[ST_LPS22HH_PRESS]);
+}
+
+static int st_lps22hh_set_fifo_mode(struct st_lps22hh_hw *hw,
+				    enum st_lps22hh_fifo_mode mode)
+{
+	switch (mode) {
+	case ST_LPS22HH_BYPASS:
+	case ST_LPS22HH_STREAM:
+		break;
+	default:
+		return -EINVAL;
+	}
+	return st_lps22hh_write_with_mask(hw, ST_LPS22HH_FIFO_CTRL_ADDR,
+					  ST_LPS22HH_FIFO_MODE_MASK, mode);
+}
+
+static int st_lps22hh_update_fifo_watermark(struct st_lps22hh_hw *hw, u8 val)
+{
+	int err;
+
+	err = st_lps22hh_write_with_mask(hw, ST_LPS22HH_FIFO_WTM_ADDR,
+					 ST_LPS22HH_FIFO_THS_MASK, val);
+	if (err < 0)
+		return err;
+
+	hw->watermark = val;
+
+	return 0;
+}
+
+ssize_t st_lps22hh_sysfs_set_hwfifo_watermark(struct device *dev,
+					      struct device_attribute *attr,
+					      const char *buf, size_t count)
+{
+	struct st_lps22hh_sensor *sensor = iio_priv(dev_to_iio_dev(dev));
+	int err, watermark;
+
+	err = kstrtoint(buf, 10, &watermark);
+	if (err < 0)
+		return err;
+
+	if (watermark < 1 || watermark > ST_LPS22HH_MAX_FIFO_LENGTH)
+		return -EINVAL;
+
+	err = st_lps22hh_update_fifo_watermark(sensor->hw, watermark);
+
+	return err < 0 ? err : count;
+}
+
+static int st_lps22hh_read_fifo(struct st_lps22hh_hw *hw, s64 delta_ts)
+{
+	u8 iio_buff[ALIGN(sizeof(u32) + sizeof(s64), sizeof(s64))];
+	u8 status, buff[ST_LPS22HH_RX_MAX_LENGTH];
+	int err, i, read_len;
+
+	err = hw->tf->read(hw->dev, ST_LPS22HH_FIFO_SRC_ADDR,
+			   sizeof(status), &status);
+	if (err < 0)
+		return err;
+
+	read_len = (status & ST_LPS22HH_FIFO_SRC_DIFF_MASK) *
+		   ST_LPS22HH_FIFO_SAMPLE_LEN;
+	if (!read_len)
+		return 0;
+
+	err = hw->tf->read(hw->dev, ST_LPS22HH_FIFO_DATA_OUT_PRESS_XL_ADDR,
+			   read_len, buff);
+	if (err < 0)
+		return err;
+
+	for (i = 0; i < read_len; i += ST_LPS22HH_FIFO_SAMPLE_LEN) {
+		/* press sample */
+		memcpy(iio_buff, buff + i, ST_LPS22HH_PRESS_SAMPLE_LEN);
+		iio_push_to_buffers_with_timestamp(
+				hw->iio_devs[ST_LPS22HH_PRESS],
+				iio_buff, hw->ts);
+		/* temp sample */
+		memcpy(iio_buff, buff + i + ST_LPS22HH_PRESS_SAMPLE_LEN,
+		       ST_LPS22HH_TEMP_SAMPLE_LEN);
+		iio_push_to_buffers_with_timestamp(
+				hw->iio_devs[ST_LPS22HH_TEMP],
+				iio_buff, hw->ts);
+		hw->ts += delta_ts;
+	}
+
+	return read_len;
+}
+
+ssize_t st_lps22hh_sysfs_flush_fifo(struct device *dev,
+				    struct device_attribute *attr,
+				    const char *buf, size_t size)
+{
+	struct iio_dev *indio_dev = dev_to_iio_dev(dev);
+	struct st_lps22hh_sensor *sensor = iio_priv(indio_dev);
+	struct st_lps22hh_hw *hw = sensor->hw;
+	u64 type, event;
+	int len;
+
+	mutex_lock(&indio_dev->mlock);
+	if (!iio_buffer_enabled(indio_dev)) {
+		mutex_unlock(&indio_dev->mlock);
+		return -EINVAL;
+	}
+
+	mutex_lock(&hw->fifo_lock);
+	len = st_lps22hh_read_fifo(hw, hw->delta_ts);
+	hw->ts = st_lps22hh_get_time_ns(hw);
+	hw->ts_irq = hw->ts;
+	mutex_unlock(&hw->fifo_lock);
+
+	type = len > 0 ? STM_IIO_EV_DIR_FIFO_DATA : STM_IIO_EV_DIR_FIFO_EMPTY;
+	if (sensor->type == ST_LPS22HH_PRESS)
+		event = IIO_UNMOD_EVENT_CODE(IIO_PRESSURE, -1,
+					     STM_IIO_EV_TYPE_FIFO_FLUSH, type);
+	else
+		event = IIO_UNMOD_EVENT_CODE(IIO_TEMP, -1,
+					     STM_IIO_EV_TYPE_FIFO_FLUSH, type);
+	iio_push_event(indio_dev, event, st_lps22hh_get_time_ns(hw));
+	mutex_unlock(&indio_dev->mlock);
+
+	return size;
+}
+
+
+#define ST_LPS22HH_EWMA_LEVEL			96
+#define ST_LPS22HH_EWMA_DIV			128
+static inline s64 st_lps22hh_ewma(s64 old, s64 new, int weight)
+{
+	s64 diff, incr;
+
+	diff = new - old;
+	incr = div_s64((ST_LPS22HH_EWMA_DIV - weight) * diff,
+		       ST_LPS22HH_EWMA_DIV);
+
+	return old + incr;
+}
+
+static irqreturn_t st_lps22hh_irq_handler(int irq, void *private)
+{
+	struct st_lps22hh_hw *hw = private;
+	s64 delta_ts, ts = st_lps22hh_get_time_ns(hw);
+
+	delta_ts = div_s64((ts - hw->ts_irq), hw->watermark);
+	if (hw->odr >= 50)
+		hw->delta_ts = st_lps22hh_ewma(hw->delta_ts, delta_ts,
+					       ST_LPS22HH_EWMA_LEVEL);
+	else
+		hw->delta_ts = delta_ts;
+	hw->ts_irq = ts;
+
+	return IRQ_WAKE_THREAD;
+}
+
+static irqreturn_t st_lps22hh_irq_thread(int irq, void *private)
+{
+	struct st_lps22hh_hw *hw = private;
+
+	mutex_lock(&hw->fifo_lock);
+	st_lps22hh_read_fifo(hw, hw->delta_ts);
+	mutex_unlock(&hw->fifo_lock);
+
+	return IRQ_HANDLED;
+}
+
+static int st_lps22hh_buffer_preenable(struct iio_dev *indio_dev)
+{
+	struct st_lps22hh_sensor *sensor = iio_priv(indio_dev);
+	struct st_lps22hh_hw *hw = sensor->hw;
+	int err;
+
+	err = st_lps22hh_set_fifo_mode(sensor->hw, ST_LPS22HH_STREAM);
+	if (err < 0)
+		return err;
+
+	err = st_lps22hh_update_fifo_watermark(hw, hw->watermark);
+	if (err < 0)
+		return err;
+
+	err = st_lps22hh_write_with_mask(sensor->hw, ST_LPS22HH_CTRL3_ADDR,
+					 ST_LPS22HH_INT_FTH_MASK, true);
+	if (err < 0)
+		return err;
+
+	err = st_lps22hh_set_enable(sensor, true);
+	if (err < 0)
+		return err;
+
+	hw->delta_ts = div_s64(1000000000UL, hw->odr);
+	hw->ts = st_lps22hh_get_time_ns(hw);
+	hw->ts_irq = hw->ts;
+
+	return 0;
+}
+
+static int st_lps22hh_buffer_postdisable(struct iio_dev *indio_dev)
+{
+	struct st_lps22hh_sensor *sensor = iio_priv(indio_dev);
+	int err;
+
+	err = st_lps22hh_set_fifo_mode(sensor->hw, ST_LPS22HH_BYPASS);
+	if (err < 0)
+		return err;
+
+	err = st_lps22hh_write_with_mask(sensor->hw, ST_LPS22HH_CTRL3_ADDR,
+					 ST_LPS22HH_INT_FTH_MASK, false);
+	if (err < 0)
+		return err;
+
+	return st_lps22hh_set_enable(sensor, false);
+}
+
+static const struct iio_buffer_setup_ops st_lps22hh_buffer_ops = {
+	.preenable = st_lps22hh_buffer_preenable,
+	.postdisable = st_lps22hh_buffer_postdisable,
+};
+
+int st_lps22hh_allocate_buffers(struct st_lps22hh_hw *hw)
+{
+#if  KERNEL_VERSION(5, 13, 0) > LINUX_VERSION_CODE
+	struct iio_buffer *buffer;
+#endif /* LINUX_VERSION_CODE */
+	unsigned long irq_type;
+	u8 int_active = 0;
+	int err, i;
+
+	irq_type = irqd_get_trigger_type(irq_get_irq_data(hw->irq));
+
+	switch (irq_type) {
+	case IRQF_TRIGGER_HIGH:
+	case IRQF_TRIGGER_RISING:
+		int_active = 0;
+		break;
+	case IRQF_TRIGGER_LOW:
+	case IRQF_TRIGGER_FALLING:
+		int_active = 1;
+		break;
+	default:
+		dev_info(hw->dev, "mode %lx unsupported\n", irq_type);
+		return -EINVAL;
+	}
+
+	err = st_lps22hh_write_with_mask(hw, ST_LPS22HH_CTRL2_ADDR,
+					 ST_LPS22HH_INT_ACTIVE_MASK,
+					 int_active);
+	if (err < 0)
+		return err;
+
+	err = devm_request_threaded_irq(hw->dev, hw->irq,
+					st_lps22hh_irq_handler,
+					st_lps22hh_irq_thread,
+					irq_type | IRQF_ONESHOT,
+					"lps22hh", hw);
+	if (err)
+		return err;
+
+	for (i = 0; i < ST_LPS22HH_SENSORS_NUMB; i++) {
+
+#if KERNEL_VERSION(5, 19, 0) <= LINUX_VERSION_CODE
+		err = devm_iio_kfifo_buffer_setup(hw->dev, hw->iio_devs[i],
+						  &st_lps22hh_buffer_ops);
+		if (err)
+			return err;
+#elif KERNEL_VERSION(5, 13, 0) <= LINUX_VERSION_CODE
+		err = devm_iio_kfifo_buffer_setup(hw->dev, hw->iio_devs[i],
+						  INDIO_BUFFER_SOFTWARE,
+						  &st_lps22hh_buffer_ops);
+		if (err)
+			return err;
+#else /* LINUX_VERSION_CODE */
+		buffer = devm_iio_kfifo_allocate(hw->dev);
+		if (!buffer)
+			return -ENOMEM;
+
+		iio_device_attach_buffer(hw->iio_devs[i], buffer);
+		hw->iio_devs[i]->modes |= INDIO_BUFFER_SOFTWARE;
+		hw->iio_devs[i]->setup_ops = &st_lps22hh_buffer_ops;
+#endif /* LINUX_VERSION_CODE */
+
+	}
+
+	return 0;
+}
diff --git a/drivers/iio/stm/pressure/st_lps22hh_core.c b/drivers/iio/stm/pressure/st_lps22hh_core.c
new file mode 100644
index 000000000..48b3a6bef
--- /dev/null
+++ b/drivers/iio/stm/pressure/st_lps22hh_core.c
@@ -0,0 +1,492 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * STMicroelectronics lps22hh driver
+ *
+ * MEMS Software Solutions Team
+ *
+ * Copyright 2017 STMicroelectronics Inc.
+ */
+
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/types.h>
+#include <linux/mutex.h>
+#include <linux/iio/iio.h>
+#include <linux/iio/sysfs.h>
+#include <linux/iio/trigger.h>
+#include <linux/delay.h>
+#include <asm/unaligned.h>
+
+#include "st_lps22hh.h"
+
+#define ST_LPS22HH_PRESS_FS_AVL_GAIN		(1000000000UL / 4096UL)
+#define ST_LPS22HH_TEMP_FS_AVL_GAIN		100
+
+#define ST_LPS22HH_ODR_LIST_NUM			8
+struct st_lps22hh_odr_table_t {
+	u8 addr;
+	u8 mask;
+	u8 odr_avl[ST_LPS22HH_ODR_LIST_NUM];
+};
+
+const static struct st_lps22hh_odr_table_t st_lps22hh_odr_table = {
+	.addr = 0x10,
+	.mask = 0x70,
+	.odr_avl = { 0, 1, 10, 25, 50, 75, 100, 200 },
+};
+
+const struct iio_event_spec st_lps22hh_fifo_flush_event = {
+	.type = STM_IIO_EV_TYPE_FIFO_FLUSH,
+	.dir = IIO_EV_DIR_EITHER,
+};
+
+static const struct iio_chan_spec st_lps22hh_press_channels[] = {
+	{
+		.type = IIO_PRESSURE,
+		.address = 0x28,
+		.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) |
+				      BIT(IIO_CHAN_INFO_SCALE),
+		.info_mask_shared_by_all = BIT(IIO_CHAN_INFO_SAMP_FREQ),
+		.channel2 = IIO_NO_MOD,
+		.scan_index = 0,
+		.scan_type = {
+			.sign = 'u',
+			.realbits = 24,
+			.storagebits = 32,
+			.endianness = IIO_LE,
+		},
+	},
+	{
+		.type = IIO_PRESSURE,
+		.scan_index = -1,
+		.indexed = -1,
+		.event_spec = &st_lps22hh_fifo_flush_event,
+		.num_event_specs = 1,
+	},
+	IIO_CHAN_SOFT_TIMESTAMP(1)
+};
+
+static const struct iio_chan_spec st_lps22hh_temp_channels[] = {
+	{
+		.type = IIO_TEMP,
+		.address = 0x2b,
+		.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) |
+				      BIT(IIO_CHAN_INFO_SCALE),
+		.info_mask_shared_by_all = BIT(IIO_CHAN_INFO_SAMP_FREQ),
+		.channel2 = IIO_NO_MOD,
+		.scan_index = 0,
+		.scan_type = {
+			.sign = 's',
+			.realbits = 16,
+			.storagebits = 16,
+			.endianness = IIO_LE,
+		},
+	},
+	{
+		.type = IIO_TEMP,
+		.scan_index = -1,
+		.indexed = -1,
+		.event_spec = &st_lps22hh_fifo_flush_event,
+		.num_event_specs = 1,
+	},
+	IIO_CHAN_SOFT_TIMESTAMP(1)
+};
+
+int st_lps22hh_write_with_mask(struct st_lps22hh_hw *hw, u8 addr, u8 mask,
+			       u8 val)
+{
+	int err;
+	u8 data;
+
+	mutex_lock(&hw->lock);
+
+	err = hw->tf->read(hw->dev, addr, sizeof(data), &data);
+	if (err < 0)
+		goto unlock;
+
+	data = (data & ~mask) | ((val << __ffs(mask)) & mask);
+	err = hw->tf->write(hw->dev, addr, sizeof(data), &data);
+unlock:
+	mutex_unlock(&hw->lock);
+
+	return err;
+}
+
+static int st_lps22hh_check_whoami(struct st_lps22hh_hw *hw)
+{
+	int err;
+	u8 data;
+
+	err = hw->tf->read(hw->dev, ST_LPS22HH_WHO_AM_I_ADDR, sizeof(data),
+			   &data);
+	if (err < 0) {
+		dev_err(hw->dev, "failed to read Who-Am-I register.\n");
+
+		return err;
+	}
+	if (data != ST_LPS22HH_WHO_AM_I_DEF) {
+		dev_err(hw->dev, "Who-Am-I value not valid.\n");
+		return -ENODEV;
+	}
+	return 0;
+}
+
+static int st_lps22hh_get_odr(struct st_lps22hh_sensor *sensor, u8 odr)
+{
+	int i;
+
+	for (i = 0; i < ST_LPS22HH_ODR_LIST_NUM; i++) {
+		if (st_lps22hh_odr_table.odr_avl[i] == odr)
+			break;
+	}
+	return i == ST_LPS22HH_ODR_LIST_NUM ? -EINVAL : i;
+}
+
+int st_lps22hh_set_enable(struct st_lps22hh_sensor *sensor, bool enable)
+{
+	struct st_lps22hh_hw *hw = sensor->hw;
+	u32 max_odr = enable ? sensor->odr : 0;
+	int i;
+
+	for (i = 0; i < ST_LPS22HH_SENSORS_NUMB; i++) {
+		if (sensor->type == i)
+			continue;
+
+		if (hw->enable_mask & BIT(i)) {
+			struct st_lps22hh_sensor *temp;
+
+			temp = iio_priv(hw->iio_devs[i]);
+			max_odr = max_t(u32, max_odr, temp->odr);
+		}
+	}
+
+	if (max_odr != hw->odr) {
+		int err, ret;
+
+		ret = st_lps22hh_get_odr(sensor, max_odr);
+		if (ret < 0)
+			return ret;
+
+		err = st_lps22hh_write_with_mask(hw, st_lps22hh_odr_table.addr,
+						 st_lps22hh_odr_table.mask, ret);
+		if (err < 0)
+			return err;
+
+		hw->odr = max_odr;
+	}
+
+	if (enable)
+		hw->enable_mask |= BIT(sensor->type);
+	else
+		hw->enable_mask &= ~BIT(sensor->type);
+
+	return 0;
+}
+
+int st_lps22hh_init_sensors(struct st_lps22hh_hw *hw)
+{
+	int err;
+
+	/* Reboot memory content */
+	err = st_lps22hh_write_with_mask(hw, ST_LPS22HH_CTRL2_ADDR,
+					 ST_LPS22HH_BOOT_MASK, 1);
+	if (err < 0)
+		return err;
+
+	msleep(10);
+
+	/* soft reset the device on power on. */
+	err = st_lps22hh_write_with_mask(hw, ST_LPS22HH_CTRL2_ADDR,
+					 ST_LPS22HH_SOFT_RESET_MASK, 1);
+	if (err < 0)
+		return err;
+
+	msleep(200);
+
+	/* enable low noise */
+	err = st_lps22hh_write_with_mask(hw, ST_LPS22HH_CTRL2_ADDR,
+					 ST_LPS22HH_LOW_NOISE_EN_MASK, 1);
+	if (err < 0)
+		return err;
+
+	/* enable latched interrupt mode */
+	err = st_lps22hh_write_with_mask(hw, ST_LPS22HH_LIR_ADDR,
+					 ST_LPS22HH_LIR_MASK, 1);
+	if (err < 0)
+		return err;
+
+	/* enable BDU */
+	return st_lps22hh_write_with_mask(hw, ST_LPS22HH_CTRL1_ADDR,
+					  ST_LPS22HH_BDU_MASK, 1);
+}
+
+static ssize_t
+st_lps22hh_get_sampling_frequency_avail(struct device *dev,
+					struct device_attribute *attr,
+					char *buf)
+{
+	int i, len = 0;
+
+	for (i = 1; i < ST_LPS22HH_ODR_LIST_NUM; i++) {
+		len += scnprintf(buf + len, PAGE_SIZE - len, "%d ",
+				 st_lps22hh_odr_table.odr_avl[i]);
+	}
+	buf[len - 1] = '\n';
+
+	return len;
+}
+
+static ssize_t
+st_lps22hh_sysfs_get_hwfifo_watermark(struct device *dev,
+				      struct device_attribute *attr, char *buf)
+{
+	struct st_lps22hh_sensor *sensor = iio_priv(dev_to_iio_dev(dev));
+
+	return sprintf(buf, "%d\n", sensor->hw->watermark);
+}
+
+static ssize_t
+st_lps22hh_sysfs_get_hwfifo_watermark_min(struct device *dev,
+					  struct device_attribute *attr,
+					  char *buf)
+{
+	return sprintf(buf, "%d\n", 1);
+}
+
+static ssize_t
+st_lps22hh_sysfs_get_hwfifo_watermark_max(struct device *dev,
+					  struct device_attribute *attr,
+					  char *buf)
+{
+	return sprintf(buf, "%d\n", ST_LPS22HH_MAX_FIFO_LENGTH);
+}
+
+static int st_lps22hh_read_raw(struct iio_dev *indio_dev,
+			       struct iio_chan_spec const *ch,
+			       int *val, int *val2, long mask)
+{
+	struct st_lps22hh_sensor *sensor = iio_priv(indio_dev);
+	struct st_lps22hh_hw *hw = sensor->hw;
+	int ret;
+
+	switch (mask) {
+	case IIO_CHAN_INFO_RAW: {
+		u8 len = ch->scan_type.realbits / 8;
+		u8 data[4] = {};
+
+		mutex_lock(&indio_dev->mlock);
+		if (iio_buffer_enabled(indio_dev)) {
+			mutex_unlock(&indio_dev->mlock);
+			ret = -EBUSY;
+			break;
+		}
+
+		ret = st_lps22hh_set_enable(sensor, true);
+		if (ret < 0) {
+			mutex_unlock(&indio_dev->mlock);
+			ret = -EBUSY;
+			break;
+		}
+
+		msleep(40);
+		ret = hw->tf->read(hw->dev, ch->address, len, data);
+		if (ret < 0) {
+			mutex_unlock(&indio_dev->mlock);
+			return ret;
+		}
+
+		if (sensor->type == ST_LPS22HH_PRESS)
+			*val = (s32)get_unaligned_le32(data);
+		else if (sensor->type == ST_LPS22HH_TEMP)
+			*val = (s16)get_unaligned_le16(data);
+
+		ret = st_lps22hh_set_enable(sensor, false);
+		mutex_unlock(&indio_dev->mlock);
+
+		if (ret < 0)
+			return ret;
+
+		ret = IIO_VAL_INT;
+		break;
+	}
+	case IIO_CHAN_INFO_SCALE:
+		switch (ch->type) {
+		case IIO_TEMP:
+			*val = 1000;
+			*val2 = sensor->gain;
+			ret = IIO_VAL_FRACTIONAL;
+			break;
+		case IIO_PRESSURE:
+			*val = 0;
+			*val2 = sensor->gain;
+			ret = IIO_VAL_INT_PLUS_NANO;
+			break;
+		default:
+			ret = -ENODEV;
+			break;
+		}
+		break;
+	case IIO_CHAN_INFO_SAMP_FREQ:
+		*val = sensor->odr;
+		ret = IIO_VAL_INT;
+		break;
+	default:
+		ret = -EINVAL;
+		break;
+	}
+	return ret;
+}
+
+static int st_lps22hh_write_raw(struct iio_dev *indio_dev,
+				struct iio_chan_spec const *ch,
+				int val, int val2, long mask)
+{
+	struct st_lps22hh_sensor *sensor = iio_priv(indio_dev);
+	int ret;
+
+	switch (mask) {
+	case IIO_CHAN_INFO_SAMP_FREQ:
+		ret = st_lps22hh_get_odr(sensor, val);
+		if (ret > 0)
+			sensor->odr = val;
+		break;
+	default:
+		ret = -EINVAL;
+		break;
+	}
+	return ret;
+}
+
+static IIO_DEV_ATTR_SAMP_FREQ_AVAIL(st_lps22hh_get_sampling_frequency_avail);
+static IIO_DEVICE_ATTR(hwfifo_watermark, 0644,
+		       st_lps22hh_sysfs_get_hwfifo_watermark,
+		       st_lps22hh_sysfs_set_hwfifo_watermark, 0);
+static IIO_DEVICE_ATTR(hwfifo_watermark_min, 0444,
+		       st_lps22hh_sysfs_get_hwfifo_watermark_min, NULL, 0);
+static IIO_DEVICE_ATTR(hwfifo_watermark_max, 0444,
+		       st_lps22hh_sysfs_get_hwfifo_watermark_max, NULL, 0);
+static IIO_DEVICE_ATTR(hwfifo_flush, 0200, NULL,
+		       st_lps22hh_sysfs_flush_fifo, 0);
+
+static struct attribute *st_lps22hh_press_attributes[] = {
+	&iio_dev_attr_sampling_frequency_available.dev_attr.attr,
+	&iio_dev_attr_hwfifo_watermark.dev_attr.attr,
+	&iio_dev_attr_hwfifo_watermark_min.dev_attr.attr,
+	&iio_dev_attr_hwfifo_watermark_max.dev_attr.attr,
+	&iio_dev_attr_hwfifo_flush.dev_attr.attr,
+	NULL,
+};
+
+static struct attribute *st_lps22hh_temp_attributes[] = {
+	&iio_dev_attr_sampling_frequency_available.dev_attr.attr,
+	&iio_dev_attr_hwfifo_watermark.dev_attr.attr,
+	&iio_dev_attr_hwfifo_watermark_min.dev_attr.attr,
+	&iio_dev_attr_hwfifo_watermark_max.dev_attr.attr,
+	&iio_dev_attr_hwfifo_flush.dev_attr.attr,
+	NULL,
+};
+
+static const struct attribute_group st_lps22hh_press_attribute_group = {
+	.attrs = st_lps22hh_press_attributes,
+};
+static const struct attribute_group st_lps22hh_temp_attribute_group = {
+	.attrs = st_lps22hh_temp_attributes,
+};
+
+static const struct iio_info st_lps22hh_press_info = {
+	.attrs = &st_lps22hh_press_attribute_group,
+	.read_raw = st_lps22hh_read_raw,
+	.write_raw = st_lps22hh_write_raw,
+};
+
+static const struct iio_info st_lps22hh_temp_info = {
+	.attrs = &st_lps22hh_temp_attribute_group,
+	.read_raw = st_lps22hh_read_raw,
+	.write_raw = st_lps22hh_write_raw,
+};
+
+int st_lps22hh_common_probe(struct device *dev, int irq, const char *name,
+			 const struct st_lps22hh_transfer_function *tf_ops)
+{
+	struct st_lps22hh_sensor *sensor;
+	struct st_lps22hh_hw *hw;
+	struct iio_dev *iio_dev;
+	int err, i;
+
+	hw = devm_kzalloc(dev, sizeof(*hw), GFP_KERNEL);
+	if (!hw)
+		return -ENOMEM;
+
+	dev_set_drvdata(dev, (void *)hw);
+	hw->dev = dev;
+	hw->tf = tf_ops;
+	hw->irq = irq;
+	/* set initial watermark */
+	hw->watermark = 1;
+
+	mutex_init(&hw->lock);
+	mutex_init(&hw->fifo_lock);
+
+	err = st_lps22hh_check_whoami(hw);
+	if (err < 0)
+		return err;
+
+	for (i = 0; i < ST_LPS22HH_SENSORS_NUMB; i++) {
+		iio_dev = devm_iio_device_alloc(dev, sizeof(*sensor));
+		if (!iio_dev)
+			return -ENOMEM;
+
+		hw->iio_devs[i] = iio_dev;
+		sensor = iio_priv(iio_dev);
+		sensor->hw = hw;
+		sensor->type = i;
+		sensor->odr = 1;
+
+		switch (i) {
+		case ST_LPS22HH_PRESS:
+			sensor->gain = ST_LPS22HH_PRESS_FS_AVL_GAIN;
+			scnprintf(sensor->name, sizeof(sensor->name),
+				  "%s_press", name);
+			iio_dev->channels = st_lps22hh_press_channels;
+			iio_dev->num_channels =
+				ARRAY_SIZE(st_lps22hh_press_channels);
+			iio_dev->info = &st_lps22hh_press_info;
+			break;
+		case ST_LPS22HH_TEMP:
+			sensor->gain = ST_LPS22HH_TEMP_FS_AVL_GAIN;
+			scnprintf(sensor->name, sizeof(sensor->name),
+				  "%s_temp", name);
+			iio_dev->channels = st_lps22hh_temp_channels;
+			iio_dev->num_channels =
+				ARRAY_SIZE(st_lps22hh_temp_channels);
+			iio_dev->info = &st_lps22hh_temp_info;
+			break;
+		default:
+			return -EINVAL;
+		};
+		iio_dev->name = sensor->name;
+		iio_dev->modes = INDIO_DIRECT_MODE;
+	}
+
+	err = st_lps22hh_init_sensors(hw);
+	if (err < 0)
+		return err;
+
+	if (irq > 0) {
+		err = st_lps22hh_allocate_buffers(hw);
+		if (err < 0)
+			return err;
+	}
+
+	for (i = 0; i < ST_LPS22HH_SENSORS_NUMB; i++) {
+		err = devm_iio_device_register(dev, hw->iio_devs[i]);
+		if (err)
+			return err;
+	}
+	return 0;
+}
+EXPORT_SYMBOL(st_lps22hh_common_probe);
+
+MODULE_DESCRIPTION("STMicroelectronics lps22hh driver");
+MODULE_AUTHOR("MEMS Software Solutions Team");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/iio/stm/pressure/st_lps22hh_i2c.c b/drivers/iio/stm/pressure/st_lps22hh_i2c.c
new file mode 100644
index 000000000..f9e806b37
--- /dev/null
+++ b/drivers/iio/stm/pressure/st_lps22hh_i2c.c
@@ -0,0 +1,94 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * STMicroelectronics lps22hh i2c driver
+ *
+ * MEMS Software Solutions Team
+ *
+ * Copyright 2017 STMicroelectronics Inc.
+ */
+
+#include <linux/i2c.h>
+
+#include "st_lps22hh.h"
+
+static int st_lps22hh_i2c_read(struct device *dev, u8 addr, int len, u8 *data)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct i2c_msg msg[2];
+
+	msg[0].addr = client->addr;
+	msg[0].flags = client->flags;
+	msg[0].len = 1;
+	msg[0].buf = &addr;
+
+	msg[1].addr = client->addr;
+	msg[1].flags = client->flags | I2C_M_RD;
+	msg[1].len = len;
+	msg[1].buf = data;
+
+	return i2c_transfer(client->adapter, msg, 2);
+}
+
+static int st_lps22hh_i2c_write(struct device *dev, u8 addr, int len, u8 *data)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct i2c_msg msg;
+	u8 send[4];
+
+	if (len >= ARRAY_SIZE(send))
+		return -ENOMEM;
+
+	send[0] = addr;
+	memcpy(&send[1], data, len * sizeof(u8));
+	len++;
+
+	msg.addr = client->addr;
+	msg.flags = client->flags;
+	msg.len = len;
+	msg.buf = send;
+
+	return i2c_transfer(client->adapter, &msg, 1);
+}
+
+static const struct st_lps22hh_transfer_function st_lps22hh_tf_i2c = {
+	.write = st_lps22hh_i2c_write,
+	.read = st_lps22hh_i2c_read,
+};
+
+static int st_lps22hh_i2c_probe(struct i2c_client *client,
+				const struct i2c_device_id *id)
+{
+	return st_lps22hh_common_probe(&client->dev, client->irq, client->name,
+				       &st_lps22hh_tf_i2c);
+}
+
+static const struct i2c_device_id st_lps22hh_ids[] = {
+	{ "lps22ch" },
+	{ "lps22hh" },
+	{ "lps27hhw" },
+	{}
+};
+MODULE_DEVICE_TABLE(i2c, st_lps22hh_ids);
+
+static const struct of_device_id st_lps22hh_id_table[] = {
+	{ .compatible = "st,lps22ch" },
+	{ .compatible = "st,lps22hh" },
+	{ .compatible = "st,lps27hhw" },
+	{},
+};
+MODULE_DEVICE_TABLE(of, st_lps22hh_id_table);
+
+static struct i2c_driver st_lps22hh_i2c_driver = {
+	.driver = {
+		   .owner = THIS_MODULE,
+		   .name = "st_lps22hh_i2c",
+		   .of_match_table = of_match_ptr(st_lps22hh_id_table),
+	},
+	.probe = st_lps22hh_i2c_probe,
+	.id_table = st_lps22hh_ids,
+};
+module_i2c_driver(st_lps22hh_i2c_driver);
+
+MODULE_DESCRIPTION("STMicroelectronics lps22hh i2c driver");
+MODULE_AUTHOR("MEMS Software Solutions Team");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/iio/stm/pressure/st_lps22hh_spi.c b/drivers/iio/stm/pressure/st_lps22hh_spi.c
new file mode 100644
index 000000000..ea9c3bbac
--- /dev/null
+++ b/drivers/iio/stm/pressure/st_lps22hh_spi.c
@@ -0,0 +1,101 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * STMicroelectronics lps22hh spi driver
+ *
+ * MEMS Software Solutions Team
+ *
+ * Copyright 2017 STMicroelectronics Inc.
+ */
+
+#include <linux/spi/spi.h>
+
+#include "st_lps22hh.h"
+
+#define ST_SENSORS_SPI_READ			0x80
+
+static int st_lps22hh_spi_read(struct device *dev, u8 addr, int len, u8 *data)
+{
+	struct spi_device *spi = to_spi_device(dev);
+	struct st_lps22hh_hw *hw = spi_get_drvdata(spi);
+	struct spi_transfer xfers[] = {
+		{
+			.tx_buf = hw->tb.tx_buf,
+			.bits_per_word = 8,
+			.len = 1,
+		},
+		{
+			.rx_buf = hw->tb.rx_buf,
+			.bits_per_word = 8,
+			.len = len,
+		}
+	};
+	int err;
+
+	hw->tb.tx_buf[0] = addr | ST_SENSORS_SPI_READ;
+	err = spi_sync_transfer(spi, xfers, ARRAY_SIZE(xfers));
+	if (err)
+		return err;
+
+	memcpy(data, hw->tb.rx_buf, len);
+
+	return len;
+}
+
+static int st_lps22hh_spi_write(struct device *dev, u8 addr, int len, u8 *data)
+{
+	struct st_lps22hh_hw *hw;
+	struct spi_device *spi;
+
+	if (len >= ST_LPS22HH_TX_MAX_LENGTH)
+		return -ENOMEM;
+
+	spi = to_spi_device(dev);
+	hw = spi_get_drvdata(spi);
+
+	hw->tb.tx_buf[0] = addr;
+	memcpy(&hw->tb.tx_buf[1], data, len);
+
+	return spi_write(spi, hw->tb.tx_buf, len + 1);
+}
+
+static const struct st_lps22hh_transfer_function st_lps22hh_tf_spi = {
+	.write = st_lps22hh_spi_write,
+	.read = st_lps22hh_spi_read,
+};
+
+static int st_lps22hh_spi_probe(struct spi_device *spi)
+{
+	return st_lps22hh_common_probe(&spi->dev, spi->irq, spi->modalias,
+				       &st_lps22hh_tf_spi);
+}
+
+static const struct spi_device_id st_lps22hh_ids[] = {
+	{ "lps22ch" },
+	{ "lps22hh" },
+	{ "lps27hhw" },
+	{}
+};
+MODULE_DEVICE_TABLE(spi, st_lps22hh_ids);
+
+static const struct of_device_id st_lps22hh_id_table[] = {
+	{ .compatible = "st,lps22ch" },
+	{ .compatible = "st,lps22hh" },
+	{ .compatible = "st,lps27hhw" },
+	{},
+};
+MODULE_DEVICE_TABLE(of, st_lps22hh_id_table);
+
+static struct spi_driver st_lps22hh_spi_driver = {
+	.driver = {
+		   .owner = THIS_MODULE,
+		   .name = "st_lps22hh_spi",
+		   .of_match_table = of_match_ptr(st_lps22hh_id_table),
+	},
+	.probe = st_lps22hh_spi_probe,
+	.id_table = st_lps22hh_ids,
+};
+module_spi_driver(st_lps22hh_spi_driver);
+
+MODULE_DESCRIPTION("STMicroelectronics lps22hh spi driver");
+MODULE_AUTHOR("MEMS Software Solutions Team");
+MODULE_LICENSE("GPL v2");
-- 
2.25.1


From 4dc659a3cea1c8aac5aa346c3f4eab45c32aaf20 Mon Sep 17 00:00:00 2001
From: Mario Tesi <mario.tesi@st.com>
Date: Mon, 9 Oct 2023 18:33:34 +0200
Subject: drivers:iio:stm:temperature: Add support to STMEMS temperature
 stts22h

Added support to STMEMS driver for stts22h temerparure device.

Signed-off-by: Mario Tesi <mario.tesi@st.com>
---
 .../bindings/iio/stm/temperature/stts22h.txt  |  17 +
 drivers/iio/stm/Kconfig                       |   1 +
 drivers/iio/stm/Makefile                      |   1 +
 drivers/iio/stm/temperature/Kconfig           |  17 +
 drivers/iio/stm/temperature/Makefile          |   6 +
 drivers/iio/stm/temperature/stts22h.c         | 643 ++++++++++++++++++
 drivers/iio/stm/temperature/stts22h.h         | 104 +++
 7 files changed, 789 insertions(+)
 create mode 100644 Documentation/devicetree/bindings/iio/stm/temperature/stts22h.txt
 create mode 100644 drivers/iio/stm/temperature/Kconfig
 create mode 100644 drivers/iio/stm/temperature/Makefile
 create mode 100644 drivers/iio/stm/temperature/stts22h.c
 create mode 100644 drivers/iio/stm/temperature/stts22h.h

diff --git a/Documentation/devicetree/bindings/iio/stm/temperature/stts22h.txt b/Documentation/devicetree/bindings/iio/stm/temperature/stts22h.txt
new file mode 100644
index 000000000..329d492c7
--- /dev/null
+++ b/Documentation/devicetree/bindings/iio/stm/temperature/stts22h.txt
@@ -0,0 +1,17 @@
+* stts22h driver for temperature MEMS sensors
+
+Required properties for the i2c bindings:
+- compatible: must be one of:
+              "st,stts22h"
+
+Example for an i2c device node:
+
+&i2c5 {
+    status = "okay";
+
+    stts22h-X_STM32MP_MSP01@38 {
+        compatible = "st,stts22h";
+        reg = <0x38>;
+        status = "okay";
+    };
+}
diff --git a/drivers/iio/stm/Kconfig b/drivers/iio/stm/Kconfig
index 3469ccf88..398c7e59f 100644
--- a/drivers/iio/stm/Kconfig
+++ b/drivers/iio/stm/Kconfig
@@ -13,6 +13,7 @@ source "drivers/iio/stm/accel/Kconfig"
 source "drivers/iio/stm/imu/Kconfig"
 source "drivers/iio/stm/magnetometer/Kconfig"
 source "drivers/iio/stm/pressure/Kconfig"
+source "drivers/iio/stm/temperature/Kconfig"
 
 endif # IIO_STM
 
diff --git a/drivers/iio/stm/Makefile b/drivers/iio/stm/Makefile
index 9c24fa254..a2750a1f8 100644
--- a/drivers/iio/stm/Makefile
+++ b/drivers/iio/stm/Makefile
@@ -8,3 +8,4 @@ obj-$(CONFIG_IIO_STM) += accel/
 obj-$(CONFIG_IIO_STM) += imu/
 obj-$(CONFIG_IIO_STM) += magnetometer/
 obj-$(CONFIG_IIO_STM) += pressure/
+obj-$(CONFIG_IIO_STM) += temperature/
diff --git a/drivers/iio/stm/temperature/Kconfig b/drivers/iio/stm/temperature/Kconfig
new file mode 100644
index 000000000..5912fb274
--- /dev/null
+++ b/drivers/iio/stm/temperature/Kconfig
@@ -0,0 +1,17 @@
+# SPDX-License-Identifier: GPL-2.0-only
+#
+# Temperature sensor drivers
+#
+menu "Temperature sensors"
+
+config IIO_STTS22H
+	tristate "STTS22H ST MEMS temperature sensor"
+	depends on I2C
+	help
+	  If you say yes here you get support for STTS22H ST MEMS I2C
+	  temperature sensor.
+
+	  This driver can also be built as a module. If so, the module
+	  will be called stts22h.
+
+endmenu
diff --git a/drivers/iio/stm/temperature/Makefile b/drivers/iio/stm/temperature/Makefile
new file mode 100644
index 000000000..617b2a864
--- /dev/null
+++ b/drivers/iio/stm/temperature/Makefile
@@ -0,0 +1,6 @@
+# SPDX-License-Identifier: GPL-2.0
+#
+# Makefile for industrial I/O temperature drivers
+#
+
+obj-$(CONFIG_IIO_STTS22H) += stts22h.o
diff --git a/drivers/iio/stm/temperature/stts22h.c b/drivers/iio/stm/temperature/stts22h.c
new file mode 100644
index 000000000..68cc78630
--- /dev/null
+++ b/drivers/iio/stm/temperature/stts22h.c
@@ -0,0 +1,643 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * STMicroelectronics stts22h temperature driver
+ *
+ * MEMS Software Solutions Team
+ *
+ * Copyright 2021 STMicroelectronics Inc.
+ */
+
+#include <linux/delay.h>
+#include <linux/i2c.h>
+#include <linux/iio/buffer.h>
+#include <linux/iio/iio.h>
+#include <linux/iio/kfifo_buf.h>
+#include <linux/iio/sysfs.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/pm.h>
+#include <linux/workqueue.h>
+#include <linux/version.h>
+
+#include "stts22h.h"
+
+static const struct iio_chan_spec st_stts22h_channel[] = {
+	{
+		.type = IIO_TEMP,
+		.address = ST_STTS22H_TEMP_L_OUT_ADDR,
+		.modified = 1,
+		.channel2 = IIO_MOD_TEMP_AMBIENT,
+		.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) |
+				      BIT(IIO_CHAN_INFO_SCALE),
+		.info_mask_shared_by_all = BIT(IIO_CHAN_INFO_SAMP_FREQ),
+		.scan_index = 0,
+		.scan_type = {
+			.sign = 's',
+			.realbits = 16,
+			.storagebits = 16,
+			.endianness = IIO_LE,
+		},
+	},
+	IIO_CHAN_SOFT_TIMESTAMP(1),
+};
+static const unsigned long st_stts22h_available_scan_masks[] = { 0x1, 0x0 };
+
+static const struct st_stts22h_odr_table_entry {
+	u8 size;
+	struct st_stts22h_reg reg;
+	struct st_stts22h_odr odr_avl[ST_STTS22H_ODR_LIST_SIZE];
+} st_stts22h_odr_table = {
+	.size = ST_STTS22H_ODR_LIST_SIZE,
+	.reg = {
+		.addr = ST_STTS22H_CTRL_ADDR,
+		.mask = ST_STTS22H_AVG_MASK,
+	},
+	.odr_avl[0] = {  25, 0x00 },
+	.odr_avl[1] = {  50, 0x01 },
+	.odr_avl[2] = { 100, 0x02 },
+	.odr_avl[3] = { 200, 0x03 },
+};
+
+static int st_stts22h_read(struct device *dev, u8 addr, int len, u8 *data)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct i2c_msg msg[2];
+
+	msg[0].addr = client->addr;
+	msg[0].flags = client->flags;
+	msg[0].len = 1;
+	msg[0].buf = &addr;
+
+	msg[1].addr = client->addr;
+	msg[1].flags = client->flags | I2C_M_RD;
+	msg[1].len = len;
+	msg[1].buf = data;
+
+	return i2c_transfer(client->adapter, msg, 2);
+}
+
+static int st_stts22h_write(struct device *dev, u8 addr, int len,
+			    const u8 *data)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct i2c_msg msg;
+	u8 send[4];
+
+	if (len > ARRAY_SIZE(send))
+		return -ENOMEM;
+
+	send[0] = addr;
+	memcpy(&send[1], data, len * sizeof(u8));
+
+	msg.addr = client->addr;
+	msg.flags = client->flags;
+	msg.len = len + 1;
+	msg.buf = send;
+
+	return i2c_transfer(client->adapter, &msg, 1);
+}
+
+static inline int st_stts22h_write_with_mask(struct st_stts22h_data *data,
+					     u8 addr, u8 mask, u8 val)
+{
+	int err;
+	u8 read;
+
+	mutex_lock(&data->lock);
+	err = st_stts22h_read(data->dev, addr, sizeof(read), &read);
+	if (err < 0) {
+		dev_err(data->dev, "failed to read %02x register\n", addr);
+		goto out;
+	}
+
+	read = (read & ~mask) | ((val << __ffs(mask)) & mask);
+
+	err = st_stts22h_write(data->dev, addr, sizeof(read), &read);
+	if (err < 0)
+		dev_err(data->dev, "failed to write %02x register\n", addr);
+
+out:
+	mutex_unlock(&data->lock);
+
+	return err;
+}
+
+static __maybe_unused int st_stts22h_reg_access(struct iio_dev *iio_dev,
+						unsigned int reg,
+						unsigned int writeval,
+						unsigned int *readval)
+{
+	struct st_stts22h_data *data = iio_priv(iio_dev);
+	int err;
+
+	err = iio_device_claim_direct_mode(iio_dev);
+	if (err)
+		return err;
+
+	mutex_lock(&data->lock);
+	if (readval == NULL)
+		err = st_stts22h_write(data->dev, reg, 1, (u8 *)&writeval);
+	else
+		err = st_stts22h_read(data->dev, reg, 1, (u8 *)readval);
+	mutex_unlock(&data->lock);
+
+	iio_device_release_direct_mode(iio_dev);
+
+	return (err < 0) ? err : 0;
+}
+
+static inline void st_stts22h_flush_works(struct st_stts22h_data *data)
+{
+	flush_workqueue(data->st_stts22h_workqueue);
+}
+
+static int st_stts22h_allocate_workqueue(struct st_stts22h_data *data)
+{
+	if (!data->st_stts22h_workqueue)
+		data->st_stts22h_workqueue =
+					create_workqueue(data->iio_devs->name);
+
+	if (!data->st_stts22h_workqueue)
+		return -ENOMEM;
+
+	return 0;
+}
+
+static inline s64 st_stts22h_get_time_ns(struct st_stts22h_data *data)
+{
+	return iio_get_time_ns(data->iio_devs);
+}
+
+static ssize_t
+st_stts22h_sysfs_sampling_frequency_avail(struct device *dev,
+					  struct device_attribute *attr,
+					  char *buf)
+{
+	int i, len = 0;
+
+	for (i = 0; i < st_stts22h_odr_table.size; i++) {
+		if (!st_stts22h_odr_table.odr_avl[i].hz)
+			continue;
+
+		len += scnprintf(buf + len, PAGE_SIZE - len, "%d ",
+				 st_stts22h_odr_table.odr_avl[i].hz);
+	}
+
+	buf[len - 1] = '\n';
+
+	return len;
+}
+
+static int st_stts22h_get_odr_val(struct st_stts22h_data *data, int val,
+				  u8 *odr)
+{
+	int i;
+
+	for (i = 0; i < st_stts22h_odr_table.size; i++) {
+		if (st_stts22h_odr_table.odr_avl[i].hz >= val)
+			break;
+	}
+
+	if (i == st_stts22h_odr_table.size)
+		return -EINVAL;
+
+	*odr = st_stts22h_odr_table.odr_avl[i].hz;
+
+	return i;
+}
+
+static int st_stts22h_set_odr(struct st_stts22h_data *data, u8 req_odr)
+{
+	int err, i;
+
+	for (i = 0; i < st_stts22h_odr_table.size; i++) {
+		if (st_stts22h_odr_table.odr_avl[i].hz >= req_odr)
+			break;
+	}
+
+	if (i == st_stts22h_odr_table.size)
+		return -EINVAL;
+
+	err = st_stts22h_write_with_mask(data, st_stts22h_odr_table.reg.addr,
+					 st_stts22h_odr_table.reg.mask,
+					 st_stts22h_odr_table.odr_avl[i].val);
+
+	return err < 0 ? err : 0;
+}
+
+static int st_stts22h_sensor_set_enable(struct st_stts22h_data *data, bool en)
+{
+	u8 odr = en ? data->odr : 0;
+	int64_t newTime;
+	int err;
+
+	err = st_stts22h_set_odr(data, odr);
+	if (err < 0)
+		return err;
+
+	err = st_stts22h_write_with_mask(data,
+					 ST_STTS22H_CTRL_ADDR,
+					 ST_STTS22H_FREERUN_MASK,
+					 en);
+	if (err < 0)
+		return err;
+
+	if (en) {
+		newTime = HZ_TO_PERIOD_NSEC(odr);
+		data->sensorktime = ktime_set(0, newTime);
+		hrtimer_start(&data->hr_timer, data->sensorktime,
+			      HRTIMER_MODE_REL);
+
+	} else {
+		cancel_work_sync(&data->iio_work);
+		hrtimer_cancel(&data->hr_timer);
+	}
+
+	data->enable = en;
+
+	return 0;
+}
+
+static int st_stts22h_read_oneshot(struct st_stts22h_data *data,
+				   u8 addr, int *val)
+{
+	int err, delay;
+	__le16 temp;
+
+	err = st_stts22h_sensor_set_enable(data, true);
+	if (err < 0)
+		return err;
+
+	delay = 2 * (1000000 / data->odr);
+	usleep_range(delay, 2 * delay);
+
+	err = st_stts22h_read(data->dev, addr, sizeof(temp), (u8 *)&temp);
+	if (err < 0)
+		return err;
+
+	st_stts22h_sensor_set_enable(data, false);
+
+	*val = (s16)le16_to_cpu(temp);
+
+	return IIO_VAL_INT;
+}
+
+static int st_stts22h_read_raw(struct iio_dev *iio_dev,
+			       struct iio_chan_spec const *ch,
+			       int *val, int *val2, long mask)
+{
+	struct st_stts22h_data *data = iio_priv(iio_dev);
+	int err;
+
+	switch (mask) {
+	case IIO_CHAN_INFO_RAW:
+		err = iio_device_claim_direct_mode(iio_dev);
+		if (err)
+			return err;
+
+		err = st_stts22h_read_oneshot(data, ch->address, val);
+		iio_device_release_direct_mode(iio_dev);
+		break;
+	case IIO_CHAN_INFO_SAMP_FREQ:
+		*val = (int)data->odr;
+		err = IIO_VAL_INT;
+		break;
+	case IIO_CHAN_INFO_SCALE:
+		*val = 1000;
+		*val2 = ST_STTS22H_GAIN;
+		err = IIO_VAL_FRACTIONAL;
+		break;
+	default:
+		err = -EINVAL;
+		break;
+	}
+
+	return err;
+}
+
+static int st_stts22h_write_raw(struct iio_dev *iio_dev,
+				struct iio_chan_spec const *chan,
+				int val, int val2, long mask)
+{
+	int err = -EINVAL;
+
+	if (mask == IIO_CHAN_INFO_SAMP_FREQ) {
+		struct st_stts22h_data *data = iio_priv(iio_dev);
+		u8 odr;
+
+
+		err = st_stts22h_get_odr_val(data, val, &odr);
+		if (err < 0)
+			return err;
+
+		err = iio_device_claim_direct_mode(iio_dev);
+		if (err)
+			return err;
+
+		data->odr = odr;
+		iio_device_release_direct_mode(iio_dev);
+	}
+
+	return err < 0 ? err : 0;
+}
+
+static IIO_DEV_ATTR_SAMP_FREQ_AVAIL(st_stts22h_sysfs_sampling_frequency_avail);
+static struct attribute *st_stts22h_attributes[] = {
+	&iio_dev_attr_sampling_frequency_available.dev_attr.attr,
+	NULL,
+};
+
+static const struct attribute_group st_stts22h_attribute_group = {
+	.attrs = st_stts22h_attributes,
+};
+
+static const struct iio_info st_stts22h_info = {
+	.attrs = &st_stts22h_attribute_group,
+	.read_raw = st_stts22h_read_raw,
+	.write_raw = st_stts22h_write_raw,
+
+#ifdef CONFIG_DEBUG_FS
+	.debugfs_reg_access = &st_stts22h_reg_access,
+#endif /* CONFIG_DEBUG_FS */
+};
+
+static int st_stts22h_check_whoami(struct st_stts22h_data *data)
+{
+	int err;
+	u8 wai;
+
+	err = st_stts22h_read(data->dev, ST_STTS22H_WHOAMI_ADDR, 1, &wai);
+	if (err < 0)
+		return err;
+
+	if (wai != ST_STTS22H_WHOAMI_VAL) {
+		dev_err(data->dev, "unsupported whoami [%02x]\n", wai);
+
+		return -ENODEV;
+	}
+
+	return 0;
+}
+
+static int st_stts22h_init(struct st_stts22h_data *data)
+{
+	int err;
+
+	/* reset cycle */
+	err = st_stts22h_write_with_mask(data, ST_STTS22H_CTRL_ADDR,
+					 ST_STTS22H_SW_RESET_MASK, 1);
+	if (err < 0)
+		return err;
+
+	err = st_stts22h_write_with_mask(data, ST_STTS22H_CTRL_ADDR,
+					 ST_STTS22H_SW_RESET_MASK, 0);
+	if (err < 0)
+		return err;
+
+	/* enable bdu */
+	err = st_stts22h_write_with_mask(data, ST_STTS22H_CTRL_ADDR,
+					 ST_STTS22H_BDU_MASK, 1);
+	if (err < 0)
+		return err;
+
+	/* enable register auto increments */
+	err = st_stts22h_write_with_mask(data, ST_STTS22H_CTRL_ADDR,
+					 ST_STTS22H_IF_ADD_INC_MASK, 1);
+
+	return err < 0 ? err : 0;
+}
+
+static
+enum hrtimer_restart st_stts22h_poll_function_read(struct hrtimer *timer)
+{
+	struct st_stts22h_data *data;
+
+	data = container_of((struct hrtimer *)timer,
+			    struct st_stts22h_data, hr_timer);
+
+	data->timestamp = st_stts22h_get_time_ns(data);
+	queue_work(data->st_stts22h_workqueue, &data->iio_work);
+
+	return HRTIMER_NORESTART;
+}
+
+static void st_stts22h_report_event(struct st_stts22h_data *data, u8 *tmp)
+{
+	struct iio_dev *iio_dev = data->iio_devs;
+	u8 iio_buf[ALIGN(ST_STTS22H_SAMPLE_SIZE, sizeof(s64)) + sizeof(s64)];
+
+	memcpy(iio_buf, tmp, ST_STTS22H_SAMPLE_SIZE);
+	iio_push_to_buffers_with_timestamp(iio_dev, iio_buf, data->timestamp);
+}
+
+static void st_stts22h_poll_function_work(struct work_struct *iio_work)
+{
+	struct st_stts22h_data *data;
+	ktime_t tmpkt, ktdelta;
+	__le16 temp;
+
+	data = container_of((struct work_struct *)iio_work,
+			     struct st_stts22h_data, iio_work);
+
+	/* adjust new timeout */
+	ktdelta = ktime_set(0, (st_stts22h_get_time_ns(data) -
+				data->timestamp));
+
+	/* avoid negative value in case of high ODRs */
+	if (ktime_after(data->sensorktime, ktdelta))
+		tmpkt = ktime_sub(data->sensorktime, ktdelta);
+	else
+		tmpkt = data->sensorktime;
+
+	hrtimer_start(&data->hr_timer, tmpkt, HRTIMER_MODE_REL);
+
+	st_stts22h_read(data->dev, ST_STTS22H_TEMP_L_OUT_ADDR,
+			sizeof(temp), (u8 *)&temp);
+	st_stts22h_report_event(data, (u8 *)&temp);
+}
+
+static int st_stts22h_preenable(struct iio_dev *iio_dev)
+{
+	struct st_stts22h_data *data = iio_priv(iio_dev);
+
+	return st_stts22h_sensor_set_enable(data, true);
+}
+
+static int st_stts22h_postdisable(struct iio_dev *iio_dev)
+{
+	struct st_stts22h_data *data = iio_priv(iio_dev);
+
+	return st_stts22h_sensor_set_enable(data, false);
+}
+
+static const struct iio_buffer_setup_ops st_stts22h_buffer_ops = {
+	.preenable = st_stts22h_preenable,
+	.postdisable = st_stts22h_postdisable,
+};
+
+static int st_stts22h_probe(struct i2c_client *client,
+			    const struct i2c_device_id *id)
+{
+	struct st_stts22h_data *data;
+#if KERNEL_VERSION(5, 13, 0) > LINUX_VERSION_CODE
+	struct iio_buffer *buffer;
+#endif /* LINUX_VERSION_CODE */
+	struct iio_dev *iio_dev;
+	struct device *dev;
+	int err;
+
+	iio_dev = devm_iio_device_alloc(&client->dev, sizeof(*data));
+	if (!iio_dev)
+		return -ENOMEM;
+
+	data = iio_priv(iio_dev);
+	i2c_set_clientdata(client, iio_dev);
+
+	dev = &client->dev;
+	data->dev = dev;
+	dev_set_drvdata(dev, (void *)data);
+
+	mutex_init(&data->lock);
+	err = st_stts22h_check_whoami(data);
+	if (err < 0)
+		return err;
+
+	err = st_stts22h_init(data);
+	if (err < 0)
+		return err;
+
+	iio_dev->name = client->name;
+	iio_dev->dev.parent = &client->dev;
+	iio_dev->modes = INDIO_DIRECT_MODE;
+	iio_dev->info = &st_stts22h_info;
+	iio_dev->channels = st_stts22h_channel;
+	iio_dev->num_channels = ARRAY_SIZE(st_stts22h_channel);
+	iio_dev->available_scan_masks = st_stts22h_available_scan_masks;
+	data->iio_devs = iio_dev;
+
+	/* configure hrtimer */
+	data->odr = st_stts22h_odr_table.odr_avl[0].hz;
+	data->enable = false;
+	hrtimer_init(&data->hr_timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
+	data->hr_timer.function = &st_stts22h_poll_function_read;
+	data->sensorktime = ktime_set(0, HZ_TO_PERIOD_NSEC(data->odr));
+	INIT_WORK(&data->iio_work, st_stts22h_poll_function_work);
+
+	err = st_stts22h_allocate_workqueue(data);
+	if (err < 0)
+		return err;
+
+#if KERNEL_VERSION(5, 19, 0) <= LINUX_VERSION_CODE
+	err = devm_iio_kfifo_buffer_setup(data->dev, data->iio_devs,
+					  &st_stts22h_buffer_ops);
+	if (err)
+		return err;
+#elif KERNEL_VERSION(5, 13, 0) <= LINUX_VERSION_CODE
+	err = devm_iio_kfifo_buffer_setup(data->dev, data->iio_devs,
+					  INDIO_BUFFER_SOFTWARE,
+					  &st_stts22h_buffer_ops);
+	if (err)
+		return err;
+#else /* LINUX_VERSION_CODE */
+	buffer = devm_iio_kfifo_allocate(data->dev);
+	if (!buffer)
+		return -ENOMEM;
+
+	iio_device_attach_buffer(data->iio_devs, buffer);
+	data->iio_devs->modes |= INDIO_BUFFER_SOFTWARE;
+	data->iio_devs->setup_ops = &st_stts22h_buffer_ops;
+#endif /* LINUX_VERSION_CODE */
+
+	return devm_iio_device_register(data->dev, data->iio_devs);
+}
+
+#if KERNEL_VERSION(5, 18, 0) <= LINUX_VERSION_CODE
+static void st_stts22h_remove(struct i2c_client *client)
+{
+	struct st_stts22h_data *data = dev_get_drvdata(&client->dev);
+
+	if (data->enable)
+		st_stts22h_sensor_set_enable(data, false);
+
+	st_stts22h_flush_works(data);
+	destroy_workqueue(data->st_stts22h_workqueue);
+	data->st_stts22h_workqueue = NULL;
+}
+#else /* LINUX_VERSION_CODE */
+static int st_stts22h_remove(struct i2c_client *client)
+{
+	struct st_stts22h_data *data = dev_get_drvdata(&client->dev);
+	int err = 0;
+
+	if (data->enable)
+		err = st_stts22h_sensor_set_enable(data, false);
+
+	st_stts22h_flush_works(data);
+	destroy_workqueue(data->st_stts22h_workqueue);
+	data->st_stts22h_workqueue = NULL;
+
+	return err;
+}
+#endif /* LINUX_VERSION_CODE */
+
+static int __maybe_unused st_stts22h_suspend(struct device *dev)
+{
+	struct st_stts22h_data *data = dev_get_drvdata(dev);
+	int err = 0;
+
+	if (data->enable)
+		err = st_stts22h_sensor_set_enable(data, false);
+
+	return err;
+}
+
+static int __maybe_unused st_stts22h_resume(struct device *dev)
+{
+	struct st_stts22h_data *data = dev_get_drvdata(dev);
+	int err = 0;
+
+	if (data->enable)
+		err = st_stts22h_sensor_set_enable(data, true);
+
+	return err;
+}
+
+#ifdef CONFIG_PM
+const struct dev_pm_ops st_stts22h_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(st_stts22h_suspend, st_stts22h_resume)
+};
+#endif /* CONFIG_PM */
+
+static const struct of_device_id st_stts22h_of_match[] = {
+	{
+		.compatible = "st,stts22h",
+	},
+	{},
+};
+MODULE_DEVICE_TABLE(of, st_stts22h_of_match);
+
+static const struct i2c_device_id st_stts22h_id_table[] = {
+	{ ST_STTS22H_DEV_NAME },
+	{},
+};
+MODULE_DEVICE_TABLE(i2c, st_stts22h_id_table);
+
+static struct i2c_driver st_stts22h_driver = {
+	.driver = {
+		.name = "st_stts22h_i2c",
+#ifdef CONFIG_PM
+		.pm = &st_stts22h_pm_ops,
+#endif /* CONFIG_PM */
+		.of_match_table = of_match_ptr(st_stts22h_of_match),
+	},
+	.probe = st_stts22h_probe,
+	.remove = st_stts22h_remove,
+	.id_table = st_stts22h_id_table,
+};
+module_i2c_driver(st_stts22h_driver);
+
+MODULE_AUTHOR("MEMS Software Solutions Team");
+MODULE_DESCRIPTION("stts22h ST MEMS temperature sensor driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/iio/stm/temperature/stts22h.h b/drivers/iio/stm/temperature/stts22h.h
new file mode 100644
index 000000000..8abdf3685
--- /dev/null
+++ b/drivers/iio/stm/temperature/stts22h.h
@@ -0,0 +1,104 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * STMicroelectronics stts22h temperature driver
+ *
+ * MEMS Software Solutions Team
+ *
+ * Copyright 2021 STMicroelectronics Inc.
+ */
+
+#ifndef ST_STTS22H_H
+#define ST_STTS22H_H
+
+#include <linux/bitops.h>
+#include <linux/device.h>
+#include <linux/err.h>
+
+#define ST_STTS22H_DEV_NAME				"stts22h"
+
+#define ST_STTS22H_WHOAMI_ADDR				0x01
+#define ST_STTS22H_WHOAMI_VAL				0xa0
+
+#define ST_STTS22H_TEMP_H_LIMIT_ADDR			0x02
+#define ST_STTS22H_TEMP_L_LIMIT_ADDR			0x03
+
+#define ST_STTS22H_CTRL_ADDR				0x04
+#define ST_STTS22H_LOW_ODR_START_MASK			BIT(7)
+#define ST_STTS22H_BDU_MASK				BIT(6)
+#define ST_STTS22H_AVG_MASK				GENMASK(5, 4)
+#define ST_STTS22H_IF_ADD_INC_MASK			BIT(3)
+#define ST_STTS22H_FREERUN_MASK				BIT(2)
+#define ST_STTS22H_TIME_OUT_DIS_MASK			BIT(1)
+#define ST_STTS22H_ONE_SHOT_MASK			BIT(0)
+
+#define ST_STTS22H_STATUS_ADDR				0x05
+#define ST_STTS22H_UNDER_THL_MASK			BIT(2)
+#define ST_STTS22H_OVER_THH_MASK			BIT(1)
+#define ST_STTS22H_BUSY_MASK				BIT(0)
+
+#define ST_STTS22H_TEMP_L_OUT_ADDR			0x06
+
+#define ST_STTS22H_SOFTWARE_RESET_ADDR			0x0c
+#define ST_STTS22H_LOW_ODR_ENABLE_MASK			BIT(6)
+#define ST_STTS22H_SW_RESET_MASK			BIT(1)
+
+#define ST_STTS22H_ODR_LIST_SIZE			4
+#define ST_STTS22H_GAIN					100
+#define ST_STTS22H_SAMPLE_SIZE				sizeof(s16)
+
+#define HZ_TO_PERIOD_NSEC(hz)				(1000000000 / \
+							 ((u32)(hz)))
+
+
+/**
+ * struct st_stts22h_reg - Sensor data register and mask
+ *
+ * @addr: Register address.
+ * @mask: Bit mask.
+ */
+struct st_stts22h_reg {
+	u8 addr;
+	u8 mask;
+};
+
+/**
+ * struct st_stts22h_odr - Sensor data odr entry
+ *
+ * @hz: Sensor ODR.
+ * @val: Register value.
+ */
+struct st_stts22h_odr {
+	u8 hz;
+	u8 val;
+};
+
+/**
+ * struct st_stts22h_data - Sensor data instance
+ *
+ * @st_stts22h_workqueue: Temperature workqueue.
+ * @iio_work: Work to schedule temperature read function.
+ * @iio_devs: Linux Device.
+ * @hr_timer: Timer to schedule workeueue.
+ * @sensorktime: Sensor schedule timeout.
+ * @dev: I2C client device.
+ * @mutex: Mutex lock to access to device registers.
+ * @timestamp: Sensor timestamp.
+ * @enable: Enable sensor flag.
+ * @irq: Interrupt number (TODO).
+ * @odr: Sensor ODR.
+ */
+struct st_stts22h_data {
+	struct workqueue_struct *st_stts22h_workqueue;
+	struct work_struct iio_work;
+	struct iio_dev *iio_devs;
+	struct hrtimer hr_timer;
+	ktime_t sensorktime;
+	struct device *dev;
+	struct mutex lock;
+	s64 timestamp;
+	bool enable;
+	int irq;
+	u8 odr;
+};
+
+#endif /* ST_STTS22H_H */
-- 
2.25.1

