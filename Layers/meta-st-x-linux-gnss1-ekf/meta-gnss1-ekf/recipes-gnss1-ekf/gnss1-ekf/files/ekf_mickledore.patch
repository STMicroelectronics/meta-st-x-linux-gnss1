diff --git a/CMakeLists.txt b/CMakeLists.txt
index 8eb7e37..ec033d9 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -4,6 +4,12 @@ cmake_minimum_required(VERSION 2.8)
 #set(GCC_COMPILATION_FLAGS "-DLINUX")
 #set(CMAKE_CXX_FLAGS  "${GCC_COMPILATION_FLAGS}")
 
+set(CMAKE_SKIP_BUILD_RPATH TRUE)
+set(CMAKE_BUILD_WITH_INSTALL_RPATH FALSE)
+set(CMAKE_INSTALL_RPATH_USE_LINK_PATH FALSE)
+
+set(CMAKE_CXX_STANDARD 17)
+
 set(
     CMAKE_RUNTIME_OUTPUT_DIRECTORY
     ${CMAKE_HOME_DIRECTORY}/bin
@@ -14,7 +20,8 @@ set(
     ${CMAKE_HOME_DIRECTORY}/lib
     )
 
-set(CMAKE_MODULE_PATH "${CMAKE_HOME_DIRECTORY}/modules")
+#set(CMAKE_MODULE_PATH "${CMAKE_HOME_DIRECTORY}/modules")
+set(CMAKE_MODULE_PATH "${WORKDIR}/recipe-sysroot/usr/share/eigen3/cmake/")
 
 list(APPEND CMAKE_MODULE_PATH "${CMAKE_CURRENT_LIST_DIR}/cmake")
 find_package(Eigen3 REQUIRED)
@@ -22,7 +29,7 @@ include_directories(${EIGEN3_INCLUDE_DIR})
 message("${CMAKE_MODULE_PATH}")
 message("${EIGEN3_INCLUDE_DIR}")
 
-find_package(Boost 1.40 COMPONENTS system REQUIRED)
+#find_package(Boost 1.40 COMPONENTS system REQUIRED)
 
 link_directories(
     /usr/local/lib
@@ -34,10 +41,9 @@ link_directories(
 include_directories(
     /usr/include/
     ${CMAKE_HOME_DIRECTORY}/ekf_nav_ins/inc
-    ${CMAKE_HOME_DIRECTORY}/Ublox_Linux_Library/inc
-    ${CMAKE_HOME_DIRECTORY}/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/src
+    ${CMAKE_HOME_DIRECTORY}/EKF_Linux_Library/inc
+    ${CMAKE_HOME_DIRECTORY}/EKF_Linux_Library/EKF_GNSS_Library/src
     )
 
-add_subdirectory(Ublox_Linux_Library/linux_build)
+add_subdirectory(EKF_Linux_Library/linux_build)
 add_subdirectory(ekf_nav_ins)
-add_subdirectory(ekf_test)
diff --git a/EKF_Linux_Library/EKF_GNSS_Library/.gitattributes b/EKF_Linux_Library/EKF_GNSS_Library/.gitattributes
new file mode 100644
index 0000000..dfe0770
--- /dev/null
+++ b/EKF_Linux_Library/EKF_GNSS_Library/.gitattributes
@@ -0,0 +1,2 @@
+# Auto detect text files and perform LF normalization
+* text=auto
diff --git a/EKF_Linux_Library/EKF_GNSS_Library/.gitignore b/EKF_Linux_Library/EKF_GNSS_Library/.gitignore
new file mode 100644
index 0000000..58b4bef
--- /dev/null
+++ b/EKF_Linux_Library/EKF_GNSS_Library/.gitignore
@@ -0,0 +1,58 @@
+# Visual Studio Code files
+.vscode
+
+# Windows image file caches
+Thumbs.db
+ehthumbs.db
+
+# Folder config file
+Desktop.ini
+
+# Recycle Bin used on file shares
+$RECYCLE.BIN/
+
+# Windows Installer files
+*.cab
+*.msi
+*.msm
+*.msp
+
+# Windows shortcuts
+*.lnk
+
+# =========================
+# Operating System Files
+# =========================
+
+# OSX
+# =========================
+
+.DS_Store
+.AppleDouble
+.LSOverride
+
+# Thumbnails
+._*
+
+# Files that might appear in the root of a volume
+.DocumentRevisions-V100
+.fseventsd
+.Spotlight-V100
+.TemporaryItems
+.Trashes
+.VolumeIcon.icns
+
+# Directories potentially created on remote AFP share
+.AppleDB
+.AppleDesktop
+Network Trash Folder
+Temporary Items
+.apdisk
+
+# VIM backup files
+*~
+[._]*.un~
+*.swp
+
+# Zephyr build files
+examples/Zephyr/*/build/*
\ No newline at end of file
diff --git a/EKF_Linux_Library/EKF_GNSS_Library/src/EKF_GNSS_MPU157F_dk2_Library.cpp b/EKF_Linux_Library/EKF_GNSS_Library/src/EKF_GNSS_MPU157F_dk2_Library.cpp
new file mode 100644
index 0000000..de27c29
--- /dev/null
+++ b/EKF_Linux_Library/EKF_GNSS_Library/src/EKF_GNSS_MPU157F_dk2_Library.cpp
@@ -0,0 +1,1271 @@
+/*
+*) Refactor the code to remove reduentent part. 
+*) Compiled for Linux with C++14 standard
+Copyright (c) 2021 Balamurugan Kandan.
+MIT License; See LICENSE.md for complete details
+Author: 2021 Balamurugan Kandan
+*/
+
+/*
+Updated to be a class, use Eigen, and compile as an Arduino library.
+Added methods to get gyro and accel bias. Added initialization to
+estimated angles rather than assuming IMU is level.
+
+Copyright (c) 2016 - 2019 Regents of the University of Minnesota and Bolder Flight Systems Inc.
+MIT License; See LICENSE.md for complete details
+Author: Brian Taylor
+*/
+
+/*
+Addapted from earlier version
+Copyright 2011 Regents of the University of Minnesota. All rights reserved.
+Original Author: Adhika Lie
+*/
+
+#include "EKF_GNSS_MPU157F_dk2_Library.h"
+#include "EKF_GNSS_msg.h"
+#include <stdio.h>
+#include <string.h>
+#include <termios.h>
+#include <unistd.h>
+#include "errno.h"
+
+static GPRMC_msg_t GPRMC_msg;
+char * strtok_single (char * str, char const * delims);
+char *strtok_single_ast (char * str, char const * delims);
+
+volatile int last_msg_index;
+volatile int fields_left;
+int valid_token=0;
+int use_mpvraw=0;
+
+GPRMC_msg_t GPRMC_msg_g;
+GPGGA_msg_t GPGGA_msg_g;
+GPVTG_msg_t GPVTG_msg_g;
+GNGSA_msg_t GNGSA_msg_g;
+GPGLL_msg_t GPGLL_msg_g;
+
+GNRMC_msg_t GNRMC_msg_g;
+GNGGA_msg_t GNGGA_msg_g;
+//GNVTG_msg_t GNVTG_msg_g;
+
+PSTMCPU_msg_t PSTMCPU_msg_g;
+PSTMPV_msg_t PSTMPV_msg_g;
+PSTMPVRAW_msg_t PSTMPVRAW_msg_g;
+
+
+fdlist_imus g_imufds;
+
+volatile ST_IMU_SensorData_t g_imudata;
+
+void clearerr_all(){
+//printf("E:%s\n",__func__);
+#if 0
+   rewind(g_imufds.gyro_x_fd);
+   rewind(g_imufds.gyro_y_fd);
+   rewind(g_imufds.gyro_z_fd);
+
+   rewind(g_imufds.gyro_xscale_fd);
+   rewind(g_imufds.gyro_yscale_fd);
+   rewind(g_imufds.gyro_zscale_fd);
+
+    /*sysfs FILE fd for accelerometer*/
+    rewind(g_imufds.accel_x_fd);
+    rewind(g_imufds.accel_y_fd);
+    rewind(g_imufds.accel_z_fd);
+
+    rewind(g_imufds.accel_xscale_fd);
+    rewind(g_imufds.accel_yscale_fd);
+    rewind(g_imufds.accel_zscale_fd);
+
+    /*sysfs FILE fd for magnetometer*/
+    rewind(g_imufds.magn_x_fd);
+    rewind(g_imufds.magn_y_fd);
+    rewind(g_imufds.magn_z_fd);
+
+    rewind(g_imufds.magn_xscale_fd);
+    rewind(g_imufds.magn_yscale_fd);
+    rewind(g_imufds.magn_zscale_fd);
+
+
+    /*SYSFS FILE FD for gyro*/
+   clearerr(g_imufds.gyro_x_fd);
+   clearerr(g_imufds.gyro_y_fd);
+   clearerr(g_imufds.gyro_z_fd);
+
+   clearerr(g_imufds.gyro_xscale_fd);
+   clearerr(g_imufds.gyro_yscale_fd);
+   clearerr(g_imufds.gyro_zscale_fd);
+
+    /*sysfs FILE fd for accelerometer*/
+    clearerr(g_imufds.accel_x_fd);
+    clearerr(g_imufds.accel_y_fd);
+    clearerr(g_imufds.accel_z_fd);
+
+    clearerr(g_imufds.accel_xscale_fd);
+    clearerr(g_imufds.accel_yscale_fd);
+    clearerr(g_imufds.accel_zscale_fd);
+
+    /*sysfs FILE fd for magnetometer*/
+    clearerr(g_imufds.magn_x_fd);
+    clearerr(g_imufds.magn_y_fd);
+    clearerr(g_imufds.magn_z_fd);
+
+    clearerr(g_imufds.magn_xscale_fd);
+    clearerr(g_imufds.magn_yscale_fd);
+    clearerr(g_imufds.magn_zscale_fd);
+#endif
+   fclose(g_imufds.gyro_x_fd);
+   fclose(g_imufds.gyro_y_fd);
+   fclose(g_imufds.gyro_z_fd);
+
+   fclose(g_imufds.gyro_xscale_fd);
+ //  fclose(g_imufds.gyro_yscale_fd);
+  // fclose(g_imufds.gyro_zscale_fd);
+
+    /*sysfs FILE fd for accelerometer*/
+    fclose(g_imufds.accel_x_fd);
+    fclose(g_imufds.accel_y_fd);
+    fclose(g_imufds.accel_z_fd);
+
+    fclose(g_imufds.accel_xscale_fd);
+  //  fclose(g_imufds.accel_yscale_fd);
+//    fclose(g_imufds.accel_zscale_fd);
+
+    /*sysfs FILE fd for magnetometer*/
+    fclose(g_imufds.magn_x_fd);
+    fclose(g_imufds.magn_y_fd);
+    fclose(g_imufds.magn_z_fd);
+
+    fclose(g_imufds.magn_xscale_fd);
+    fclose(g_imufds.magn_yscale_fd);
+    fclose(g_imufds.magn_zscale_fd);
+
+
+    initGyro(g_imufds.gyro_path);
+    initMagn(g_imufds.magn_path);
+    initAccel(g_imufds.accel_path);
+//    printf("X:%s\n",__func__);
+    return;
+}
+
+#pragma GCC push_options
+#pragma GCC optimize ("O0")
+void print_fd(){
+	printf("g_imufds.gyro_x_fd:0x%x,y:0x%x,z:0x%x\n",
+			g_imufds.gyro_x_fd,
+			g_imufds.gyro_y_fd,
+			g_imufds.gyro_z_fd);
+
+	printf("g_imufds.accel_x_fd:0x%x,y:0x%x,z:0x%x\n",
+			g_imufds.accel_x_fd,
+			g_imufds.accel_y_fd,
+			g_imufds.accel_z_fd);
+
+
+	printf("g_imufds.magn_x_fd:0x%x,y:0x%x,z:0x%x\n",
+			g_imufds.magn_x_fd,
+			g_imufds.magn_y_fd,
+			g_imufds.magn_z_fd);
+
+
+}
+
+void getIMUData(){
+
+   volatile  float data=0;
+    volatile float scale_data=0;
+
+    char data_read_accel[25];
+    char data_read_magn[25];
+    char data_read_gyro[25];
+    char data_read[25];
+   
+/*Accel Data*/
+    fgets(data_read_accel, 20, g_imufds.accel_x_fd );
+    data = atof(data_read_accel);
+    debug_imu("accelx:%f, ",data);
+    fgets(data_read_accel, 20, g_imufds.accel_xscale_fd );
+    scale_data = atof(data_read_accel);
+    g_imudata.accel_x_data = data * scale_data * (-1);
+
+    fgets(data_read_accel, 20, g_imufds.accel_y_fd );
+    data = atof(data_read_accel);
+    debug_imu("accely:%f, ",data);
+    fgets(data_read_accel, 20, g_imufds.accel_yscale_fd );
+    scale_data = atof(data_read_accel);
+    debug_imu("accely scale:%f ",scale_data);
+    g_imudata.accel_y_data = data * scale_data * (-1);
+
+    fgets(data_read_accel, 20, g_imufds.accel_z_fd );
+    data = atof(data_read_accel);
+    debug_imu("accelz:%f , ",data);
+    fgets(data_read_accel, 20, g_imufds.accel_zscale_fd );
+    scale_data = atof(data_read_accel);
+    g_imudata.accel_z_data = data * scale_data;
+    debug_imu("accelz scale:%f \n",scale_data);
+
+
+/*Gyro Data*/
+   // printf("gyrox\n");
+    fgets(data_read, 20, g_imufds.gyro_x_fd );
+    data = atof(data_read);
+    fgets(data_read, 20, g_imufds.gyro_xscale_fd );
+    scale_data = atof(data_read);
+    debug_imu("gyrox:%f,",data);
+    debug_imu("gyrox scale:%f\n ",scale_data);
+
+    g_imudata.gyro_x_data = data * scale_data;
+
+    fgets(data_read, 20, g_imufds.gyro_y_fd );
+    data = atof(data_read);
+    fgets(data_read, 20, g_imufds.gyro_yscale_fd );
+    scale_data = atof(data_read);
+    debug_imu("gyroy:%f,",data);
+    debug_imu("gyroy scale:%f\n ",scale_data);
+
+    g_imudata.gyro_y_data = data * scale_data;
+
+    fgets(data_read, 20, g_imufds.gyro_z_fd);
+    data = atof(data_read);
+    fgets(data_read, 20, g_imufds.gyro_zscale_fd);
+    scale_data = atof(data_read);
+    debug_imu("gyroz:%f,",data);
+    debug_imu("gyroz scale:%f\n ",scale_data);
+
+    g_imudata.gyro_z_data = data * scale_data;
+
+    debug_imu("gyroz\n");
+
+#if 1
+/* MAGN Data */
+//    printf("magx\n");
+    fgets(data_read, 20, g_imufds.magn_x_fd);
+    data = atof(data_read);
+    fgets(data_read, 20, g_imufds.magn_xscale_fd);
+    scale_data = atof(data_read);
+    debug_imu("magx:%f,",data);
+    debug_imu("magx scale:%f ",scale_data);
+    //g_imudata.magn_x_data = data * scale_data;
+    g_imudata.magn_x_data = data * 1;
+
+    fgets(data_read, 20, g_imufds.magn_y_fd );
+    data = atof(data_read);
+    fgets(data_read, 20, g_imufds.magn_yscale_fd );
+    scale_data = atof(data_read);
+    debug_imu("magy:%f,",data);
+    debug_imu("magy scale:%f ",scale_data);
+    //g_imudata.magn_y_data = data * scale_data;
+    g_imudata.magn_y_data = data * 1;
+
+    fgets(data_read, 20, g_imufds.magn_z_fd );
+    data = atof(data_read);
+    fgets(data_read, 20, g_imufds.magn_zscale_fd );
+    scale_data = atof(data_read);
+    debug_imu("magz:%f,",data);
+    debug_imu("magz scale:%f\n ",scale_data);
+
+    //g_imudata.magn_z_data = data * scale_data;
+    g_imudata.magn_z_data = data * 1;
+//	printf("magnz\n");
+    clearerr_all();
+
+//    sleep(1);
+
+    //print_fd();
+    debug_imu("X:%s\n",__func__);
+#endif
+
+    return;
+}
+
+#pragma GCC pop_options
+
+
+char *temp_array=NULL;
+void init_st_imulib(){
+
+    temp_array = (char *)malloc(sizeof(char) * 100);
+    return;
+
+}
+void initAccel(char *dev_name){
+
+    snprintf(temp_array,100,"%s%s",dev_name,"in_accel_x_raw");
+    g_imufds.accel_x_fd = fopen(temp_array,"r");
+    if(g_imufds.accel_x_fd == NULL)
+	printf("\nunable to open:%s\n",temp_array);
+   // else{
+//	printf("open:%s succesfull\n",temp_array);
+   // }
+
+    snprintf(temp_array,100,"%s%s",dev_name,"in_accel_y_raw");
+    g_imufds.accel_y_fd = fopen(temp_array,"r");
+    if(g_imufds.accel_y_fd == NULL)
+	printf("\nunable to open:%s\n",temp_array);
+ //   else
+//	printf("open:%s succesfull\n",temp_array);
+
+    snprintf(temp_array,100,"%s%s",dev_name,"in_accel_z_raw");
+    g_imufds.accel_z_fd = fopen(temp_array,"r");
+    if(g_imufds.accel_z_fd == NULL)
+	printf("\nunable to open:%s\n",temp_array);
+    //else
+//	printf("open:%s succesfull\n",temp_array);
+
+
+#if 1
+    snprintf(temp_array,100,"%s%s",dev_name,"in_accel_scale");
+    g_imufds.accel_xscale_fd = fopen(temp_array,"r");
+    if(g_imufds.accel_xscale_fd == NULL)
+	printf("\nunable to open:%s\n",temp_array);
+
+    g_imufds.accel_yscale_fd = g_imufds.accel_xscale_fd;
+    g_imufds.accel_zscale_fd = g_imufds.accel_xscale_fd;
+#else
+    snprintf(temp_array,100,"%s%s",dev_name,"in_accel_x_scale");
+    g_imufds.accel_xscale_fd = fopen(temp_array,"r");
+    if(g_imufds.accel_xscale_fd == NULL)
+	printf("\nunable to open:%s\n",temp_array);
+ //   else
+//	printf("open:%s succesfull\n",temp_array);
+
+    snprintf(temp_array,100,"%s%s",dev_name,"in_accel_y_scale");
+    g_imufds.accel_yscale_fd = fopen(temp_array,"r");
+    if(g_imufds.accel_yscale_fd == NULL)
+	printf("\nunable to open:%s\n",temp_array);
+   // else
+//	printf("open:%s succesfull\n",temp_array);
+
+    snprintf(temp_array,100,"%s%s",dev_name,"in_accel_z_scale");
+    g_imufds.accel_zscale_fd = fopen(temp_array,"r");
+    if(g_imufds.accel_zscale_fd == NULL)
+	printf("\nunable to open:%s\n",temp_array);
+  //  else
+//	printf("open:%s succesfull\n",temp_array);
+#endif
+    return;
+}
+
+void initGyro(char *dev_name){
+    //printf("%s: %s\n",__func__,dev_name);
+    snprintf(temp_array,100,"%s%s",dev_name,"in_anglvel_x_raw");
+    g_imufds.gyro_x_fd = fopen(temp_array,"r");
+    if(g_imufds.gyro_x_fd == NULL)
+	printf("\nunable to open:%s\n",temp_array);
+//    else
+//	printf("open:%s succesfull\n",temp_array);
+
+    snprintf(temp_array,100,"%s%s",dev_name,"in_anglvel_y_raw");
+    g_imufds.gyro_y_fd = fopen(temp_array,"r");
+    if(g_imufds.gyro_y_fd == NULL)
+	printf("\nunable to open:%s\n",temp_array);
+  //  else
+//	printf("open:%s succesfull\n",temp_array);
+
+    snprintf(temp_array,100,"%s%s",dev_name,"in_anglvel_z_raw");
+    g_imufds.gyro_z_fd = fopen(temp_array,"r");
+    if(g_imufds.gyro_z_fd == NULL)
+	printf("\nunable to open:%s\n",temp_array);
+  //  else
+//	printf("open:%s succesfull\n",temp_array);
+
+#if 1 
+    snprintf(temp_array,100,"%s%s",dev_name,"in_anglvel_scale");
+    g_imufds.gyro_xscale_fd = fopen(temp_array,"r");
+    if(g_imufds.gyro_xscale_fd == NULL)
+	printf("\nunable to open:%s\n",temp_array);
+    g_imufds.gyro_yscale_fd = g_imufds.gyro_xscale_fd;
+    g_imufds.gyro_zscale_fd = g_imufds.gyro_xscale_fd;
+#else
+
+    snprintf(temp_array,100,"%s%s",dev_name,"in_anglvel_x_scale");
+    g_imufds.gyro_xscale_fd = fopen(temp_array,"r");
+    if(g_imufds.gyro_xscale_fd == NULL)
+	printf("\nunable to open:%s\n",temp_array);
+  //  else
+//	printf("open:%s succesfull\n",temp_array);
+
+    snprintf(temp_array,100,"%s%s",dev_name,"in_anglvel_y_scale");
+    g_imufds.gyro_yscale_fd = fopen(temp_array,"r");
+    if(g_imufds.gyro_yscale_fd == NULL)
+	printf("\nunable to open:%s\n",temp_array);
+  //  else
+//	printf("open:%s succesfull\n",temp_array);
+
+    snprintf(temp_array,100,"%s%s",dev_name,"in_anglvel_z_scale");
+    g_imufds.gyro_zscale_fd = fopen(temp_array,"r");
+    if(g_imufds.gyro_zscale_fd == NULL)
+	printf("\nunable to open:%s\n",temp_array);
+  //  else
+//	printf("open:%s succesfull\n",temp_array);
+#endif
+
+    return;
+}
+
+void initMagn(char *dev_name){
+
+    snprintf(temp_array,100,"%s%s",dev_name,"in_magn_x_raw");
+    g_imufds.magn_x_fd = fopen(temp_array,"r");
+    if(g_imufds.magn_x_fd == NULL)
+	printf("\nunable to open:%s\n",temp_array);
+  //  else
+//	printf("open:%s succesfull\n",temp_array);
+
+    snprintf(temp_array,100,"%s%s",dev_name,"in_magn_y_raw");
+    g_imufds.magn_y_fd = fopen(temp_array,"r");
+    if(g_imufds.magn_y_fd == NULL)
+	printf("\nunable to open:%s\n",temp_array);
+  //  else
+//	printf("open:%s succesfull\n",temp_array);
+
+    snprintf(temp_array,100,"%s%s",dev_name,"in_magn_z_raw\0");
+    g_imufds.magn_z_fd = fopen(temp_array,"r");
+    if(g_imufds.magn_z_fd == NULL){
+	printf("something went wrong withopen()! %s\n", strerror(errno));
+	printf("\nunable to open magn node:%s\n",temp_array);
+	}
+  //  else
+//	printf("open:%s succesfull\n",temp_array);
+
+
+    snprintf(temp_array,100,"%s%s",dev_name,"in_magn_x_scale");
+    g_imufds.magn_xscale_fd = fopen(temp_array,"r");
+    if(g_imufds.magn_xscale_fd == NULL)
+	printf("\nunable to open:%s\n",temp_array);
+  //  else
+//	printf("open:%s succesfull\n",temp_array);
+
+    snprintf(temp_array,100,"%s%s",dev_name,"in_magn_y_scale");
+    g_imufds.magn_yscale_fd = fopen(temp_array,"r");
+    if(g_imufds.magn_yscale_fd == NULL)
+	printf("\nunable to open:%s\n",temp_array);
+  //  else
+//	printf("open:%s succesfull\n",temp_array);
+
+    snprintf(temp_array,100,"%s%s",dev_name,"in_magn_z_scale");
+    g_imufds.magn_zscale_fd = fopen(temp_array,"r");
+    if(g_imufds.magn_zscale_fd == NULL)
+	printf("\nunable to open:%s\n",temp_array);
+  //  else
+//	printf("open:%s succesfull\n",temp_array);
+
+    return;
+}
+
+imu_s_data getGyroData(){
+
+}
+
+
+void save_gprmc_token_3_1(char *token,int field_num){
+   // printf("%s:token:%s,field_num:%d\n",__func__,token,field_num);
+    GPRMC_msg_t *ptr = &GPRMC_msg_g; 
+    switch(field_num){
+    case 0:
+	ptr->timestamp = atof(token);
+	debug_gps("timestamp:%f\n",ptr->timestamp);
+	break;
+    case 1:
+        //strcpy(&ptr->status, token);
+	ptr->status = *token;
+	debug_gps("status:%c\n",ptr->status);
+	break;
+    case 2:
+	ptr->latitude = atof(token);
+	debug_gps("latitude:%f\n",ptr->latitude);
+	break;
+    case 3:
+        //strcpy(&ptr->lat_direction, token);
+	ptr->lat_direction = *token;
+	debug_gps("lat_direction:%c\n",ptr->lat_direction);
+	break;
+    case 4:
+	ptr->longitude  = atof(token);
+	debug_gps("longitude:%f\n",ptr->longitude);
+	break;
+    case 5:
+        //strcpy(&ptr->lat_direction, token);
+	ptr->long_direction = *token;
+	debug_gps("long_direction:%c\n",ptr->long_direction);
+	break;
+    case 6:
+	ptr->speed = atof(token);
+	debug_gps("speed:%f\n",ptr->speed);
+	break;
+    case 7:
+	ptr->trackgood  = atof(token);	
+	debug_gps("trackgood:%f\n",ptr->trackgood);
+	break;
+    case 8:
+	ptr->date  = atof(token);
+	debug_gps("date:%f\n",ptr->date);
+	break;
+    case 9:
+	ptr->magvar = atof(token);
+	debug_gps("magvar:%f\n",ptr->magvar);
+	break;
+    case 10:
+	ptr->magvardirection = (*token);
+	debug_gps("magvardirection:%c\n",ptr->magvardirection);
+	break;
+    case 11:
+        strcpy(ptr->checksum, token);
+	debug_gps("checksum:%s\n",ptr->checksum);
+	break;
+
+
+    default:
+        debug_gps("\nGPRMC: fieldnumber{%d}:is not implemented:value:%s\n",field_num,token);
+	break;
+    }
+
+    return;
+} 
+
+
+
+
+//alt 8th case for gpgga
+void save_gpgga_token_3_1(char *token,int field_num){
+    GPGGA_msg_t *ptr = &GPGGA_msg_g;
+    debug_gps("GPGGA:token %s,  field_num:%d\n",token,field_num);
+    switch(field_num){
+	case 8:
+		ptr->alt =atof(token);
+		debug_gps("%s:set alt:%f,token:%s\n",__func__,ptr->alt,token);
+	default:
+		debug_gps("%s: %s token , %d field not used for now",__func__,token,field_num);
+    }
+//    debug_gps("%s:token:%s,field_num:%d\n",__func__,token,field_num);
+    return;
+}
+
+
+void save_gpvtg_token_3_1(char *token,int field_num){
+
+    debug_gps("%s:token:%s,field_num:%d\n",__func__,token,field_num);
+    return;
+}
+
+
+void save_gngsa_token_3_1(char *token,int field_num){
+
+    debug_gps("%s:token:%s,field_num:%d\n",__func__,token,field_num);
+    return;
+}
+
+
+void save_gpgll_token_3_1(char *token,int field_num){
+    debug_gps("%s:token:%s,field_num:%d\n",__func__,token,field_num);
+    return;
+}
+
+
+
+void save_gnrmc_token_4_1(char *token,int field_num){
+    GNRMC_msg_t *ptr = &GNRMC_msg_g; 
+    switch(field_num){
+    case 0:
+	ptr->timestamp = atof(token);
+	debug_gps("timestamp:%f\n",ptr->timestamp);
+	break;
+    case 1:
+        //strcpy(&ptr->status, token);
+	ptr->status = *token;
+	debug_gps("status:%c\n",ptr->status);
+	break;
+    case 2:
+	ptr->latitude = atof(token);
+	debug_gps("latitude:%f\n",ptr->latitude);
+	break;
+    case 3:
+        //strcpy(&ptr->lat_direction, token);
+	ptr->lat_direction = *token;
+	debug_gps("lat_direction:%c\n",ptr->lat_direction);
+	break;
+    case 4:
+	ptr->longitude  = atof(token);
+	debug_gps("longitude:%f\n",ptr->longitude);
+	break;
+    case 5:
+        //strcpy(&ptr->lat_direction, token);
+	ptr->long_direction = *token;
+	debug_gps("long_direction:%c\n",ptr->long_direction);
+	break;
+    case 6:
+	ptr->speed = atof(token);
+	debug_gps("speed:%f\n",ptr->speed);
+	break;
+    case 7:
+	ptr->trackgood  = atof(token);	
+	debug_gps("trackgood:%f\n",ptr->trackgood);
+	break;
+    case 8:
+	ptr->date  = atof(token);
+	debug_gps("date:%f\n",ptr->date);
+	break;
+    case 9:
+	ptr->magvar = atof(token);
+	debug_gps("magvar:%f\n",ptr->magvar);
+	break;
+    case 10:
+	ptr->magvardirection = (*token);
+	debug_gps("magvardirection:%c\n",ptr->magvardirection);
+	break;
+    case 11:
+        //strcpy(ptr->mode, token);
+	ptr->mode = *token;
+	debug_gps("mode:%c\n",ptr->mode);
+	break;
+    case 12:
+	{
+       // strcpy(ptr->checksum, token);{
+        char *new_token	= strtok_single_ast(token,"*");
+	ptr->navStatus = *new_token;
+        strcpy(ptr->checksum, token);
+	debug_gps("navstatus:%c, checksum:%s\n",ptr->navStatus,ptr->checksum);
+	}
+	break;
+    default:
+        debug_gps("\nGNRMC: fieldnumber{%d}:is not implemented:value:%s\n",field_num,token);
+	break;
+    }
+
+    return;
+} 
+
+
+
+void save_pstmcpu_token_3_1(char *token,int field_num){
+
+    debug_gps("%s:token:%s,field_num:%d\n",__func__,token,field_num);
+    return;
+}
+
+
+//#define DEBUG_PSTMPV
+void save_pstmpv_token_3_1(char *token,int field_num){
+    //printf("%s:token:%s,field_num:%d\n",__func__,token,field_num);
+    PSTMPV_msg_t *ptr = &PSTMPV_msg_g; 
+    switch(field_num){
+    case 0:
+	ptr->timestamp = atof(token);
+	debug_gps("timestamp:%f\n",ptr->timestamp);
+        #ifdef DEBUG_PSTMPV
+	printf("timestamp:%f\n",ptr->timestamp);
+	#endif
+	break;
+    case 1:
+	ptr->latitude = atof(token);
+	debug_gps("latitude:%f\n",ptr->latitude);
+        #ifdef DEBUG_PSTMPV
+	printf("latitude:%f\n",ptr->latitude);
+	#endif
+	break;
+    case 2:
+        //strcpy(&ptr->lat_direction, token);
+	ptr->lat_direction = *token;
+	debug_gps("lat_direction:%c\n",ptr->lat_direction);
+	break;
+    case 3:
+	ptr->longitude  = atof(token);
+	debug_gps("longitude:%f\n",ptr->longitude);
+	break;
+    case 4:
+        //strcpy(&ptr->lat_direction, token);
+	ptr->long_direction = *token;
+	debug_gps("long_direction:%c\n",ptr->long_direction);
+	break;
+    case 5:
+	ptr->alt = atof(token);
+	debug_gps("alt:%f\n",ptr->alt);
+	break;
+    case 6:
+	ptr->alt_val  = *(token);	
+	debug_gps("alt_val:%c\n",ptr->alt_val);
+	break;
+    case 7:
+	ptr->vel_N  = atof(token);
+	debug_gps("vel_N:%f\n",ptr->vel_N);
+        #ifdef DEBUG_PSTMPV
+	printf("vel_N:%f\n",ptr->vel_N);
+	#endif
+	break;
+    case 8:
+	ptr->vel_E = atof(token);
+	debug_gps("vel_E:%f\n",ptr->vel_E);
+        #ifdef DEBUG_PSTMPV
+	printf("vel_E:%f\n",ptr->vel_E);
+	#endif
+	break;
+    case 9:
+	ptr->P_cov_N = atof(token);
+	debug_gps("P_cov_N:%f\n",ptr->P_cov_N);
+        #ifdef DEBUG_PSTMPV
+	printf("P_cov_N:%f\n",ptr->P_cov_N);
+	#endif
+	break;
+
+    case 10:
+	ptr->P_cov_NE = atof(token);
+	debug_gps("P_cov_NE:%f\n",ptr->P_cov_NE);
+	break;
+
+    case 11:
+	ptr->P_cov_NV = atof(token);
+	debug_gps("P_cov_NV:%f\n",ptr->P_cov_NV);
+	break;
+    case 12:
+	ptr->P_cov_E = atof(token);
+	debug_gps("P_cov_E:%f\n",ptr->P_cov_E);
+	break;
+    case 13:
+	ptr->P_cov_EV = atof(token);
+	debug_gps("P_cov_EV:%f\n",ptr->P_cov_EV);
+	break;
+    case 14:
+	ptr->P_cov_V = atof(token);
+	debug_gps("P_cov_V:%f\n",ptr->P_cov_V);
+	break;
+    case 15:
+	ptr->P_cov_N = atof(token);
+	debug_gps("P_cov_N:%f\n",ptr->P_cov_N);
+	break;
+    case 16:
+	ptr->V_cov_N = atof(token);
+	debug_gps("V_cov_N:%f\n",ptr->V_cov_N);
+	break;
+    case 17:
+	ptr->V_cov_NE = atof(token);
+	debug_gps("V_cov_NE:%f\n",ptr->V_cov_NE);
+	break;
+    case 18:
+	ptr->V_cov_NV = atof(token);
+	debug_gps("V_cov_NV:%f\n",ptr->V_cov_NV);
+	break;
+    case 19:
+	ptr->V_cov_E = atof(token);
+	debug_gps("V_cov_E:%f\n",ptr->V_cov_E);
+	break;
+    case 20:
+	ptr->V_cov_EV = atof(token);
+	debug_gps("V_cov_EV:%f\n",ptr->V_cov_EV);
+	break;
+    case 21:
+	ptr->V_cov_V = atof(token);
+	debug_gps("V_cov_V:%f\n",ptr->V_cov_V);
+	break;
+
+    default:
+        debug_gps("\nPSTMPV: fieldnumber{%d}:is not implemented:value:%s\n",field_num,token);
+	break;
+    }
+
+    return;
+} 
+
+//#define DEBUG_PSTMPVRAW
+void save_pstmpvraw_token_3_1(char *token,int field_num){
+    //printf("%s:token:%s,field_num:%d\n",__func__,token,field_num);
+    PSTMPVRAW_msg_t *ptr = &PSTMPVRAW_msg_g; 
+    use_mpvraw=1;
+    switch(field_num){
+    case 0:
+	ptr->timestamp = atof(token);
+	debug_gps("timestamp:%f\n",ptr->timestamp);
+        #ifdef DEBUG_PSTMPVRAW
+	printf("timestamp:%f\n",ptr->timestamp);
+	#endif
+	break;
+    case 1:
+	ptr->latitude = atof(token);
+	debug_gps("latitude:%f\n",ptr->latitude);
+        #ifdef DEBUG_PSTMPVRAW
+	printf("latitude:%f\n",ptr->latitude);
+	#endif
+	break;
+    case 2:
+        //strcpy(&ptr->lat_direction, token);
+	ptr->lat_direction = *token;
+	debug_gps("lat_direction:%c\n",ptr->lat_direction);
+	break;
+    case 3:
+	ptr->longitude  = atof(token);
+	debug_gps("longitude:%f\n",ptr->longitude);
+	break;
+    case 4:
+        //strcpy(&ptr->lat_direction, token);
+	ptr->long_direction = *token;
+	debug_gps("long_direction:%c\n",ptr->long_direction);
+	break;
+    case 5:
+	ptr->GPSQual = atof(token);
+	debug_gps("GPSQual:%f\n",ptr->alt);
+	break;
+    case 6:
+	ptr->Sats  = atof(token);	
+	debug_gps("Sats:%f\n",ptr->Sats);
+	break;
+    case 7:
+	ptr->HDOP  = atof(token);
+	debug_gps("HDOP:%f\n",ptr->HDOP);
+        #ifdef DEBUG_PSTMPVRAW
+	printf("HDOP:%f\n",ptr->HDOP);
+	#endif
+	break;
+    case 8:
+	ptr->alt = atof(token);
+	debug_gps("alt:%f\n",ptr->alt);
+        #ifdef DEBUG_PSTMPVRAW
+	printf("MPVRAW alt:%f\n",ptr->alt);
+	#endif
+	break;
+    case 9:
+	ptr->alt_val = *token;
+	debug_gps("alt_val:%c\n",ptr->alt_val);
+        #ifdef DEBUG_PSTMPVRAW
+	printf("MPVRAW alt_val:%c\n",ptr->alt_val);
+	#endif
+	break;
+
+    case 10:
+	ptr->geoSep = atof(token);
+	debug_gps("geoSep:%f\n",ptr->geoSep);
+	break;
+
+    case 11:
+	ptr->geoVal = *token;
+	debug_gps("geoVal:%c\n",ptr->geoVal);
+	break;
+    case 12:
+	ptr->vel_N = atof(token);
+	debug_gps("vel_N:%f\n",ptr->vel_N);
+	break;
+    case 13:
+	ptr->vel_E = atof(token);
+	debug_gps("vel_E:%f\n",ptr->vel_E);
+	break;
+    case 14:
+	ptr->vel_V = atof(strtok_single_ast(token,"*"));
+	debug_gps("vel_N:%f\n",ptr->vel_V);
+	break;
+    default:
+        printf("\nPSTMPVRAW: fieldnumber{%d}:is not implemented:value:%s\n",field_num,token);
+	break;
+    }
+
+    return;
+} 
+
+
+msg_details_nmea_t nmea_msg_details[]={
+{"$GPRMC", 12, &save_gprmc_token_3_1}, //0
+{"$GPGGA",14, &save_gpgga_token_3_1}, 
+{"$GPVTG",9, &save_gpvtg_token_3_1},
+{"$GPGLL",7, &save_gpgll_token_3_1},
+
+//{"$GNGSA",17, &save_gngsa_token_4_1},
+{"$GNRMC",13,&save_gnrmc_token_4_1}, //4
+{"$GNGGA",14, &save_gpgga_token_3_1}, 
+{"$GNVTG",9, &save_gpvtg_token_3_1},
+
+{"$PSTMCPU",3, &save_pstmcpu_token_3_1}, //7
+{"$PSTMPVRAW",15, &save_pstmpvraw_token_3_1},
+{"$PSTMPV",22, &save_pstmpv_token_3_1},
+
+};
+
+/*below macros should follow nmea_msg_details order*/
+#define GPRMC 0
+#define GPGGA 1
+#define GPVTG 2
+#define GPGLL 3
+
+#define GNRMC 4
+#define GNGGA 5
+#define GNVTG 6
+
+#define PSTMCPU 7
+#define PSTMPVRAW 8
+#define PSTMPV 9
+
+
+static int nmea_msg_valid[sizeof(nmea_msg_details)/sizeof(nmea_msg_details[0])];
+
+
+float getLatitude(){
+   if(nmea_msg_valid[GPRMC])
+	  return GPRMC_msg_g.latitude;
+
+   if(nmea_msg_valid[GNRMC])
+	  return GNRMC_msg_g.latitude;
+
+   if(nmea_msg_valid[PSTMPV])
+	  return PSTMPV_msg_g.latitude;
+    debug_gps("%s not valid data\n",__func__);
+    return float(0.0);
+}
+
+float getLongitude(){
+   if(nmea_msg_valid[GPRMC])
+	  return GPRMC_msg_g.longitude;
+
+   if(nmea_msg_valid[GNRMC])
+	  return GNRMC_msg_g.longitude;
+
+   if(nmea_msg_valid[PSTMPV])
+	  return PSTMPV_msg_g.longitude;
+    
+    debug_gps("%s not valid data\n",__func__);
+    return float(0.0);
+
+}
+
+
+float getAltitude(){
+   //if(nmea_msg_valid[PSTMPV])
+	  //return PSTMPV_msg_g.alt;
+   if(nmea_msg_valid[GPGGA])
+	  return GPGGA_msg_g.alt;
+
+   if(nmea_msg_valid[PSTMPVRAW])
+	  return PSTMPVRAW_msg_g.alt_val;
+
+    debug_gps("%s not valid data\n",__func__);
+    debug_gps("Return zero Altitude:nmea_msg_valid[GPGGA]:%d\n",nmea_msg_valid[GPGGA]);
+    return float(0.0);
+
+}
+
+float getNedNorthVel(){
+
+    if(nmea_msg_valid[PSTMPVRAW])
+        return PSTMPVRAW_msg_g.vel_N;
+
+    if(nmea_msg_valid[PSTMPV])
+        return PSTMPV_msg_g.vel_N;
+
+    debug_gps("%s not valid data\n",__func__);
+    return float(0.0);
+}
+
+float getNedEastVel(){
+#if 0
+   if(nmea_msg_valid[PSTMPV])
+        return PSTMPV_msg_g.vel_E;
+    return float(0.0);
+#endif
+    if(nmea_msg_valid[PSTMPVRAW])
+        return PSTMPVRAW_msg_g.vel_E;
+    if(nmea_msg_valid[PSTMPV])
+        return PSTMPV_msg_g.vel_E;
+    
+    debug_gps("%s not valid data\n",__func__);
+    return float(0.0);
+
+}
+
+float getNedDownVel(){
+
+   if(nmea_msg_valid[PSTMPVRAW])
+       return PSTMPVRAW_msg_g.vel_V;
+   if(nmea_msg_valid[PSTMPV])
+       return PSTMPV_msg_g.vel_V;
+
+    debug_gps("%s not valid data\n",__func__);
+    return float(0.0);
+}
+
+
+
+int get_nmea_index(char *token){
+    int i,ret=-1;
+    int array_size=(sizeof(nmea_msg_details)/sizeof(nmea_msg_details[0]));
+    //printf("E:%s,array_size:%d\n",__func__,array_size);
+//	printf("token:%s\n",token);
+    for(i=0;i<array_size;i++){
+       // printf("i:%d\n",i);
+	//if (!strcmp(token, nmea_msg_details[i].name) ){
+	
+	if (strstr(token, nmea_msg_details[i].name)!=NULL ){
+  //  	    printf("index found:X:{%s}:%d\n",token,i);
+	    ret=i;
+	    break;
+	} 
+    }
+    if(i==array_size){
+//	printf("index not found, Message :{%s} is not supported by app",token);
+	ret=-1;
+  }
+   return ret;
+}
+
+
+char *
+strtok_single (char * str, char const * delims)
+{
+  static char  * src = NULL;
+  char  *  p,  * ret = 0;
+
+  if (str != NULL)
+    src = str;
+
+  if (src == NULL || *src == '\0')
+    return NULL;
+
+  ret = src;
+  if ((p = strpbrk (src, delims)) != NULL) {
+    *p  = 0;
+    //ret = src;
+    src = ++p;
+
+  } else
+         src+=strlen(src); 
+
+  return ret;
+}
+char *
+strtok_single_ast (char * str, char const * delims)
+{
+  static char  * src_ast = NULL;
+  char  *  p,  * ret = 0;
+
+  if (str != NULL)
+    src_ast = str;
+
+  if (src_ast == NULL || *src_ast == '\0')
+    return NULL;
+
+  ret = src_ast;
+  if ((p = strpbrk (src_ast, delims)) != NULL) {
+    *p  = 0;
+    //ret = src;
+    src_ast = ++p;
+
+  } else
+         src_ast+=strlen(src_ast); 
+
+  return ret;
+}
+
+
+void process_gps_string(char *buffer){
+    int i = 0;
+    int current_msg_idx = -1;
+
+          // sleep(1);
+   // printf("%s():%s\n",__func__,buffer);
+    fflush(stdout);
+          // sleep(1);
+
+    char *token = strtok_single(buffer,",");
+    while (token!=NULL){
+	debug_gps("token is:%s\n",token);
+	if((strstr(token,"$G")!=NULL) || (strstr(token,"$P")!=NULL)){
+			debug_gps("%s is new message\n",token);
+			/*add check if message is supported or not here*/
+			valid_token=1;
+			last_msg_index = get_nmea_index(token);
+			if(last_msg_index >=0){
+	//		printf("index:%d\n",last_msg_index);
+				fields_left = nmea_msg_details[last_msg_index].field_count;
+				current_msg_idx = last_msg_index;
+			} else {
+				valid_token=0;
+				current_msg_idx = -1;
+				debug_gps("token:%s not supported\n",token);
+			}
+	}else{
+		if(!valid_token){
+	//		printf("token not valid: discardind{%s}\n",token);
+		//	sleep(1);
+        		token=strtok_single(NULL,",");
+	//		printf("new token is:%s\n",token);
+			continue;
+		}
+		if(*token == NULL){
+			debug_gps("Empty Field\n");
+		}else{
+			debug_gps("token:%s\n",token);
+			nmea_msg_details[last_msg_index].save_token(token,
+	 			nmea_msg_details[last_msg_index].field_count - fields_left);
+			if(last_msg_index==1){//GPGGA
+				debug_gps("GPGGA Token:%s\n",token);
+			}
+		}
+		fields_left--;
+		debug_gps("fields left for :%s is :%d\n",nmea_msg_details[last_msg_index].name,fields_left);
+		if(fields_left == 0){
+			debug_gps("all fields received:\n");
+			if(current_msg_idx >= 0){
+				debug_gps("marking %s/%d nmea_msg valid\n", 
+					nmea_msg_details[current_msg_idx].name,current_msg_idx);
+				nmea_msg_valid[current_msg_idx] = 1;
+				if(current_msg_idx ==  1){
+					debug_gps("Marking%s valid\n",nmea_msg_details[current_msg_idx].name);
+				}
+			}
+	//		sleep(1);
+			valid_token = 0;
+		}
+	}
+        token=strtok_single(NULL,",");
+   }
+	/*if complete message was not received, mark it invalid and proceed*/
+		if(current_msg_idx >= 0 && fields_left != 0){
+				nmea_msg_valid[current_msg_idx] = 0;
+					debug_gps("Marking%s invalid \n",nmea_msg_details[current_msg_idx].name);
+
+			}
+
+           debug_gps("%s: done!!\n",__func__);
+           //sleep(1);
+    return;
+}
+
+
+
+void readGPS_thread(ST_GNSS1_IMU *ST_GNSS1_cls){
+	printf("%s started\n",__func__);
+	//uint8_t buffer ;
+	int i=0;
+	int device;
+        char buffer[1024*16];
+	//device = serialPort_g.getFD();
+	device = ST_GNSS1_cls->serialPort.getFD();
+	printf("%s: FD:%d\n",__func__, device);
+#if 0		
+	SerialPort_local = ST_GNSS1_cls->serialPort;
+	if(ST_GNSS1_cls == NULL){
+		printf("Error NULL imu class\n");
+	}
+	printf("gpsThread\n");
+	std::string port = "/dev/ttySTM1";
+        device = open(port.c_str(), O_RDWR | O_NOCTTY | O_SYNC);
+
+
+    std::string response;
+    int parity=0;
+    struct termios tty;
+    ssize_t read_l;
+    size_t len = 0;
+    if (tcgetattr(device ,&tty)!=0){
+	printf("Error in tcgetatt\n");
+    }
+#if 1
+        cfsetospeed (&tty, B9600);
+        cfsetispeed (&tty, B9600);
+
+        tty.c_cflag = (tty.c_cflag & ~CSIZE) | CS8;     // 8-bit chars
+        // disable IGNBRK for mismatched speed tests; otherwise receive break
+        // as \000 chars
+        tty.c_iflag &= ~IGNBRK;         // disable break processing
+        tty.c_lflag = 0;                // no signaling chars, no echo,
+                                        // no canonical processing
+        tty.c_oflag = 0;                // no remapping, no delays
+        tty.c_cc[VMIN]  = 0;            // read doesn't block
+        tty.c_cc[VTIME] = 5;            // 0.5 seconds read timeout
+
+        tty.c_iflag &= ~(IXON | IXOFF | IXANY); // shut off xon/xoff ctrl
+
+        tty.c_cflag |= (CLOCAL | CREAD);// ignore modem controls,
+                                        // enable reading
+        tty.c_cflag &= ~(PARENB | PARODD);      // shut off parity
+        tty.c_cflag |= parity;
+        tty.c_cflag &= ~CSTOPB;
+        tty.c_cflag &= ~CRTSCTS;
+       if (tcsetattr (device, TCSANOW, &tty) != 0)
+        {
+                printf("error from tcsetattr\n");
+                return;
+        } else {
+		printf("serial config done\n");
+	}
+
+#endif
+
+#endif
+
+
+
+    do
+    {
+        int n = read(device,(void *) buffer, sizeof buffer);
+
+        if (n > 0) {
+#if 0
+	   //buffer[n+2]='\0';
+	   char *pch = strstr(buffer,"\n");
+           while(pch != NULL){
+		strncpy(pch, ",",1);
+		pch = strstr(buffer, "\n");
+	   }
+
+#endif
+     	   debug_gps("\n[BE4S]:buffer 4m serial: %s\n",buffer);
+	  // fflush(stdout);
+           //sleep(1);
+	  for(int i = 0;buffer[i]!='\0';i++){
+		if(buffer[i]=='\n'){
+			buffer[i]=',';
+		}
+ 	   }
+     	  // printf("\nbuffer from serial is: %s\n",buffer);
+	  // fflush(stdout);
+	   process_gps_string(buffer);
+           //std::cout << buffer;
+        }else{
+		printf("no serial Data\n");
+		usleep(10000); //10,ms
+	}
+
+	getIMUData();
+	//usleep(100000);
+#ifdef DEBUG_IMU_DATA
+	printf("gyro data:x%f,y:%f,Z:%f\n",g_imudata.gyro_x_data ,
+		g_imudata.gyro_y_data, g_imudata.gyro_z_data);
+
+	printf("accel data:x%f,y:%f,Z:%f\n",g_imudata.accel_x_data ,
+		g_imudata.accel_y_data, g_imudata.accel_z_data);
+
+	printf("magn data:x%f,y:%f,Z:%f\n",g_imudata.magn_x_data ,
+		g_imudata.magn_y_data, g_imudata.magn_z_data);
+//	sleep(2);
+#endif
+
+    } while (1); // 'X' means end of transmission
+
+
+    close(device);
+#if 0
+	while(1){
+		while(SerialPort_local.available()){
+			buffer = SerialPort_local.read();
+			printf("gnssData:%c,%d",buffer,buffer);
+		}
+		if(i%10 == 1){
+			i=1;
+			i++;
+			printf("Debug:gpsThread 10 read tries done\n");
+		}
+		sleep(1);
+	}
+#endif
+	return;
+
+}
+
+std::thread ST_GNSS1_IMU::initGPS(Stream serialDev, int gpsDataFormat){
+	this->serialPort = serialDev;
+	return std::thread(&readGPS_thread,this);
+}
+
+
+ST_GNSS1_IMU::ST_GNSS1_IMU(void){
+
+
+}
+
+
diff --git a/EKF_Linux_Library/EKF_GNSS_Library/src/EKF_GNSS_MPU157F_dk2_Library.h b/EKF_Linux_Library/EKF_GNSS_Library/src/EKF_GNSS_MPU157F_dk2_Library.h
new file mode 100644
index 0000000..2b740ef
--- /dev/null
+++ b/EKF_Linux_Library/EKF_GNSS_Library/src/EKF_GNSS_MPU157F_dk2_Library.h
@@ -0,0 +1,238 @@
+/*
+*) Refactor the code to remove reduentent part. 
+*) Compiled for Linux with C++14 standard
+Copyright (c) 2021 Balamurugan Kandan.
+MIT License; See LICENSE.md for complete details
+Author: 2021 Balamurugan Kandan
+*/
+
+/*
+Updated to be a class, use Eigen, and compile as an Arduino library.
+Added methods to get gyro and accel bias. Added initialization to
+estimated angles rather than assuming IMU is level.
+
+Copyright (c) 2016 - 2019 Regents of the University of Minnesota and Bolder Flight Systems Inc.
+MIT License; See LICENSE.md for complete details
+Author: Brian Taylor
+*/
+
+/*
+Addapted from earlier version
+Copyright 2011 Regents of the University of Minnesota. All rights reserved.
+Original Author: Adhika Lie
+*/
+
+
+
+#ifndef EKF_GNSS_MPU157F_DK2_LIBRARY_H
+
+#define EKF_GNSS_MPU157F_DK2_LIBRARY_H
+
+#include <Wire.h>
+#include <stdint.h>
+#include <atomic>
+#include <cstdio> 
+#include <thread>
+#include <mutex>
+#include <Stream.h>
+
+
+float getLatitude();
+
+float getLongitude();
+
+float getAltitude();
+float getNedNorthVel();
+float getNedEastVel();
+float getNedDownVel();
+
+
+
+std::atomic<int> gpslock(0);
+std::mutex gpsBuffReadmtx[2];
+#define IIO_SYS_DIR "/sys/bus/iio/devices/iio:device"
+
+void init_st_imulib();
+
+typedef struct
+{
+    /* iio dev number in sysfs */
+    uint32_t gyro_id;
+    uint32_t magnet_id;
+    uint32_t accel_id;
+
+    /* gyro scale factor */
+    float gyro_x_scale;
+    float gyro_y_scale;
+    float gyro_z_scale;
+
+
+    /* accelerometer scale factor */
+    float accel_x_scale;
+    float accel_y_scale;
+    float accel_z_scale;
+
+    /* magnetometer scale factor */
+    float magn_x_scale;
+    float magn_y_scale;
+    float magn_z_scale;
+
+    /*SYSFS FILE FD for gyro*/
+    FILE *gyro_x_fd;
+    FILE *gyro_y_fd;
+    FILE *gyro_z_fd;
+
+    /*sysfs FILE fd for accelerometer*/
+    FILE *accel_x_fd;
+    FILE *accel_y_fd;
+    FILE *accel_z_fd;
+
+
+    /*sysfs FILE fd for magnetometer*/
+    FILE *magn_x_fd;
+    FILE *magn_y_fd;
+    FILE *magn_z_fd;
+
+} ST_IMU_SensorInfo_t;
+
+
+typedef struct file_fd_imus_t{
+
+    /*SYSFS FILE FD for gyro*/
+    char gyro_path[100];
+    FILE *gyro_x_fd;
+    FILE *gyro_y_fd;
+    FILE *gyro_z_fd;
+
+    FILE *gyro_xscale_fd;
+    FILE *gyro_yscale_fd;
+    FILE *gyro_zscale_fd;
+    char accel_path[100];
+    /*sysfs FILE fd for accelerometer*/
+    FILE *accel_x_fd;
+    FILE *accel_y_fd;
+    FILE *accel_z_fd;
+
+    FILE *accel_xscale_fd;
+    FILE *accel_yscale_fd;
+    FILE *accel_zscale_fd;
+
+    /*sysfs FILE fd for magnetometer*/
+    char magn_path[100];
+    FILE *magn_x_fd;
+    FILE *magn_y_fd;
+    FILE *magn_z_fd;
+
+    FILE *magn_xscale_fd;
+    FILE *magn_yscale_fd;
+    FILE *magn_zscale_fd;
+
+}fdlist_imus;
+
+
+typedef struct imu_s_data_{
+	float x;
+	float y;
+	float z;
+}imu_s_data;
+
+typedef struct
+{
+
+    float gyro_x_data;
+    float gyro_y_data;
+    float gyro_z_data;
+
+    float accel_x_data;
+    float accel_y_data;
+    float accel_z_data;
+
+    float magn_x_data;
+    float magn_y_data;
+    float magn_z_data;
+
+} ST_IMU_SensorData_t;
+
+typedef struct
+{
+    int solutionType; /* 2: DGNSS/FIX , 1: DGNSS/Float 0:No RTK FIxed*/
+    float latitude;
+    float longitude;
+    float altitude;
+    float altitude_msl;
+    float SIV; /* satellite in view */
+    float PDOP; /* Position Dilution of Precision*/
+    float fixType;
+    float groundSpeed;
+    float VelN; /* NORTH Velocity */
+    float VelE; /* EAST Velocity */
+    float VelD; /* NDOWN Velocity */
+    float VAcc; /* Vertical Acceleration */
+    float HAcc; /* Horizontal Acceleration */
+    float SpeedAccEst; /* ?? */
+    float HeadAccEst; /* ?? */
+    float HeadVehValid; /* ?? */
+    float HeadVeh;
+    float MagDec;
+    float MagAcc;
+
+
+} ST_GPS_Data_t;
+
+
+enum gpsDataType{
+	NONE=0,
+	NMEA,
+	RTCM,
+	RTCM3,
+	GPS_D_MAX
+} currentDataMode = NONE;
+
+
+void initGyro(char *dev_name);
+void initAccel(char *dev_name);
+void initMagn(char *dev_name);
+void  getIMUData();
+
+
+class ST_GNSS1_IMU
+{
+public:
+	ST_GNSS1_IMU(void);
+	void initGPSThread();
+	imu_s_data getGyroData();	
+	imu_s_data getAccelData();	
+	imu_s_data getMagnData();	
+
+	/*gpsDataFormat is either NMEA, RTCM, RTCM3*/
+	std::thread initGPS(Stream serialdevGPS ,int gpsDataFormat); 
+	float getGPSData();
+	/*get IMU Data*/
+	ST_IMU_SensorData_t getIMUData();
+	Stream serial_inst;
+	uint8_t *serialBuffer = NULL;
+	Stream serialPort;
+
+private:
+	/*thread processes GPS data in a thread and stores in gpsData pingpong bufer
+	 Atomic operation is needed to ensure while updating active buffer getGPSData callback doesnt picks old/invalid data*/	
+	
+	/*save sensor information like FILE fd for various sensors data nodes and scaling parameters*/
+	ST_IMU_SensorInfo_t sensorinfo;
+	/*below is needed if running IU sensor data thread and storing data in pingpong buffer
+	Just like GPS*/
+	/*ST_IMU_SensorData_t sensordata[2];
+
+	std::atomic<int> imudatalock(0);
+	*/
+
+
+	ST_GPS_Data_t GPSpingpong_dat[2];
+	uint16_t baudrate;
+	char SerialName[40];
+	uint8_t gpsValidnum;
+
+};
+
+
+#endif
diff --git a/EKF_Linux_Library/EKF_GNSS_Library/src/EKF_GNSS_msg.h b/EKF_Linux_Library/EKF_GNSS_Library/src/EKF_GNSS_msg.h
new file mode 100644
index 0000000..712cdaa
--- /dev/null
+++ b/EKF_Linux_Library/EKF_GNSS_Library/src/EKF_GNSS_msg.h
@@ -0,0 +1,252 @@
+/*
+*) Refactor the code to remove reduentent part. 
+*) Compiled for Linux with C++14 standard
+Copyright (c) 2021 Balamurugan Kandan.
+MIT License; See LICENSE.md for complete details
+Author: 2021 Balamurugan Kandan
+*/
+
+/*
+Updated to be a class, use Eigen, and compile as an Arduino library.
+Added methods to get gyro and accel bias. Added initialization to
+estimated angles rather than assuming IMU is level.
+
+Copyright (c) 2016 - 2019 Regents of the University of Minnesota and Bolder Flight Systems Inc.
+MIT License; See LICENSE.md for complete details
+Author: Brian Taylor
+*/
+
+/*
+Addapted from earlier version
+Copyright 2011 Regents of the University of Minnesota. All rights reserved.
+Original Author: Adhika Lie
+*/
+
+#ifndef EKF_GNSS_MSG_H
+#define EKF_GNSS_MSG_H
+
+#define NMEA_0183
+#define NMEA_REV_3_1
+
+#ifdef NMEA_0183
+
+#ifdef NMEA_REV_3_1
+
+#include <stdlib.h>
+
+/*
+extern GPRMC_msg_g;
+extern GPGGA_msg_g;
+extern GPVTG_msg_g;
+extern GNGSA_msg_g;
+extern GPGLL_msg_g;
+extern PSTMCPU_msg_g;
+*/
+
+typedef struct msg_array_NMEA{
+ char *name;
+ int field_count;
+ void (*save_token)(char *token,int field_num);
+// void *getData();
+}msg_details_nmea_t;
+
+
+typedef struct GPRMC_msg_rev3_1 {
+    float timestamp;
+    char status;
+    float latitude;
+    char lat_direction;
+    float longitude;
+    char long_direction;
+    float speed;
+    float trackgood;
+    float date;
+    float magvar;
+    char magvardirection;
+   // char mode;
+    //char navStatus;
+    char checksum[8];
+} GPRMC_msg_t;
+
+typedef struct GNRMC_msg_rev4_1 {
+    float timestamp;
+    char status;
+    float latitude;
+    char lat_direction;
+    float longitude;
+    char long_direction;
+    float speed;
+    float trackgood;
+    float date;
+    float magvar;
+    char magvardirection;
+    char mode;
+    char navStatus;
+    char checksum[8];
+} GNRMC_msg_t;
+
+
+typedef struct PSTMPV_msg_rev3_1 {
+    float timestamp;
+    float latitude;
+    char lat_direction;
+    float longitude;
+    char long_direction;
+    float alt;
+    char alt_val; //M=meters
+    float vel_N;//north velocity, m/s
+    float vel_E;//east velocity, m/s
+    float vel_V; //velocity vertical, m/s
+    float P_cov_N;
+    float P_cov_NE;
+    float P_cov_NV;
+    float P_cov_E;
+    float P_cov_EV;
+    float P_cov_V;
+    float V_cov_N;
+    float V_cov_NE;
+    float V_cov_NV;
+    float V_cov_E;
+    float V_cov_EV;
+    float V_cov_V;
+}PSTMPV_msg_t;
+
+typedef struct PSTMPVRAW_msg_rev3_1 {
+    float timestamp;
+    float latitude;
+    char lat_direction;
+    float longitude;
+    char long_direction;
+    float GPSQual;
+    float Sats;
+    float HDOP;
+    float alt;
+    char alt_val;
+    float geoSep;
+    char geoVal;
+    float vel_N;//north velocity, m/s
+    float vel_E;//east velocity, m/s
+    float vel_V; //velocity vertical, m/s
+//    float checksum;
+}PSTMPVRAW_msg_t;
+
+typedef struct GPGGA_msg_rev3_1 {
+    float timestamp;
+    float latitude;
+    char  lat_direction;
+    float longitude;
+    char  long_direction;
+    unsigned char gpsQual;
+    unsigned char sats;
+    float HDOP;
+    float alt;
+    float GeoSep;
+    float GeoVal;
+    float DGPSAge;
+    float DGPSRef;
+    char checksum[8];
+} GPGGA_msg_t;
+
+typedef struct GPVTG_msg_rev3_1 {
+    float tmgt;
+    char terrest;
+    float tmgm;
+    char magn;
+    float SoGN;
+    char n;
+    float SoGK;
+    char km;
+   // char mode_d;
+    char checksum[8];
+
+}GPVTG_msg_t;
+
+
+typedef struct GNGSA_msg_rev3_1 {
+    char mode_1; /*M=Manual, A= AUtomatic*/
+    char mode_2; /*Fix Type, 1= N/A, 2=2D , 3=3D*/
+    unsigned long prn;
+    float PDOP;
+    float HDOP; 
+    float VDOP; 
+    unsigned int sys_ID;
+    char checksum[8];
+}GNGSA_msg_t;
+
+typedef struct GNGGA_msg_rev4_1 {
+    float timestamp;
+    float latitude;
+    char  lat_direction;
+    float longitude;
+    char  long_direction;
+    unsigned char gpsQual;
+    unsigned char sats;
+    float HDOP;
+    float alt;
+    float GeoSep;
+    float GeoVal;
+    float DGPSAge;
+    float DGPSRef;
+    char checksum[8];
+} GNGGA_msg_t;
+
+
+typedef struct GPGLL_msg_rev3_1 {
+    float latitude;
+    char lat_direction;
+    float longitude;
+    char lon_direction;
+    float timestamp;
+    char status;
+    char pos_mode;
+    char checksum[8];
+}GPGLL_msg_t;
+
+typedef struct PSTMCPU_msg_rev3_1 {
+    float CPU_usage;
+    float CPU_speed;
+    char checksum[8];
+}PSTMCPU_msg_t;
+
+
+void process_gps_string(char *buffer);
+
+float getLatitude();
+float getLongitude();
+float getAltitude();
+float getNedNorthVel();
+float getNedEastVel();
+float getNedDownVel();
+
+
+//#define DEBUG_GPS_ON 
+//#define DEBUG_IMU_DATA
+
+#ifdef DEBUG_GPS_ON
+
+#define debug_gps(fmt, ...) \
+	do { printf("%s():" fmt,__func__,__VA_ARGS__);}while(0)
+
+#else
+#define debug_gps(fmt,...) do {} while(false)
+#endif
+
+
+//#define DEBUG_IMU_ON
+#ifdef DEBUG_IMU_ON
+
+#define debug_imu(fmt, args...) \
+	do { printf("%s():" fmt,__func__, ##args);}while(0)
+
+#else
+#define debug_imu(fmt,...) do {} while(false)
+#endif
+
+
+
+
+#endif //NMEA_REV_3_1
+
+#endif //NMEA_0183
+
+#endif //Header
diff --git a/Ublox_Linux_Library/LICENSE b/EKF_Linux_Library/LICENSE
similarity index 100%
rename from Ublox_Linux_Library/LICENSE
rename to EKF_Linux_Library/LICENSE
diff --git a/Ublox_Linux_Library/inc/Common.h b/EKF_Linux_Library/inc/Common.h
similarity index 70%
rename from Ublox_Linux_Library/inc/Common.h
rename to EKF_Linux_Library/inc/Common.h
index 0b46147..f7b6b99 100644
--- a/Ublox_Linux_Library/inc/Common.h
+++ b/EKF_Linux_Library/inc/Common.h
@@ -1,6 +1,6 @@
 #ifndef COMMON_H__
 #define COMMON_H__
-
+#include <stdint.h>
 typedef uint8_t byte;
 typedef bool boolean;
 
@@ -11,6 +11,6 @@ typedef bool boolean;
 
 #define SHORT_BUFF 256
 
-#define I2C_DEV "/dev/ublox_i2c"
+#define I2C_DEV "/dev/noname"
 
-#endif // COMMON_H__
\ No newline at end of file
+#endif // COMMON_H__
diff --git a/Ublox_Linux_Library/inc/Print.h b/EKF_Linux_Library/inc/Print.h
similarity index 100%
rename from Ublox_Linux_Library/inc/Print.h
rename to EKF_Linux_Library/inc/Print.h
diff --git a/Ublox_Linux_Library/inc/Stream.h b/EKF_Linux_Library/inc/Stream.h
similarity index 92%
rename from Ublox_Linux_Library/inc/Stream.h
rename to EKF_Linux_Library/inc/Stream.h
index 35bbd8b..b075f65 100644
--- a/Ublox_Linux_Library/inc/Stream.h
+++ b/EKF_Linux_Library/inc/Stream.h
@@ -42,17 +42,20 @@ class Stream : public Print {
 public:
 	Stream(char *devName) : m_IsAvailable(false), m_IsConnected(false), m_SerialFd(-1), m_baudRate(115200), m_devName({'\0'}) {
 		strcpy(m_devName, devName);
+		printf("Strea constructor 1\n");
 		open_comm(devName);
 		m_recvdByte = '\0';
 	}
 
 	Stream() : m_IsAvailable(false), m_IsConnected(false), m_SerialFd(-1) {
+		printf("Strea constructor 2\n");
 		open_comm(create_pseudo_com());
 		m_recvdByte = '\0';
 	}
 
 	virtual ~Stream() {
-		close_comm();
+		printf("Stream Destructor called\n");
+		//close_comm();
 	}
 
 	void close_comm() {
@@ -96,15 +99,16 @@ public:
 	bool open_comm(char *devName) {
 		m_SerialFd = open(devName, O_NOCTTY|O_RDWR|O_NONBLOCK);
 		if (m_SerialFd != -1) {
-			printf ("\n%s is connected successfully!!!\n", devName);
 			// Get device info
 			struct termios newtio;
 			memset(&newtio,0,sizeof(newtio));
 			cfmakeraw(&newtio);
 			newtio.c_cflag |= get_baud(m_baudRate);
+			 printf("Stream baudrate:%d, %d\n",m_baudRate,get_baud(m_baudRate));
 			tcflush(m_SerialFd, TCIFLUSH);
 			tcsetattr(m_SerialFd,TCSANOW,&newtio);
 			m_IsConnected = true;
+			printf ("\n%s is connected successfully!!!:brate:%d\n", devName,m_baudRate);
 		} else {
 			printf("Unable to open GNSS on: %s\n",devName);
 		}
@@ -149,6 +153,7 @@ public:
 	}
 
 	void begin(uint16_t baud_rate) {
+		printf("Stream begin\n");
 		m_baudRate = baud_rate;
 		close_comm();
 		open_comm(m_devName);
@@ -183,4 +188,4 @@ private:
 //typedef Stream Serial;
 extern Stream Serial;
 
-#endif // STREAM__
\ No newline at end of file
+#endif // STREAM__
diff --git a/Ublox_Linux_Library/inc/Utils.h b/EKF_Linux_Library/inc/Utils.h
similarity index 100%
rename from Ublox_Linux_Library/inc/Utils.h
rename to EKF_Linux_Library/inc/Utils.h
diff --git a/Ublox_Linux_Library/inc/WProgram.h b/EKF_Linux_Library/inc/WProgram.h
similarity index 100%
rename from Ublox_Linux_Library/inc/WProgram.h
rename to EKF_Linux_Library/inc/WProgram.h
diff --git a/Ublox_Linux_Library/inc/Wire.h b/EKF_Linux_Library/inc/Wire.h
similarity index 98%
rename from Ublox_Linux_Library/inc/Wire.h
rename to EKF_Linux_Library/inc/Wire.h
index 957e936..53b13f4 100755
--- a/Ublox_Linux_Library/inc/Wire.h
+++ b/EKF_Linux_Library/inc/Wire.h
@@ -6,7 +6,9 @@
 #include <linux/i2c.h>
 #include <sys/ioctl.h>
 #include <cstdio>
-
+#include <unistd.h>
+#include <errno.h>
+#include <cstring>
 #include "Common.h"
 
 class TwoWire
@@ -172,4 +174,4 @@ private:
 
 extern TwoWire Wire;
 
-#endif //Wire_h
\ No newline at end of file
+#endif //Wire_h
diff --git a/EKF_Linux_Library/linux_build/CMakeLists.txt b/EKF_Linux_Library/linux_build/CMakeLists.txt
new file mode 100644
index 0000000..51401f6
--- /dev/null
+++ b/EKF_Linux_Library/linux_build/CMakeLists.txt
@@ -0,0 +1,54 @@
+project (ekf_linux)
+cmake_minimum_required(VERSION 2.8)
+
+set(CMAKE_SKIP_BUILD_RPATH TRUE)
+set(CMAKE_BUILD_WITH_INSTALL_RPATH FALSE)
+set(CMAKE_INSTALL_RPATH_USE_LINK_PATH FALSE)
+
+set(
+    CMAKE_RUNTIME_OUTPUT_DIRECTORY
+    ${CMAKE_HOME_DIRECTORY}/bin
+    )
+
+set(
+    CMAKE_LIBRARY_OUTPUT_DIRECTORY
+    ${CMAKE_HOME_DIRECTORY}/lib
+    )
+
+add_definitions(
+    -std=c++11 -Wno-deprecated -fconcepts -Wall -DLINUX_PLATFORM -pthread
+    )
+
+link_directories(
+    /usr/local/lib
+    /usr/lib
+    ${CMAKE_HOME_DIRECTORY}/lib
+    )
+
+include_directories(
+    ${CMAKE_HOME_DIRECTORY}/../inc
+    ${CMAKE_HOME_DIRECTORY}/../EKF_GNSS_Library/src
+    )
+
+set(
+    ekf_parser_src
+    ../EKF_GNSS_Library/src/EKF_GNSS_MPU157F_dk2_Library.cpp
+    ../src/Print.cpp
+    ../src/Utils.cpp
+    )
+
+add_library(
+    ekf_linux SHARED ${ekf_parser_src}
+    )
+
+
+set(
+    ekf_gnss1_test_src
+    ../linux_examples/ekf_gnss1_test.cpp
+    )
+
+add_executable(
+    ekf_gnss1_test ${ekf_gnss1_test_src}
+    )
+
+target_link_libraries(ekf_gnss1_test ekf_linux util)
diff --git a/EKF_Linux_Library/linux_examples/ekf_gnss1_test.cpp b/EKF_Linux_Library/linux_examples/ekf_gnss1_test.cpp
new file mode 100644
index 0000000..60f50b0
--- /dev/null
+++ b/EKF_Linux_Library/linux_examples/ekf_gnss1_test.cpp
@@ -0,0 +1,821 @@
+/*
+Copyright (c) 2020 Balamurugan Kandan
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in all
+copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+SOFTWARE.
+*/
+
+
+/*
+*) Refactor the code to remove reduentent part. 
+*) Compiled for Linux with C++14 standard
+Copyright (c) 2021 Balamurugan Kandan.
+MIT License; See LICENSE.md for complete details
+Author: 2021 Balamurugan Kandan
+*/
+
+/*
+Updated to be a class, use Eigen, and compile as an Arduino library.
+Added methods to get gyro and accel bias. Added initialization to
+estimated angles rather than assuming IMU is level.
+
+Copyright (c) 2016 - 2019 Regents of the University of Minnesota and Bolder Flight Systems Inc.
+MIT License; See LICENSE.md for complete details
+Author: Brian Taylor
+*/
+
+/*
+Addapted from earlier version
+Copyright 2011 Regents of the University of Minnesota. All rights reserved.
+Original Author: Adhika Lie
+*/
+
+
+
+#include <algorithm>
+#include "ekfNavINS.h"
+#include "../../ekf_nav_ins/inc/ekfNavINS.h"
+#include <iostream>
+#include <iomanip>
+#include <tuple>
+#include <fstream>
+#include <string>
+#include <signal.h>
+#include <time.h>
+
+#include "EKF_GNSS_MPU157F_dk2_Library.h"
+#define SERIAL_ST_DEV "/dev/ttySTM1"
+ST_GNSS1_IMU myGPS;
+
+
+using namespace std;
+static int running = 0;
+
+extern fdlist_imus g_imufds;
+extern ST_IMU_SensorData_t g_imudata;
+
+
+static void __signal_handler(__attribute__((unused))int dummy){
+	running = 0;
+	return;
+}
+
+char* getCmdOption(char ** begin, char ** end, const std::string & option)
+{
+    char ** itr = std::find(begin, end, option);
+    if (itr != end && ++itr != end)
+    {
+        return *itr;
+    }
+    return 0;
+}
+
+#define NEW_TEST
+#ifdef NEW_TEST
+
+// file pointer
+fstream fout;
+fstream fout_log;
+inline void open_file(std::string file_name) {
+    fout.open(file_name, ios::out | ios::app);
+    fout << std::fixed <<"time" << "," << "latitude" << "," << "longitude" << "," 
+    								   << "roll" << "," << "pitch" << "," << "yaw" << "," 
+    								   << "filtered_latitude" << "," << "filtered_longitude" << ","
+    								   << "filtered_roll" << "," << "filtered_pitch" << "," << "filtered_yaw" << std::endl;
+}
+
+
+inline void open_file_log(std::string file_name) {
+    fout_log.open(file_name, ios::out | ios::app);
+    fout_log << std::fixed <<"time" << "," << "latitude" << "," << "longitude" << ","  << "altid" << ","
+    								   << "ax" << "," << "ay" << "," << "az" << "," 
+    								   << "hx" << "," << "hy" << ","
+    								   << "hz" << "," << "nVel" << ","  << "eVel" << ","  << "dVel" << std::endl;
+}
+
+
+
+inline void update_file(long int time, double latitude, double longitude,
+						float roll, float pitch, float yaw, 
+						double filtered_latitude, double filtered_longitude,
+						float filtered_roll, float filtered_pitch, float filtered_yaw) {
+	fout << time << "," << std::setprecision(7) << latitude << "," << std::setprecision(7) << longitude 
+				 << "," << roll << "," << pitch << "," << yaw
+				 << "," << std::setprecision(7) << filtered_latitude << "," << std::setprecision(7) << filtered_longitude 
+				 << "," << filtered_roll << "," << filtered_pitch << "," << filtered_yaw << std::endl;
+}
+
+inline void update_file_log(long int time, double latitude, double longitude,double altid, double ax,double ay,double az, double hx, double hy,double hz,double nVel, double eVel, double dVel){
+	fout_log << time << "," << std::setprecision(7) << latitude << "," << std::setprecision(7) << longitude << "," << std::setprecision(7) << altid
+				 << "," << ax << "," << ay << "," << az
+				 << "," << std::setprecision(7) << hx << "," << std::setprecision(7) << hy 
+				 << "," << hz << "," << nVel << "," << eVel << "," << dVel<< std::endl;
+}
+
+
+
+
+inline void close_file() {
+	printf("%s\n",__func__);
+	fout.close();
+}
+
+ inline void close_file_log() {
+	fout_log.close();
+}     
+
+
+#endif
+
+bool cmdOptionExists(char** begin, char** end, const std::string& option)
+{
+    return std::find(begin, end, option) != end;
+}
+
+void helpmenu(){
+    printf("\n-----HELP MENU-----\n");
+    printf("-h 'GPS Serial device'\n");
+    printf("-m magnetometer device number in %s\n",IIO_SYS_DIR);
+    printf("-g gyro device number in %s\n",IIO_SYS_DIR);
+    printf("-a accelerometer device number in %s\n",IIO_SYS_DIR);
+    printf("Sample cmdline: app_name -h /dev/ttySTM1 -g 0 -a 2 -m 3,\n where 0,2,3 are iio dev numbers in %s\n",IIO_SYS_DIR);
+    printf("\n---Menu Ends here---");
+}
+
+char *gyro_dev;
+char filename_csv[50];
+char *magn_dev;
+char *accel_dev;
+int filename_custom=0;
+
+int main(int argc, char** argv)
+{
+    std::thread gpsThread;
+    char *ttyName;
+    char *baudrate;
+    int brate = 115200;
+    char delim_s='/';
+    int accel_passed = 0;
+    int gyro_passed = 0;
+    int magn_passed = 0;
+    ttyName=(char *) malloc(sizeof(char)*30);
+    baudrate=(char *) malloc(sizeof(char)*30);
+    init_st_imulib();
+for (int i = 1; i < argc; i++) {
+
+    if (strcmp(argv[i],"-h")==0) {
+        strcpy(ttyName,argv[i+1]);
+        printf("ttyName: %s\n",ttyName);
+    } else if(strcmp(argv[i],"-b")==0){
+        strcpy(baudrate,argv[i+1]);
+        brate = atof(baudrate);	
+        printf("baudrate: %d\n",brate);
+    } else if (strcmp(argv[i],"-a")==0) {
+
+	accel_dev = (char *)malloc(strlen(IIO_SYS_DIR)+strlen(argv[i+1])+1);	
+	strcpy(accel_dev,IIO_SYS_DIR);
+	strcat(accel_dev,argv[i+1]);
+	strcat(accel_dev,&delim_s);
+	strcpy(g_imufds.accel_path,accel_dev);
+	printf("accel device node:%s\n",accel_dev);
+
+        int accel = atoi(argv[i + 1]);
+        printf("\naccel ID: %d",accel);
+        initAccel(accel_dev);
+	accel_passed = 1; 
+	
+    } else if (strcmp(argv[i],"-f")==0) {
+	printf("filename is:%s\n",argv[i+1]);
+	strcpy(filename_csv,argv[i+1]);
+	filename_custom = 1;
+    } else if (strcmp(argv[i],"-g")==0) {
+
+	gyro_dev = (char *)malloc(strlen(IIO_SYS_DIR)+strlen(argv[i+1])+1);	
+	strcpy(gyro_dev,IIO_SYS_DIR);
+	strcat(gyro_dev,argv[i+1]);
+	strcat(gyro_dev,&delim_s);
+	strcpy(g_imufds.gyro_path,gyro_dev);
+	printf("gyro device node:%s\n",gyro_dev);
+
+       int gyro = atoi(argv[i + 1]);
+        printf("\ngyro ID:%d",gyro);
+	initGyro(gyro_dev);
+	gyro_passed = 1; 
+
+    } else if (strcmp(argv[i],"-m")==0) {
+
+	magn_dev = (char *)malloc(strlen(IIO_SYS_DIR)+strlen(argv[i+1])+1);	
+	strcpy(magn_dev,IIO_SYS_DIR);
+	strcat(magn_dev,argv[i+1]);
+	strcat(magn_dev,&delim_s);
+	strcpy(g_imufds.magn_path,magn_dev);
+	printf("magn device node:%s\n",magn_dev);
+
+       int magnet = atof(argv[i + 1]);
+        printf("\ntmagnet id:%d",magnet);
+	initMagn(magn_dev);
+	magn_passed = 1; 
+    }
+
+}
+	if(magn_passed && gyro_passed && accel_passed){
+		printf("imu options passed correctly\n");
+	}else {
+		helpmenu();
+		return -1;	
+	}
+
+	
+
+
+    ekfNavINS ekf;
+    float ax, ay, az, hx, hy, hz, pitch, roll, yaw;
+    float latid,longid,altid;
+
+    signal(SIGINT, __signal_handler);
+    running = 1;
+
+
+
+
+    Stream seriComm(ttyName);
+    seriComm.begin(brate);
+    if (!seriComm.isConnected()) {
+        printf ("Please connect GNSS1 module and try again...\n");
+        return 0;
+    }
+
+    #ifdef NEW_TEST 
+	if(!filename_custom)
+		open_file(std::string("./gnss.csv"));
+	else
+		open_file(std::string(filename_csv));
+	//open_file(std::string("./gnss.csv"));
+	open_file_log(std::string("./data_log.csv"));
+    #endif
+    printf ("\n--------------------------------------------------------\n");
+	gpsThread = myGPS.initGPS(seriComm, NMEA);
+        //gpsThread.join();
+	int i = 0;
+	float init_longid=0;
+	float init_latid=0;
+	int is_latlon_init = 0;
+	int latlong_def_value = 0;
+	int init_latitlong=0;
+//#define TEST_OUTDOOR_ONLY
+#ifdef TEST_OUTDOOR_ONLY
+	printf("Test OUTDOOR macro case\n");
+	/*skip first value to avoid logging default value */
+	while(!init_latitlong){
+		usleep(100000);
+		longid = getLongitude();
+                latid = getLatitude();
+                altid = getAltitude();
+                if((longid == 0) || (latid == 0)){
+			continue;
+	        }
+		if(!latlong_def_value){
+			printf("non zero value found:%f, %f\n",longid,latid);
+			init_longid = longid;
+			init_latid = latid;
+			latlong_def_value=1;
+			continue;
+		}
+		if((longid != init_longid) ||(latid != init_latid) ){
+			printf("new latlong found:%f, %f\n",longid,latid);
+			init_latitlong = 1;
+		}
+	
+	}
+#endif
+	printf("Start logging Data,as new latlong value recieved!!!\n");
+	while(running){
+	    ax = g_imudata.accel_x_data;
+	    ay = g_imudata.accel_y_data;
+	    az = g_imudata.accel_z_data;
+
+	    hx = g_imudata.magn_x_data; 
+	    hy = g_imudata.magn_y_data; 
+	    hz = g_imudata.magn_z_data; 
+#if 0
+            std::tie(pitch,roll,yaw) = ekf.getPitchRollYaw(ax, ay, az, hx, hy, hz);
+
+            ekf.ekf_update(time(NULL) /*,gps.getTimeOfWeek()*/, getNedNorthVel()*1e-3, getNedEastVel()*1e-3, getNedDownVel()*1e-3,
+                        getLatitude()*1e-7*DEG_TO_RAD, getLongitude()*1e-7*DEG_TO_RAD, (getAltitude()*1e-3),
+                        g_imudata.gyro_x_data*DEG_TO_RAD, -1*g_imudata.gyro_y_data*DEG_TO_RAD, g_imudata.gyro_z_data*DEG_TO_RAD,                   
+                        ax, ay, az, hx, hy, hz);
+#else
+
+            std::tie(pitch,roll,yaw) = ekf.getPitchRollYaw(ax, ay, az, hx, hy, hz);
+		longid = getLongitude();
+                latid = getLatitude();
+                altid = getAltitude();
+
+                float north_vel = getNedNorthVel()*1e-3;
+		float east_vel = getNedEastVel()*1e-3;
+		float down_vel = getNedDownVel()*1e-3;
+//		printf("lat:%f,long:%f, height:%f\n",latid,longid,altid);
+               // printf("velocity:N:%f,E:%f, D:%f", north_vel,east_vel,down_vel);
+		//Update location only if long and latid are not zero!!!
+//#ifndef TEST_OUTDOOR_ONLY
+            if((longid != 0) &&(latid != 0) && (altid !=0 )){ /*altid is zero, TODO check */
+//#endif
+            	ekf.ekf_update(time(NULL) /*,gps.getTimeOfWeek()*/, getNedNorthVel()*1e-3, getNedEastVel()*1e-3, getNedDownVel()*1e-3,
+                        latid*1e-2*DEG_TO_RAD, longid*1e-2*DEG_TO_RAD, altid*1e-3,
+                        g_imudata.gyro_x_data*DEG_TO_RAD, -1*g_imudata.gyro_y_data*DEG_TO_RAD, g_imudata.gyro_z_data*DEG_TO_RAD,                   
+                        ax, ay, az, hx, hy, hz);
+//#ifndef TEST_OUTDOOR_ONLY
+	      }
+//#endif
+	
+#endif
+
+
+#ifdef NEW_TEST
+
+#if 0
+	    update_file(time(NULL), 
+						getLatitude()*1e-7, getLongitude()*1e-7,
+						roll, pitch, yaw,
+						ekf.getLatitude_rad()*RAD_TO_DEG, ekf.getLongitude_rad()*RAD_TO_DEG,
+						ekf.getRoll_rad(), ekf.getPitch_rad(), ekf.getHeading_rad());
+#else
+            if((longid != 0) &&(latid != 0)){
+	                         update_file(time(NULL), 
+                        			latid*1e-2, longid*1e-2, 
+						roll, pitch, yaw,
+						ekf.getLatitude_rad()*RAD_TO_DEG, ekf.getLongitude_rad()*RAD_TO_DEG,
+						ekf.getRoll_rad(), ekf.getPitch_rad(), ekf.getHeading_rad());
+
+
+	                         update_file_log(time(NULL), 
+                        			latid*1e-2, longid*1e-2,altid ,ax,ay,az,hx,hy,hz,
+						north_vel, east_vel, down_vel); 
+
+	     }
+
+#endif
+
+#endif
+	usleep(100000);
+	}
+
+        //sleep(10);
+#if 0
+    while(true) {
+        if (myGPS.getPVT()) {
+          printf ("%02d/%02d/%02d %02d:%02d:%02d %d:%d\n", myGPS.getDay(), myGPS.getMonth(), myGPS.getYear(), 
+                                                           myGPS.getHour(), myGPS.getMinute(), myGPS.getSecond(), 
+                                                           myGPS.getMillisecond(), myGPS.getNanosecond());
+          printf("Latitude                : %2.8f (deg)\n", myGPS.getLatitude() * 1e-7);
+          printf("Longitude               : %2.8f (deg)\n", myGPS.getLongitude() * 1e-7);
+          printf("Altitude                : %d (mm)\n", myGPS.getAltitude());
+          printf("Altitude MSL            : %d (mm)\n", myGPS.getAltitudeMSL());
+          printf("SIV                     : %d\n", myGPS.getSIV());
+          printf("PDOP                    : %f\n", myGPS.getPDOP() * 1e-2); 
+          printf("Fix type                : %d\n", myGPS.getFixType());
+          printf("Ground Speed            : %d\n", myGPS.getGroundSpeed());
+          printf("VelN                    : %08d (mm/s)\n", myGPS.getNedNorthVel());
+          printf("VelE                    : %08d (mm/s)\n", myGPS.getNedEastVel());
+          printf("VelD                    : %08d (mm/s)\n", myGPS.getNedDownVel());
+          printf("VAcc                    : %08d (mm)\n", myGPS.getVerticalAccEst());
+          printf("HAcc                    : %08d (mm)\n", myGPS.getHorizontalAccEst());
+          printf("SpeedAccEst             : %08d (mm/s)\n", myGPS.getSpeedAccEst());
+          printf("HeadAccEst              : %08d (degrees * 10^-5)\n", myGPS.getHeadingAccEst());
+          printf("HeadVehValid            : %s\n", myGPS.getHeadVehValid() ? "true" : "false");
+          printf("HeadVeh                 : %08d (degrees * 10^-5)\n", myGPS.getHeadVeh());
+          printf("MagDec                  : %08d (degrees * 10^-2)\n", myGPS.getMagDec());
+          printf("MagAcc                  : %08d (degrees * 10^-2)\n", myGPS.getMagAcc());
+          int solnType = myGPS.getCarrierSolutionType();
+          if (solnType == 0) printf ("### No RTK Fix yet ###\n");
+          else if (solnType == 1) printf ("&&& DGNSS/Float &&&\n");
+          else if (solnType == 2) printf ("*** DGNSS/Fix ***\n");
+          printf ("\n--------------------------------------------------------\n");
+          usleep(50);
+        }
+
+        usleep(25);
+    }
+#endif
+	printf("%s:calling gpsThread Join\n",__func__);
+        gpsThread.join();
+	printf("%s:close files:\n",__func__);
+	close_file();
+	close_file_log();
+    return 0;
+}
+
+
+
+
+
+
+
+void ekfNavINS::ekf_init(uint64_t time, double vn,double ve,double vd,double lat,double lon,double alt,float p,float q,float r,float ax,float ay,float az,float hx,float hy, float hz) {
+  // grab initial gyro values for biases
+  gbx = p;
+  gby = q;
+  gbz = r;
+  std::tie(theta,phi,psi) = getPitchRollYaw(ax, ay, az, hx, hy, hz);
+  // euler to quaternion
+  quat = toQuaternion(phi, theta, psi);
+  // Assemble the matrices
+  // ... gravity
+  grav(2,0) = G;
+  // ... H
+  H.block(0,0,5,5) = Eigen::Matrix<float,5,5>::Identity();
+  // ... Rw
+  Rw.block(0,0,3,3) = powf(SIG_W_A,2.0f) * Eigen::Matrix<float,3,3>::Identity();
+  Rw.block(3,3,3,3) = powf(SIG_W_G,2.0f) * Eigen::Matrix<float,3,3>::Identity();
+  Rw.block(6,6,3,3) = 2.0f * powf(SIG_A_D,2.0f) / TAU_A*Eigen::Matrix<float,3,3>::Identity();
+  Rw.block(9,9,3,3) = 2.0f * powf(SIG_G_D,2.0f) / TAU_G*Eigen::Matrix<float,3,3>::Identity();
+  // ... P
+  P.block(0,0,3,3) = powf(P_P_INIT,2.0f) * Eigen::Matrix<float,3,3>::Identity();
+  P.block(3,3,3,3) = powf(P_V_INIT,2.0f) * Eigen::Matrix<float,3,3>::Identity();
+  P.block(6,6,2,2) = powf(P_A_INIT,2.0f) * Eigen::Matrix<float,2,2>::Identity();
+  P(8,8) = powf(P_HDG_INIT,2.0f);
+  P.block(9,9,3,3) = powf(P_AB_INIT,2.0f) * Eigen::Matrix<float,3,3>::Identity();
+  P.block(12,12,3,3) = powf(P_GB_INIT,2.0f) * Eigen::Matrix<float,3,3>::Identity();
+  // ... R
+  R.block(0,0,2,2) = powf(SIG_GPS_P_NE,2.0f) * Eigen::Matrix<float,2,2>::Identity();
+  R(2,2) = powf(SIG_GPS_P_D,2.0f);
+  R.block(3,3,2,2) = powf(SIG_GPS_V_NE,2.0f) * Eigen::Matrix<float,2,2>::Identity();
+  R(5,5) = powf(SIG_GPS_V_D,2.0f);
+  // .. then initialize states with GPS Data
+  lat_ins = lat;
+  lon_ins = lon;
+  alt_ins = alt;
+  vn_ins = vn;
+  ve_ins = ve;
+  vd_ins = vd;
+  // specific force
+  f_b(0,0) = ax;
+  f_b(1,0) = ay;
+  f_b(2,0) = az;
+  /* initialize the time */
+  _tprev = time;
+}
+
+void ekfNavINS::ekf_update( uint64_t time/*, unsigned long TOW*/, double vn,double ve,double vd,double lat,double lon,double alt,
+                          float p,float q,float r,float ax,float ay,float az,float hx,float hy, float hz ) {
+  if (!initialized_) {
+    ekf_init(time, vn, ve, vd, lat, lon, alt, p, q, r, ax, ay, az, hx, hy, hz);
+    // initialized flag
+    initialized_ = true;
+  } else {
+    // get the change in time
+    float _dt = ((float)(time - _tprev)) / 1e6;
+    // Update Gyro and Accelerometer biases
+    updateBias(ax, ay, az, p, q, r);
+    // Update INS values
+    updateINS();
+    // Attitude Update
+    dq(0) = 1.0f;
+    dq(1) = 0.5f*om_ib(0,0)*_dt;
+    dq(2) = 0.5f*om_ib(1,0)*_dt;
+    dq(3) = 0.5f*om_ib(2,0)*_dt;
+    quat = qmult(quat,dq);
+    quat.normalize();
+    // Avoid quaternion flips sign
+    if (quat(0) < 0) {
+      quat = -1.0f*quat;
+    }
+    // AHRS Transformations
+    C_N2B = quat2dcm(quat);
+    C_B2N = C_N2B.transpose();
+    // obtain euler angles from quaternion
+    std::tie(phi, theta, psi) = toEulerAngles(quat);
+    // Velocity Update
+    dx = C_B2N*f_b + grav;
+    vn_ins += _dt*dx(0,0);
+    ve_ins += _dt*dx(1,0);
+    vd_ins += _dt*dx(2,0);
+    // Position Update
+    dxd = llarate(V_ins,lla_ins);
+    lat_ins += _dt*dxd(0,0);
+    lon_ins += _dt*dxd(1,0);
+    alt_ins += _dt*dxd(2,0);
+    // Jacobian update
+    updateJacobianMatrix();
+    // Update process noise and covariance time
+    updateProcessNoiseCovarianceTime(_dt);
+    // Gps measurement update
+    //if ((TOW - previousTOW) > 0) {
+    if ((time - _tprev) > 0) {
+      //previousTOW = TOW;
+      lla_gps(0,0) = lat;
+      lla_gps(1,0) = lon;
+      lla_gps(2,0) = alt;
+      V_gps(0,0) = vn;
+      V_gps(1,0) = ve;
+      V_gps(2,0) = vd;
+      // Update INS values
+      updateINS();
+      // Create measurement Y
+      updateCalculatedVsPredicted();
+      // Kalman gain
+      K = P*H.transpose()*(H*P*H.transpose() + R).inverse();
+      // Covariance update
+      P = (Eigen::Matrix<float,15,15>::Identity()-K*H)*P*(Eigen::Matrix<float,15,15>::Identity()-K*H).transpose() + K*R*K.transpose();
+      // State update
+      x = K*y;
+      // Update the results
+      update15statesAfterKF();
+      _tprev = time;
+    }
+    // Get the new Specific forces and Rotation Rate
+    updateBias(ax, ay, az, p, q, r);
+  }
+}
+
+void ekfNavINS::ekf_update(uint64_t time) {
+  std::shared_lock lock(shMutex);
+  ekf_update(time, /*0,*/ gpsVel.vN, gpsVel.vE, gpsVel.vD,
+                      gpsCoor.lat, gpsCoor.lon, gpsCoor.alt,
+                      imuDat.gyroX, imuDat.gyroY, imuDat.gyroZ,
+                      imuDat.accX, imuDat.accY, imuDat.accZ,
+                      imuDat.hX, imuDat.hY, imuDat.hZ);
+}
+
+void ekfNavINS::imuUpdateEKF(uint64_t time, imuData imu) {
+  {
+    std::unique_lock lock(shMutex);
+    imuDat = imu;
+  }
+  ekf_update(time);
+}
+
+void ekfNavINS::gpsCoordinateUpdateEKF(gpsCoordinate coor) {
+  std::unique_lock lock(shMutex);
+  gpsCoor = coor;
+}
+
+void ekfNavINS::gpsVelocityUpdateEKF(gpsVelocity vel) {
+  std::unique_lock lock(shMutex);
+  gpsVel = vel;
+}
+
+void ekfNavINS::updateINS() {
+  // Update lat, lng, alt, velocity INS values to matrix
+  lla_ins(0,0) = lat_ins;
+  lla_ins(1,0) = lon_ins;
+  lla_ins(2,0) = alt_ins;
+  V_ins(0,0) = vn_ins;
+  V_ins(1,0) = ve_ins;
+  V_ins(2,0) = vd_ins;
+}
+
+std::tuple<float,float,float> ekfNavINS::getPitchRollYaw(float ax, float ay, float az, float hx, float hy, float hz) {
+  // initial attitude and heading
+  theta = asinf(ax/G);
+  phi = -asinf(ay/(G*cosf(theta)));
+  // magnetic heading correction due to roll and pitch angle
+  Bxc = hx*cosf(theta) + (hy*sinf(phi) + hz*cosf(phi))*sinf(theta);
+  Byc = hy*cosf(phi) - hz*sinf(phi);
+  // finding initial heading
+  psi = -atan2f(Byc,Bxc);
+  //printf("\nax:%f,ay:%f,az:%f\n",ax,ay,az);
+ // printf("\nhx:%f,hy:%f,hz:%f\n",hx,hy,hz);
+ // printf("\npitch:%f,roll:%f,yaw:%f\n",theta,phi,psi);
+   /*check for nan*/
+  if(phi !=phi)
+	phi=0;
+  if(psi!=psi)
+	psi=0;
+  if(theta !=theta)
+	theta=0;
+  return (std::make_tuple(theta,phi,psi));
+}
+
+void ekfNavINS::updateCalculatedVsPredicted() {
+      // Position, converted to NED
+      pos_ecef_ins = lla2ecef(lla_ins);
+      pos_ecef_gps = lla2ecef(lla_gps);
+      pos_ned_gps = ecef2ned(pos_ecef_gps - pos_ecef_ins, lla_ins);
+      // Update the difference between calculated and predicted
+      y(0,0) = (float)(pos_ned_gps(0,0));
+      y(1,0) = (float)(pos_ned_gps(1,0));
+      y(2,0) = (float)(pos_ned_gps(2,0));
+      y(3,0) = (float)(V_gps(0,0) - V_ins(0,0));
+      y(4,0) = (float)(V_gps(1,0) - V_ins(1,0));
+      y(5,0) = (float)(V_gps(2,0) - V_ins(2,0));
+}
+
+void ekfNavINS::update15statesAfterKF() {
+      estmimated_ins = llarate ((x.block(0,0,3,1)).cast<double>(), lat_ins, alt_ins);
+      lat_ins += estmimated_ins(0,0);
+      lon_ins += estmimated_ins(1,0);
+      alt_ins += estmimated_ins(2,0);
+      vn_ins = vn_ins + x(3,0);
+      ve_ins = ve_ins + x(4,0);
+      vd_ins = vd_ins + x(5,0);
+      // Attitude correction
+      dq(0,0) = 1.0f;
+      dq(1,0) = x(6,0);
+      dq(2,0) = x(7,0);
+      dq(3,0) = x(8,0);
+      quat = qmult(quat,dq);
+      quat.normalize();
+      // obtain euler angles from quaternion
+      std::tie(phi, theta, psi) = toEulerAngles(quat);
+      abx = abx + x(9,0);
+      aby = aby + x(10,0);
+      abz = abz + x(11,0);
+      gbx = gbx + x(12,0);
+      gby = gby + x(13,0);
+      gbz = gbz + x(14,0);
+}
+
+void ekfNavINS::updateBias(float ax,float ay,float az,float p,float q, float r) {
+  f_b(0,0) = ax - abx;
+  f_b(1,0) = ay - aby;
+  f_b(2,0) = az - abz;
+  om_ib(0,0) = p - gbx;
+  om_ib(1,0) = q - gby;
+  om_ib(2,0) = r - gbz;
+}
+
+void ekfNavINS::updateProcessNoiseCovarianceTime(float _dt) {
+  PHI = Eigen::Matrix<float,15,15>::Identity()+Fs*_dt;
+  // Process Noise
+  Gs.setZero();
+  Gs.block(3,0,3,3) = -C_B2N;
+  Gs.block(6,3,3,3) = -0.5f*Eigen::Matrix<float,3,3>::Identity();
+  Gs.block(9,6,6,6) = Eigen::Matrix<float,6,6>::Identity();
+  // Discrete Process Noise
+  Q = PHI*_dt*Gs*Rw*Gs.transpose();
+  Q = 0.5f*(Q+Q.transpose());
+  // Covariance Time Update
+  P = PHI*P*PHI.transpose()+Q;
+  P = 0.5f*(P+P.transpose());
+}
+
+void ekfNavINS::updateJacobianMatrix() {
+    // Jacobian
+  Fs.setZero();
+  // ... pos2gs
+  Fs.block(0,3,3,3) = Eigen::Matrix<float,3,3>::Identity();
+  // ... gs2pos
+  Fs(5,2) = -2.0f*G/EARTH_RADIUS;
+  // ... gs2att
+  Fs.block(3,6,3,3) = -2.0f*C_B2N*sk(f_b);
+  // ... gs2acc
+  Fs.block(3,9,3,3) = -C_B2N;
+  // ... att2att
+  Fs.block(6,6,3,3) = -sk(om_ib);
+  // ... att2gyr
+  Fs.block(6,12,3,3) = -0.5f*Eigen::Matrix<float,3,3>::Identity();
+  // ... Accel Markov Bias
+  Fs.block(9,9,3,3) = -1.0f/TAU_A*Eigen::Matrix<float,3,3>::Identity();
+  Fs.block(12,12,3,3) = -1.0f/TAU_G*Eigen::Matrix<float,3,3>::Identity();
+}
+
+// This function gives a skew symmetric matrix from a given vector w
+Eigen::Matrix<float,3,3> ekfNavINS::sk(Eigen::Matrix<float,3,1> w) {
+  Eigen::Matrix<float,3,3> C;
+  C(0,0) = 0.0f;    C(0,1) = -w(2,0); C(0,2) = w(1,0);
+  C(1,0) = w(2,0);  C(1,1) = 0.0f;    C(1,2) = -w(0,0);
+  C(2,0) = -w(1,0); C(2,1) = w(0,0);  C(2,2) = 0.0f;
+  return C;
+}
+
+constexpr std::pair<double, double> ekfNavINS::earthradius(double lat) {
+  double denom = fabs(1.0 - (ECC2 * pow(sin(lat),2.0)));
+  double Rew = EARTH_RADIUS / sqrt(denom);
+  double Rns = EARTH_RADIUS * (1.0-ECC2) / (denom*sqrt(denom));
+  return (std::make_pair(Rew, Rns));
+}
+
+// This function calculates the rate of change of latitude, longitude, and altitude.
+Eigen::Matrix<double,3,1> ekfNavINS::llarate(Eigen::Matrix<double,3,1> V,Eigen::Matrix<double,3,1> lla) {
+  double Rew, Rns, denom;
+  Eigen::Matrix<double,3,1> lla_dot;
+  std::tie(Rew, Rns) = earthradius(lla(0,0));
+  lla_dot(0,0) = V(0,0)/(Rns + lla(2,0));
+  lla_dot(1,0) = V(1,0)/((Rew + lla(2,0))*cos(lla(0,0)));
+  lla_dot(2,0) = -V(2,0);
+  return lla_dot;
+}
+
+// This function calculates the rate of change of latitude, longitude, and altitude.
+Eigen::Matrix<double,3,1> ekfNavINS::llarate(Eigen::Matrix<double,3,1> V, double lat, double alt) {
+  Eigen::Matrix<double,3,1> lla;
+  lla(0,0) = lat;
+  lla(1,0) = 0.0; // Not used
+  lla(2,0) = alt;
+  return llarate(V, lla);
+}
+
+// This function calculates the ECEF Coordinate given the Latitude, Longitude and Altitude.
+Eigen::Matrix<double,3,1> ekfNavINS::lla2ecef(Eigen::Matrix<double,3,1> lla) {
+  double Rew, denom;
+  Eigen::Matrix<double,3,1> ecef;
+  std::tie(Rew, std::ignore) = earthradius(lla(0,0));
+  ecef(0,0) = (Rew + lla(2,0)) * cos(lla(0,0)) * cos(lla(1,0));
+  ecef(1,0) = (Rew + lla(2,0)) * cos(lla(0,0)) * sin(lla(1,0));
+  ecef(2,0) = (Rew * (1.0 - ECC2) + lla(2,0)) * sin(lla(0,0));
+  return ecef;
+}
+
+// This function converts a vector in ecef to ned coordinate centered at pos_ref.
+Eigen::Matrix<double,3,1> ekfNavINS::ecef2ned(Eigen::Matrix<double,3,1> ecef,Eigen::Matrix<double,3,1> pos_ref) {
+  Eigen::Matrix<double,3,1> ned;
+  ned(1,0)=-sin(pos_ref(1,0))*ecef(0,0) + cos(pos_ref(1,0))*ecef(1,0);
+  ned(0,0)=-sin(pos_ref(0,0))*cos(pos_ref(1,0))*ecef(0,0)-sin(pos_ref(0,0))*sin(pos_ref(1,0))*ecef(1,0)+cos(pos_ref(0,0))*ecef(2,0);
+  ned(2,0)=-cos(pos_ref(0,0))*cos(pos_ref(1,0))*ecef(0,0)-cos(pos_ref(0,0))*sin(pos_ref(1,0))*ecef(1,0)-sin(pos_ref(0,0))*ecef(2,0);
+  return ned;
+}
+
+// quaternion to dcm
+Eigen::Matrix<float,3,3> ekfNavINS::quat2dcm(Eigen::Matrix<float,4,1> q) {
+  Eigen::Matrix<float,3,3> C_N2B;
+  C_N2B(0,0) = 2.0f*powf(q(0,0),2.0f)-1.0f + 2.0f*powf(q(1,0),2.0f);
+  C_N2B(1,1) = 2.0f*powf(q(0,0),2.0f)-1.0f + 2.0f*powf(q(2,0),2.0f);
+  C_N2B(2,2) = 2.0f*powf(q(0,0),2.0f)-1.0f + 2.0f*powf(q(3,0),2.0f);
+
+  C_N2B(0,1) = 2.0f*q(1,0)*q(2,0) + 2.0f*q(0,0)*q(3,0);
+  C_N2B(0,2) = 2.0f*q(1,0)*q(3,0) - 2.0f*q(0,0)*q(2,0);
+
+  C_N2B(1,0) = 2.0f*q(1,0)*q(2,0) - 2.0f*q(0,0)*q(3,0);
+  C_N2B(1,2) = 2.0f*q(2,0)*q(3,0) + 2.0f*q(0,0)*q(1,0);
+
+  C_N2B(2,0) = 2.0f*q(1,0)*q(3,0) + 2.0f*q(0,0)*q(2,0);
+  C_N2B(2,1) = 2.0f*q(2,0)*q(3,0) - 2.0f*q(0,0)*q(1,0);
+  return C_N2B;
+}
+
+// quaternion multiplication
+Eigen::Matrix<float,4,1> ekfNavINS::qmult(Eigen::Matrix<float,4,1> p, Eigen::Matrix<float,4,1> q) {
+  Eigen::Matrix<float,4,1> r;
+  r(0,0) = p(0,0)*q(0,0) - (p(1,0)*q(1,0) + p(2,0)*q(2,0) + p(3,0)*q(3,0));
+  r(1,0) = p(0,0)*q(1,0) + q(0,0)*p(1,0) + p(2,0)*q(3,0) - p(3,0)*q(2,0);
+  r(2,0) = p(0,0)*q(2,0) + q(0,0)*p(2,0) + p(3,0)*q(1,0) - p(1,0)*q(3,0);
+  r(3,0) = p(0,0)*q(3,0) + q(0,0)*p(3,0) + p(1,0)*q(2,0) - p(2,0)*q(1,0);
+  return r;
+}
+
+// bound angle between -180 and 180
+float ekfNavINS::constrainAngle180(float dta) {
+  if(dta >  M_PI) dta -= (M_PI*2.0f);
+  if(dta < -M_PI) dta += (M_PI*2.0f);
+  return dta;
+}
+
+// bound angle between 0 and 360
+float ekfNavINS::constrainAngle360(float dta){
+  dta = fmod(dta,2.0f*M_PI);
+  if (dta < 0)
+    dta += 2.0f*M_PI;
+  return dta;
+}
+
+Eigen::Matrix<float,4,1> ekfNavINS::toQuaternion(float yaw, float pitch, float roll) {
+    float cy = cosf(yaw * 0.5f);
+    float sy = sinf(yaw * 0.5f);
+    float cp = cosf(pitch * 0.5f);
+    float sp = sinf(pitch * 0.5f);
+    float cr = cosf(roll * 0.5f);
+    float sr = sinf(roll * 0.5f);
+    Eigen::Matrix<float,4,1> q;
+    q(0) = cr * cp * cy + sr * sp * sy; // w
+    q(1) = cr * cp * sy - sr * sp * cy; // x
+    q(2) = cr * sp * cy + sr * cp * sy; // y
+    q(3) = sr * cp * cy - cr * sp * sy; // z
+    return q;
+}
+
+std::tuple<float, float, float> ekfNavINS::toEulerAngles(Eigen::Matrix<float,4,1> quat) {
+    float roll, pitch, yaw;
+    // roll (x-axis rotation)
+    float sinr_cosp = 2.0f * (quat(0,0)*quat(1,0)+quat(2,0)*quat(3,0));
+    float cosr_cosp = 1.0f - 2.0f * (quat(1,0)*quat(1,0)+quat(2,0)*quat(2,0));
+    roll = atan2f(sinr_cosp, cosr_cosp);
+    // pitch (y-axis rotation)
+    double sinp = 2.0f * (quat(0,0)*quat(2,0) - quat(1,0)*quat(3,0));
+    //angles.pitch = asinf(-2.0f*(quat(1,0)*quat(3,0)-quat(0,0)*quat(2,0)));
+    if (std::abs(sinp) >= 1)
+        pitch = std::copysign(M_PI / 2.0f, sinp); // use 90 degrees if out of range
+    else
+        pitch = asinf(sinp);
+    // yaw (z-axis rotation)
+    float siny_cosp = 2.0f * (quat(1,0)*quat(2,0)+quat(0,0)*quat(3,0));
+    float cosy_cosp = 1.0f - 2.0f * (quat(2,0)*quat(2,0)+quat(3,0)*quat(3,0));
+    yaw = atan2f(siny_cosp, cosy_cosp);
+    return std::make_tuple(roll, pitch, yaw);
+}
+
diff --git a/Ublox_Linux_Library/src/Print.cpp b/EKF_Linux_Library/src/Print.cpp
similarity index 99%
rename from Ublox_Linux_Library/src/Print.cpp
rename to EKF_Linux_Library/src/Print.cpp
index bc33ee1..288d9bd 100644
--- a/Ublox_Linux_Library/src/Print.cpp
+++ b/EKF_Linux_Library/src/Print.cpp
@@ -24,9 +24,6 @@
 #include <stdio.h>
 #include <string.h>
 #include <math.h>
-/*
-#include "Arduino.h"
-*/
 #include "Print.h"
 
 // Public Methods //////////////////////////////////////////////////////////////
diff --git a/Ublox_Linux_Library/src/Utils.cpp b/EKF_Linux_Library/src/Utils.cpp
similarity index 100%
rename from Ublox_Linux_Library/src/Utils.cpp
rename to EKF_Linux_Library/src/Utils.cpp
diff --git a/Ublox_Linux_Library/README.md b/Ublox_Linux_Library/README.md
deleted file mode 100644
index 9e741f2..0000000
--- a/Ublox_Linux_Library/README.md
+++ /dev/null
@@ -1,33 +0,0 @@
-# Ublox_Linux_Library
-The aim of this repository to port the SparkFun_u-blox_GNSS_Arduino_Library to linux platform.
-
-## How to pull the code
-* git clone https://github.com/balamuruganky/Ublox_Linux_Library
-* cd Ublox_Linux_Library
-* git submodule update --init
-
-## How to compile Linux Library (Assumed that CMake setup done already)
-* cd linux_build
-* mkdir build
-* cd build
-* cmake ..
-* make
-
-## How to compile Android Library (Assumed that NDK setup done already)
-* cd android_build
-* ndk-build -j2 NDK_PROJECT_PATH=. APP_BUILD_SCRIPT=./Android.mk NDK_APPLICATION_MK=./Application.mk
-
-## How to execute test
-* cd ../bin (Assuming the current directorty is build directory, created above)
-* ./ublox_f9p_test /dev/ttyACM0
-* ./ublox_f9p_i2c_test /dev/ublox_i2c 0x42 (or without command line arguments)
-
-## License
-This repository consists files from different other repositories such as Arduino and SparkFun_u-blox_GNSS_Arduino_Library. Please consider the licenses according to the files where it is from.
-
-## Linux Examples
-Feel free to port the examples from Sparkfun_Ublox_Arduino_Library to linux.
-
-## Future Work
-Port some important examples from Arduino to Linux
-
diff --git a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/CONTRIBUTING.md b/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/CONTRIBUTING.md
deleted file mode 100644
index f874edd..0000000
--- a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/CONTRIBUTING.md
+++ /dev/null
@@ -1,20 +0,0 @@
-# How to Contribute
-
-Thank you so *much* for offering to help out. We truly appreciate it.
-
-If you'd like to contribute, start by searching through the [issues](https://github.com/sparkfun/SparkFun_u-blox_GNSS_Arduino_Library/issues) and [pull requests](https://github.com/sparkfun/SparkFun_u-blox_GNSS_Arduino_Library/pulls) to see whether someone else has raised a similar idea or question.
-Please check the [closed issues](https://github.com/sparkfun/SparkFun_u-blox_GNSS_Arduino_Library/issues?q=is%3Aissue+is%3Aclosed)
-and [closed pull requests](https://github.com/sparkfun/SparkFun_u-blox_GNSS_Arduino_Library/pulls?q=is%3Apr+is%3Aclosed) too - you may find that your issue or feature has already been discussed.
-
-If you decide to add a feature to this library, please create a PR and follow these best practices:
-
-* Change as little as possible. Do not submit a PR that changes 100 lines of whitespace. Break up into multiple PRs if necessary.
-* If you've added a new feature document it with a simple example sketch. This serves both as a test of your PR and as a quick way for users to quickly learn how to use your new feature.
-* If you add new functions also add them to _keywords.txt_ so that they are properly highlighted in Arduino. [Read more](https://www.arduino.cc/en/Hacking/libraryTutorial).
-* **Important:** Please submit your PR using the [release_candidate branch](https://github.com/sparkfun/SparkFun_u-blox_GNSS_Arduino_Library/tree/release_candidate). That way, we can merge and test your PR quickly without changing the _master_ branch
-
-![Contributing.JPG](./img/Contributing.JPG)
-
-## Style guide
-
-Please read and follow the [Arduino API style guide](https://www.arduino.cc/en/Reference/APIStyleGuide). Also read and consider the [Arduino style guide](https://www.arduino.cc/en/Reference/StyleGuide).
diff --git a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/ISSUE_TEMPLATE.md b/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/ISSUE_TEMPLATE.md
deleted file mode 100644
index 84ae55b..0000000
--- a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/ISSUE_TEMPLATE.md
+++ /dev/null
@@ -1,18 +0,0 @@
-### Subject of the issue
-Describe your issue here. If you reference a datasheet please specify which one and in which section (ie, the protocol manual, section 5.1.2). Additionally, screenshots are easy to paste into github.
-
-### Your workbench
-* What development board or microcontroller are you using?
-* What version of hardware or breakout board are you using? 
-* How is the breakout board wired to your microcontroller?
-* How is everything being powered?
-* Are there any additional details that may help us help you?
-
-### Steps to reproduce
-Tell us how to reproduce this issue. Please post stripped down example code demonstrating your issue.
-
-### Expected behavior
-Tell us what should happen
-
-### Actual behavior
-Tell us what happens instead
diff --git a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/LICENSE.md b/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/LICENSE.md
deleted file mode 100644
index e64bd4e..0000000
--- a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/LICENSE.md
+++ /dev/null
@@ -1,55 +0,0 @@
-SparkFun License Information
-============================
-
-SparkFun uses two different licenses for our files — one for hardware and one for code.
-
-Hardware
----------
-
-**SparkFun hardware is released under [Creative Commons Share-alike 4.0 International](http://creativecommons.org/licenses/by-sa/4.0/).**
-
-Note: This is a human-readable summary of (and not a substitute for) the [license](http://creativecommons.org/licenses/by-sa/4.0/legalcode).
-
-You are free to:
-
-Share — copy and redistribute the material in any medium or format
-Adapt — remix, transform, and build upon the material
-for any purpose, even commercially.
-The licensor cannot revoke these freedoms as long as you follow the license terms.
-Under the following terms:
-
-Attribution — You must give appropriate credit, provide a link to the license, and indicate if changes were made. You may do so in any reasonable manner, but not in any way that suggests the licensor endorses you or your use.
-ShareAlike — If you remix, transform, or build upon the material, you must distribute your contributions under the same license as the original.
-No additional restrictions — You may not apply legal terms or technological measures that legally restrict others from doing anything the license permits.
-Notices:
-
-You do not have to comply with the license for elements of the material in the public domain or where your use is permitted by an applicable exception or limitation.
-No warranties are given. The license may not give you all of the permissions necessary for your intended use. For example, other rights such as publicity, privacy, or moral rights may limit how you use the material.
-
-
-Code
---------
-
-**SparkFun code, firmware, and software is released under the MIT License(http://opensource.org/licenses/MIT).**
-
-The MIT License (MIT)
-
-Copyright (c) 2016 SparkFun Electronics
-
-Permission is hereby granted, free of charge, to any person obtaining a copy
-of this software and associated documentation files (the "Software"), to deal
-in the Software without restriction, including without limitation the rights
-to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-copies of the Software, and to permit persons to whom the Software is
-furnished to do so, subject to the following conditions:
-
-The above copyright notice and this permission notice shall be included in all
-copies or substantial portions of the Software.
-
-THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
-SOFTWARE.
diff --git a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/README.md b/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/README.md
deleted file mode 100644
index 1eb267f..0000000
--- a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/README.md
+++ /dev/null
@@ -1,107 +0,0 @@
-# SparkFun u-blox Arduino GNSS Library
-
-<table class="table table-hover table-striped table-bordered">
-  <tr align="center">
-   <td><a href="https://www.sparkfun.com/products/15136"><img src="https://cdn.sparkfun.com//assets/parts/1/3/5/1/4/15136-SparkFun_GPS-RTK2_Board_-_ZED-F9P__Qwiic_-03.jpg"></a></td>
-   <td><a href="https://www.sparkfun.com/products/15005"><img src="https://cdn.sparkfun.com//assets/parts/1/3/3/2/0/15005-SparkFun_GPS-RTK__Qwiic__-_NEO-M8P-2-00.jpg"></a></td>
-   <td><a href="https://www.sparkfun.com/products/15193"><img src="https://cdn.sparkfun.com//assets/parts/1/3/6/1/4/15193-SparkFun_GPS_Breakout_-_U.FL__ZOE-M8__Qwiic_-01.jpg"></a></td>
-   <td><a href="https://www.sparkfun.com/products/15210"><img src="https://cdn.sparkfun.com//assets/parts/1/3/6/4/8/15210-SparkFun_GPS_Breakout_-_Chip_Antenna__SAM-M8Q__Qwiic_-01.jpg"></a></td>
-    <td><a href="https://www.sparkfun.com/products/15733"><img src="https://cdn.sparkfun.com//assets/parts/1/4/3/2/2/15733-SparkFun_GPS_Breakout_-_NEO-M9N__Chip_Antenna__Qwiic_-01.jpg"></a></td>
-  </tr>
-  <tr align="center">
-    <td><a href="https://www.sparkfun.com/products/15136">SparkFun GPS-RTK2 - ZED-F9P (GPS-15136)</a></td>
-    <td><a href="https://www.sparkfun.com/products/15005">SparkFun GPS-RTK - NEO-M8P-2 (GPS-15005)</a></td>
-    <td><a href="https://www.sparkfun.com/products/15193">SparkFun ZOE-M8Q Breakout (GPS-15193)</a></td>
-    <td><a href="https://www.sparkfun.com/products/15210">SparkFun SAM-M8Q Breakout (GPS-15210)</a></td>
-    <td><a href="https://www.sparkfun.com/products/15733">SparkFun NEO-M9N Breakout (GPS-15733)</a></td>
-  </tr>
-</table>
-
-u-blox makes some incredible GNSS receivers covering everything from low-cost, highly configurable modules such as the SAM-M8Q all the way up to the surveyor grade ZED-F9P with precision of the diameter of a dime. This library focuses on configuration and control of u-blox devices over I<sup>2</sup>C (called DDC by u-blox) and Serial. The UBX protocol is supported over both I<sup>2</sup>C and serial, and is a much easier and lighterweight interface to a GNSS module. Stop polling messages and parsing NMEA data! Simply ask for the datums you need and receive an automatic callback when they arrive.
-
-This library can be installed via the Arduino Library manager. Search for **SparkFun u-blox GNSS**.
-
-## v2.0
-
-This library is the new and improved version of the very popular SparkFun u-blox GNSS Arduino Library. v2.0 contains some big changes and improvements:
-
-* Seamless support for "automatic" message delivery:
-  * In v1.8, you could ask for the NAV PVT (Navigation Position Velocity Time) message to be delivered _automatically_, without polling. v2.0 adds automatic support for [**23 messages**](./Theory.md#auto-messages), covering the full range of: standard and High Precision position, velocity and time information; relative positioning; event capture with nanosecond time resolution; raw GNSS signal data including carrier phase; Sensor Fusion; and High Navigation Rate data.
-* Dynamic memory allocation with clearly-defined data storage structs for each message:
-  * There are no static 'global' variables to eat up your RAM. v2.0 automatically allocates memory for the automatic messages when they are enabled. You may find your total RAM use is lower with v2.0 than with v1.8.
-  * Each "auto" message has a clearly-defined [data storage struct](./src/u-blox_structs.h) which follows the u-blox protocol specification precisely.
-* Callbacks:
-  * No more polling! Simply request the "auto" messages you need and receive an automatic callback when each message arrives.
-  * Please see the [callback examples](./examples/Callbacks) for more details.
-* Built-in support for data logging:
-  * Want to log RXM SFRBX and RAWX data for Post-Processed Kinematics or Precise Point Positioning? You can absolutely do that! v2.0 provides built-in support for data logging, allowing you to log **any** of the "auto" messages simply and easily.
-  * Incoming "auto" data can be stored in a configurable ring buffer. You can then extract the data from the buffer and write it to (e.g.) SD card using your favorite SD library.
-  * Data is logged in u-blox UBX format which is compact and efficient. You can replay the data using [u-center](https://www.u-blox.com/en/product/u-center).
-  * Please see the [data logging examples](./examples/Data_Logging) for more details.
-
-## Migrating to v2.0
-
-Migrating to v2.0 is easy. There are two small changes all users will need to make:
-
-* The name of the library class has changed from ```SFE_UBLOX_GPS``` to ```SFE_UBLOX_GNSS``` to reflect that the library supports all of the Global Navigation Satellite Systems:
-  * As a minimum, you need to change: ```SFE_UBLOX_GPS myGPS;```
-  * to: ```SFE_UBLOX_GNSS myGPS;```
-  * But we would encourage you to use ```SFE_UBLOX_GNSS myGNSS;```. You will see that all of the library examples now use ```myGNSS``` instead of ```myGPS```.
-* The name of the library header and C++ files have changed too:
-  * Change: ```#include <SparkFun_Ublox_Arduino_Library.h>```
-  * to: ```#include <SparkFun_u-blox_GNSS_Arduino_Library.h>```
-
-If you are using the Dead Reckoning Sensor Fusion or High Dynamic Rate messages, you will need to make more small changes to your code. Please see the [dead reckoning examples](./examples/Dead_Reckoning) for more details. There is more detail available in [Theory.md](./Theory.md#migrating-your-code-to-v20) if you need it.
-
-## Max (400kHz) I<sup>2</sup>C Support
-
-To achieve 400kHz I<sup>2</sup>C speed please be sure to remove all pull-ups on the I<sup>2</sup>C bus. Most, if not all, u-blox modules include internal pull ups on the I<sup>2</sup>C lines (sometimes called DDC in their manuals). Cut all I<sup>2</sup>C pull up jumpers and/or remove them from peripheral boards. Otherwise, various data glitches can occur. See issues [38](https://github.com/sparkfun/SparkFun_Ublox_Arduino_Library/issues/38) and [40](https://github.com/sparkfun/SparkFun_Ublox_Arduino_Library/issues/40) for more information. If possible, run the I<sup>2</sup>C bus at 100kHz.
-
-## Contributing
-
-If you would like to contribute to this library: please do, we truly appreciate it, but please follow [these guidelines](./CONTRIBUTING.md). Thanks!
-
-## Repository Contents
-
-* [**/examples**](./examples) - Example sketches for the library (.ino). Run these from the Arduino IDE.
-* [**/src**](./src) - Source files for the library (.cpp, .h).
-* [**keywords.txt**](./keywords.txt) - Keywords from this library that will be highlighted in the Arduino IDE.
-* [**library.properties**](./library.properties) - General library properties for the Arduino package manager.
-* [**CONTRIBUTING.md**](./CONTRIBUTING.md) - Guidelines on how to contribute to this library.
-* [**Theory.md**](./Theory.md) - provides detail on how data is processed by the library.
-* [**/Utils**](./Utils) - contains a Python utility which can check the contents of UBX log files.
-
-## Documentation
-
-* [**Installing an Arduino Library Guide**](https://learn.sparkfun.com/tutorials/installing-an-arduino-library) - Basic information on how to install an Arduino library.
-
-## Theory
-
-If you would like to learn more about how this library works, including the big changes we made in version 2.0, please see [**Theory.md**](./Theory.md) for full details.
-
-## Products That Use This Library
-
-* [GPS-16481](https://www.sparkfun.com/products/16481) - SparkFun GPS-RTK-SMA Breakout - ZED-F9P (Qwiic)
-* [GPS-15136](https://www.sparkfun.com/products/15136) - SparkFun GPS-RTK2 Board - ZED-F9P (Qwiic)
-* [GPS-16344](https://www.sparkfun.com/products/16344) - SparkFun GPS-RTK Dead Reckoning Breakout - ZED-F9R (Qwiic)
-* [GPS-15005](https://www.sparkfun.com/products/15005) - SparkFun GPS-RTK Board - NEO-M8P-2 (Qwiic)
-* [GPS-15210](https://www.sparkfun.com/products/15210) - SparkFun GPS Breakout - Chip Antenna, SAM-M8Q (Qwiic)
-* [GPS-15193](https://www.sparkfun.com/products/15193) - SparkFun GPS Breakout - Chip Antenna, ZOE-M8Q (Qwiic)
-* [GPS-17285](https://www.sparkfun.com/products/17285) - SparkFun GPS Breakout - NEO-M9N, SMA (Qwiic)
-* [GPS-15733](https://www.sparkfun.com/products/15733) - SparkFun GPS Breakout - NEO-M9N, Chip Antenna (Qwiic)
-* [GPS-15712](https://www.sparkfun.com/products/15712) - SparkFun GPS Breakout - NEO-M9N, U.FL (Qwiic)
-* [GPS-16329](https://www.sparkfun.com/products/16329) - SparkFun GPS Dead Reckoning Breakout - NEO-M8U (Qwiic)
-* [SPX-14980](https://www.sparkfun.com/products/14980) - SparkX GPS-RTK Black
-* [SPX-15106](https://www.sparkfun.com/products/15106) - SparkX SAM-M8Q
-
-## License Information
-
-This product is _**open source**_!
-
-Various bits of the code have different licenses applied. Anything SparkFun wrote is beerware; if you see me (or any other SparkFun employee) at the local, and you've found our code helpful, please buy us a round!
-
-Please use, reuse, and modify these files as you see fit. Please maintain attribution to SparkFun Electronics and release anything derivative under the same license.
-
-Distributed as-is; no warranty is given.
-
-- Your friends at SparkFun.
diff --git a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/Theory.md b/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/Theory.md
deleted file mode 100644
index eb8bdd3..0000000
--- a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/Theory.md
+++ /dev/null
@@ -1,127 +0,0 @@
-## How I<sup>2</sup>C (aka DDC) communication works with a u-blox module
-
-When the user calls one of the methods the library will poll the u-blox module for new data.
-
-* Wait for a minimum of 25 ms between polls (configured dynamically when update rate is set)
-* Write 0xFD to module
-* Read two bytes (0xFD and 0xFE) for bytes available
-* If 0x7F or 0xFF then no bytes are available
-* Otherwise, read number of bytes and process into NMEA, UBX, or RTCM frame.
-* If checksum is valid, flag frame as complete.
-
-This library was originally written to use the I<sup>2</sup>C interface but Serial has been implemented as well.
-
-## How data is processed by this library
-
-In Version 1 of this library, we tried to minimize memory usage by being very careful about how much RAM we allocated to UBX packet storage and processing. We used only three buffers or containers to store the incoming data: **packetBuf** (packetBuffer); **packetCfg** (packetConfiguration); and **packetAck** (packetAcknowledge). Incoming packets were stored in **packetBuf** initially and then diverted into **packetAck** or **packetCfg** as necessary. Once data was received and validated, it would be copied out of **packetCfg** and into 'global' variables with names like ```gpsSecond``` or ```latitude```. We also introduced the concept of _Polling vs. Auto-Reporting_ where messages like PVT (Position, Velocity, Time) could be generated and parsed "automatically". This meant that functions like ```getLatitude``` could be non-blocking, returning the most recent data and requesting fresh data when necessary. But it also meant that _polled_ messages could be _overwritten_ (in **packetCfg**) by any _auto-reported_ messages. The library dealt with this successfully, but it was a headache.
-
-Version 1 had two main drawbacks. As time went on:
-- the RAM use increased as we had to add new 'global' storage for each new data type
-- the number of messages which needed "auto" processing through **packetCfg** became complex, requiring significant code changes each time a new "auto" message was added. (We started with NAV-PVT. Then came NAV-HPPOSLLH and NAV-DOP. Things got complicated when HNR-ATT, HNR-INS and HNR-PVT were added to the mix.)
-
-Version 2 of the library does things differently. Whilst of course trying to keep the library backward-compatible as much as possible, we have taken a fresh approach:
-- We have added **packetAuto** which is used to temporarily buffer expected auto-reported messages and prevents data from being overwritten in **packetCfg**.
-  - The payload for **packetAuto** is allocated dynamically in RAM and deleted after use.
-  - If insufficient RAM is available, the code falls back to using **packetCfg** to buffer the data instead.
-- The library no longer uses 'global' (permanently-allocated) storage for the GNSS data. Instead:
-  - Each message type has a **typedef struct** defined which matches the format of the UBX message. (_typedef structs_ are just definitions, they don't occupy memory.) You can find the definitions in [_**u-blox_structs.h**_](./src/u-blox_structs.h).
-  - The struct allows each data field (latitude, longitude, etc.) to be read simply and easily using dot notation. Flags etc. are supported by bit definitions in the struct. The field names are as defined in the u-blox interface description.
-  - Storage for that message is only _allocated_ in RAM if/when required. The allocation is done using _new_ via a pointer to the struct.
-- _Any_ message can be "auto" if required, but can be polled too.
-- An optional _callback_ can be associated with the arrival of each message type. A simple scheduler ```checkCallbacks``` triggers the callbacks once I<sup>2</sup>C/Serial data reception is complete.
-  - This means that your code no longer needs to wait for the arrival of a message, you are able to request (e.g.) PVT or HNR data and your callback is called once the data arrives.
-  - The callbacks are not re-entrant.
-  - The callback receives a _copy_ of the data, so data reception and processing can continue while the callback is executing. Data integrity is preserved. You can call ```checkUblox()``` from inside a callback if needed.
-- Incoming data can be copied to a separate buffer to allow automatic writing to a file on SD card, which will be useful for (e.g.) RAWX logging.
-  - Data is stored in a RingBuffer, the size of which can be set by calling ```setFileBufferSize``` _before_ ```.begin```.
-  - The default buffer size is zero - to save memory.
-  - To simplify SD card writing, data can be copied from the RingBuffer to a user-defined linear buffer first using ```extractFileBufferData```.
-  - Data reception and processing can continue during the SD write.
-  - User-defined code does the actual writing of data from the linear buffer to the SD card. The u-blox GNSS library itself does not perform the writing and so is not tied to any particular SD library.
-  - The logged files can be played back and analyzed with (e.g.) u-center or RTKLIB.
-
-In terms of RAM, you may find that your total RAM use is lower using v2 compared to v1, but it does of course depend on how many message types are being processed. The downside to this is that it is difficult to know in advance how much RAM is required, since it is only allocated if/when required. If the processor runs out of RAM (i.e. the _new_ fails) then a debug error message is generated.
-
-## "Auto" messages
-
-In v2.0, the full list of messages which can be processed and logged automatically is:
-- UBX-NAV-POSECEF (0x01 0x01): Position solution in ECEF
-- UBX-NAV-STATUS (0x01 0x03): Receiver navigation status
-- UBX-NAV-DOP (0x01 0x04): Dilution of precision
-- UBX-NAV-ATT (0x01 0x05): Attitude solution (**only with ADR or UDR products**)
-- UBX-NAV-PVT (0x01 0x07): Navigation position velocity time solution
-- UBX-NAV-ODO (0x01 0x09): Odometer solution
-- UBX-NAV-VELECEF (0x01 0x11): Velocity solution in ECEF
-- UBX-NAV-VELNED (0x01 0x12): Velocity solution in NED frame
-- UBX-NAV-HPPOSECEF (0x01 0x13): High precision position solution in ECEF
-- UBX-NAV-HPPOSLLH (0x01 0x14): High precision geodetic position solution
-- UBX-NAV-CLOCK (0x01 0x22): Clock solution
-- UBX-NAV-SVIN (0x01 0x3B): Survey-in data (**only with High Precision GNSS products**)
-- UBX-NAV-RELPOSNED (0x01 0x3C): Relative positioning information in NED frame (**only with High Precision GNSS products**)
-- UBX-RXM-SFRBX (0x02 0x13): Broadcast navigation data subframe
-- UBX-RXM-RAWX (0x02 0x15): Multi-GNSS raw measurement data (**only with ADR or High Precision GNSS or Time Sync products**)
-- UBX-TIM-TM2 (0x0D 0x03): Time mark data
-- UBX-ESF-ALG (0x10 0x14): IMU alignment information (**only with ADR or UDR products**)
-- UBX-ESF-INS (0x10 0x15): Vehicle dynamics information (**only with ADR or UDR products**)
-- UBX-ESF-MEAS (0x10 0x02): External sensor fusion measurements (**only with ADR or UDR products**)
-- UBX-ESF-RAW (0x10 0x03): Raw sensor measurements (**only with ADR or UDR products**)
-- UBX-ESF-STATUS (0x10 0x10): External sensor fusion status (**only with ADR or UDR products**)
-- UBX-HNR-PVT (0x28 0x00): High rate output of PVT solution (**only with ADR or UDR products**)
-- UBX-HNR-ATT (0x28 0x01): Attitude solution (**only with ADR or UDR products**)
-- UBX-HNR-INS (0x28 0x02): Vehicle dynamics information (**only with ADR or UDR products**)
-
-Notes:
-- UBX-NAV-POSLLH is not supported as UBX-NAV-PVT contains the same information
-- UBX-NAV-TIMEUTC is not supported as UBX-NAV-PVT contains the same information
-
-## Migrating your code to v2.0
-
-Migrating to v2.0 is easy. There are two small changes all users will need to make:
-
-* The name of the library class has changed from ```SFE_UBLOX_GPS``` to ```SFE_UBLOX_GNSS``` to reflect that the library supports all of the Global Navigation Satellite Systems:
-  * As a minimum, you need to change: ```SFE_UBLOX_GPS myGPS;```
-  * to: ```SFE_UBLOX_GNSS myGPS;```
-  * But we would encourage you to use ```SFE_UBLOX_GNSS myGNSS;```. You will see that all of the library examples now use ```myGNSS``` instead of ```myGPS```.
-* The name of the library header and C++ files have changed too:
-  * Change: ```#include <SparkFun_Ublox_Arduino_Library.h>```
-  * to: ```#include <SparkFun_u-blox_GNSS_Arduino_Library.h>```
-
-The biggest change in v2.0 is that data is now stored in a _struct_ which matches the u-blox interface description for that message. For example:
-- In v1, the NAV PVT (Position Velocity Time) latitude and longitude were stored in 'global' _int32_t_ variables called ```latitude``` and ```longitude```
-  - In v2.0, the data is now stored in <strong>UBX_NAV_PVT_t *packetUBXNAVPVT</strong>
-  - ```myGPS.latitude``` becomes ```myGNSS.packetUBXNAVPVT->data.lat```
-  - ```myGPS.longitude``` becomes ```myGNSS.packetUBXNAVPVT->data.lon```
-  - The helper functions ```myGNSS.getLatitude()``` and ```myGNSS.getLongitude()``` are still available and work in the same way.
-- In v1, the ESF Sensor Fusion data for the Dead Reckoning modules was stored in 'global' variables ```imuMeas```, ```ubloxSen``` and ```vehAtt```
-  - In v2.0, the data is now stored in:
-  - <strong>UBX_ESF_ALG_t *packetUBXESFALG</strong> contains the IMU alignment information (roll, pitch and yaw)
-  - <strong>UBX_ESF_INS_t *packetUBXESFINS</strong> contains the vehicle dynamics information (acceleration and angular rate)
-  - <strong>UBX_ESF_MEAS_t *packetUBXESFMEAS</strong> contains the sensor fusion measurements
-  - <strong>UBX_ESF_RAW_t *packetUBXESFRAW</strong> contains the raw sensor measurements
-  - <strong>UBX_ESF_STATUS_t *packetUBXESFSTATUS</strong> contains the sensor fusion status
-  - e.g. ```myGPS.imuMeas.fusionMode``` becomes ```myGNSS.packetUBXESFSTATUS->data.fusionMode```
-  - The helper functions ```getSensorFusionMeasurement```, ```getRawSensorMeasurement``` and ```getSensorFusionStatus``` can be used to extract the sensor data for an individual sensor
-  - "auto" data can be marked as stale by calling (e.g.) ```myGNSS.flushESFALG()```
-  - Please see the [**Dead_Reckoning/Example4_vehicleDynamics**](./examples/Dead_Reckoning/Example4_vehicleDynamics/Example4_vehicleDynamics.ino) example for more details
-- In v1, the HNR (High Navigation Rate) data for the Dead Reckoning modules was stored in 'global' variables ```hnrAtt```, ```hnrVehDyn``` and ```hnrPVT```
-  - In v2.0, e.g.:
-  - ```myGPS.hnrAtt.roll``` becomes ```myGNSS.packetUBXHNRATT->data.roll```
-  - ```myGPS.hnrVehDyn.xAccel``` becomes ```myGNSS.packetUBXHNRINS->data.xAccel```
-  - ```myGPS.hnrPVT.lat``` becomes ```myGNSS.packetUBXHNRPVT->data.lat```
-  - "auto" data can be marked as stale by calling (e.g.) ```myGNSS.flushHNRATT()```
-  - Please see the [**Dead_Reckoning/Example6_getAutoHNRData**](./examples/Dead_Reckoning/Example6_getAutoHNRData/Example6_getAutoHNRData.ino) example for more details
-
-Other changes include:
-- In v1, NAV_RELPOSNED relPosN, relPosE and relPosD were returned as (float)m. In v2.0 they are returned via <strong>packetUBXNAVRELPOSNED->data.relPosN</strong> (etc.) as (int32_t)cm.
-  - New helper functions (```getRelPosN```, ```getRelPosE``` and ```getRelPosD```) provide backward-compatibility
-  - Please see the [**ZED-F9P/Example5_RelativePositioningInformation**](./examples/ZED-F9P/Example5_RelativePositioningInformation/Example5_RelativePositioningInformation.ino) example for more details
-- In v1, NAV_RELPOSNED accN, accE and accD were returned as (float)m. In v2.0 they are returned via <strong>packetUBXNAVRELPOSNED->data.accN</strong> (etc.) as (uint32_t)mm*0.1.
-  - New helper functions (```getRelPosAccN```, ```getRelPosAccE``` and ```getRelPosAccD```) provide backward-compatibility
-  - Please see the [**ZED-F9P/Example5_RelativePositioningInformation**](./examples/ZED-F9P/Example5_RelativePositioningInformation/Example5_RelativePositioningInformation.ino) example for more details
-- getSurveyStatus now returns data via <strong>UBX_NAV_SVIN_t *packetUBXNAVSVIN</strong>
-  - ```myGPS.svin.active``` becomes ```myGNSS.packetUBXNAVSVIN->data.active```
-  - ```myGPS.svin.valid``` becomes ```myGNSS.packetUBXNAVSVIN->data.valid```
-  - ```myGPS.svin.observationTime``` becomes ```myGNSS.packetUBXNAVSVIN->data.dur``` and is now uint32_t (not uint16_t)
-  - ```myGPS.svin.MeanAccuracy``` becomes ```myGNSS.packetUBXNAVSVIN->data.meanAcc``` and is now uint32_t * 0.1mm (not float * m)
-  - New helper functions (```getSurveyInActive```, ```getSurveyInValid```, ```getSurveyInObservationTime``` and ```getSurveyInMeanAccuracy```) provide backward-compatibility
-  - Please see the [**ZED-F9P/Example3_StartRTCMBase**](./examples/ZED-F9P/Example3_StartRTCMBase/Example3_StartRTCMBase.ino) example for more details
diff --git a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/Utils/UBX_Integrity_Checker.py b/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/Utils/UBX_Integrity_Checker.py
deleted file mode 100644
index 2fac318..0000000
--- a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/Utils/UBX_Integrity_Checker.py
+++ /dev/null
@@ -1,399 +0,0 @@
-# Checks the integrity of u-blox binary files
-
-# Written by: Paul Clark
-# Last update: August 26th 2020
-
-# Reads a UBX file and checks the integrity of both UBX and NMEA data
-# Will rewind and re-sync if an error is found
-
-# SparkFun code, firmware, and software is released under the MIT License (http://opensource.org/licenses/MIT)
-#
-# The MIT License (MIT)
-#
-# Copyright (c) 2020 SparkFun Electronics
-#
-# Permission is hereby granted, free of charge, to any person obtaining a copy
-# of this software and associated documentation files (the "Software"), to deal
-# in the Software without restriction, including without limitation the rights
-# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-# copies of the Software, and to permit persons to whom the Software is
-# furnished to do so, subject to the following conditions:
-#
-# The above copyright notice and this permission notice shall be included in all
-# copies or substantial portions of the Software.
-#
-# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
-# SOFTWARE.
-
-import sys
-import os
-
-# Add byte to checksums sum1 and sum2
-def csum(byte, sum1, sum2):
-    sum1 = sum1 + byte
-    sum2 = sum2 + sum1
-    sum1 = sum1 & 0xFF
-    sum2 = sum2 & 0xFF
-    return sum1,sum2
-
-print('UBX Integrity Checker')
-print()
-
-filename = ''
-
-if filename == '':
-    # Check if the bin filename was passed in argv
-    if len(sys.argv) > 1: filename = sys.argv[1]
-
-# Find first .ubx file in the current directory
-firstfile = ''
-for root, dirs, files in os.walk("."):
-    if len(files) > 0:
-        if root == ".": # Comment this line to check sub-directories too
-            for afile in files:
-                if afile[-4:] == '.ubx':
-                    if firstfile == '': firstfile = os.path.join(root, afile)
-
-# Ask user for .bin filename offering firstfile as the default
-if filename == '': filename = input('Enter the UBX filename (default: ' + firstfile + '): ') # Get the filename
-if filename == '': filename = firstfile
-
-# Ask user if the data contains NMEA messages
-response = input('Could this file contain any NMEA messages? (Y/n): ') # Get the response
-if (response == '') or (response == 'Y') or (response == 'y'):
-    containsNMEA = True
-else:
-    containsNMEA = False
-
-print()
-print('Processing',filename)
-print()
-filesize = os.path.getsize(filename) # Record the file size
-
-# Try to open file for reading
-try:
-    fi = open(filename,"rb")
-except:
-    raise Exception('Invalid file!')
-
-processed = -1 # The nunber of bytes processed
-messages = {} # The collected message types
-longest = 0 # The length of the longest UBX message
-keepGoing = True
-
-# Sync 'state machine'
-looking_for_B5_dollar   = 0 # Looking for either a UBX 0xB5 or an NMEA '$'
-looking_for_62          = 1 # Looking for a UBX 0x62 header byte
-looking_for_class       = 2 # Looking for UBX class byte
-looking_for_ID          = 3 # Looking for UBX ID byte
-looking_for_length_LSB  = 4 # Looking for UBX length bytes
-looking_for_length_MSB  = 5
-processing_payload      = 6 # Processing the payload. Keep going until length bytes have been processed
-looking_for_checksum_A  = 7 # Looking for UBX checksum bytes
-looking_for_checksum_B  = 8
-sync_lost               = 9 # Go into this state if sync is lost (bad checksum etc.)
-looking_for_asterix     = 10 # Looking for NMEA '*'
-looking_for_csum1       = 11 # Looking for NMEA checksum bytes
-looking_for_csum2       = 12
-looking_for_term1       = 13 # Looking for NMEA terminating bytes (CR and LF)
-looking_for_term2       = 14
-
-ubx_nmea_state = sync_lost # Initialize the state machine
-
-# Storage for UBX messages
-ubx_length = 0
-ubx_class = 0
-ubx_ID = 0
-ubx_checksum_A = 0
-ubx_checksum_B = 0
-ubx_expected_checksum_A = 0
-ubx_expected_checksum_B = 0
-
-# Storage for NMEA messages
-nmea_length = 0
-nmea_char_1 = 0 # e.g. G
-nmea_char_2 = 0 # e.g. P
-nmea_char_3 = 0 # e.g. G
-nmea_char_4 = 0 # e.g. G
-nmea_char_5 = 0 # e.g. A
-nmea_csum = 0
-nmea_csum1 = 0
-nmea_csum2 = 0
-nmea_expected_csum1 = 0
-nmea_expected_csum2 = 0
-
-max_nmea_len = 100 # Maximum length for an NMEA message: use this to detect if we have lost sync while receiving an NMEA message
-sync_lost_at = -1 # Record where we lost sync
-rewind_to = -1 # Keep a note of where we should rewind to if sync is lost
-rewind_attempts = 0 # Keep a note of how many rewinds have been attempted
-max_rewinds = 100 # Abort after this many rewinds
-rewind_in_progress = False # Flag to indicate if a rewind is in progress
-resyncs = 0 # Record the number of successful resyncs
-resync_in_progress = False # Flag to indicate if a resync is in progress
-message_start_byte = 0 # Record where the latest message started (for resync reporting)
-
-try:
-    while keepGoing:
-
-        # Read one byte from the file
-        fileBytes = fi.read(1)
-        if (len(fileBytes) == 0):
-            print('ERROR: Read zero bytes. End of file?! Or zero file size?!')
-            raise Exception('End of file?! Or zero file size?!')
-        c = fileBytes[0]
-
-        processed = processed + 1 # Keep a record of how many bytes have been read and processed
-
-        # Process data bytes according to ubx_nmea_state
-        # For UBX messages:
-        # Sync Char 1: 0xB5
-        # Sync Char 2: 0x62
-        # Class byte
-        # ID byte
-        # Length: two bytes, little endian
-        # Payload: length bytes
-        # Checksum: two bytes
-        # For NMEA messages:
-        # Starts with a '$'
-        # The next five characters indicate the message type (stored in nmea_char_1 to nmea_char_5)
-        # Message fields are comma-separated
-        # Followed by an '*'
-        # Then a two character checksum (the logical exclusive-OR of all characters between the $ and the * as ASCII hex)
-        # Ends with CR LF
-        # Only allow a new file to be opened when a complete packet has been processed and ubx_nmea_state has returned to "looking_for_B5_dollar"
-        # Or when a data error is detected (sync_lost)
-
-        # RXM_RAWX is class 0x02 ID 0x15
-        # RXM_SFRBF is class 0x02 ID 0x13
-        # TIM_TM2 is class 0x0d ID 0x03
-        # NAV_POSLLH is class 0x01 ID 0x02
-        # NAV_PVT is class 0x01 ID 0x07
-        # NAV-STATUS is class 0x01 ID 0x03
-
-        if (ubx_nmea_state == looking_for_B5_dollar) or (ubx_nmea_state == sync_lost):
-            if (c == 0xB5): # Have we found Sync Char 1 (0xB5) if we were expecting one?
-                if (ubx_nmea_state == sync_lost):
-                    print("UBX Sync Char 1 (0xB5) found at byte "+str(processed)+". Checking for Sync Char 2")
-                ubx_nmea_state = looking_for_62 # Now look for Sync Char 2 (0x62)
-                message_start_byte = processed # Record the message start byte for resync reporting
-            elif (c == 0x24) and (containsNMEA == True): # Have we found an NMEA '$' if we were expecting one?
-                if (ubx_nmea_state == sync_lost):
-                    print("NMEA $ found at byte "+str(processed)+". Attempting to process the message")
-                ubx_nmea_state = looking_for_asterix # Now keep going until we receive an asterix
-                nmea_length = 0 # Reset nmea_length then use it to check for excessive message length
-                nmea_csum = 0 # Reset the nmea_csum. Update it as each character arrives
-                nmea_char_1 = 0x30 # Reset the first five NMEA chars to something invalid
-                nmea_char_2 = 0x30
-                nmea_char_3 = 0x30
-                nmea_char_4 = 0x30
-                nmea_char_5 = 0x30
-                message_start_byte = processed # Record the message start byte for resync reporting
-            else:
-                #print("Was expecting Sync Char 0xB5 or an NMEA $ but did not receive one!")
-                if (c == 0x24):
-                    print("Warning: * found at byte "+str(processed)+"! Are you sure this file does not contain NMEA messages?")
-                sync_lost_at = processed
-                ubx_nmea_state = sync_lost
-        elif (ubx_nmea_state == looking_for_62):
-            if (c == 0x62): # Have we found Sync Char 2 (0x62) when we were expecting one?
-                ubx_expected_checksum_A = 0 # Reset the expected checksum
-                ubx_expected_checksum_B = 0
-                ubx_nmea_state = looking_for_class # Now look for Class byte
-            else:
-                print("Panic!! Was expecting Sync Char 2 (0x62) but did not receive one!")
-                print("Sync lost at byte "+str(processed)+". Attemting to re-sync")
-                sync_lost_at = processed
-                resync_in_progress = True
-                ubx_nmea_state = sync_lost
-        elif (ubx_nmea_state == looking_for_class):
-            ubx_class = c
-            ubx_expected_checksum_A = ubx_expected_checksum_A + c # Update the expected checksum
-            ubx_expected_checksum_B = ubx_expected_checksum_B + ubx_expected_checksum_A
-            ubx_nmea_state = looking_for_ID # Now look for ID byte
-        elif (ubx_nmea_state == looking_for_ID):
-            ubx_ID = c
-            ubx_expected_checksum_A = ubx_expected_checksum_A + c # Update the expected checksum
-            ubx_expected_checksum_B = ubx_expected_checksum_B + ubx_expected_checksum_A
-            message_type = '0x%02X 0x%02X'%(ubx_class,ubx_ID) # Record the message type
-            ubx_nmea_state = looking_for_length_LSB # Now look for length LSB
-        elif (ubx_nmea_state == looking_for_length_LSB):
-            ubx_length = c # Store the length LSB
-            ubx_expected_checksum_A = ubx_expected_checksum_A + c # Update the expected checksum
-            ubx_expected_checksum_B = ubx_expected_checksum_B + ubx_expected_checksum_A
-            ubx_nmea_state = looking_for_length_MSB # Now look for length MSB
-        elif (ubx_nmea_state == looking_for_length_MSB):
-            ubx_length = ubx_length + (c * 256) # Add the length MSB
-            ubx_expected_checksum_A = ubx_expected_checksum_A + c # Update the expected checksum
-            ubx_expected_checksum_B = ubx_expected_checksum_B + ubx_expected_checksum_A
-            if (ubx_length > longest): # Update the longest UBX message length    
-                longest = ubx_length
-            rewind_to = processed # If we lose sync due to dropped bytes then rewind to here
-            ubx_nmea_state = processing_payload # Now look for payload bytes (length: ubx_length)
-        elif (ubx_nmea_state == processing_payload):
-            ubx_length = ubx_length - 1 # Decrement length by one
-            ubx_expected_checksum_A = ubx_expected_checksum_A + c # Update the expected checksum
-            ubx_expected_checksum_B = ubx_expected_checksum_B + ubx_expected_checksum_A
-            if (ubx_length == 0):
-                ubx_expected_checksum_A = ubx_expected_checksum_A & 0xff # Limit checksums to 8-bits
-                ubx_expected_checksum_B = ubx_expected_checksum_B & 0xff
-                ubx_nmea_state = looking_for_checksum_A # If we have received length payload bytes, look for checksum bytes
-        elif (ubx_nmea_state == looking_for_checksum_A):
-            ubx_checksum_A = c
-            ubx_nmea_state = looking_for_checksum_B
-        elif (ubx_nmea_state == looking_for_checksum_B):
-            ubx_checksum_B = c
-            ubx_nmea_state = looking_for_B5_dollar # All bytes received so go back to looking for a new Sync Char 1 unless there is a checksum error
-            if ((ubx_expected_checksum_A != ubx_checksum_A) or (ubx_expected_checksum_B != ubx_checksum_B)):
-                print("Panic!! UBX checksum error!")
-                print("Sync lost at byte "+str(processed)+". Attemting to re-sync.")
-                sync_lost_at = processed
-                resync_in_progress = True
-                ubx_nmea_state = sync_lost
-            else:
-                # Valid UBX message was received. Check if we have seen this message type before
-                if message_type in messages:
-                    messages[message_type] += 1 # if we have, increment its count
-                else:
-                    messages[message_type] = 1 # if we have not, set its count to 1
-                rewind_in_progress = False # Clear rewind_in_progress
-                rewind_to = -1
-                if (resync_in_progress == True): # Check if we are resyncing
-                    resync_in_progress = False # Clear the flag now that a valid message has been received
-                    resyncs += 1 # Increment the number of successful resyncs
-                    print("Sync successfully re-established at byte "+str(processed)+". The UBX message started at byte "+str(message_start_byte))
-                    print()
-        # NMEA messages
-        elif (ubx_nmea_state == looking_for_asterix):
-            nmea_length = nmea_length + 1 # Increase the message length count
-            if (nmea_length > max_nmea_len): # If the length is greater than max_nmea_len, something bad must have happened (sync_lost)
-                print("Panic!! Excessive NMEA message length!")
-                print("Sync lost at byte "+str(processed)+". Attemting to re-sync")
-                sync_lost_at = processed
-                resync_in_progress = True
-                ubx_nmea_state = sync_lost
-                continue
-            # If this is one of the first five characters, store it
-            if (nmea_length <= 5):
-                if (nmea_length == 1):
-                    nmea_char_1 = c
-                    rewind_to = processed # If we lose sync due to dropped bytes then rewind to here
-                elif (nmea_length == 2):
-                    nmea_char_2 = c
-                elif (nmea_length == 3):
-                    nmea_char_3 = c
-                elif (nmea_length == 4):
-                    nmea_char_4 = c
-                else: # ubx_length == 5
-                    nmea_char_5 = c
-                    message_type = chr(nmea_char_1) + chr(nmea_char_2) + chr(nmea_char_3) + chr(nmea_char_4) + chr(nmea_char_5) # Record the message type
-            # Now check if this is an '*'
-            if (c == 0x2A):
-                # Asterix received
-                # Don't exOR it into the checksum
-                # Instead calculate what the expected checksum should be (nmea_csum in ASCII hex)
-                nmea_expected_csum1 = ((nmea_csum & 0xf0) >> 4) + 0x30 # Convert MS nibble to ASCII hex
-                if (nmea_expected_csum1 >= 0x3A): # : follows 9 so add 7 to convert to A-F
-                    nmea_expected_csum1 += 7
-                nmea_expected_csum2 = (nmea_csum & 0x0f) + 0x30 # Convert LS nibble to ASCII hex
-                if (nmea_expected_csum2 >= 0x3A): # : follows 9 so add 7 to convert to A-F
-                    nmea_expected_csum2 += 7
-                # Next, look for the first csum character
-                ubx_nmea_state = looking_for_csum1
-                continue # Don't include the * in the checksum
-            # Now update the checksum
-            # The checksum is the exclusive-OR of all characters between the $ and the *
-            nmea_csum = nmea_csum ^ c
-        elif (ubx_nmea_state == looking_for_csum1):
-            # Store the first NMEA checksum character
-            nmea_csum1 = c
-            ubx_nmea_state = looking_for_csum2
-        elif (ubx_nmea_state == looking_for_csum2):
-            # Store the second NMEA checksum character
-            nmea_csum2 = c
-            # Now check if the checksum is correct
-            if ((nmea_csum1 != nmea_expected_csum1) or (nmea_csum2 != nmea_expected_csum2)):
-                # The checksum does not match so sync_lost
-                print("Panic!! NMEA checksum error!")
-                print("Sync lost at byte "+str(processed)+". Attemting to re-sync")
-                sync_lost_at = processed
-                resync_in_progress = True
-                ubx_nmea_state = sync_lost
-            else:
-                # Checksum was valid so wait for the terminators
-                ubx_nmea_state = looking_for_term1
-        elif (ubx_nmea_state == looking_for_term1):
-            # Check if this is CR
-            if (c != 0x0D):
-                print("Panic!! NMEA CR not found!")
-                print("Sync lost at byte "+str(processed)+". Attemting to re-sync")
-                sync_lost_at = processed
-                resync_in_progress = True
-                ubx_nmea_state = sync_lost
-            else:
-                ubx_nmea_state = looking_for_term2
-        elif (ubx_nmea_state == looking_for_term2):
-            # Check if this is LF
-            if (c != 0x0A):
-                print("Panic!! NMEA LF not found!")
-                print("Sync lost at byte "+str(processed)+". Attemting to re-sync")
-                sync_lost_at = processed
-                resync_in_progress = True
-                ubx_nmea_state = sync_lost
-            else:
-                # Valid NMEA message was received. Check if we have seen this message type before
-                if message_type in messages:
-                    messages[message_type] += 1 # if we have, increment its count
-                else:
-                    messages[message_type] = 1 # if we have not, set its count to 1
-                # LF was received so go back to looking for B5 or a $
-                ubx_nmea_state = looking_for_B5_dollar
-                rewind_in_progress = False # Clear rewind_in_progress
-                rewind_to = -1
-                if (resync_in_progress == True): # Check if we are resyncing
-                    resync_in_progress = False # Clear the flag now that a valid message has been received
-                    resyncs += 1 # Increment the number of successful resyncs
-                    print("Sync successfully re-established at byte "+str(processed)+". The NMEA message started at byte "+str(message_start_byte))
-                    print()
-
-        # Check if the end of the file has been reached
-        if (processed >= filesize - 1): keepGoing = False
-
-        # Check if we should attempt to rewind
-        # Don't rewind if we have not yet seen a valid message
-        # Don't rewind if a rewind is already in progress
-        if (ubx_nmea_state == sync_lost) and (len(messages) > 0) and (rewind_in_progress == False) and (rewind_to >= 0):
-            rewind_attempts += 1 # Increment the number of rewind attempts
-            if (rewind_attempts > max_rewinds): # Only rewind up to max_rewind times
-                print("Panic! Maximum rewind attempts reached! Aborting...")
-                keepGoing = False
-            else:
-                print("Sync has been lost. Currently processing byte "+str(processed)+". Rewinding to byte "+str(rewind_to))
-                fi.seek(rewind_to) # Rewind the file
-                processed = rewind_to - 1 # Rewind processed too! (-1 is needed as processed is incremented at the start of the loop)
-                rewind_in_progress = True # Flag that a rewind is in progress
-            
-
-finally:
-    fi.close() # Close the file
-
-    # Print the file statistics
-    print()
-    processed += 1
-    print('Processed',processed,'bytes')
-    print('File size was',filesize)
-    if (processed != filesize):
-        print('FILE SIZE MISMATCH!!')
-    print('Longest UBX message was %i data bytes'%longest)
-    if len(messages) > 0:
-        print('Message types and totals were:')
-        for key in messages.keys():
-            print('Message type:',key,'  Total:',messages[key])
-    if (resyncs > 0):
-        print('Number of successful resyncs:',resyncs)
-    print()
-    print('Bye!')
diff --git a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Callbacks/CallbackExample1_NAV_PVT/CallbackExample1_NAV_PVT.ino b/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Callbacks/CallbackExample1_NAV_PVT/CallbackExample1_NAV_PVT.ino
deleted file mode 100644
index 4b1afba..0000000
--- a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Callbacks/CallbackExample1_NAV_PVT/CallbackExample1_NAV_PVT.ino
+++ /dev/null
@@ -1,104 +0,0 @@
-/*
-  Configuring the GNSS to automatically send position reports over I2C and display them using a callback
-  By: Paul Clark
-  SparkFun Electronics
-  Date: December 30th, 2020
-  License: MIT. See license file for more information but you can
-  basically do whatever you want with this code.
-
-  This example shows how to configure the u-blox GNSS to send navigation reports automatically
-  and access the data via a callback. No more polling!
-
-  Feel like supporting open source hardware?
-  Buy a board from SparkFun!
-  ZED-F9P RTK2: https://www.sparkfun.com/products/15136
-  NEO-M8P RTK: https://www.sparkfun.com/products/15005
-  SAM-M8Q: https://www.sparkfun.com/products/15106
-
-  Hardware Connections:
-  Plug a Qwiic cable into the GPS and a BlackBoard
-  If you don't have a platform with a Qwiic connection use the SparkFun Qwiic Breadboard Jumper (https://www.sparkfun.com/products/14425)
-  Open the serial monitor at 115200 baud to see the output
-*/
-
-#include <Wire.h> //Needed for I2C to GPS
-
-#include <SparkFun_u-blox_GNSS_Arduino_Library.h> //http://librarymanager/All#SparkFun_u-blox_GNSS
-SFE_UBLOX_GNSS myGNSS;
-
-// Callback: printPVTdata will be called when new NAV PVT data arrives
-// See u-blox_structs.h for the full definition of UBX_NAV_PVT_data_t
-//         _____  You can use any name you like for the callback. Use the same name when you call setAutoPVTcallback
-//        /                  _____  This _must_ be UBX_NAV_PVT_data_t
-//        |                 /               _____ You can use any name you like for the struct
-//        |                 |              /
-//        |                 |              |
-void printPVTdata(UBX_NAV_PVT_data_t ubxDataStruct)
-{
-    Serial.println();
-
-    Serial.print(F("Time: ")); // Print the time
-    uint8_t hms = ubxDataStruct.hour; // Print the hours
-    if (hms < 10) Serial.print(F("0")); // Print a leading zero if required
-    Serial.print(hms);
-    Serial.print(F(":"));
-    hms = ubxDataStruct.min; // Print the minutes
-    if (hms < 10) Serial.print(F("0")); // Print a leading zero if required
-    Serial.print(hms);
-    Serial.print(F(":"));
-    hms = ubxDataStruct.sec; // Print the seconds
-    if (hms < 10) Serial.print(F("0")); // Print a leading zero if required
-    Serial.print(hms);
-    Serial.print(F("."));
-    unsigned long millisecs = ubxDataStruct.iTOW % 1000; // Print the milliseconds
-    if (millisecs < 100) Serial.print(F("0")); // Print the trailing zeros correctly
-    if (millisecs < 10) Serial.print(F("0"));
-    Serial.print(millisecs);
-
-    long latitude = ubxDataStruct.lat; // Print the latitude
-    Serial.print(F(" Lat: "));
-    Serial.print(latitude);
-
-    long longitude = ubxDataStruct.lon; // Print the longitude
-    Serial.print(F(" Long: "));
-    Serial.print(longitude);
-    Serial.print(F(" (degrees * 10^-7)"));
-
-    long altitude = ubxDataStruct.hMSL; // Print the height above mean sea level
-    Serial.print(F(" Height above MSL: "));
-    Serial.print(altitude);
-    Serial.println(F(" (mm)"));
-}
-
-void setup()
-{
-  Serial.begin(115200);
-  while (!Serial); //Wait for user to open terminal
-  Serial.println("SparkFun u-blox Example");
-
-  Wire.begin();
-
-  //myGNSS.enableDebugging(); // Uncomment this line to enable helpful debug messages on Serial
-
-  if (myGNSS.begin() == false) //Connect to the u-blox module using Wire port
-  {
-    Serial.println(F("u-blox GNSS not detected at default I2C address. Please check wiring. Freezing."));
-    while (1);
-  }
-
-  myGNSS.setI2COutput(COM_TYPE_UBX); //Set the I2C port to output UBX only (turn off NMEA noise)
-  myGNSS.saveConfigSelective(VAL_CFG_SUBSEC_IOPORT); //Save (only) the communications port settings to flash and BBR
-
-  myGNSS.setNavigationFrequency(2); //Produce two solutions per second
-
-  myGNSS.setAutoPVTcallback(&printPVTdata); // Enable automatic NAV PVT messages with callback to printPVTdata
-}
-
-void loop()
-{
-  myGNSS.checkUblox(); // Check for the arrival of new data and process it.
-  myGNSS.checkCallbacks(); // Check if any callbacks are waiting to be processed.
-
-  Serial.print(".");
-  delay(50);
-}
diff --git a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Callbacks/CallbackExample2_NAV_ODO/CallbackExample2_NAV_ODO.ino b/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Callbacks/CallbackExample2_NAV_ODO/CallbackExample2_NAV_ODO.ino
deleted file mode 100644
index 3e1008c..0000000
--- a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Callbacks/CallbackExample2_NAV_ODO/CallbackExample2_NAV_ODO.ino
+++ /dev/null
@@ -1,89 +0,0 @@
-/*
-  Configuring the GNSS to automatically send odometer reports over I2C and display the data using a callback
-  By: Paul Clark
-  SparkFun Electronics
-  Date: December 30th, 2020
-  License: MIT. See license file for more information but you can
-  basically do whatever you want with this code.
-
-  This example shows how to configure the u-blox GNSS to send odometer reports automatically
-  and display the data via a callback. No more polling!
-
-  Feel like supporting open source hardware?
-  Buy a board from SparkFun!
-  ZED-F9P RTK2: https://www.sparkfun.com/products/15136
-  NEO-M8P RTK: https://www.sparkfun.com/products/15005
-  SAM-M8Q: https://www.sparkfun.com/products/15106
-
-  Hardware Connections:
-  Plug a Qwiic cable into the GPS and a BlackBoard
-  If you don't have a platform with a Qwiic connection use the SparkFun Qwiic Breadboard Jumper (https://www.sparkfun.com/products/14425)
-  Open the serial monitor at 115200 baud to see the output
-*/
-
-#include <Wire.h> //Needed for I2C to GPS
-
-#include <SparkFun_u-blox_GNSS_Arduino_Library.h> //http://librarymanager/All#SparkFun_u-blox_GNSS
-SFE_UBLOX_GNSS myGNSS;
-
-// Callback: printODOdata will be called when new NAV ODO data arrives
-// See u-blox_structs.h for the full definition of UBX_NAV_ODO_data_t
-//         _____  You can use any name you like for the callback. Use the same name when you call setAutoNAVODOcallback
-//        /                  _____  This _must_ be UBX_NAV_ODO_data_t
-//        |                 /                   _____ You can use any name you like for the struct
-//        |                 |                  /
-//        |                 |                  |
-void printODOdata(UBX_NAV_ODO_data_t ubxDataStruct)
-{
-    Serial.println();
-
-    Serial.print(F("TOW: ")); // Print the Time Of Week
-    unsigned long iTOW = ubxDataStruct.iTOW; // iTOW is in milliseconds
-    Serial.print(iTOW);
-    Serial.print(F(" (ms)"));
-
-    Serial.print(F(" Distance: "));
-    unsigned long distance = ubxDataStruct.distance; // Print the distance
-    Serial.print(distance);
-    Serial.print(F(" (m)"));
-
-    Serial.print(F(" Total Distance: "));
-    unsigned long totalDistance = ubxDataStruct.totalDistance; // Print the total distance
-    Serial.print(totalDistance);
-    Serial.println(F(" (m)"));
-}
-
-void setup()
-{
-  Serial.begin(115200);
-  while (!Serial); //Wait for user to open terminal
-  Serial.println("SparkFun u-blox Example");
-
-  Wire.begin();
-
-  //myGNSS.enableDebugging(); // Uncomment this line to enable helpful debug messages on Serial
-
-  if (myGNSS.begin() == false) //Connect to the u-blox module using Wire port
-  {
-    Serial.println(F("u-blox GNSS not detected at default I2C address. Please check wiring. Freezing."));
-    while (1);
-  }
-
-  myGNSS.setI2COutput(COM_TYPE_UBX); //Set the I2C port to output UBX only (turn off NMEA noise)
-  myGNSS.saveConfigSelective(VAL_CFG_SUBSEC_IOPORT); //Save (only) the communications port settings to flash and BBR
-
-  myGNSS.setNavigationFrequency(1); //Produce one solution per second
-
-  //myGNSS.resetOdometer(); //Uncomment this line to reset the odometer
-
-  myGNSS.setAutoNAVODOcallback(&printODOdata); // Enable automatic NAV ODO messages with callback to printODOdata
-}
-
-void loop()
-{
-  myGNSS.checkUblox(); // Check for the arrival of new data and process it.
-  myGNSS.checkCallbacks(); // Check if any callbacks are waiting to be processed.
-
-  Serial.print(".");
-  delay(50);
-}
diff --git a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Callbacks/CallbackExample3_TIM_TM2/CallbackExample3_TIM_TM2.ino b/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Callbacks/CallbackExample3_TIM_TM2/CallbackExample3_TIM_TM2.ino
deleted file mode 100644
index 3737bec..0000000
--- a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Callbacks/CallbackExample3_TIM_TM2/CallbackExample3_TIM_TM2.ino
+++ /dev/null
@@ -1,115 +0,0 @@
-/*
-  Configuring the GNSS to automatically send TIM TM2 reports over I2C and display the data using a callback
-  By: Paul Clark
-  SparkFun Electronics
-  Date: December 30th, 2020
-  License: MIT. See license file for more information but you can
-  basically do whatever you want with this code.
-
-  This example shows how to configure the u-blox GNSS to send TIM TM2 reports automatically
-  and display the data via a callback. No more polling!
-
-  Connecting the PPS (Pulse Per Second) breakout pin to the INT (Interrupt) pin with a jumper wire
-  will cause a TIM TM2 message to be produced once per second. You can then study the timing of the
-  pulse edges with nanosecond resolution!
-
-  Note: TIM TM2 can only capture the timing of one rising edge and one falling edge per
-  navigation solution. So with setNavigationFrequency set to 1Hz, we can only see the timing
-  of one rising and one falling edge per second. If the frequency of the signal on the INT pin
-  is higher than 1Hz, we will only be able to see the timing of the most recent edges.
-  However, the module can count the number of rising edges too, at rates faster than the navigation rate.
-
-  TIM TM2 messages are only produced when a rising or falling edge is detected on the INT pin.
-  If you disconnect your PPS to INT jumper wire, the messages will stop.
-
-  Feel like supporting open source hardware?
-  Buy a board from SparkFun!
-  ZED-F9P RTK2: https://www.sparkfun.com/products/15136
-  NEO-M8P RTK: https://www.sparkfun.com/products/15005
-  NEO-M9N: https://www.sparkfun.com/products/17285
-
-  Hardware Connections:
-  Plug a Qwiic cable into the GPS and a BlackBoard
-  If you don't have a platform with a Qwiic connection use the SparkFun Qwiic Breadboard Jumper (https://www.sparkfun.com/products/14425)
-  Open the serial monitor at 115200 baud to see the output
-*/
-
-#include <Wire.h> //Needed for I2C to GPS
-
-#include <SparkFun_u-blox_GNSS_Arduino_Library.h> //http://librarymanager/All#SparkFun_u-blox_GNSS
-SFE_UBLOX_GNSS myGNSS;
-
-int dotsPrinted = 0; // Print dots in rows of 50 while waiting for a TIM TM2 message
-
-// Callback: printTIMTM2data will be called when new TIM TM2 data arrives
-// See u-blox_structs.h for the full definition of UBX_TIM_TM2_data_t
-//         _____  You can use any name you like for the callback. Use the same name when you call setAutoTIMTM2callback
-//        /                  _____  This _must_ be UBX_TIM_TM2_data_t
-//        |                 /                   _____ You can use any name you like for the struct
-//        |                 |                  /
-//        |                 |                  |
-void printTIMTM2data(UBX_TIM_TM2_data_t ubxDataStruct)
-{
-    Serial.println();
-
-    Serial.print(F("newFallingEdge: ")); // 1 if a new falling edge was detected
-    Serial.print(ubxDataStruct.flags.bits.newFallingEdge);
-
-    Serial.print(F(" newRisingEdge: ")); // 1 if a new rising edge was detected
-    Serial.print(ubxDataStruct.flags.bits.newRisingEdge);
-
-    Serial.print(F(" Rising Edge Counter: ")); // Rising edge counter
-    Serial.print(ubxDataStruct.count);
-
-    Serial.print(F(" towMsR: ")); // Time Of Week of rising edge (ms)
-    Serial.print(ubxDataStruct.towMsR);
-
-    Serial.print(F(" towSubMsR: ")); // Millisecond fraction of Time Of Week of rising edge in nanoseconds
-    Serial.print(ubxDataStruct.towSubMsR);
-
-    Serial.print(F(" towMsF: ")); // Time Of Week of falling edge (ms)
-    Serial.print(ubxDataStruct.towMsF);
-
-    Serial.print(F(" towSubMsF: ")); // Millisecond fraction of Time Of Week of falling edge in nanoseconds
-    Serial.println(ubxDataStruct.towSubMsF);
-
-    dotsPrinted = 0; // Reset dotsPrinted
-}
-
-void setup()
-{
-  Serial.begin(115200);
-  while (!Serial); //Wait for user to open terminal
-  Serial.println("SparkFun u-blox Example");
-
-  Wire.begin();
-
-  //myGNSS.enableDebugging(); // Uncomment this line to enable helpful debug messages on Serial
-
-  if (myGNSS.begin() == false) //Connect to the u-blox module using Wire port
-  {
-    Serial.println(F("u-blox GNSS not detected at default I2C address. Please check wiring. Freezing."));
-    while (1);
-  }
-
-  myGNSS.setI2COutput(COM_TYPE_UBX); //Set the I2C port to output UBX only (turn off NMEA noise)
-  myGNSS.saveConfigSelective(VAL_CFG_SUBSEC_IOPORT); //Save (only) the communications port settings to flash and BBR
-
-  myGNSS.setNavigationFrequency(1); //Produce one solution per second
-
-  myGNSS.setAutoTIMTM2callback(&printTIMTM2data); // Enable automatic TIM TM2 messages with callback to printTIMTM2data
-}
-
-void loop()
-{
-  myGNSS.checkUblox(); // Check for the arrival of new data and process it.
-  myGNSS.checkCallbacks(); // Check if any callbacks are waiting to be processed.
-
-  Serial.print(".");
-  delay(50);
-  if (++dotsPrinted > 50)
-  {
-    Serial.println();
-    dotsPrinted = 0;
-  }
-}
diff --git a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Callbacks/CallbackExample4_HNR/CallbackExample4_HNR.ino b/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Callbacks/CallbackExample4_HNR/CallbackExample4_HNR.ino
deleted file mode 100644
index 7c86fa8..0000000
--- a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Callbacks/CallbackExample4_HNR/CallbackExample4_HNR.ino
+++ /dev/null
@@ -1,117 +0,0 @@
-/*
-  By: Paul Clark
-  SparkFun Electronics
-  Date: December, 2020
-  License: MIT. See license file for more information but you can
-  basically do whatever you want with this code.
-
-  This example configures the High Navigation Rate on the NEO-M8U and then
-  reads and displays the attitude solution, vehicle dynamics information
-  and high rate position, velocity and time.
-
-  This example uses callbacks to process the HNR data automatically. No more polling!
-
-  Please make sure your NEO-M8U is running UDR firmware >= 1.31. Please update using u-center if necessary:
-  https://www.u-blox.com/en/product/neo-m8u-module#tab-documentation-resources
-
-  Feel like supporting open source hardware?
-  Buy a board from SparkFun!
-  NEO-M8U: https://www.sparkfun.com/products/16329
-
-  Hardware Connections:
-  Plug a Qwiic cable into the GPS and a Redboard Qwiic
-  If you don't have a platform with a Qwiic connection use the
-	SparkFun Qwiic Breadboard Jumper (https://www.sparkfun.com/products/14425)
-  Open the serial monitor at 115200 baud to see the output
-
-*/
-
-#include <Wire.h> //Needed for I2C to GPS
-
-#include <SparkFun_u-blox_GNSS_Arduino_Library.h> //http://librarymanager/All#SparkFun_u-blox_GNSS
-SFE_UBLOX_GNSS myGNSS;
-
-// Callback: printHNRATTdata will be called when new HNR ATT data arrives
-// See u-blox_structs.h for the full definition of UBX_HNR_ATT_data_t
-//         _____  You can use any name you like for the callback. Use the same name when you call setAutoHNRATTcallback
-//        /                  _____  This _must_ be UBX_HNR_ATT_data_t
-//        |                 /                   _____ You can use any name you like for the struct
-//        |                 |                  /
-//        |                 |                  |
-void printHNRATTdata(UBX_HNR_ATT_data_t ubxDataStruct)
-{
-  Serial.println();
-  Serial.print(F("Roll: ")); // Print selected data
-  Serial.print((float)ubxDataStruct.roll / 100000.0, 2); // Convert roll to degrees
-  Serial.print(F(" Pitch: "));
-  Serial.print((float)ubxDataStruct.pitch / 100000.0, 2); // Convert pitch to degrees
-  Serial.print(F(" Heading: "));
-  Serial.println((float)ubxDataStruct.heading / 100000.0, 2); // Convert heading to degrees
-}
-
-// Callback: printHNRINSdata will be called when new HNR INS data arrives
-// See u-blox_structs.h for the full definition of UBX_HNR_INS_data_t
-void printHNRINSdata(UBX_HNR_INS_data_t ubxDataStruct)
-{
-  Serial.print(F("xAccel: ")); // Print selected data
-  Serial.print(ubxDataStruct.xAccel);
-  Serial.print(F(" yAccel: "));
-  Serial.print(ubxDataStruct.yAccel);
-  Serial.print(F(" zAccel: "));
-  Serial.println(ubxDataStruct.zAccel);
-}
-
-// Callback: printHNRPVTdata will be called when new HNR PVT data arrives
-// See u-blox_structs.h for the full definition of UBX_HNR_PVT_data_t
-void printHNRPVTdata(UBX_HNR_PVT_data_t ubxDataStruct)
-{
-  Serial.print(F("ns: ")); // Print selected data
-  Serial.print(ubxDataStruct.nano);
-  Serial.print(F(" Lat: "));
-  Serial.print(ubxDataStruct.lat);
-  Serial.print(F(" Lon: "));
-  Serial.println(ubxDataStruct.lon);
-}
-
-void setup()
-{
-  Serial.begin(115200);
-  while (!Serial); //Wait for user to open terminal
-  Serial.println(F("SparkFun u-blox Example"));
-
-  Wire.begin();
-
-  //myGNSS.enableDebugging(); // Uncomment this line to enable debug messages on Serial
-
-  if (myGNSS.begin() == false) //Connect to the u-blox module using Wire port
-  {
-    Serial.println(F("u-blox GNSS not detected at default I2C address. Please check wiring. Freezing."));
-    while (1);
-  }
-
-  myGNSS.setI2COutput(COM_TYPE_UBX); //Set the I2C port to output UBX only (turn off NMEA noise)
-  myGNSS.saveConfigSelective(VAL_CFG_SUBSEC_IOPORT); //Save (only) the communications port settings to flash and BBR
-
-  if (myGNSS.setHNRNavigationRate(10) == true) //Set the High Navigation Rate to 10Hz
-    Serial.println(F("setHNRNavigationRate was successful"));
-  else
-    Serial.println(F("setHNRNavigationRate was NOT successful"));
-
-  if (myGNSS.setAutoHNRATTcallback(&printHNRATTdata) == true) // Enable automatic HNR ATT messages with callback to printHNRATTdata
-    Serial.println(F("setAutoHNRATTcallback successful"));
-
-  if (myGNSS.setAutoHNRINScallback(&printHNRINSdata) == true) // Enable automatic HNR INS messages with callback to printHNRINSdata
-    Serial.println(F("setAutoHNRINScallback successful"));
-
-  if (myGNSS.setAutoHNRPVTcallback(&printHNRPVTdata) == true) // Enable automatic HNR PVT messages with callback to printHNRPVTdata
-    Serial.println(F("setAutoHNRPVTcallback successful"));
-}
-
-void loop()
-{
-  myGNSS.checkUblox(); // Check for the arrival of new data and process it.
-  myGNSS.checkCallbacks(); // Check if any callbacks are waiting to be processed.
-
-  Serial.print(".");
-  delay(25);
-}
diff --git a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Callbacks/CallbackExample5_ESF/CallbackExample5_ESF.ino b/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Callbacks/CallbackExample5_ESF/CallbackExample5_ESF.ino
deleted file mode 100644
index bd5a7d6..0000000
--- a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Callbacks/CallbackExample5_ESF/CallbackExample5_ESF.ino
+++ /dev/null
@@ -1,179 +0,0 @@
-/*
-  By: Paul Clark
-  SparkFun Electronics
-  Date: December, 2020
-  License: MIT. See license file for more information but you can
-  basically do whatever you want with this code.
-
-  This example configures the External Sensor Fusion messages on the NEO-M8U and
-  uses callbacks to process and display the ESF data automatically. No more polling!
-
-  Please make sure your NEO-M8U is running UDR firmware >= 1.31. Please update using u-center if necessary:
-  https://www.u-blox.com/en/product/neo-m8u-module#tab-documentation-resources
-
-  Feel like supporting open source hardware?
-  Buy a board from SparkFun!
-  NEO-M8U: https://www.sparkfun.com/products/16329
-
-  Hardware Connections:
-  Plug a Qwiic cable into the GPS and a Redboard Qwiic
-  If you don't have a platform with a Qwiic connection use the
-	SparkFun Qwiic Breadboard Jumper (https://www.sparkfun.com/products/14425)
-  Open the serial monitor at 115200 baud to see the output
-
-*/
-
-#include <Wire.h> //Needed for I2C to GPS
-
-#include <SparkFun_u-blox_GNSS_Arduino_Library.h> //http://librarymanager/All#SparkFun_u-blox_GNSS
-SFE_UBLOX_GNSS myGNSS;
-
-// Callback: printESFALGdata will be called when new ESF ALG data arrives
-// See u-blox_structs.h for the full definition of UBX_ESF_ALG_data_t
-//         _____  You can use any name you like for the callback. Use the same name when you call setAutoESFALGcallback
-//        /                  _____  This _must_ be UBX_ESF_ALG_data_t
-//        |                 /                   _____ You can use any name you like for the struct
-//        |                 |                  /
-//        |                 |                  |
-void printESFALGdata(UBX_ESF_ALG_data_t ubxDataStruct)
-{
-  Serial.println();
-
-  Serial.print(F("TOW: ")); // Print the Time Of Week
-  unsigned long iTOW = ubxDataStruct.iTOW; // iTOW is in milliseconds
-  Serial.print(iTOW);
-  Serial.print(F(" (ms)"));
-
-  Serial.print(F(" Roll: ")); // Print selected data
-  Serial.print((float)ubxDataStruct.roll / 100.0, 2); // Convert roll to degrees
-
-  Serial.print(F(" Pitch: "));
-  Serial.print((float)ubxDataStruct.pitch / 100.0, 2); // Convert pitch to degrees
-
-  Serial.print(F(" Yaw: "));
-  Serial.print((float)ubxDataStruct.yaw / 100.0, 2); // Convert yaw to degrees
-
-  Serial.println(F(" (Degrees)"));
-}
-
-// Callback: printESFINSdata will be called when new ESF INS data arrives
-// See u-blox_structs.h for the full definition of UBX_ESF_INS_data_t
-void printESFINSdata(UBX_ESF_INS_data_t ubxDataStruct)
-{
-  Serial.print(F("xAccel: ")); // Print selected data
-  Serial.print(ubxDataStruct.xAccel);
-
-  Serial.print(F(" yAccel: "));
-  Serial.print(ubxDataStruct.yAccel);
-
-  Serial.print(F(" zAccel: "));
-  Serial.print(ubxDataStruct.zAccel);
-
-  Serial.println(F(" (m/s^2)"));
-}
-
-// Callback: printESFMEASdata will be called when new ESF MEAS data arrives
-// See u-blox_structs.h for the full definition of UBX_ESF_MEAS_data_t
-// and UBX_ESF_MEAS_sensorData_t
-void printESFMEASdata(UBX_ESF_MEAS_data_t ubxDataStruct)
-{
-  Serial.println();
-
-  Serial.print(F("id: ")); // Print selected data
-  Serial.print(ubxDataStruct.id);
-
-  Serial.print(F(" numMeas: "));
-  Serial.println(ubxDataStruct.flags.bits.numMeas);
-
-  for (uint8_t num = 0; num < ubxDataStruct.flags.bits.numMeas; num++) // For each sensor
-  {
-    Serial.print(F("Sensor "));
-    Serial.print(num);
-
-    UBX_ESF_MEAS_sensorData_t sensorData;
-    myGNSS.getSensorFusionMeasurement(&sensorData, ubxDataStruct, num); // Extract the data for one sensor
-
-    Serial.print(F(": Type: "));
-    Serial.print(sensorData.data.bits.dataType);
-    Serial.print(F(" Data: "));
-    Serial.println(sensorData.data.bits.dataField);
-  }
-}
-
-// Callback: printESFSTATUSdata will be called when new ESF STATUS data arrives
-// See u-blox_structs.h for the full definition of UBX_ESF_STATUS_data_t
-// and UBX_ESF_STATUS_sensorStatus_t
-void printESFSTATUSdata(UBX_ESF_STATUS_data_t ubxDataStruct)
-{
-  Serial.print(F("fusionMode: ")); // Print selected data
-  Serial.print(ubxDataStruct.fusionMode);
-
-  Serial.print(F(" numSens: "));
-  Serial.println(ubxDataStruct.numSens);
-
-  for (uint8_t num = 0; num < ubxDataStruct.numSens; num++) // For each sensor
-  {
-    Serial.print(F("Sensor "));
-    Serial.print(num);
-
-    UBX_ESF_STATUS_sensorStatus_t sensorStatus;
-    myGNSS.getSensorFusionStatus(&sensorStatus, ubxDataStruct, num); // Extract the data for one sensor
-
-    Serial.print(F(": Type: "));
-    Serial.print(sensorStatus.sensStatus1.bits.type);
-    Serial.print(F(" Used: "));
-    Serial.print(sensorStatus.sensStatus1.bits.used);
-    Serial.print(F(" Ready: "));
-    Serial.print(sensorStatus.sensStatus1.bits.ready);
-    Serial.print(F(" Calib Status: "));
-    Serial.print(sensorStatus.sensStatus2.bits.calibStatus);
-    Serial.print(F(" Noisy: "));
-    Serial.println(sensorStatus.faults.bits.noisyMeas);
-  }
-}
-
-void setup()
-{
-  Serial.begin(115200);
-  while (!Serial); //Wait for user to open terminal
-  Serial.println(F("SparkFun u-blox Example"));
-
-  Wire.begin();
-
-  //myGNSS.enableDebugging(); // Uncomment this line to enable debug messages on Serial
-
-  if (myGNSS.begin() == false) //Connect to the u-blox module using Wire port
-  {
-    Serial.println(F("u-blox GNSS not detected at default I2C address. Please check wiring. Freezing."));
-    while (1);
-  }
-
-  myGNSS.setI2COutput(COM_TYPE_UBX); //Set the I2C port to output UBX only (turn off NMEA noise)
-  myGNSS.saveConfigSelective(VAL_CFG_SUBSEC_IOPORT); //Save (only) the communications port settings to flash and BBR
-
-  myGNSS.setNavigationFrequency(1); //Produce one solution per second
-  myGNSS.setHNRNavigationRate(1); //Set the High Navigation Rate to 1Hz
-
-  myGNSS.setI2CpollingWait(50); //Allow checkUblox to poll I2C data every 50ms to keep up with the ESF MEAS messages
-
-  if (myGNSS.setAutoESFALGcallback(&printESFALGdata) == true) // Enable automatic ESF ALG messages with callback to printESFALGdata
-    Serial.println(F("setAutoESFALGcallback successful"));
-
-  if (myGNSS.setAutoESFINScallback(&printESFINSdata) == true) // Enable automatic ESF INS messages with callback to printESFINSdata
-    Serial.println(F("setAutoESFINScallback successful"));
-
-  if (myGNSS.setAutoESFMEAScallback(&printESFMEASdata) == true) // Enable automatic ESF MEAS messages with callback to printESFMEASdata
-    Serial.println(F("setAutoESFMEAScallback successful"));
-
-  if (myGNSS.setAutoESFSTATUScallback(&printESFSTATUSdata) == true) // Enable automatic ESF STATUS messages with callback to printESFSTATUSdata
-    Serial.println(F("setAutoESFSTATUScallback successful"));
-}
-
-void loop()
-{
-  myGNSS.checkUblox(); // Check for the arrival of new data and process it.
-  myGNSS.checkCallbacks(); // Check if any callbacks are waiting to be processed.
-
-  Serial.print(".");
-  delay(25);
-}
diff --git a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Callbacks/CallbackExample6_RAWX/CallbackExample6_RAWX.ino b/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Callbacks/CallbackExample6_RAWX/CallbackExample6_RAWX.ino
deleted file mode 100644
index 2461ccc..0000000
--- a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Callbacks/CallbackExample6_RAWX/CallbackExample6_RAWX.ino
+++ /dev/null
@@ -1,107 +0,0 @@
-/*
-  Configuring the GNSS to automatically send RXM RZWX reports over I2C and display them using a callback
-  By: Paul Clark
-  SparkFun Electronics
-  Date: March 11th, 2021
-  License: MIT. See license file for more information but you can
-  basically do whatever you want with this code.
-
-  This example shows how to configure the u-blox GNSS to send RXM RAWX reports automatically
-  and access the data via a callback. No more polling!
-
-  Feel like supporting open source hardware?
-  Buy a board from SparkFun!
-  ZED-F9P RTK2: https://www.sparkfun.com/products/15136
-
-  Hardware Connections:
-  Plug a Qwiic cable into the GPS and a BlackBoard
-  If you don't have a platform with a Qwiic connection use the SparkFun Qwiic Breadboard Jumper (https://www.sparkfun.com/products/14425)
-  Open the serial monitor at 115200 baud to see the output
-*/
-
-#include <Wire.h> //Needed for I2C to GPS
-
-#include <SparkFun_u-blox_GNSS_Arduino_Library.h> //http://librarymanager/All#SparkFun_u-blox_GNSS
-SFE_UBLOX_GNSS myGNSS;
-
-// Callback: newRAWX will be called when new RXM RAWX data arrives
-// See u-blox_structs.h for the full definition of UBX_RXMRAWX_data_t
-//         _____  You can use any name you like for the callback. Use the same name when you call setAutoRXMRAWXcallback
-//        /             _____  This _must_ be UBX_RXM_RAWX_data_t
-//        |            /                _____ You can use any name you like for the struct
-//        |            |               /
-//        |            |               |
-void newRAWX(UBX_RXM_RAWX_data_t ubxDataStruct)
-{
-  Serial.println();
-
-  Serial.print(F("New RAWX data received. It contains "));
-  Serial.print(ubxDataStruct.header.numMeas); // Print numMeas (Number of measurements / blocks)
-  Serial.println(F(" data blocks:"));
-
-  for (uint8_t block = 0; block < ubxDataStruct.header.numMeas; block++) // For each block
-  {
-    Serial.print(F("GNSS ID: "));
-    if (ubxDataStruct.blocks[block].gnssId < 100) Serial.print(F(" ")); // Align the gnssId
-    if (ubxDataStruct.blocks[block].gnssId < 10) Serial.print(F(" ")); // Align the gnssId
-    Serial.print(ubxDataStruct.blocks[block].gnssId);
-    Serial.print(F("  SV ID: "));
-    if (ubxDataStruct.blocks[block].svId < 100) Serial.print(F(" ")); // Align the svId
-    if (ubxDataStruct.blocks[block].svId < 10) Serial.print(F(" ")); // Align the svId
-    Serial.print(ubxDataStruct.blocks[block].svId);
-
-    if (sizeof(double) == 8) // Check if our processor supports 64-bit double
-    {
-      // Convert prMes from uint8_t[8] to 64-bit double
-      // prMes is little-endian
-      double pseudorange;
-      memcpy(&pseudorange, &ubxDataStruct.blocks[block].prMes, 8);
-      Serial.print(F("  PR: "));
-      Serial.print(pseudorange, 3);
-
-      // Convert cpMes from uint8_t[8] to 64-bit double
-      // cpMes is little-endian
-      double carrierPhase;
-      memcpy(&carrierPhase, &ubxDataStruct.blocks[block].cpMes, 8);
-      Serial.print(F(" m  CP: "));
-      Serial.print(carrierPhase, 3);
-      Serial.print(F(" cycles"));
-    }
-    Serial.println();
-  }
-}
-
-void setup()
-{
-  Serial.begin(115200);
-  while (!Serial); //Wait for user to open terminal
-  Serial.println("SparkFun u-blox Example");
-
-  Wire.begin();
-
-  //myGNSS.enableDebugging(); // Uncomment this line to enable helpful debug messages on Serial
-
-  myGNSS.disableUBX7Fcheck(); // RAWX data can legitimately contain 0x7F, so we need to disable the "7F" check in checkUbloxI2C
-
-  if (myGNSS.begin() == false) //Connect to the u-blox module using Wire port
-  {
-    Serial.println(F("u-blox GNSS not detected at default I2C address. Please check wiring. Freezing."));
-    while (1);
-  }
-
-  myGNSS.setI2COutput(COM_TYPE_UBX); //Set the I2C port to output UBX only (turn off NMEA noise)
-  myGNSS.saveConfigSelective(VAL_CFG_SUBSEC_IOPORT); //Save (only) the communications port settings to flash and BBR
-
-  myGNSS.setNavigationFrequency(1); //Produce one solution per second (RAWX produces a _lot_ of data!)
-
-  myGNSS.setAutoRXMRAWXcallback(&newRAWX); // Enable automatic RXM RAWX messages with callback to newRAWX
-}
-
-void loop()
-{
-  myGNSS.checkUblox(); // Check for the arrival of new data and process it.
-  myGNSS.checkCallbacks(); // Check if any callbacks are waiting to be processed.
-
-  Serial.print(".");
-  delay(50);
-}
diff --git a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Data_Logging/DataLoggingExample1_NAV_PVT/DataLoggingExample1_NAV_PVT.ino b/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Data_Logging/DataLoggingExample1_NAV_PVT/DataLoggingExample1_NAV_PVT.ino
deleted file mode 100644
index 0f09f64..0000000
--- a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Data_Logging/DataLoggingExample1_NAV_PVT/DataLoggingExample1_NAV_PVT.ino
+++ /dev/null
@@ -1,230 +0,0 @@
-/*
-  Configuring the GNSS to automatically send NAV PVT reports over I2C and log them to file on SD card
-  By: Paul Clark
-  SparkFun Electronics
-  Date: December 30th, 2020
-  License: MIT. See license file for more information but you can
-  basically do whatever you want with this code.
-
-  This example shows how to configure the u-blox GNSS to send NAV PVT reports automatically
-  and log the data to SD card in UBX format.
-
-  This code is intended to be run on the MicroMod Data Logging Carrier Board using the Artemis Processor
-  but can be adapted by changing the chip select pin and SPI definitions:
-  https://www.sparkfun.com/products/16829
-  https://www.sparkfun.com/products/16401
-
-  Hardware Connections:
-  Please see: https://learn.sparkfun.com/tutorials/micromod-data-logging-carrier-board-hookup-guide
-  Insert the Artemis Processor into the MicroMod Data Logging Carrier Board and secure with the screw.
-  Connect your GNSS breakout to the Carrier Board using a Qwiic cable.
-  Connect an antenna to your GNSS board if required.
-  Insert a formatted micro-SD card into the socket on the Carrier Board.
-  Connect the Carrier Board to your computer using a USB-C cable.
-  Ensure you have the SparkFun Apollo3 boards installed: http://boardsmanager/All#SparkFun_Apollo3
-  This code has been tested using version 1.2.1 of the Apollo3 boards on Arduino IDE 1.8.13.
-  Select "SparkFun Artemis MicroMod" as the board type.
-  Press upload to upload the code onto the Artemis.
-  Open the Serial Monitor at 115200 baud to see the output.
-
-  To minimise I2C bus errors, it is a good idea to open the I2C pull-up split pad links on
-  both the MicroMod Data Logging Carrier Board and the u-blox module breakout.
-
-  Data is logged in u-blox UBX format. Please see the u-blox protocol specification for more details.
-  You can replay and analyze the data using u-center:
-  https://www.u-blox.com/en/product/u-center
-
-  Feel like supporting open source hardware?
-  Buy a board from SparkFun!
-  ZED-F9P RTK2: https://www.sparkfun.com/products/15136
-  NEO-M8P RTK: https://www.sparkfun.com/products/15005
-  SAM-M8Q: https://www.sparkfun.com/products/15106
-
-*/
-
-#include <SPI.h>
-#include <SD.h>
-#include <Wire.h> //Needed for I2C to GNSS
-
-#include <SparkFun_u-blox_GNSS_Arduino_Library.h> //Click here to get the library: http://librarymanager/All#SparkFun_u-blox_GNSS
-SFE_UBLOX_GNSS myGNSS;
-
-File myFile; //File that all GNSS data is written to
-
-#define sdChipSelect CS //Primary SPI Chip Select is CS for the MicroMod Artemis Processor. Adjust for your processor if necessary.
-
-#define packetLength 100 // NAV PVT is 92 + 8 bytes in length (including the sync chars, class, id, length and checksum bytes)
-
-// Callback: printPVTdata will be called when new NAV PVT data arrives
-// See u-blox_structs.h for the full definition of UBX_NAV_PVT_data_t
-//         _____  You can use any name you like for the callback. Use the same name when you call setAutoPVTcallback
-//        /                  _____  This _must_ be UBX_NAV_PVT_data_t
-//        |                 /               _____ You can use any name you like for the struct
-//        |                 |              /
-//        |                 |              |
-void printPVTdata(UBX_NAV_PVT_data_t ubxDataStruct)
-{
-    Serial.println();
-
-    Serial.print(F("Time: ")); // Print the time
-    uint8_t hms = ubxDataStruct.hour; // Print the hours
-    if (hms < 10) Serial.print(F("0")); // Print a leading zero if required
-    Serial.print(hms);
-    Serial.print(F(":"));
-    hms = ubxDataStruct.min; // Print the minutes
-    if (hms < 10) Serial.print(F("0")); // Print a leading zero if required
-    Serial.print(hms);
-    Serial.print(F(":"));
-    hms = ubxDataStruct.sec; // Print the seconds
-    if (hms < 10) Serial.print(F("0")); // Print a leading zero if required
-    Serial.print(hms);
-    Serial.print(F("."));
-    unsigned long millisecs = ubxDataStruct.iTOW % 1000; // Print the milliseconds
-    if (millisecs < 100) Serial.print(F("0")); // Print the trailing zeros correctly
-    if (millisecs < 10) Serial.print(F("0"));
-    Serial.print(millisecs);
-
-    long latitude = ubxDataStruct.lat; // Print the latitude
-    Serial.print(F(" Lat: "));
-    Serial.print(latitude);
-
-    long longitude = ubxDataStruct.lon; // Print the longitude
-    Serial.print(F(" Long: "));
-    Serial.print(longitude);
-    Serial.print(F(" (degrees * 10^-7)"));
-
-    long altitude = ubxDataStruct.hMSL; // Print the height above mean sea level
-    Serial.print(F(" Height above MSL: "));
-    Serial.print(altitude);
-    Serial.println(F(" (mm)"));
-}
-
-void setup()
-{
-  Serial.begin(115200);
-  while (!Serial); //Wait for user to open terminal
-  Serial.println("SparkFun u-blox Example");
-
-  Wire.begin(); // Start I2C communication with the GNSS
-
-#if defined(AM_PART_APOLLO3)
-  Wire.setPullups(0); // On the Artemis, we can disable the internal I2C pull-ups too to help reduce bus errors
-#endif
-
-  while (Serial.available()) // Make sure the Serial buffer is empty
-  {
-    Serial.read();
-  }
-
-  Serial.println(F("Press any key to start logging."));
-
-  while (!Serial.available()) // Wait for the user to press a key
-  {
-    ; // Do nothing
-  }
-
-  delay(100); // Wait, just in case multiple characters were sent
-
-  while (Serial.available()) // Empty the Serial buffer
-  {
-    Serial.read();
-  }
-
-  Serial.println("Initializing SD card...");
-
-  // See if the card is present and can be initialized:
-  if (!SD.begin(sdChipSelect))
-  {
-    Serial.println("Card failed, or not present. Freezing...");
-    // don't do anything more:
-    while (1);
-  }
-  Serial.println("SD card initialized.");
-
-  // Create or open a file called "NAV_PVT.ubx" on the SD card.
-  // If the file already exists, the new data is appended to the end of the file.
-  myFile = SD.open("NAV_PVT.ubx", FILE_WRITE);
-  if(!myFile)
-  {
-    Serial.println(F("Failed to create UBX data file! Freezing..."));
-    while (1);
-  }
-
-  //myGNSS.enableDebugging(); // Uncomment this line to enable helpful GNSS debug messages on Serial
-
-  // NAV PVT messages are 100 bytes long.
-  // In this example, the data will arrive no faster than one message per second.
-  // So, setting the file buffer size to 301 bytes should be more than adequate.
-  // I.e. room for three messages plus an empty tail byte.
-  myGNSS.setFileBufferSize(301); // setFileBufferSize must be called _before_ .begin
-
-  if (myGNSS.begin() == false) //Connect to the u-blox module using Wire port
-  {
-    Serial.println(F("u-blox GNSS not detected at default I2C address. Please check wiring. Freezing..."));
-    while (1);
-  }
-
-  // Uncomment the next line if you want to reset your module back to the default settings with 1Hz navigation rate
-  // (This will also disable any "auto" messages that were enabled and saved by other examples and reduce the load on the I2C bus)
-  //myGNSS.factoryDefault(); delay(5000);
-
-  myGNSS.setI2COutput(COM_TYPE_UBX); //Set the I2C port to output UBX only (turn off NMEA noise)
-  myGNSS.saveConfigSelective(VAL_CFG_SUBSEC_IOPORT); //Save (only) the communications port settings to flash and BBR
-
-  myGNSS.setNavigationFrequency(1); //Produce one navigation solution per second
-
-  myGNSS.setAutoPVTcallback(&printPVTdata); // Enable automatic NAV PVT messages with callback to printPVTdata
-
-  myGNSS.logNAVPVT(); // Enable NAV PVT data logging
-
-  Serial.println(F("Press any key to stop logging."));
-}
-
-void loop()
-{
-  myGNSS.checkUblox(); // Check for the arrival of new data and process it.
-  myGNSS.checkCallbacks(); // Check if any callbacks are waiting to be processed.
-
-  if (myGNSS.fileBufferAvailable() >= packetLength) // Check to see if a new packetLength-byte NAV PVT message has been stored
-  {
-    uint8_t myBuffer[packetLength]; // Create our own buffer to hold the data while we write it to SD card
-
-    myGNSS.extractFileBufferData((uint8_t *)&myBuffer, packetLength); // Extract exactly packetLength bytes from the UBX file buffer and put them into myBuffer
-
-    myFile.write(myBuffer, packetLength); // Write exactly packetLength bytes from myBuffer to the ubxDataFile on the SD card
-
-    //printBuffer(myBuffer); // Uncomment this line to print the data as Hexadecimal bytes
-  }
-
-  if (Serial.available()) // Check if the user wants to stop logging
-  {
-    myFile.close(); // Close the data file
-    Serial.println(F("Logging stopped. Freezing..."));
-    while(1); // Do nothing more
-  }
-
-  Serial.print(".");
-  delay(50);
-}
-
-// Print the buffer contents as Hexadecimal bytes
-// You should see:
-// SYNC CHAR 1: 0xB5
-// SYNC CHAR 2: 0x62
-// CLASS: 0x01 for NAV
-// ID: 0x07 for PVT
-// LENGTH: 2-bytes Little Endian (0x5C00 = 92 bytes for NAV PVT)
-// PAYLOAD: LENGTH bytes
-// CHECKSUM_A
-// CHECKSUM_B
-// Please see the u-blox protocol specification for more details
-void printBuffer(uint8_t *ptr)
-{
-  for (int i = 0; i < packetLength; i++)
-  {
-    if (ptr[i] < 16) Serial.print("0"); // Print a leading zero if required
-    Serial.print(ptr[i], HEX); // Print the byte as Hexadecimal
-    Serial.print(" ");
-  }
-  Serial.println();
-}
diff --git a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Data_Logging/DataLoggingExample2_TIM_TM2/DataLoggingExample2_TIM_TM2.ino b/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Data_Logging/DataLoggingExample2_TIM_TM2/DataLoggingExample2_TIM_TM2.ino
deleted file mode 100644
index 05417ae..0000000
--- a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Data_Logging/DataLoggingExample2_TIM_TM2/DataLoggingExample2_TIM_TM2.ino
+++ /dev/null
@@ -1,241 +0,0 @@
-/*
-  Configuring the GNSS to automatically send TIM TM2 reports over I2C and log them to file on SD card
-  By: Paul Clark
-  SparkFun Electronics
-  Date: December 30th, 2020
-  License: MIT. See license file for more information but you can
-  basically do whatever you want with this code.
-
-  This example shows how to configure the u-blox GNSS to send TIM TM2 reports automatically
-  and log the data to SD card in UBX format.
-
-  This code is intended to be run on the MicroMod Data Logging Carrier Board using the Artemis Processor
-  but can be adapted by changing the chip select pin and SPI definitions:
-  https://www.sparkfun.com/products/16829
-  https://www.sparkfun.com/products/16401
-
-  Hardware Connections:
-  Please see: https://learn.sparkfun.com/tutorials/micromod-data-logging-carrier-board-hookup-guide
-  Insert the Artemis Processor into the MicroMod Data Logging Carrier Board and secure with the screw.
-  Connect your GNSS breakout to the Carrier Board using a Qwiic cable.
-  Connect an antenna to your GNSS board if required.
-  Insert a formatted micro-SD card into the socket on the Carrier Board.
-  Connect the Carrier Board to your computer using a USB-C cable.
-  Ensure you have the SparkFun Apollo3 boards installed: http://boardsmanager/All#SparkFun_Apollo3
-  This code has been tested using version 1.2.1 of the Apollo3 boards on Arduino IDE 1.8.13.
-  Select "SparkFun Artemis MicroMod" as the board type.
-  Press upload to upload the code onto the Artemis.
-  Open the Serial Monitor at 115200 baud to see the output.
-
-  To minimise I2C bus errors, it is a good idea to open the I2C pull-up split pad links on
-  both the MicroMod Data Logging Carrier Board and the u-blox module breakout.
-
-  Connecting the PPS (Pulse Per Second) breakout pin to the INT (Interrupt) pin with a jumper wire
-  will cause a TIM TM2 message to be produced once per second. You can then study the timing of the
-  pulse edges with nanosecond resolution!
-
-  Note: TIM TM2 can only capture the timing of one rising edge and one falling edge per
-  navigation solution. So with setNavigationFrequency set to 1Hz, we can only see the timing
-  of one rising and one falling edge per second. If the frequency of the signal on the INT pin
-  is higher than 1Hz, we will only be able to see the timing of the most recent edges.
-  However, the module can count the number of rising edges too, at rates faster than the navigation rate.
-
-  TIM TM2 messages are only produced when a rising or falling edge is detected on the INT pin.
-  If you disconnect your PPS to INT jumper wire, the messages will stop.
-
-  Data is logged in u-blox UBX format. Please see the u-blox protocol specification for more details.
-  You can replay and analyze the data using u-center:
-  https://www.u-blox.com/en/product/u-center
-
-  Feel like supporting open source hardware?
-  Buy a board from SparkFun!
-  ZED-F9P RTK2: https://www.sparkfun.com/products/15136
-  NEO-M8P RTK: https://www.sparkfun.com/products/15005
-  NEO-M9N: https://www.sparkfun.com/products/17285
-
-*/
-
-#include <SPI.h>
-#include <SD.h>
-#include <Wire.h> //Needed for I2C to GNSS
-
-#include <SparkFun_u-blox_GNSS_Arduino_Library.h> //Click here to get the library: http://librarymanager/All#SparkFun_u-blox_GNSS
-SFE_UBLOX_GNSS myGNSS;
-
-File myFile; //File that all GNSS data is written to
-
-#define sdChipSelect CS //Primary SPI Chip Select is CS for the MicroMod Artemis Processor. Adjust for your processor if necessary.
-
-#define packetLength 36 // TIM TM2 is 28 + 8 bytes in length (including the sync chars, class, id, length and checksum bytes)
-
-int dotsPrinted = 0; // Print dots in rows of 50 while waiting for a TIM TM2 message
-
-// Callback: printTIMTM2data will be called when new TIM TM2 data arrives
-// See u-blox_structs.h for the full definition of UBX_TIM_TM2_data_t
-//         _____  You can use any name you like for the callback. Use the same name when you call setAutoTIMTM2callback
-//        /                  _____  This _must_ be UBX_TIM_TM2_data_t
-//        |                 /                   _____ You can use any name you like for the struct
-//        |                 |                  /
-//        |                 |                  |
-void printTIMTM2data(UBX_TIM_TM2_data_t ubxDataStruct)
-{
-  Serial.println();
-
-  Serial.print(F("newFallingEdge: ")); // 1 if a new falling edge was detected
-  Serial.print(ubxDataStruct.flags.bits.newFallingEdge);
-
-  Serial.print(F(" newRisingEdge: ")); // 1 if a new rising edge was detected
-  Serial.print(ubxDataStruct.flags.bits.newRisingEdge);
-
-  Serial.print(F(" Rising Edge Counter: ")); // Rising edge counter
-  Serial.print(ubxDataStruct.count);
-
-  Serial.print(F(" towMsR: ")); // Time Of Week of rising edge (ms)
-  Serial.print(ubxDataStruct.towMsR);
-
-  Serial.print(F(" towSubMsR: ")); // Millisecond fraction of Time Of Week of rising edge in nanoseconds
-  Serial.print(ubxDataStruct.towSubMsR);
-
-  Serial.print(F(" towMsF: ")); // Time Of Week of falling edge (ms)
-  Serial.print(ubxDataStruct.towMsF);
-
-  Serial.print(F(" towSubMsF: ")); // Millisecond fraction of Time Of Week of falling edge in nanoseconds
-  Serial.println(ubxDataStruct.towSubMsF);
-
-  dotsPrinted = 0; // Reset dotsPrinted
-}
-
-void setup()
-{
-  Serial.begin(115200);
-  while (!Serial); //Wait for user to open terminal
-  Serial.println("SparkFun u-blox Example");
-
-  Wire.begin(); // Start I2C communication with the GNSS
-
-#if defined(AM_PART_APOLLO3)
-  Wire.setPullups(0); // On the Artemis, we can disable the internal I2C pull-ups too to help reduce bus errors
-#endif
-
-  while (Serial.available()) // Make sure the Serial buffer is empty
-  {
-    Serial.read();
-  }
-
-  Serial.println(F("Press any key to start logging."));
-
-  while (!Serial.available()) // Wait for the user to press a key
-  {
-    ; // Do nothing
-  }
-
-  delay(100); // Wait, just in case multiple characters were sent
-
-  while (Serial.available()) // Empty the Serial buffer
-  {
-    Serial.read();
-  }
-
-  Serial.println("Initializing SD card...");
-
-  // See if the card is present and can be initialized:
-  if (!SD.begin(sdChipSelect))
-  {
-    Serial.println("Card failed, or not present. Freezing...");
-    // don't do anything more:
-    while (1);
-  }
-  Serial.println("SD card initialized.");
-
-  // Create or open a file called "TIM_TM2.ubx" on the SD card.
-  // If the file already exists, the new data is appended to the end of the file.
-  myFile = SD.open("TIM_TM2.ubx", FILE_WRITE);
-  if(!myFile)
-  {
-    Serial.println(F("Failed to create UBX data file! Freezing..."));
-    while (1);
-  }
-
-  //myGNSS.enableDebugging(); // Uncomment this line to enable helpful GNSS debug messages on Serial
-
-  // TIM TM2 messages are 36 bytes long.
-  // In this example, the data will arrive no faster than one message per second.
-  // So, setting the file buffer size to 109 bytes should be more than adequate.
-  // I.e. room for three messages plus an empty tail byte.
-  myGNSS.setFileBufferSize(109); // setFileBufferSize must be called _before_ .begin
-
-  if (myGNSS.begin() == false) //Connect to the u-blox module using Wire port
-  {
-    Serial.println(F("u-blox GNSS not detected at default I2C address. Please check wiring. Freezing..."));
-    while (1);
-  }
-
-  // Uncomment the next line if you want to reset your module back to the default settings with 1Hz navigation rate
-  // (This will also disable any "auto" messages that were enabled and saved by other examples and reduce the load on the I2C bus)
-  //myGNSS.factoryDefault(); delay(5000);
-
-  myGNSS.setI2COutput(COM_TYPE_UBX); //Set the I2C port to output UBX only (turn off NMEA noise)
-  myGNSS.saveConfigSelective(VAL_CFG_SUBSEC_IOPORT); //Save (only) the communications port settings to flash and BBR
-
-  myGNSS.setNavigationFrequency(1); //Produce one navigation solution per second
-
-  myGNSS.setAutoTIMTM2callback(&printTIMTM2data); // Enable automatic TIM TM2 messages with callback to printTIMTM2data
-
-  myGNSS.logTIMTM2(); // Enable TIM TM2 data logging
-
-  Serial.println(F("Press any key to stop logging."));
-}
-
-void loop()
-{
-  myGNSS.checkUblox(); // Check for the arrival of new data and process it.
-  myGNSS.checkCallbacks(); // Check if any callbacks are waiting to be processed.
-
-  if (myGNSS.fileBufferAvailable() >= packetLength) // Check to see if a new packetLength-byte TIM TM2 message has been stored
-  {
-    uint8_t myBuffer[packetLength]; // Create our own buffer to hold the data while we write it to SD card
-
-    myGNSS.extractFileBufferData((uint8_t *)&myBuffer, packetLength); // Extract exactly packetLength bytes from the UBX file buffer and put them into myBuffer
-
-    myFile.write(myBuffer, packetLength); // Write exactly packetLength bytes from myBuffer to the ubxDataFile on the SD card
-
-    //printBuffer(myBuffer); // Uncomment this line to print the data
-  }
-
-  if (Serial.available()) // Check if the user wants to stop logging
-  {
-    myFile.close(); // Close the data file
-    Serial.println(F("Logging stopped. Freezing..."));
-    while(1); // Do nothing more
-  }
-
-  Serial.print("."); // Print dots in rows of 50
-  delay(50);
-  if (++dotsPrinted > 50)
-  {
-    Serial.println();
-    dotsPrinted = 0;
-  }
-}
-
-// Print the buffer contents as Hexadecimal
-// You should see:
-// SYNC CHAR 1: 0xB5
-// SYNC CHAR 2: 0x62
-// CLASS: 0x0D for TIM
-// ID: 0x03 for TM2
-// LENGTH: 2-bytes Little Endian (0x1C00 = 28 bytes for TIM TM2)
-// PAYLOAD: LENGTH bytes
-// CHECKSUM_A
-// CHECKSUM_B
-// Please see the u-blox protocol specification for more details
-void printBuffer(uint8_t *ptr)
-{
-  for (int i = 0; i < packetLength; i++)
-  {
-    if (ptr[i] < 16) Serial.print("0"); // Print a leading zero if required
-    Serial.print(ptr[i], HEX); // Print the byte as Hexadecimal
-    Serial.print(" ");
-  }
-  Serial.println();
-}
diff --git a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Data_Logging/DataLoggingExample3_RXM_SFRBX_and_RAWX/DataLoggingExample3_RXM_SFRBX_and_RAWX.ino b/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Data_Logging/DataLoggingExample3_RXM_SFRBX_and_RAWX/DataLoggingExample3_RXM_SFRBX_and_RAWX.ino
deleted file mode 100644
index 952f840..0000000
--- a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Data_Logging/DataLoggingExample3_RXM_SFRBX_and_RAWX/DataLoggingExample3_RXM_SFRBX_and_RAWX.ino
+++ /dev/null
@@ -1,273 +0,0 @@
-/*
-  Configuring the GNSS to automatically send RXM SFRBX and RAWX reports over I2C and log them to file on SD card
-  By: Paul Clark
-  SparkFun Electronics
-  Date: December 30th, 2020
-  License: MIT. See license file for more information but you can
-  basically do whatever you want with this code.
-
-  This example shows how to configure the u-blox GNSS to send RXM SFRBX and RAWX reports automatically
-  and log the data to SD card in UBX format.
-
-  ** Please note: this example will only work on u-blox ADR or High Precision GNSS or Time Sync products **
-
-  ** Please note: this example will only work on processors like the Artemis which have plenty of RAM available **
-
-  Data is logged in u-blox UBX format. Please see the u-blox protocol specification for more details.
-  You can replay and analyze the data using u-center:
-  https://www.u-blox.com/en/product/u-center
-  Or you can use (e.g.) RTKLIB to analyze the data and extract your precise location or produce
-  Post-Processed Kinematic data:
-  https://rtklibexplorer.wordpress.com/
-  http://rtkexplorer.com/downloads/rtklib-code/
-
-  This code is intended to be run on the MicroMod Data Logging Carrier Board using the Artemis Processor
-  but can be adapted by changing the chip select pin and SPI definitions:
-  https://www.sparkfun.com/products/16829
-  https://www.sparkfun.com/products/16401
-
-  Hardware Connections:
-  Please see: https://learn.sparkfun.com/tutorials/micromod-data-logging-carrier-board-hookup-guide
-  Insert the Artemis Processor into the MicroMod Data Logging Carrier Board and secure with the screw.
-  Connect your GNSS breakout to the Carrier Board using a Qwiic cable.
-  Connect an antenna to your GNSS board if required.
-  Insert a formatted micro-SD card into the socket on the Carrier Board.
-  Connect the Carrier Board to your computer using a USB-C cable.
-  Ensure you have the SparkFun Apollo3 boards installed: http://boardsmanager/All#SparkFun_Apollo3
-  This code has been tested using version 1.2.1 of the Apollo3 boards on Arduino IDE 1.8.13.
-  Select "SparkFun Artemis MicroMod" as the board type.
-  Press upload to upload the code onto the Artemis.
-  Open the Serial Monitor at 115200 baud to see the output.
-
-  To minimise I2C bus errors, it is a good idea to open the I2C pull-up split pad links on
-  both the MicroMod Data Logging Carrier Board and the u-blox module breakout.
-
-  Feel like supporting open source hardware?
-  Buy a board from SparkFun!
-  ZED-F9P RTK2: https://www.sparkfun.com/products/15136
-  NEO-M8P RTK: https://www.sparkfun.com/products/15005
-*/
-
-#include <SPI.h>
-#include <SD.h>
-#include <Wire.h> //Needed for I2C to GNSS
-
-#include <SparkFun_u-blox_GNSS_Arduino_Library.h> //Click here to get the library: http://librarymanager/All#SparkFun_u-blox_GNSS
-SFE_UBLOX_GNSS myGNSS;
-
-File myFile; //File that all GNSS data is written to
-
-#define sdChipSelect CS //Primary SPI Chip Select is CS for the MicroMod Artemis Processor. Adjust for your processor if necessary.
-
-#define sdWriteSize 512 // Write data to the SD card in blocks of 512 bytes
-#define fileBufferSize 16384 // Allocate 16KBytes of RAM for UBX message storage
-
-unsigned long lastPrint; // Record when the last Serial print took place
-
-// Note: we'll keep a count of how many SFRBX and RAWX messages arrive - but the count will not be completely accurate.
-// If two or more SFRBX messages arrive together as a group and are processed by one call to checkUblox, the count will
-// only increase by one.
-
-int numSFRBX = 0; // Keep count of how many SFRBX message groups have been received (see note above)
-int numRAWX = 0; // Keep count of how many RAWX message groups have been received (see note above)
-
-// Callback: newSFRBX will be called when new RXM SFRBX data arrives
-// See u-blox_structs.h for the full definition of UBX_RXMSFRBX_data_t
-//         _____  You can use any name you like for the callback. Use the same name when you call setAutoRXMSFRBXcallback
-//        /                  _____  This _must_ be UBX_RXM_SFRBX_data_t
-//        |                 /                   _____ You can use any name you like for the struct
-//        |                 |                  /
-//        |                 |                  |
-void newSFRBX(UBX_RXM_SFRBX_data_t ubxDataStruct)
-{
-  numSFRBX++; // Increment the count
-}
-
-// Callback: newRAWX will be called when new RXM RAWX data arrives
-// See u-blox_structs.h for the full definition of UBX_RXMRAWX_data_t
-//         _____  You can use any name you like for the callback. Use the same name when you call setAutoRXMRAWXcallback
-//        /             _____  This _must_ be UBX_RXM_RAWX_data_t
-//        |            /                _____ You can use any name you like for the struct
-//        |            |               /
-//        |            |               |
-void newRAWX(UBX_RXM_RAWX_data_t ubxDataStruct)
-{
-  numRAWX++; // Increment the count
-}
-
-void setup()
-{
-  Serial.begin(115200);
-  while (!Serial); //Wait for user to open terminal
-  Serial.println("SparkFun u-blox Example");
-
-  pinMode(LED_BUILTIN, OUTPUT); // Flash LED_BUILTIN each time we write to the SD card
-  digitalWrite(LED_BUILTIN, LOW);
-
-  Wire.begin(); // Start I2C communication
-
-#if defined(AM_PART_APOLLO3)
-  Wire.setPullups(0); // On the Artemis, we can disable the internal I2C pull-ups too to help reduce bus errors
-#endif
-
-  while (Serial.available()) // Make sure the Serial buffer is empty
-  {
-    Serial.read();
-  }
-
-  Serial.println(F("Press any key to start logging."));
-
-  while (!Serial.available()) // Wait for the user to press a key
-  {
-    ; // Do nothing
-  }
-
-  delay(100); // Wait, just in case multiple characters were sent
-
-  while (Serial.available()) // Empty the Serial buffer
-  {
-    Serial.read();
-  }
-
-  Serial.println("Initializing SD card...");
-
-  // See if the card is present and can be initialized:
-  if (!SD.begin(sdChipSelect))
-  {
-    Serial.println("Card failed, or not present. Freezing...");
-    // don't do anything more:
-    while (1);
-  }
-  Serial.println("SD card initialized.");
-
-  // Create or open a file called "RXM_RAWX.ubx" on the SD card.
-  // If the file already exists, the new data is appended to the end of the file.
-  myFile = SD.open("RXM_RAWX.ubx", FILE_WRITE);
-  if(!myFile)
-  {
-    Serial.println(F("Failed to create UBX data file! Freezing..."));
-    while (1);
-  }
-
-  //myGNSS.enableDebugging(); // Uncomment this line to enable lots of helpful GNSS debug messages on Serial
-  //myGNSS.enableDebugging(Serial, true); // Or, uncomment this line to enable only the important GNSS debug messages on Serial
-
-  myGNSS.disableUBX7Fcheck(); // RAWX data can legitimately contain 0x7F, so we need to disable the "7F" check in checkUbloxI2C
-
-  // RAWX messages can be over 2KBytes in size, so we need to make sure we allocate enough RAM to hold all the data.
-  // SD cards can occasionally 'hiccup' and a write takes much longer than usual. The buffer needs to be big enough
-  // to hold the backlog of data if/when this happens.
-  // getMaxFileBufferAvail will tell us the maximum number of bytes which the file buffer has contained.
-  myGNSS.setFileBufferSize(fileBufferSize); // setFileBufferSize must be called _before_ .begin
-
-  if (myGNSS.begin() == false) //Connect to the u-blox module using Wire port
-  {
-    Serial.println(F("u-blox GNSS not detected at default I2C address. Please check wiring. Freezing..."));
-    while (1);
-  }
-
-  // Uncomment the next line if you want to reset your module back to the default settings with 1Hz navigation rate
-  // (This will also disable any "auto" messages that were enabled and saved by other examples and reduce the load on the I2C bus)
-  //myGNSS.factoryDefault(); delay(5000);
-
-  myGNSS.setI2COutput(COM_TYPE_UBX); //Set the I2C port to output UBX only (turn off NMEA noise)
-  myGNSS.saveConfigSelective(VAL_CFG_SUBSEC_IOPORT); //Save (only) the communications port settings to flash and BBR
-
-  myGNSS.setNavigationFrequency(1); //Produce one navigation solution per second (that's plenty for Precise Point Positioning)
-
-  myGNSS.setAutoRXMSFRBXcallback(&newSFRBX); // Enable automatic RXM SFRBX messages with callback to newSFRBX
-
-  myGNSS.logRXMSFRBX(); // Enable RXM SFRBX data logging
-
-  myGNSS.setAutoRXMRAWXcallback(&newRAWX); // Enable automatic RXM RAWX messages with callback to newRAWX
-
-  myGNSS.logRXMRAWX(); // Enable RXM RAWX data logging
-
-  Serial.println(F("Press any key to stop logging."));
-
-  lastPrint = millis(); // Initialize lastPrint
-}
-
-void loop()
-{
-  // =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
-
-  myGNSS.checkUblox(); // Check for the arrival of new data and process it.
-  myGNSS.checkCallbacks(); // Check if any callbacks are waiting to be processed.
-
-  // =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
-
-  while (myGNSS.fileBufferAvailable() >= sdWriteSize) // Check to see if we have at least sdWriteSize waiting in the buffer
-  {
-    digitalWrite(LED_BUILTIN, HIGH); // Flash LED_BUILTIN each time we write to the SD card
-
-    uint8_t myBuffer[sdWriteSize]; // Create our own buffer to hold the data while we write it to SD card
-
-    myGNSS.extractFileBufferData((uint8_t *)&myBuffer, sdWriteSize); // Extract exactly sdWriteSize bytes from the UBX file buffer and put them into myBuffer
-
-    myFile.write(myBuffer, sdWriteSize); // Write exactly sdWriteSize bytes from myBuffer to the ubxDataFile on the SD card
-
-    // In case the SD writing is slow or there is a lot of data to write, keep checking for the arrival of new data
-    myGNSS.checkUblox(); // Check for the arrival of new data and process it.
-    myGNSS.checkCallbacks(); // Check if any callbacks are waiting to be processed.
-
-    digitalWrite(LED_BUILTIN, LOW); // Turn LED_BUILTIN off again
-  }
-
-  // =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
-
-  if (millis() > (lastPrint + 1000)) // Print the message count once per second
-  {
-    Serial.print(F("Number of message groups received: SFRBX: ")); // Print how many message groups have been received (see note above)
-    Serial.print(numSFRBX);
-    Serial.print(F(" RAWX: "));
-    Serial.println(numRAWX);
-
-    uint16_t maxBufferBytes = myGNSS.getMaxFileBufferAvail(); // Get how full the file buffer has been (not how full it is now)
-
-    //Serial.print(F("The maximum number of bytes which the file buffer has contained is: ")); // It is a fun thing to watch how full the buffer gets
-    //Serial.println(maxBufferBytes);
-
-    if (maxBufferBytes > ((fileBufferSize / 5) * 4)) // Warn the user if fileBufferSize was more than 80% full
-    {
-      Serial.println(F("Warning: the file buffer has been over 80% full. Some data may have been lost."));
-    }
-
-    lastPrint = millis(); // Update lastPrint
-  }
-
-  // =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
-
-  if (Serial.available()) // Check if the user wants to stop logging
-  {
-    uint16_t remainingBytes = myGNSS.fileBufferAvailable(); // Check if there are any bytes remaining in the file buffer
-
-    while (remainingBytes > 0) // While there is still data in the file buffer
-    {
-      digitalWrite(LED_BUILTIN, HIGH); // Flash LED_BUILTIN while we write to the SD card
-
-      uint8_t myBuffer[sdWriteSize]; // Create our own buffer to hold the data while we write it to SD card
-
-      uint16_t bytesToWrite = remainingBytes; // Write the remaining bytes to SD card sdWriteSize bytes at a time
-      if (bytesToWrite > sdWriteSize)
-      {
-        bytesToWrite = sdWriteSize;
-      }
-
-      myGNSS.extractFileBufferData((uint8_t *)&myBuffer, bytesToWrite); // Extract bytesToWrite bytes from the UBX file buffer and put them into myBuffer
-
-      myFile.write(myBuffer, bytesToWrite); // Write bytesToWrite bytes from myBuffer to the ubxDataFile on the SD card
-
-      remainingBytes -= bytesToWrite; // Decrement remainingBytes
-    }
-
-    digitalWrite(LED_BUILTIN, LOW); // Turn LED_BUILTIN off
-
-    myFile.close(); // Close the data file
-
-    Serial.println(F("Logging stopped. Freezing..."));
-    while(1); // Do nothing more
-  }
-
-  // =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
-}
diff --git a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Data_Logging/DataLoggingExample4_RXM_without_Callbacks/DataLoggingExample4_RXM_without_Callbacks.ino b/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Data_Logging/DataLoggingExample4_RXM_without_Callbacks/DataLoggingExample4_RXM_without_Callbacks.ino
deleted file mode 100644
index 9e4737c..0000000
--- a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Data_Logging/DataLoggingExample4_RXM_without_Callbacks/DataLoggingExample4_RXM_without_Callbacks.ino
+++ /dev/null
@@ -1,247 +0,0 @@
-/*
-  Configuring the GNSS to automatically send RXM SFRBX and RAWX reports over I2C and log them to file on SD card
-  ** without using callbacks **
-  By: Paul Clark
-  SparkFun Electronics
-  Date: December 30th, 2020
-  License: MIT. See license file for more information but you can
-  basically do whatever you want with this code.
-
-  This example shows how to configure the u-blox GNSS to send RXM SFRBX and RAWX reports automatically
-  and log the data to SD card in UBX format ** without using callbacks **
-
-  ** Please note: this example will only work on u-blox ADR or High Precision GNSS or Time Sync products **
-
-  ** Please note: this example will only work on processors like the Artemis which have plenty of RAM available **
-
-  Data is logged in u-blox UBX format. Please see the u-blox protocol specification for more details.
-  You can replay and analyze the data using u-center:
-  https://www.u-blox.com/en/product/u-center
-  Or you can use (e.g.) RTKLIB to analyze the data and extract your precise location or produce
-  Post-Processed Kinematic data:
-  https://rtklibexplorer.wordpress.com/
-  http://rtkexplorer.com/downloads/rtklib-code/
-
-  This code is intended to be run on the MicroMod Data Logging Carrier Board using the Artemis Processor
-  but can be adapted by changing the chip select pin and SPI definitions:
-  https://www.sparkfun.com/products/16829
-  https://www.sparkfun.com/products/16401
-
-  Hardware Connections:
-  Please see: https://learn.sparkfun.com/tutorials/micromod-data-logging-carrier-board-hookup-guide
-  Insert the Artemis Processor into the MicroMod Data Logging Carrier Board and secure with the screw.
-  Connect your GNSS breakout to the Carrier Board using a Qwiic cable.
-  Connect an antenna to your GNSS board if required.
-  Insert a formatted micro-SD card into the socket on the Carrier Board.
-  Connect the Carrier Board to your computer using a USB-C cable.
-  Ensure you have the SparkFun Apollo3 boards installed: http://boardsmanager/All#SparkFun_Apollo3
-  This code has been tested using version 1.2.1 of the Apollo3 boards on Arduino IDE 1.8.13.
-  Select "SparkFun Artemis MicroMod" as the board type.
-  Press upload to upload the code onto the Artemis.
-  Open the Serial Monitor at 115200 baud to see the output.
-
-  To minimise I2C bus errors, it is a good idea to open the I2C pull-up split pad links on
-  both the MicroMod Data Logging Carrier Board and the u-blox module breakout.
-
-  Feel like supporting open source hardware?
-  Buy a board from SparkFun!
-  ZED-F9P RTK2: https://www.sparkfun.com/products/15136
-  NEO-M8P RTK: https://www.sparkfun.com/products/15005
-*/
-
-#include <SPI.h>
-#include <SD.h>
-#include <Wire.h> //Needed for I2C to GNSS
-
-#include <SparkFun_u-blox_GNSS_Arduino_Library.h> //Click here to get the library: http://librarymanager/All#SparkFun_u-blox_GNSS
-SFE_UBLOX_GNSS myGNSS;
-
-File myFile; //File that all GNSS data is written to
-
-#define sdChipSelect CS //Primary SPI Chip Select is CS for the MicroMod Artemis Processor. Adjust for your processor if necessary.
-
-#define sdWriteSize 512 // Write data to the SD card in blocks of 512 bytes
-#define fileBufferSize 16384 // Allocate 16KBytes of RAM for UBX message storage
-
-unsigned long lastPrint; // Record when the last Serial print took place
-unsigned long bytesWritten = 0; // Record how many bytes have been written to SD card
-
-void setup()
-{
-  Serial.begin(115200);
-  while (!Serial); //Wait for user to open terminal
-  Serial.println("SparkFun u-blox Example");
-
-  pinMode(LED_BUILTIN, OUTPUT); // Flash LED_BUILTIN each time we write to the SD card
-  digitalWrite(LED_BUILTIN, LOW);
-
-  Wire.begin(); // Start I2C communication
-
-#if defined(AM_PART_APOLLO3)
-  Wire.setPullups(0); // On the Artemis, we can disable the internal I2C pull-ups too to help reduce bus errors
-#endif
-
-  while (Serial.available()) // Make sure the Serial buffer is empty
-  {
-    Serial.read();
-  }
-
-  Serial.println(F("Press any key to start logging."));
-
-  while (!Serial.available()) // Wait for the user to press a key
-  {
-    ; // Do nothing
-  }
-
-  delay(100); // Wait, just in case multiple characters were sent
-  
-  while (Serial.available()) // Empty the Serial buffer
-  {
-    Serial.read();
-  }
-
-  Serial.println("Initializing SD card...");
-
-  // See if the card is present and can be initialized:
-  if (!SD.begin(sdChipSelect))
-  {
-    Serial.println("Card failed, or not present. Freezing...");
-    // don't do anything more:
-    while (1);
-  }
-  Serial.println("SD card initialized.");
-
-  // Create or open a file called "RXM_RAWX.ubx" on the SD card.
-  // If the file already exists, the new data is appended to the end of the file.
-  myFile = SD.open("RXM_RAWX.ubx", FILE_WRITE);
-  if(!myFile)
-  {
-    Serial.println(F("Failed to create UBX data file! Freezing..."));
-    while (1);
-  }
-
-  //myGNSS.enableDebugging(); // Uncomment this line to enable lots of helpful GNSS debug messages on Serial
-  //myGNSS.enableDebugging(Serial, true); // Or, uncomment this line to enable only the important GNSS debug messages on Serial
-
-  myGNSS.disableUBX7Fcheck(); // RAWX data can legitimately contain 0x7F, so we need to disable the "7F" check in checkUbloxI2C
-
-  // RAWX messages can be over 2KBytes in size, so we need to make sure we allocate enough RAM to hold all the data.
-  // SD cards can occasionally 'hiccup' and a write takes much longer than usual. The buffer needs to be big enough
-  // to hold the backlog of data if/when this happens.
-  // getMaxFileBufferAvail will tell us the maximum number of bytes which the file buffer has contained.
-  myGNSS.setFileBufferSize(fileBufferSize); // setFileBufferSize must be called _before_ .begin
-
-  if (myGNSS.begin() == false) //Connect to the u-blox module using Wire port
-  {
-    Serial.println(F("u-blox GNSS not detected at default I2C address. Please check wiring. Freezing..."));
-    while (1);
-  }
-
-  // Uncomment the next line if you want to reset your module back to the default settings with 1Hz navigation rate
-  // (This will also disable any "auto" messages that were enabled and saved by other examples and reduce the load on the I2C bus)
-  //myGNSS.factoryDefault(); delay(5000);
-
-  myGNSS.setI2COutput(COM_TYPE_UBX); //Set the I2C port to output UBX only (turn off NMEA noise)
-  myGNSS.saveConfigSelective(VAL_CFG_SUBSEC_IOPORT); //Save (only) the communications port settings to flash and BBR
-  
-  myGNSS.setNavigationFrequency(1); //Produce one navigation solution per second (that's plenty for Precise Point Positioning)
-
-  myGNSS.setAutoRXMSFRBX(true, false); // Enable automatic RXM SFRBX messages: without callback; without implicit update
-  
-  myGNSS.logRXMSFRBX(); // Enable RXM SFRBX data logging
-
-  myGNSS.setAutoRXMRAWX(true, false); // Enable automatic RXM RAWX messages: without callback; without implicit update
-  
-  myGNSS.logRXMRAWX(); // Enable RXM RAWX data logging
-
-  Serial.println(F("Press any key to stop logging."));
-
-  lastPrint = millis(); // Initialize lastPrint
-}
-
-void loop()
-{
-  // =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
-
-  myGNSS.checkUblox(); // Check for the arrival of new data and process it.
-
-  // =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
-
-  while (myGNSS.fileBufferAvailable() >= sdWriteSize) // Check to see if we have at least sdWriteSize waiting in the buffer
-  {
-    digitalWrite(LED_BUILTIN, HIGH); // Flash LED_BUILTIN each time we write to the SD card
-  
-    uint8_t myBuffer[sdWriteSize]; // Create our own buffer to hold the data while we write it to SD card
-
-    myGNSS.extractFileBufferData((uint8_t *)&myBuffer, sdWriteSize); // Extract exactly sdWriteSize bytes from the UBX file buffer and put them into myBuffer
-
-    myFile.write(myBuffer, sdWriteSize); // Write exactly sdWriteSize bytes from myBuffer to the ubxDataFile on the SD card
-
-    bytesWritten += sdWriteSize; // Update bytesWritten
-
-    // In case the SD writing is slow or there is a lot of data to write, keep checking for the arrival of new data
-    myGNSS.checkUblox(); // Check for the arrival of new data and process it.
-
-    digitalWrite(LED_BUILTIN, LOW); // Turn LED_BUILTIN off again
-  }
-
-  // =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
-
-  if (millis() > (lastPrint + 1000)) // Print bytesWritten once per second
-  {
-    Serial.print(F("The number of bytes written to SD card is ")); // Print how many bytes have been written to SD card
-    Serial.println(bytesWritten);
-
-    uint16_t maxBufferBytes = myGNSS.getMaxFileBufferAvail(); // Get how full the file buffer has been (not how full it is now)
-    
-    //Serial.print(F("The maximum number of bytes which the file buffer has contained is: ")); // It is a fun thing to watch how full the buffer gets
-    //Serial.println(maxBufferBytes);
-
-    if (maxBufferBytes > ((fileBufferSize / 5) * 4)) // Warn the user if fileBufferSize was more than 80% full
-    {
-      Serial.println(F("Warning: the file buffer has been over 80% full. Some data may have been lost."));
-    }
-    
-    lastPrint = millis(); // Update lastPrint
-  }
-
-  // =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
-
-  if (Serial.available()) // Check if the user wants to stop logging
-  {
-    uint16_t remainingBytes = myGNSS.fileBufferAvailable(); // Check if there are any bytes remaining in the file buffer
-    
-    while (remainingBytes > 0) // While there is still data in the file buffer
-    {
-      digitalWrite(LED_BUILTIN, HIGH); // Flash LED_BUILTIN while we write to the SD card
-      
-      uint8_t myBuffer[sdWriteSize]; // Create our own buffer to hold the data while we write it to SD card
-
-      uint16_t bytesToWrite = remainingBytes; // Write the remaining bytes to SD card sdWriteSize bytes at a time
-      if (bytesToWrite > sdWriteSize)
-      {
-        bytesToWrite = sdWriteSize;
-      }
-  
-      myGNSS.extractFileBufferData((uint8_t *)&myBuffer, bytesToWrite); // Extract bytesToWrite bytes from the UBX file buffer and put them into myBuffer
-
-      myFile.write(myBuffer, bytesToWrite); // Write bytesToWrite bytes from myBuffer to the ubxDataFile on the SD card
-
-      bytesWritten += bytesToWrite; // Update bytesWritten
-
-      remainingBytes -= bytesToWrite; // Decrement remainingBytes
-    }
-
-    digitalWrite(LED_BUILTIN, LOW); // Turn LED_BUILTIN off
-
-    Serial.print(F("The total number of bytes written to SD card is ")); // Print how many bytes have been written to SD card
-    Serial.println(bytesWritten);
-
-    myFile.close(); // Close the data file
-    
-    Serial.println(F("Logging stopped. Freezing..."));
-    while(1); // Do nothing more
-  }
-
-  // =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
-}
diff --git a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Data_Logging/DataLoggingExample5_Fast_RXM/DataLoggingExample5_Fast_RXM.ino b/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Data_Logging/DataLoggingExample5_Fast_RXM/DataLoggingExample5_Fast_RXM.ino
deleted file mode 100644
index 9a5881c..0000000
--- a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Data_Logging/DataLoggingExample5_Fast_RXM/DataLoggingExample5_Fast_RXM.ino
+++ /dev/null
@@ -1,272 +0,0 @@
-/*
-  Configuring the GNSS to automatically send RXM SFRBX and RAWX reports over I2C and log them to file on SD card
-  without using callbacks and ** as fast as your module can go! **
-  By: Paul Clark
-  SparkFun Electronics
-  Date: December 30th, 2020
-  License: MIT. See license file for more information but you can
-  basically do whatever you want with this code.
-
-  This example shows how to configure the u-blox GNSS to send RXM SFRBX and RAWX reports automatically
-  and log the data to SD card in UBX format without using callbacks and ** as fast as your module can go! **
-
-  ** Please note: this example will only work on u-blox ADR or High Precision GNSS or Time Sync products **
-
-  ** Please note: this example will only work on processors like the Artemis which have plenty of RAM available **
-
-  Data is logged in u-blox UBX format. Please see the u-blox protocol specification for more details.
-  You can replay and analyze the data using u-center:
-  https://www.u-blox.com/en/product/u-center
-  Or you can use (e.g.) RTKLIB to analyze the data and extract your precise location or produce
-  Post-Processed Kinematic data:
-  https://rtklibexplorer.wordpress.com/
-  http://rtkexplorer.com/downloads/rtklib-code/
-
-  This code is intended to be run on the MicroMod Data Logging Carrier Board using the Artemis Processor
-  but can be adapted by changing the chip select pin and SPI definitions:
-  https://www.sparkfun.com/products/16829
-  https://www.sparkfun.com/products/16401
-
-  Hardware Connections:
-  Please see: https://learn.sparkfun.com/tutorials/micromod-data-logging-carrier-board-hookup-guide
-  Insert the Artemis Processor into the MicroMod Data Logging Carrier Board and secure with the screw.
-  Connect your GNSS breakout to the Carrier Board using a Qwiic cable.
-  Connect an antenna to your GNSS board if required.
-  Insert a formatted micro-SD card into the socket on the Carrier Board.
-  Connect the Carrier Board to your computer using a USB-C cable.
-  Ensure you have the SparkFun Apollo3 boards installed: http://boardsmanager/All#SparkFun_Apollo3
-  This code has been tested using version 1.2.1 of the Apollo3 boards on Arduino IDE 1.8.13.
-  Select "SparkFun Artemis MicroMod" as the board type.
-  Press upload to upload the code onto the Artemis.
-  Open the Serial Monitor at 115200 baud to see the output.
-
-  To minimise I2C bus errors, it is a good idea to open the I2C pull-up split pad links on
-  both the MicroMod Data Logging Carrier Board and the u-blox module breakout.
-
-  Feel like supporting open source hardware?
-  Buy a board from SparkFun!
-  ZED-F9P RTK2: https://www.sparkfun.com/products/15136
-  NEO-M8P RTK: https://www.sparkfun.com/products/15005
-*/
-
-#include <SPI.h>
-#include <SD.h>
-#include <Wire.h> //Needed for I2C to GNSS
-
-#include <SparkFun_u-blox_GNSS_Arduino_Library.h> //Click here to get the library: http://librarymanager/All#SparkFun_u-blox_GNSS
-SFE_UBLOX_GNSS myGNSS;
-
-File myFile; //File that all GNSS data is written to
-
-#define sdChipSelect CS //Primary SPI Chip Select is CS for the MicroMod Artemis Processor. Adjust for your processor if necessary.
-
-#define sdWriteSize 512 // Write data to the SD card in blocks of 512 bytes
-#define fileBufferSize 32768 // Allocate 32KBytes of RAM for UBX message storage
-
-unsigned long lastPrint; // Record when the last Serial print took place
-unsigned long bytesWritten = 0; // Record how many bytes have been written to SD card
-
-void setup()
-{
-  Serial.begin(115200);
-  while (!Serial); //Wait for user to open terminal
-  Serial.println("SparkFun u-blox Example");
-
-  pinMode(LED_BUILTIN, OUTPUT); // Flash LED_BUILTIN each time we write to the SD card
-  digitalWrite(LED_BUILTIN, LOW);
-
-  Wire.begin(); // Start I2C communication
-
-#if defined(AM_PART_APOLLO3)
-  Wire.setPullups(0); // On the Artemis, we can disable the internal I2C pull-ups too to help reduce bus errors
-#endif
-
-  while (Serial.available()) // Make sure the Serial buffer is empty
-  {
-    Serial.read();
-  }
-
-  Serial.println(F("Press any key to start logging."));
-
-  while (!Serial.available()) // Wait for the user to press a key
-  {
-    ; // Do nothing
-  }
-
-  delay(100); // Wait, just in case multiple characters were sent
-  
-  while (Serial.available()) // Empty the Serial buffer
-  {
-    Serial.read();
-  }
-
-  Serial.println("Initializing SD card...");
-
-  // See if the card is present and can be initialized:
-  if (!SD.begin(sdChipSelect))
-  {
-    Serial.println("Card failed, or not present. Freezing...");
-    // don't do anything more:
-    while (1);
-  }
-  Serial.println("SD card initialized.");
-
-  // Create or open a file called "Fast_RXM.ubx" on the SD card.
-  // If the file already exists, the new data is appended to the end of the file.
-  myFile = SD.open("Fast_RXM.ubx", FILE_WRITE);
-  if(!myFile)
-  {
-    Serial.println(F("Failed to create UBX data file! Freezing..."));
-    while (1);
-  }
-
-  //myGNSS.enableDebugging(); // Uncomment this line to enable lots of helpful GNSS debug messages on Serial
-  //myGNSS.enableDebugging(Serial, true); // Or, uncomment this line to enable only the important GNSS debug messages on Serial
-
-  myGNSS.disableUBX7Fcheck(); // RAWX data can legitimately contain 0x7F, so we need to disable the "7F" check in checkUbloxI2C
-
-  // RAWX messages can be over 2KBytes in size, so we need to make sure we allocate enough RAM to hold all the data.
-  // SD cards can occasionally 'hiccup' and a write takes much longer than usual. The buffer needs to be big enough
-  // to hold the backlog of data if/when this happens.
-  // getMaxFileBufferAvail will tell us the maximum number of bytes which the file buffer has contained.
-  myGNSS.setFileBufferSize(fileBufferSize); // setFileBufferSize must be called _before_ .begin
-
-  if (myGNSS.begin() == false) //Connect to the u-blox module using Wire port
-  {
-    Serial.println(F("u-blox GNSS not detected at default I2C address. Please check wiring. Freezing..."));
-    while (1);
-  }
-
-  // Uncomment the next line if you want to reset your module back to the default settings with 1Hz navigation rate
-  // (This will also disable any "auto" messages that were enabled and saved by other examples and reduce the load on the I2C bus)
-  //myGNSS.factoryDefault(); delay(5000);
-
-  myGNSS.setI2COutput(COM_TYPE_UBX); //Set the I2C port to output UBX only (turn off NMEA noise)
-  myGNSS.saveConfigSelective(VAL_CFG_SUBSEC_IOPORT); //Save (only) the communications port settings to flash and BBR
-
-  // Modules like the ZED-F9P can produce RAW navigation data at rates of up to 25Hz but not while using all of the GNSS constellations.
-  // Please consult the data sheet for the Performance figures for your module.
-  // In this example we make sure GPS is enabled and then disable Galileo, GLONASS, BeiDou, SBAS and QZSS to achieve 25Hz.
-  myGNSS.enableGNSS(true, SFE_UBLOX_GNSS_ID_GPS); // Make sure GPS is enabled (we must leave at least one major GNSS enabled!)
-  myGNSS.enableGNSS(false, SFE_UBLOX_GNSS_ID_SBAS); // Disable SBAS
-  myGNSS.enableGNSS(false, SFE_UBLOX_GNSS_ID_GALILEO); // Disable Galileo
-  myGNSS.enableGNSS(false, SFE_UBLOX_GNSS_ID_BEIDOU); // Disable BeiDou
-  myGNSS.enableGNSS(false, SFE_UBLOX_GNSS_ID_IMES); // Disable IMES
-  myGNSS.enableGNSS(false, SFE_UBLOX_GNSS_ID_QZSS); // Disable QZSS
-  myGNSS.enableGNSS(false, SFE_UBLOX_GNSS_ID_GLONASS); // Disable GLONASS
-
-  delay(2000); // Give the module some extra time to get ready
-
-  //Produce 7 navigation solutions per second. That's a lot of RAWX data - especially when using both GPS bands L1 and L2.
-  //The SD library and card need to be able to cope with the data rate too. You may need a faster SD library to go above 7Hz.
-  myGNSS.setNavigationFrequency(7);
-
-  myGNSS.setAutoRXMSFRBX(true, false); // Enable automatic RXM SFRBX messages: without callback; without implicit update
-  
-  myGNSS.logRXMSFRBX(); // Enable RXM SFRBX data logging
-
-  myGNSS.setAutoRXMRAWX(true, false); // Enable automatic RXM RAWX messages: without callback; without implicit update
-  
-  myGNSS.logRXMRAWX(); // Enable RXM RAWX data logging
-
-  Serial.println(F("Press any key to stop logging."));
-
-  lastPrint = millis(); // Initialize lastPrint
-}
-
-void loop()
-{
-  // =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
-
-  myGNSS.checkUblox(); // Check for the arrival of new data and process it.
-
-  // =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
-
-  while (myGNSS.fileBufferAvailable() >= sdWriteSize) // Check to see if we have at least sdWriteSize waiting in the buffer
-  {
-    digitalWrite(LED_BUILTIN, HIGH); // Flash LED_BUILTIN each time we write to the SD card
-  
-    uint8_t myBuffer[sdWriteSize]; // Create our own buffer to hold the data while we write it to SD card
-
-    myGNSS.extractFileBufferData((uint8_t *)&myBuffer, sdWriteSize); // Extract exactly sdWriteSize bytes from the UBX file buffer and put them into myBuffer
-
-    myFile.write(myBuffer, sdWriteSize); // Write exactly sdWriteSize bytes from myBuffer to the ubxDataFile on the SD card
-
-    bytesWritten += sdWriteSize; // Update bytesWritten
-
-    // In case the SD writing is slow or there is a lot of data to write, keep checking for the arrival of new data
-    myGNSS.checkUblox(); // Check for the arrival of new data and process it.
-
-    digitalWrite(LED_BUILTIN, LOW); // Turn LED_BUILTIN off again
-  }
-
-  // =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
-
-  if (millis() > (lastPrint + 1000)) // Print bytesWritten once per second
-  {
-    Serial.print(F("The number of bytes written to SD card is: ")); // Print how many bytes have been written to SD card
-    Serial.println(bytesWritten);
-
-    uint16_t maxBufferBytes = myGNSS.getMaxFileBufferAvail(); // Get how full the file buffer has been (not how full it is now)
-    
-    //Serial.print(F("The maximum number of bytes which the file buffer has contained is: ")); // It is a fun thing to watch how full the buffer gets
-    //Serial.println(maxBufferBytes);
-
-    if (maxBufferBytes > ((fileBufferSize / 5) * 4)) // Warn the user if fileBufferSize was more than 80% full
-    {
-      Serial.println(F("Warning: the file buffer has been over 80% full. Some data may have been lost."));
-    }
-    
-    lastPrint = millis(); // Update lastPrint
-  }
-
-  // =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
-
-  if (Serial.available()) // Check if the user wants to stop logging
-  {
-    myGNSS.setAutoRXMSFRBX(false, false); // Disable the automatic RXM SFRBX messages
-    myGNSS.setAutoRXMRAWX(false, false); // Disable the automatic RXM RAWX messages
-
-    delay(1000); // Allow time for any remaining messages to arrive
-    myGNSS.checkUblox(); // Process any remaining data
-
-    uint16_t remainingBytes = myGNSS.fileBufferAvailable(); // Check if there are any bytes remaining in the file buffer
-    
-    while (remainingBytes > 0) // While there is still data in the file buffer
-    {
-      digitalWrite(LED_BUILTIN, HIGH); // Flash LED_BUILTIN while we write to the SD card
-      
-      uint8_t myBuffer[sdWriteSize]; // Create our own buffer to hold the data while we write it to SD card
-
-      uint16_t bytesToWrite = remainingBytes; // Write the remaining bytes to SD card sdWriteSize bytes at a time
-      if (bytesToWrite > sdWriteSize)
-      {
-        bytesToWrite = sdWriteSize;
-      }
-  
-      myGNSS.extractFileBufferData((uint8_t *)&myBuffer, bytesToWrite); // Extract bytesToWrite bytes from the UBX file buffer and put them into myBuffer
-
-      myFile.write(myBuffer, bytesToWrite); // Write bytesToWrite bytes from myBuffer to the ubxDataFile on the SD card
-
-      bytesWritten += bytesToWrite; // Update bytesWritten
-
-      remainingBytes -= bytesToWrite; // Decrement remainingBytes
-    }
-
-    digitalWrite(LED_BUILTIN, LOW); // Turn LED_BUILTIN off
-
-    Serial.print(F("The total number of bytes written to SD card is: ")); // Print how many bytes have been written to SD card
-    Serial.println(bytesWritten);
-
-    uint16_t maxBufferBytes = myGNSS.getMaxFileBufferAvail(); // Show how full the file buffer has been (not how full it is now)
-    Serial.print(F("The maximum number of bytes which the file buffer has contained is: "));
-    Serial.println(maxBufferBytes);
-
-    myFile.close(); // Close the data file
-    
-    Serial.println(F("Logging stopped. Freezing..."));
-    while(1); // Do nothing more
-  }
-
-  // =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
-}
diff --git a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Dead_Reckoning/Example1_calibrateSensor/Example1_calibrateSensor.ino b/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Dead_Reckoning/Example1_calibrateSensor/Example1_calibrateSensor.ino
deleted file mode 100644
index ed85e6a..0000000
--- a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Dead_Reckoning/Example1_calibrateSensor/Example1_calibrateSensor.ino
+++ /dev/null
@@ -1,75 +0,0 @@
-/*
-  By: Elias Santistevan
-  SparkFun Electronics
-  Date: May, 2020
-  License: MIT. See license file for more information but you can
-  basically do whatever you want with this code.
-
-  Feel like supporting open source hardware?
-  Buy a board from SparkFun!
-  NEO-M8U: https://www.sparkfun.com/products/16329
-  ZED-F9R: https://www.sparkfun.com/products/16344  
-
-  Hardware Connections:
-  Plug a Qwiic cable into the GNSS and a Redboard Qwiic
-  If you don't have a platform with a Qwiic connection use the 
-  SparkFun Qwiic Breadboard Jumper (https://www.sparkfun.com/products/14425)
-  Open the serial monitor at 115200 baud to see the output
-
-  To take advantage of the internal IMU of either the Dead Reckoning GNSS
-  boards (ZED-F9R, NEO-M8U), you must first calibrate it. This includes securing the GNSS module
-  to your vehicle so that it is stable within 2 degrees and that the frame of
-  reference of the board is consistent with the picture outlined in the
-  Receiver-Description-Prot-Spec Datasheet under Automotive/Untethered Dead
-  Reckoning. You may also check either the ZED-F9R or NEO-M8U Hookup Guide for
-  more information. After the board is secure, you'll need to put the module
-  through certain conditions for proper calibration: acceleration, turning,
-  stopping for a few minutes, getting to a speed over 30km/h all under a clear sky 
-  with good GNSS signal. This example simply looks at the
-  "fusionMode" status which indicates whether the SparkFun Dead Reckoning is
-  initializing - 0, calibrated - 1, or if an error has occurred - 2,3.  
-*/
-
-#include <Wire.h> //Needed for I2C to GNSS
-
-#include <SparkFun_u-blox_GNSS_Arduino_Library.h> //http://librarymanager/All#SparkFun_u-blox_GNSS
-SFE_UBLOX_GNSS myGNSS;
-
-void setup()
-{
-  Serial.begin(115200);
-  while (!Serial); //Wait for user to open terminal
-  Serial.println(F("SparkFun u-blox Example"));
-
-  Wire.begin();
-
-  if (myGNSS.begin() == false) //Connect to the u-blox module using Wire port
-  {
-    Serial.println(F("u-blox GNSS not detected at default I2C address. Please check wiring. Freezing."));
-    while (1);
-  }
-
-  myGNSS.setI2COutput(COM_TYPE_UBX); //Set the I2C port to output UBX only (turn off NMEA noise)
-
-  //myGNSS.resetIMUalignment(); // Uncomment this line to reset the IMU alignment
-}
-
-void loop()
-{
-  // ESF data is produced at the navigation rate, so by default we'll get fresh data once per second
-  if (myGNSS.getEsfInfo()) // Poll new ESF STATUS data
-  {
-    Serial.print(F("Fusion Mode: "));  
-    Serial.print(myGNSS.packetUBXESFSTATUS->data.fusionMode);  
-    if (myGNSS.packetUBXESFSTATUS->data.fusionMode == 0)
-      Serial.println(F("  Sensor is initializing..."));  
-    else if (myGNSS.packetUBXESFSTATUS->data.fusionMode == 1)
-      Serial.println(F("  Sensor is calibrated!"));  
-    else if (myGNSS.packetUBXESFSTATUS->data.fusionMode == 2)
-      Serial.println(F("  Sensor fusion is suspended!"));  
-    else if (myGNSS.packetUBXESFSTATUS->data.fusionMode == 3)
-      Serial.println(F("  Sensor fusion is disabled!"));  
-  }
-
-  delay(250);
-}
diff --git a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Dead_Reckoning/Example2_getIMUData/Example2_getIMUData.ino b/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Dead_Reckoning/Example2_getIMUData/Example2_getIMUData.ino
deleted file mode 100644
index e9889d9..0000000
--- a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Dead_Reckoning/Example2_getIMUData/Example2_getIMUData.ino
+++ /dev/null
@@ -1,91 +0,0 @@
-/*
-  By: Elias Santistevan
-  SparkFun Electronics
-  Date: May, 2020
-  License: MIT. See license file for more information but you can
-  basically do whatever you want with this code.
-
-  Feel like supporting open source hardware?
-  Buy a board from SparkFun!
-  NEO-M8U: https://www.sparkfun.com/products/16329
-  ZED-F9R: https://www.sparkfun.com/products/16344  
-
-  Hardware Connections:
-  Plug a Qwiic cable into the GNSS and a Redboard Qwiic
-  If you don't have a platform with a Qwiic connection use the 
-	SparkFun Qwiic Breadboard Jumper (https://www.sparkfun.com/products/14425)
-  Open the serial monitor at 115200 baud to see the output
-
-	After calibrating the module, also known as "Fusion Mode", you can get
-	data directly from the IMU. This data is integrated directly into the GNSS
-	output, but is provided by the module as well. 
-
-*/
-
-#include <Wire.h> //Needed for I2C to GNSS
-
-#include <SparkFun_u-blox_GNSS_Arduino_Library.h> //http://librarymanager/All#SparkFun_u-blox_GNSS
-SFE_UBLOX_GNSS myGNSS;
-
-void setup()
-{
-  Serial.begin(115200);
-  while (!Serial); //Wait for user to open terminal
-  Serial.println(F("SparkFun u-blox Example"));
-
-  Wire.begin();
-
-  if (myGNSS.begin() == false) //Connect to the u-blox module using Wire port
-  {
-    Serial.println(F("u-blox GNSS not detected at default I2C address. Please check wiring. Freezing."));
-    while (1);
-  }
-
-  myGNSS.setI2COutput(COM_TYPE_UBX); //Set the I2C port to output UBX only (turn off NMEA noise)
-
-  if (myGNSS.getEsfInfo()){
-
-    Serial.print(F("Fusion Mode: "));
-    Serial.println(myGNSS.packetUBXESFSTATUS->data.fusionMode);  
-
-    if (myGNSS.packetUBXESFSTATUS->data.fusionMode == 1){
-      Serial.println(F("Fusion Mode is Initialized!"));  
-		}
-		else {
-      Serial.println(F("Fusion Mode is either disabled or not initialized!"));  
-			Serial.println(F("Please see the previous example for more information."));
-		}
-  }
-}
-
-void loop()
-{
-  // ESF data is produced at the navigation rate, so by default we'll get fresh data once per second
-  if (myGNSS.getEsfIns()) // Poll new ESF INS data
-  {
-    Serial.print(F("X Ang Rate: "));
-    Serial.print(myGNSS.packetUBXESFINS->data.xAngRate);  
-    Serial.print(F(" Y Ang Rate: "));
-    Serial.print(myGNSS.packetUBXESFINS->data.yAngRate);  
-    Serial.print(F(" Z Ang Rate: "));
-    Serial.print(myGNSS.packetUBXESFINS->data.zAngRate);  
-    Serial.print(F(" X Accel: "));
-    Serial.print(myGNSS.packetUBXESFINS->data.xAccel);  
-    Serial.print(F(" Y Accel: "));
-    Serial.print(myGNSS.packetUBXESFINS->data.yAccel);  
-    Serial.print(F(" Z Accel: "));
-    Serial.print(myGNSS.packetUBXESFINS->data.zAccel);
-      
-		// These values also have "validity checks" that can be provided by the
-		// ublox library by reading bitfield0
-    Serial.print(F(" Validity: "));
-    Serial.print(myGNSS.packetUBXESFINS->data.bitfield0.bits.xAngRateValid);
-    Serial.print(myGNSS.packetUBXESFINS->data.bitfield0.bits.yAngRateValid);
-    Serial.print(myGNSS.packetUBXESFINS->data.bitfield0.bits.zAngRateValid);
-    Serial.print(myGNSS.packetUBXESFINS->data.bitfield0.bits.xAccelValid);
-    Serial.print(myGNSS.packetUBXESFINS->data.bitfield0.bits.yAccelValid);
-    Serial.println(myGNSS.packetUBXESFINS->data.bitfield0.bits.zAccelValid);
-  }
-
-  delay(250);
-}
diff --git a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Dead_Reckoning/Example3_getSensorStatus/Example3_getSensorStatus.ino b/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Dead_Reckoning/Example3_getSensorStatus/Example3_getSensorStatus.ino
deleted file mode 100644
index db48d20..0000000
--- a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Dead_Reckoning/Example3_getSensorStatus/Example3_getSensorStatus.ino
+++ /dev/null
@@ -1,125 +0,0 @@
-/*
-  By: Elias Santistevan
-  SparkFun Electronics
-  Date: May, 2020
-  License: MIT. See license file for more information but you can
-  basically do whatever you want with this code.
-
-  Feel like supporting open source hardware?
-  Buy a board from SparkFun!
-  NEO-M8U: https://www.sparkfun.com/products/16329
-  ZED-F9R: https://www.sparkfun.com/products/16344  
-
-  Hardware Connections:
-  Plug a Qwiic cable into the GNSS and a Redboard Qwiic
-  If you don't have a platform with a Qwiic connection use the 
-	SparkFun Qwiic Breadboard Jumper (https://www.sparkfun.com/products/14425)
-  Open the serial monitor at 115200 baud to see the output
-
-	After calibrating the module, also known as "Fusion Mode", you can get
-	data directly from the IMU. This example code walks you through trouble
-  shooting or identifying the different states of any individual  
-  "external" (which include internal) sensors you've hooked up (vehicle speed
-  sensor) or the internal IMU used by the modules. You can see if the sensor is
-  being used, if it's calibrated, ready, what data type it returns, the state
-  of the measurement etc.
-
-*/
-
-#include <Wire.h> //Needed for I2C to GNSS
-
-#include <SparkFun_u-blox_GNSS_Arduino_Library.h> //http://librarymanager/All#SparkFun_u-blox_GNSS
-SFE_UBLOX_GNSS myGNSS;
-
-void setup()
-{
-  Serial.begin(115200);
-  while (!Serial); //Wait for user to open terminal
-  Serial.println(F("SparkFun u-blox Example"));
-
-  Wire.begin();
-
-  if (myGNSS.begin() == false) //Connect to the u-blox module using Wire port
-  {
-    Serial.println(F("u-blox GNSS not detected at default I2C address. Please check wiring. Freezing."));
-    while (1);
-  }
-
-  myGNSS.setI2COutput(COM_TYPE_UBX); //Set the I2C port to output UBX only (turn off NMEA noise)
-
-	// GetEsfInfo also gets the number of sensors used by the ublox module, this
-	// includes (in the case of the ZED-F9R) wheel tick input from the vehicle
-	// speed sensor attached to the module. 
-  if (myGNSS.getEsfInfo()){
-
-    Serial.print(F("Fusion Mode: "));  
-    Serial.println(myGNSS.packetUBXESFSTATUS->data.fusionMode);  
-
-    if (myGNSS.packetUBXESFSTATUS->data.fusionMode == 1){
-      Serial.println(F("Fusion Mode is Initialized!"));  
-		}
-		else {
-      Serial.println(F("Fusion Mode is either disabled or not initialized!"));  
-			Serial.println(F("Please see the previous example for more information."));
-		}
-  }
-}
-
-void loop()
-{
-  // ESF data is produced at the navigation rate, so by default we'll get fresh data once per second
-  if (myGNSS.getEsfInfo()) // Poll new ESF STATUS data
-  {
-    UBX_ESF_STATUS_sensorStatus_t sensorStatus; // Create storage for the individual sensor status
-
-    //See ublox receiver description or our hookup guide for information on the return values
-
-    Serial.println(F("                              "));
-    Serial.println(F("              C               "));
-    Serial.println(F("              a               "));
-    Serial.println(F("              l               "));
-    Serial.println(F("              i               "));
-    Serial.println(F("              b           M   "));
-    Serial.println(F("              r           i  N"));
-    Serial.println(F("              a        B  s  o"));
-    Serial.println(F("    S         t  T  B  a  s  i"));
-    Serial.println(F("S   e   B     i  i  a  d  e  s"));
-    Serial.println(F("e   n   e     o  m  d     d  y"));
-    Serial.println(F("n   s   i  I  n  e     T      "));
-    Serial.println(F("s   o   n  s        M  i  M  M"));
-    Serial.println(F("o   r   g     S  S  e  m  e  e"));
-    Serial.println(F("r          R  t  t  a  e  a  a"));
-    Serial.println(F("    T   U  e  a  a  s     s  s"));
-    Serial.println(F("N   y   s  a  t  t  u  T  u  u"));
-    Serial.println(F("o   p   e  d  u  u  r  a  r  r"));
-    Serial.println(F(".   e   d  y  s  s  e  g  e  e"));
-    Serial.println(F("                              "));
-
-  	for(uint8_t i = 0; i < myGNSS.packetUBXESFSTATUS->data.numSens; i++)
-  	{
-      myGNSS.getSensorFusionStatus(&sensorStatus, i); // Extract the individual sensor data for this sensor
-      
-      Serial.print(i); Serial.print(F("   ")); // Print the sensor number
-
-      // Print the sensor type
-  		Serial.print(sensorStatus.sensStatus1.bits.type);
-      if (sensorStatus.sensStatus1.bits.type < 10) Serial.print(F(" "));
-  		Serial.print(F("  "));
-
-      Serial.print(sensorStatus.sensStatus1.bits.used); Serial.print(F("  ")); // Print the used flag
-      Serial.print(sensorStatus.sensStatus1.bits.ready); Serial.print(F("  ")); // Print the ready flag
-
-      Serial.print(sensorStatus.sensStatus2.bits.calibStatus); Serial.print(F("  ")); // Print the calibration status
-      Serial.print(sensorStatus.sensStatus2.bits.timeStatus); Serial.print(F("  ")); // Print the time status
-
-      Serial.print(sensorStatus.faults.bits.badMeas); Serial.print(F("  ")); // Print the bad measurement flag
-      Serial.print(sensorStatus.faults.bits.badTTag); Serial.print(F("  ")); // Print the time tag flag
-      Serial.print(sensorStatus.faults.bits.missingMeas); Serial.print(F("  ")); // Print the missing measurement flag
-      Serial.print(sensorStatus.faults.bits.noisyMeas); // Print the noisy measure flag
-
-      Serial.println(); 
-  	}
-  }
-
-  delay(250);
-}
diff --git a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Dead_Reckoning/Example4_vehicleDynamics/Example4_vehicleDynamics.ino b/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Dead_Reckoning/Example4_vehicleDynamics/Example4_vehicleDynamics.ino
deleted file mode 100644
index 451fec6..0000000
--- a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Dead_Reckoning/Example4_vehicleDynamics/Example4_vehicleDynamics.ino
+++ /dev/null
@@ -1,83 +0,0 @@
-/*
-  By: Elias Santistevan
-  SparkFun Electronics
-  Date: May, 2020
-  License: MIT. See license file for more information but you can
-  basically do whatever you want with this code.
-
-  Feel like supporting open source hardware?
-  Buy a board from SparkFun!
-  NEO-M8U: https://www.sparkfun.com/products/16329
-  ZED-F9R: https://www.sparkfun.com/products/16344  
-
-  Hardware Connections:
-  Plug a Qwiic cable into the GNSS and a Redboard Qwiic
-  If you don't have a platform with a Qwiic connection use the 
-	SparkFun Qwiic Breadboard Jumper (https://www.sparkfun.com/products/14425)
-  Open the serial monitor at 115200 baud to see the output
-
-	After calibrating the module and securing it to your vehicle such that it's
-  stable within 2 degrees, and the board is oriented correctly with regards to
-  the vehicle's frame, you can now read the vehicle's "attitude". The attitude
-  includes the vehicle's heading, pitch, and roll. You can also check the
-  accuracy of those readings. 
-
-*/
-
-#include <Wire.h> //Needed for I2C to GNSS
-
-#include <SparkFun_u-blox_GNSS_Arduino_Library.h> //http://librarymanager/All#SparkFun_u-blox_GNSS
-SFE_UBLOX_GNSS myGNSS;
-
-void setup()
-{
-  Serial.begin(115200);
-  while (!Serial); //Wait for user to open terminal
-  Serial.println(F("SparkFun u-blox Example"));
-
-  Wire.begin();
-
-  if (myGNSS.begin() == false) //Connect to the u-blox module using Wire port
-  {
-    Serial.println(F("u-blox GNSS not detected at default I2C address. Please check wiring. Freezing."));
-    while (1);
-  }
-
-  myGNSS.setI2COutput(COM_TYPE_UBX); //Set the I2C port to output UBX only (turn off NMEA noise)
-
-  if (myGNSS.getEsfInfo()){
-
-    Serial.print(F("Fusion Mode: "));  
-    Serial.println(myGNSS.packetUBXESFSTATUS->data.fusionMode);  
-
-    if (myGNSS.packetUBXESFSTATUS->data.fusionMode == 1){
-      Serial.println(F("Fusion Mode is Initialized!"));  
-		}
-		else {
-      Serial.println(F("Fusion Mode is either disabled or not initialized!"));  
-			Serial.println(F("Please see the previous example for more information."));
-		}
-  }
-}
-
-void loop()
-{
-  // ESF data is produced at the navigation rate, so by default we'll get fresh data once per second
-	if (myGNSS.getEsfAlignment()) // Poll new ESF ALG data
-  {
-  	Serial.print(F("Status: ")); 
-  	Serial.print(myGNSS.packetUBXESFALG->data.flags.bits.status);
-    Serial.print(F(" Roll: ")); 
-    Serial.print(myGNSS.getESFroll(), 2); // Use the helper function to get the roll in degrees
-  	Serial.print(F(" Pitch: ")); 
-  	Serial.print(myGNSS.getESFpitch(), 2); // Use the helper function to get the pitch in degrees
-  	Serial.print(F(" Heading: ")); 
-  	Serial.print(myGNSS.getESFyaw(), 2); // Use the helper function to get the yaw in degrees
-  	Serial.print(F(" Errors: ")); 
-  	Serial.print(myGNSS.packetUBXESFALG->data.error.bits.tiltAlgError);
-  	Serial.print(myGNSS.packetUBXESFALG->data.error.bits.yawAlgError);
-  	Serial.println(myGNSS.packetUBXESFALG->data.error.bits.angleError);
-  }
-
-  delay(250);
-}
diff --git a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Dead_Reckoning/Example5_getHNRData/Example5_getHNRData.ino b/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Dead_Reckoning/Example5_getHNRData/Example5_getHNRData.ino
deleted file mode 100644
index a1e4930..0000000
--- a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Dead_Reckoning/Example5_getHNRData/Example5_getHNRData.ino
+++ /dev/null
@@ -1,94 +0,0 @@
-/*
-  By: Paul Clark
-  SparkFun Electronics
-  Date: December, 2020
-  License: MIT. See license file for more information but you can
-  basically do whatever you want with this code.
-
-  This example configures the High Navigation Rate on the NEO-M8U and then
-  polls and displays the attitude solution, vehicle dynamics information
-  and high rate position, velocity and time.
-  
-  This example polls the high rate data.
-  (The next example uses "autoHNR" to receive the HNR data automatically.)
-  
-  Please make sure your NEO-M8U is running UDR firmware >= 1.31. Please update using u-center if necessary:
-  https://www.u-blox.com/en/product/neo-m8u-module#tab-documentation-resources
-
-  Feel like supporting open source hardware?
-  Buy a board from SparkFun!
-  NEO-M8U: https://www.sparkfun.com/products/16329
-
-  Hardware Connections:
-  Plug a Qwiic cable into the GPS and a Redboard Qwiic
-  If you don't have a platform with a Qwiic connection use the 
-	SparkFun Qwiic Breadboard Jumper (https://www.sparkfun.com/products/14425)
-  Open the serial monitor at 115200 baud to see the output
-
-*/
-
-#include <Wire.h> //Needed for I2C to GPS
-
-#include <SparkFun_u-blox_GNSS_Arduino_Library.h> //http://librarymanager/All#SparkFun_u-blox_GNSS
-SFE_UBLOX_GNSS myGNSS;
-
-void setup()
-{
-  Serial.begin(115200);
-  while (!Serial); //Wait for user to open terminal
-  Serial.println(F("SparkFun u-blox Example"));
-
-  Wire.begin();
-
-  //myGNSS.enableDebugging(); // Uncomment this line to enable debug messages on Serial
-
-  if (myGNSS.begin() == false) //Connect to the u-blox module using Wire port
-  {
-    Serial.println(F("Warning! u-blox GPS did not begin correctly."));
-    Serial.println(F("(This may be because the I2C port is busy with HNR messages.)"));
-  }
-
-  myGNSS.setI2COutput(COM_TYPE_UBX); //Set the I2C port to output UBX only (turn off NMEA noise)
-  myGNSS.saveConfigSelective(VAL_CFG_SUBSEC_IOPORT); //Save (only) the communications port settings to flash and BBR
-
-  if (myGNSS.setHNRNavigationRate(10) == true) //Set the High Navigation Rate to 10Hz
-    Serial.println(F("setHNRNavigationRate was successful"));
-  else
-    Serial.println(F("setHNRNavigationRate was NOT successful"));
-
-  myGNSS.setAutoHNRATT(false); //Make sure auto HNR attitude messages are disabled
-  myGNSS.setAutoHNRINS(false); //Make sure auto HNR vehicle dynamics messages are disabled
-  myGNSS.setAutoHNRPVT(false); //Make sure auto HNR PVT messages are disabled
-}
-
-void loop()
-{
-  // Poll and print selected HNR data
-  if (myGNSS.getHNRAtt(125) == true) // Request HNR Att data using a 125ms timeout
-  {
-    Serial.print(F("Roll: "));
-    Serial.print(myGNSS.getHNRroll(), 2); // Use the helper function to get the roll in degrees
-    Serial.print(F(" Pitch: "));
-    Serial.print(myGNSS.getHNRpitch(), 2); // Use the helper function to get the pitch in degrees
-    Serial.print(F(" Heading: "));
-    Serial.println(myGNSS.getHNRheading(), 2); // Use the helper function to get the heading in degrees
-  }
-  if (myGNSS.getHNRDyn(125) == true) // Request HNR Dyn data using a 125ms timeout
-  {
-    Serial.print(F("xAccel: "));
-    Serial.print(myGNSS.packetUBXHNRINS->data.xAccel);
-    Serial.print(F(" yAccel: "));
-    Serial.print(myGNSS.packetUBXHNRINS->data.yAccel);
-    Serial.print(F(" zAccel: "));
-    Serial.println(myGNSS.packetUBXHNRINS->data.zAccel);
-  }
-  if (myGNSS.getHNRPVT(125) == true) // Request HNR PVT data using a 125ms timeout
-  {
-    Serial.print(F("ns: "));
-    Serial.print(myGNSS.packetUBXHNRPVT->data.nano);
-    Serial.print(F(" Lat: "));
-    Serial.print(myGNSS.packetUBXHNRPVT->data.lat);
-    Serial.print(F(" Lon: "));
-    Serial.println(myGNSS.packetUBXHNRPVT->data.lon);
-  }
-}
diff --git a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Dead_Reckoning/Example6_getAutoHNRData/Example6_getAutoHNRData.ino b/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Dead_Reckoning/Example6_getAutoHNRData/Example6_getAutoHNRData.ino
deleted file mode 100644
index d48787e..0000000
--- a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Dead_Reckoning/Example6_getAutoHNRData/Example6_getAutoHNRData.ino
+++ /dev/null
@@ -1,107 +0,0 @@
-/*
-  By: Paul Clark
-  SparkFun Electronics
-  Date: December, 2020
-  License: MIT. See license file for more information but you can
-  basically do whatever you want with this code.
-
-  This example configures the High Navigation Rate on the NEO-M8U and then
-  reads and displays the attitude solution, vehicle dynamics information
-  and high rate position, velocity and time.
-  
-  This example uses "autoHNR" to receive the HNR data automatically.
-
-  Please make sure your NEO-M8U is running UDR firmware >= 1.31. Please update using u-center if necessary:
-  https://www.u-blox.com/en/product/neo-m8u-module#tab-documentation-resources
-
-  Feel like supporting open source hardware?
-  Buy a board from SparkFun!
-  NEO-M8U: https://www.sparkfun.com/products/16329
-
-  Hardware Connections:
-  Plug a Qwiic cable into the GPS and a Redboard Qwiic
-  If you don't have a platform with a Qwiic connection use the 
-	SparkFun Qwiic Breadboard Jumper (https://www.sparkfun.com/products/14425)
-  Open the serial monitor at 115200 baud to see the output
-
-*/
-
-#include <Wire.h> //Needed for I2C to GPS
-
-#include <SparkFun_u-blox_GNSS_Arduino_Library.h> //http://librarymanager/All#SparkFun_u-blox_GNSS
-SFE_UBLOX_GNSS myGNSS;
-
-boolean usingAutoHNRAtt = false;
-boolean usingAutoHNRDyn = false;
-boolean usingAutoHNRPVT = false;
-
-void setup()
-{
-  Serial.begin(115200);
-  while (!Serial); //Wait for user to open terminal
-  Serial.println(F("SparkFun u-blox Example"));
-
-  Wire.begin();
-
-  //myGNSS.enableDebugging(); // Uncomment this line to enable debug messages on Serial
-
-  if (myGNSS.begin() == false) //Connect to the u-blox module using Wire port
-  {
-    Serial.println(F("Warning! u-blox GPS did not begin correctly."));
-    Serial.println(F("(This may be because the I2C port is busy with HNR messages.)"));
-  }
-
-  myGNSS.setI2COutput(COM_TYPE_UBX); //Set the I2C port to output UBX only (turn off NMEA noise)
-  myGNSS.saveConfigSelective(VAL_CFG_SUBSEC_IOPORT); //Save (only) the communications port settings to flash and BBR
-
-  if (myGNSS.setHNRNavigationRate(10) == true) //Set the High Navigation Rate to 10Hz
-    Serial.println(F("setHNRNavigationRate was successful"));
-  else
-    Serial.println(F("setHNRNavigationRate was NOT successful"));
-    
-  usingAutoHNRAtt = myGNSS.setAutoHNRATT(true); //Attempt to enable auto HNR attitude messages
-  if (usingAutoHNRAtt)
-    Serial.println(F("AutoHNRATT successful"));
-  
-  usingAutoHNRDyn = myGNSS.setAutoHNRINS(true); //Attempt to enable auto HNR vehicle dynamics messages  
-  if (usingAutoHNRDyn)
-    Serial.println(F("AutoHNRINS successful"));
-  
-  usingAutoHNRPVT = myGNSS.setAutoHNRPVT(true); //Attempt to enable auto HNR PVT messages
-  if (usingAutoHNRPVT)
-    Serial.println(F("AutoHNRPVT successful"));
-}
-
-void loop()
-{
-  if (usingAutoHNRAtt && (myGNSS.getHNRAtt() == true)) // If setAutoHNRAtt was successful and new data is available
-  {
-    Serial.print(F("Roll: ")); // Print selected data
-    Serial.print(myGNSS.getHNRroll(), 2); // Use the helper function to get the roll in degrees
-    Serial.print(F(" Pitch: "));
-    Serial.print(myGNSS.getHNRpitch(), 2); // Use the helper function to get the pitch in degrees
-    Serial.print(F(" Heading: "));
-    Serial.println(myGNSS.getHNRheading(), 2); // Use the helper function to get the heading in degrees
-    myGNSS.flushHNRATT(); // Mark data as stale
-  }
-  if (usingAutoHNRDyn && (myGNSS.getHNRDyn() == true)) // If setAutoHNRDyn was successful and new data is available
-  {
-    Serial.print(F("xAccel: ")); // Print selected data
-    Serial.print(myGNSS.packetUBXHNRINS->data.xAccel);
-    Serial.print(F(" yAccel: "));
-    Serial.print(myGNSS.packetUBXHNRINS->data.yAccel);
-    Serial.print(F(" zAccel: "));
-    Serial.println(myGNSS.packetUBXHNRINS->data.zAccel);
-    myGNSS.flushHNRINS(); // Mark data as stale
-  }
-  if (usingAutoHNRPVT && (myGNSS.getHNRPVT() == true)) // If setAutoHNRPVT was successful and new data is available
-  {
-    Serial.print(F("ns: ")); // Print selected data
-    Serial.print(myGNSS.packetUBXHNRPVT->data.nano);
-    Serial.print(F(" Lat: "));
-    Serial.print(myGNSS.packetUBXHNRPVT->data.lat);
-    Serial.print(F(" Lon: "));
-    Serial.println(myGNSS.packetUBXHNRPVT->data.lon);
-    myGNSS.flushHNRPVT(); // Mark data as stale
-  }
-}
diff --git a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Example10_AltitudeMSL/Example10_AltitudeMSL.ino b/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Example10_AltitudeMSL/Example10_AltitudeMSL.ino
deleted file mode 100644
index a6f82ee..0000000
--- a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Example10_AltitudeMSL/Example10_AltitudeMSL.ino
+++ /dev/null
@@ -1,82 +0,0 @@
-/*
-  Reading two altitudes - Mean Sea Level and Ellipsode
-  By: Nathan Seidle
-  SparkFun Electronics
-  Date: January 3rd, 2019
-  License: MIT. See license file for more information but you can
-  basically do whatever you want with this code.
-
-  This example shows how to query a u-blox module for its lat/long/altitude. 
-
-  getAltitude() reports mm above ellipsode model of the globe. There are some
-  instances where altitude above Mean Sea Level is better. This example shows how 
-  to use getAltitudeMSL(). The difference varies but is ~20m.
-  Ellipsoid model: https://www.esri.com/news/arcuser/0703/geoid1of3.html
-  Difference between Ellipsoid Model and Mean Sea Level: https://eos-gnss.com/elevation-for-beginners/
-  
-  Leave NMEA parsing behind. Now you can simply ask the module for the datums you want!
-
-  Feel like supporting open source hardware?
-  Buy a board from SparkFun!
-  ZED-F9P RTK2: https://www.sparkfun.com/products/15136
-  NEO-M8P RTK: https://www.sparkfun.com/products/15005
-  SAM-M8Q: https://www.sparkfun.com/products/15106
-
-  Hardware Connections:
-  Plug a Qwiic cable into the GNSS and a BlackBoard
-  If you don't have a platform with a Qwiic connection use the SparkFun Qwiic Breadboard Jumper (https://www.sparkfun.com/products/14425)
-  Open the serial monitor at 115200 baud to see the output
-*/
-
-#include <Wire.h> //Needed for I2C to GNSS
-
-#include <SparkFun_u-blox_GNSS_Arduino_Library.h> //http://librarymanager/All#SparkFun_u-blox_GNSS
-SFE_UBLOX_GNSS myGNSS;
-
-long lastTime = 0; //Tracks the passing of 2000ms (2 seconds)
-
-void setup()
-{
-  Serial.begin(115200);
-  while (!Serial); //Wait for user to open terminal
-  Serial.println("SparkFun u-blox Example");
-
-  Wire.begin();
-
-  if (myGNSS.begin() == false) //Connect to the u-blox module using Wire port
-  {
-    Serial.println(F("u-blox GNSS not detected at default I2C address. Please check wiring. Freezing."));
-    while (1);
-  }
-}
-
-void loop()
-{
-  //Query module only every second. Doing it more often will just cause I2C traffic.
-  //The module only responds when a new position is available
-  if (millis() - lastTime > 1000)
-  {
-    lastTime = millis(); //Update the timer
-    
-    long latitude = myGNSS.getLatitude();
-    Serial.print(F("Lat: "));
-    Serial.print(latitude);
-
-    long longitude = myGNSS.getLongitude();
-    Serial.print(F(" Long: "));
-    Serial.print(longitude);
-    Serial.print(F(" (degrees * 10^-7)"));
-
-    long altitude = myGNSS.getAltitude();
-    Serial.print(F(" Alt: "));
-    Serial.print(altitude);
-    Serial.print(F(" (mm)"));
-
-    long altitudeMSL = myGNSS.getAltitudeMSL();
-    Serial.print(F(" AltMSL: "));
-    Serial.print(altitudeMSL);
-    Serial.print(F(" (mm)"));
-
-    Serial.println();
-  }
-}
diff --git a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Example11_ResetModule/Example1_FactoryDefaultviaI2C/Example1_FactoryDefaultviaI2C.ino b/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Example11_ResetModule/Example1_FactoryDefaultviaI2C/Example1_FactoryDefaultviaI2C.ino
deleted file mode 100644
index 856bcd3..0000000
--- a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Example11_ResetModule/Example1_FactoryDefaultviaI2C/Example1_FactoryDefaultviaI2C.ino
+++ /dev/null
@@ -1,60 +0,0 @@
-/*
-  Send command to reset module over I2C
-  By: Nathan Seidle
-  Date: January 29rd, 2019
-  License: MIT. See license file for more information but you can
-  basically do whatever you want with this code.
-
-  This example shows how to reset the U-Blox module to factory defaults over I2C.
-
-  Feel like supporting open source hardware?
-  Buy a board from SparkFun!
-  ZED-F9P RTK2: https://www.sparkfun.com/products/15136
-  NEO-M8P RTK: https://www.sparkfun.com/products/15005
-  SAM-M8Q: https://www.sparkfun.com/products/15106
-
-  Hardware Connections:
-  Plug a Qwiic cable into the GNSS and a BlackBoard
-  If you don't have a platform with a Qwiic connection use the SparkFun Qwiic Breadboard Jumper (https://www.sparkfun.com/products/14425)
-  Open the serial monitor at 115200 baud to see the output
-*/
-
-#include <SparkFun_u-blox_GNSS_Arduino_Library.h> //http://librarymanager/All#SparkFun_u-blox_GNSS
-SFE_UBLOX_GNSS myGNSS;
-
-void setup()
-{
-  Serial.begin(115200);
-  while (!Serial); //Wait for user to open terminal
-  Serial.println("SparkFun u-blox Example");
-
-  Wire.begin();
-
-  if (myGNSS.begin() == false) //Connect to the u-blox module using Wire port
-  {
-    Serial.println(F("u-blox GNSS not detected at default I2C address. Please check wiring. Freezing."));
-    while (1);
-  }
-
-  while (Serial.available()) Serial.read(); //Trash any incoming chars
-  Serial.println("Press a key to reset module to factory defaults");
-  while (Serial.available() == false) ; //Wait for user to send character
-
-  myGNSS.factoryReset(); //Reset everything: baud rate, I2C address, update rate, everything.
-
-  delay(5000); // Wait while the module restarts
-
-  while (myGNSS.begin() == false) //Attempt to re-connect
-  {
-    delay(1000);
-    Serial.println(F("Attempting to re-connect to u-blox GNSS..."));
-  }
-
-  Serial.println("Unit has now been factory reset. Freezing...");
-  while(1); // Do nothing more
-}
-
-void loop()
-{
-
-}
diff --git a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Example11_ResetModule/Example2_FactoryDefaultsviaSerial/Example2_FactoryDefaultsviaSerial.ino b/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Example11_ResetModule/Example2_FactoryDefaultsviaSerial/Example2_FactoryDefaultsviaSerial.ino
deleted file mode 100644
index 4493f7a..0000000
--- a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Example11_ResetModule/Example2_FactoryDefaultsviaSerial/Example2_FactoryDefaultsviaSerial.ino
+++ /dev/null
@@ -1,110 +0,0 @@
-/*
-  Test baud rate changes on serial, factory reset, and hard reset.
-  By: Thorsten von Eicken
-  Date: January 29rd, 2019
-  License: MIT. See license file for more information but you can
-  basically do whatever you want with this code.
-
-  This example shows how to reset the U-Blox module to factory defaults over serial.
-
-  Feel like supporting open source hardware?
-  Buy a board from SparkFun!
-  ZED-F9P RTK2: https://www.sparkfun.com/products/15136
-  NEO-M8P RTK: https://www.sparkfun.com/products/15005
-  SAM-M8Q: https://www.sparkfun.com/products/15106
-
-  Hardware Connections:
-  Connect the U-Blox serial port to Serial1
-  If you're using a Uno or don't have a 2nd serial port (Serial1), use SoftwareSerial instead (see below)
-  Open the serial monitor at 115200 baud to see the output
-*/
-
-#include <SparkFun_u-blox_GNSS_Arduino_Library.h> //http://librarymanager/All#SparkFun_u-blox_GNSS
-SFE_UBLOX_GNSS myGNSS;
-
-#include <SoftwareSerial.h>
-
-//#define mySerial Serial1 // Uncomment this line to connect via Serial1
-// - or -
-SoftwareSerial mySerial(10, 11); // Uncomment this line to connect via SoftwareSerial(RX, TX). Connect pin 10 to GNSS TX pin.
-
-#define defaultRate 9600 // Uncomment this line if you are using an M8 - which defaults to 9600 Baud on UART1
-// - or -
-//#define defaultRate 38400 // Uncomment this line if you are using an F9 - which defaults to 38400 Baud on UART1
-
-int state = 0; // steps through auto-baud, reset, etc states
-
-void setup()
-{
-  Serial.begin(115200);
-  while (!Serial); //Wait for user to open terminal
-  Serial.println("SparkFun u-blox Example");
-
-  //myGNSS.enableDebugging(); // Uncomment this line to enable helpful debug messages on Serial
-}
-
-void loop()
-{
-    Serial.print("===== STATE ");
-    Serial.println(state);
-    switch (state) {
-    case 0: // auto-baud connection, then switch to 38400 and save config
-        do {
-            Serial.println("GNSS: trying 38400 baud");
-            mySerial.begin(38400);
-            if (myGNSS.begin(mySerial)) break;
-
-            delay(100);
-            Serial.println("GNSS: trying 9600 baud");
-            mySerial.begin(9600);
-            if (myGNSS.begin(mySerial)) {
-                Serial.println("GNSS: connected at 9600 baud, switching to 38400");
-                myGNSS.setSerialRate(38400);
-                delay(100);
-            } else {
-                delay(2000); //Wait a bit before trying again to limit the Serial output flood
-            }
-        } while(1);
-        myGNSS.setUART1Output(COM_TYPE_UBX); //Set the UART port to output UBX only
-        myGNSS.saveConfiguration(); //Save the current settings to flash and BBR
-        Serial.println("GNSS serial connected, saved config");
-        state++;
-        break;
-    case 1: // hardReset, expect to see GNSS back at 38400 baud
-        Serial.println("Issuing hardReset (cold start)");
-        myGNSS.hardReset();
-        delay(2000);
-        mySerial.begin(38400);
-        if (myGNSS.begin(mySerial)) {
-            Serial.println("Success.");
-            state++;
-        } else {
-            Serial.println("*** GNSS did not respond at 38400 baud, starting over.");
-            state = 0;
-        }
-        break;
-    case 2: // factoryReset, expect to see GNSS back at defaultRate baud
-        Serial.println("Issuing factoryReset");
-        myGNSS.factoryReset();
-        delay(5000); // takes more than one second... a loop to resync would be best
-        mySerial.begin(defaultRate);
-        if (myGNSS.begin(mySerial)) {
-            Serial.println("Success.");
-            state++;
-        } else {
-            Serial.println("*** GNSS did not come back at defaultRate baud, starting over.");
-            state = 0;
-        }
-        break;
-    case 3: // print version info
-        // Note: this may fail on boards like the UNO (ATmega328P) with modules like the ZED-F9P
-        // because getProtocolVersion returns a lot of data - more than the UNO's serial buffer can hold
-        Serial.print("GNSS protocol version: ");
-        Serial.print(myGNSS.getProtocolVersionHigh());
-        Serial.print('.');
-        Serial.println(myGNSS.getProtocolVersionLow());
-        Serial.println("All finished! Freezing...");
-        while(1);
-    }
-    delay(1000);
-}
diff --git a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Example12_UseUart/Example12_UseUart.ino b/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Example12_UseUart/Example12_UseUart.ino
deleted file mode 100644
index 5d28e08..0000000
--- a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Example12_UseUart/Example12_UseUart.ino
+++ /dev/null
@@ -1,98 +0,0 @@
-/*
-  Reading lat and long via UBX binary commands using UART @38400 baud - free from I2C
-  By: Nathan Seidle, Adapted from Example3_GetPosition by Thorsten von Eicken
-  SparkFun Electronics
-  Date: January 28rd, 2019
-  License: MIT. See license file for more information but you can
-  basically do whatever you want with this code.
-
-  This example shows how to configure the library and U-Blox for serial port use as well as
-  switching the module from the default 9600 baud to 38400.
-
-  Note: Long/lat are large numbers because they are * 10^7. To convert lat/long
-  to something google maps understands simply divide the numbers by 10,000,000. We 
-  do this so that we don't have to use floating point numbers.
-
-  Leave NMEA parsing behind. Now you can simply ask the module for the datums you want!
-
-  Feel like supporting open source hardware?
-  Buy a board from SparkFun!
-  ZED-F9P RTK2: https://www.sparkfun.com/products/15136
-  NEO-M8P RTK: https://www.sparkfun.com/products/15005
-  SAM-M8Q: https://www.sparkfun.com/products/15106
-
-  Hardware Connections:
-  Connect the U-Blox serial TX pin to Uno pin 10
-  Connect the U-Blox serial RX pin to Uno pin 11
-  Open the serial monitor at 115200 baud to see the output
-*/
-
-#include <SparkFun_u-blox_GNSS_Arduino_Library.h> //http://librarymanager/All#SparkFun_u-blox_GNSS
-SFE_UBLOX_GNSS myGNSS;
-
-#include <SoftwareSerial.h>
-SoftwareSerial mySerial(10, 11); // RX, TX. Pin 10 on Uno goes to TX pin on GNSS module.
-
-long lastTime = 0; //Simple local timer. Limits amount of I2C traffic to u-blox module.
-
-void setup()
-{
-  Serial.begin(115200);
-  while (!Serial); //Wait for user to open terminal
-  Serial.println("SparkFun u-blox Example");
-
-  //Assume that the U-Blox GNSS is running at 9600 baud (the default) or at 38400 baud.
-  //Loop until we're in sync and then ensure it's at 38400 baud.
-  do {
-    Serial.println("GNSS: trying 38400 baud");
-    mySerial.begin(38400);
-    if (myGNSS.begin(mySerial) == true) break;
-
-    delay(100);
-    Serial.println("GNSS: trying 9600 baud");
-    mySerial.begin(9600);
-    if (myGNSS.begin(mySerial) == true) {
-        Serial.println("GNSS: connected at 9600 baud, switching to 38400");
-        myGNSS.setSerialRate(38400);
-        delay(100);
-    } else {
-        //myGNSS.factoryReset();
-        delay(2000); //Wait a bit before trying again to limit the Serial output
-    }
-  } while(1);
-  Serial.println("GNSS serial connected");
-
-  myGNSS.setUART1Output(COM_TYPE_UBX); //Set the UART port to output UBX only
-  myGNSS.setI2COutput(COM_TYPE_UBX); //Set the I2C port to output UBX only (turn off NMEA noise)
-  myGNSS.saveConfiguration(); //Save the current settings to flash and BBR
-}
-
-void loop()
-{
-  //Query module only every second. Doing it more often will just cause I2C traffic.
-  //The module only responds when a new position is available
-  if (millis() - lastTime > 1000)
-  {
-    lastTime = millis(); //Update the timer
-    
-    long latitude = myGNSS.getLatitude();
-    Serial.print(F("Lat: "));
-    Serial.print(latitude);
-
-    long longitude = myGNSS.getLongitude();
-    Serial.print(F(" Long: "));
-    Serial.print(longitude);
-    Serial.print(F(" (degrees * 10^-7)"));
-
-    long altitude = myGNSS.getAltitude();
-    Serial.print(F(" Alt: "));
-    Serial.print(altitude);
-    Serial.print(F(" (mm)"));
-
-    byte SIV = myGNSS.getSIV();
-    Serial.print(F(" SIV: "));
-    Serial.print(SIV);
-
-    Serial.println();
-  }
-}
diff --git a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Example13_PVT/Example1_AutoPVT/Example1_AutoPVT.ino b/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Example13_PVT/Example1_AutoPVT/Example1_AutoPVT.ino
deleted file mode 100644
index f82d4bc..0000000
--- a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Example13_PVT/Example1_AutoPVT/Example1_AutoPVT.ino
+++ /dev/null
@@ -1,141 +0,0 @@
-/*
-  Configuring the GNSS to automatically send position reports over I2C
-  By: Nathan Seidle and Thorsten von Eicken
-  SparkFun Electronics
-  Date: January 3rd, 2019
-  License: MIT. See license file for more information but you can
-  basically do whatever you want with this code.
-
-  This example shows how to configure the U-Blox GNSS the send navigation reports automatically
-  and retrieving the latest one via getPVT. This eliminates the blocking in getPVT while the GNSS
-  produces a fresh navigation solution at the expense of returning a slighly old solution.
-
-  This can be used over serial or over I2C, this example shows the I2C use. With serial the GNSS
-  simply outputs the UBX_NAV_PVT packet. With I2C it queues it into its internal I2C buffer (4KB in
-  size?) where it can be retrieved in the next I2C poll.
-
-  Feel like supporting open source hardware?
-  Buy a board from SparkFun!
-  ZED-F9P RTK2: https://www.sparkfun.com/products/15136
-  NEO-M8P RTK: https://www.sparkfun.com/products/15005
-  SAM-M8Q: https://www.sparkfun.com/products/15106
-
-  Hardware Connections:
-  Plug a Qwiic cable into the GNSS and a BlackBoard
-  If you don't have a platform with a Qwiic connection use the SparkFun Qwiic Breadboard Jumper (https://www.sparkfun.com/products/14425)
-  Open the serial monitor at 115200 baud to see the output
-*/
-
-#include <Wire.h> //Needed for I2C to GNSS
-
-#include <SparkFun_u-blox_GNSS_Arduino_Library.h> //http://librarymanager/All#SparkFun_u-blox_GNSS
-SFE_UBLOX_GNSS myGNSS;
-
-void setup()
-{
-  Serial.begin(115200);
-  while (!Serial); //Wait for user to open terminal
-  Serial.println("SparkFun u-blox Example");
-
-  Wire.begin();
-
-  if (myGNSS.begin() == false) //Connect to the u-blox module using Wire port
-  {
-    Serial.println(F("u-blox GNSS not detected at default I2C address. Please check wiring. Freezing."));
-    while (1);
-  }
-
-  myGNSS.setI2COutput(COM_TYPE_UBX); //Set the I2C port to output UBX only (turn off NMEA noise)
-  myGNSS.setNavigationFrequency(2); //Produce two solutions per second
-  myGNSS.setAutoPVT(true); //Tell the GNSS to "send" each solution
-  //myGNSS.saveConfiguration(); //Optional: Save the current settings to flash and BBR
-}
-
-void loop()
-{
-  // Calling getPVT returns true if there actually is a fresh navigation solution available.
-  // Start the reading only when valid LLH is available
-  if (myGNSS.getPVT() && (myGNSS.getInvalidLlh() == false))
-  {
-    Serial.println();
-    long latitude = myGNSS.getLatitude();
-    Serial.print(F("Lat: "));
-    Serial.print(latitude);
-
-    long longitude = myGNSS.getLongitude();
-    Serial.print(F(" Long: "));
-    Serial.print(longitude);
-    Serial.print(F(" (degrees * 10^-7)"));
-
-    long altitude = myGNSS.getAltitude();
-    Serial.print(F(" Alt: "));
-    Serial.print(altitude);
-    Serial.print(F(" (mm)"));
-
-    byte SIV = myGNSS.getSIV();
-    Serial.print(F(" SIV: "));
-    Serial.print(SIV);
-
-    int PDOP = myGNSS.getPDOP();
-    Serial.print(F(" PDOP: "));
-    Serial.print(PDOP);
-    Serial.print(F(" (10^-2)"));
-
-    int nedNorthVel = myGNSS.getNedNorthVel();
-    Serial.print(F(" VelN: "));
-    Serial.print(nedNorthVel);
-    Serial.print(F(" (mm/s)"));
-
-    int nedEastVel = myGNSS.getNedEastVel();
-    Serial.print(F(" VelE: "));
-    Serial.print(nedEastVel);
-    Serial.print(F(" (mm/s)"));
-
-    int nedDownVel = myGNSS.getNedDownVel();
-    Serial.print(F(" VelD: "));
-    Serial.print(nedDownVel);
-    Serial.print(F(" (mm/s)"));
-
-    int verticalAccEst = myGNSS.getVerticalAccEst();
-    Serial.print(F(" VAccEst: "));
-    Serial.print(verticalAccEst);
-    Serial.print(F(" (mm)"));
-
-    int horizontalAccEst = myGNSS.getHorizontalAccEst();
-    Serial.print(F(" HAccEst: "));
-    Serial.print(horizontalAccEst);
-    Serial.print(F(" (mm)"));
-
-    int speedAccEst = myGNSS.getSpeedAccEst();
-    Serial.print(F(" SpeedAccEst: "));
-    Serial.print(speedAccEst);
-    Serial.print(F(" (mm/s)"));
-
-    int headAccEst = myGNSS.getHeadingAccEst();
-    Serial.print(F(" HeadAccEst: "));
-    Serial.print(headAccEst);
-    Serial.print(F(" (degrees * 10^-5)"));
-
-    if (myGNSS.getHeadVehValid() == true) {
-      int headVeh = myGNSS.getHeadVeh();
-      Serial.print(F(" HeadVeh: "));
-      Serial.print(headVeh);
-      Serial.print(F(" (degrees * 10^-5)"));
-
-      int magDec = myGNSS.getMagDec();
-      Serial.print(F(" MagDec: "));
-      Serial.print(magDec);
-      Serial.print(F(" (degrees * 10^-2)"));
-
-      int magAcc = myGNSS.getMagAcc();
-      Serial.print(F(" MagAcc: "));
-      Serial.print(magAcc);
-      Serial.print(F(" (degrees * 10^-2)"));
-    }
-
-    Serial.println();
-  } else {
-    Serial.print(".");
-    delay(50);
-  }
-}
diff --git a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Example13_PVT/Example2_AutoPVT_ExplicitUpdate/Example2_AutoPVT_ExplicitUpdate.ino b/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Example13_PVT/Example2_AutoPVT_ExplicitUpdate/Example2_AutoPVT_ExplicitUpdate.ino
deleted file mode 100644
index 429b2ad..0000000
--- a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Example13_PVT/Example2_AutoPVT_ExplicitUpdate/Example2_AutoPVT_ExplicitUpdate.ino
+++ /dev/null
@@ -1,103 +0,0 @@
-/*
-  Configuring the GNSS to automatically send position reports over I2C, with explicit data parsing calls
-  By: Nathan Seidle Thorsten von Eicken and Felix Jirka
-  SparkFun Electronics
-  Date: July 1st, 2019
-  License: MIT. See license file for more information but you can
-  basically do whatever you want with this code.
-
-  This example shows how to configure the U-Blox GNSS the send navigation reports automatically
-  and retrieving the latest one via checkUblox when available.
-  This eliminates the implicit update in getPVT when accessing data fields twice.
-  Also this reduces the memory overhead of a separate buffer while introducing a slight error by inconsistencies because of the unsynchronized updates (on a multi core system).
-
-  This can be used over serial or over I2C, this example shows the I2C use. With serial the GNSS
-  simply outputs the UBX_NAV_PVT packet. With I2C it queues it into its internal I2C buffer (4KB in
-  size?) where it can be retrieved in the next I2C poll.
-
-  Feel like supporting open source hardware?
-  Buy a board from SparkFun!
-  ZED-F9P RTK2: https://www.sparkfun.com/products/15136
-  NEO-M8P RTK: https://www.sparkfun.com/products/15005
-  SAM-M8Q: https://www.sparkfun.com/products/15106
-
-  Hardware Connections:
-  Plug a Qwiic cable into the GNSS and a BlackBoard
-  If you don't have a platform with a Qwiic connection use the SparkFun Qwiic Breadboard Jumper (https://www.sparkfun.com/products/14425)
-  Open the serial monitor at 115200 baud to see the output
-*/
-
-#include <Wire.h> //Needed for I2C to GNSS
-
-#include <SparkFun_u-blox_GNSS_Arduino_Library.h> //http://librarymanager/All#SparkFun_u-blox_GNSS
-SFE_UBLOX_GNSS myGNSS;
-
-void setup()
-{
-  Serial.begin(115200);
-  while (!Serial)
-    ; //Wait for user to open terminal
-  Serial.println("SparkFun u-blox Example");
-
-  Wire.begin();
-
-  if (myGNSS.begin() == false) //Connect to the u-blox module using Wire port
-  {
-    Serial.println(F("u-blox GNSS not detected at default I2C address. Please check wiring. Freezing."));
-    while (1)
-      ;
-  }
-
-  myGNSS.setI2COutput(COM_TYPE_UBX); //Set the I2C port to output UBX only (turn off NMEA noise)
-  myGNSS.setNavigationFrequency(2);  //Produce two solutions per second
-  myGNSS.setAutoPVT(true, false);    //Tell the GNSS to "send" each solution and the lib not to update stale data implicitly
-  //myGNSS.saveConfiguration();        //Optional: Save the current settings to flash and BBR
-}
-
-/*
-     Calling getPVT would return false now (compare to previous example where it would return true), so we just use the data provided
-     If you are using a threaded OS eg. FreeRTOS on an ESP32, the explicit mode of autoPVT allows you to use the data provided on both cores and inside multiple threads
-     The data update in background creates an inconsistent state, but that should not cause issues for most applications as they usually won't change the GNSS location significantly within a 2Hz - 5Hz update rate.
-     Also you could oversample (10Hz - 20Hz) the data to smooth out such issues...
-*/
-void loop()
-{
-  static uint16_t counter = 0;
-
-  if (counter % 10 == 0)
-  {
-    // update your AHRS filter here for a ~100Hz update rate
-    // GNSS data will be quasi static but data from your IMU will be changing
-  }
-  // debug output each half second
-  if (counter % 500 == 0)
-  {
-    Serial.println();
-    long latitude = myGNSS.getLatitude();
-    Serial.print(F("Lat: "));
-    Serial.print(latitude);
-
-    long longitude = myGNSS.getLongitude();
-    Serial.print(F(" Long: "));
-    Serial.print(longitude);
-    Serial.print(F(" (degrees * 10^-7)"));
-
-    long altitude = myGNSS.getAltitude();
-    Serial.print(F(" Alt: "));
-    Serial.print(altitude);
-    Serial.print(F(" (mm)"));
-
-    byte SIV = myGNSS.getSIV();
-    Serial.print(F(" SIV: "));
-    Serial.print(SIV);
-
-    Serial.println();
-  }
-  // call checkUblox all 50ms to capture the GNSS data
-  if (counter % 50 == 0)
-  {
-    myGNSS.checkUblox();
-  }
-  delay(1);
-  counter++;
-}
diff --git a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Example13_PVT/Example3_AutoPVTviaUart/Example3_AutoPVTviaUart.ino b/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Example13_PVT/Example3_AutoPVTviaUart/Example3_AutoPVTviaUart.ino
deleted file mode 100644
index 8aa3937..0000000
--- a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Example13_PVT/Example3_AutoPVTviaUart/Example3_AutoPVTviaUart.ino
+++ /dev/null
@@ -1,107 +0,0 @@
-/*
-  Configuring the GNSS to automatically send position reports over Serial
-  By: Nathan Seidle, Adapted from Example11 by Felix Jirka
-  SparkFun Electronics
-  Date: July 2nd, 2019
-  License: MIT. See license file for more information but you can
-  basically do whatever you want with this code.
-
-  This example shows how to configure the U-Blox GNSS the send navigation reports automatically
-  and retrieving the latest one via getPVT. This eliminates the blocking in getPVT while the GNSS
-  produces a fresh navigation solution at the expense of returning a slighly old solution.
-
-  This can be used over serial or over I2C, this example shows the Serial use. With serial the GNSS
-  simply outputs the UBX_NAV_PVT packet. With I2C it queues it into its internal I2C buffer (4KB in
-  size?) where it can be retrieved in the next I2C poll.
-
-  Leave NMEA parsing behind. Now you can simply ask the module for the datums you want!
-
-  Feel like supporting open source hardware?
-  Buy a board from SparkFun!
-  ZED-F9P RTK2: https://www.sparkfun.com/products/15136
-  NEO-M8P RTK: https://www.sparkfun.com/products/15005
-  SAM-M8Q: https://www.sparkfun.com/products/15106
-
-  Hardware Connections:
-  Plug a Qwiic cable into the GNSS and a BlackBoard
-  If you don't have a platform with a Qwiic connection use the SparkFun Qwiic Breadboard Jumper (https://www.sparkfun.com/products/14425)
-  Open the serial monitor at 115200 baud to see the output
-*/
-
-#include <SparkFun_u-blox_GNSS_Arduino_Library.h> //http://librarymanager/All#SparkFun_u-blox_GNSS
-SFE_UBLOX_GNSS myGNSS;
-
-#include <SoftwareSerial.h>
-
-//#define mySerial Serial2 // Uncomment this line to connect via Serial2
-// - or -
-SoftwareSerial mySerial(10, 11); // Uncomment this line to connect via SoftwareSerial(RX, TX). Connect pin 10 to GNSS TX pin.
-
-//#define baudRate 9600 // Uncomment this line to select 9600 Baud for the M8
-// - or -
-#define baudRate 38400 // Uncomment this line to select 38400 Baud for the F9
-
-void setup()
-{
-  Serial.begin(115200);
-  while (!Serial); //Wait for user to open terminal
-  Serial.println("SparkFun u-blox Example");
-
-  mySerial.begin(baudRate); // Start the Serial port
-
-  if (myGNSS.begin(mySerial) == false) //Connect to the u-blox module using Serial
-  {
-    Serial.println(F("u-blox GNSS not detected. Please check wiring. Freezing."));
-    while (1);
-  }
-
-  myGNSS.setUART1Output(COM_TYPE_UBX); //Set the UART1 port to output UBX only (turn off NMEA noise)
-  myGNSS.setNavigationFrequency(2); //Produce two solutions per second
-  myGNSS.setAutoPVT(true); //Tell the GNSS to "send" each solution
-  //myGNSS.saveConfiguration(); //Optional: Save the current settings to flash and BBR
-}
-
-void loop()
-{
-  // getPVT will return true if there actually is a fresh navigation solution available.
-  // Important note: the PVT message is 100 bytes long. We need to call getPVT often enough
-  // to prevent serial buffer overflows on boards like the original RedBoard / UNO.
-  // At 38400 Baud, the 100 PVT bytes will arrive in 26ms.
-  // On the RedBoard, we need to call getPVT every 5ms to keep up.
-  if (myGNSS.getPVT())
-  {
-    Serial.println();
-
-    long latitude = myGNSS.getLatitude();
-    Serial.print(F("Lat: "));
-    Serial.print(latitude);
-
-    long longitude = myGNSS.getLongitude();
-    Serial.print(F(" Long: "));
-    Serial.print(longitude);
-    Serial.print(F(" (degrees * 10^-7)"));
-
-    long altitude = myGNSS.getAltitude();
-    Serial.print(F(" Alt: "));
-    Serial.print(altitude);
-    Serial.print(F(" (mm)"));
-
-    byte SIV = myGNSS.getSIV();
-    Serial.print(F(" SIV: "));
-    Serial.print(SIV);
-
-    Serial.println();
-  }
-  else
-  {
-    delay(5); // Delay for 5ms only
-
-    static int counter = 0; // Print a dot every 50ms
-    counter++;
-    if (counter > 10)
-    {
-      Serial.print(".");
-      counter = 0;
-    }
-  }
-}
diff --git a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Example13_PVT/Example4_AssumeAutoPVTviaUart/Example4_AssumeAutoPVTviaUart.ino b/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Example13_PVT/Example4_AssumeAutoPVTviaUart/Example4_AssumeAutoPVTviaUart.ino
deleted file mode 100644
index 756a8b0..0000000
--- a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Example13_PVT/Example4_AssumeAutoPVTviaUart/Example4_AssumeAutoPVTviaUart.ino
+++ /dev/null
@@ -1,110 +0,0 @@
-/*
-  Reading lat and long via UBX binary commands using an RX-only UART
-  By: Nathan Seidle, Adapted from Example11 by Felix Jirka
-  SparkFun Electronics
-  Date: July 2nd, 2019
-  License: MIT. See license file for more information but you can
-  basically do whatever you want with this code.
-
-  This example shows how to configure the library for serial port use with a single wire connection using the assumeAutoPVT method.
-  Saving your pins for other stuff :-)
-
-  This example only works correctly if the module has already been configured is sending PVT messages via its UART1 TX pin.
-  Run the previous example to enable the auto PVT messages if you need to.
-
-  Leave NMEA parsing behind. Now you can simply ask the module for the datums you want!
-
-  Feel like supporting open source hardware?
-  Buy a board from SparkFun!
-  ZED-F9P RTK2: https://www.sparkfun.com/products/15136
-  NEO-M8P RTK: https://www.sparkfun.com/products/15005
-  SAM-M8Q: https://www.sparkfun.com/products/15106
-
-  Preconditions:
-  U-Blox module is configured to send cyclical PVT message
-  
-  Hardware Connections:
-  Connect the U-Blox serial TX pin to Rx of Serial2 (default: GPIO16) on your ESP32
-  Or, switch to SoftwareSerial
-  Open the serial monitor at 115200 baud to see the output
-*/
-
-#include <SparkFun_u-blox_GNSS_Arduino_Library.h> //http://librarymanager/All#SparkFun_u-blox_GNSS
-SFE_UBLOX_GNSS myGNSS;
-
-#include <SoftwareSerial.h>
-
-//#define mySerial Serial2 // Uncomment this line to connect via Serial2
-// - or -
-SoftwareSerial mySerial(10, 11); // Uncomment this line to connect via SoftwareSerial(RX, TX). Connect pin 10 to GNSS TX pin.
-
-//#define baudRate 9600 // Uncomment this line to select 9600 Baud for the M8
-// - or -
-#define baudRate 38400 // Uncomment this line to select 38400 Baud for the F9
-
-void setup()
-{
-  Serial.begin(115200);
-  while (!Serial); //Wait for user to open terminal
-  Serial.println("SparkFun u-blox Example");
-
-  //Use any Serial port with at least a RX Pin connected or a receive only version of SoftwareSerial here
-  //Assume that the U-Blox GNSS is running at baudRate baud
-  mySerial.begin(baudRate);
-  // No need to check return value as internal call to isConnected() will not succeed
-  myGNSS.begin(mySerial);
-
-  // Tell the library we are expecting the module to send PVT messages by itself to our Rx pin.
-  // You can set second parameter to "false" if you want to control the parsing and eviction of the data (need to call checkUblox cyclically)
-  myGNSS.assumeAutoPVT(true, true);
-
-}
-
-void loop()
-{
-  // If implicit updates are enabled, calling getPVT will trigger parsing of the incoming messages
-  // and return true once a PVT message has been parsed.
-  // In case you want to use explicit updates, wrap this in a timer and call checkUblox()
-  // as often as needed, not to overflow your UART buffers.
-  //
-  // Important note: the PVT message is 100 bytes long. We need to call getPVT often enough
-  // to prevent serial buffer overflows on boards like the original RedBoard / UNO.
-  // At 38400 Baud, the 100 PVT bytes will arrive in 26ms.
-  // On the RedBoard, we need to call getPVT every 5ms to keep up.
-  if (myGNSS.getPVT())
-  {
-    Serial.println();
-
-    long latitude = myGNSS.getLatitude();
-    Serial.print(F("Lat: "));
-    Serial.print(latitude);
-
-    long longitude = myGNSS.getLongitude();
-    Serial.print(F(" Long: "));
-    Serial.print(longitude);
-    Serial.print(F(" (degrees * 10^-7)"));
-
-    long altitude = myGNSS.getAltitude();
-    Serial.print(F(" Alt: "));
-    Serial.print(altitude);
-    Serial.print(F(" (mm)"));
-
-    byte SIV = myGNSS.getSIV();
-    Serial.print(F(" SIV: "));
-    Serial.print(SIV);
-
-    Serial.println();
-  }
-  else
-  {
-    delay(5); // Delay for 5ms only
-
-    static int counter = 0; // Print a dot every 50ms
-    counter++;
-    if (counter > 10)
-    {
-      Serial.print(".");
-      counter = 0;
-    }
-  }
-}
diff --git a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Example14_DebugOutput/Example14_DebugOutput.ino b/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Example14_DebugOutput/Example14_DebugOutput.ino
deleted file mode 100644
index 544655e..0000000
--- a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Example14_DebugOutput/Example14_DebugOutput.ino
+++ /dev/null
@@ -1,107 +0,0 @@
-/*
-  Debug Output
-  By: Nathan Seidle, Adapted from Example3_GetPosition by Thorsten von Eicken
-  SparkFun Electronics
-  Date: January 28rd, 2019
-  License: MIT. See license file for more information but you can
-  basically do whatever you want with this code.
-
-  This example shows how to configure the debug output from the library.
-  Debug shows various packet and status outputs. These prints can be directed
-  towards Serial (as in Serial.print) or any other port (Serial1, SerialUSB, etc).
-
-  You can also limit the debug messages to the "critical" ones by adding an extra argument.
-
-  The debug messages can be disabled again by calling disableDebugging()
-
-  Feel like supporting open source hardware?
-  Buy a board from SparkFun!
-  ZED-F9P RTK2: https://www.sparkfun.com/products/15136
-  NEO-M8P RTK: https://www.sparkfun.com/products/15005
-  SAM-M8Q: https://www.sparkfun.com/products/15106
-
-  Hardware Connections:
-  Plug a Qwiic cable into the GNSS and a BlackBoard
-  If you don't have a platform with a Qwiic connection use the SparkFun Qwiic Breadboard Jumper (https://www.sparkfun.com/products/14425)
-  Open the serial monitor at 115200 baud to see the output
-*/
-
-#include <SparkFun_u-blox_GNSS_Arduino_Library.h> //http://librarymanager/All#SparkFun_u-blox_GNSS
-SFE_UBLOX_GNSS myGNSS;
-
-unsigned long lastTime = 0; //Simple local timer. Limits amount if I2C traffic to u-blox module.
-int counter = 0; // Disable the debug messages when counter reaches 20
-
-void setup()
-{
-  Serial.begin(115200);
-  while (!Serial); //Wait for user to open terminal
-  Serial.println("SparkFun u-blox Example");
-
-  Wire.begin();
-
-  if (myGNSS.begin() == false) //Connect to the u-blox module using Wire port
-  {
-    Serial.println(F("u-blox GNSS not detected at default I2C address. Please check wiring. Freezing."));
-    while (1);
-  }
-
-  myGNSS.setI2COutput(COM_TYPE_UBX); //Set the I2C port to output UBX only (turn off NMEA noise)
-  //myGNSS.saveConfiguration(); //Optional: Save the current settings to flash and BBR
-
-  myGNSS.enableDebugging(); //Enable all the debug messages over Serial (default)
-  
-  //myGNSS.enableDebugging(SerialUSB); //Enable debug messages over Serial USB
-
-  //myGNSS.enableDebugging(Serial, true); //Enable only the critical debug messages over Serial
-  
-}
-
-void loop()
-{
-  //Query module only every second. Doing it more often will just cause I2C traffic.
-  //The module only responds when a new position is available
-  if (millis() - lastTime > 1000)
-  {
-    lastTime = millis(); //Update the timer
-    
-    long latitude = myGNSS.getLatitude();
-    Serial.print(F("Lat: "));
-    Serial.print(latitude);
-
-    long longitude = myGNSS.getLongitude();
-    Serial.print(F(" Long: "));
-    Serial.print(longitude);
-    Serial.print(F(" (degrees * 10^-7)"));
-
-    long altitude = myGNSS.getAltitude();
-    Serial.print(F(" Alt: "));
-    Serial.print(altitude);
-    Serial.print(F(" (mm)"));
-
-    byte SIV = myGNSS.getSIV();
-    Serial.print(F(" SIV: "));
-    Serial.print(SIV);
-
-    Serial.print(F("   "));
-    Serial.print(myGNSS.getYear());
-    Serial.print(F("-"));
-    Serial.print(myGNSS.getMonth());
-    Serial.print(F("-"));
-    Serial.print(myGNSS.getDay());
-    Serial.print(F(" "));
-    Serial.print(myGNSS.getHour());
-    Serial.print(F(":"));
-    Serial.print(myGNSS.getMinute());
-    Serial.print(F(":"));
-    Serial.println(myGNSS.getSecond());
-    
-    Serial.println();
-
-    counter++; // Increment counter
-    if (counter == 20)
-    {
-      myGNSS.disableDebugging(); // Disable the debug messages when counter reaches 20
-    }
-  }
-}
diff --git a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Example15_GetDateTime/Example15_GetDateTime.ino b/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Example15_GetDateTime/Example15_GetDateTime.ino
deleted file mode 100644
index bdbaf63..0000000
--- a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Example15_GetDateTime/Example15_GetDateTime.ino
+++ /dev/null
@@ -1,107 +0,0 @@
-/*
-  Getting time and date using u-blox commands
-  By: davidallenmann
-  SparkFun Electronics
-  Date: April 16th, 2019
-  License: MIT. See license file for more information but you can
-  basically do whatever you want with this code.
-
-  This example shows how to query a u-blox module for the current time and date. We also
-  turn off the NMEA output on the I2C port. This decreases the amount of I2C traffic
-  dramatically.
-
-  Leave NMEA parsing behind. Now you can simply ask the module for the datums you want!
-
-  Feel like supporting open source hardware?
-  Buy a board from SparkFun!
-  ZED-F9P RTK2: https://www.sparkfun.com/products/15136
-  NEO-M8P RTK: https://www.sparkfun.com/products/15005
-  SAM-M8Q: https://www.sparkfun.com/products/15106
-
-  Hardware Connections:
-  Plug a Qwiic cable into the GNSS and a BlackBoard
-  If you don't have a platform with a Qwiic connection use the SparkFun Qwiic Breadboard Jumper (https://www.sparkfun.com/products/14425)
-  Open the serial monitor at 115200 baud to see the output
-*/
-
-#include <Wire.h> //Needed for I2C to GNSS
-
-#include <SparkFun_u-blox_GNSS_Arduino_Library.h> //http://librarymanager/All#SparkFun_u-blox_GNSS
-SFE_UBLOX_GNSS myGNSS;
-
-long lastTime = 0; //Simple local timer. Limits amount if I2C traffic to u-blox module.
-
-void setup()
-{
-  Serial.begin(115200);
-  while (!Serial)
-    ; //Wait for user to open terminal
-  Serial.println("SparkFun u-blox Example");
-
-  Wire.begin();
-
-  if (myGNSS.begin() == false) //Connect to the u-blox module using Wire port
-  {
-    Serial.println(F("u-blox GNSS not detected at default I2C address. Please check wiring. Freezing."));
-    while (1)
-      ;
-  }
-
-  myGNSS.setI2COutput(COM_TYPE_UBX); //Set the I2C port to output UBX only (turn off NMEA noise)
-  //myGNSS.saveConfiguration();        //Optional: Save the current settings to flash and BBR
-}
-
-void loop()
-{
-  //Query module only every second. Doing it more often will just cause I2C traffic.
-  //The module only responds when a new position is available
-  if (millis() - lastTime > 1000)
-  {
-    lastTime = millis(); //Update the timer
-
-    long latitude = myGNSS.getLatitude();
-    Serial.print(F("Lat: "));
-    Serial.print(latitude);
-
-    long longitude = myGNSS.getLongitude();
-    Serial.print(F(" Long: "));
-    Serial.print(longitude);
-    Serial.print(F(" (degrees * 10^-7)"));
-
-    long altitude = myGNSS.getAltitude();
-    Serial.print(F(" Alt: "));
-    Serial.print(altitude);
-    Serial.print(F(" (mm)"));
-
-    byte SIV = myGNSS.getSIV();
-    Serial.print(F(" SIV: "));
-    Serial.print(SIV);
-
-    Serial.println();
-    Serial.print(myGNSS.getYear());
-    Serial.print("-");
-    Serial.print(myGNSS.getMonth());
-    Serial.print("-");
-    Serial.print(myGNSS.getDay());
-    Serial.print(" ");
-    Serial.print(myGNSS.getHour());
-    Serial.print(":");
-    Serial.print(myGNSS.getMinute());
-    Serial.print(":");
-    Serial.print(myGNSS.getSecond());
-
-    Serial.print("  Time is ");
-    if (myGNSS.getTimeValid() == false)
-    {
-      Serial.print("not ");
-    }
-    Serial.print("valid  Date is ");
-    if (myGNSS.getDateValid() == false)
-    {
-      Serial.print("not ");
-    }
-    Serial.print("valid");
-
-    Serial.println();
-  }
-}
diff --git a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Example16_Nanosecond_MaxOutput/Example16_Nanosecond_MaxOutput.ino b/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Example16_Nanosecond_MaxOutput/Example16_Nanosecond_MaxOutput.ino
deleted file mode 100644
index 6fa1d68..0000000
--- a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Example16_Nanosecond_MaxOutput/Example16_Nanosecond_MaxOutput.ino
+++ /dev/null
@@ -1,109 +0,0 @@
-/*
-  Getting time and date using u-blox commands
-  By: davidallenmann
-  SparkFun Electronics
-  Date: April 16th, 2019
-  License: MIT. See license file for more information but you can
-  basically do whatever you want with this code.
-
-  This example shows how to query a u-blox module for the current time and date. We also
-  turn off the NMEA output on the I2C port. This decreases the amount of I2C traffic
-  dramatically.
-
-  Note: you will need to set your Serial Monitor to 500000 Baud to see the output
-
-  Leave NMEA parsing behind. Now you can simply ask the module for the datums you want!
-
-  Feel like supporting open source hardware?
-  Buy a board from SparkFun!
-  ZED-F9P RTK2: https://www.sparkfun.com/products/15136
-  NEO-M8P RTK: https://www.sparkfun.com/products/15005
-  SAM-M8Q: https://www.sparkfun.com/products/15106
-
-  Hardware Connections:
-  Plug a Qwiic cable into the GNSS and a BlackBoard
-  If you don't have a platform with a Qwiic connection use the SparkFun Qwiic Breadboard Jumper (https://www.sparkfun.com/products/14425)
-  Open the serial monitor at 115200 baud to see the output
-*/
-
-#include <Wire.h> //Needed for I2C to GNSS
-
-#include <SparkFun_u-blox_GNSS_Arduino_Library.h> //http://librarymanager/All#SparkFun_u-blox_GNSS
-SFE_UBLOX_GNSS myGNSS;
-
-long lastTime = 0; //Simple local timer. Limits amount if I2C traffic to u-blox module.
-
-void setup()
-{
-  Serial.begin(500000); //Increase serial speed to maximize
-  while (!Serial)
-    ; //Wait for user to open terminal
-  Serial.println("SparkFun u-blox Example");
-
-  Wire.begin();
-  Wire.setClock(400000); // Increase I2C clock speed to 400kHz
-
-  //myGNSS.enableDebugging(); //Uncomment this line to enable debug messages over Serial
-
-  if (myGNSS.begin() == false) //Connect to the u-blox module using Wire port
-  {
-    Serial.println(F("u-blox GNSS not detected at default I2C address. Please check wiring. Freezing."));
-    while (1)
-      ;
-  }
-
-  myGNSS.setI2COutput(COM_TYPE_UBX); //Set the I2C port to output UBX only (turn off NMEA noise)
-  //myGNSS.saveConfiguration(); //Optional: Save the current settings to flash and BBR
-
-  myGNSS.setNavigationFrequency(5); //Set output to 5 times a second
-  
-  byte rate = myGNSS.getNavigationFrequency(); //Get the update rate of this module
-  Serial.print("Current update rate: ");
-  Serial.println(rate);
-}
-
-void loop()
-{
-  // Calling getPVT returns true if there actually is a fresh navigation solution available.
-  if (myGNSS.getPVT())
-  {
-    lastTime = millis(); //Update the timer
-
-    long latitude = myGNSS.getLatitude();
-    Serial.print(F("Lat: "));
-    Serial.print(latitude);
-
-    long longitude = myGNSS.getLongitude();
-    Serial.print(F(" Long: "));
-    Serial.print(longitude);
-    Serial.print(F(" (degrees * 10^-7)"));
-
-    long altitude = myGNSS.getAltitude();
-    Serial.print(F(" Alt: "));
-    Serial.print(altitude);
-    Serial.print(F(" (mm)"));
-
-    byte SIV = myGNSS.getSIV();
-    Serial.print(F(" SIV: "));
-    Serial.print(SIV);
-
-    Serial.print(" ");
-    Serial.print(myGNSS.getYear());
-    Serial.print("-");
-    Serial.print(myGNSS.getMonth());
-    Serial.print("-");
-    Serial.print(myGNSS.getDay());
-    Serial.print(" ");
-    Serial.print(myGNSS.getHour());
-    Serial.print(":");
-    Serial.print(myGNSS.getMinute());
-    Serial.print(":");
-    Serial.print(myGNSS.getSecond());
-    Serial.print(" nanoseconds: ");
-    Serial.print(myGNSS.getNanosecond()); // Nanoseconds can be negative
-
-    myGNSS.flushPVT();
-
-    Serial.println();
-  }
-}
diff --git a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Example16_PartialSecond_MaxOutput/Example16_PartialSecond_MaxOutput.ino b/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Example16_PartialSecond_MaxOutput/Example16_PartialSecond_MaxOutput.ino
deleted file mode 100644
index aee070b..0000000
--- a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Example16_PartialSecond_MaxOutput/Example16_PartialSecond_MaxOutput.ino
+++ /dev/null
@@ -1,118 +0,0 @@
-/*
-  Getting time and date using u-blox commands
-  By: Nathan Seidle
-  SparkFun Electronics
-  Date: April 16th, 2019
-  License: MIT. See license file for more information but you can
-  basically do whatever you want with this code.
-
-  This example shows how to use the Millisecond and Nanosecond output as well as increase the
-  I2C speed (100 to 400kHz), and serial output (115200 to 500kbps).
-
-  Note: you will need to set your Serial Monitor to 500000 Baud to see the output
-
-  Leave NMEA parsing behind. Now you can simply ask the module for the datums you want!
-
-  Feel like supporting open source hardware?
-  Buy a board from SparkFun!
-  ZED-F9P RTK2: https://www.sparkfun.com/products/15136
-  NEO-M8P RTK: https://www.sparkfun.com/products/15005
-  SAM-M8Q: https://www.sparkfun.com/products/15106
-
-  Hardware Connections:
-  Plug a Qwiic cable into the GNSS and a BlackBoard
-  If you don't have a platform with a Qwiic connection use the SparkFun Qwiic Breadboard Jumper (https://www.sparkfun.com/products/14425)
-  Open the serial monitor at 115200 baud to see the output
-*/
-
-#include <Wire.h> //Needed for I2C to GNSS
-
-#include <SparkFun_u-blox_GNSS_Arduino_Library.h> //http://librarymanager/All#SparkFun_u-blox_GNSS
-SFE_UBLOX_GNSS myGNSS;
-
-long lastTime = 0; //Simple local timer. Limits amount if I2C traffic to u-blox module.
-
-void setup()
-{
-  Serial.begin(500000); //Increase serial speed to maximize
-  while (!Serial)
-    ; //Wait for user to open terminal
-  Serial.println("SparkFun u-blox Example");
-
-  Wire.begin();
-  Wire.setClock(400000); // Increase I2C clock speed to 400kHz
-
-  //myGNSS.enableDebugging(); //Uncomment this line to enable debug messages over Serial
-
-  if (myGNSS.begin() == false) //Connect to the u-blox module using Wire port
-  {
-    Serial.println(F("u-blox GNSS not detected at default I2C address. Please check wiring. Freezing."));
-    while (1)
-      ;
-  }
-
-  myGNSS.setI2COutput(COM_TYPE_UBX); //Set the I2C port to output UBX only (turn off NMEA noise)
-
-  // Note: not all u-blox modules can output solutions at 10Hz - or not while tracking all satellite constellations
-  // If the rate drops back to 1Hz, you're asking too much of your module
-  myGNSS.setNavigationFrequency(10);           //Set output to 10 times a second
-  
-  byte rate = myGNSS.getNavigationFrequency(); //Get the update rate of this module
-  Serial.print("Current update rate:");
-  Serial.println(rate);
-
-  //myGNSS.saveConfiguration(); //Optional: Save the current settings to flash and BBR
-}
-
-void loop()
-{
-  // Calling getPVT returns true if there actually is a fresh navigation solution available.
-  if (myGNSS.getPVT())
-  {
-    lastTime = millis(); //Update the timer
-
-    long latitude = myGNSS.getLatitude();
-    Serial.print(F("Lat: "));
-    Serial.print(latitude);
-
-    long longitude = myGNSS.getLongitude();
-    Serial.print(F(" Long: "));
-    Serial.print(longitude);
-    Serial.print(F(" (degrees * 10^-7)"));
-
-    long altitude = myGNSS.getAltitude();
-    Serial.print(F(" Alt: "));
-    Serial.print(altitude);
-    Serial.print(F(" (mm)"));
-
-    byte SIV = myGNSS.getSIV();
-    Serial.print(F(" SIV: "));
-    Serial.print(SIV);
-
-    Serial.print(" ");
-    Serial.print(myGNSS.getYear());
-    Serial.print("-");
-    Serial.print(myGNSS.getMonth());
-    Serial.print("-");
-    Serial.print(myGNSS.getDay());
-    Serial.print(" ");
-    Serial.print(myGNSS.getHour());
-    Serial.print(":");
-    Serial.print(myGNSS.getMinute());
-    Serial.print(":");
-    Serial.print(myGNSS.getSecond());
-    Serial.print(".");
-    //Pretty print leading zeros
-    int mseconds = myGNSS.getMillisecond();
-    if (mseconds < 100)
-      Serial.print("0");
-    if (mseconds < 10)
-      Serial.print("0");
-    Serial.print(mseconds);
-
-    Serial.print(" nanoseconds: ");
-    Serial.print(myGNSS.getNanosecond());
-
-    Serial.println();
-  }
-}
diff --git a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Example17_Geofence/Example17_Geofence.ino b/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Example17_Geofence/Example17_Geofence.ino
deleted file mode 100644
index 684fd05..0000000
--- a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Example17_Geofence/Example17_Geofence.ino
+++ /dev/null
@@ -1,169 +0,0 @@
-/*
-  u-blox M8 geofence example
-
-  Written by Paul Clark (PaulZC)
-  10th December 2019
-
-  License: MIT. See license file for more information but you can
-  basically do whatever you want with this code.
-
-  This example demonstrates how to use the addGeofence and getGeofenceState functions
-
-  Feel like supporting open source hardware?
-  Buy a board from SparkFun!
-  ZED-F9P RTK2: https://www.sparkfun.com/products/15136
-  NEO-M8P RTK: https://www.sparkfun.com/products/15005
-  SAM-M8Q: https://www.sparkfun.com/products/15210
-  ZOE-M8Q: https://www.sparkfun.com/products/15193
-
-  This example powers up the GNSS and reads the fix.
-  Once a valid 3D fix has been found, the code reads the latitude and longitude.
-  The code then sets four geofences around that position with a radii of 5m, 10m, 15m and 20m with 95% confidence.
-  The code then monitors the geofence status.
-  The LED will be illuminated if you are inside the _combined_ geofence (i.e. within the 20m radius).
-
-  This code has been tested on the ZOE-M8Q.
-*/
-
-#define LED LED_BUILTIN // Change this if your LED is on a different pin
-
-#include <Wire.h> // Needed for I2C
-
-#include <SparkFun_u-blox_GNSS_Arduino_Library.h> //http://librarymanager/All#SparkFun_u-blox_GNSS
-SFE_UBLOX_GNSS myGNSS;
-
-void setup()
-{
-  pinMode(LED, OUTPUT);
-
-  // Set up the I2C pins
-  Wire.begin();
-
-  // Start the console serial port
-  Serial.begin(115200);
-  while (!Serial); // Wait for the user to open the serial monitor
-  delay(100);
-  Serial.println();
-  Serial.println();
-  Serial.println(F("u-blox M8 geofence example"));
-  Serial.println();
-  Serial.println();
-
-  delay(1000); // Let the GNSS power up
-
-  if (myGNSS.begin() == false) //Connect to the u-blox module using Wire port
-  {
-    Serial.println(F("u-blox GNSS not detected at default I2C address. Please check wiring. Freezing."));
-    while (1);
-  }
-
-  //myGNSS.enableDebugging(); // Enable debug messages
-  myGNSS.setI2COutput(COM_TYPE_UBX); // Limit I2C output to UBX (disable the NMEA noise)
-
-  Serial.println(F("Waiting for a 3D fix..."));
-
-  byte fixType = 0;
-
-  while (fixType < 3)
-  {
-    fixType = myGNSS.getFixType(); // Get the fix type
-    Serial.print(F("Fix: ")); // Print it
-    Serial.print(fixType);
-    if(fixType == 0) Serial.print(F(" = No fix"));
-    else if(fixType == 1) Serial.print(F(" = Dead reckoning"));
-    else if(fixType == 2) Serial.print(F(" = 2D"));
-    else if(fixType == 3) Serial.print(F(" = 3D"));
-    else if(fixType == 4) Serial.print(F(" = GNSS + Dead reckoning"));
-    else if(fixType == 5) Serial.print(F(" = Time only"));
-    Serial.println();
-    delay(1000);
-  }
-
-  Serial.println(F("3D fix found!"));
-
-  long latitude = myGNSS.getLatitude(); // Get the latitude in degrees * 10^-7
-  Serial.print(F("Lat: "));
-  Serial.print(latitude);
-
-  long longitude = myGNSS.getLongitude(); // Get the longitude in degrees * 10^-7
-  Serial.print(F("   Long: "));
-  Serial.println(longitude);
-
-  uint32_t radius = 500; // Set the radius to 5m (radius is in m * 10^-2 i.e. cm)
-
-  byte confidence = 2; // Set the confidence level: 0=none, 1=68%, 2=95%, 3=99.7%, 4=99.99%
-
-  // Call clearGeofences() to clear all existing geofences.
-  Serial.print(F("Clearing any existing geofences. clearGeofences returned: "));
-  Serial.println(myGNSS.clearGeofences());
-
-  // It is possible to define up to four geofences.
-  // Call addGeofence up to four times to define them.
-  Serial.println(F("Setting the geofences:"));
-
-  Serial.print(F("addGeofence for geofence 1 returned: "));
-  Serial.println(myGNSS.addGeofence(latitude, longitude, radius, confidence));
-
-  radius = 1000; // 10m
-  Serial.print(F("addGeofence for geofence 2 returned: "));
-  Serial.println(myGNSS.addGeofence(latitude, longitude, radius, confidence));
-
-  radius = 1500; // 15m
-  Serial.print(F("addGeofence for geofence 3 returned: "));
-  Serial.println(myGNSS.addGeofence(latitude, longitude, radius, confidence));
-
-  radius = 2000; // 20m
-  Serial.print(F("addGeofence for geofence 4 returned: "));
-  Serial.println(myGNSS.addGeofence(latitude, longitude, radius, confidence));
-}
-
-void loop()
-{
-  geofenceState currentGeofenceState; // Create storage for the geofence state
-
-  boolean result = myGNSS.getGeofenceState(currentGeofenceState);
-
-  Serial.print(F("getGeofenceState returned: ")); // Print the combined state
-  Serial.print(result); // Get the geofence state
-
-  if (!result) // If getGeofenceState did not return true
-  {
-    Serial.println(F(".")); // Tidy up
-    return; // and go round the loop again
-  }
-
-  Serial.print(F(". status is: ")); // Print the status
-  Serial.print(currentGeofenceState.status);
-
-  Serial.print(F(". numFences is: ")); // Print the numFences
-  Serial.print(currentGeofenceState.numFences);
-
-  Serial.print(F(". combState is: ")); // Print the combined state
-  Serial.print(currentGeofenceState.combState);
-
-  if (currentGeofenceState.combState == 0)
-  {
-    Serial.print(F(" = Unknown"));
-    digitalWrite(LED, LOW);
-  }
-  if (currentGeofenceState.combState == 1)
-  {
-    Serial.print(F(" = Inside"));
-    digitalWrite(LED, HIGH);
-  }
-  else if (currentGeofenceState.combState == 2)
-  {
-    Serial.print(F(" = Outside"));
-    digitalWrite(LED, LOW);
-  }
-
-  Serial.print(F(". The individual states are: ")); // Print the state of each geofence
-  for(int i = 0; i < currentGeofenceState.numFences; i++)
-  {
-    if (i > 0) Serial.print(F(","));
-    Serial.print(currentGeofenceState.states[i]);
-  }
-  Serial.println();
-
-  delay(1000);
-}
diff --git a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Example18_PowerSaveMode/Example18_PowerSaveMode.ino b/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Example18_PowerSaveMode/Example18_PowerSaveMode.ino
deleted file mode 100644
index fc24259..0000000
--- a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Example18_PowerSaveMode/Example18_PowerSaveMode.ino
+++ /dev/null
@@ -1,163 +0,0 @@
-/*
-  Power Save Mode
-  By: Paul Clark (PaulZC)
-  Date: April 22nd, 2020
-
-  Based extensively on Example3_GetPosition
-  By: Nathan Seidle
-  SparkFun Electronics
-  Date: January 3rd, 2019
-  License: MIT. See license file for more information but you can
-  basically do whatever you want with this code.
-
-  This example shows how to put the u-blox module into power save mode and then
-  query its lat/long/altitude. We also turn off the NMEA output on the I2C port.
-  This decreases the amount of I2C traffic dramatically.
-
-  ** When it is able to ** the module will reduce its current draw.
-  For the ZOE-M8Q with a passive antenna, you should see the current drop
-  from (approx.) 25-28mA to (approx.) 9mA when power save mode kicks in.
-
-  Note: this will fail on the ZED (protocol version >= 27) as UBX-CFG-RXM is not supported
-
-  Note: Long/lat are large numbers because they are * 10^7. To convert lat/long
-  to something google maps understands simply divide the numbers by 10,000,000. We
-  do this so that we don't have to use floating point numbers.
-
-  Leave NMEA parsing behind. Now you can simply ask the module for the datums you want!
-
-  Feel like supporting open source hardware?
-  Buy a board from SparkFun!
-  ZED-F9P RTK2: https://www.sparkfun.com/products/15136
-  NEO-M8P RTK: https://www.sparkfun.com/products/15005
-  SAM-M8Q: https://www.sparkfun.com/products/15106
-
-  Hardware Connections:
-  Plug a Qwiic cable into the GNSS and a BlackBoard
-  If you don't have a platform with a Qwiic connection use the SparkFun Qwiic Breadboard Jumper (https://www.sparkfun.com/products/14425)
-  Open the serial monitor at 115200 baud to see the output
-*/
-
-#include <Wire.h> //Needed for I2C to GNSS
-
-#include <SparkFun_u-blox_GNSS_Arduino_Library.h> //http://librarymanager/All#SparkFun_u-blox_GNSS
-SFE_UBLOX_GNSS myGNSS;
-
-long lastTime = 0; //Simple local timer. Limits amount if I2C traffic to u-blox module.
-
-void setup()
-{
-  Serial.begin(115200);
-  while (!Serial)
-    ; //Wait for user to open terminal
-  Serial.println("SparkFun u-blox Example");
-
-  Wire.begin();
-
-  if (myGNSS.begin() == false) //Connect to the u-blox module using Wire port
-  {
-    Serial.println(F("u-blox GNSS not detected at default I2C address. Please check wiring. Freezing."));
-    while (1)
-      ;
-  }
-
-  //myGNSS.enableDebugging(); // Uncomment this line to enable debug messages
-
-  myGNSS.setI2COutput(COM_TYPE_UBX); //Set the I2C port to output UBX only (turn off NMEA noise)
-  //myGNSS.saveConfiguration(); //Optional: Uncomment this line to save the current settings to flash and BBR
-
-  Serial.println("Power save example.");
-  Serial.println("1) Enable power saving");
-  Serial.println("2) Disable power saving");
-}
-
-void loop()
-{
-  if (Serial.available())
-  {
-    byte incoming = Serial.read();
-
-    if (incoming == '1')
-    {
-      // Put the GNSS into power save mode
-      // (If you want to disable power save mode, call myGNSS.powerSaveMode(false) instead)
-      // This will fail on the ZED (protocol version >= 27) as UBX-CFG-RXM is not supported
-      if (myGNSS.powerSaveMode()) // Defaults to true
-        Serial.println(F("Power Save Mode enabled."));
-      else
-        Serial.println(F("***!!! Power Save Mode FAILED !!!***"));
-    }
-    else if (incoming == '2')
-    {
-      //Go to normal power mode (not power saving mode)
-      if (myGNSS.powerSaveMode(false))
-        Serial.println(F("Power Save Mode disabled."));
-      else
-        Serial.println(F("***!!! Power Save Disable FAILED !!!***"));
-    }
-
-    // Read and print the new low power mode
-    uint8_t lowPowerMode = myGNSS.getPowerSaveMode();
-    if (lowPowerMode == 255)
-    {
-      Serial.println(F("***!!! getPowerSaveMode FAILED !!!***"));
-    }
-    else
-    {
-      Serial.print(F("The low power mode is: "));
-      Serial.print(lowPowerMode);
-      if (lowPowerMode == 0)
-      {
-        Serial.println(F(" (Continuous)"));
-      }
-      else if (lowPowerMode == 1)
-      {
-        Serial.println(F(" (Power Save)"));
-      }
-      else if (lowPowerMode == 4)
-      {
-        Serial.println(F(" (Continuous)"));
-      }
-      else
-      {
-        Serial.println(F(" (Unknown!)"));
-      }
-    }
-  }
-
-  //Query module every 10 seconds so it is easier to monitor the current draw
-  if (millis() - lastTime > 10000)
-  {
-    lastTime = millis(); //Update the timer
-
-    byte fixType = myGNSS.getFixType(); // Get the fix type
-    Serial.print(F("Fix: "));
-    Serial.print(fixType);
-    if (fixType == 0)
-      Serial.print(F("(No fix)"));
-    else if (fixType == 1)
-      Serial.print(F("(Dead reckoning)"));
-    else if (fixType == 2)
-      Serial.print(F("(2D)"));
-    else if (fixType == 3)
-      Serial.print(F("(3D)"));
-    else if (fixType == 4)
-      Serial.print(F("(GNSS + Dead reckoning)"));
-
-    long latitude = myGNSS.getLatitude();
-    Serial.print(F(" Lat: "));
-    Serial.print(latitude);
-
-    long longitude = myGNSS.getLongitude();
-    Serial.print(F(" Long: "));
-    Serial.print(longitude);
-    Serial.print(F(" (degrees * 10^-7)"));
-
-    long altitude = myGNSS.getAltitude();
-    Serial.print(F(" Alt: "));
-    Serial.print(altitude);
-    Serial.print(F(" (mm)"));
-
-    Serial.println();
-  }
-}
diff --git a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Example19_DynamicModel/Example19_DynamicModel.ino b/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Example19_DynamicModel/Example19_DynamicModel.ino
deleted file mode 100644
index 9915647..0000000
--- a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Example19_DynamicModel/Example19_DynamicModel.ino
+++ /dev/null
@@ -1,117 +0,0 @@
-/*
-  Set Dynamic Model
-  By: Paul Clark (PaulZC)
-  Date: April 22nd, 2020
-
-  Based extensively on Example3_GetPosition
-  By: Nathan Seidle
-  SparkFun Electronics
-  Date: January 3rd, 2019
-  License: MIT. See license file for more information but you can
-  basically do whatever you want with this code.
-
-  This example shows how to change the u-blox module's dynamic platform model and then
-  query its lat/long/altitude. We also turn off the NMEA output on the I2C port.
-  This decreases the amount of I2C traffic dramatically.
-
-  Possible values for the dynamic model are: PORTABLE, STATIONARY, PEDESTRIAN, AUTOMOTIVE,
-  SEA, AIRBORNE1g, AIRBORNE2g, AIRBORNE4g, WRIST, BIKE
-
-  Note: Long/lat are large numbers because they are * 10^7. To convert lat/long
-  to something google maps understands simply divide the numbers by 10,000,000. We
-  do this so that we don't have to use floating point numbers.
-
-  Leave NMEA parsing behind. Now you can simply ask the module for the datums you want!
-
-  Feel like supporting open source hardware?
-  Buy a board from SparkFun!
-  ZED-F9P RTK2: https://www.sparkfun.com/products/15136
-  NEO-M8P RTK: https://www.sparkfun.com/products/15005
-  SAM-M8Q: https://www.sparkfun.com/products/15106
-
-  Hardware Connections:
-  Plug a Qwiic cable into the GNSS and a BlackBoard
-  If you don't have a platform with a Qwiic connection use the SparkFun Qwiic Breadboard Jumper (https://www.sparkfun.com/products/14425)
-  Open the serial monitor at 115200 baud to see the output
-*/
-
-#include <Wire.h> //Needed for I2C to GNSS
-
-#include <SparkFun_u-blox_GNSS_Arduino_Library.h> //http://librarymanager/All#SparkFun_u-blox_GNSS
-SFE_UBLOX_GNSS myGNSS;
-
-long lastTime = 0; //Simple local timer. Limits amount if I2C traffic to u-blox module.
-
-void setup()
-{
-  Serial.begin(115200);
-  while (!Serial)
-    ; //Wait for user to open terminal
-  Serial.println(F("SparkFun u-blox Example"));
-
-  Wire.begin();
-
-  //myGNSS.enableDebugging(); // Uncomment this line to enable debug messages
-
-  if (myGNSS.begin() == false) //Connect to the u-blox module using Wire port
-  {
-    Serial.println(F("u-blox GNSS not detected at default I2C address. Please check wiring. Freezing."));
-    while (1)
-      ;
-  }
-
-  myGNSS.setI2COutput(COM_TYPE_UBX); //Set the I2C port to output UBX only (turn off NMEA noise)
-
-  // If we are going to change the dynamic platform model, let's do it here.
-  // Possible values are:
-  // PORTABLE, STATIONARY, PEDESTRIAN, AUTOMOTIVE, SEA, AIRBORNE1g, AIRBORNE2g, AIRBORNE4g, WRIST, BIKE
-
-  if (myGNSS.setDynamicModel(DYN_MODEL_PORTABLE) == false) // Set the dynamic model to PORTABLE
-  {
-    Serial.println(F("***!!! Warning: setDynamicModel failed !!!***"));
-  }
-  else
-  {
-    Serial.println(F("Dynamic platform model changed successfully!"));
-  }
-
-  // Let's read the new dynamic model to see if it worked
-  uint8_t newDynamicModel = myGNSS.getDynamicModel();
-  if (newDynamicModel == DYN_MODEL_UNKNOWN)
-  {
-    Serial.println(F("***!!! Warning: getDynamicModel failed !!!***"));
-  }
-  else
-  {
-    Serial.print(F("The new dynamic model is: "));
-    Serial.println(newDynamicModel);
-  }
-
-  //myGNSS.saveConfigSelective(VAL_CFG_SUBSEC_NAVCONF); //Uncomment this line to save only the NAV settings to flash and BBR
-}
-
-void loop()
-{
-  //Query module only every second. Doing it more often will just cause I2C traffic.
-  //The module only responds when a new position is available
-  if (millis() - lastTime > 1000)
-  {
-    lastTime = millis(); //Update the timer
-
-    long latitude = myGNSS.getLatitude();
-    Serial.print(F("Lat: "));
-    Serial.print(latitude);
-
-    long longitude = myGNSS.getLongitude();
-    Serial.print(F(" Long: "));
-    Serial.print(longitude);
-    Serial.print(F(" (degrees * 10^-7)"));
-
-    long altitude = myGNSS.getAltitude();
-    Serial.print(F(" Alt: "));
-    Serial.print(altitude);
-    Serial.print(F(" (mm)"));
-
-    Serial.println();
-  }
-}
diff --git a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Example1_BasicNMEARead/Example1_BasicNMEARead.ino b/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Example1_BasicNMEARead/Example1_BasicNMEARead.ino
deleted file mode 100644
index f2c2368..0000000
--- a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Example1_BasicNMEARead/Example1_BasicNMEARead.ino
+++ /dev/null
@@ -1,51 +0,0 @@
-/*
-  Read NMEA sentences over I2C using u-blox module SAM-M8Q, NEO-M8P, ZED-F9P, etc
-  By: Nathan Seidle
-  SparkFun Electronics
-  Date: August 22nd, 2018
-  License: MIT. See license file for more information but you can
-  basically do whatever you want with this code.
-
-  This example reads the NMEA setences from the u-blox module over I2c and outputs
-  them to the serial port
-  
-  Feel like supporting open source hardware?
-  Buy a board from SparkFun!
-  ZED-F9P RTK2: https://www.sparkfun.com/products/15136
-  NEO-M8P RTK: https://www.sparkfun.com/products/15005
-  SAM-M8Q: https://www.sparkfun.com/products/15106
-
-  Hardware Connections:
-  Plug a Qwiic cable into the GNSS and a BlackBoard
-  If you don't have a platform with a Qwiic connection use the SparkFun Qwiic Breadboard Jumper (https://www.sparkfun.com/products/14425)
-  Open the serial monitor at 115200 baud to see the output
-*/
-
-#include <Wire.h> //Needed for I2C to GNSS
-
-#include <SparkFun_u-blox_GNSS_Arduino_Library.h> //Click here to get the library: http://librarymanager/All#SparkFun_Ublox_GPS
-SFE_UBLOX_GNSS myGNSS;
-
-void setup()
-{
-  Serial.begin(115200);
-  Serial.println("SparkFun u-blox Example");
-
-  Wire.begin();
-
-  if (myGNSS.begin() == false)
-  {
-    Serial.println(F("u-blox GNSS not detected at default I2C address. Please check wiring. Freezing."));
-    while (1);
-  }
-
-  //This will pipe all NMEA sentences to the serial port so we can see them
-  myGNSS.setNMEAOutputPort(Serial);
-}
-
-void loop()
-{
-  myGNSS.checkUblox(); //See if new data is available. Process bytes as they come in.
-
-  delay(250); //Don't pound too hard on the I2C bus
-}
diff --git a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Example20_SendCustomCommand/Example20_SendCustomCommand.ino b/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Example20_SendCustomCommand/Example20_SendCustomCommand.ino
deleted file mode 100644
index 45c259b..0000000
--- a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Example20_SendCustomCommand/Example20_SendCustomCommand.ino
+++ /dev/null
@@ -1,166 +0,0 @@
-/*
-  Send Custom Command
-  By: Paul Clark (PaulZC)
-  Date: April 20th, 2020
-
-  License: MIT. See license file for more information but you can
-  basically do whatever you want with this code.
-
-  This example shows how you can create and send a custom UBX packet
-  using the SparkFun u-blox library.
-
-  Previously it was possible to create and send a custom packet
-  through the library but it would always appear to timeout as
-  some of the internal functions referred to the internal private
-  struct packetCfg.
-  The most recent version of the library allows sendCommand to
-  use a custom packet as if it were packetCfg and so:
-  - sendCommand will return a sfe_ublox_status_e enum as if
-    it had been called from within the library
-  - the custom packet will be updated with data returned by the module
-    (previously this was not possible from outside the library)
-
-  Feel like supporting open source hardware?
-  Buy a board from SparkFun!
-  ZED-F9P RTK2: https://www.sparkfun.com/products/15136
-  NEO-M8P RTK: https://www.sparkfun.com/products/15005
-  SAM-M8Q: https://www.sparkfun.com/products/15106
-
-  Hardware Connections:
-  Plug a Qwiic cable into the GNSS and a BlackBoard
-  If you don't have a platform with a Qwiic connection use the SparkFun Qwiic Breadboard Jumper (https://www.sparkfun.com/products/14425)
-  Open the serial monitor at 115200 baud to see the output
-*/
-
-#define NAV_RATE 5 // The new navigation rate in Hz (measurements per second)
-
-#include <Wire.h> //Needed for I2C to GNSS
-
-#include <SparkFun_u-blox_GNSS_Arduino_Library.h> //http://librarymanager/All#SparkFun_u-blox_GNSS
-SFE_UBLOX_GNSS myGNSS;
-
-void setup()
-{
-  Serial.begin(115200); // You may need to increase this for high navigation rates!
-  while (!Serial)
-    ; //Wait for user to open terminal
-  Serial.println("SparkFun u-blox Example");
-
-  Wire.begin();
-
-  //myGNSS.enableDebugging(); // Uncomment this line to enable debug messages
-
-  if (myGNSS.begin() == false) //Connect to the u-blox module using Wire port
-  {
-    Serial.println(F("u-blox GNSS not detected at default I2C address. Please check wiring. Freezing."));
-    while (1)
-      ;
-  }
-
-  myGNSS.setI2COutput(COM_TYPE_UBX); //Set the I2C port to output UBX only (turn off NMEA noise)
-
-  // Let's configure the module's navigation rate as if we were using setNavigationFrequency
-
-  // Let's create our custom packet
-  uint8_t customPayload[MAX_PAYLOAD_SIZE]; // This array holds the payload data bytes
-  // The next line creates and initialises the packet information which wraps around the payload
-  ubxPacket customCfg = {0, 0, 0, 0, 0, customPayload, 0, 0, SFE_UBLOX_PACKET_VALIDITY_NOT_DEFINED, SFE_UBLOX_PACKET_VALIDITY_NOT_DEFINED};
-
-  // The structure of ubxPacket is:
-  // uint8_t cls           : The message Class
-  // uint8_t id            : The message ID
-  // uint16_t len          : Length of the payload. Does not include cls, id, or checksum bytes
-  // uint16_t counter      : Keeps track of number of overall bytes received. Some responses are larger than 255 bytes.
-  // uint16_t startingSpot : The counter value needed to go past before we begin recording into payload array
-  // uint8_t *payload      : The payload
-  // uint8_t checksumA     : Given to us by the module. Checked against the rolling calculated A/B checksums.
-  // uint8_t checksumB
-  // sfe_ublox_packet_validity_e valid            : Goes from NOT_DEFINED to VALID or NOT_VALID when checksum is checked
-  // sfe_ublox_packet_validity_e classAndIDmatch  : Goes from NOT_DEFINED to VALID or NOT_VALID when the Class and ID match the requestedClass and requestedID
-
-  // sendCommand will return:
-  // SFE_UBLOX_STATUS_DATA_RECEIVED if the data we requested was read / polled successfully
-  // SFE_UBLOX_STATUS_DATA_SENT     if the data we sent was writted successfully (ACK'd)
-  // Other values indicate errors. Please see the sfe_ublox_status_e enum for further details.
-
-  // Referring to the u-blox M8 Receiver Description and Protocol Specification we see that
-  // the navigation rate is configured using the UBX-CFG-RATE message. So let's load our
-  // custom packet with the correct information so we can read (poll / get) the current settings.
-
-  customCfg.cls = UBX_CLASS_CFG; // This is the message Class
-  customCfg.id = UBX_CFG_RATE; // This is the message ID
-  customCfg.len = 0; // Setting the len (length) to zero let's us poll the current settings
-  customCfg.startingSpot = 0; // Always set the startingSpot to zero (unless you really know what you are doing)
-
-  // We also need to tell sendCommand how long it should wait for a reply
-  uint16_t maxWait = 250; // Wait for up to 250ms (Serial may need a lot longer e.g. 1100)
-
-  // Now let's read the current navigation rate. The results will be loaded into customCfg.
-  if (myGNSS.sendCommand(&customCfg, maxWait) != SFE_UBLOX_STATUS_DATA_RECEIVED) // We are expecting data and an ACK
-  {
-    Serial.println(F("sendCommand (poll / get) failed! Freezing..."));
-    while (1)
-      ;
-  }
-
-  // Referring to the message definition for UBX-CFG-RATE we see that the measurement rate
-  // is stored in payload bytes 0 and 1 as a uint16_t in LSB-first (little endian) format
-
-  uint16_t rate = (customPayload[1] << 8) | customPayload[0]; // Extract the current rate (ms)
-  float f_rate = 1000.0 / ((float)rate); // Convert the navigation rate to Hz (measurements per second)
-
-  // Print the current measurement rate
-  Serial.print(F("The current measurement rate is: "));
-  Serial.println(f_rate, 1);
-
-  // Let's change it
-  rate = 1000 / NAV_RATE; // Load the new value into rate
-  customPayload[0] = rate & 0xFF; // Store it in the payload
-  customPayload[1] = rate >> 8;
-
-  // Print the new measurement rate
-  Serial.print(F("The new measurement rate will be: "));
-  Serial.println(NAV_RATE);
-
-  // We don't need to update customCfg.len as it will have been set to 6
-  // when sendCommand read the data
-
-  // Now we write the custom packet back again to change the setting
-  if (myGNSS.sendCommand(&customCfg, maxWait) != SFE_UBLOX_STATUS_DATA_SENT) // This time we are only expecting an ACK
-  {
-    Serial.println(F("sendCommand (set) failed! Freezing."));
-    while (1)
-      ;
-  }
-  else
-  {
-    Serial.println(F("Navigation rate updated. Here we go..."));
-  }
-
-  myGNSS.setAutoPVT(true); // Enable AutoPVT. The module will generate measurements automatically without being polled.
-
-  //myGNSS.saveConfigSelective(VAL_CFG_SUBSEC_NAVCONF); //Uncomment this line to save only the NAV settings to flash and BBR
-}
-
-void loop()
-{
-  //Query the module as fast as possible
-    int32_t latitude = myGNSS.getLatitude();
-    Serial.print(F("Lat: "));
-    Serial.print(latitude);
-
-    int32_t longitude = myGNSS.getLongitude();
-    Serial.print(F(" Lon: "));
-    Serial.print(longitude);
-    Serial.print(F(" (degrees * 10^-7)"));
-
-    int32_t altitude = myGNSS.getAltitude();
-    Serial.print(F(" Alt: "));
-    Serial.print(altitude);
-    Serial.print(F(" (mm)"));
-    
-    uint16_t milliseconds = myGNSS.getMillisecond();
-    Serial.print(F(" Milliseconds: "));
-    Serial.print(altitude);
-    Serial.println();
-}
diff --git a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Example21_ModuleInfo/Example21_ModuleInfo.ino b/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Example21_ModuleInfo/Example21_ModuleInfo.ino
deleted file mode 100644
index 9349eca..0000000
--- a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Example21_ModuleInfo/Example21_ModuleInfo.ino
+++ /dev/null
@@ -1,183 +0,0 @@
-/*
-  Module Info - extracts and prints the full module information from UBX_MON_VER
-  using a custom command.
-  By: @mayopan
-  Date: May 9th, 2020
-
-  Based on:
-  Send Custom Command
-  By: Paul Clark (PaulZC)
-  Date: April 20th, 2020
-
-  License: MIT. See license file for more information but you can
-  basically do whatever you want with this code.
-
-  Previously it was possible to create and send a custom packet
-  through the library but it would always appear to timeout as
-  some of the internal functions referred to the internal private
-  struct packetCfg.
-  The most recent version of the library allows sendCommand to
-  use a custom packet as if it were packetCfg and so:
-  - sendCommand will return a sfe_ublox_status_e enum as if
-    it had been called from within the library
-  - the custom packet will be updated with data returned by the module
-    (previously this was not possible from outside the library)
-
-  Feel like supporting open source hardware?
-  Buy a board from SparkFun!
-  ZED-F9P RTK2: https://www.sparkfun.com/products/15136
-  NEO-M8P RTK: https://www.sparkfun.com/products/15005
-  SAM-M8Q: https://www.sparkfun.com/products/15106
-
-  Hardware Connections:
-  Plug a Qwiic cable into the GNSS and a BlackBoard
-  If you don't have a platform with a Qwiic connection use the SparkFun Qwiic Breadboard Jumper (https://www.sparkfun.com/products/14425)
-  Open the serial monitor at 115200 baud to see the output
-*/
-
-#include <Wire.h> //Needed for I2C to GNSS
-
-#define MAX_PAYLOAD_SIZE 384 // Override MAX_PAYLOAD_SIZE for getModuleInfo which can return up to 348 bytes
-
-#include <SparkFun_u-blox_GNSS_Arduino_Library.h> //http://librarymanager/All#SparkFun_u-blox_GNSS
-
-// Extend the class for getModuleInfo
-class SFE_UBLOX_GPS_ADD : public SFE_UBLOX_GNSS
-{
-public:
-    boolean getModuleInfo(uint16_t maxWait = 1100); //Queries module, texts
-
-    struct minfoStructure // Structure to hold the module info (uses 341 bytes of RAM)
-    {
-        char swVersion[30];
-        char hwVersion[10];
-        uint8_t extensionNo = 0;
-        char extension[10][30];
-    } minfo;
-};
-
-SFE_UBLOX_GPS_ADD myGNSS;
-
-void setup()
-{
-    Serial.begin(115200); // You may need to increase this for high navigation rates!
-    while (!Serial)
-        ; //Wait for user to open terminal
-    Serial.println(F("SparkFun u-blox Example"));
-
-    Wire.begin();
-
-    //myGNSS.enableDebugging(); // Uncomment this line to enable debug messages
-
-    if (myGNSS.begin() == false) //Connect to the u-blox module using Wire port
-    {
-        Serial.println(F("u-blox GNSS not detected at default I2C address. Please check wiring. Freezing."));
-        while (1)
-            ;
-    }
-
-    myGNSS.setI2COutput(COM_TYPE_UBX); //Set the I2C port to output UBX only (turn off NMEA noise)
-
-    Serial.print(F("Polling module info"));
-    if (myGNSS.getModuleInfo(1100) == false) // Try to get the module info
-    {
-        Serial.print(F("getModuleInfo failed! Freezing..."));
-        while (1)
-            ;
-    }
-
-    Serial.println();
-    Serial.println();
-    Serial.println(F("Module Info : "));
-    Serial.print(F("Soft version: "));
-    Serial.println(myGNSS.minfo.swVersion);
-    Serial.print(F("Hard version: "));
-    Serial.println(myGNSS.minfo.hwVersion);
-    Serial.print(F("Extensions:"));
-    Serial.println(myGNSS.minfo.extensionNo);
-    for (int i = 0; i < myGNSS.minfo.extensionNo; i++)
-    {
-        Serial.print("  ");
-        Serial.println(myGNSS.minfo.extension[i]);
-    }
-    Serial.println();
-    Serial.println(F("Done!"));
-}
-
-void loop()
-{
-}
-
-boolean SFE_UBLOX_GPS_ADD::getModuleInfo(uint16_t maxWait)
-{
-    myGNSS.minfo.hwVersion[0] = 0;
-    myGNSS.minfo.swVersion[0] = 0;
-    for (int i = 0; i < 10; i++)
-        myGNSS.minfo.extension[i][0] = 0;
-    myGNSS.minfo.extensionNo = 0;
-
-    // Let's create our custom packet
-    uint8_t customPayload[MAX_PAYLOAD_SIZE]; // This array holds the payload data bytes
-
-    // The next line creates and initialises the packet information which wraps around the payload
-    ubxPacket customCfg = {0, 0, 0, 0, 0, customPayload, 0, 0, SFE_UBLOX_PACKET_VALIDITY_NOT_DEFINED, SFE_UBLOX_PACKET_VALIDITY_NOT_DEFINED};
-
-    // The structure of ubxPacket is:
-    // uint8_t cls           : The message Class
-    // uint8_t id            : The message ID
-    // uint16_t len          : Length of the payload. Does not include cls, id, or checksum bytes
-    // uint16_t counter      : Keeps track of number of overall bytes received. Some responses are larger than 255 bytes.
-    // uint16_t startingSpot : The counter value needed to go past before we begin recording into payload array
-    // uint8_t *payload      : The payload
-    // uint8_t checksumA     : Given to us by the module. Checked against the rolling calculated A/B checksums.
-    // uint8_t checksumB
-    // sfe_ublox_packet_validity_e valid            : Goes from NOT_DEFINED to VALID or NOT_VALID when checksum is checked
-    // sfe_ublox_packet_validity_e classAndIDmatch  : Goes from NOT_DEFINED to VALID or NOT_VALID when the Class and ID match the requestedClass and requestedID
-
-    // sendCommand will return:
-    // SFE_UBLOX_STATUS_DATA_RECEIVED if the data we requested was read / polled successfully
-    // SFE_UBLOX_STATUS_DATA_SENT     if the data we sent was writted successfully (ACK'd)
-    // Other values indicate errors. Please see the sfe_ublox_status_e enum for further details.
-
-    // Referring to the u-blox M8 Receiver Description and Protocol Specification we see that
-    // the module information can be read using the UBX-MON-VER message. So let's load our
-    // custom packet with the correct information so we can read (poll / get) the module information.
-
-    customCfg.cls = UBX_CLASS_MON; // This is the message Class
-    customCfg.id = UBX_MON_VER;    // This is the message ID
-    customCfg.len = 0;             // Setting the len (length) to zero let's us poll the current settings
-    customCfg.startingSpot = 0;    // Always set the startingSpot to zero (unless you really know what you are doing)
-
-    // Now let's send the command. The module info is returned in customPayload
-
-    if (sendCommand(&customCfg, maxWait) != SFE_UBLOX_STATUS_DATA_RECEIVED)
-        return (false); //If command send fails then bail
-
-    // Now let's extract the module info from customPayload
-
-    uint16_t position = 0;
-    for (int i = 0; i < 30; i++)
-    {
-        minfo.swVersion[i] = customPayload[position];
-        position++;
-    }
-    for (int i = 0; i < 10; i++)
-    {
-        minfo.hwVersion[i] = customPayload[position];
-        position++;
-    }
-
-    while (customCfg.len >= position + 30)
-    {
-        for (int i = 0; i < 30; i++)
-        {
-            minfo.extension[minfo.extensionNo][i] = customPayload[position];
-            position++;
-        }
-        minfo.extensionNo++;
-        if (minfo.extensionNo > 9)
-            break;
-    }
-
-    return (true); //Success!
-}
diff --git a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Example22_PowerOff/Example22_PowerOff.ino b/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Example22_PowerOff/Example22_PowerOff.ino
deleted file mode 100644
index dd0f128..0000000
--- a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Example22_PowerOff/Example22_PowerOff.ino
+++ /dev/null
@@ -1,88 +0,0 @@
-/*
-  Powering off a ublox GNSS module
-  By: bjorn
-  unsurv.org
-  Date: July 20th, 2020
-  License: MIT. See license file for more information but you can
-  basically do whatever you want with this code.
-
-  This example shows you how to turn off the ublox module to lower the power consumption.
-  There are two functions: one just specifies a duration in milliseconds the other also specifies a pin on the GNSS device to wake it up with.
-  By driving a voltage from LOW to HIGH or HIGH to LOW on the chosen module pin you wake the device back up.
-  Note: Doing so on the INT0 pin when using the regular powerOff(durationInMs) function will wake the device anyway. (tested on SAM-M8Q)
-  Note: While powered off, you should not query the device for data or it might wake up. This can be used to wake the device but is not recommended.
-        Works best when also putting your microcontroller to sleep.
-
-  Feel like supporting open source hardware?
-  Buy a board from SparkFun!
-  ZED-F9P RTK2: https://www.sparkfun.com/products/15136
-  NEO-M8P RTK: https://www.sparkfun.com/products/15005
-  SAM-M8Q: https://www.sparkfun.com/products/15106
-
-  Hardware Connections:
-  Plug a Qwiic cable into the GNSS and a BlackBoard.
-  To force the device to wake up you need to connect to a pin (for example INT0) seperately on the module.
-  If you don't have a platform with a Qwiic connection use the SparkFun Qwiic Breadboard Jumper (https://www.sparkfun.com/products/14425)
-  Open the serial monitor at 115200 baud to see the output
-*/
-
-#include <SparkFun_u-blox_GNSS_Arduino_Library.h> //http://librarymanager/All#SparkFun_u-blox_GNSS
-SFE_UBLOX_GNSS myGNSS;
-
-// define a digital pin capable of driving HIGH and LOW
-#define WAKEUP_PIN 5
-
-// Possible GNSS interrupt pins for powerOffWithInterrupt are:
-// VAL_RXM_PMREQ_WAKEUPSOURCE_UARTRX  = uartrx
-// VAL_RXM_PMREQ_WAKEUPSOURCE_EXTINT0 = extint0 (default)
-// VAL_RXM_PMREQ_WAKEUPSOURCE_EXTINT1 = extint1
-// VAL_RXM_PMREQ_WAKEUPSOURCE_SPICS   = spics
-// These values can be or'd (|) together to enable interrupts on multiple pins
-
-void wakeUp() {
-
-  Serial.print("-- waking up module via pin " + String(WAKEUP_PIN));
-  Serial.println(" on your microcontroller --");
-
-  digitalWrite(WAKEUP_PIN, LOW);
-  delay(1000);
-  digitalWrite(WAKEUP_PIN, HIGH);
-  delay(1000);
-  digitalWrite(WAKEUP_PIN, LOW);
-}
-
-
-void setup() {
-
-  pinMode(WAKEUP_PIN, OUTPUT);
-  digitalWrite(WAKEUP_PIN, LOW);
-
-  Serial.begin(115200);
-  while (!Serial); //Wait for user to open terminal
-  Serial.println("SparkFun u-blox Example");
-
-  Wire.begin();
-
-  //myGNSS.enableDebugging(); // Enable debug messages
-
-  if (myGNSS.begin() == false) //Connect to the u-blox module using Wire port
-  {
-    Serial.println(F("u-blox GNSS not detected at default I2C address. Please check wiring. Freezing."));
-    while (1);
-  }
-
-  // Powering off for 20s, you should see the power consumption drop.
-  Serial.println("-- Powering off module for 20s --");
-
-  myGNSS.powerOff(20000);
-  //myGNSS.powerOffWithInterrupt(20000, VAL_RXM_PMREQ_WAKEUPSOURCE_EXTINT0);
-
-  delay(10000);
-
-  // After 10 seconds wake the device via the specified pin on your microcontroller and module.
-  wakeUp();
-}
-
-void loop() {
-  //Do nothing
-}
diff --git a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Example23_TimePulseParameters/Example23_TimePulse_BulletTime/Example23_TimePulse_BulletTime.ino b/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Example23_TimePulseParameters/Example23_TimePulse_BulletTime/Example23_TimePulse_BulletTime.ino
deleted file mode 100644
index c7b25fa..0000000
--- a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Example23_TimePulseParameters/Example23_TimePulse_BulletTime/Example23_TimePulse_BulletTime.ino
+++ /dev/null
@@ -1,120 +0,0 @@
-/*
-  Time Pulse Parameters - Bullet Time (https://en.wikipedia.org/wiki/Bullet_time)
-  By: Paul Clark (PaulZC)
-  Date: January 13th, 2021
-
-  License: MIT. See license file for more information but you can
-  basically do whatever you want with this code.
-
-  This example shows how to change the time pulse parameters and configure the TIMEPULSE (PPS)
-  pin to produce a pulse once per second but with an adjustable delay. You could use this to
-  trigger multiple cameras and replicate the "bullet time" effect.
-
-  The SparkFun GPS-RTK-SMA Breakout - ZED-F9P (Qwiic) (https://www.sparkfun.com/products/16481)
-  has solder pads which will let you connect an SMA connector to the TIMEPULSE signal. Need an
-  accurate timelapse camera shutter signal? This is the product for you!
-
-  Feel like supporting open source hardware?
-  Buy a board from SparkFun!
-  ZED-F9P RTK2: https://www.sparkfun.com/products/15136
-  NEO-M8P RTK: https://www.sparkfun.com/products/15005
-  SAM-M8Q: https://www.sparkfun.com/products/15106
-
-  Hardware Connections:
-  Plug a Qwiic cable into the GNSS and a BlackBoard
-  If you don't have a platform with a Qwiic connection use the SparkFun Qwiic Breadboard Jumper (https://www.sparkfun.com/products/14425)
-  Open the serial monitor at 115200 baud to see the output
-*/
-
-#include <Wire.h> //Needed for I2C to GNSS
-
-#include "SparkFun_u-blox_GNSS_Arduino_Library.h" //http://librarymanager/All#SparkFun_u-blox_GNSS
-SFE_UBLOX_GNSS myGNSS;
-
-void setup()
-{
-  Serial.begin(115200);
-  while (!Serial)
-    ; //Wait for user to open terminal
-  Serial.println(F("SparkFun u-blox Example"));
-
-  Wire.begin();
-
-  //myGNSS.enableDebugging(); // Uncomment this line to enable debug messages
-
-  if (myGNSS.begin() == false) //Connect to the u-blox module using Wire port
-  {
-    Serial.println(F("u-blox GNSS not detected at default I2C address. Please check wiring. Freezing."));
-    while (1)
-      ;
-  }
-
-  myGNSS.setI2COutput(COM_TYPE_UBX); //Set the I2C port to output UBX only (turn off NMEA noise)
-
-  // Create storage for the time pulse parameters
-  UBX_CFG_TP5_data_t timePulseParameters;
-
-  // Get the time pulse parameters
-  if (myGNSS.getTimePulseParameters(&timePulseParameters) == false)
-  {
-    Serial.println(F("getTimePulseParameters failed! Freezing..."));
-    while (1) ; // Do nothing more
-  }
-
-  // Print the CFG TP5 version
-  Serial.print(F("UBX_CFG_TP5 version: "));
-  Serial.println(timePulseParameters.version);
-
-  timePulseParameters.tpIdx = 0; // Select the TIMEPULSE pin
-  //timePulseParameters.tpIdx = 1; // Or we could select the TIMEPULSE2 pin instead, if the module has one
-
-  // We can configure the time pulse pin to produce a defined frequency or period
-  // Here is how to set the period:
-
-  // Let's say that we want our pulse-per-second to be as accurate as possible. So, let's tell the module
-  // to generate no signal while it is _locking_ to GNSS time. We want the signal to start only when the module is
-  // _locked_ to GNSS time.
-  timePulseParameters.freqPeriod = 0; // Set the frequency/period to zero
-  timePulseParameters.pulseLenRatio = 0; // Set the pulse ratio to zero
-
-  // When the module is _locked_ to GNSS time, make it generate a 0.1 second pulse once per second
-  timePulseParameters.freqPeriodLock = 1000000; // Set the period to 1,000,000 us
-  timePulseParameters.pulseLenRatioLock = 100000; // Set the pulse length to 0.1s (100,000 us)
-  timePulseParameters.flags.bits.polarity = 1; // Set the polarity to "1" (high for 0.1s, low for 0.9s, rising edge at top of second)
-
-  // We can use userConfigDelay to delay the pulse for each camera. The delay needs to be negative for this example.
-  // We can delay the pulse by +/- 2^31 nanoseconds (+/- 2.147 seconds)
-  //timePulseParameters.userConfigDelay = 0; // Camera 1: delay the pulse by 0ns
-  //timePulseParameters.userConfigDelay = -100000000; // Camera 2: delay the pulse by 0.1s (100,000,000 ns)
-  //timePulseParameters.userConfigDelay = -200000000; // Camera 3: delay the pulse by 0.2s (200,000,000 ns)
-  timePulseParameters.userConfigDelay = -300000000; // Camera 4: delay the pulse by 0.3s (300,000,000 ns)
-  //timePulseParameters.userConfigDelay = -400000000; // Camera 5: delay the pulse by 0.4s (400,000,000 ns)
-  //timePulseParameters.userConfigDelay = -500000000; // Camera 6: delay the pulse by 0.5s (500,000,000 ns)
-  //timePulseParameters.userConfigDelay = -600000000; // Camera 7: delay the pulse by 0.6s (600,000,000 ns)
-  //timePulseParameters.userConfigDelay = -700000000; // Camera 8: delay the pulse by 0.7s (700,000,000 ns)
-  //timePulseParameters.userConfigDelay = -800000000; // Camera 9: delay the pulse by 0.8s (800,000,000 ns)
-  //timePulseParameters.userConfigDelay = -900000000; // Camera 10: delay the pulse by 0.9s (900,000,000 ns)
-
-  timePulseParameters.flags.bits.active = 1; // Make sure the active flag is set to enable the time pulse. (Set to 0 to disable.)
-  timePulseParameters.flags.bits.lockedOtherSet = 1; // Tell the module to use freqPeriod while locking and freqPeriodLock when locked to GNSS time
-  timePulseParameters.flags.bits.isFreq = 0; // Tell the module that we want to set the period (not the frequency)
-  timePulseParameters.flags.bits.isLength = 1; // Tell the module that pulseLenRatio is a length (in us) - not a duty cycle
-
-  // Now set the time pulse parameters
-  if (myGNSS.setTimePulseParameters(&timePulseParameters) == false)
-  {
-    Serial.println(F("setTimePulseParameters failed!"));
-  }
-  else
-  {
-    Serial.println(F("Success!"));
-  }
-
-  // Finally, save the time pulse parameters in battery-backed memory so the pulse will automatically restart at power on
-  myGNSS.saveConfigSelective(VAL_CFG_SUBSEC_NAVCONF); // Save the configuration
-}
-
-void loop()
-{
-  // Nothing to do here
-}
diff --git a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Example23_TimePulseParameters/Example23_TimePulse_Frequency/Example23_TimePulse_Frequency.ino b/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Example23_TimePulseParameters/Example23_TimePulse_Frequency/Example23_TimePulse_Frequency.ino
deleted file mode 100644
index e8c775c..0000000
--- a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Example23_TimePulseParameters/Example23_TimePulse_Frequency/Example23_TimePulse_Frequency.ino
+++ /dev/null
@@ -1,101 +0,0 @@
-/*
-  Time Pulse Parameters - Frequency
-  By: Paul Clark (PaulZC)
-  Date: January 13th, 2021
-
-  License: MIT. See license file for more information but you can
-  basically do whatever you want with this code.
-
-  This example shows how to change the time pulse parameters and configure the TIMEPULSE (PPS)
-  pin to produce a 1kHz squarewave
-
-  The SparkFun GPS-RTK-SMA Breakout - ZED-F9P (Qwiic) (https://www.sparkfun.com/products/16481)
-  has solder pads which will let you connect an SMA connector to the TIMEPULSE signal. Need an
-  accurate frequency or clock source for your latest project? This is the product for you!
-
-  Feel like supporting open source hardware?
-  Buy a board from SparkFun!
-  ZED-F9P RTK2: https://www.sparkfun.com/products/15136
-  NEO-M8P RTK: https://www.sparkfun.com/products/15005
-  SAM-M8Q: https://www.sparkfun.com/products/15106
-
-  Hardware Connections:
-  Plug a Qwiic cable into the GNSS and a BlackBoard
-  If you don't have a platform with a Qwiic connection use the SparkFun Qwiic Breadboard Jumper (https://www.sparkfun.com/products/14425)
-  Open the serial monitor at 115200 baud to see the output
-*/
-
-#include <Wire.h> //Needed for I2C to GNSS
-
-#include "SparkFun_u-blox_GNSS_Arduino_Library.h" //http://librarymanager/All#SparkFun_u-blox_GNSS
-SFE_UBLOX_GNSS myGNSS;
-
-void setup()
-{
-  Serial.begin(115200);
-  while (!Serial)
-    ; //Wait for user to open terminal
-  Serial.println(F("SparkFun u-blox Example"));
-
-  Wire.begin();
-
-  //myGNSS.enableDebugging(); // Uncomment this line to enable debug messages
-
-  if (myGNSS.begin() == false) //Connect to the u-blox module using Wire port
-  {
-    Serial.println(F("u-blox GNSS not detected at default I2C address. Please check wiring. Freezing."));
-    while (1)
-      ;
-  }
-
-  myGNSS.setI2COutput(COM_TYPE_UBX); //Set the I2C port to output UBX only (turn off NMEA noise)
-
-  // Create storage for the time pulse parameters
-  UBX_CFG_TP5_data_t timePulseParameters;
-
-  // Get the time pulse parameters
-  if (myGNSS.getTimePulseParameters(&timePulseParameters) == false)
-  {
-    Serial.println(F("getTimePulseParameters failed! Freezing..."));
-    while (1) ; // Do nothing more
-  }
-
-  // Print the CFG TP5 version
-  Serial.print(F("UBX_CFG_TP5 version: "));
-  Serial.println(timePulseParameters.version);
-
-  timePulseParameters.tpIdx = 0; // Select the TIMEPULSE pin
-  //timePulseParameters.tpIdx = 1; // Or we could select the TIMEPULSE2 pin instead, if the module has one
-
-  // We can configure the time pulse pin to produce a defined frequency or period
-  // Here is how to set the frequency:
-
-  // While the module is _locking_ to GNSS time, make it generate 2kHz
-  timePulseParameters.freqPeriod = 2000; // Set the frequency/period to 2000Hz
-  timePulseParameters.pulseLenRatio = 0x55555555; // Set the pulse ratio to 1/3 * 2^32 to produce 33:67 mark:space
-
-  // When the module is _locked_ to GNSS time, make it generate 1kHz
-  timePulseParameters.freqPeriodLock = 1000; // Set the frequency/period to 1000Hz
-  timePulseParameters.pulseLenRatioLock = 0x80000000; // Set the pulse ratio to 1/2 * 2^32 to produce 50:50 mark:space
-
-  timePulseParameters.flags.bits.active = 1; // Make sure the active flag is set to enable the time pulse. (Set to 0 to disable.)
-  timePulseParameters.flags.bits.lockedOtherSet = 1; // Tell the module to use freqPeriod while locking and freqPeriodLock when locked to GNSS time
-  timePulseParameters.flags.bits.isFreq = 1; // Tell the module that we want to set the frequency (not the period)
-  timePulseParameters.flags.bits.isLength = 0; // Tell the module that pulseLenRatio is a ratio / duty cycle (* 2^-32) - not a length (in us)
-  timePulseParameters.flags.bits.polarity = 1; // Tell the module that we want the rising edge at the top of second. (Set to 0 for falling edge.)
-
-  // Now set the time pulse parameters
-  if (myGNSS.setTimePulseParameters(&timePulseParameters) == false)
-  {
-    Serial.println(F("setTimePulseParameters failed!"));
-  }
-  else
-  {
-    Serial.println(F("Success!"));
-  }
-}
-
-void loop()
-{
-  // Nothing to do here
-}
diff --git a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Example23_TimePulseParameters/Example23_TimePulse_Period/Example23_TimePulse_Period.ino b/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Example23_TimePulseParameters/Example23_TimePulse_Period/Example23_TimePulse_Period.ino
deleted file mode 100644
index 4a49ba2..0000000
--- a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Example23_TimePulseParameters/Example23_TimePulse_Period/Example23_TimePulse_Period.ino
+++ /dev/null
@@ -1,108 +0,0 @@
-/*
-  Time Pulse Parameters - Period
-  By: Paul Clark (PaulZC)
-  Date: January 13th, 2021
-
-  License: MIT. See license file for more information but you can
-  basically do whatever you want with this code.
-
-  This example shows how to change the time pulse parameters and configure the TIMEPULSE (PPS)
-  pin to produce a 1 second pulse every 30 seconds. What's really cool is that if you run this
-  example on two GNSS boards, the pulses are precisely synchronised!
-
-  The SparkFun GPS-RTK-SMA Breakout - ZED-F9P (Qwiic) (https://www.sparkfun.com/products/16481)
-  has solder pads which will let you connect an SMA connector to the TIMEPULSE signal. Need an
-  accurate timelapse camera shutter signal? This is the product for you!
-
-  Feel like supporting open source hardware?
-  Buy a board from SparkFun!
-  ZED-F9P RTK2: https://www.sparkfun.com/products/15136
-  NEO-M8P RTK: https://www.sparkfun.com/products/15005
-  SAM-M8Q: https://www.sparkfun.com/products/15106
-
-  Hardware Connections:
-  Plug a Qwiic cable into the GNSS and a BlackBoard
-  If you don't have a platform with a Qwiic connection use the SparkFun Qwiic Breadboard Jumper (https://www.sparkfun.com/products/14425)
-  Open the serial monitor at 115200 baud to see the output
-*/
-
-#include <Wire.h> //Needed for I2C to GNSS
-
-#include "SparkFun_u-blox_GNSS_Arduino_Library.h" //http://librarymanager/All#SparkFun_u-blox_GNSS
-SFE_UBLOX_GNSS myGNSS;
-
-void setup()
-{
-  Serial.begin(115200);
-  while (!Serial)
-    ; //Wait for user to open terminal
-  Serial.println(F("SparkFun u-blox Example"));
-
-  Wire.begin();
-
-  //myGNSS.enableDebugging(); // Uncomment this line to enable debug messages
-
-  if (myGNSS.begin() == false) //Connect to the u-blox module using Wire port
-  {
-    Serial.println(F("u-blox GNSS not detected at default I2C address. Please check wiring. Freezing."));
-    while (1)
-      ;
-  }
-
-  myGNSS.setI2COutput(COM_TYPE_UBX); //Set the I2C port to output UBX only (turn off NMEA noise)
-
-  // Create storage for the time pulse parameters
-  UBX_CFG_TP5_data_t timePulseParameters;
-
-  // Get the time pulse parameters
-  if (myGNSS.getTimePulseParameters(&timePulseParameters) == false)
-  {
-    Serial.println(F("getTimePulseParameters failed! Freezing..."));
-    while (1) ; // Do nothing more
-  }
-
-  // Print the CFG TP5 version
-  Serial.print(F("UBX_CFG_TP5 version: "));
-  Serial.println(timePulseParameters.version);
-
-  timePulseParameters.tpIdx = 0; // Select the TIMEPULSE pin
-  //timePulseParameters.tpIdx = 1; // Or we could select the TIMEPULSE2 pin instead, if the module has one
-
-  // We can configure the time pulse pin to produce a defined frequency or period
-  // Here is how to set the period:
-
-  // Let's say that we want our 1 pulse every 30 seconds to be as accurate as possible. So, let's tell the module
-  // to generate no signal while it is _locking_ to GNSS time. We want the signal to start only when the module is
-  // _locked_ to GNSS time.
-  timePulseParameters.freqPeriod = 0; // Set the frequency/period to zero
-  timePulseParameters.pulseLenRatio = 0; // Set the pulse ratio to zero
-
-  // When the module is _locked_ to GNSS time, make it generate a 1 second pulse every 30 seconds
-  // (Although the period can be a maximum of 2^32 microseconds (over one hour), the upper limit appears to be around 33 seconds)
-  timePulseParameters.freqPeriodLock = 30000000; // Set the period to 30,000,000 us
-  timePulseParameters.pulseLenRatioLock = 1000000; // Set the pulse length to 1,000,000 us
-
-  timePulseParameters.flags.bits.active = 1; // Make sure the active flag is set to enable the time pulse. (Set to 0 to disable.)
-  timePulseParameters.flags.bits.lockedOtherSet = 1; // Tell the module to use freqPeriod while locking and freqPeriodLock when locked to GNSS time
-  timePulseParameters.flags.bits.isFreq = 0; // Tell the module that we want to set the period (not the frequency)
-  timePulseParameters.flags.bits.isLength = 1; // Tell the module that pulseLenRatio is a length (in us) - not a duty cycle
-  timePulseParameters.flags.bits.polarity = 1; // Tell the module that we want the rising edge at the top of second. (Set to 0 for falling edge.)
-
-  // Now set the time pulse parameters
-  if (myGNSS.setTimePulseParameters(&timePulseParameters) == false)
-  {
-    Serial.println(F("setTimePulseParameters failed!"));
-  }
-  else
-  {
-    Serial.println(F("Success!"));
-  }
-
-  // Finally, save the time pulse parameters in battery-backed memory so the pulse will automatically restart at power on
-  myGNSS.saveConfigSelective(VAL_CFG_SUBSEC_NAVCONF); // Save the configuration
-}
-
-void loop()
-{
-  // Nothing to do here
-}
diff --git a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Example24_GetUnixEpochAndMicros/Example24_GetUnixEpochAndMicros.ino b/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Example24_GetUnixEpochAndMicros/Example24_GetUnixEpochAndMicros.ino
deleted file mode 100644
index 2ebdc2a..0000000
--- a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Example24_GetUnixEpochAndMicros/Example24_GetUnixEpochAndMicros.ino
+++ /dev/null
@@ -1,111 +0,0 @@
-/*
-  Getting Unix Epoch Time and micros using u-blox commands
-  By: UT2UH
-  Date: March 31th, 2021
-  License: MIT. See license file for more information but you can
-  basically do whatever you want with this code.
-
-  This example shows how to query a u-blox module for the current time and date as Unix Epoch uint32_t type to avoid time.h dependency.
-  We also turn off the NMEA output on the I2C port. This decreases the amount of I2C traffic dramatically.
-
-  Note: this example works best on modules like the ZED_F9P. Modules like the ZOE_M8Q do not support confirmedTime.
-
-  Leave NMEA parsing behind. Now you can simply ask the module for the datums you want!
-
-  Feel like supporting open source hardware?
-  Buy a board from SparkFun!
-  ZED-F9P RTK2: https://www.sparkfun.com/products/15136
-  NEO-M8P RTK: https://www.sparkfun.com/products/15005
-  SAM-M8Q: https://www.sparkfun.com/products/15106
-
-  Hardware Connections:
-  Plug a Qwiic cable into the GNSS and a BlackBoard
-  If you don't have a platform with a Qwiic connection use the SparkFun Qwiic Breadboard Jumper (https://www.sparkfun.com/products/14425)
-  Open the serial monitor at 115200 baud to see the output
-*/
-
-#include <Wire.h> //Needed for I2C to GNSS
-
-#include <SparkFun_u-blox_GNSS_Arduino_Library.h> //http://librarymanager/All#SparkFun_u-blox_GNSS
-SFE_UBLOX_GNSS myGNSS;
-
-
-long lastTime = 0; //Simple local timer. Limits amount if I2C traffic to u-blox module.
-  
-void setup()
-{
-  Serial.begin(115200);
-  while (!Serial)
-    ; //Wait for user to open terminal
-  Serial.println("SparkFun u-blox Example");
-
-  Wire.begin();
-  
-  if (myGNSS.begin() == false) //Connect to the u-blox module using Wire port
-  {
-    Serial.println(F("u-blox GNSS not detected at default I2C address. Please check wiring. Freezing."));
-    while (1)
-      ;
-  }
-
-  // Uncomment the next line if you need to completely reset your module
-  //myGNSS.factoryDefault(); delay(5000); // Reset everything and wait while the module restarts
-
-  myGNSS.setI2COutput(COM_TYPE_UBX); //Set the I2C port to output UBX only (turn off NMEA noise)
-  //myGNSS.saveConfiguration();        //Optional: Save the current settings to flash and BBR
-
-  Serial.println("Compare Unix Epoch given with reference one from https://www.epochconverter.com/");
-
-}
-
-void loop()
-{
-  //Query module only every second. Doing it more often will just cause I2C traffic.
-  //The module only responds when a new position is available
-  if (millis() - lastTime > 1000)
-  {
-    lastTime = millis(); //Update the timer
-
-    // getUnixEpoch marks the PVT data as stale so you will get Unix time and PVT time on alternate seconds
-
-    uint32_t us;  //microseconds returned by getUnixEpoch()
-    uint32_t epoch = myGNSS.getUnixEpoch();
-    Serial.print("Unix Epoch rounded: ");
-    Serial.print(epoch, DEC);    
-    epoch = myGNSS.getUnixEpoch(us);
-    Serial.print("  Exact Unix Epoch: ");
-    Serial.print(epoch, DEC);
-    Serial.print("  micros: ");
-    Serial.println(us, DEC);
-
-    Serial.print(myGNSS.getYear());
-    Serial.print("-");
-    Serial.print(myGNSS.getMonth());
-    Serial.print("-");
-    Serial.print(myGNSS.getDay());
-    Serial.print(" ");
-    Serial.print(myGNSS.getHour());
-    Serial.print(":");
-    Serial.print(myGNSS.getMinute());
-    Serial.print(":");
-    Serial.print(myGNSS.getSecond());
-    
-    Serial.print("  Time is ");
-    if (myGNSS.getTimeValid() == false)
-    {
-      Serial.print("not ");
-    }
-    Serial.print("valid ");
-    if (myGNSS.getConfirmedTime() == false)
-    {
-      Serial.print("but not ");
-    } else {
-      Serial.print("and ");
-    }
-    Serial.print("confirmed");
-
-    byte SIV = myGNSS.getSIV();
-    Serial.print(F("  SIV: "));
-    Serial.println(SIV);
-  }
-}
\ No newline at end of file
diff --git a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Example25_MeasurementAndNavigationRate/Example25_MeasurementAndNavigationRate.ino b/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Example25_MeasurementAndNavigationRate/Example25_MeasurementAndNavigationRate.ino
deleted file mode 100644
index c16f6ed..0000000
--- a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Example25_MeasurementAndNavigationRate/Example25_MeasurementAndNavigationRate.ino
+++ /dev/null
@@ -1,123 +0,0 @@
-/*
-  Demonstrate get/setMeasurementRate and get/setNavigationRate
-  By: Paul Clark
-  SparkFun Electronics
-  Date: March 30th, 2021
-  License: MIT. See license file for more information but you can
-  basically do whatever you want with this code.
-
-  This example shows how to slow down the measurement and navigation rates.
-  This should run on any GNSS module but has only been tested on the ZED_F9P and ZOE_M8Q.
-
-  Feel like supporting open source hardware?
-  Buy a board from SparkFun!
-  ZED-F9P RTK2: https://www.sparkfun.com/products/15136
-  NEO-M8P RTK: https://www.sparkfun.com/products/15005
-  SAM-M8Q: https://www.sparkfun.com/products/15106
-
-  Hardware Connections:
-  Plug a Qwiic cable into the GNSS and a BlackBoard
-  If you don't have a platform with a Qwiic connection use the SparkFun Qwiic Breadboard Jumper (https://www.sparkfun.com/products/14425)
-  Open the serial monitor at 115200 baud to see the output
-*/
-
-#include <Wire.h> //Needed for I2C to GNSS
-
-#include <SparkFun_u-blox_GNSS_Arduino_Library.h> //http://librarymanager/All#SparkFun_u-blox_GNSS
-SFE_UBLOX_GNSS myGNSS;
-
-unsigned long lastTime = 0; //Simple local timer. Used to calc the message interval.
-
-void setup()
-{
-  Serial.begin(115200);
-  while (!Serial); //Wait for user to open terminal
-  Serial.println("SparkFun u-blox Example");
-
-  Wire.begin();
-
-  //myGNSS.enableDebugging(); // Uncomment this line to enable helpful debug messages on Serial
-
-  if (myGNSS.begin() == false) //Connect to the u-blox module using Wire port
-  {
-    Serial.println(F("u-blox GNSS not detected at default I2C address. Please check wiring. Freezing."));
-    while (1);
-  }
-
-  // Uncomment the next line if you need to completely reset your module
-  //myGNSS.factoryDefault(); delay(5000); // Reset everything and wait while the module restarts
-
-  myGNSS.setI2COutput(COM_TYPE_UBX); //Set the I2C port to output UBX only (turn off NMEA noise)
-
-  // Begin by printing the current measurement rate and navigation rate
-
-  uint16_t rate = myGNSS.getMeasurementRate(); //Get the measurement rate of this module
-  Serial.print("Current measurement interval (ms): ");
-  Serial.println(rate);
-
-  rate = myGNSS.getNavigationRate(); //Get the navigation rate of this module
-  Serial.print("Current navigation ratio (cycles): ");
-  Serial.println(rate);
-
-  // The measurement rate is the elapsed time between GNSS measurements, which defines the rate
-  // e.g. 100 ms => 10 Hz, 1000 ms => 1 Hz, 10000 ms => 0.1 Hz.
-  // Let's set the measurement rate (interval) to 5 seconds = 5000 milliseconds
-  if (myGNSS.setMeasurementRate(5000) == false)
-  {
-    Serial.println(F("Could not set the measurement rate. Freezing."));
-    while (1);
-  }
-
-  // setMeasurementRate will set i2cPollingWait to a quarter of the interval
-  // Let's override that so we can poll the module more frequently and avoid timeouts
-  myGNSS.setI2CpollingWait(25); // Set i2cPollingWait to 25ms
-
-  // The navigation rate is the ratio between the number of measurements and the number of navigation solutions
-  // e.g. 5 means five measurements for every navigation solution. Maximum value is 127
-  // Let's set the navigation rate (ratio) to 12 to produce a solution every minute
-  if (myGNSS.setNavigationRate(12) == false)
-  {
-    Serial.println(F("Could not set the navigation rate. Freezing."));
-    while (1);
-  }
-
-  // Another trick we can use is to mark the CFG RATE data as stale so we can be sure we read fresh data
-  myGNSS.packetUBXCFGRATE->moduleQueried.moduleQueried.all = 0; // Mark all of the CFG RATE data as stale
-
-  // Read and print the updated measurement rate and navigation rate
-
-  rate = myGNSS.getMeasurementRate(); //Get the measurement rate of this module
-  Serial.print("New measurement interval (ms): ");
-  Serial.println(rate);
-
-  rate = myGNSS.getNavigationRate(); //Get the navigation rate of this module
-  Serial.print("New navigation ratio (cycles): ");
-  Serial.println(rate);
-
-  lastTime = millis();
-}
-
-void loop()
-{
-  // i2cPollingWait will prevent us from thrashing the I2C bus
-
-  if (myGNSS.getPVT()) //Check for new Position, Velocity, Time data. getPVT returns true if new data is available.
-  {    
-      long latitude = myGNSS.getLatitude();
-      Serial.print(F("Lat: "));
-      Serial.print(latitude);
-
-      long longitude = myGNSS.getLongitude();
-      Serial.print(F(" Long: "));
-      Serial.print(longitude);
-
-      //Calculate the interval since the last message
-      Serial.print(F(" Interval: "));
-      Serial.print(((float)(millis() - lastTime)) / 1000.0, 2);
-      Serial.print(F("s"));
-
-      Serial.println();
-
-      lastTime = millis(); //Update lastTime
-  }
-}
diff --git a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Example26_End/Example26_End.ino b/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Example26_End/Example26_End.ino
deleted file mode 100644
index 077ed90..0000000
--- a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Example26_End/Example26_End.ino
+++ /dev/null
@@ -1,91 +0,0 @@
-/*
-  Demonstrating how to use "end"
-  By: Paul Clark
-  SparkFun Electronics
-  Date: April 1st, 2021
-  License: MIT. See license file for more information but you can
-  basically do whatever you want with this code.
-
-  This example shows how to use the end function.
-  End will stop all automatic message processing and free (nearly) all used RAM.
-  The file buffer is deleted (if it exists).
-  
-  Feel like supporting open source hardware?
-  Buy a board from SparkFun!
-  ZED-F9P RTK2: https://www.sparkfun.com/products/15136
-  NEO-M8P RTK: https://www.sparkfun.com/products/15005
-  SAM-M8Q: https://www.sparkfun.com/products/15106
-
-  Hardware Connections:
-  Plug a Qwiic cable into the GNSS and a BlackBoard
-  If you don't have a platform with a Qwiic connection use the SparkFun Qwiic Breadboard Jumper (https://www.sparkfun.com/products/14425)
-  Open the serial monitor at 115200 baud to see the output
-*/
-
-#include <Wire.h> //Needed for I2C to GNSS
-
-#include <SparkFun_u-blox_GNSS_Arduino_Library.h> //http://librarymanager/All#SparkFun_u-blox_GNSS
-SFE_UBLOX_GNSS myGNSS;
-
-void setup()
-{
-  Serial.begin(115200);
-  while (!Serial); //Wait for user to open terminal
-  Serial.println("SparkFun u-blox Example");
-
-  Wire.begin();
-
-  //myGNSS.enableDebugging(); // Uncomment this line to enable helpful debug messages on Serial
-  
-  if (myGNSS.begin() == false) //Connect to the u-blox module using Wire port
-  {
-    Serial.println(F("u-blox GNSS not detected at default I2C address. Please check wiring. Freezing."));
-    while (1);
-  }
-
-  myGNSS.setI2COutput(COM_TYPE_UBX); //Set the I2C port to output UBX only (turn off NMEA noise)
-  //myGNSS.saveConfiguration(); //Optional: Save the current settings to flash and BBR
-
-  myGNSS.end(); // Call end now just because we can - it won't do much as we haven't used any automatic messages
-}
-
-void loop()
-{
-  // Allocate 128 bytes for file storage - this checks that issue #20 has been resolved
-  // Allocating only 128 bytes will let this code run on the ATmega328P
-  // If your processor has plenty of RAM, you can increase this to something useful like 16KB
-  myGNSS.setFileBufferSize(128);
-  
-  if (myGNSS.begin() == false) //Connect to the u-blox module using Wire port
-  {
-    Serial.println(F("u-blox GNSS not detected. Freezing."));
-    while (1);
-  }
-
-  Serial.print(F("The file buffer size is: "));
-  Serial.println(myGNSS.getFileBufferSize());    
-
-  // Request Position, Velocity, Time
-  // RAM will be allocated for PVT message processing
-  // getPVT will return true is fresh PVT data was received and processed
-  if (myGNSS.getPVT())
-  {
-    long latitude = myGNSS.getLatitude();
-    Serial.print(F("Lat: "));
-    Serial.print(latitude);
-
-    long longitude = myGNSS.getLongitude();
-    Serial.print(F(" Long: "));
-    Serial.print(longitude);
-    Serial.print(F(" (degrees * 10^-7)"));
-
-    long altitude = myGNSS.getAltitude();
-    Serial.print(F(" Alt: "));
-    Serial.print(altitude);
-    Serial.println(F(" (mm)"));
-  }
-
-  // Calling end will free the RAM allocated for file storage and PVT processing
-  // Calling end is optional. You can comment the next line if you want to.
-  myGNSS.end();
-}
diff --git a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Example27_MultipleRates/Example27_MultipleRates.ino b/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Example27_MultipleRates/Example27_MultipleRates.ino
deleted file mode 100644
index 057b493..0000000
--- a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Example27_MultipleRates/Example27_MultipleRates.ino
+++ /dev/null
@@ -1,106 +0,0 @@
-/*
-  Configuring the GNSS to produce multiple messages at different rates
-  By: Paul Clark
-  SparkFun Electronics
-  Date: April 1st, 2021
-  License: MIT. See license file for more information but you can
-  basically do whatever you want with this code.
-
-  This example shows how to configure the U-Blox GNSS to output multiple messages at different rates:
-  PVT is output every second;
-  POSECEF is output every five seconds;
-  VELNED is output every ten seconds.
-
-  Feel like supporting open source hardware?
-  Buy a board from SparkFun!
-  ZED-F9P RTK2: https://www.sparkfun.com/products/15136
-  NEO-M8P RTK: https://www.sparkfun.com/products/15005
-  SAM-M8Q: https://www.sparkfun.com/products/15106
-
-  Hardware Connections:
-  Plug a Qwiic cable into the GNSS and a BlackBoard
-  If you don't have a platform with a Qwiic connection use the SparkFun Qwiic Breadboard Jumper (https://www.sparkfun.com/products/14425)
-  Open the serial monitor at 115200 baud to see the output
-*/
-
-#include <Wire.h> //Needed for I2C to GNSS
-
-#include <SparkFun_u-blox_GNSS_Arduino_Library.h> //http://librarymanager/All#SparkFun_u-blox_GNSS
-SFE_UBLOX_GNSS myGNSS;
-
-void setup()
-{
-  Serial.begin(115200);
-  while (!Serial); //Wait for user to open terminal
-  Serial.println("SparkFun u-blox Example");
-
-  Wire.begin();
-
-  if (myGNSS.begin() == false) //Connect to the u-blox module using Wire port
-  {
-    Serial.println(F("u-blox GNSS not detected at default I2C address. Please check wiring. Freezing."));
-    while (1);
-  }
-
-  myGNSS.setI2COutput(COM_TYPE_UBX); //Set the I2C port to output UBX only (turn off NMEA noise)
-  myGNSS.setMeasurementRate(1000); //Produce a measurement every 1000ms
-  myGNSS.setNavigationRate(1); //Produce a navigation solution every measurement
-  
-  myGNSS.setAutoPVTrate(1); //Tell the GNSS to send the PVT solution every measurement
-  myGNSS.setAutoNAVPOSECEFrate(5); //Tell the GNSS to send each POSECEF solution every 5th measurement
-  myGNSS.setAutoNAVVELNEDrate(10); //Tell the GNSS to send each VELNED solution every 10th measurement
-  //myGNSS.saveConfiguration(); //Optional: Save the current settings to flash and BBR
-}
-
-void loop()
-{
-  // Calling getPVT returns true if there actually is a fresh navigation solution available.
-  if (myGNSS.getPVT())
-  {
-    long latitude = myGNSS.getLatitude();
-    Serial.print(F("Lat: "));
-    Serial.print(latitude);
-
-    long longitude = myGNSS.getLongitude();
-    Serial.print(F(" Long: "));
-    Serial.print(longitude);
-    Serial.print(F(" (degrees * 10^-7)"));
-
-    long altitude = myGNSS.getAltitude();
-    Serial.print(F(" Alt: "));
-    Serial.print(altitude);
-    Serial.println(F(" (mm)"));
-  }
-
-  // Calling getNAVPOSECEF returns true if there actually is a fresh position solution available.
-  if (myGNSS.getNAVPOSECEF())
-  {
-    Serial.print(F("ecefX: "));
-    Serial.print((float)myGNSS.packetUBXNAVPOSECEF->data.ecefX / 100.0, 2); // convert ecefX to m
-
-    Serial.print(F(" ecefY: "));
-    Serial.print((float)myGNSS.packetUBXNAVPOSECEF->data.ecefY / 100.0, 2); // convert ecefY to m
-
-    Serial.print(F(" ecefZ: "));
-    Serial.print((float)myGNSS.packetUBXNAVPOSECEF->data.ecefZ / 100.0, 2); // convert ecefY to m
-    Serial.println(F(" (m)"));
-
-    myGNSS.flushNAVPOSECEF(); //Mark all the data as read/stale so we get fresh data next time
-  }
-
-  // Calling getNAVVELNED returns true if there actually is fresh velocity data available.
-  if (myGNSS.getNAVVELNED())
-  {
-    Serial.print(F("velN: "));
-    Serial.print((float)myGNSS.packetUBXNAVVELNED->data.velN / 100.0, 2); // convert velN to m/s
-
-    Serial.print(F(" velE: "));
-    Serial.print((float)myGNSS.packetUBXNAVVELNED->data.velE / 100.0, 2); // convert velE to m/s
-
-    Serial.print(F(" velD: "));
-    Serial.print((float)myGNSS.packetUBXNAVVELNED->data.velD / 100.0, 2); // convert velD to m/s
-    Serial.println(F(" (m/s)"));
-
-    myGNSS.flushNAVVELNED(); //Mark all the data as read/stale so we get fresh data next time
-  }
-}
diff --git a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Example2_NMEAParsing/Example2_NMEAParsing.ino b/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Example2_NMEAParsing/Example2_NMEAParsing.ino
deleted file mode 100644
index 35c2001..0000000
--- a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Example2_NMEAParsing/Example2_NMEAParsing.ino
+++ /dev/null
@@ -1,83 +0,0 @@
-/*
-  Read NMEA sentences over I2C using u-blox module SAM-M8Q, NEO-M8P, etc
-  By: Nathan Seidle
-  SparkFun Electronics
-  Date: August 22nd, 2018
-  License: MIT. See license file for more information but you can
-  basically do whatever you want with this code.
-
-  This example reads the NMEA characters over I2C and pipes them to MicroNMEA
-  This example will output your current long/lat and satellites in view
- 
-  Feel like supporting open source hardware?
-  Buy a board from SparkFun!
-  ZED-F9P RTK2: https://www.sparkfun.com/products/15136
-  NEO-M8P RTK: https://www.sparkfun.com/products/15005
-  SAM-M8Q: https://www.sparkfun.com/products/15106
-
-  For more MicroNMEA info see https://github.com/stevemarple/MicroNMEA
-
-  Hardware Connections:
-  Plug a Qwiic cable into the GNSS and a BlackBoard
-  If you don't have a platform with a Qwiic connection use the SparkFun Qwiic Breadboard Jumper (https://www.sparkfun.com/products/14425)
-  Open the serial monitor at 115200 baud to see the output
-  Go outside! Wait ~25 seconds and you should see your lat/long
-*/
-
-#include <Wire.h> //Needed for I2C to GNSS
-
-#include <SparkFun_u-blox_GNSS_Arduino_Library.h> //http://librarymanager/All#SparkFun_u-blox_GNSS
-SFE_UBLOX_GNSS myGNSS;
-
-#include <MicroNMEA.h> //http://librarymanager/All#MicroNMEA
-char nmeaBuffer[100];
-MicroNMEA nmea(nmeaBuffer, sizeof(nmeaBuffer));
-
-void setup()
-{
-  Serial.begin(115200);
-  Serial.println("SparkFun u-blox Example");
-
-  Wire.begin();
-
-  if (myGNSS.begin() == false)
-  {
-    Serial.println(F("u-blox GNSS not detected at default I2C address. Please check wiring. Freezing."));
-    while (1);
-  }
-}
-
-void loop()
-{
-  myGNSS.checkUblox(); //See if new data is available. Process bytes as they come in.
-
-  if(nmea.isValid() == true)
-  {
-    long latitude_mdeg = nmea.getLatitude();
-    long longitude_mdeg = nmea.getLongitude();
-
-    Serial.print("Latitude (deg): ");
-    Serial.println(latitude_mdeg / 1000000., 6);
-    Serial.print("Longitude (deg): ");
-    Serial.println(longitude_mdeg / 1000000., 6);
-  }
-  else
-  {
-    Serial.print("No Fix - ");
-    Serial.print("Num. satellites: ");
-    Serial.println(nmea.getNumSatellites());
-  }
-
-  delay(250); //Don't pound too hard on the I2C bus
-}
-
-//This function gets called from the SparkFun u-blox Arduino Library
-//As each NMEA character comes in you can specify what to do with it
-//Useful for passing to other libraries like tinyGPS, MicroNMEA, or even
-//a buffer, radio, etc.
-void SFE_UBLOX_GNSS::processNMEA(char incoming)
-{
-  //Take the incoming char from the u-blox I2C port and pass it on to the MicroNMEA lib
-  //for sentence cracking
-  nmea.process(incoming);
-}
diff --git a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Example3_GetPosition/Example3_GetPosition.ino b/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Example3_GetPosition/Example3_GetPosition.ino
deleted file mode 100644
index be605f3..0000000
--- a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Example3_GetPosition/Example3_GetPosition.ino
+++ /dev/null
@@ -1,84 +0,0 @@
-/*
-  Reading lat and long via UBX binary commands - no more NMEA parsing!
-  By: Nathan Seidle
-  SparkFun Electronics
-  Date: January 3rd, 2019
-  License: MIT. See license file for more information but you can
-  basically do whatever you want with this code.
-
-  This example shows how to query a u-blox module for its lat/long/altitude. We also
-  turn off the NMEA output on the I2C port. This decreases the amount of I2C traffic 
-  dramatically.
-
-  Note: Long/lat are large numbers because they are * 10^7. To convert lat/long
-  to something google maps understands simply divide the numbers by 10,000,000. We 
-  do this so that we don't have to use floating point numbers.
-
-  Leave NMEA parsing behind. Now you can simply ask the module for the datums you want!
-
-  Feel like supporting open source hardware?
-  Buy a board from SparkFun!
-  ZED-F9P RTK2: https://www.sparkfun.com/products/15136
-  NEO-M8P RTK: https://www.sparkfun.com/products/15005
-  SAM-M8Q: https://www.sparkfun.com/products/15106
-
-  Hardware Connections:
-  Plug a Qwiic cable into the GNSS and a BlackBoard
-  If you don't have a platform with a Qwiic connection use the SparkFun Qwiic Breadboard Jumper (https://www.sparkfun.com/products/14425)
-  Open the serial monitor at 115200 baud to see the output
-*/
-
-#include <Wire.h> //Needed for I2C to GNSS
-
-#include <SparkFun_u-blox_GNSS_Arduino_Library.h> //http://librarymanager/All#SparkFun_u-blox_GNSS
-SFE_UBLOX_GNSS myGNSS;
-
-long lastTime = 0; //Simple local timer. Limits amount if I2C traffic to u-blox module.
-
-void setup()
-{
-  Serial.begin(115200);
-  while (!Serial); //Wait for user to open terminal
-  Serial.println("SparkFun u-blox Example");
-
-  Wire.begin();
-
-  if (myGNSS.begin() == false) //Connect to the u-blox module using Wire port
-  {
-    Serial.println(F("u-blox GNSS not detected at default I2C address. Please check wiring. Freezing."));
-    while (1);
-  }
-
-  myGNSS.setI2COutput(COM_TYPE_UBX); //Set the I2C port to output UBX only (turn off NMEA noise)
-  myGNSS.saveConfigSelective(VAL_CFG_SUBSEC_IOPORT); //Save (only) the communications port settings to flash and BBR
-}
-
-void loop()
-{
-  //Query module only every second. Doing it more often will just cause I2C traffic.
-  //The module only responds when a new position is available
-  if (millis() - lastTime > 1000)
-  {
-    lastTime = millis(); //Update the timer
-    
-    long latitude = myGNSS.getLatitude();
-    Serial.print(F("Lat: "));
-    Serial.print(latitude);
-
-    long longitude = myGNSS.getLongitude();
-    Serial.print(F(" Long: "));
-    Serial.print(longitude);
-    Serial.print(F(" (degrees * 10^-7)"));
-
-    long altitude = myGNSS.getAltitude();
-    Serial.print(F(" Alt: "));
-    Serial.print(altitude);
-    Serial.print(F(" (mm)"));
-
-    byte SIV = myGNSS.getSIV();
-    Serial.print(F(" SIV: "));
-    Serial.print(SIV);
-
-    Serial.println();
-  }
-}
diff --git a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Example4_FixType/Example4_FixType.ino b/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Example4_FixType/Example4_FixType.ino
deleted file mode 100644
index 5ddfc01..0000000
--- a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Example4_FixType/Example4_FixType.ino
+++ /dev/null
@@ -1,96 +0,0 @@
-/*
-  Get fix type and RTK fix type if available
-  By: Nathan Seidle
-  SparkFun Electronics
-  Date: January 3rd, 2019
-  License: MIT. See license file for more information but you can
-  basically do whatever you want with this code.
-
-  This example shows how to query a u-blox module for fix type and RTK fix type.
-  The fix type is as follows:
-    0 = no fix
-    1 = dead reckoning (requires external sensors)
-    2 = 2D (not quite enough satellites in view)
-    3 = 3D (the standard fix)
-    4 = GNSS + dead reckoning (requires external sensors)
-    5 = Time fix only
-
-  Additionally, if we are doing RTK, we can figure out if we have a floating 
-  RTK solution or if we have been able to resolve a fixec solution (better precision).
-
-  Leave NMEA parsing behind. Now you can simply ask the module for the datums you want!
-
-  Feel like supporting open source hardware?
-  Buy a board from SparkFun!
-  ZED-F9P RTK2: https://www.sparkfun.com/products/15136
-  NEO-M8P RTK: https://www.sparkfun.com/products/15005
-  SAM-M8Q: https://www.sparkfun.com/products/15106
-
-  Hardware Connections:
-  Plug a Qwiic cable into the GNSS and a BlackBoard
-  If you don't have a platform with a Qwiic connection use the SparkFun Qwiic Breadboard Jumper (https://www.sparkfun.com/products/14425)
-  Open the serial monitor at 115200 baud to see the output
-*/
-
-#include <Wire.h> //Needed for I2C to GNSS
-
-#include <SparkFun_u-blox_GNSS_Arduino_Library.h> //http://librarymanager/All#SparkFun_u-blox_GNSS
-SFE_UBLOX_GNSS myGNSS;
-
-long lastTime = 0; //Simple local timer. Limits amount if I2C traffic to u-blox module.
-
-void setup()
-{
-  Serial.begin(115200);
-  while (!Serial); //Wait for user to open terminal
-  Serial.println("SparkFun u-blox Example");
-
-  Wire.begin();
-  //Wire.setClock(400000); //Optional. Increase I2C clock speed to 400kHz.
-
-  if (myGNSS.begin() == false) //Connect to the u-blox module using Wire port
-  {
-    Serial.println(F("u-blox GNSS not detected at default I2C address. Please check wiring. Freezing."));
-    while (1);
-  }
-}
-
-void loop()
-{
-  //Query module only every second. Doing it more often will just cause I2C traffic.
-  if (millis() - lastTime > 1000)
-  {
-    lastTime = millis(); //Update the timer
-
-    long latitude = myGNSS.getLatitude();
-    Serial.print(F("Lat: "));
-    Serial.print(latitude);
-
-    long longitude = myGNSS.getLongitude();
-    Serial.print(F(" Long: "));
-    Serial.print(longitude);
-
-    long altitude = myGNSS.getAltitude();
-    Serial.print(F(" Alt: "));
-    Serial.print(altitude);
-
-    byte fixType = myGNSS.getFixType();
-    Serial.print(F(" Fix: "));
-    if(fixType == 0) Serial.print(F("No fix"));
-    else if(fixType == 1) Serial.print(F("Dead reckoning"));
-    else if(fixType == 2) Serial.print(F("2D"));
-    else if(fixType == 3) Serial.print(F("3D"));
-    else if(fixType == 4) Serial.print(F("GNSS + Dead reckoning"));
-    else if(fixType == 5) Serial.print(F("Time only"));
-
-    byte RTK = myGNSS.getCarrierSolutionType();
-    Serial.print(" RTK: ");
-    Serial.print(RTK);
-    if (RTK == 0) Serial.print(F(" (No solution)"));
-    else if (RTK == 1) Serial.print(F(" (High precision floating fix)"));
-    else if (RTK == 2) Serial.print(F(" (High precision fix)"));
-
-    Serial.println();
-  }
-
-}
diff --git a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Example5_SpeedHeadingPrecision/Example5_SpeedHeadingPrecision.ino b/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Example5_SpeedHeadingPrecision/Example5_SpeedHeadingPrecision.ino
deleted file mode 100644
index 427f726..0000000
--- a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Example5_SpeedHeadingPrecision/Example5_SpeedHeadingPrecision.ino
+++ /dev/null
@@ -1,83 +0,0 @@
-/*
-  Get Speed/Heading and dilution of precision via UBX binary commands - no more NMEA parsing!
-  By: Nathan Seidle
-  SparkFun Electronics
-  Date: January 3rd, 2019
-  License: MIT. See license file for more information but you can
-  basically do whatever you want with this code.
-
-  This example shows how to query a u-blox module for its lat/long/altitude.
-
-  Note: Long/lat are large numbers because they are * 10^7. To convert lat/long
-  to something google maps understands simply divide the numbers by 1,000,000. We
-  do this so that we don't have to use floating point numbers.
-
-  Leave NMEA parsing behind. Now you can simply ask the module for the datums you want!
-
-  Feel like supporting open source hardware?
-  Buy a board from SparkFun!
-  ZED-F9P RTK2: https://www.sparkfun.com/products/15136
-  NEO-M8P RTK: https://www.sparkfun.com/products/15005
-  SAM-M8Q: https://www.sparkfun.com/products/15106
-
-  Hardware Connections:
-  Plug a Qwiic cable into the GNSS and a BlackBoard
-  If you don't have a platform with a Qwiic connection use the SparkFun Qwiic Breadboard Jumper (https://www.sparkfun.com/products/14425)
-  Open the serial monitor at 115200 baud to see the output
-*/
-
-#include <Wire.h> //Needed for I2C to GNSS
-
-#include <SparkFun_u-blox_GNSS_Arduino_Library.h> //http://librarymanager/All#SparkFun_u-blox_GNSS
-SFE_UBLOX_GNSS myGNSS;
-
-long lastTime = 0; //Simple local timer. Limits amount if I2C traffic to u-blox module.
-
-void setup()
-{
-  Serial.begin(115200);
-  while (!Serial); //Wait for user to open terminal
-  Serial.println("SparkFun u-blox Example");
-
-  Wire.begin();
-
-  if (myGNSS.begin() == false) //Connect to the u-blox module using Wire port
-  {
-    Serial.println(F("u-blox GNSS not detected at default I2C address. Please check wiring. Freezing."));
-    while (1);
-  }
-}
-
-void loop()
-{
-  //Query module only every second. Doing it more often will just cause I2C traffic.
-  //The module only responds when a new position is available
-  if (millis() - lastTime > 1000)
-  {
-    lastTime = millis(); //Update the timer
-    
-    long latitude = myGNSS.getLatitude();
-    Serial.print(F("Lat: "));
-    Serial.print(latitude);
-
-    long longitude = myGNSS.getLongitude();
-    Serial.print(F(" Long: "));
-    Serial.print(longitude);
-
-    long speed = myGNSS.getGroundSpeed();
-    Serial.print(F(" Speed: "));
-    Serial.print(speed);
-    Serial.print(F(" (mm/s)"));
-
-    long heading = myGNSS.getHeading();
-    Serial.print(F(" Heading: "));
-    Serial.print(heading);
-    Serial.print(F(" (degrees * 10^-5)"));
-
-    int pDOP = myGNSS.getPDOP();
-    Serial.print(F(" pDOP: "));
-    Serial.print(pDOP / 100.0, 2); // Convert pDOP scaling from 0.01 to 1
-
-    Serial.println();
-  }
-}
diff --git a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Example6_EnableNMEASentences/Example6_EnableNMEASentences.ino b/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Example6_EnableNMEASentences/Example6_EnableNMEASentences.ino
deleted file mode 100644
index ca1b462..0000000
--- a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Example6_EnableNMEASentences/Example6_EnableNMEASentences.ino
+++ /dev/null
@@ -1,79 +0,0 @@
-/*
-  Turn on/off various NMEA sentences.
-  By: Nathan Seidle
-  SparkFun Electronics
-  Date: January 3rd, 2019
-  License: MIT. See license file for more information but you can
-  basically do whatever you want with this code.
-
-  This example shows how to turn on/off the NMEA sentences being output
-  over UART1. We use the I2C interface on the u-blox module for configuration
-  but you won't see any output from this sketch. You'll need to hook up
-  a Serial Basic or other USB to Serial device to UART1 on your u-blox module
-  to see the output.
-
-  This example turns off all sentences except for the GPGGA and GPVTG sentences.
-
-  Feel like supporting open source hardware?
-  Buy a board from SparkFun!
-  ZED-F9P RTK2: https://www.sparkfun.com/products/15136
-  NEO-M8P RTK: https://www.sparkfun.com/products/15005
-  SAM-M8Q: https://www.sparkfun.com/products/15106
-
-  Hardware Connections:
-  Plug a Qwiic cable into the GNSS and a RedBoard
-  If you don't have a platform with a Qwiic connection use the SparkFun Qwiic Breadboard Jumper (https://www.sparkfun.com/products/14425)
-  Open the serial monitor at 115200 baud to see the output
-  Hookup a Serial Basic (https://www.sparkfun.com/products/15096) to UART1 on the u-blox module. Open a terminal at 57600bps
-  and see GPGGA and GPVTG sentences.
-*/
-#include <Wire.h> //Needed for I2C to GNSS
-
-#include <SparkFun_u-blox_GNSS_Arduino_Library.h> //Click here to get the library: http://librarymanager/All#SparkFun_u-blox_GNSS
-SFE_UBLOX_GNSS myGNSS;
-
-unsigned long lastGNSSsend = 0;
-
-void setup()
-{
-  Serial.begin(115200); // Serial debug output over USB visible from Arduino IDE
-  Serial.println("Example showing how to enable/disable certain NMEA sentences");
-
-  Wire.begin();
-
-  if (myGNSS.begin() == false)
-  {
-    Serial.println(F("u-blox GNSS not detected at default I2C address. Please check wiring. Freezing."));
-    while (1)
-      ;
-  }
-
-  //Disable or enable various NMEA sentences over the UART1 interface
-  myGNSS.disableNMEAMessage(UBX_NMEA_GLL, COM_PORT_UART1); //Several of these are on by default on ublox board so let's disable them
-  myGNSS.disableNMEAMessage(UBX_NMEA_GSA, COM_PORT_UART1);
-  myGNSS.disableNMEAMessage(UBX_NMEA_GSV, COM_PORT_UART1);
-  myGNSS.disableNMEAMessage(UBX_NMEA_RMC, COM_PORT_UART1);
-  myGNSS.enableNMEAMessage(UBX_NMEA_GGA, COM_PORT_UART1); //Only leaving GGA & VTG enabled at current navigation rate
-  myGNSS.enableNMEAMessage(UBX_NMEA_VTG, COM_PORT_UART1);
-
-  //Here's the advanced configure method
-  //Some of the other examples in this library enable the PVT message so let's disable it
-  myGNSS.configureMessage(UBX_CLASS_NAV, UBX_NAV_PVT, COM_PORT_UART1, 0); //Message Class, ID, and port we want to configure, sendRate of 0 (disable).
-
-  myGNSS.setUART1Output(COM_TYPE_NMEA); //Turn off UBX and RTCM sentences on the UART1 interface
-
-  myGNSS.setSerialRate(57600); //Set UART1 to 57600bps.
-
-  //myGNSS.saveConfiguration(); //Optional: Save these settings to NVM
-
-  Serial.println(F("Messages configured. NMEA now being output over the UART1 port on the u-blox module at 57600bps."));
-}
-
-void loop()
-{
-  if (millis() - lastGNSSsend > 200)
-  {
-    myGNSS.checkUblox(); //See if new data is available, but we don't want to get NMEA here. Go check UART1.
-    lastGNSSsend = millis();
-  }
-}
diff --git a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Example7_OutputRate/Example7_OutputRate.ino b/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Example7_OutputRate/Example7_OutputRate.ino
deleted file mode 100644
index 18efc58..0000000
--- a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Example7_OutputRate/Example7_OutputRate.ino
+++ /dev/null
@@ -1,94 +0,0 @@
-/*
-  Set update rate to 10Hz
-  By: Nathan Seidle
-  SparkFun Electronics
-  Date: January 3rd, 2019
-  License: MIT. See license file for more information but you can
-  basically do whatever you want with this code.
-
-  This example shows how to increase the output of the module from 1Hz to 4Hz.
-  The max output rate various from model to model. RTFM! But you cannot do harm
-  to the module.
-
-  We also disable NMEA output on the I2C bus and use only UBX. This dramatically 
-  decreases the amount of data that needs to be transmitted.
-
-  Leave NMEA parsing behind. Now you can simply ask the module for the datums you want!
-
-  Feel like supporting open source hardware?
-  Buy a board from SparkFun!
-  ZED-F9P RTK2: https://www.sparkfun.com/products/15136
-  NEO-M8P RTK: https://www.sparkfun.com/products/15005
-  SAM-M8Q: https://www.sparkfun.com/products/15106
-
-  Hardware Connections:
-  Plug a Qwiic cable into the GNSS and a BlackBoard
-  If you don't have a platform with a Qwiic connection use the SparkFun Qwiic Breadboard Jumper (https://www.sparkfun.com/products/14425)
-  Open the serial monitor at 115200 baud to see the output
-*/
-
-#include <Wire.h> //Needed for I2C to GNSS
-
-#include <SparkFun_u-blox_GNSS_Arduino_Library.h> //http://librarymanager/All#SparkFun_u-blox_GNSS
-SFE_UBLOX_GNSS myGNSS;
-
-unsigned long lastTime = 0; //Simple local timer. Limits amount if I2C traffic to u-blox module.
-unsigned long startTime = 0; //Used to calc the actual update rate.
-unsigned long updateCount = 0; //Used to calc the actual update rate.
-
-void setup()
-{
-  Serial.begin(115200);
-  while (!Serial); //Wait for user to open terminal
-  Serial.println("SparkFun u-blox Example");
-
-  Wire.begin();
-
-  // Increase I2C clock speed to 400kHz to cope with the high navigation rate
-  // (We normally recommend running the bus at 100kHz)
-  Wire.setClock(400000);
-  
-  if (myGNSS.begin() == false) //Connect to the u-blox module using Wire port
-  {
-    Serial.println(F("u-blox GNSS not detected at default I2C address. Please check wiring. Freezing."));
-    while (1);
-  }
-
-  myGNSS.setI2COutput(COM_TYPE_UBX); //Set the I2C port to output UBX only (turn off NMEA noise)
-  myGNSS.setNavigationFrequency(5); //Set output to 5 times a second
-
-  uint8_t rate = myGNSS.getNavigationFrequency(); //Get the update rate of this module
-  Serial.print("Current update rate: ");
-  Serial.println(rate);
-
-  startTime = millis();
-}
-
-void loop()
-{
-  //Query module every 25 ms. Doing it more often will just cause I2C traffic.
-  //The module only responds when a new position is available. This is defined
-  //by the update freq.
-  if (millis() - lastTime > 25)
-  {
-    lastTime = millis(); //Update the timer
-    
-    long latitude = myGNSS.getLatitude();
-    Serial.print(F("Lat: "));
-    Serial.print(latitude);
-
-    long longitude = myGNSS.getLongitude();
-    Serial.print(F(" Long: "));
-    Serial.print(longitude);
-
-    updateCount++;
-
-    //Calculate the actual update rate based on the sketch start time and the 
-    //number of updates we've received.
-    Serial.print(F(" Rate: "));
-    Serial.print( updateCount / ((millis() - startTime) / 1000.0), 2);
-    Serial.print(F("Hz"));
-
-    Serial.println();
-  }
-}
diff --git a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Example8_GetProtocolVersion/Example8_GetProtocolVersion.ino b/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Example8_GetProtocolVersion/Example8_GetProtocolVersion.ino
deleted file mode 100644
index f7ed3e0..0000000
--- a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Example8_GetProtocolVersion/Example8_GetProtocolVersion.ino
+++ /dev/null
@@ -1,61 +0,0 @@
-/*
-  Reading the protocol version of a u-blox module
-  By: Nathan Seidle
-  SparkFun Electronics
-  Date: January 3rd, 2019
-  License: MIT. See license file for more information but you can
-  basically do whatever you want with this code.
-
-  This example shows how to query a u-blox module for its protocol version.
-
-  Various modules have various protocol version. We've seen v18 up to v27. Depending
-  on the protocol version there are different commands available. This is a handy
-  way to predict which commands will or won't work.
-
-  Leave NMEA parsing behind. Now you can simply ask the module for the datums you want!
-
-  Feel like supporting open source hardware?
-  Buy a board from SparkFun!
-  ZED-F9P RTK2: https://www.sparkfun.com/products/15136
-  NEO-M8P RTK: https://www.sparkfun.com/products/15005
-  SAM-M8Q: https://www.sparkfun.com/products/15106
-
-  Hardware Connections:
-  Plug a Qwiic cable into the GNSS and a BlackBoard
-  If you don't have a platform with a Qwiic connection use the SparkFun Qwiic Breadboard Jumper (https://www.sparkfun.com/products/14425)
-  Open the serial monitor at 115200 baud to see the output
-*/
-
-#include <Wire.h> //Needed for I2C to GNSS
-
-#include <SparkFun_u-blox_GNSS_Arduino_Library.h> //http://librarymanager/All#SparkFun_u-blox_GNSS
-SFE_UBLOX_GNSS myGNSS;
-
-long lastTime = 0; //Simple local timer. Limits amount if I2C traffic to u-blox module.
-
-void setup()
-{
-  Serial.begin(115200);
-  while (!Serial); //Wait for user to open terminal
-  Serial.println("SparkFun u-blox Example");
-
-  Wire.begin();
-
-  if (myGNSS.begin() == false) //Connect to the u-blox module using Wire port
-  {
-    Serial.println(F("u-blox GNSS not detected at default I2C address. Please check wiring. Freezing."));
-    while (1);
-  }
-
-  Serial.print(F("Version: "));
-  byte versionHigh = myGNSS.getProtocolVersionHigh();
-  Serial.print(versionHigh);
-  Serial.print(".");
-  byte versionLow = myGNSS.getProtocolVersionLow();
-  Serial.print(versionLow);
-}
-
-void loop()
-{
-  //Do nothing
-}
diff --git a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Example8_GetProtocolVersion_Serial/Example8_GetProtocolVersion_Serial.ino b/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Example8_GetProtocolVersion_Serial/Example8_GetProtocolVersion_Serial.ino
deleted file mode 100644
index 0f9ad28..0000000
--- a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Example8_GetProtocolVersion_Serial/Example8_GetProtocolVersion_Serial.ino
+++ /dev/null
@@ -1,81 +0,0 @@
-/*
-  Reading the protocol version of a u-blox module
-  By: Nathan Seidle
-  SparkFun Electronics
-  Date: January 3rd, 2019
-  License: MIT. See license file for more information but you can
-  basically do whatever you want with this code.
-
-  This example shows how to query a u-blox module for its protocol version.
-
-  Note: this may fail on boards like the UNO (ATmega328P) with modules like the ZED-F9P
-        because getProtocolVersion returns a lot of data - more than the UNO's serial buffer can hold
-
-  Various modules have various protocol version. We've seen v18 up to v27. Depending
-  on the protocol version there are different commands available. This is a handy
-  way to predict which commands will or won't work.
-
-  Leave NMEA parsing behind. Now you can simply ask the module for the datums you want!
-
-  Feel like supporting open source hardware?
-  Buy a board from SparkFun!
-  ZED-F9P RTK2: https://www.sparkfun.com/products/15136
-  NEO-M8P RTK: https://www.sparkfun.com/products/15005
-  SAM-M8Q: https://www.sparkfun.com/products/15106
-
-  Hardware Connections:
-  Plug a Qwiic cable into the GNSS and a BlackBoard
-  If you don't have a platform with a Qwiic connection use the SparkFun Qwiic Breadboard Jumper (https://www.sparkfun.com/products/14425)
-  Open the serial monitor at 115200 baud to see the output
-*/
-
-#include <SoftwareSerial.h>
-
-#define mySerial Serial1 // Uncomment this line to connect via Serial1
-// - or -
-//SoftwareSerial mySerial(10, 11); // Uncomment this line to connect via SoftwareSerial(RX, TX). Connect pin 10 to GNSS TX pin.
-
-#include <SparkFun_u-blox_GNSS_Arduino_Library.h> //http://librarymanager/All#SparkFun_u-blox_GNSS
-SFE_UBLOX_GNSS myGNSS;
-
-long lastTime = 0; //Simple local timer. Limits amount if I2C traffic to u-blox module.
-
-void setup()
-{
-  Serial.begin(115200);
-  while (!Serial); //Wait for user to open terminal
-  Serial.println("SparkFun u-blox Example");
-
-  Serial.println("Trying 38400 baud");
-  mySerial.begin(38400);
-  if (myGNSS.begin(mySerial))
-  {
-    Serial.println("GNSS connected at 38400 baud");
-  }
-  else
-  {
-    Serial.println("Trying 9600 baud");
-    mySerial.begin(9600);
-    if (myGNSS.begin(mySerial))
-    {
-      Serial.println("GNSS connected at 9600 baud");
-    }
-    else
-    {
-      Serial.println("Could not connect to GNSS. Freezing...");
-      while(1); // Do nothing more
-    }
-  }
-
-  Serial.print(F("Version: "));
-  byte versionHigh = myGNSS.getProtocolVersionHigh();
-  Serial.print(versionHigh);
-  Serial.print(".");
-  byte versionLow = myGNSS.getProtocolVersionLow();
-  Serial.print(versionLow);
-}
-
-void loop()
-{
-  //Do nothing
-}
diff --git a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Example9_ChangeI2CAddress/Example9_ChangeI2CAddress.ino b/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Example9_ChangeI2CAddress/Example9_ChangeI2CAddress.ino
deleted file mode 100644
index 9a5b061..0000000
--- a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Example9_ChangeI2CAddress/Example9_ChangeI2CAddress.ino
+++ /dev/null
@@ -1,116 +0,0 @@
-/*
-  Change the I2C address of a u-blox module using I2C
-  By: Nathan Seidle
-  SparkFun Electronics
-  Date: January 3rd, 2019
-  License: MIT. See license file for more information but you can
-  basically do whatever you want with this code.
-
-  This example shows how to change the I2C address of a u-blox module
-
-  Feel like supporting open source hardware?
-  Buy a board from SparkFun!
-  ZED-F9P RTK2: https://www.sparkfun.com/products/15136
-  NEO-M8P RTK: https://www.sparkfun.com/products/15005
-  SAM-M8Q: https://www.sparkfun.com/products/15106
-
-  Hardware Connections:
-  Plug a Qwiic cable into the GNSS and a BlackBoard
-  If you don't have a platform with a Qwiic connection use the SparkFun Qwiic Breadboard Jumper (https://www.sparkfun.com/products/14425)
-  Open the serial monitor at 115200 baud to see the output
-*/
-
-#include <Wire.h> //Needed for I2C to GNSS
-
-#include <SparkFun_u-blox_GNSS_Arduino_Library.h> //http://librarymanager/All#SparkFun_u-blox_GNSS
-SFE_UBLOX_GNSS myGNSS;
-
-long lastTime = 0; //Tracks the passing of 2000ms (2 seconds)
-
-void setup()
-{
-  Serial.begin(115200);
-  while (!Serial); //Wait for user to open terminal
-  Serial.println("SparkFun u-blox Example");
-
-  Wire.begin();
-
-  byte oldAddress = 0x42; //The default address for u-blox modules is 0x42
-  byte newAddress = 0x3F; //Address you want to change to. Valid is 0x08 to 0x77.
-
-  while (Serial.available()) Serial.read(); //Trash any incoming chars
-  Serial.print("Press a key to change address to 0x");
-  Serial.println(newAddress, HEX);
-  while (Serial.available() == false) ; //Wait for user to send character
-
-  //myGNSS.enableDebugging(); // Uncomment this line to enable helpful debug messages on Serial
-  
-  if (myGNSS.begin(Wire, oldAddress) == true) //Connect to the u-blox module using Wire port and the old address
-  {
-    Serial.print("GNSS found at address 0x");
-    Serial.println(oldAddress, HEX);
-
-    myGNSS.setI2CAddress(newAddress); //Change I2C address of this device
-    //Device's I2C address is stored to memory and loaded on each power-on
-
-    delay(2000); // Allow time for the change to take
-
-    if (myGNSS.begin(Wire, newAddress) == true)
-    {
-      myGNSS.saveConfiguration(); //Save the current settings to flash and BBR
-      
-      Serial.print("Address successfully changed to 0x");
-      Serial.println(newAddress, HEX);
-      Serial.print("Now load another example sketch using .begin(Wire, 0x");
-      Serial.print(newAddress, HEX);
-      Serial.println(") to use this GPS module");
-      Serial.println("Freezing...");
-      while (1);
-    }
-  }
-
-  //Something went wrong, begin looking for the I2C device
-  Serial.println("Address change probably failed. Beginning an I2C scan.");
-
-  Wire.begin();
-}
-
-void loop() {
-
-  byte address;
-  int nDevices;
-
-  Serial.println("Scanning...");
-
-  nDevices = 0;
-  for (address = 1; address < 127; address++ )
-  {
-    Wire.beginTransmission(address);
-    byte error = Wire.endTransmission();
-
-    if (error == 0)
-    {
-      Serial.print("I2C device found at address 0x");
-      if (address < 16)
-        Serial.print("0");
-      Serial.print(address, HEX);
-      Serial.println("  !");
-
-      nDevices++;
-    }
-//    else if (error == 4)
-//    {
-//      Serial.print("Unknown error at address 0x");
-//      if (address < 16)
-//        Serial.print("0");
-//      Serial.println(address, HEX);
-//    }
-  }
-
-  if (nDevices == 0)
-    Serial.println("No I2C devices found\n");
-  else
-    Serial.println("done\n");
-
-  delay(5000);           // wait 5 seconds for next scan
-}
diff --git a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/NEO-M8P-2/Example1_EnableRTCM/Example1_EnableRTCM.ino b/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/NEO-M8P-2/Example1_EnableRTCM/Example1_EnableRTCM.ino
deleted file mode 100644
index 6addf88..0000000
--- a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/NEO-M8P-2/Example1_EnableRTCM/Example1_EnableRTCM.ino
+++ /dev/null
@@ -1,77 +0,0 @@
-/*
-  Send UBX binary commands to enable RTCM sentences on u-blox NEO-M8P module
-  By: Nathan Seidle
-  SparkFun Electronics
-  Date: September 7th, 2018
-  License: MIT. See license file for more information but you can
-  basically do whatever you want with this code.
-
-  This example sends the command to enable the four RTCM messages needed for RTK. This 
-  is the first part of a larger tutorial and example to setup an RTK base station.
-  These commands are only accepted by the NEO-M8P module.
- 
-  Feel like supporting open source hardware?
-  Buy a board from SparkFun!
-  ZED-F9P RTK2: https://www.sparkfun.com/products/15136
-  NEO-M8P RTK: https://www.sparkfun.com/products/15005
-  SAM-M8Q: https://www.sparkfun.com/products/15106
-
-  Hardware Connections:
-  Plug a Qwiic cable into the GNSS and a BlackBoard
-  If you don't have a platform with a Qwiic connection use the SparkFun Qwiic Breadboard Jumper (https://www.sparkfun.com/products/14425)
-  Open the serial monitor at 115200 baud to see the output
-*/
-
-#include <Wire.h> //Needed for I2C to GNSS
-
-#include <SparkFun_u-blox_GNSS_Arduino_Library.h> //http://librarymanager/All#SparkFun_u-blox_GNSS
-SFE_UBLOX_GNSS myGNSS;
-
-void setup()
-{
-  Serial.begin(115200);
-  while(!Serial); //Wait for user to open terminal
-  Serial.println(F("u-blox RTCM Enable Example"));
-
-  Wire.begin();
-  Wire.setClock(400000); //Increase I2C clock speed to 400kHz
-
-  if (myGNSS.begin() == false) //Connect to the u-blox module using Wire port
-  {
-    Serial.println(F("u-blox GNSS not detected at default I2C address. Please check wiring. Freezing."));
-    while (1);
-  }
-
-  while(Serial.available()) Serial.read(); //Clear any latent chars in serial buffer
-  Serial.println(F("Press any key to send commands to enable RTCM 3.x"));
-  while(Serial.available() == 0) ; //Wait for user to press a key
-
-  myGNSS.setI2COutput(COM_TYPE_UBX); //Set the I2C port to output UBX only (turn off NMEA noise)
-  myGNSS.saveConfiguration(); //Save the current settings to flash and BBR
-
-  boolean response = true;
-  response &= myGNSS.enableRTCMmessage(UBX_RTCM_1005, COM_PORT_I2C, 1); //Enable message 1005 to output through I2C port, message every second
-  response &= myGNSS.enableRTCMmessage(UBX_RTCM_1077, COM_PORT_I2C, 1);
-  response &= myGNSS.enableRTCMmessage(UBX_RTCM_1087, COM_PORT_I2C, 1);
-  response &= myGNSS.enableRTCMmessage(UBX_RTCM_1230, COM_PORT_I2C, 10); //Enable message every 10 seconds
-
-  if (response == true)
-  {
-    Serial.println(F("RTCM messages enabled"));
-  }
-  else
-  {
-    Serial.println(F("RTCM failed to enable. Are you sure you have an NEO-M8P?"));
-    while(1); //Freeze
-  }
-
-  //RTCM is now enabled but we haven't done a 'survey-in'
-  //See example 4 for the full Base RTK setup
-}
-
-void loop()
-{
-  myGNSS.checkUblox(); //See if new data is available. Process bytes as they come in.
-
-  delay(250); //Don't pound too hard on the I2C bus
-}
diff --git a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/NEO-M8P-2/Example2_StartRTCMBase/Example2_StartRTCMBase.ino b/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/NEO-M8P-2/Example2_StartRTCMBase/Example2_StartRTCMBase.ino
deleted file mode 100644
index 8cf2375..0000000
--- a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/NEO-M8P-2/Example2_StartRTCMBase/Example2_StartRTCMBase.ino
+++ /dev/null
@@ -1,164 +0,0 @@
-/*
-  Note: compiles OK with v2.0 but is currently untested
-  
-  Send UBX binary commands to enable RTCM sentences on u-blox NEO-M8P-2 module
-  By: Nathan Seidle
-  SparkFun Electronics
-  Date: September 7th, 2018
-  License: MIT. See license file for more information but you can
-  basically do whatever you want with this code.
-
-  This example does all steps to configure and enable a NEO-M8P-2 as a base station:
-    Begin Survey-In
-    Once we've achieved 2m accuracy and 300s have passed, survey is complete
-    Enable four RTCM messages
-    Begin outputting RTCM bytes
-
-  Feel like supporting open source hardware?
-  Buy a board from SparkFun!
-  ZED-F9P RTK2: https://www.sparkfun.com/products/15136
-  NEO-M8P RTK: https://www.sparkfun.com/products/15005
-  SAM-M8Q: https://www.sparkfun.com/products/15106
-
-  Hardware Connections:
-  Plug a Qwiic cable into the GNSS and a BlackBoard
-  If you don't have a platform with a Qwiic connection use the SparkFun Qwiic Breadboard Jumper (https://www.sparkfun.com/products/14425)
-  Open the serial monitor at 115200 baud to see the output
-*/
-
-#include <Wire.h> //Needed for I2C to GNSS
-
-#include <SparkFun_u-blox_GNSS_Arduino_Library.h> //http://librarymanager/All#SparkFun_u-blox_GNSS
-SFE_UBLOX_GNSS myGNSS;
-
-void setup()
-{
-  Serial.begin(115200);
-  while (!Serial); //Wait for user to open terminal
-  Serial.println(F("u-blox NEO-M8P-2 base station example"));
-
-  Wire.begin();
-  Wire.setClock(400000); //Increase I2C clock speed to 400kHz
-
-  if (myGNSS.begin() == false) //Connect to the u-blox module using Wire port
-  {
-    Serial.println(F("u-blox GNSS not detected at default I2C address. Please check wiring. Freezing."));
-    while (1);
-  }
-
-  myGNSS.setI2COutput(COM_TYPE_UBX); //Set the I2C port to output UBX only (turn off NMEA noise)
-  myGNSS.saveConfiguration(); //Save the current settings to flash and BBR
-
-  while (Serial.available()) Serial.read(); //Clear any latent chars in serial buffer
-  Serial.println(F("Press any key to send commands to begin Survey-In"));
-  while (Serial.available() == 0) ; //Wait for user to press a key
-
-  boolean response;
-
-  //Check if Survey is in Progress before initiating one
-  // From v2.0, the data from getSurveyStatus (UBX-NAV-SVIN) is returned in UBX_NAV_SVIN_t packetUBXNAVSVIN
-  // Please see u-blox_structs.h for the full definition of UBX_NAV_SVIN_t
-  // You can either read the data from packetUBXNAVSVIN directly
-  // or can use the helper functions: getSurveyInActive; getSurveyInValid; getSurveyInObservationTime; and getSurveyInMeanAccuracy
-  response = myGNSS.getSurveyStatus(2000); //Query module for SVIN status with 2000ms timeout (request can take a long time)
-  
-  if (response == false) // Check if fresh data was received
-  {
-    Serial.println(F("Failed to get Survey In status. Freezing..."));
-    while (1); //Freeze
-  }
-
-  if (myGNSS.getSurveyInActive() == true) // Use the helper function
-  {
-    Serial.print(F("Survey already in progress."));
-  }
-  else
-  {
-    //Start survey
-    response = myGNSS.enableSurveyMode(300, 2.000); //Enable Survey in, 300 seconds, 2.0m
-    if (response == false)
-    {
-      Serial.println(F("Survey start failed. Freezing..."));
-      while (1);
-    }
-    Serial.println(F("Survey started. This will run until 300s has passed and less than 2m accuracy is achieved."));
-  }
-
-  while(Serial.available()) Serial.read(); //Clear buffer
-  
-  //Begin waiting for survey to complete
-  while (myGNSS.getSurveyInValid() == false) // Call the helper function
-  {
-    if(Serial.available())
-    {
-      byte incoming = Serial.read();
-      if(incoming == 'x')
-      {
-        //Stop survey mode
-        response = myGNSS.disableSurveyMode(); //Disable survey
-        Serial.println(F("Survey stopped"));
-        break;
-      }
-    }
-    
-    // From v2.0, the data from getSurveyStatus (UBX-NAV-SVIN) is returned in UBX_NAV_SVIN_t packetUBXNAVSVIN
-    // Please see u-blox_structs.h for the full definition of UBX_NAV_SVIN_t
-    // You can either read the data from packetUBXNAVSVIN directly
-    // or can use the helper functions: getSurveyInActive; getSurveyInValid; getSurveyInObservationTime; and getSurveyInMeanAccuracy
-    response = myGNSS.getSurveyStatus(2000); //Query module for SVIN status with 2000ms timeout (req can take a long time)
-    if (response == true) // Check if fresh data was received
-    {
-      Serial.print(F("Press x to end survey - "));
-      Serial.print(F("Time elapsed: "));
-      Serial.print((String)myGNSS.getSurveyInObservationTime());
-
-      Serial.print(F(" Accuracy: "));
-      Serial.print((String)myGNSS.getSurveyInMeanAccuracy());
-      Serial.println();
-    }
-    else
-    {
-      Serial.println(F("SVIN request failed"));
-    }
-
-    delay(1000);
-  }
-  Serial.println(F("Survey valid!"));
-
-  response = true;
-  response &= myGNSS.enableRTCMmessage(UBX_RTCM_1005, COM_PORT_I2C, 1); //Enable message 1005 to output through I2C port, message every second
-  response &= myGNSS.enableRTCMmessage(UBX_RTCM_1077, COM_PORT_I2C, 1);
-  response &= myGNSS.enableRTCMmessage(UBX_RTCM_1087, COM_PORT_I2C, 1);
-  response &= myGNSS.enableRTCMmessage(UBX_RTCM_1230, COM_PORT_I2C, 10); //Enable message every 10 seconds
-
-  if (response == true)
-  {
-    Serial.println(F("RTCM messages enabled"));
-  }
-  else
-  {
-    Serial.println(F("RTCM failed to enable. Are you sure you have an NEO-M8P?"));
-    while (1); //Freeze
-  }
-
-  Serial.println(F("Base survey complete! RTCM now broadcasting."));
-}
-
-void loop()
-{
-  myGNSS.checkUblox(); //See if new data is available. Process bytes as they come in.
-
-  delay(250); //Don't pound too hard on the I2C bus
-}
-
-//This function gets called from the SparkFun u-blox Arduino Library.
-//As each RTCM byte comes in you can specify what to do with it
-//Useful for passing the RTCM correction data to a radio, Ntrip broadcaster, etc.
-void SFE_UBLOX_GNSS::processRTCM(uint8_t incoming)
-{
-  //Let's just pretty-print the HEX values for now
-  if (myGNSS.rtcmFrameCounter % 16 == 0) Serial.println();
-  Serial.print(F(" "));
-  if (incoming < 0x10) Serial.print(F("0"));
-  Serial.print(incoming, HEX);
-}
diff --git a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/NEO-M8P-2/Example3_BaseWithLCD/Example3_BaseWithLCD.ino b/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/NEO-M8P-2/Example3_BaseWithLCD/Example3_BaseWithLCD.ino
deleted file mode 100644
index d39f2b9..0000000
--- a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/NEO-M8P-2/Example3_BaseWithLCD/Example3_BaseWithLCD.ino
+++ /dev/null
@@ -1,195 +0,0 @@
-/*
-  Note: compiles OK with v2.0 but is currently untested
-  
-  Send UBX binary commands to enable RTCM sentences on u-blox NEO-M8P-2 module
-  By: Nathan Seidle
-  SparkFun Electronics
-  Date: September 7th, 2018
-  License: MIT. See license file for more information but you can
-  basically do whatever you want with this code.
-
-  This example does all steps to configure and enable a NEO-M8P-2 as a base station:
-    Begin Survey-In
-    Once we've achieved 2m accuracy and 300s have passed, survey is complete
-    Enable four RTCM messages
-    Begin outputting RTCM bytes
-
-  Feel like supporting open source hardware?
-  Buy a board from SparkFun!
-  ZED-F9P RTK2: https://www.sparkfun.com/products/15136
-  NEO-M8P RTK: https://www.sparkfun.com/products/15005
-  SAM-M8Q: https://www.sparkfun.com/products/15106
-
-  Hardware Connections:
-  Plug a Qwiic cable into the GNSS and a BlackBoard
-  Plug a SerLCD onto the Qwiic bus
-  If you don't have a platform with a Qwiic connection use the SparkFun Qwiic Breadboard Jumper (https://www.sparkfun.com/products/14425)
-  Watch the output on the LCD or open the serial monitor at 115200 baud to see the output
-*/
-
-#define STAT_LED 13
-
-#include <Wire.h> //Needed for I2C to GNSS
-
-#include <SparkFun_u-blox_GNSS_Arduino_Library.h> //Click here to get the library: http://librarymanager/All#SparkFun_u-blox_GNSS
-SFE_UBLOX_GNSS myGNSS;
-
-#include <SerLCD.h> //Click here to get the library: http://librarymanager/All#SparkFun_SerLCD
-SerLCD lcd; // Initialize the library with default I2C address 0x72
-
-void setup()
-{
-  Serial.begin(115200);
-  while (!Serial); //Wait for user to open terminal
-  Serial.println(F("u-blox GNSS I2C Test"));
-
-  Wire.begin();
-
-  pinMode(STAT_LED, OUTPUT);
-  digitalWrite(STAT_LED, LOW);
-
-  lcd.begin(Wire); //Set up the LCD for Serial communication at 9600bps
-  lcd.setBacklight(0x4B0082); //indigo, a kind of dark purplish blue
-  lcd.clear();
-  lcd.print(F("LCD Ready"));
-
-  myGNSS.begin(Wire);
-  if (myGNSS.isConnected() == false)
-  {
-    Serial.println(F("u-blox GNSS not detected at default I2C address. Please check wiring. Freezing."));
-    lcd.setCursor(0, 1);
-    lcd.print(F("No GNSS detected"));
-    while (1);
-  }
-
-  Wire.setClock(400000); //Increase I2C clock speed to 400kHz
-
-  lcd.setCursor(0, 1);
-  lcd.print("GNSS Detected");
-
-  //Check if Survey is in Progress before initiating one
-  // From v2.0, the data from getSurveyStatus (UBX-NAV-SVIN) is returned in UBX_NAV_SVIN_t packetUBXNAVSVIN
-  // Please see u-blox_structs.h for the full definition of UBX_NAV_SVIN_t
-  // You can either read the data from packetUBXNAVSVIN directly
-  // or can use the helper functions: getSurveyInActive; getSurveyInValid; getSurveyInObservationTime; and getSurveyInMeanAccuracy
-  boolean response;
-  response = myGNSS.getSurveyStatus(2000); //Query module for SVIN status with 2000ms timeout (request can take a long time)
-  if (response == false)
-  {
-    Serial.println(F("Failed to get Survey In status"));
-    while (1); //Freeze
-  }
-
-  if (myGNSS.getSurveyInActive() == true) // Use the helper function
-  {
-    Serial.print(F("Survey already in progress."));
-    lcd.setCursor(0, 2);
-    lcd.print(F("Survey already going"));
-  }
-  else
-  {
-    //Start survey
-    response = myGNSS.enableSurveyMode(300, 2.000); //Enable Survey in, 300 seconds, 2.0m
-    if (response == false)
-    {
-      Serial.println(F("Survey start failed"));
-      lcd.setCursor(0, 3);
-      lcd.print(F("Survey start failed"));
-      while (1);
-    }
-    Serial.println(F("Survey started. This will run until 300s has passed and less than 2m accuracy is achieved."));
-  }
-
-  while (Serial.available()) Serial.read(); //Clear buffer
-
-  lcd.clear();
-  lcd.print(F("Survey in progress"));
-
-  //Begin waiting for survey to complete
-  while (myGNSS.getSurveyInValid() == false) // Call the helper function
-  {
-    if (Serial.available())
-    {
-      byte incoming = Serial.read();
-      if (incoming == 'x')
-      {
-        //Stop survey mode
-        response = myGNSS.disableSurveyMode(); //Disable survey
-        Serial.println(F("Survey stopped"));
-        break;
-      }
-    }
-
-    // From v2.0, the data from getSurveyStatus (UBX-NAV-SVIN) is returned in UBX_NAV_SVIN_t packetUBXNAVSVIN
-    // Please see u-blox_structs.h for the full definition of UBX_NAV_SVIN_t
-    // You can either read the data from packetUBXNAVSVIN directly
-    // or can use the helper functions: getSurveyInActive; getSurveyInValid; getSurveyInObservationTime; and getSurveyInMeanAccuracy
-    response = myGNSS.getSurveyStatus(2000); //Query module for SVIN status with 2000ms timeout (req can take a long time)
-    if (response == true)
-    {
-      Serial.print(F("Press x to end survey - "));
-      Serial.print(F("Time elapsed: "));
-      Serial.print((String)myGNSS.getSurveyInObservationTime());
-
-      lcd.setCursor(0, 1);
-      lcd.print(F("Elapsed: "));
-      lcd.print((String)myGNSS.getSurveyInObservationTime());
-
-      Serial.print(F(" Accuracy: "));
-      Serial.print((String)myGNSS.getSurveyInMeanAccuracy());
-      Serial.println();
-
-      lcd.setCursor(0, 2);
-      lcd.print(F("Accuracy: "));
-      lcd.print((String)myGNSS.getSurveyInMeanAccuracy());
-    }
-    else
-    {
-      Serial.println(F("SVIN request failed"));
-    }
-
-    delay(1000);
-  }
-  Serial.println(F("Survey valid!"));
-
-  response = true;
-  response &= myGNSS.enableRTCMmessage(UBX_RTCM_1005, COM_PORT_I2C, 1); //Enable message 1005 to output through I2C port, message every second
-  response &= myGNSS.enableRTCMmessage(UBX_RTCM_1077, COM_PORT_I2C, 1);
-  response &= myGNSS.enableRTCMmessage(UBX_RTCM_1087, COM_PORT_I2C, 1);
-  response &= myGNSS.enableRTCMmessage(UBX_RTCM_1230, COM_PORT_I2C, 10); //Enable message every 10 seconds
-
-  if (response == true)
-  {
-    Serial.println(F("RTCM messages enabled"));
-  }
-  else
-  {
-    Serial.println(F("RTCM failed to enable. Are you sure you have an NEO-M8P?"));
-    while (1); //Freeze
-  }
-
-  Serial.println(F("Base survey complete! RTCM now broadcasting."));
-  lcd.clear();
-  lcd.print(F("Transmitting RTCM"));
-}
-
-void loop()
-{
-  myGNSS.checkUblox(); //See if new data is available. Process bytes as they come in.
-
-  //Do anything you want. Call checkUblox() every second. NEO-M8P-2 has TX buffer of 4k bytes.
-  
-  delay(250); //Don't pound too hard on the I2C bus
-}
-
-//This function gets called from the SparkFun u-blox Arduino Library.
-//As each RTCM byte comes in you can specify what to do with it
-//Useful for passing the RTCM correction data to a radio, Ntrip broadcaster, etc.
-void SFE_UBLOX_GNSS::processRTCM(uint8_t incoming)
-{
-  //Let's just pretty-print the HEX values for now
-  if (myGNSS.rtcmFrameCounter % 16 == 0) Serial.println();
-  Serial.print(" ");
-  if (incoming < 0x10) Serial.print("0");
-  Serial.print(incoming, HEX);
-}
diff --git a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/ZED-F9P/Example10_GetHighPrecisionPositionAndAccuracy/Example10_GetHighPrecisionPositionAndAccuracy.ino b/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/ZED-F9P/Example10_GetHighPrecisionPositionAndAccuracy/Example10_GetHighPrecisionPositionAndAccuracy.ino
deleted file mode 100644
index 0496d5c..0000000
--- a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/ZED-F9P/Example10_GetHighPrecisionPositionAndAccuracy/Example10_GetHighPrecisionPositionAndAccuracy.ino
+++ /dev/null
@@ -1,172 +0,0 @@
-/*
-  Get the high precision geodetic solution for latitude and longitude
-  By: Nathan Seidle
-  Modified by: Steven Rowland and Paul Clark
-  SparkFun Electronics
-  Date: April 17th, 2020
-  License: MIT. See license file for more information but you can
-  basically do whatever you want with this code.
-
-  This example shows how to inspect the accuracy of the high-precision
-  positional solution. Please see below for information about the units.
-
-  Feel like supporting open source hardware?
-  Buy a board from SparkFun!
-  ZED-F9P RTK2: https://www.sparkfun.com/products/15136
-  NEO-M8P RTK: https://www.sparkfun.com/products/15005
-
-  Hardware Connections:
-  Plug a Qwiic cable into the GNSS and a BlackBoard
-  If you don't have a platform with a Qwiic connection use the SparkFun Qwiic Breadboard Jumper (https://www.sparkfun.com/products/14425)
-  Open the serial monitor at 115200 baud to see the output
-*/
-
-#include <Wire.h> //Needed for I2C to GNSS
-
-#include <SparkFun_u-blox_GNSS_Arduino_Library.h> //http://librarymanager/All#SparkFun_u-blox_GNSS
-SFE_UBLOX_GNSS myGNSS;
-
-long lastTime = 0; //Simple local timer. Limits amount if I2C traffic to u-blox module.
-
-void setup()
-{
-  Serial.begin(115200);
-  while (!Serial); //Wait for user to open terminal
-
-  Wire.begin();
-
-  //myGNSS.enableDebugging(Serial);
-
-  if (myGNSS.begin(Wire) == false) //Connect to the u-blox module using Wire port
-  {
-    Serial.println(F("u-blox GNSS not detected at default I2C address. Please check wiring. Freezing."));
-    while (1);
-  }
-
-  myGNSS.setI2COutput(COM_TYPE_UBX); //Set the I2C port to output UBX only (turn off NMEA noise)
-  myGNSS.setNavigationFrequency(20); //Set output to 20 times a second
-
-  byte rate = myGNSS.getNavigationFrequency(); //Get the update rate of this module
-  Serial.print("Current update rate: ");
-  Serial.println(rate);
-
-  //myGNSS.saveConfiguration(); //Save the current settings to flash and BBR
-}
-
-void loop()
-{
-  //Query module only every second. Doing it more often will just cause I2C traffic.
-  //The module only responds when a new position is available
-  if (millis() - lastTime > 1000)
-  {
-    lastTime = millis(); //Update the timer
-
-    // getHighResLatitude: returns the latitude from HPPOSLLH as an int32_t in degrees * 10^-7
-    // getHighResLatitudeHp: returns the high resolution component of latitude from HPPOSLLH as an int8_t in degrees * 10^-9
-    // getHighResLongitude: returns the longitude from HPPOSLLH as an int32_t in degrees * 10^-7
-    // getHighResLongitudeHp: returns the high resolution component of longitude from HPPOSLLH as an int8_t in degrees * 10^-9
-    // getElipsoid: returns the height above ellipsoid as an int32_t in mm
-    // getElipsoidHp: returns the high resolution component of the height above ellipsoid as an int8_t in mm * 10^-1
-    // getMeanSeaLevel: returns the height above mean sea level as an int32_t in mm
-    // getMeanSeaLevelHp: returns the high resolution component of the height above mean sea level as an int8_t in mm * 10^-1
-    // getHorizontalAccuracy: returns the horizontal accuracy estimate from HPPOSLLH as an uint32_t in mm * 10^-1
-
-    // If you want to use the high precision latitude and longitude with the full 9 decimal places
-    // you will need to use a 64-bit double - which is not supported on all platforms
-
-    // To allow this example to run on standard platforms, we cheat by converting lat and lon to integer and fractional degrees
-
-    // The high resolution altitudes can be converted into standard 32-bit float
-
-    // First, let's collect the position data
-    int32_t latitude = myGNSS.getHighResLatitude();
-    int8_t latitudeHp = myGNSS.getHighResLatitudeHp();
-    int32_t longitude = myGNSS.getHighResLongitude();
-    int8_t longitudeHp = myGNSS.getHighResLongitudeHp();
-    int32_t ellipsoid = myGNSS.getElipsoid();
-    int8_t ellipsoidHp = myGNSS.getElipsoidHp();
-    int32_t msl = myGNSS.getMeanSeaLevel();
-    int8_t mslHp = myGNSS.getMeanSeaLevelHp();
-    uint32_t accuracy = myGNSS.getHorizontalAccuracy();
-
-    // Defines storage for the lat and lon units integer and fractional parts
-    int32_t lat_int; // Integer part of the latitude in degrees
-    int32_t lat_frac; // Fractional part of the latitude
-    int32_t lon_int; // Integer part of the longitude in degrees
-    int32_t lon_frac; // Fractional part of the longitude
-
-    // Calculate the latitude and longitude integer and fractional parts
-    lat_int = latitude / 10000000; // Convert latitude from degrees * 10^-7 to Degrees
-    lat_frac = latitude - (lat_int * 10000000); // Calculate the fractional part of the latitude
-    lat_frac = (lat_frac * 100) + latitudeHp; // Now add the high resolution component
-    if (lat_frac < 0) // If the fractional part is negative, remove the minus sign
-    {
-      lat_frac = 0 - lat_frac;
-    }
-    lon_int = longitude / 10000000; // Convert latitude from degrees * 10^-7 to Degrees
-    lon_frac = longitude - (lon_int * 10000000); // Calculate the fractional part of the longitude
-    lon_frac = (lon_frac * 100) + longitudeHp; // Now add the high resolution component
-    if (lon_frac < 0) // If the fractional part is negative, remove the minus sign
-    {
-      lon_frac = 0 - lon_frac;
-    }
-
-    // Print the lat and lon
-    Serial.print("Lat (deg): ");
-    Serial.print(lat_int); // Print the integer part of the latitude
-    Serial.print(".");
-    printFractional(lat_frac, 9); // Print the fractional part of the latitude with leading zeros
-    Serial.print(", Lon (deg): ");
-    Serial.print(lon_int); // Print the integer part of the latitude
-    Serial.print(".");
-    printFractional(lon_frac, 9); // Print the fractional part of the latitude with leading zeros
-    Serial.println();
-
-    // Now define float storage for the heights and accuracy
-    float f_ellipsoid;
-    float f_msl;
-    float f_accuracy;
-
-    // Calculate the height above ellipsoid in mm * 10^-1
-    f_ellipsoid = (ellipsoid * 10) + ellipsoidHp;
-    // Now convert to m
-    f_ellipsoid = f_ellipsoid / 10000.0; // Convert from mm * 10^-1 to m
-
-    // Calculate the height above mean sea level in mm * 10^-1
-    f_msl = (msl * 10) + mslHp;
-    // Now convert to m
-    f_msl = f_msl / 10000.0; // Convert from mm * 10^-1 to m
-
-    // Convert the horizontal accuracy (mm * 10^-1) to a float
-    f_accuracy = accuracy;
-    // Now convert to m
-    f_accuracy = f_accuracy / 10000.0; // Convert from mm * 10^-1 to m
-
-    // Finally, do the printing
-    Serial.print("Ellipsoid (m): ");
-    Serial.print(f_ellipsoid, 4); // Print the ellipsoid with 4 decimal places
-
-    Serial.print(", Mean Sea Level(m): ");
-    Serial.print(f_msl, 4); // Print the mean sea level with 4 decimal places
-
-    Serial.print(", Accuracy (m): ");
-    Serial.println(f_accuracy, 4); // Print the accuracy with 4 decimal places
-  }
-}
-
-// Pretty-print the fractional part with leading zeros - without using printf
-// (Only works with positive numbers)
-void printFractional(int32_t fractional, uint8_t places)
-{
-  if (places > 1)
-  {
-    for (uint8_t place = places - 1; place > 0; place--)
-    {
-      if (fractional < pow(10, place))
-      {
-        Serial.print("0");
-      }
-    }
-  }
-  Serial.print(fractional);
-}
diff --git a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/ZED-F9P/Example11_GetHighPrecisionPositionUsingDouble/Example11_GetHighPrecisionPositionUsingDouble.ino b/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/ZED-F9P/Example11_GetHighPrecisionPositionUsingDouble/Example11_GetHighPrecisionPositionUsingDouble.ino
deleted file mode 100644
index bb8eef8..0000000
--- a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/ZED-F9P/Example11_GetHighPrecisionPositionUsingDouble/Example11_GetHighPrecisionPositionUsingDouble.ino
+++ /dev/null
@@ -1,146 +0,0 @@
-/*
-  Get the high precision geodetic solution for latitude and longitude using double
-  By: Nathan Seidle
-  Modified by: Paul Clark (PaulZC)
-  SparkFun Electronics
-  Date: April 17th, 2020
-  License: MIT. See license file for more information but you can
-  basically do whatever you want with this code.
-
-  This example shows how to inspect the accuracy of the high-precision
-  positional solution. Please see below for information about the units.
-
-  ** This example will only work correctly on platforms which support 64-bit double **
-
-  Feel like supporting open source hardware?
-  Buy a board from SparkFun!
-  ZED-F9P RTK2: https://www.sparkfun.com/products/15136
-  NEO-M8P RTK: https://www.sparkfun.com/products/15005
-
-  Hardware Connections:
-  Plug a Qwiic cable into the GNSS and (e.g.) a Redboard Artemis https://www.sparkfun.com/products/15444
-  or an Artemis Thing Plus https://www.sparkfun.com/products/15574
-  If you don't have a platform with a Qwiic connection use the SparkFun Qwiic Breadboard Jumper (https://www.sparkfun.com/products/14425)
-  Open the serial monitor at 115200 baud to see the output
-*/
-
-#include <Wire.h> // Needed for I2C to GNSS
-
-#define myWire Wire // This will work on the Redboard Artemis and the Artemis Thing Plus using Qwiic
-//#define myWire Wire1 // Uncomment this line if you are using the extra SCL1/SDA1 pins (D17 and D16) on the Thing Plus
-
-#include <SparkFun_u-blox_GNSS_Arduino_Library.h> //http://librarymanager/All#SparkFun_u-blox_GNSS
-SFE_UBLOX_GNSS myGNSS;
-
-long lastTime = 0; //Simple local timer. Limits amount if I2C traffic to u-blox module.
-
-void setup()
-{
-  Serial.begin(115200);
-  while (!Serial); //Wait for user to open terminal
-
-  myWire.begin();
-
-  //myGNSS.enableDebugging(Serial); // Uncomment this line to enable debug messages
-
-  if (myGNSS.begin(myWire) == false) //Connect to the u-blox module using Wire port
-  {
-    Serial.println(F("u-blox GNSS not detected at default I2C address. Please check wiring. Freezing."));
-    while (1)
-      ;
-  }
-
-  // Check that this platform supports 64-bit (8 byte) double
-  if (sizeof(double) < 8)
-  {
-    Serial.println(F("Warning! Your platform does not support 64-bit double."));
-    Serial.println(F("The latitude and longitude will be inaccurate."));
-  }
-
-  myGNSS.setI2COutput(COM_TYPE_UBX); //Set the I2C port to output UBX only (turn off NMEA noise)
-
-  //myGNSS.setNavigationFrequency(20); //Set output to 20 times a second
-
-  byte rate = myGNSS.getNavigationFrequency(); //Get the update rate of this module
-  Serial.print("Current update rate: ");
-  Serial.println(rate);
-
-  //myGNSS.saveConfiguration(); //Save the current settings to flash and BBR
-}
-
-void loop()
-{
-  //Query module only every second.
-  //The module only responds when a new position is available.
-  if (millis() - lastTime > 1000)
-  {
-    lastTime = millis(); //Update the timer
-
-    // getHighResLatitude: returns the latitude from HPPOSLLH as an int32_t in degrees * 10^-7
-    // getHighResLatitudeHp: returns the high resolution component of latitude from HPPOSLLH as an int8_t in degrees * 10^-9
-    // getHighResLongitude: returns the longitude from HPPOSLLH as an int32_t in degrees * 10^-7
-    // getHighResLongitudeHp: returns the high resolution component of longitude from HPPOSLLH as an int8_t in degrees * 10^-9
-    // getElipsoid: returns the height above ellipsoid as an int32_t in mm
-    // getElipsoidHp: returns the high resolution component of the height above ellipsoid as an int8_t in mm * 10^-1
-    // getMeanSeaLevel: returns the height above mean sea level as an int32_t in mm
-    // getMeanSeaLevelHp: returns the high resolution component of the height above mean sea level as an int8_t in mm * 10^-1
-    // getHorizontalAccuracy: returns the horizontal accuracy estimate from HPPOSLLH as an uint32_t in mm * 10^-1
-
-    // First, let's collect the position data
-    int32_t latitude = myGNSS.getHighResLatitude();
-    int8_t latitudeHp = myGNSS.getHighResLatitudeHp();
-    int32_t longitude = myGNSS.getHighResLongitude();
-    int8_t longitudeHp = myGNSS.getHighResLongitudeHp();
-    int32_t ellipsoid = myGNSS.getElipsoid();
-    int8_t ellipsoidHp = myGNSS.getElipsoidHp();
-    int32_t msl = myGNSS.getMeanSeaLevel();
-    int8_t mslHp = myGNSS.getMeanSeaLevelHp();
-    uint32_t accuracy = myGNSS.getHorizontalAccuracy();
-
-    // Defines storage for the lat and lon as double
-    double d_lat; // latitude
-    double d_lon; // longitude
-
-    // Assemble the high precision latitude and longitude
-    d_lat = ((double)latitude) / 10000000.0; // Convert latitude from degrees * 10^-7 to degrees
-    d_lat += ((double)latitudeHp) / 1000000000.0; // Now add the high resolution component (degrees * 10^-9 )
-    d_lon = ((double)longitude) / 10000000.0; // Convert longitude from degrees * 10^-7 to degrees
-    d_lon += ((double)longitudeHp) / 1000000000.0; // Now add the high resolution component (degrees * 10^-9 )
-
-   // Print the lat and lon
-    Serial.print("Lat (deg): ");
-    Serial.print(d_lat, 9);
-    Serial.print(", Lon (deg): ");
-    Serial.print(d_lon, 9);
-
-    // Now define float storage for the heights and accuracy
-    float f_ellipsoid;
-    float f_msl;
-    float f_accuracy;
-
-    // Calculate the height above ellipsoid in mm * 10^-1
-    f_ellipsoid = (ellipsoid * 10) + ellipsoidHp;
-    // Now convert to m
-    f_ellipsoid = f_ellipsoid / 10000.0; // Convert from mm * 10^-1 to m
-
-    // Calculate the height above mean sea level in mm * 10^-1
-    f_msl = (msl * 10) + mslHp;
-    // Now convert to m
-    f_msl = f_msl / 10000.0; // Convert from mm * 10^-1 to m
-
-    // Convert the horizontal accuracy (mm * 10^-1) to a float
-    f_accuracy = accuracy;
-    // Now convert to m
-    f_accuracy = f_accuracy / 10000.0; // Convert from mm * 10^-1 to m
-
-    // Finally, do the printing
-    Serial.print(", Ellipsoid (m): ");
-    Serial.print(f_ellipsoid, 4); // Print the ellipsoid with 4 decimal places
-
-    Serial.print(", Mean Sea Level (m): ");
-    Serial.print(f_msl, 4); // Print the mean sea level with 4 decimal places
-
-    Serial.print(", Accuracy (m): ");
-    Serial.println(f_accuracy, 4); // Print the accuracy with 4 decimal places
-  }
-}
diff --git a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/ZED-F9P/Example12_setStaticPosition/Example12_setStaticPosition.ino b/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/ZED-F9P/Example12_setStaticPosition/Example12_setStaticPosition.ino
deleted file mode 100644
index d30ef49..0000000
--- a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/ZED-F9P/Example12_setStaticPosition/Example12_setStaticPosition.ino
+++ /dev/null
@@ -1,77 +0,0 @@
-/*
-  Set the static position of the receiver.
-  By: SparkFun Electronics / Nathan Seidle
-  Date: September 26th, 2020
-  License: MIT. See license file for more information but you can
-  basically do whatever you want with this code.
-
-  This example shows how to set the static position of a receiver
-  using an Earth-Centered, Earth-Fixed (ECEF) location. This is the
-  output from a long (24 hour+) survey-in. Setting the static position
-  immediately causes the receiver to begin outputting RTCM data (if
-  enabled), perfect for setting up your own RTCM NTRIP caster or CORS.
-
-  Feel like supporting open source hardware?
-  Buy a board from SparkFun!
-  ZED-F9P RTK2: https://www.sparkfun.com/products/15136
-  NEO-M8P RTK: https://www.sparkfun.com/products/15005
-
-  Hardware Connections:
-  Plug a Qwiic cable into the GNSS and a BlackBoard
-  If you don't have a platform with a Qwiic connection use the SparkFun Qwiic Breadboard Jumper (https://www.sparkfun.com/products/14425)
-  Open the serial monitor at 115200 baud to see the output
-*/
-
-#include <Wire.h> //Needed for I2C to GNSS
-
-#include <SparkFun_u-blox_GNSS_Arduino_Library.h> //http://librarymanager/All#SparkFun_u-blox_GNSS
-SFE_UBLOX_GNSS myGNSS;
-
-void setup()
-{
-  Serial.begin(115200); // You may need to increase this for high navigation rates!
-  while (!Serial)
-    ; //Wait for user to open terminal
-  Serial.println(F("SparkFun u-blox Example"));
-
-  Wire.begin();
-
-  //myGNSS.enableDebugging(); // Uncomment this line to enable debug messages
-
-  if (myGNSS.begin() == false) //Connect to the u-blox module using Wire port
-  {
-    Serial.println(F("u-blox GNSS not detected at default I2C address. Please check wiring. Freezing."));
-    while (1)
-      ;
-  }
-
-  myGNSS.setI2COutput(COM_TYPE_UBX); //Set the I2C port to output UBX only (turn off NMEA noise)
-
-  boolean success = true;
-
-  //-1280208.308,-4716803.847,4086665.811 is SparkFun HQ so...
-
-  //Units are cm so 1234 = 12.34m
-  //success &= myGNSS.setStaticPosition(-128020831, -471680385, 408666581);
-
-  //Units are cm with a high precision extension so -1234.5678 should be called: (-123456, -78)
-  success &= myGNSS.setStaticPosition(-128020830, -80, -471680384, -70, 408666581, 10); //With high precision 0.1mm parts
-
-  //We can also set via lat/long
-  //40.09029751,-105.18507900,1560.238
-  //success &= myGNSS.setStaticPosition(400902975, -1051850790, 156024, true); //True at end enables lat/long input
-  //success &= myGNSS.setStaticPosition(400902975, 10, -1051850790, 0, 156023, 80, true);
-
-  if (!success) Serial.println(F("At least one call to setStaticPosition failed!"));
-
-  //Now let's use getVals to read back the data
-  //long ecefX = myGNSS.getVal32(0x40030003);
-  //Serial.print("ecefX: ");
-  //Serial.println(ecefX);
-
-  Serial.println(F("Done!"));
-}
-
-void loop()
-{
-}
diff --git a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/ZED-F9P/Example13_autoHPPOSLLH/Example13_autoHPPOSLLH.ino b/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/ZED-F9P/Example13_autoHPPOSLLH/Example13_autoHPPOSLLH.ino
deleted file mode 100644
index ca7d7a2..0000000
--- a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/ZED-F9P/Example13_autoHPPOSLLH/Example13_autoHPPOSLLH.ino
+++ /dev/null
@@ -1,119 +0,0 @@
-/*
-  Configuring the GNSS to automatically send HPPOSLLH position reports over I2C
-  By: Paul Clark
-  Date: October 27th 2020
-
-  Based on an earlier example:
-  By: Nathan Seidle and Thorsten von Eicken
-  SparkFun Electronics
-  Date: January 3rd, 2019
-  License: MIT. See license file for more information but you can
-  basically do whatever you want with this code.
-
-  This example shows how to configure the U-Blox GNSS the send navigation reports automatically
-  and retrieving the latest one via getHPPOSLLH. This eliminates the blocking in getHPPOSLLH while the GNSS
-  produces a fresh navigation solution at the expense of returning a slighly old solution.
-
-  This can be used over serial or over I2C, this example shows the I2C use. With serial the GNSS
-  simply outputs the UBX_NAV_HPPOSLLH packet. With I2C it queues it into its internal I2C buffer (4KB in
-  size?) where it can be retrieved in the next I2C poll.
-
-  Feel like supporting open source hardware?
-  Buy a board from SparkFun!
-  ZED-F9P RTK2: https://www.sparkfun.com/products/15136
-  NEO-M8P RTK: https://www.sparkfun.com/products/15005
-
-  Hardware Connections:
-  Plug a Qwiic cable into the GNSS and a BlackBoard
-  If you don't have a platform with a Qwiic connection use the SparkFun Qwiic Breadboard Jumper (https://www.sparkfun.com/products/14425)
-  Open the serial monitor at 115200 baud to see the output
-*/
-
-#include <Wire.h> //Needed for I2C to GNSS
-
-#include <SparkFun_u-blox_GNSS_Arduino_Library.h> //http://librarymanager/All#SparkFun_u-blox_GNSS
-SFE_UBLOX_GNSS myGNSS;
-
-void setup()
-{
-  Serial.begin(115200);
-  while (!Serial); //Wait for user to open terminal
-  Serial.println("SparkFun u-blox Example");
-
-  Wire.begin();
-
-  //myGNSS.enableDebugging(); // Uncomment this line to enable lots of helpful debug messages
-  //myGNSS.enableDebugging(Serial, true); // Uncomment this line to enable the minimum of helpful debug messages
-
-  if (myGNSS.begin() == false) //Connect to the u-blox module using Wire port
-  {
-    Serial.println(F("u-blox GNSS not detected at default I2C address. Please check wiring. Freezing."));
-    while (1);
-  }
-
-  // Uncomment the next line if you want to reset your module back to the default settings with 1Hz navigation rate
-  //myGNSS.factoryDefault(); delay(5000);
-
-  myGNSS.setI2COutput(COM_TYPE_UBX); //Set the I2C port to output UBX only (turn off NMEA noise)
-  myGNSS.saveConfigSelective(VAL_CFG_SUBSEC_IOPORT); //Save the communications port settings to flash and BBR
-
-  myGNSS.setNavigationFrequency(1); //Produce one solution per second
-
-
-  // The acid test: all four of these combinations should work seamlessly :-)
-
-  //myGNSS.setAutoPVT(false); // Library will poll each reading
-  //myGNSS.setAutoHPPOSLLH(false); // Library will poll each reading
-
-  //myGNSS.setAutoPVT(true); // Tell the GPS to "send" each solution automatically
-  //myGNSS.setAutoHPPOSLLH(false); // Library will poll each reading
-
-  //myGNSS.setAutoPVT(false); // Library will poll each reading
-  //myGNSS.setAutoHPPOSLLH(true); // Tell the GPS to "send" each hi res solution automatically
-
-  myGNSS.setAutoPVT(true); // Tell the GPS to "send" each solution automatically
-  myGNSS.setAutoHPPOSLLH(true); // Tell the GPS to "send" each hi res solution automatically
-}
-
-void loop()
-{
-  // Calling getHPPOSLLH returns true if there actually is a fresh navigation solution available.
-  // Calling getPVT returns true if there actually is a fresh navigation solution available.
-  if ((myGNSS.getHPPOSLLH()) || (myGNSS.getPVT()))
-  {
-    Serial.println();
-
-    long highResLatitude = myGNSS.getHighResLatitude();
-    Serial.print(F("Hi Res Lat: "));
-    Serial.print(highResLatitude);
-
-    int highResLatitudeHp = myGNSS.getHighResLatitudeHp();
-    Serial.print(F(" "));
-    Serial.print(highResLatitudeHp);
-
-    long highResLongitude = myGNSS.getHighResLongitude();
-    Serial.print(F(" Hi Res Long: "));
-    Serial.print(highResLongitude);
-
-    int highResLongitudeHp = myGNSS.getHighResLongitudeHp();
-    Serial.print(F(" "));
-    Serial.print(highResLongitudeHp);
-
-    unsigned long horizAccuracy = myGNSS.getHorizontalAccuracy();
-    Serial.print(F(" Horiz accuracy: "));
-    Serial.print(horizAccuracy);
-
-    long latitude = myGNSS.getLatitude();
-    Serial.print(F(" Lat: "));
-    Serial.print(latitude);
-
-    long longitude = myGNSS.getLongitude();
-    Serial.print(F(" Long: "));
-    Serial.println(longitude);
-  }
-  else
-  {
-    Serial.print(".");
-    delay(50);
-  }
-}
diff --git a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/ZED-F9P/Example13_autoHPPOSLLH_with_Callback/Example13_autoHPPOSLLH_with_Callback.ino b/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/ZED-F9P/Example13_autoHPPOSLLH_with_Callback/Example13_autoHPPOSLLH_with_Callback.ino
deleted file mode 100644
index 94a6e75..0000000
--- a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/ZED-F9P/Example13_autoHPPOSLLH_with_Callback/Example13_autoHPPOSLLH_with_Callback.ino
+++ /dev/null
@@ -1,150 +0,0 @@
-/*
-  Configuring the GNSS to automatically send HPPOSLLH position reports over I2C
-  and uses callbacks to process and display the data automatically
-  By: Paul Clark
-  Date: October 27th 2020
-
-  Based on an earlier example:
-  By: Nathan Seidle and Thorsten von Eicken
-  SparkFun Electronics
-  Date: January 3rd, 2019
-  License: MIT. See license file for more information but you can
-  basically do whatever you want with this code.
-
-  This example shows how to configure the U-Blox GNSS the send navigation reports automatically
-  and and uses callbacks to process and display the data automatically. No more polling!
-
-  This can be used over serial or over I2C, this example shows the I2C use. With serial the GNSS
-  simply outputs the UBX_NAV_HPPOSLLH packet. With I2C it queues it into its internal I2C buffer (4KB in
-  size?) where it can be retrieved in the next I2C poll.
-
-  Feel like supporting open source hardware?
-  Buy a board from SparkFun!
-  ZED-F9P RTK2: https://www.sparkfun.com/products/15136
-  NEO-M8P RTK: https://www.sparkfun.com/products/15005
-
-  Hardware Connections:
-  Plug a Qwiic cable into the GNSS and a BlackBoard
-  If you don't have a platform with a Qwiic connection use the SparkFun Qwiic Breadboard Jumper (https://www.sparkfun.com/products/14425)
-  Open the serial monitor at 115200 baud to see the output
-*/
-
-#include <Wire.h> //Needed for I2C to GNSS
-
-#include <SparkFun_u-blox_GNSS_Arduino_Library.h> //http://librarymanager/All#SparkFun_u-blox_GNSS
-SFE_UBLOX_GNSS myGNSS;
-
-// Callback: printHPdata will be called when new NAV HPPOSLLH data arrives
-// See u-blox_structs.h for the full definition of UBX_NAV_HPPOSLLH_data_t
-//         _____  You can use any name you like for the callback. Use the same name when you call setAutoHPPOSLLHcallback
-//        /                  _____  This _must_ be UBX_NAV_HPPOSLLH_data_t
-//        |                 /                   _____ You can use any name you like for the struct
-//        |                 |                  /
-//        |                 |                  |
-void printHPdata(UBX_NAV_HPPOSLLH_data_t ubxDataStruct)
-{
-  Serial.println();
-
-  long highResLatitude = ubxDataStruct.lat;
-  Serial.print(F("Hi Res Lat: "));
-  Serial.print(highResLatitude);
-
-  int highResLatitudeHp = ubxDataStruct.latHp;
-  Serial.print(F(" "));
-  Serial.print(highResLatitudeHp);
-
-  long highResLongitude = ubxDataStruct.lon;
-  Serial.print(F(" Hi Res Long: "));
-  Serial.print(highResLongitude);
-
-  int highResLongitudeHp = ubxDataStruct.lonHp;
-  Serial.print(F(" "));
-  Serial.print(highResLongitudeHp);
-
-  float horizAccuracy = ((float)ubxDataStruct.hAcc) / 10000.0; // Convert hAcc from mm*0.1 to m
-  Serial.print(F(" Horiz accuracy: "));
-  Serial.println(horizAccuracy);
-}
-
-// Callback: printPVTdata will be called when new NAV PVT data arrives
-// See u-blox_structs.h for the full definition of UBX_NAV_PVT_data_t
-//         _____  You can use any name you like for the callback. Use the same name when you call setAutoPVTcallback
-//        /                  _____  This _must_ be UBX_NAV_PVT_data_t
-//        |                 /                _____ You can use any name you like for the struct
-//        |                 |               /
-//        |                 |               |
-void printPVTdata(UBX_NAV_PVT_data_t ubxDataStruct)
-{
-    Serial.println();
-
-    Serial.print(F("Time: ")); // Print the time
-    uint8_t hms = ubxDataStruct.hour; // Print the hours
-    if (hms < 10) Serial.print(F("0")); // Print a leading zero if required
-    Serial.print(hms);
-    Serial.print(F(":"));
-    hms = ubxDataStruct.min; // Print the minutes
-    if (hms < 10) Serial.print(F("0")); // Print a leading zero if required
-    Serial.print(hms);
-    Serial.print(F(":"));
-    hms = ubxDataStruct.sec; // Print the seconds
-    if (hms < 10) Serial.print(F("0")); // Print a leading zero if required
-    Serial.print(hms);
-    Serial.print(F("."));
-    unsigned long millisecs = ubxDataStruct.iTOW % 1000; // Print the milliseconds
-    if (millisecs < 100) Serial.print(F("0")); // Print the trailing zeros correctly
-    if (millisecs < 10) Serial.print(F("0"));
-    Serial.print(millisecs);
-
-    long latitude = ubxDataStruct.lat; // Print the latitude
-    Serial.print(F(" Lat: "));
-    Serial.print(latitude);
-
-    long longitude = ubxDataStruct.lon; // Print the longitude
-    Serial.print(F(" Long: "));
-    Serial.print(longitude);
-    Serial.print(F(" (degrees * 10^-7)"));
-
-    long altitude = ubxDataStruct.hMSL; // Print the height above mean sea level
-    Serial.print(F(" Height above MSL: "));
-    Serial.print(altitude);
-    Serial.println(F(" (mm)"));
-}
-
-void setup()
-{
-  Serial.begin(115200);
-  while (!Serial); //Wait for user to open terminal
-  Serial.println("SparkFun u-blox Example");
-
-  Wire.begin();
-
-  //myGNSS.enableDebugging(); // Uncomment this line to enable lots of helpful debug messages
-  //myGNSS.enableDebugging(Serial, true); // Uncomment this line to enable the minimum of helpful debug messages
-
-  if (myGNSS.begin() == false) //Connect to the u-blox module using Wire port
-  {
-    Serial.println(F("u-blox GNSS not detected at default I2C address. Please check wiring. Freezing."));
-    while (1);
-  }
-
-  // Uncomment the next line if you want to reset your module back to the default settings with 1Hz navigation rate
-  //myGNSS.factoryDefault(); delay(5000);
-
-  myGNSS.setI2COutput(COM_TYPE_UBX); //Set the I2C port to output UBX only (turn off NMEA noise)
-  myGNSS.saveConfigSelective(VAL_CFG_SUBSEC_IOPORT); //Save the communications port settings to flash and BBR
-
-  myGNSS.setNavigationFrequency(2); //Produce two solutions per second
-
-  myGNSS.setAutoPVTcallback(&printPVTdata); // Enable automatic NAV PVT messages with callback to printPVTdata
-
-  myGNSS.setAutoHPPOSLLHcallback(&printHPdata); // Enable automatic NAV HPPOSLLH messages with callback to printHPdata
-}
-
-void loop()
-{
-  myGNSS.checkUblox(); // Check for the arrival of new data and process it. You could set up a timer interrupt to do this for you.
-  myGNSS.checkCallbacks(); // Check if any callbacks are waiting to be processed.
-
-  Serial.print(".");
-  delay(50);
-}
diff --git a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/ZED-F9P/Example14_NTRIPServer/Example14_NTRIPServer.ino b/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/ZED-F9P/Example14_NTRIPServer/Example14_NTRIPServer.ino
deleted file mode 100644
index ca01530..0000000
--- a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/ZED-F9P/Example14_NTRIPServer/Example14_NTRIPServer.ino
+++ /dev/null
@@ -1,276 +0,0 @@
-/*
-  Note: compiles OK with v2.0 but is currently untested
-  
-  Use ESP32 WiFi to push RTCM data to RTK2Go (caster) as a Server
-  By: SparkFun Electronics / Nathan Seidle
-  Date: December 14th, 2020
-  License: MIT. See license file for more information but you can
-  basically do whatever you want with this code.
-
-  This example shows how to gather RTCM data over I2C and push it to a casting service over WiFi.
-  It's confusing, but the Arduino is acting as a 'server' to a 'caster'. In this case we will
-  use RTK2Go.com as our caster because it is free. A rover (car, surveyor stick, etc) can
-  then connect to RTK2Go as a 'client' and get the RTCM data it needs.
-
-  You will need to register your mountpoint here: http://www.rtk2go.com/new-reservation/
-  (They'll probably block the credentials we include in this example)
-
-  To see if your mountpoint is active go here: http://rtk2go.com:2101/
-
-  This is a proof of concept. Serving RTCM to a caster over WiFi is useful when you need to
-  set up a high-precision base station.
-
-  Feel like supporting open source hardware?
-  Buy a board from SparkFun!
-  ZED-F9P RTK2: https://www.sparkfun.com/products/16481
-  RTK Surveyor: https://www.sparkfun.com/products/17369
-
-  Hardware Connections:
-  Plug a Qwiic cable into the GNSS and a ESP32 Thing Plus
-  If you don't have a platform with a Qwiic connection use the SparkFun Qwiic Breadboard Jumper (https://www.sparkfun.com/products/14425)
-  Open the serial monitor at 115200 baud to see the output
-*/
-
-#include <WiFi.h>
-#include "secrets.h"
-WiFiClient client;
-
-#include <Wire.h> //Needed for I2C to GNSS
-#include <SparkFun_u-blox_GNSS_Arduino_Library.h> //http://librarymanager/All#SparkFun_u-blox_GNSS
-SFE_UBLOX_GNSS myGNSS;
-
-//Basic Connection settings to RTK2Go NTRIP Caster - See secrets for mount specific credentials
-//=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
-const uint16_t casterPort = 2101;
-const char * casterHost = "rtk2go.com";
-const char * ntrip_server_name = "SparkFun_RTK_Surveyor";
-
-long lastSentRTCM_ms = 0; //Time of last data pushed to socket
-int maxTimeBeforeHangup_ms = 10000; //If we fail to get a complete RTCM frame after 10s, then disconnect from caster
-
-uint32_t serverBytesSent = 0; //Just a running total
-//=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
-
-long lastReport_ms = 0; //Time of last report of bytes sent
-
-void setup()
-{
-  Serial.begin(115200); // You may need to increase this for high navigation rates!
-  while (!Serial)
-    ; //Wait for user to open terminal
-  Serial.println(F("SparkFun u-blox Example"));
-
-  Wire.begin();
-
-  //myGNSS.enableDebugging(); // Uncomment this line to enable debug messages
-
-  if (myGNSS.begin() == false) //Connect to the u-blox module using Wire port
-  {
-    Serial.println(F("u-blox GNSS not detected at default I2C address. Please check wiring. Freezing."));
-    while (1)
-      ;
-  }
-
-  Serial.print("Connecting to local WiFi");
-  WiFi.begin(ssid, password);
-  while (WiFi.status() != WL_CONNECTED) {
-    delay(500);
-    Serial.print(".");
-  }
-
-  Serial.print("\nWiFi connected with IP: ");
-  Serial.println(WiFi.localIP());
-
-  myGNSS.setI2COutput(COM_TYPE_UBX | COM_TYPE_NMEA | COM_TYPE_RTCM3); //UBX+RTCM3 is not a valid option so we enable all three.
-
-  myGNSS.setNavigationFrequency(1); //Set output in Hz. RTCM rarely benefits from >1Hz.
-
-  //Disable all NMEA sentences
-  bool response = true;
-  response &= myGNSS.disableNMEAMessage(UBX_NMEA_GGA, COM_PORT_I2C);
-  response &= myGNSS.disableNMEAMessage(UBX_NMEA_GSA, COM_PORT_I2C);
-  response &= myGNSS.disableNMEAMessage(UBX_NMEA_GSV, COM_PORT_I2C);
-  response &= myGNSS.disableNMEAMessage(UBX_NMEA_RMC, COM_PORT_I2C);
-  response &= myGNSS.disableNMEAMessage(UBX_NMEA_GST, COM_PORT_I2C);
-  response &= myGNSS.disableNMEAMessage(UBX_NMEA_GLL, COM_PORT_I2C);
-  response &= myGNSS.disableNMEAMessage(UBX_NMEA_VTG, COM_PORT_I2C);
-
-  if (response == false)
-  {
-    Serial.println(F("Failed to disable NMEA. Freezing..."));
-    while (1);
-  }
-  else
-    Serial.println(F("NMEA disabled"));
-
-  //Enable necessary RTCM sentences
-  response &= myGNSS.enableRTCMmessage(UBX_RTCM_1005, COM_PORT_I2C, 1); //Enable message 1005 to output through UART2, message every second
-  response &= myGNSS.enableRTCMmessage(UBX_RTCM_1074, COM_PORT_I2C, 1);
-  response &= myGNSS.enableRTCMmessage(UBX_RTCM_1084, COM_PORT_I2C, 1);
-  response &= myGNSS.enableRTCMmessage(UBX_RTCM_1094, COM_PORT_I2C, 1);
-  response &= myGNSS.enableRTCMmessage(UBX_RTCM_1124, COM_PORT_I2C, 1);
-  response &= myGNSS.enableRTCMmessage(UBX_RTCM_1230, COM_PORT_I2C, 10); //Enable message every 10 seconds
-
-  if (response == false)
-  {
-    Serial.println(F("Failed to enable RTCM. Freezing..."));
-    while (1);
-  }
-  else
-    Serial.println(F("RTCM sentences enabled"));
-
-  //-1280208.308,-4716803.847,4086665.811 is SparkFun HQ so...
-  //Units are cm with a high precision extension so -1234.5678 should be called: (-123456, -78)
-  //For more infomation see Example12_setStaticPosition
-  //Note: If you leave these coordinates in place and setup your antenna *not* at SparkFun, your receiver
-  //will be very confused and fail to generate correction data because, well, you aren't at SparkFun...
-  //See this tutorial on getting PPP coordinates: https://learn.sparkfun.com/tutorials/how-to-build-a-diy-gnss-reference-station/all
-  response &= myGNSS.setStaticPosition(-128020830, -80, -471680384, -70, 408666581, 10); //With high precision 0.1mm parts
-  if (response == false)
-  {
-    Serial.println(F("Failed to enter static position. Freezing..."));
-    while (1);
-  }
-  else
-    Serial.println(F("Static position set"));
-
-  //You could instead do a survey-in but it takes much longer to start generating RTCM data. See Example4_BaseWithLCD
-  //myGNSS.enableSurveyMode(60, 5.000); //Enable Survey in, 60 seconds, 5.0m
-
-  if (myGNSS.saveConfiguration() == false) //Save the current settings to flash and BBR
-    Serial.println(F("Module failed to save."));
-
-  Serial.println(F("Module configuration complete"));
-}
-
-void loop()
-{
-  if (Serial.available()) beginServing();
-
-  Serial.println(F("Press any key to start serving."));
-
-  delay(1000);
-}
-
-void beginServing()
-{
-  Serial.println("Xmit to RTK2Go. Press any key to stop");
-  delay(10); //Wait for any serial to arrive
-  while (Serial.available()) Serial.read(); //Flush
-
-  while (Serial.available() == 0)
-  {
-    //Connect if we are not already
-    if (client.connected() == false)
-    {
-      Serial.printf("Opening socket to %s\n", casterHost);
-
-      if (client.connect(casterHost, casterPort) == true) //Attempt connection
-      {
-        Serial.printf("Connected to %s:%d\n", casterHost, casterPort);
-
-        const int SERVER_BUFFER_SIZE  = 512;
-        char serverBuffer[SERVER_BUFFER_SIZE];
-
-        snprintf(serverBuffer, SERVER_BUFFER_SIZE, "SOURCE %s /%s\r\nSource-Agent: NTRIP %s/%s\r\n\r\n",
-                 mntpnt_pw, mntpnt, ntrip_server_name, "App Version 1.0");
-
-        Serial.printf("Sending credentials:\n%s\n", serverBuffer);
-        client.write(serverBuffer, strlen(serverBuffer));
-
-        //Wait for response
-        unsigned long timeout = millis();
-        while (client.available() == 0)
-        {
-          if (millis() - timeout > 5000)
-          {
-            Serial.println(">>> Client Timeout !");
-            client.stop();
-            return;
-          }
-          delay(10);
-        }
-
-        //Check reply
-        bool connectionSuccess = false;
-        char response[512];
-        int responseSpot = 0;
-        while (client.available())
-        {
-          response[responseSpot++] = client.read();
-          if (strstr(response, "200") > 0) //Look for 'ICY 200 OK'
-            connectionSuccess = true;
-          if (responseSpot == 512 - 1) break;
-        }
-        response[responseSpot] = '\0';
-
-        if (connectionSuccess == false)
-        {
-          Serial.printf("Failed to connect to RTK2Go: %s", response);
-        }
-      } //End attempt to connect
-      else
-      {
-        Serial.println("Connection to host failed");
-      }
-    } //End connected == false
-
-    if (client.connected() == true)
-    {
-      delay(10);
-      while (Serial.available()) Serial.read(); //Flush any endlines or carriage returns
-
-      lastReport_ms = millis();
-      lastSentRTCM_ms = millis();
-
-      //This is the main sending loop. We scan for new ublox data but processRTCM() is where the data actually gets sent out.
-      while (1)
-      {
-        if (Serial.available()) break;
-
-        myGNSS.checkUblox(); //See if new data is available. Process bytes as they come in.
-
-        //Close socket if we don't have new data for 10s
-        //RTK2Go will ban your IP address if you abuse it. See http://www.rtk2go.com/how-to-get-your-ip-banned/
-        //So let's not leave the socket open/hanging without data
-        if (millis() - lastSentRTCM_ms > maxTimeBeforeHangup_ms)
-        {
-          Serial.println("RTCM timeout. Disconnecting...");
-          client.stop();
-          return;
-        }
-
-        delay(10);
-
-        //Report some statistics every 250
-        if (millis() - lastReport_ms > 250)
-        {
-          lastReport_ms += 250;
-          Serial.printf("Total sent: %d\n", serverBytesSent);
-        }
-      }
-    }
-
-    delay(10);
-  }
-
-  Serial.println("User pressed a key");
-  Serial.println("Disconnecting...");
-  client.stop();
-
-  delay(10);
-  while (Serial.available()) Serial.read(); //Flush any endlines or carriage returns
-}
-
-//This function gets called from the SparkFun u-blox Arduino Library.
-//As each RTCM byte comes in you can specify what to do with it
-//Useful for passing the RTCM correction data to a radio, Ntrip broadcaster, etc.
-void SFE_UBLOX_GNSS::processRTCM(uint8_t incoming)
-{
-  if (client.connected() == true)
-  {
-    client.write(incoming); //Send this byte to socket
-    serverBytesSent++;
-    lastSentRTCM_ms = millis();
-  }
-}
diff --git a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/ZED-F9P/Example14_NTRIPServer/secrets.h b/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/ZED-F9P/Example14_NTRIPServer/secrets.h
deleted file mode 100644
index 5dcd50e..0000000
--- a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/ZED-F9P/Example14_NTRIPServer/secrets.h
+++ /dev/null
@@ -1,7 +0,0 @@
-//Your WiFi credentials
-const char* ssid = "TRex";
-const char* password =  "hasBigTeeth";
-
-//Your RTK2GO mount point credentials
-const char* mntpnt_pw = "WR5wRo4H";
-const char* mntpnt = "bldr_dwntwn2";
diff --git a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/ZED-F9P/Example1_GetPositionAccuracy/Example1_GetPositionAccuracy.ino b/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/ZED-F9P/Example1_GetPositionAccuracy/Example1_GetPositionAccuracy.ino
deleted file mode 100644
index 05270cb..0000000
--- a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/ZED-F9P/Example1_GetPositionAccuracy/Example1_GetPositionAccuracy.ino
+++ /dev/null
@@ -1,76 +0,0 @@
-/*
-  Get the high position accuracy of the RTK enhanced position from HPPOSECEF
-  By: Nathan Seidle
-  SparkFun Electronics
-  Date: January 3rd, 2019
-  License: MIT. See license file for more information but you can
-  basically do whatever you want with this code.
-
-  This example shows how to inspect the accuracy of the high-precision
-  positional solution.
-
-  Feel like supporting open source hardware?
-  Buy a board from SparkFun!
-  ZED-F9P RTK2: https://www.sparkfun.com/products/15136
-  NEO-M8P RTK: https://www.sparkfun.com/products/15005
-  SAM-M8Q: https://www.sparkfun.com/products/15106
-
-  Hardware Connections:
-  Plug a Qwiic cable into the GNSS and a BlackBoard
-  If you don't have a platform with a Qwiic connection use the SparkFun Qwiic Breadboard Jumper (https://www.sparkfun.com/products/14425)
-  Open the serial monitor at 115200 baud to see the output
-*/
-
-#include <Wire.h> //Needed for I2C to GNSS
-
-#include <SparkFun_u-blox_GNSS_Arduino_Library.h> //http://librarymanager/All#SparkFun_u-blox_GNSS
-SFE_UBLOX_GNSS myGNSS;
-
-long lastTime = 0; //Simple local timer. Limits amount if I2C traffic to u-blox module.
-
-void setup()
-{
-  Serial.begin(115200);
-  while (!Serial); //Wait for user to open terminal
-  Serial.println("SparkFun u-blox Example");
-
-  Wire.begin();
-
-  if (myGNSS.begin() == false) //Connect to the u-blox module using Wire port
-  {
-    Serial.println(F("u-blox GNSS not detected at default I2C address. Please check wiring. Freezing."));
-    while (1);
-  }
-
-  myGNSS.setI2COutput(COM_TYPE_UBX); //Set the I2C port to output UBX only (turn off NMEA noise)
-  //myGNSS.saveConfiguration(); //Optional: Save the current settings to flash and BBR
-}
-
-void loop()
-{
-  //Query module only every second. Doing it more often will just cause I2C traffic.
-  //The module only responds when a new position is available
-  if (millis() - lastTime > 1000)
-  {
-    lastTime = millis(); //Update the timer
-
-    long latitude = myGNSS.getLatitude();
-    Serial.print(F("Lat: "));
-    Serial.print(latitude);
-
-    long longitude = myGNSS.getLongitude();
-    Serial.print(F(" Long: "));
-    Serial.print(longitude);
-    Serial.print(F(" (degrees * 10^-7)"));
-
-    long altitude = myGNSS.getAltitude();
-    Serial.print(F(" Alt: "));
-    Serial.print(altitude);
-    Serial.print(F(" (mm)"));
-
-    long accuracy = myGNSS.getPositionAccuracy();
-    Serial.print(F(" 3D Positional Accuracy: "));
-    Serial.print(accuracy);
-    Serial.println(F(" (mm)"));
-  }
-}
diff --git a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/ZED-F9P/Example2_ValConfigurationMethod/Example2_ValConfigurationMethod.ino b/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/ZED-F9P/Example2_ValConfigurationMethod/Example2_ValConfigurationMethod.ino
deleted file mode 100644
index a2dac0b..0000000
--- a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/ZED-F9P/Example2_ValConfigurationMethod/Example2_ValConfigurationMethod.ino
+++ /dev/null
@@ -1,63 +0,0 @@
-/*
-  Configuring u-blox Module using new VALGET / VALSET / VALDEL methods
-
-  Please see u-blox_config_keys.h for the definitions of _all_ of the configuration keys
-  
-  By: Nathan Seidle
-  SparkFun Electronics
-  Date: January 3rd, 2019
-  License: MIT. See license file for more information but you can
-  basically do whatever you want with this code.
-
-  u-blox deprecated many -CFG messages and replaced them with new
-  VALGET, VALSET, VALDEL methods. This shows the basics of how to use
-  these methods.
-
-  Leave NMEA parsing behind. Now you can simply ask the module for the datums you want!
-
-  Feel like supporting open source hardware?
-  Buy a board from SparkFun!
-  ZED-F9P RTK2: https://www.sparkfun.com/products/15136
-  NEO-M8P RTK: https://www.sparkfun.com/products/15005
-  SAM-M8Q: https://www.sparkfun.com/products/15106
-
-  Hardware Connections:
-  Plug a Qwiic cable into the GNSS and a BlackBoard
-  If you don't have a platform with a Qwiic connection use the SparkFun Qwiic Breadboard Jumper (https://www.sparkfun.com/products/14425)
-  Open the serial monitor at 115200 baud to see the output
-*/
-
-#include <Wire.h> //Needed for I2C to GNSS
-
-#include <SparkFun_u-blox_GNSS_Arduino_Library.h> //http://librarymanager/All#SparkFun_u-blox_GNSS
-SFE_UBLOX_GNSS myGNSS;
-
-long lastTime = 0; //Simple local timer. Limits amount if I2C traffic to u-blox module.
-
-void setup()
-{
-  Serial.begin(115200);
-  while (!Serial); //Wait for user to open terminal
-  Serial.println("SparkFun u-blox Example");
-
-  Wire.begin();
-
-  if (myGNSS.begin() == false) //Connect to the u-blox module using Wire port
-  {
-    Serial.println(F("u-blox GNSS not detected at default I2C address. Please check wiring. Freezing."));
-    while (1);
-  }
-
-  byte response;
-  response = myGNSS.getVal8(UBLOX_CFG_I2C_ADDRESS, VAL_LAYER_RAM); // Get the I2C address (see u-blox_config_keys.h for details)
-  Serial.print(F("I2C Address: 0x"));
-  Serial.println(response >> 1, HEX); //We have to shift by 1 to get the common '7-bit' I2C address format
-
-  response = myGNSS.getVal8(UBLOX_CFG_I2COUTPROT_NMEA, VAL_LAYER_RAM); // Get the flag indicating is NMEA should be output on I2C
-  Serial.print(F("Output NMEA over I2C port: 0x"));
-  Serial.print(response, HEX);
-}
-
-void loop()
-{
-}
diff --git a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/ZED-F9P/Example3_StartRTCMBase/Example3_StartRTCMBase.ino b/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/ZED-F9P/Example3_StartRTCMBase/Example3_StartRTCMBase.ino
deleted file mode 100644
index d3d13be..0000000
--- a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/ZED-F9P/Example3_StartRTCMBase/Example3_StartRTCMBase.ino
+++ /dev/null
@@ -1,194 +0,0 @@
-/*
-  Send UBX binary commands to enable RTCM sentences on u-blox ZED-F9P module
-  By: Nathan Seidle
-  SparkFun Electronics
-  Date: January 9th, 2019
-  License: MIT. See license file for more information but you can
-  basically do whatever you want with this code.
-
-  This example does all steps to configure and enable a ZED-F9P as a base station:
-    Begin Survey-In
-    Once we've achieved 2m accuracy and 300s have passed, survey is complete
-    Enable six RTCM messages
-    Begin outputting RTCM bytes
-
-  Feel like supporting open source hardware?
-  Buy a board from SparkFun!
-  ZED-F9P RTK2: https://www.sparkfun.com/products/15136
-  NEO-M8P RTK: https://www.sparkfun.com/products/15005
-  SAM-M8Q: https://www.sparkfun.com/products/15106
-
-  Hardware Connections:
-  Plug a Qwiic cable into the GNSS and a BlackBoard
-  If you don't have a platform with a Qwiic connection use the SparkFun Qwiic Breadboard Jumper (https://www.sparkfun.com/products/14425)
-  Open the serial monitor at 115200 baud to see the output
-*/
-
-#include <Wire.h> //Needed for I2C to GNSS
-
-#include <SparkFun_u-blox_GNSS_Arduino_Library.h> //http://librarymanager/All#SparkFun_u-blox_GNSS
-SFE_UBLOX_GNSS myGNSS;
-
-//#define USE_SERIAL1 // Uncomment this line to push the RTCM data to Serial1
-
-void setup()
-{
-  Serial.begin(115200);
-  while (!Serial); //Wait for user to open terminal
-  Serial.println(F("u-blox Base Station example"));
-
-#ifdef USE_SERIAL1
-  // If our board supports it, we can output the RTCM data on Serial1
-  Serial1.begin(115200);
-#endif
-
-  Wire.begin();
-  Wire.setClock(400000); //Increase I2C clock speed to 400kHz
-
-  if (myGNSS.begin() == false) //Connect to the u-blox module using Wire port
-  {
-    Serial.println(F("u-blox GNSS not detected at default I2C address. Please check wiring. Freezing."));
-    while (1);
-  }
-
-  // Uncomment the next line if you want to reset your module back to the default settings with 1Hz navigation rate
-  //myGNSS.factoryDefault(); delay(5000);
-
-  myGNSS.setI2COutput(COM_TYPE_UBX); //Set the I2C port to output UBX only (turn off NMEA noise)
-  myGNSS.saveConfigSelective(VAL_CFG_SUBSEC_IOPORT); //Save the communications port settings to flash and BBR
-
-  while (Serial.available()) Serial.read(); //Clear any latent chars in serial buffer
-  Serial.println(F("Press any key to send commands to begin Survey-In"));
-  while (Serial.available() == 0) ; //Wait for user to press a key
-
-  boolean response = true;
-  response &= myGNSS.enableRTCMmessage(UBX_RTCM_1005, COM_PORT_I2C, 1); //Enable message 1005 to output through I2C port, message every second
-  response &= myGNSS.enableRTCMmessage(UBX_RTCM_1074, COM_PORT_I2C, 1);
-  response &= myGNSS.enableRTCMmessage(UBX_RTCM_1084, COM_PORT_I2C, 1);
-  response &= myGNSS.enableRTCMmessage(UBX_RTCM_1094, COM_PORT_I2C, 1);
-  response &= myGNSS.enableRTCMmessage(UBX_RTCM_1124, COM_PORT_I2C, 1);
-  response &= myGNSS.enableRTCMmessage(UBX_RTCM_1230, COM_PORT_I2C, 10); //Enable message every 10 seconds
-
-  //Use COM_PORT_UART1 for the above six messages to direct RTCM messages out UART1
-  //COM_PORT_UART2, COM_PORT_USB, COM_PORT_SPI are also available
-  //For example: response &= myGNSS.enableRTCMmessage(UBX_RTCM_1005, COM_PORT_UART1, 10);
-
-  if (response == true)
-  {
-    Serial.println(F("RTCM messages enabled"));
-  }
-  else
-  {
-    Serial.println(F("RTCM failed to enable. Are you sure you have an ZED-F9P?"));
-    while (1); //Freeze
-  }
-
-  //Check if Survey is in Progress before initiating one
-  // From v2.0, the data from getSurveyStatus (UBX-NAV-SVIN) is returned in UBX_NAV_SVIN_t packetUBXNAVSVIN
-  // Please see u-blox_structs.h for the full definition of UBX_NAV_SVIN_t
-  // You can either read the data from packetUBXNAVSVIN directly
-  // or can use the helper functions: getSurveyInActive; getSurveyInValid; getSurveyInObservationTime; and getSurveyInMeanAccuracy
-  response = myGNSS.getSurveyStatus(2000); //Query module for SVIN status with 2000ms timeout (request can take a long time)
-  
-  if (response == false) // Check if fresh data was received
-  {
-    Serial.println(F("Failed to get Survey In status"));
-    while (1); //Freeze
-  }
-
-  if (myGNSS.getSurveyInActive() == true) // Use the helper function
-  //if (myGNSS.packetUBXNAVSVIN->data.active > 0) // Or we could read active directly
-  {
-    Serial.print(F("Survey already in progress."));
-  }
-  else
-  {
-    //Start survey
-    //The ZED-F9P is slightly different than the NEO-M8P. See the Integration manual 3.5.8 for more info.
-    //response = myGNSS.enableSurveyMode(300, 2.000); //Enable Survey in on NEO-M8P, 300 seconds, 2.0m
-    response = myGNSS.enableSurveyMode(60, 5.000); //Enable Survey in, 60 seconds, 5.0m
-    if (response == false)
-    {
-      Serial.println(F("Survey start failed. Freezing..."));
-      while (1);
-    }
-    Serial.println(F("Survey started. This will run until 60s has passed and less than 5m accuracy is achieved."));
-  }
-
-  while(Serial.available()) Serial.read(); //Clear buffer
-  
-  //Begin waiting for survey to complete
-  while (myGNSS.getSurveyInValid() == false) // Call the helper function
-  //while (myGNSS.packetUBXNAVSVIN->data.valid == 0) // Or we could read valid directly
-  {
-    if(Serial.available())
-    {
-      byte incoming = Serial.read();
-      if(incoming == 'x')
-      {
-        //Stop survey mode
-        response = myGNSS.disableSurveyMode(); //Disable survey
-        Serial.println(F("Survey stopped"));
-        break;
-      }
-    }
-
-    // From v2.0, the data from getSurveyStatus (UBX-NAV-SVIN) is returned in UBX_NAV_SVIN_t packetUBXNAVSVIN
-    // Please see u-blox_structs.h for the full definition of UBX_NAV_SVIN_t
-    // You can either read the data from packetUBXNAVSVIN directly
-    // or can use the helper functions: getSurveyInActive; getSurveyInValid; getSurveyInObservationTime; and getSurveyInMeanAccuracy
-    response = myGNSS.getSurveyStatus(2000); //Query module for SVIN status with 2000ms timeout (req can take a long time)
-    
-    if (response == true) // Check if fresh data was received
-    {
-      Serial.print(F("Press x to end survey - "));
-      Serial.print(F("Time elapsed: "));
-      Serial.print((String)myGNSS.getSurveyInObservationTime()); // Call the helper function
-      Serial.print(F(" ("));
-      Serial.print((String)myGNSS.packetUBXNAVSVIN->data.dur); // Read the survey-in duration directly from packetUBXNAVSVIN
-
-      Serial.print(F(") Accuracy: "));
-      Serial.print((String)myGNSS.getSurveyInMeanAccuracy()); // Call the helper function
-      Serial.print(F(" ("));
-      // Read the mean accuracy directly from packetUBXNAVSVIN and manually convert from mm*0.1 to m
-      float meanAcc = ((float)myGNSS.packetUBXNAVSVIN->data.meanAcc) / 10000.0;
-      Serial.print((String)meanAcc); 
-      Serial.println(F(")"));
-    }
-    else
-    {
-      Serial.println(F("SVIN request failed"));
-    }
-
-    delay(1000);
-  }
-  Serial.println(F("Survey valid!"));
-
-  Serial.println(F("Base survey complete! RTCM now broadcasting."));
-
-  myGNSS.setI2COutput(COM_TYPE_UBX | COM_TYPE_RTCM3); //Set the I2C port to output UBX and RTCM sentences (not really an option, turns on NMEA as well)
-}
-
-void loop()
-{
-  myGNSS.checkUblox(); //See if new data is available. Process bytes as they come in.
-
-  delay(250); //Don't pound too hard on the I2C bus
-}
-
-//This function gets called from the SparkFun u-blox Arduino Library.
-//As each RTCM byte comes in you can specify what to do with it
-//Useful for passing the RTCM correction data to a radio, Ntrip broadcaster, etc.
-void SFE_UBLOX_GNSS::processRTCM(uint8_t incoming)
-{
-#ifdef USE_SERIAL1
-  //Push the RTCM data to Serial1
-  Serial1.write(incoming);
-#endif
-
-  //Pretty-print the HEX values to Serial
-  if (myGNSS.rtcmFrameCounter % 16 == 0) Serial.println();
-  Serial.print(F(" "));
-  if (incoming < 0x10) Serial.print(F("0"));
-  Serial.print(incoming, HEX);
-}
diff --git a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/ZED-F9P/Example4_BaseWithLCD/Example4_BaseWithLCD.ino b/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/ZED-F9P/Example4_BaseWithLCD/Example4_BaseWithLCD.ino
deleted file mode 100644
index dfa025a..0000000
--- a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/ZED-F9P/Example4_BaseWithLCD/Example4_BaseWithLCD.ino
+++ /dev/null
@@ -1,210 +0,0 @@
-/*
-  Note: compiles OK with v2.0 but is untested. The previous example works fine though.
-  
-  Send UBX binary commands to enable RTCM sentences on u-blox ZED-F9P module
-  By: Nathan Seidle
-  SparkFun Electronics
-  Date: January 9th, 2019
-  License: MIT. See license file for more information but you can
-  basically do whatever you want with this code.
-
-  This example does all steps to configure and enable a ZED-F9P as a base station:
-    Begin Survey-In
-    Once we've achieved 2m accuracy and 300s have passed, survey is complete
-    Enable six RTCM messages
-    Begin outputting RTCM bytes
-
-  Feel like supporting open source hardware?
-  Buy a board from SparkFun!
-  ZED-F9P RTK2: https://www.sparkfun.com/products/15136
-  NEO-M8P RTK: https://www.sparkfun.com/products/15005
-  SAM-M8Q: https://www.sparkfun.com/products/15106
-
-  Hardware Connections:
-  Plug a Qwiic cable into the GNSS and a BlackBoard
-  Plug a SerLCD onto the Qwiic bus
-  If you don't have a platform with a Qwiic connection use the SparkFun Qwiic Breadboard Jumper (https://www.sparkfun.com/products/14425)
-  Watch the output on the LCD or open the serial monitor at 115200 baud to see the output
-*/
-
-#define STAT_LED 13
-
-#include <Wire.h> //Needed for I2C to GNSS
-
-#include <SparkFun_u-blox_GNSS_Arduino_Library.h> //Click here to get the library: http://librarymanager/All#SparkFun_u-blox_GNSS
-SFE_UBLOX_GNSS myGNSS;
-
-#include <SerLCD.h> //Click here to get the library: http://librarymanager/All#SparkFun_SerLCD
-SerLCD lcd;         // Initialize the library with default I2C address 0x72
-
-void setup()
-{
-  Serial.begin(115200);
-  while (!Serial)
-    ; //Wait for user to open terminal
-  Serial.println(F("u-blox GNSS I2C Test"));
-
-  Wire.begin();
-
-  pinMode(STAT_LED, OUTPUT);
-  digitalWrite(STAT_LED, LOW);
-
-  lcd.begin(Wire);            //Set up the LCD for Serial communication at 9600bps
-  lcd.setBacklight(0x4B0082); //indigo, a kind of dark purplish blue
-  lcd.clear();
-  lcd.print(F("LCD Ready"));
-
-  myGNSS.begin(Wire);
-  if (myGNSS.isConnected() == false)
-  {
-    Serial.println(F("u-blox GNSS not detected at default I2C address. Please check wiring. Freezing."));
-    lcd.setCursor(0, 1);
-    lcd.print(F("No GNSS detected"));
-    while (1)
-      ;
-  }
-
-  Wire.setClock(400000); //Increase I2C clock speed to 400kHz
-
-  lcd.setCursor(0, 1);
-  lcd.print("GNSS Detected");
-
-  //myGNSS.setI2COutput(COM_TYPE_RTCM3); //Set the I2C port to output RTCM3 sentences (turn off NMEA noise)
-  myGNSS.setI2COutput(COM_TYPE_UBX); //Set the I2C port to output UBX sentences (turn off NMEA noise)
-  myGNSS.saveConfigSelective(VAL_CFG_SUBSEC_IOPORT); //Save the communications port settings to flash and BBR
-
-  boolean response = true;
-  response &= myGNSS.enableRTCMmessage(UBX_RTCM_1005, COM_PORT_I2C, 1); //Enable message 1005 to output through I2C port, message every second
-  response &= myGNSS.enableRTCMmessage(UBX_RTCM_1074, COM_PORT_I2C, 1);
-  response &= myGNSS.enableRTCMmessage(UBX_RTCM_1084, COM_PORT_I2C, 1);
-  response &= myGNSS.enableRTCMmessage(UBX_RTCM_1094, COM_PORT_I2C, 1);
-  response &= myGNSS.enableRTCMmessage(UBX_RTCM_1124, COM_PORT_I2C, 1);
-  response &= myGNSS.enableRTCMmessage(UBX_RTCM_1230, COM_PORT_I2C, 10); //Enable message every 10 seconds
-  if (response == true)
-  {
-    Serial.println(F("RTCM messages enabled"));
-  }
-  else
-  {
-    Serial.println(F("RTCM failed to enable. Are you sure you have an ZED-F9P? Freezing."));
-    while (1)
-      ; //Freeze
-  }
-
-  //Check if Survey is in Progress before initiating one
-  // From v2.0, the data from getSurveyStatus (UBX-NAV-SVIN) is returned in UBX_NAV_SVIN_t packetUBXNAVSVIN
-  // Please see u-blox_structs.h for the full definition of UBX_NAV_SVIN_t
-  // You can either read the data from packetUBXNAVSVIN directly
-  // or can use the helper functions: getSurveyInActive; getSurveyInValid; getSurveyInObservationTime; and getSurveyInMeanAccuracy
-  response = myGNSS.getSurveyStatus(2000); //Query module for SVIN status with 2000ms timeout (request can take a long time)
-  if (response == false)
-  {
-    Serial.println(F("Failed to get Survey In status. Freezing."));
-    while (1)
-      ; //Freeze
-  }
-
-  if (myGNSS.getSurveyInActive() == true) // Use the helper function
-  {
-    Serial.print(F("Survey already in progress."));
-    lcd.setCursor(0, 2);
-    lcd.print(F("Survey already going"));
-  }
-  else
-  {
-    //Start survey
-    response = myGNSS.enableSurveyMode(60, 5.000); //Enable Survey in, 60 seconds, 5.0m
-    if (response == false)
-    {
-      Serial.println(F("Survey start failed"));
-      lcd.setCursor(0, 3);
-      lcd.print(F("Survey start failed. Freezing."));
-      while (1)
-        ;
-    }
-    Serial.println(F("Survey started. This will run until 60s has passed and less than 5m accuracy is achieved."));
-  }
-
-  while (Serial.available())
-    Serial.read(); //Clear buffer
-
-  lcd.clear();
-  lcd.print(F("Survey in progress"));
-
-  //Begin waiting for survey to complete
-  while (myGNSS.getSurveyInValid() == false) // Call the helper function
-  {
-    if (Serial.available())
-    {
-      byte incoming = Serial.read();
-      if (incoming == 'x')
-      {
-        //Stop survey mode
-        response = myGNSS.disableSurveyMode(); //Disable survey
-        Serial.println(F("Survey stopped"));
-        break;
-      }
-    }
-
-    // From v2.0, the data from getSurveyStatus (UBX-NAV-SVIN) is returned in UBX_NAV_SVIN_t packetUBXNAVSVIN
-    // Please see u-blox_structs.h for the full definition of UBX_NAV_SVIN_t
-    // You can either read the data from packetUBXNAVSVIN directly
-    // or can use the helper functions: getSurveyInActive; getSurveyInValid; getSurveyInObservationTime; and getSurveyInMeanAccuracy
-    response = myGNSS.getSurveyStatus(2000); //Query module for SVIN status with 2000ms timeout (req can take a long time)
-    if (response == true)
-    {
-      Serial.print(F("Press x to end survey - "));
-      Serial.print(F("Time elapsed: "));
-      Serial.print((String)myGNSS.getSurveyInObservationTime()); // Call the helper function
-
-      lcd.setCursor(0, 1);
-      lcd.print(F("Elapsed: "));
-      lcd.print((String)myGNSS.getSurveyInObservationTime()); // Call the helper function
-
-      Serial.print(F(" Accuracy: "));
-      Serial.print((String)myGNSS.getSurveyInMeanAccuracy()); // Call the helper function
-      Serial.println();
-
-      lcd.setCursor(0, 2);
-      lcd.print(F("Accuracy: "));
-      lcd.print((String)myGNSS.getSurveyInMeanAccuracy()); // Call the helper function
-    }
-    else
-    {
-      Serial.println(F("SVIN request failed"));
-    }
-
-    delay(1000);
-  }
-  Serial.println(F("Survey valid!"));
-
-  Serial.println(F("Base survey complete! RTCM now broadcasting."));
-  lcd.clear();
-  lcd.print(F("Transmitting RTCM"));
-
-  myGNSS.setI2COutput(COM_TYPE_UBX | COM_TYPE_RTCM3); //Set the I2C port to output UBX and RTCM sentences (not really an option, turns on NMEA as well)
-  
-}
-
-void loop()
-{
-  myGNSS.checkUblox(); //See if new data is available. Process bytes as they come in.
-
-  //Do anything you want. Call checkUblox() every second. ZED-F9P has TX buffer of 4k bytes.
-
-  delay(250); //Don't pound too hard on the I2C bus
-}
-
-//This function gets called from the SparkFun u-blox Arduino Library.
-//As each RTCM byte comes in you can specify what to do with it
-//Useful for passing the RTCM correction data to a radio, Ntrip broadcaster, etc.
-void SFE_UBLOX_GNSS::processRTCM(uint8_t incoming)
-{
-  //Let's just pretty-print the HEX values for now
-  if (myGNSS.rtcmFrameCounter % 16 == 0)
-    Serial.println();
-  Serial.print(" ");
-  if (incoming < 0x10)
-    Serial.print("0");
-  Serial.print(incoming, HEX);
-}
diff --git a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/ZED-F9P/Example5_RelativePositioningInformation/Example5_RelativePositioningInformation.ino b/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/ZED-F9P/Example5_RelativePositioningInformation/Example5_RelativePositioningInformation.ino
deleted file mode 100644
index 3990f89..0000000
--- a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/ZED-F9P/Example5_RelativePositioningInformation/Example5_RelativePositioningInformation.ino
+++ /dev/null
@@ -1,165 +0,0 @@
-/*
-  Send UBX binary commands to enable RTCM sentences on u-blox ZED-F9P module
-  By: Nathan Seidle
-  SparkFun Electronics
-  Date: January 9th, 2019
-  License: MIT. See license file for more information but you can
-  basically do whatever you want with this code.
-
-  This example shows how to query the module for RELPOS information in the NED frame.
-  It assumes you already have RTCM correction data being fed to the receiver.
-
-  Feel like supporting open source hardware?
-  Buy a board from SparkFun!
-  ZED-F9P RTK2: https://www.sparkfun.com/products/15136
-  NEO-M8P RTK: https://www.sparkfun.com/products/15005
-  SAM-M8Q: https://www.sparkfun.com/products/15106
-
-  Hardware Connections:
-  Plug a Qwiic cable into the GNSS and a RedBoard Qwiic or BlackBoard
-  If you don't have a platform with a Qwiic connection use the SparkFun Qwiic Breadboard Jumper (https://www.sparkfun.com/products/14425)
-  Open the serial monitor at 115200 baud to see the output
-*/
-
-#include <Wire.h> //Needed for I2C to GNSS
-
-#include <SparkFun_u-blox_GNSS_Arduino_Library.h> //http://librarymanager/All#SparkFun_u-blox_GNSS
-SFE_UBLOX_GNSS myGNSS;
-
-//#define USE_SERIAL1 // Uncomment this line to push the RTCM data from Serial1 to the module via I2C
-
-size_t numBytes = 0; // Record the number os bytes received from Serial1
-
-void setup()
-{
-  Serial.begin(115200);
-  while (!Serial); //Wait for user to open terminal
-  Serial.println("u-blox Base station example");
-
-#ifdef USE_SERIAL1
-  // If our board supports it, we can receive the RTCM data on Serial1
-  Serial1.begin(115200);
-#endif
-
-  Wire.begin();
-  Wire.setClock(400000); //Increase I2C clock speed to 400kHz
-
-  if (myGNSS.begin() == false) //Connect to the u-blox module using Wire port
-  {
-    Serial.println(F("u-blox GNSS not detected at default I2C address. Please check wiring. Freezing."));
-    while (1);
-  }
-
-  // Uncomment the next line if you want to reset your module back to the default settings with 1Hz navigation rate
-  //myGNSS.factoryDefault(); delay(5000);
-
-#ifdef USE_SERIAL1
-  Serial.print(F("Enabling UBX and RTCM input on I2C. Result: "));
-  Serial.print(myGNSS.setPortInput(COM_PORT_I2C, COM_TYPE_UBX | COM_TYPE_RTCM3)); //Enable UBX and RTCM input on I2C
-  myGNSS.saveConfigSelective(VAL_CFG_SUBSEC_IOPORT); //Save the communications port settings to flash and BBR
-#endif
-}
-
-void loop()
-{
-  // From v2.0, the data from getRELPOSNED (UBX-NAV-RELPOSNED) is returned in UBX_NAV_RELPOSNED_t packetUBXNAVRELPOSNED
-  // Please see u-blox_structs.h for the full definition of UBX_NAV_RELPOSNED_t
-  // You can either read the data from packetUBXNAVRELPOSNED directly
-  // or can use the helper functions: getRelPosN/E/D; getRelPosAccN/E/D
-  if (myGNSS.getRELPOSNED() == true)
-  {
-    Serial.print("relPosN: ");
-    Serial.println(myGNSS.getRelPosN(), 4); // Use the helper functions to get the rel. pos. as m
-    Serial.print("relPosE: ");
-    Serial.println(myGNSS.getRelPosE(), 4);
-    Serial.print("relPosD: ");
-    Serial.println(myGNSS.getRelPosD(), 4);
-
-    Serial.print("relPosLength: ");
-    Serial.println(myGNSS.packetUBXNAVRELPOSNED->data.relPosLength);
-    Serial.print("relPosHeading: ");
-    Serial.println(myGNSS.packetUBXNAVRELPOSNED->data.relPosHeading);
-
-    Serial.print("relPosHPN: ");
-    Serial.println(myGNSS.packetUBXNAVRELPOSNED->data.relPosHPN);
-    Serial.print("relPosHPE: ");
-    Serial.println(myGNSS.packetUBXNAVRELPOSNED->data.relPosHPE);
-    Serial.print("relPosHPD: ");
-    Serial.println(myGNSS.packetUBXNAVRELPOSNED->data.relPosHPD);
-    Serial.print("relPosHPLength: ");
-    Serial.println(myGNSS.packetUBXNAVRELPOSNED->data.relPosHPLength);
-
-    Serial.print("accN: ");
-    Serial.println(myGNSS.getRelPosAccN(), 4); // Use the helper functions to get the rel. pos. accuracy as m
-    Serial.print("accE: ");
-    Serial.println(myGNSS.getRelPosAccE(), 4);
-    Serial.print("accD: ");
-    Serial.println(myGNSS.getRelPosAccD(), 4);
-
-    Serial.print("gnssFixOk: ");
-    if (myGNSS.packetUBXNAVRELPOSNED->data.flags.bits.gnssFixOK == true)
-      Serial.println("x");
-    else
-      Serial.println("");
-
-    Serial.print("diffSolution: ");
-    if (myGNSS.packetUBXNAVRELPOSNED->data.flags.bits.diffSoln == true)
-      Serial.println("x");
-    else
-      Serial.println("");
-
-    Serial.print("relPosValid: ");
-    if (myGNSS.packetUBXNAVRELPOSNED->data.flags.bits.relPosValid == true)
-      Serial.println("x");
-    else
-      Serial.println("");
-
-    Serial.print("carrier Solution Type: ");
-    if (myGNSS.packetUBXNAVRELPOSNED->data.flags.bits.carrSoln == 0)
-      Serial.println("None");
-    else if (myGNSS.packetUBXNAVRELPOSNED->data.flags.bits.carrSoln == 1)
-      Serial.println("Float");
-    else if (myGNSS.packetUBXNAVRELPOSNED->data.flags.bits.carrSoln == 2)
-      Serial.println("Fixed");
-
-    Serial.print("isMoving: ");
-    if (myGNSS.packetUBXNAVRELPOSNED->data.flags.bits.isMoving == true)
-      Serial.println("x");
-    else
-      Serial.println("");
-
-    Serial.print("refPosMiss: ");
-    if (myGNSS.packetUBXNAVRELPOSNED->data.flags.bits.refPosMiss == true)
-      Serial.println("x");
-    else
-      Serial.println("");
-
-    Serial.print("refObsMiss: ");
-    if (myGNSS.packetUBXNAVRELPOSNED->data.flags.bits.refObsMiss == true)
-      Serial.println("x");
-    else
-      Serial.println("");
-  }
-  else
-    Serial.println("RELPOS request failed");
-
-  for (int i = 0; i < 500; i++)
-  {
-#ifdef USE_SERIAL1
-    uint8_t store[256];
-    while ((Serial1.available()) && (numBytes < 256)) // Check if data has been received
-    {
-      store[numBytes++] = Serial1.read(); // Read a byte from Serial1 and store it
-    }
-    if (numBytes > 0) // Check if data was received
-    {
-      //Serial.print("Pushing ");
-      //Serial.print(numBytes);
-      //Serial.println(" bytes via I2C");
-      myGNSS.pushRawData(((uint8_t *)&store), numBytes); // Push the RTCM data via I2C
-      numBytes = 0; // Reset numBytes
-    }
-#endif
-    delay(10);
-  }
-}
diff --git a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/ZED-F9P/Example6_GetVal/Example6_GetVal.ino b/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/ZED-F9P/Example6_GetVal/Example6_GetVal.ino
deleted file mode 100644
index 8a419dc..0000000
--- a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/ZED-F9P/Example6_GetVal/Example6_GetVal.ino
+++ /dev/null
@@ -1,60 +0,0 @@
-/*
-  Get a device's I2C address using advanced getVal method
-  By: Nathan Seidle
-  SparkFun Electronics
-  Date: January 9th, 2019
-  License: MIT. See license file for more information but you can
-  basically do whatever you want with this code.
-
-  u-blox changed how to configure their modules in 2019. As of version 23 of the UBX protocol the
-  UBX-CFG commands are deprecated; they still work, they just recommend using VALSET, VALGET, and VALDEL
-  commands instead. This example shows how to use this new command structure.
-
-  Feel like supporting open source hardware?
-  Buy a board from SparkFun!
-  ZED-F9P RTK2: https://www.sparkfun.com/products/15136
-  NEO-M8P RTK: https://www.sparkfun.com/products/15005
-  SAM-M8Q: https://www.sparkfun.com/products/15106
-
-  Hardware Connections:
-  Plug a Qwiic cable into the GNSS and a RedBoard Qwiic or BlackBoard
-  If you don't have a platform with a Qwiic connection use the SparkFun Qwiic Breadboard Jumper (https://www.sparkfun.com/products/14425)
-  Open the serial monitor at 115200 baud to see the output
-*/
-
-#include <Wire.h> //Needed for I2C to GNSS
-
-#include <SparkFun_u-blox_GNSS_Arduino_Library.h> //http://librarymanager/All#SparkFun_u-blox_GNSS
-SFE_UBLOX_GNSS myGNSS;
-
-long lastTime = 0; //Simple local timer. Limits amount if I2C traffic to u-blox module.
-
-void setup()
-{
-  Serial.begin(115200);
-  while (!Serial)
-    ; //Wait for user to open terminal
-  Serial.println("u-blox getVal example");
-
-  Wire.begin();
-  Wire.setClock(400000); //Increase I2C clock speed to 400kHz
-
-  if (myGNSS.begin() == false) //Connect to the u-blox module using Wire port
-  {
-    Serial.println(F("u-blox GNSS not detected at default I2C address. Please check wiring. Freezing."));
-    while (1)
-      ;
-  }
-
-  //myGNSS.enableDebugging(); //Enable debug messages over Serial (default)
-  //myGNSS.enableDebugging(SerialUSB); //Enable debug messages over Serial USB
-
-  uint8_t currentI2Caddress = myGNSS.getVal8(UBLOX_CFG_I2C_ADDRESS);
-  Serial.print("Current I2C address (should be 0x42): 0x");
-  Serial.println(currentI2Caddress >> 1, HEX); //u-blox module returns a shifted 8-bit address. Make it 7-bit unshifted.
-}
-
-void loop()
-{
-  // Nothing to do here
-}
diff --git a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/ZED-F9P/Example7_SetVal/Example7_SetVal.ino b/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/ZED-F9P/Example7_SetVal/Example7_SetVal.ino
deleted file mode 100644
index 859d568..0000000
--- a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/ZED-F9P/Example7_SetVal/Example7_SetVal.ino
+++ /dev/null
@@ -1,76 +0,0 @@
-/*
-  Send UBX binary commands to enable RTCM sentences on u-blox ZED-F9P module
-  By: Nathan Seidle
-  SparkFun Electronics
-  Date: January 9th, 2019
-  License: MIT. See license file for more information but you can
-  basically do whatever you want with this code.
-
-  u-blox changed how to configure their modules in 2019. As of version 23 of the UBX protocol the
-  UBX-CFG commands are deprecated; they still work, they just recommend using VALSET, VALGET, and VALDEL
-  commands instead. This example shows how to use this new command structure.
-
-  Feel like supporting open source hardware?
-  Buy a board from SparkFun!
-  ZED-F9P RTK2: https://www.sparkfun.com/products/15136
-  NEO-M8P RTK: https://www.sparkfun.com/products/15005
-  SAM-M8Q: https://www.sparkfun.com/products/15106
-
-  Hardware Connections:
-  Plug a Qwiic cable into the GNSS and a RedBoard Qwiic or BlackBoard
-  If you don't have a platform with a Qwiic connection use the SparkFun Qwiic Breadboard Jumper (https://www.sparkfun.com/products/14425)
-  Open the serial monitor at 115200 baud to see the output
-*/
-
-#include <Wire.h> //Needed for I2C to GNSS
-
-#include <SparkFun_u-blox_GNSS_Arduino_Library.h> //http://librarymanager/All#SparkFun_u-blox_GNSS
-SFE_UBLOX_GNSS myGNSS;
-
-long lastTime = 0; //Simple local timer. Limits amount if I2C traffic to u-blox module.
-
-void setup()
-{
-  Serial.begin(115200);
-  while (!Serial)
-    ; //Wait for user to open terminal
-  Serial.println("u-blox getVal example");
-
-  Wire.begin();
-  Wire.setClock(400000); //Increase I2C clock speed to 400kHz
-
-  if (myGNSS.begin() == false) //Connect to the u-blox module using Wire port
-  {
-    Serial.println(F("u-blox GNSS not detected at default I2C address. Please check wiring. Freezing."));
-    while (1)
-      ;
-  }
-
-  //myGNSS.enableDebugging(); //Enable debug messages over Serial (default)
-  //myGNSS.enableDebugging(SerialUSB); //Enable debug messages over Serial USB
-
-  bool setValueSuccess;
-
-  //These key values are hard coded and defined in u-blox_config_keys.h.
-  //You can obtain them from the ZED-F9P interface description doc
-  //or from u-center's Messages->CFG->VALSET window. Keys must be 32-bit.
-  //setValueSuccess = myGNSS.setVal(UBLOX_CFG_NMEA_HIGHPREC, 0); //Enable high precision NMEA
-  //setValueSuccess = myGNSS.setVal(UBLOX_CFG_RATE_MEAS, 1000); //Set measurement rate to 100ms (10Hz update rate)
-  setValueSuccess = myGNSS.setVal(UBLOX_CFG_RATE_MEAS, 1000); //Set measurement rate to 1000ms (1Hz update rate)
-
-  //Below is the original way we enabled the RTCM message on the I2C port. After that, we show how to do the same
-  //but with setVal().
-  //Original: myGNSS.enableRTCMmessage(UBX_RTCM_1005, COM_PORT_I2C, 1); //Enable message 1005 to output through I2C port, message every second
-  //setValueSuccess = myGNSS.setVal(UBLOX_CFG_MSGOUT_RTCM_3X_TYPE1005_I2C, 1); //Set output rate of msg 1005 over the I2C port to once per second
-
-  if (setValueSuccess == true)
-  {
-    Serial.println("Value was successfully set");
-  }
-  else
-    Serial.println("Value set failed");
-}
-
-void loop()
-{
-}
diff --git a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/ZED-F9P/Example8_GetSetPortSettings/Example8_GetSetPortSettings.ino b/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/ZED-F9P/Example8_GetSetPortSettings/Example8_GetSetPortSettings.ino
deleted file mode 100644
index 5207746..0000000
--- a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/ZED-F9P/Example8_GetSetPortSettings/Example8_GetSetPortSettings.ino
+++ /dev/null
@@ -1,98 +0,0 @@
-/*
-  Configuring port settings using the newer getVal/setVal methods
-  By: Nathan Seidle
-  SparkFun Electronics
-  Date: October 23rd, 2020
-  License: MIT. See license file for more information but you can
-  basically do whatever you want with this code.
-
-  This example shows how to query a u-blox module for its UART1 settings and
-  then change them if the settings aren't what we want.
-
-  Note: getVal/setVal/delVal are only support in u-blox protocol versions 27 and higher.
-
-  Feel like supporting open source hardware?
-  Buy a board from SparkFun!
-  ZED-F9P RTK2: https://www.sparkfun.com/products/15136
-
-  Hardware Connections:
-  Plug a Qwiic cable into the GNSS and a RedBoard
-  If you don't have a platform with a Qwiic connection use the SparkFun Qwiic Breadboard Jumper (https://www.sparkfun.com/products/14425)
-  Open the serial monitor at 115200 baud to see the output
-*/
-
-#include <Wire.h> //Needed for I2C to GNSS
-
-#include <SparkFun_u-blox_GNSS_Arduino_Library.h> //http://librarymanager/All#SparkFun_u-blox_GNSS
-SFE_UBLOX_GNSS myGNSS;
-
-void setup()
-{
-  Serial.begin(115200);
-  while (!Serial)
-    ; //Wait for user to open terminal
-  Serial.println("SparkFun u-blox Example");
-
-  Wire.begin();
-
-  if (myGNSS.begin() == false) //Connect to the u-blox module using Wire port
-  {
-    Serial.println(F("u-blox GNSS not detected at default I2C address. Please check wiring. Freezing."));
-    while (1)
-      ;
-  }
-
-  bool response = true;
-
-  //Read the settings from RAM (what the module is running right now, not BBR, Flash, or default)
-  uint8_t currentUART1Setting_ubx = myGNSS.getVal8(UBLOX_CFG_UART1INPROT_UBX);
-  uint8_t currentUART1Setting_nmea = myGNSS.getVal8(UBLOX_CFG_UART1INPROT_NMEA);
-  uint8_t currentUART1Setting_rtcm3 = myGNSS.getVal8(UBLOX_CFG_UART1INPROT_RTCM3X);
-
-  Serial.print("currentUART1Setting_ubx: ");
-  Serial.println(currentUART1Setting_ubx);
-  Serial.print("currentUART1Setting_nmea: ");
-  Serial.println(currentUART1Setting_nmea);
-  Serial.print("currentUART1Setting_rtcm3: ");
-  Serial.println(currentUART1Setting_rtcm3);
-
-  //Check if NMEA and RTCM are enabled for UART1
-  if (currentUART1Setting_ubx == 0 || currentUART1Setting_nmea == 0)
-  {
-    Serial.println("Updating UART1 configuration");
-
-    //setVal sets the values for RAM, BBR, and Flash automatically so no .saveConfiguration() is needed
-    response &= myGNSS.setVal8(UBLOX_CFG_UART1INPROT_UBX, 1);    //Enable UBX on UART1 Input
-    response &= myGNSS.setVal8(UBLOX_CFG_UART1INPROT_NMEA, 1);   //Enable NMEA on UART1 Input
-    response &= myGNSS.setVal8(UBLOX_CFG_UART1INPROT_RTCM3X, 0); //Disable RTCM on UART1 Input
-
-    if (response == false)
-      Serial.println("SetVal failed");
-    else
-      Serial.println("SetVal succeeded");
-  }
-  else
-    Serial.println("No port change needed");
-
-  //Change speed of UART2
-  uint32_t currentUART2Baud = myGNSS.getVal32(UBLOX_CFG_UART2_BAUDRATE);
-  Serial.print("currentUART2Baud: ");
-  Serial.println(currentUART2Baud);
-
-  if (currentUART2Baud != 57600)
-  {
-    response &= myGNSS.setVal32(UBLOX_CFG_UART2_BAUDRATE, 57600);
-    if (response == false)
-      Serial.println("SetVal failed");
-    else
-      Serial.println("SetVal succeeded");
-  }
-  else
-    Serial.println("No baud change needed");
-
-  Serial.println("Done");
-}
-
-void loop()
-{
-}
diff --git a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/ZED-F9P/Example9_multiSetVal/Example9_multiSetVal.ino b/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/ZED-F9P/Example9_multiSetVal/Example9_multiSetVal.ino
deleted file mode 100644
index 7e7655d..0000000
--- a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/ZED-F9P/Example9_multiSetVal/Example9_multiSetVal.ino
+++ /dev/null
@@ -1,90 +0,0 @@
-/*
-  Send UBX binary commands to enable RTCM sentences on u-blox ZED-F9P module
-  Based on Example7 By: Nathan Seidle
-  SparkFun Electronics
-  Updated by Paul Clark to demonstrate setVal8/16/32, newCfgValset8/16/32, addCfgValset8/16/32 and sendCfgValset8/16/32
-  Date: July 1st, 2019
-  License: MIT. See license file for more information but you can
-  basically do whatever you want with this code.
-
-  u-blox changed how to configure their modules in 2019. As of version 23 of the UBX protocol the
-  UBX-CFG commands are deprecated; they still work, they just recommend using VALSET, VALGET, and VALDEL
-  commands instead. This example shows how to use this new command structure.
-
-  Feel like supporting open source hardware?
-  Buy a board from SparkFun!
-  ZED-F9P RTK2: https://www.sparkfun.com/products/15136
-  NEO-M8P RTK: https://www.sparkfun.com/products/15005
-  SAM-M8Q: https://www.sparkfun.com/products/15106
-
-  Hardware Connections:
-  Plug a Qwiic cable into the GNSS and a RedBoard Qwiic or BlackBoard
-  If you don't have a platform with a Qwiic connection use the SparkFun Qwiic Breadboard Jumper (https://www.sparkfun.com/products/14425)
-  Open the serial monitor at 115200 baud to see the output
-*/
-
-#include <Wire.h> //Needed for I2C to GNSS
-
-#include <SparkFun_u-blox_GNSS_Arduino_Library.h> //http://librarymanager/All#SparkFun_u-blox_GNSS
-SFE_UBLOX_GNSS myGNSS;
-
-void setup()
-{
-  Serial.begin(115200);
-  while (!Serial)
-    ; //Wait for user to open terminal
-  Serial.println("u-blox multi setVal example");
-
-  Wire.begin();
-  Wire.setClock(400000); //Increase I2C clock speed to 400kHz
-
-  if (myGNSS.begin() == false) //Connect to the u-blox module using Wire port
-  {
-    Serial.println(F("u-blox GNSS not detected at default I2C address. Please check wiring. Freezing."));
-    while (1)
-      ;
-  }
-
-  //myGNSS.enableDebugging(); //Enable debug messages over Serial (default)
-  //myGNSS.enableDebugging(SerialUSB); //Enable debug messages over Serial USB
-
-  bool setValueSuccess = true;
-
-  //These key values are hard coded. You can obtain them from the ZED-F9P interface description doc
-  //or from u-center's Messages->CFG->VALSET window. Keys must be 32-bit.
-  //Choose setVal8, setVal16 or setVal32 depending on the required value data width (1, 2 or 4 bytes)
-  //L, U1, I1, E1 and X1 values are 8-bit
-  //U2, I2, E2 and X2 values are 16-bit
-  //U4, I4, R4, E4, X4 values are 32-bit
-
-  setValueSuccess &= myGNSS.setVal8(UBLOX_CFG_NMEA_HIGHPREC, 0); //Enable high precision NMEA (value is 8-bit (L / U1))
-  //setValueSuccess &= myGNSS.setVal16(UBLOX_CFG_RATE_MEAS, 200); //Set measurement rate to 100ms (10Hz update rate) (value is 16-bit (U2))
-  //setValueSuccess &= myGNSS.setVal16(UBLOX_CFG_RATE_MEAS, 200, 1); //Set rate setting in RAM instead of BBR
-  setValueSuccess &= myGNSS.setVal16(UBLOX_CFG_RATE_MEAS, 1000); //Set measurement rate to 1000ms (1Hz update rate) (value is 16-bit (U2))
-
-  //Below is the original way we enabled a single RTCM message on the I2C port. After that, we show how to do the same
-  //but with multiple messages all in one go using newCfgValset, addCfgValset and sendCfgValset.
-  //Original: myGNSS.enableRTCMmessage(UBX_RTCM_1005, COM_PORT_I2C, 1); //Enable message 1005 to output through I2C port, message every second
-
-  //Begin with newCfgValset8/16/32
-  setValueSuccess &= myGNSS.newCfgValset8(UBLOX_CFG_MSGOUT_RTCM_3X_TYPE1005_I2C, 1); //Set output rate of msg 1005 over the I2C port to once per measurement (value is 8-bit (U1))
-  //setValueSuccess &= myGNSS.newCfgValset8(UBLOX_CFG_MSGOUT_RTCM_3X_TYPE1005_I2C, 1, VAL_LAYER_RAM); //Set this and the following settings in RAM only instead of Flash/RAM/BBR
-  //Add extra keyIDs and values using addCfgValset8/16/32
-  setValueSuccess &= myGNSS.addCfgValset8(UBLOX_CFG_MSGOUT_RTCM_3X_TYPE1077_I2C, 1); //Set output rate of msg 1077 over the I2C port to once per measurement (value is 8-bit (U1))
-  setValueSuccess &= myGNSS.addCfgValset8(UBLOX_CFG_MSGOUT_RTCM_3X_TYPE1087_I2C, 1); //Set output rate of msg 1087 over the I2C port to once per measurement (value is 8-bit (U1))
-  setValueSuccess &= myGNSS.addCfgValset8(UBLOX_CFG_MSGOUT_RTCM_3X_TYPE1127_I2C, 1); //Set output rate of msg 1127 over the I2C port to once per measurement (value is 8-bit (U1))
-  setValueSuccess &= myGNSS.addCfgValset8(UBLOX_CFG_MSGOUT_RTCM_3X_TYPE1097_I2C, 1); //Set output rate of msg 1097 over the I2C port to once per measurement (value is 8-bit (U1))
-  // Add the final value and send the packet using sendCfgValset8/16/32
-  setValueSuccess &= myGNSS.sendCfgValset8(UBLOX_CFG_MSGOUT_RTCM_3X_TYPE1230_I2C, 10); //Set output rate of msg 1230 over the I2C port to once every 10 measurements (value is 8-bit (U1))
-
-  if (setValueSuccess == true)
-  {
-    Serial.println("Values were successfully set");
-  }
-  else
-    Serial.println("Value set failed");
-}
-
-void loop()
-{
-}
diff --git a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/img/Contributing.JPG b/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/img/Contributing.JPG
deleted file mode 100644
index 39ebf68b048682d490c560ab5cd4fc67656ae778..0000000000000000000000000000000000000000
GIT binary patch
literal 0
KcmV+b0RR6000031

literal 62131
zcmV;k@=Oi?*#F=F5K2Z#MgRc;0RUhCU;qIB+W<oV0s#R60RaL60s;a80s;dC0|NsC
z0|o>H0|f^L2L}fR2L}iV3ke7a3J3=W3JnSh3k(bl3<n7g4-E_s3k(bl|JwjV0RjR7
z0|NsF0|N#O2nPrZ3=9km3=9km3=9km3=9km3=9km3=9km3=9km3=9km3=9km3=9km
z3=9km3=9km4FA9Y5eNZP1FZuAA^-vr0Rs^M|HJ?v000360RaI40RaF20000000033
z0|W&I2M7rY3;)CbwGaRT0Rsa91Oo*H1Oxy80et}i0{{dO1ri}KK?W01VFw~{6f%L4
zp$H>FvB4Em(eNZQVse5B3Kka_85$)fCnzZ@G&MFiI5|2)L`6nNNJ&alR8>}2SXo+Q
zWMyV&XlZJ5bai%jczJq*goTEOh>41lla!T~mzbHFqNAjxrl+W>s<N}RwYImoxw^u`
z#Kp$P$jQpm)6~`0*Vx(G;o{@u<>u$;>FV+F^Yr!h_xSnx|HJ?v0RRI50RaI40RaI4
z00000000330|W&I2M7rY3;)CbwGjXU0RjXB0|W;J1Oxy90(Srb0s|2Q1tBp85<yW1
zVQ~{8GJyybLXn}d!3iTXQt%aGa?uJFBsAeA@fR2w8YU+wDJnHKH#j*uLqtVJM@UIZ
zQ&d$}S6EqEV`OD!XJ~0^b98lfcX)Yvf`f#GhKGoWijtF*m6n&7nVO=bq@|{(sHv*5
zv$VCgx45~w!o$SH#>dFX%F@%+)z;V8+1ldc<mKk)=;`Y6^Yr!h_xSnx|Jncy0|5X6
z5d#qbKLGvwqKYU0qP%nV)cvsRKV#pAdTr|HT9=G`UE-}uJrBaZ7}Hr&?_bm;1gt^Z
zD->!0X(eD)6-mK32gh!Fcl&kdcJg?RZv%eK`o@<U8<XJ+4Qo}0Tx7;Yx?jkjWHa{3
zjbkUHW2l;UeHM-R+W!EPPff0`x(1rE>iT{kpMC7@vp&V5ywCPW{i$>h+ZW(|o#Sl+
z-%!(%d1kWIG|fUUD*Hyhfy{Rnlc(^>8>t7>V2%xXWmKZ#?8O-=E1;r^Dn=AhMF130
zMF130MF130MF136&i??kXU9(z_z(8`{hd4&rD~sL@XwCo@hfY#UuK2=+-)qOmf!b`
zhD6xz$M<Zzvxdmxo%=0(bMa5aZ`(Wek?@|gs(rJ={sGlAJ8cHn?9j*d2<|k+o?*QZ
zJe#B?vm-Gb1_u>UgOa-J-^ocs^M7!p`E7o`@L%YC4Mh}Gj3}at04So004So004Soo
zpZ4MXt89N_FWG0spA<D6ChuLf@U&35u(p+AlI5njiUb?j5TkUeNx{Ge0G=tN+fiG+
zKK&6;gr_AK?$21FqqU#yHnGW!d5RkznHi}mZJ`m8l2Tg*6j4CJiYTB0iYTB0iYTB0
ziYTB0iYTB0iYTB0iYTB0iYTB0iYTB0iYTB0iYTB0iYTB0iYTB0iYTB0iYTB0iYTB0
ziYTB0iYTB0iYTB0iYTB0iYTB0iYTB0iYTB0iYTB0iYTB0iYTB0iYTB0iYTB0iYTB0
ziYTB0iYTB0iYTB0iYTB0iYTB0iYTB0iYTB0iYTB0iYTB0iYTB0iYTB0iYTB0iYTB0
ziYTB0iYTBDkH2f_;L-m8;H$r~h5ocQ=+fGFr%%)6ll@FuthScsA)H`H@T}^*f_Ved
zzQM0E{j5J^?+E_ce+eb<kBi~GNEYHN{X0_Ar~5XgqF%&zLwRX11jRBQje;;pAc8^g
ziN9bU+7HAq%b@GOwl9pXd=WaEc`fwc1!-D#za_pgv-?qZGRcmzq$=d|oaZE4_G+J1
zdv>#KTJG<5*4taCNiKeV_PXk=rkyQoJ^m}cr_P=$@^vrR7yb${tLY(s;TY9CU9W#<
zynpJankySvuH;Mr2saAgk(`x0oMye7#$WJCzlT0F{gc<l`tA3KrueyM;c=?l{6bA~
z?j2W5y-QCqB(^Imq!#GI3j!*}5Mvq3S5^N21qJvM;cwZW{s_tOXTbgo(&EwlH{t&P
z1YbdEY>Zs;g`M5bS>$&t%<M^KVoAxYYhU;$FT_8Ie*?6C0w3BV#Wo)W^*tim+ULWO
z=r*sd8y1CkST3+z%oh0h0ccuXpDRkjqmlAdrAAh9g(#^#Ez23k`dzKBWqW*(bEQ%h
zDyyd|vT@$`lqGF+d)r$cAMw}r(($*(zu6o1JJEGZ4~Uwu_~T_I{{W2bybI;QuWPpU
zHc2eDuro~$mX|Kd@)VI9%2@)QaCX0DzX40|m-g29Wq0sH_Idc{@MpoAoVR*+kL^4`
z6fx*G_N{EqZFFNx>zrLjIw11`DP@s^G0lB*`$PW0ejE7B@QcBI9q|68seC!reizLJ
z*MfDu4N%;8a#&&VQB@=ilETpw9FaIG>TqyyL|*}aXD^IC5%K+wwect8?dQY`JuVkZ
zeIrcpm7j;Ku4H5>=G|<0q?v#us;kC<uyz~@>-LfM)2SUVDL+*9T6uf6*?dXeyK}fp
z*i)wUYAHV_cX?~_cir00Wq+Cf0A;V(o57#8x9t=AR)50Dg7?K<7q$4IJQkiCn)X;U
z$mcqJnUd;A;$-usDq~eL77>Ic0+(WaH~t9{_kIJn_~r1hYMQ30;m?G>5pMKP4V^~m
z?x(TSUfv6ctvtsi*&;H!sbWst4%O{{vrp{5{{Rf{<6nyU$M)y;$NVh+02fQ*uP5wZ
zXa3CJZEpvWyUcGl9!Bl>PrZ%2WY_(e{{UqV_-7x99~Znq{lERQ{{RbH#b?C-0B8FT
z+5Z5t^KA?sM(;8F-}PI!;Xd{@@srDk=7ed(qN5nU@uf@gR+>+>(spY5)?Ct*y8B5r
z{uk{(2YBh<TWDc_!AE?5;GYWo1h&yUYj5L?Vjml8HkuZjpm;*^TTNfYmu~)I*+(pL
z#8Nj{+{#R`ua>S0bA$1x!0!R-f3lbS6xZNor-l9p-G0x082FYo%_~^b4~-(#$B9<k
zPHU*8p3Vs+hAE<v7ZV9tm^%YsaDLkV0I}%(u6!Zkv8VW}Qt&5?ybZ0z;x7#NipttM
zw$m?TM~^QApCr*TNb1qC0OWJUd9R0m;G4cI)xT;Vg`XF`Abe)je0AdAhSO>QMgIT@
z{910CHMP~8mflUhyi*Zw!KCvZS2MhuRdR}|2DnzCHz{eW`KJplw|v*V^h(Vu?yD|n
z+xxnIitY8;ZDzH;?JZZ<b@{LV00hea0D^h^JN>LbWQ*NP;;oJ6j;$ZX-Xw!b((d&e
zm~1pChOcxO!wga)iQY}_XCTXlRSXqCuhNSA(*FR0Xa38-6Z}#8DBWvc3%)q&9}JVk
z9xd@9)$A_(HErS>R+Tk-sD;I#nbEDKF`_FByi8O#mAJDuEBLp!*?)gDKj7-M>9b|e
z_)A~5zx0`&WBW>Yi&)Zs;EzAG{{X{F{c~3FHk0s!$FTToK-6_RhPk``&ij6uaTT<a
zF)brO=QLr7&ec)I0I#dR;JlymhyMVIU-j#yf9cN7y&J;+0PsyO0BAq4M~S`&U0iFL
zzK`Q%yPw25)!oXzt*hVMx0x;clI`2)`GHw}Tn{Y<2pss=#?Sa9hs6H?+GqA-)P5HH
zLj9(7pAl$@9lB`lo)5OOXqp+Lc;vq^P9FJ|G$^BdE4hS@uFAOVrBcqEDm(JZn{w{b
zf}8Jq!<k=xZEVeGRE#H1X;~@F+p?6R;=5TTXKUKpCUzgSH~ggU_B{UpuTK~M0O_*Y
ztp3EG@{vE=2mZr;8vg*(GFPhnQ~i~H;bs2QzX!e}{{U}&i~bcnI>cYu-(vGWwSM1i
z6dCh;!R2{=Uhla3vyYb<sXhq)%fIlaKWMLvK0f~3{?Y#cg|U04UVVe?UQhN{*zCow
z-!sf_H-0x~YHjI*)}}K_Yy7fbH&sb~3jYA`PBj<FO?I{ZN=x-ekpBR|bp^ry0D@Zl
zOZzE|U3r>El4J*9f9-oMyRptQjMtrh*`Eh&Kj4_3u|LHhieC=f#20@Ve0d(1qw8KQ
zyVPgDzrVP+ypG@PDGbv6o+pp(G8mFIjTG!3b!+NR+lTgE{{V)}{g}K(@Z<Y){t>_J
z`7EUV(fb$MJdd;9L358Q%#U{OCvV>v-JWrS(f-h%06aJQPy7+_2gCmW7h1`A;r{><
zS{qBHiTt@^!3>hd-@_t0tE+Zp2b#lbPTTWe);5jR`g2*Q^1jIFz4=#b`Pu1bZoI8s
zeEXl5-w-|#r^BBISa^@%Z|uqYRrqV;ripoJdk>5?rh(+~6D-lS)OxIgQ<U6AaT>@O
zOiUE8+NuUC>0clGF4KSDp}+7_A07NX_>%Y9kHb%c-Wt)a;P8rHOKoGUYFdw<D_z~J
zOr~)XLb0MbC<`&i%yZxTKmClpI{0?~087(#&)Sz?*E|`d+(zQs9|r06dfoNBYzkZ4
zYCE5BAws-~0!ZU`%n8kFe$qd%mbLK*<L#ftpN0Pb67T*Kd`4X{G%Zf-Xz=S=X1!pN
z8B!~&IbAa7#kNY4BPe1y7{;=iZa39lPtx(S(`zTuZ0{wiSLcLUjF!&HdfG|7cY0l2
z?|VHq@IQn<vloYdWpDT`{{V+{F9*x2+W1=M;SQm5W1`&OOLuLeAMHzZc<oHA&m1g3
ze=By?V*5Z1f#`qmMZftY{{R_(?6i2d{{Txxa32aj3F^NG{{Y~({u-CWo;22eAb77_
z_(7;#YMRabF<QpubvtxOt?gn0J9rQel^1go%+Bu2TD?*a_$NP&{u+E^@usctv*V_*
z@bkfc5w&@B?R&$2@Qqq(l0knkQE_o$bu$mLw3|U8;+aDdLi7RBlT@j;?|4*={QbLr
zw)a}wwt-%nl}BZ6SwdFw_BMW3yp#L-pEUd_{h~GR*;D=rLHk(v>%!;D@fMNsTg6c6
z(`;A!EcY6uHp?(p`ALk;zYWL9&lSUX^Wel@82CoI=fa=azxKA$zi3@CAil8piK{id
zmzuruGBk%!kZO{7w)2H$c)YeiukxV9eaZVY{{X=-{4el7_DT4G@M~YyZhUXyKOgIQ
zwxx1zVt8&Mx4vLREg_ail32oz-<Ax_H((me@Hgx+@yo(CRz4e>_NwtU?|}5?NMV3@
zKTnUuZD@c6w|!8v20K6oQEnwXoxt-`3nvtvnvEsR+m<Oc-$$=iF24%8)l+H4{{2^O
z>QcOXw!ZqS`MY^<{1gk}Hm&0i+AqT%Gx)Rcug2dPJ_DzOVz-~eJ{y`#rtr?T(-xNY
z<4j3od&TltD0LDTytX?5AlI4y0Krba3;xgl01|)Tg;!oH_+MdRuXtO*aU{MAzn13e
z;%yi0TD`Je#HQhl$Z}dU9Gsv~xBvlPZG3(B1@WK99}-Tl@blx({44De;>|6tG+WOF
z+G~*{s!nbomE?)zkb(vn$sSibIXUOs{t1cT+5Z4we-nHJxz+W%-8aSGYrEAo$;4l7
zxYTYge%AN9RTd>-akZ5dLV%%t=|ZB6Z*3I0lIs2D?D{<$Nw%6+PWtln&}tRw&QAMX
z^s<Ui&hM(Vp0C%`KW2Z~hrl1Qm&3-;J{@>lOz@VEeR2JxacN?#BbMQ#L}?C5`HIGa
z{sJq}E6zV<?}mOp_)qZH`zPWj#Av=J>v7Hdty(`1#iDJ1Mu@SrG07li%Ci^U$#cK}
z3iNt)UFUn>`u#RJ=tahwi&kMp6jo-TMHEm0MHEm0MHEm0MHEm0MHEm0MHEm0MHEm0
zMHEm0MHEm0MHEm0MHEm0MHEm0MHEm0MHEm0MHEm0MHEm0MHEm0MHEm0MHEm0MHEm0
zMHEm0MHEm0MHEm0MHEm0MHEm0MHEm0MHEm0MHEm0MHEm0MHEm0MHEm0MHEm0MHEm0
zMHEm0MHEm0MHEm0MHEm0MHEm0MHEm0MHEm0MHEm0MHEm0MHEm0MHEm0MR{MuzZCe7
z#-AE(ejoUET5k%&7LWb8t7{ha(A-}nZ8?e<EtYh6Rh^Pj@<|+kDg_C-!=h{76R$sK
zSUfwRYO;98;&!>>i|d#)r?;}x;k}ec37wK=4Q*^Ts=gm=V*x?u=3+X>o4($5cKq-6
zdR%%-m#^h@f6CA2>u$&5{{X^24}5y~U#|Ew#hQQiuZFx!XC;QEXXnWW+F)^pP4Tk2
z<absF-nTT3Dh&%twz9QPD%Q><f)w0aVkiouCnVqj*1XeA{j0RSPsP^uN#XAlE{Aig
zwt$`_c<qLl{h+0zYk&3s0BFygjSrY1@{FTsbC65h_L?yG>AXL2;7=S`UR~Q?TxinV
zrGiD`187%#aDSz4jo3J37b^&5$;iQ^{n)v5{{SU_!8@hd-Dtwsc6+baf5ln(t36Tb
z6jy_M9{sX!{9o`hz}nui;GYo5;_n(;`IdSnm@K#IDv+$RT*6-O%8K1X5BT_+H^~dP
zb0}|E_-XMf%i@=TZMEwtFRfyf%M{j^Q3blPo*5b`ppjIt^COiV4${g>ouz>U+~VPW
zZh&+&SDt(^{h_1yh2y)A4c~ZA#hwt=(@jlY+8u2z2ixshLm84kv(GltjkGdLvDeH`
zmy?WdiXXNHoAAfQJ|@#Y;S%w-z5f6RWsDl8w|Ax5+daL7tg9mlb0qP!n?z1oBUY0G
zAsA9>+P~|+-DiH*ci1&;#c%yv@4B~ps~)*Uc~_2qYke2N+MW7a=zb>g2AQDSL3^)i
z+GIB7&q0D^^AbtC*`ty`BK_+vymGRp2~oL0cBA`V_+LnuM2hO)TY`Oa#Zve}IE|{a
zTU{fv31uqeEDn6Ft_jcDA;=q!*UIn9*ZvA$n@i>$Il6zqzvQlZopOH#eg}A4_IL0q
z_-n!1U-mwVx0hGq+wC)4Vr!Y+d7pHy&GSnmwljg80007|@PEZy4;y$pQrB%Dy-N)?
z?)uYoikZ1KlSvGZ9vFg!;(er$NC4nwxNnBvwoZ}p8N4$ycw5Gr29@JWHoMSuEn3#z
zC^a@)f3!3Ti95|4o?6Jm&5aSnOi`Q_Ej=8&EqxxpjkfXzwu|om^`rZ*znSb5SDyHH
z_L0#%Q>A=5y0*2|Q9dWyHRhBgiZE@|S{uAihdWP}G4k*Ey}7SF{gD1R_@m;6v*DPv
z-Baz+>K_jD&352@ni#yx*{&x^CHWL%DvCCblw*J@xnDb`_h02F{{XhXz&^vMwpRRF
zU#avZ73Uhy?JcHgzZ7-P48Duv2_x{ej9QkrtSVcko2A>y6tXOi&oao|Lg1`%y90to
z-fJGm_RP?r({FEe{{Rp8yTUecXzj09ORCyJ$62#iL@#e0ywb=VG|&$wRgPTG7}=e{
zXMMk|{{YGT&$At#o`3K^&3)^-J${PueM9!u)BG<dh+*+3f;@TQd*2Rta_7ZU+h4<D
zA-J-Ekz2}=-s)JILd}4M!5dEPps8-V#^1C@hdvzmj^@K!lIqGkFAm&zqUQ0U-vl<0
z$dR}^NpmJ-1S+A<4i0b&YS#0=;d}koe{jFAzn0(nRDSe#R9BAPe%U&2hxDuW*SsO)
zKMrbk(b-F9rD_Rd_N`fN?gg|SOGk3>sWUR838jq3y-V#<4OH=u?L*>y58^k&Jthx^
z-Y9|}8QtF7>K6BMX}@c-5Je*lGT(W5`2?h?kQlgJ$?{X=Z~FeW>)WWCNniT@pHAyk
zcbA_4{3U<!-pk@-x=!yK>Dn~D9=FuK)iCnxWSM4oe4zeO%!;RRLc<shjw`XRB>km6
zG3y@*ym#=*Ei&6x)b0F1tzB5&X_|GcQ(WpmY1dN48kq{Lf4xY_c6iZ3lJ2Rv)$a#>
z)fz8~wY@J(xYB$<p=z3jt97AIYpBBrZ8H7{1<1CU<CWtrExGe!XqrTI2j&NgNj9vu
zU*~uDy?oxfy<6VzulZZ@kKDYEO`^FU1pI2zylvn;Q^e`^jXy%tuCJhb%gu=#vD!-{
zQrsz4Z{2Q+Ocuc*bBqz5O@C{9OHT(~Yx<vpymzB%1}G%bX1lbtFX9)tkz%)o-Wcv4
zRF+nfJV$bnu-}&pwf3c}vfod~Z=2}1c72A`xAXir`?|f6>r_{eYJavqk>Otr_>%L)
zei!kVhV>r{3n^~&YpZK(oB3_-<`6+~2(_MQr9&Wf+L9RoiH6LT4VS8Z-MU_Y+VW~X
z1^9(wKZGQJ_>MVkteg7^+HkEE+>Vz`9I-N%IJaqKQ4{Zta5G9RyD#hd`~}kg0N3^Y
zYq~woit=9?{?}T6ggjN^oiZN?_}^Sl1c;^AFLdimb8BG)kSyY0(oT&q2uU%*uPEAo
zcZNdOz9W9qmVXXj&hAePc&k+K#lqRV-XpP&)akZMbt=ajKbbmC>Ng`XhA9H80#5`4
zlXkaX*Kfa|JvaWptFOIxJu-^%Pl&&@g@vw}@d6mMuO4akUILWb>YDzaZ>N-kaUHzE
zI2PhY^BIzL<ib>8vQ+IR&yW8AZ0#T6?}<E7XE%ksYkjBqBI?@T#2Uq=rMp<^Njy-@
zvoU$rSy578Ttgg=ff%v{C|pr)*6OakG}rN8dJe62-1aIf$9^Mz+1fwDwDA?^{36~n
z*8D%=IsV0}>w0Ciw3c?aSVCY5^Q7)anHXsjCW%WB(hZNd(7q@9OVfT5_&R-ORQpVk
zM<jOe+uKFv++N&D>l`pdoNkgy8C5|bWwJ;Bkh&>%+w}YHt={U}pz7n>`usZfItnYm
zz9D|oekalVckuQ&yc6SnC;MAgzp%XU^w4RuUh1MfJ*SDIl`bT=R1QJjZX*Dr1|y;B
zwC~!Dd`aL7ZF58LCyzDThq}A6z0z%<vWoXfmexZY={cU}I5HezL~^-&<pU@r68BZ#
zPwV`z+Uom)yZQeBU*~T2cG&egE61)sY`r4=d^Elu@VAWoU322U4*vkcQDbkV+gmG(
zJ<+N28sd17BnDOa3uK&ulf_MA`(Wt4C$rI|@Xv?5TjJBIX%K7IF=>{tESf!(#g;iP
z7I~sO%SR{?MdnIOFN8d0wBvUAewV-glJ)XozTegDZ@%kI^<B?fqP%+B_Q}$`L*Z`@
z>K+{MpN%|Kcj7G#d`7xnodu#^SlG7<B;I|*Q3frQ5u}YH6>X|Qu^KvO?Ny}sv&LF(
zli{5U#C|J^_fFIGdyPX*TU55wEiakHw9_o}#WMyG$izh)g+d&Fc&EuL+s@yg`8DdA
z-7tD@{cZkh?@aXyE1md}<Ga5B>2}jt_+P|cExNj&$y+@fTM1BYW->e6%?wC`Za!%N
zC6oY3t{+eRuXL{y_;bUTJ{$1Yi#$=P_>Rg=L3CRf?IOO@;fhZxX1HsMh@gz5*^6(Q
zOE_(T!m|nfzYG3Jzmo&jsIMqb+T%!15cq=D>%-nF)9gGUV;-U64OZ^n2(0vI-ppO7
zkQuz!eT1n<W094|%mS5Ws-L!IlcQMPT==KLzBKSeFlcu^BDFfrwW&IlrMjz3V_SLV
zWRVs~$%<hdpFiFCUu$Wt{{XH30Li~aairan>;C`){MV(`&tamxt5E%@&W+){F6R5d
zJ~pz|_3cn;T26^1npwQm+}pL!nH;NnZ9;izA^GQ4%wz>5sBQlMi60boFA4kr)%;y&
z;oVL3OD!HvMm-+m$QLlkBi-f8`{j$|KYwheAzNW%jLk>M7b$fA0EY@|+Db8x+S~83
z+fiOA;eXpM)-Q$f>pm#(&xtfWO2fi%_@;X=Cf;VhiOZo&Q4I2ia_GBJm>gU}2?VfR
zZA<pT@TG=_E}<Mc&F#3+w7p&dYizPfdUYutJ1a=je&cZ~rZ$ijLn&ubk~Eb$MovAQ
zzISW$O?s<tOkXrqzpjt+l75cos?l6W!rzV2d`IyHt)kv|d&C|R@eYd|H#6ya$hI>*
zyxYWA2=>!W3&zbHsl=O=qhQK1r1`}E0JVOh;17yF6|MDc2gRNt@b`mt8&{I=OtH56
zK7nG|ZLIP<h2)M&{&t>1kcs709H0#tX|}w+SNu}_N=d!Huj{9C->9!Pwf&{+wSR~@
z{)44>YsGrXcxD8jP}HoTw|g`aT8o%gJj^ATq*JskQLzn;!Bv%xE${7}rFe5d@lDr=
zd?n*w4c~Y`Y4YCbcUJbdSF*!<F@_1D7Pk{eB9~VMRrlsL8%f#;%Ei5{*ZTcY>~vR?
z+J4u1HLaJ5KexO;;=c;&o)s2tHkGJb!8PUZyki}w*}ls((aL6(S|w2XgQ*M`t#cm`
zKWXn2X&yfKe-wTP@y?JnU0VLa^FW#%Hf!BjCY;m6(Mui7kRk^oF4M*Vje`(4CoBHH
zt^BtS>-zHZ*!TJ?$!vdX?IT+7wvltD_;1C!j=!wmUTM*IYA7wE)ghkE*>09oEa_~E
z5gfUnV{br=#nc$={{U<)GhVyVtn^O`c*9=RwJSOAuQcme?Bcr7BZBAbvx|kE<}l41
z;o~a-l;$!(AfaJJwvy}qSNpB4_6MT7{<XK?eJ#DuUZRTmI#1d^$NnOdz*-He_?}5T
zQR6QV*j?*7G&(?@D@z;8<ci%E?Sx}&aKv5AOvX6dYZ+RItG-Z{kmvrkZ}dK~qPfj)
z;%$eAz9i^=7`uw@E3XjR-CS8*m0z<+*8W*|H*VeLl#sfv+!cyLpO(DyP5rcV?-p9w
zpA2{}$388(yRdy(t#sIIk?pK}`5}Vk-g~H`+i+rci51#bMI@r&(&>NeulYZ^<Fo#}
z{{X9c>ACFGR}0`D+9Sii6Lsw}$457}E35c=KN8zqv_4!-Z1Q<wSTPQ=hU%q8FhMyO
zr|91v^nG*odtZrBTWU+8K8V`zf#X4U<Sa%~yF--Uv~=H$_wPi#)a5Og`L+4Q{lOTy
zOO`w7_@vk1(c95pMd9z;E5rBK7k}G&CyKlqXAg(u@lCbnw`meZsA;in^Ja}<mPrwi
zNfBtKNaY@C{F%rPxBaj5jXO`(X7MkE{9WMLH0?G$S_^Gf-rh;|OLve$rrj;3n3wZf
zBr!h815FqzH&r-EJ6m7)f5%6r`aaA{U03zD`K@-<cSo&JUQ)lco|&d-n&g`IhP+qd
zoo7RPH2%ZCiq>2GK;Aiu&+O*fd0~G#Wq5{V8(ABE#T%-h!9R`q_r$N-E5`aRr=#oM
z8L`l`O(NnQBUXmj&VqU6zY<C%w~|=oS4g4zvba)&VOw~m%Kreb>&<=P_IbTO7MJRK
z6&2zZ-?hcogYi$|g@=i}F{<f474QT$(?_c++s)>QBMcPB9mJDJ^06LLq#)ym+Qb9b
z{51Ifo;&fBo*mTuE8?F8>%U+crL~^8EX!Y8ZxOtawXMYI@;e}OW>;S^K3p8olY4((
z(oOnnuuI+F`rG{1&Dit`E1mKG0L04=hW9!O>M>pU9w5~t(j&QzRKsaBs^%jxEDEc-
ztV%#Rl32z$$l~>X+S^FB)^0StFT?&R@fNVU&BlpmW2ZxGA5)gvB$nz}o@t|rVTX7|
zd7eMs0*kqdf|k2~TYvIP??Y<a{{UP60P-*HXRA?OY2gprlSA=-t>OJNY1-zWs_VL)
z_KhWt+))X%tGhT_X`;9(BQM-gRibGXgP{j$&2>KxekNFaPO;Tzu!`;!(lu+n9$|2*
zrKYx&#_YIb@)8aS!N*W3+go{G<)*%xue@C^=Wm|6dg%V+qN2Rh!k@IXUN@TJ=S%Q+
zjc+_QkzC1Xuf=U__FAEXcIARGIl4R9Sz~5_QcMD@Rgs$-`}WY%yf>nFlH<f45%Ir=
zbq@<Zm@f3In`=v}*`w4hKF@C~BG%$)<WnGURbP1W*lZ_gC7<Q^>G%0=7S`V**(k0X
z;U~v9J}K+k{*OP0{6pbgd&6x3ywi1*xAVNI(6lq7+s!mj8|;yIlW=I9Fc=x9;;-5!
zF9m!^)AT({!hS8c(=|O#9Uc!6G*-XaZFekt<BuMH+HlQ?!-zI-Aa3et<$TILU+ez>
z4!(MB9UQxVU+{f3*z{T}!F&z-R9|VDQ(52Xdhd+<Nvim-#9DTjr|BtW1jf?B`dIQ>
z;%j(u9AYKq%#EDku*7e8!}h+@yeE6C`Cbw6wzH@BRtTr@9;0JxZT5c;?}$#xD#<!a
zERn*?Bc-%+GOI5eh*FlS{z?7+0M)Ox^c#y(aq632bGP->^~x&;#{U2k^lyj153c-C
zsa+AHS=)=2mI&H*m0KGGXn?ei<fv6pOBMhENUjR|_N|*nvb2j)_-XML!^AqZ;Iz`T
z2^UP3_f`GdO7ce}cdu%Z#)!qt)5nYfg3f`vC}1%amFdT=w@cS{w%%XLwUv?0R~Jg1
zxt{9%U*+GYccQyJZi?~={{U>A8r#B_SC8SZ7=LVCc#QZ?Uk|0VyqcYsrR2Qp6uW0I
z1!&bAO0u+JW=CgK-pfzI{{XiRi{fopOo6;3<DE9v?_E9@zQ4Y;wT|CJ)v{G==f%Ny
zEZY=IZnHpIR32`31?X8eHK!#F7n=Mv*8MHL)vtAYrI_L3uPJ%#^xpT=My&3gn&p#v
zMcdlwuN+U?KS*s-=>Gu1DdTj|G~W<O;hjUoFK2F=b%o+w{giG7aXgVUr3al9QbwEq
z0C>n!K%1A}v|?!A7Ie=HYCaF~j+<w#>Jn*MZohFAr}ky-%0VRNH4AWVP!)zyuOtYJ
zQ{`eA3uf}HQr<lq-E`IU-pxK;?C)!8TgK5%ruKH(@2{5EO*gV>rtXhNqP%BC{k1gD
z5qNL=PS3&KH<}yGR$UK9kIAxGd_#K-*AYt%vYU~#C)s6lB>q%e26vngJKuz#6|KH4
z_<HK@Jv&p;Z?xOlbnQn=)PzFwO}LK)$0w5{k({GPB9xJpl0+c$Q(rB_(TkN>+Ro2a
z`Cj|z-pT0o&~V04n^BA3Z6D{iM`gQ7wX-^!E6ij4sBE<V0EnkS*Ss;}uL@er1@+C2
zwW}?nY5I(IdrZYVyN8}XkeL_Hiap4TM@&{#*X@yOr1%E&#X6UOej@399*HewvAdqi
z)!SH(=He(KXkd=v=SC)I-^!jirP@f@yc8E4rxhzG#`m?gTHV<tuCD2;EmfV?j87Xy
zJ4xGqkEO2m+f}aGt#wDS(Oyffe$`WHm(gjKzYV@1>i#8<P8zPKq1c@*uJlWGl1Slc
z<ZIQoW|YMtNa31SAsCeyscb)MT_eR_B+%?UEueUt#u4ipWtO!q-kO%NMWxwY$jJ=z
zrOfckK{3i%VU9;Z8*WfahCi}#R_5i?z2jx-@1lQYy(RW;PuJ*L_kB7$>u#34)z#MO
z`q=eaE6=_Y{?JhTWAPrL2AAQV633z0TwYp5;v0{#jXL&wOOtIpQL5ZE%CMDW1I>X0
z2$+IK-0)sK{h)QN2llkQ(e((tQQ`jp0eCCJL&Q3!qi(ue*j^+3r!rjmj`v~|`#Drw
zbV&?>w~sGrE|yhZb!A1_N-=VGYo|>w?>DC|_uVZ=ENwMU+D7eNM@08+FS}j#w^QG!
zuPN}4?OSWE>WgWs_&3J>4wmytpIXyDw(ac~`&!x%jW3oVxRk{ztdWxyz=}*i-T5Th
z#Y_8Z$EfPR5ByJYW#SJAcoW1LRsN>ytJ_-{^;o=%NiAL|;gV@X7M!BT@<{GL2-!k(
zr;=kQClwx#s&~>(%GbMmvQ}5sH0@_;S&kj@+FR}N<-7FvqVKhuw&?mUit@;RY4dsF
z{VPGY@E4A5HG8`&T}x8615QaiJ#BF_#T1u8?$owSQn6cqIg}yXpp{eVb;F3l)uC@{
zt$#HC04Mi%TCEM~SA|B@I$NXaular5LW(G^b6}#1C;+00C;+00C;+00C;+00C;+00
zC;+00C;+00C;+00C;+00C;+00C<D*FDf}DNJWJz^E5*JQ@f2Pe@kW<xE}qg|>EGHm
z8jYlku3@-<Nfd``sB~!Njg_}&a<eI~2f=N7Tk&UtHU9t-_@2j8)x0HpeRn6=baQ2E
za<>-GZn4K3Pb0(-Fk)UwOE&IQ5Es&DrkhKZZT@=xf3I+QyT9xD{{Sw?`TqdH{{XOt
zk>GEPQ+R^UP551Rr%SBOtt09l1d4wUTT3gMm_@0r!eeaA%#6@8BH?m&gH?VGe!?>R
zGx)`#c)Igj@V23OqD6TN-dXriS!){S+7oG)P`+!KTINxJcLYF5f0vcp^i>pI(dFrD
ze63)5w%=EOne&FJ`vM(r;g5p!Jxf#YPlztQ9+|B)XV-ihx|M{M5=M#TT-wQVnI|4v
zH=h)c@}uMmSzFco5Abz-8Sq8?BW83j4$CE_#2;wzrjRsSTUjOF`|EpeGEXUiVBEW9
zfjQ>`xT1+SD7d|z{{YwZuDg!!nNO<Q@4xl;Y<MT^+4~hYz;BAr;<<0U7}qjrZK6vL
zhrA{Ih%ZT+DSp*(=H_>ra$_Nxk2|x$&hEd(AG5FgB$}7S3y<xOC;k>ri3W|g?3=%{
zytpnR^E148ne+3v<;KisoR3VRijCBdB=*&P?Z3^jQ~lie;l7XVNiWGCIrzu^3H_$)
zzC3Mq3vY%Rw71rFR@#F2yTEbl(lgsaun8^Y`$R7Yc+mkyGAJkr!7aOc#ow`Qmx#Pw
z<K0@@T75Y9w@yg3_!7(*^c&!?2E9NWZ(?k$7$?hvY<^?B<J+jGDau;EKgWOTr$I$1
z?dAAw{dMYbo*MXYzYP8YLE(EzCBHgOjBJ)&n3C>65e)lAerIg926<}okJ)qfd+}Y@
z!w-b>c-vo&T|dG44ZM~b5@>IyUfSKghuM$YC28BtXrh*M3b4b=<$)?I=&C7R{P+7-
z{5iUR+utsOe`R*R<8Si$^*krxpX`z19|Y_F01v;kd~;{2Xg>^MxU<o0AkaR`G}iK3
zy{dhtb8!A-sD(aw(lu;8W6J`Y-vGa65BO2Kj*UO|=k}-eM}%y=Ew}7mN1OI}Ws}d(
znAqLsV`n(q_l|4UD5uXSE`Go8B)=&?ztBF*k4O46{{S?PJih&&?6uz&d`7&~uNv!4
z_>HAn=@(XO7RI-VD6S%MB+1-eXFtL=?eCsEzrr8zPb&=<!P>rya=#614epwjHk#Ll
zd;<oFt-~a8M<jF0a3_*EPWX|TRv6Wo0s?`yzLTPoZ8q0kKd-zyU!%JGKgl06>z}jV
zi+&`0de(IB9P2BrY2GIIbEs$%YC1NDCYfVp=G{U9sFG`s^nwey-7W}4!T_vWdjA0S
zIo3WU>KeS?5d39f;uO{VC2`><gG=!E(_)G#Wr|O<0VMYX${IdH5{Ko&E*L+(QAPdK
zyC%N(EBa|Rv<|oQe{zrO1kay56Z;lj_#47n-JOJA1a#d)R<?@CuC%{}(b>a!Z@V+W
zdkDQhXo^(;ZB~c_&m-lnPYnLZ`iFw_UjqLCW%!#<gH-Tdv3aQ=Z5hs%AiGIpmd@JL
zTq|2di6$XmImCN#RmTI{=&JUTz5f8O_-`$@?#bm=vFD#0{tfE?026i32Wt8kh;2MQ
zs`xiin^CuWy)5bwT$wE<wlT>VnkL(ci91{#FbK|T%KkZg8rHl&@OJ+IO0~V!{6q0m
z#-1aGT(Q=4-4<x9bnQkX1aVBmGR0|a4ZKLDW|XvwvH)av+h0r3QT=`?{Iy8Czw76}
zefDQ5AHl5=J_;WI`BHzvKH53Z*#rLZt=ba{e8)dAQh7bjYl6G|n|x#9pNFGB@ejlc
z8{?xJD~}H97JeQ3E!~yfq^l%1H(RbGOO_@y4zZ*P!KA=l%2V1Xr_A}e`sn^^RQ^}f
zu)fNVMf%$R0DZOZ)bTxg_Egq>A=vBpUMul#oqggxY-yIsb*AV|WoKn+Wq2;uB!TWF
zki3!?-0d+OrW9=<wtgu7%^&cxv|ov~pW9zz{{V%Jra`A~`yZM8o#jOF@5b@wXMS<=
z;~i_%=%bn1z?)kC0AJRJ&Qkmq@z;!gG5lY)(>z4J6!7<nCa|=)mg~dqbv4{S+0e%%
zmNS{7NaW?vv!v)5SL6j)HGhm>@K0F&DEN+PBh~yb9+$GhI|HitTl-g6&||b%g2Q8a
z_bMQX%v+dwOvR;?@5=(eO3_X-acReOZ^Qc2wb(sXp4PYJ{!8vWi^X5Ezx*WM556gA
zU)#P<{4A|d>Rx}?w|{45-qszPe8J{_$F_5o`}oHhGI;CuUH<@t)55<OG|%nNvwy<V
zWp6X=TmJyE_SnH`)65=k`i=cl?_;)4tkFp}t!{}&<gIVXeZ#$*ecOLF@A;n_{C@az
z;u)95zYaVbs`#4j%f|ZJ-p!}U;5|SkoYTBATrz7?6tP=CRi$Ox@*UDfkG+&H(?1)&
z6fedv1Ak^Fp)QZ8+Fo1gdS;;<OEIy$x0PmwLmOa7o74tOjmTIAQbP{DiZAZQKg(-;
zt!sK)PQv?5_x*2s`rlsXnArRk@iw{RPYC#f#eOQ%bxlXYdWGfMCYhl=pKUBt*_&Yy
zSGk$gsb-L|cic_@Pz7+FH~obt@lDQuw>&SZSxc*G+MK#yiM%WQwWjXAxJi~ow>L4U
zxr8esOxwO$WE%$KpQ31_^?cq|`Dy+@uA|G-f6acZ@-KnEvat9qd*IndyZxd(BjDfo
zL_+<9LH4iS!zbD}aufYlHUNJ2-s2VJI?uxU@7WpbBk<RV{7-SJ+<0OQA5x0T;nt<D
z$Eqc~v$PLyExU*;u77_rW_cbznl@y@<o#zwIk!C}w!e=vep|`CQ~VX2UoGv{--VL=
z657Ygx(ECd-L;>FKMiKpEj$A^ihMcY8&41FcHS-UoIWPA{n!$I><Qs$<w+V<E|L^*
z=PGcdcYZ1Tk?#Ca;$I0!x|f4=ohQOeW^9v8@Q}3B^tObfOBSDYw?F8X)A?$T35s0C
z&YQ>}ueZ@w>dDKQcjo!sztxk=ef84cEkDT~UHeOZ&sRSmA<))4?+$&RNSawE()>rD
z9dk(3H=tE%ZA9>Hk}@)kT!q~K04XF9$b2^ajJ3akz8~<=@L!Cyoj+R9H2a+*>RbN+
z4gI4|)GZ~vmhLtCELSkJPZP?)3Qf0bI4E+vK7gXLS}QMK!LP}*H?IAy_}}waJhcAI
zR@&y1@gB!t)#ueM{v}&MZG6z%t+cRgu}epFIc40%41?tXNdpHQ=UINw-Z#|s7&Si;
zc>e%L)itdLOP^2BE^T}+En>EsWkr(e?l!rT?GhD@S8QzpVdeR9$Yb_8DYtvysP6Rg
z{{VshN6(sX>{+SkzYTRg0^3#ibk@4wrnlF+Eysa;?+Ywz5}=L^Fx~?T84+e@6Ohtw
zV!1qehlf56N27cNi@=v!wxy}WG<MP^)NUVr%*xRi+49-vlYmLU01|PU?C7OGel8N(
z+W!D0W%vYS<0UBWw)^gQoL{m<-mHEZ&#riq&g%Q&^8J?K^!+8RBG#<Yp_UjO9(hU>
zp4QS*+n6zlz*P_O*3iFVD}N9CHt`ONZ{kao)Gxe47l<@nMQqppBu#AbwT-xpu@c1y
zjZuLsy;;E7kVm@FROcr7p7+1b>EFrSUjDt^($R9Qw)tzPnzOaLS#(DM@VntIv*GU>
z>fS2xUcIMygT#8Bq#9~Io20gxXK85*Na~3b%{+zLNnM$mQV+-iuG71b@t5qq;+=2B
zem;{*@#U72;r{@MGs1OyH}L-e+Al4kTR1HwTU(#BD#s*|#NRxTN~^grfU6hw+A4S7
zwY;p|-kWcz(`ns3e;qd0%Ey#n{>)6e55$`-FT_`RG4bWSy}hLN(J+@r@@%8ELL1Bt
zC;G6*1r7-Tf%&U}@Q3^p-8?sA;{;t#!J0YoYUs+={ul6i=(ZN8PP~%mf08a_F7k&6
zS)U_lJd7y%R*J59Uz@I<hQj+QJs12B@<)>VQ~j0G;%|$5Ppp4$Po~~$R$4rIe305J
zwv~6LUEE#4bMq3igCxtkGNUStH+=b9T7SV$6l;Dr@Rx{uS>nwfRlo42p?P-{dR~J1
zeY}xRW^IH)Ug~!RS(-xS+d0}5K+SrE6q9LL1ik0X_x}Jb51#ye`vh2c*47!Nx$v&3
zsoD64Ro3m-#GV$9S<^hNLQV2PC9_O~vXzXisVX*O>9v_k__OvVyYWYZd_SN=fAHr(
z()55N+oJdsSxcqdnc7FY(qvn_>Guq!M)T+V$QvB8pP=Zc2{@$~?5%H-vi`g4xJ%w{
zQr+M2cYllhHZeREp=%lu)xWj%)2<7>MoXIjY|`8NI@N-Nw#uL0Z6S}C-!b3MO7s5!
z2L8)m@QG_a5xf4~`$zmDy8gSaZ2K0^wSQ^7)A?ER4&N*7INi?uofkZM-4w3Z-EZss
z_hHiBclqo7Z%vO7{k8ltdGRMf@ZW}X7<Kr3TY0O)KAWo8*h=>LG(5w5Jl8vXn1|Tq
zxJ5>7?#`hUk&&&he$M*OhWuo@*TatzX&w=lZ4%o+yR_7FCe>`-3sUCQ;#9b|c;$>s
zD&)JPD-5Po8ugkfN8OE=S9kYY?n`er-%+;P*P^%Mf6wwqirW6k`j3G19}V32AH}ig
zlIZ#i_;&V9Pe@%w@8D^cV>)b>1&Zg)^BZwji!vO<Kmxb?HTygt4}QsUd@ef4xH0%?
z{5*9-X|%TJ3_f?1AK!M}{@JffqKSLZbl%VY3;g8%@y2qDl+)E)@UmXJEzc$K_w1dg
zd`x{h4PQ}`T{7Fjx`%`AZR58A?qj<)nVndY5U<&IQmhGnPs@YEXkYM8O(^_1@gIk^
zYafL0e{EPrX&#~BuZNIm*FoczCRe%LaWr=bWr`+fwjwc72*Ch-BSll3n{D;|TYsB>
z(nQDINiLgwt^P>)`$7GOV$!?|saQll8hB?~d+QxjP1O7y;8oDX7dCSF(3_Zz)Zb}M
z-~yrJ`C32-Ex2~S2!07`{tfu6;%^xEm&G<-A=P|Mr&wvv1&)x~b)}NpJ<~6gjXckW
z7d(b`JC%qyV2SCJQO^GWuSCBjh03jO>wErso<rmR0NG|=9{8)r62FKR(?#*sjiOw^
z6^3u@Z*4L5dzdZ^o>*1dtYdf|EV<qX%TP`5FUR+{_dX!hJa3`ic*-p-=$b|DpP+wc
z+UamjJThHQVwP*8G~_~sL17+aRoc6mtJ!F!7Sp=^xBVTxH0(C-zxB8IFX^+(e{4kl
z(f9|e=`iV<?yszC0d4eXw7UszWRFo+5?V^`ic$ngk~cEUQZ?Jlb~$#Rvi_@}_(#BV
zXkH|>(!6Ql+k1tZQM}Vmp=YYecopx=@GP*o^Jh^oDJm6pUaOQo%|#`r_5E*sd#f&k
zyU}|7Kh~YKJVtNXJ6E#)%GWgC7T81M+bw?U#8+CK)`n)&uV%TlHj>5mG`Nk@C4@$?
z;^4aZN?GJ3w|1WZz7O4e8t{gtr{C*m#5bC*v3smfcx=|wFLNoCkRr1H6t)LF0Iuqa
zcj@JCmYRBKzTt28-{-Ery0gRd-`R7;+8@IGOTc=6#8|9+AN`$kVWWsNHjh`+R!sRT
zCEDDCmN<hI0U?RmRY8*=vvYn7{{Vt}r-mc(IbBb|nmO?-x(uyt;eQ9Ni(zhbyY{=!
zk}hN{@`eampDVN;MihN1MKva!`sw&Puf!g^_rK--NaQ>_@UQy=<4=k_VfOz3H~tb$
zJ5R9tCy}@8-(+i(zkcJpf7&{27}?b4k0bFf>>oFZemL9szVBS{wZXFSJRT#rySVV6
zo5TpQNUkh@v|8tjU;$M`g?5d(Er#FpT@<4y8LEqQx89%TkW1c+gW2!*Tk>au_}}(7
z)O<_u{_n$ZYrYe?({&wdSJrM}*Ze2_s~Smrbo0d|09{1T&u`{PsVHNe<m?0tPj~wz
zc!x-~*YvLr{6Kpz4|vMn2(|Uqbb+brlSsC)+0Aipb>~L0%`_25xXldeBn86qRQsJ2
zmXYP@x68Bcv|n=UHzwuJ*6sY;z5er!_?7TmPxyuKZhr<P#m<ju_IM()xwQ(?>GE5$
zJ-nzKGLsv}8vwwAw**%ito#P}h2m*+jc)${;s=J;#-19xc{HobPYKBunf7^N^5=r$
z)vumecktVi<}IxpL<|NG?6g;X49gKka>1?J)-iguXS#c>8riKK&RUo{RV~eZ6|`-B
zO>NQco~q399T)apxrXmY)iqBMMStQ5d|Uqj34X102ATGId-;WgmMaWVd8}cLVliWL
z%HO*=EL$SZz56o%0Bz`k&--u6{{V{S-^P3X$Dj3Aaol~I8~gcte9qa<(~MWD(N+De
zisn;N)mqvuEbgqWYc7j!n+jMuGN$QCT{P3x>vbgcz4cR;yX$@Ie9`c`_I&ZLjO@Hc
zr)u6JT_3?0zB|=5Tb&wR0n<~wjdeLDjbgkrDy6K&B6FK}c2|%rsvSJLI#=u!HNVIG
zC&u@>?}cxt(Y!--uEl(OB%{Q4i89=x+1zSva>d|@ZUV-s3ILEqxFKuk>MODF7BxA0
zCZeR8vW#|W&!+8e_uE|zCzWC9U)m<`E^mrk-M;-U&jayK>?x;stKc??;S0;X2UooC
z-oJU`3kmhV4@ar#uPw#R)U6f8lgI?A<=x1fN{zWy!zmcAL;atA4MFfbz#rJ~>HY`P
zq?YCGXC4#q*zo;?uGj(o%qE-X+Nui~4t9=!V!N6vlD=<@twrJL&hc_`Yfav-r+sa=
zk)=Gl4NjzL!anp@Dt=$rSE=(4gn!_iFj;u^JzrndyeX<G+3H$#-QACb#g4hI!+Qh5
z?Wk%Eb1Pg*6@d&97dyUAS7&P9vyY8DMeyVP5nmGgK+^SnGRj>swCSMm*|obXXL$w2
z>!<ruq|&;;s9Gd}0e5dK@T=`KS4D0i$JUf*R%y7}-t2VcZL4XfucrGw35HpQh4~X#
zZM|iym9Kquy_V;e`2PUlcZr|keg6Q9d<){uE5jO|yQaaV>hWs26KeMN3vSZ2ywNIL
z+q82hpE8on=)kU1E0fE3gZ3(#`Fs_oSnK*UItPN`wM#pTuMaHVBD9hz1I;a_qa4u-
zX1Lm`C=fU!cmOMH9`{9KM>)mPQRI^Mc6_nEiKTaIyC%}T?6g)z)XV5j{K@OStu52p
zJ8IS6ey5Q9GyR&iF9`g1)ckX*YhE3=yS;*IX8y(S=k`U$sEo<wHm4}Kk#A*&IMpL@
z99uWZfrr4=_=Ed4>E9FlSK|w<Uh-GdJZ0fX{3~^56k#NaHInJtRg{u95p#exa8Mka
z;Cf9Jobyanrm8t=l8UlQ$!e0a(#DX&QiNO*(oXNK-S5}T@!b>lb@5)cs@vW8<Hq`L
ziDc2Vo1HI5Ha;Ex%`v^iVkvH}iMX52n__@GuOczNU)`O_<>zbv0I>d>;@<}RFw!+0
zYUH1WS}D_P?`<IaJ=nPx@I@8u5(g#;BQS0Q=L9)c%9ai8bXLFHSj8ncOO>sxqZ?@@
zqDdvBrMG+TWU}l!vT?nyyKjD5?%(o9?(=u>uNZ#IJ}>y4sd!p{6Zp@<I*k4vXk|K;
zzk^M#u>`Trz2vdG7l-U-Xx228Y>`+8z*T*V>wX2%HH`yExQAQUKez6ry}6z%kFlk%
zlLN}n3>#38e5lIDyz=`u9!+ggT-cm_Y(!%kjaoOdNhGfB^hqtvXyK{SZNm3<z1wd^
zWvg$e-@DW(qKe}>0*WZ00*WZ00*WZ00*WZ00*WZ00*WZ00*WZ00*WZ00*WZ00*WZ0
z0*WZ00*bA7rN?_9XKR2!$L{VVjDAW$sK4PKgZuZt_!&3<02M$NsH#8kkHP)>-~0@l
z{{V`k{t@^;zkB}xfs=pnRP+M%6-WLN_&>jU{{VrLfALg*!aoQ1?|<+zZ~iKc0KG*~
z{{V!35AWXp0N`Zb{8b<DkHP)>-~0@l{{V`kKrc~Lf8ig4`}e>288`m`6-WFd@PB^y
z{{RCf{{Z5s&<oU6ANWV${{8R%22K9}#ZmtN2>c)4z5f8f$-nrjGy?S%NB$A`Kfinb
z0D+T#@l=1pKL_{kfABJI{wj?Cy+u*~0EB)I@816a;AG$YRUhz=!TtN+{0y7_0E(kP
zFHux~;U9zh_rLfVH~#<?NBkr3e}4D>00Sof0OF|73)EE~_($OW{qOz;P5%JJQU3r4
z{2$-F{{X<rzxb*&0`(O~{t@^;zkB}xfs=pnRDZ%h2lwxP@G@`yDvbcWMN$6%gnke2
z-v0pLWZ(Q%AMlUC{rlhi44eM|ilaa;QB;57AA|e%zxWw9{{R(7{3Gyxe)s<X11A3f
z;;7II)Kwq&N8tYb@BRi&{{Y2N{{RU5AK$(I0Kmz=_^LDl^%Y0{5%@p9d;b7|lYjA4
zf5JZp_wRr3GH?DWjR3txQU3sheh=^7{{Y}*-~3e{@Q=a$```QwoBsfcqd+fFRDa<g
zgZuZt_!&3<02N34Bk+HI_x}I`CjS89sL%`4RUi0A;QsyZ{sv9|0L4-N00{ga-@X3;
zz{$V(sx$)i6-WLN_&>jU{{VrLfALg*!aoQ1?|<+zZ~iKc0KG*~{{V!35AWXp0N`Zb
z{8b<DkHP)>-~0@l{{V`kKrc~Lf8ig4`}e>288`m`6-WFd@PB^y{{RCf{{Z5s&<oU6
zANWV${{8R%22K9}#ZmtN2>c)4z5f8f$-nrjGy?S%NB$A`Kfinb0D+T#@l=1pKL_{k
zfABJI{wj?Cy+u*~0EB)I@816a;AG$YRUhz=!TtN+{0y7_0E(kPFHux~;U9zh_rLfV
zH~#<?NBkr3e}4D>00Sof0OF|73)EE~_($OW{qOz;P5%JJQU3r4{2$-F{{X<rzxb*&
z0`(O~{t@^;zkB}xfs=pnRDZ%h2lwxP@G@`yDvbcWMN$6%gnke2-v0pLWZ(Q%AMlUC
z{rlhi44eM|ilaa;QB;57AA|e%zxWw9{{R(7{3Gyxe)s<X11A3f;;7II)Kwq&N8tYb
z@BRi&{{Y2N{{RU5AK$(I0Kmz=_^LDl^%Y0{5%@p9d;b7|lYjA4f5JZp_wRr3GH?DW
zjR3txQU3sheh=^7{{Y}*-~3e{@Q=a$```QwoBsfcqd+fFRDa<ggZuZt_!&3<02N34
zBk+HI_x}I`CjS89sL%`4RUi0A;QsyZ{sv9|0L4-N00{ga-@X3;z{$V(sx$)i6-WLN
z_&>jU{{VrLfALg*!aoQ1?|<+zZ~iKc0KG*~{{V!35AWXp0N`Zb{8b<DkHP)>-~0@l
z{{V`kKrc~Lf8ig4`}e>288`m`6-WFd@PB^y{{RCf{{Z5s&<oU6ANWV${{8R%22K9}
z#ZmtN2>c)4z5f8f$-nrjGy?S%NB$A`Kfinb0D+T#@l=1pKL_{kfABJI{wj?Cy+u*~
z0EB)I@816a;AG$YRUhz=!TtN+{0y7_0E(kPFHux~;U9zh_rLfVH~#<?NBkr3e}4D>
z00Sof0OF|73)EE~_($OW{qOz;P5%JJQU3r4{2$-F{{X<rzxb*&0`(O~{t@^;zkB}x
zfs=pnRDZ%h2lwxP@G@`yDvbcWMN$6%gnke2-v0pLWZ(Q%AMlUC{rlhi44eM|ilaa;
zQB;57AA|e%zxWw9{{R(7{3Gyxe)s<X11A3f;;7II)Kwq&N8tYb@BRi&{{Y2N{{RU5
zAK$(I0Kmz=_^LDl^%Y0{5%@p9d;b7|lYjA4f5JZp_wRr3GH?DWjR3txQU3sheh=^7
z{{Y}*-~3e{@Q=a$```QwoBsfcqd+fFRDa<ggZuZt_!&3<02N34Bk+HI_x}I`CjS89
zsL%`4RUi0A;QsyZ{sv9|0L4-N00{ga-@X3;z{$V(sx$)i6-WLN_&>jU{{VrLfALg*
z!aoQ1?|<+zZ~iKc0KG*~{{V!35AWXp0N`Zb{8b<DkHP)>-~0@l{{V`kKrc~Lf8ig4
z`}e>288`m`6-WFd@PB^y{{RCf{{Z5s&<oU6ANWV${{8R%22K9}#ZmtN2>c)4z5f8f
z$-nrjGy?S%NB$A`Kfinb0D+T#@l=1pKL_{kfABJI{wj?Cy+u*~0EB)I@816a;AG$Y
zRUhz=!TtN+{0y7_0E(kPFHux~;U9zh_rLfVH~#<?NBkr3e}4D>00Sof0OF|73)EE~
z_($OW{qOz;P5%JJQU3r4{2$-F{{X<rzxb*&0`(M8NCJw^)i32Yg4PBRw$Cz23gn<9
zfq~N}2d||;_It1T2;Khx-w}WD6znUT6jndk?!V|GcmDu<MgIWAQTBVU`Uu_s0N)XR
z@f7((nEcQG0E3jj=8OLT+;jf`an<>6U#Fk&aqM!({{RYa%(<H5{zG`)5N-bekbh08
zDE|P1aHEz__*|Y{%+~(^@&wMnhj;vhI_^_nnC6%du4l5tb8_=rTVH4=<=FoKK|DR<
z5A|Qc>^^<$eXp|T_c^(5&5D#hD@xYpzRvcynfZrBe@`E0y8i&6jo<z87ykeeN7?Sb
z=p%Rk0DMLN0K`|J{-XZ?)Bgbcm;V5^J}dqv`~Iar`CtD4xSz~D75zMYp6mXCH-GoU
zU;ITMXS)9YppD=C@fZI95l8xq{{T<_0P<h{*gxWLzv@%}0G0m$`-%L+(O=WY+3vsS
zBX|D*d`15N#8LKpulfkx{{Y_+fAJK5sK5080RI3b{{ZcS{wDkWr9b&!{{Xn3%smzT
zJbj+){(?7u_rzcPMIUFn{{Wzk-~I6y{{Rt3`iuVnPyYb&U;fxX;%~p|Q~v;!{{Z`m
z{KL^-)5qEFzvv@({{VbN{{X~M_It1T2;Khx-w}WD6o06{^#1_=044tb?SuX%`~Iar
z`CtD4xSz~D75zMYp6mXCH-GoUU;ITMXS)9YppD=C@fZI95l8xq{{T<_0P<h{*gxWL
zzv@%}0G0m$`-%L+(O=WY+3vsSBX|D*d`15N#8LKpulfkx{{Y_+fAJK5sK5080RI3b
z{{ZcS{wDkWr9b&!{{Xn3%smzTJbj+){(?7u_rzcPMIUFn{{Wzk-~I6y{{Rt3`iuVn
zPyYb&U;fxX;%~p|Q~v;!{{Z`m{KL^-)5qEFzvv@({{VbN{{X~M_It1T2;Khx-w}WD
z6o06{^#1_=044tb?SuX%`~Iar`CtD4xSz~D75zMYp6mXCH-GoUU;ITMXS)9YppD=C
z@fZI95l8xq{{T<_0P<h{*gxWLzv@%}0G0m$`-%L+*QtKPpYnR&2mb)<chP_Jz8d}4
z{kGt^AF+qU+~3_e{{Vz5S;~})4gP~S942e<m-ZwC{@MQk2(ZNu{3g0K7-K8`oew<m
zULIkSe`jK;L!X<Or?tBJv-Qph@lXAC;oQp=^<QD^qbS>-p7*BR@5u{(C-j3wWBs1%
z{(?7u_rzcPMIUFn{{Wzk-~I6y{{RtRt#Y5{r!lcbWBs1%{(?7u_rzcPMIUFn{{Wzk
z-~I6y{{Rt3D03SWRzKP9zvv@({{VbN{{X~M_It1T2;Khx-w}WD6mo|#u|;G3p6mXC
zH-GoUU;ITMXS)9YppD=C@fZI95l1L<8x&SQ+3vsSBX|D*d`15N#8LKpulfkx{{Y_+
zfAJJ@hcU55WBs1%{(?7u_rzcPMIUFn{{Wzk-~I6y{{Rt3D03SWRzKP9zvv@({{VbN
z{{X~M_It1T2;Khx-w}WD6mo|#u|;G3p6mXCH-GoUU;ITMXS)9YppD=C@fZI95l1L<
z8x&SQ+3vsSBX|D*d`15N#8LKpulfkx{{Y_+fAJJ@hcU55WBs1%{(?7u_rzcPMIUFn
z{{Wzk-~I6y{{Rt3D03SWRzKP9zvv@({{VbN{{X~M_It1T2;Khx-w}WD6mo|#u|;G3
zp6mXCH-GoUU;ITMXS)9YppD=C@fZI95l1L<8x&SQ+3vsSBX|D*d`15N#8LKpulfkx
z{{Y_+fAJJ@hcU55WBs1%{(?7u_rzcPMIUFn{{Wzk-~I6y{{Rt3D03SWRzKP9zvv@(
z{{VbN{{X~M_It1T2;Khx-w}WD6mo|#u|;G3p6mXCH-GoUU;ITMXS)9YppD=C@fZI9
z5l1L<8x&SQ+3vsSBX|D*d`15N#8LKpulfkx{{Y_+fAJJ@hcU55WBs1%{(?7u_rzcP
zMIUFn{{Wzk-~I6y{{Rt3D03SWRzKP9zvv@({{VbN{{X~M_It1T2;Khx-w}WD6mo|#
zu|;G3p6mXCH-GoUU;ITMXS)9YppD=C@fZI95l1L<8x&SQ+3vsSBX|D*d`15N#8LKp
zulfkx{{Y_+fAJJ@hcU55WBs1%{(?7u_rzcPMIUFn{{Wzk-~I6y{{Rt3D03SWRzKP9
zzvv@({{VbN{{X~M_It1T2;Khx-w}WD6mo|#u|;G3p6mXCH-GoUU;ITMXS)9YppD=C
z@fZI95l1L<8x&SQ+3vsSBX|D*d`15N#8LKpulfkx{{Y_+fAJJ@hcU55WBs1%{(?7u
z_rzcPMIUFn{{Wzk-~I6y{{Rt3D03SWRzKP9zvv@({{VbN{{X~M_It1T2;Khx-w}WD
z6mo|#u|;G3p6mXCH-GoUU;ITMXS)9YppD=C@fZI95l1L<8x&SQ+3vsSBX|D*d`15N
z#8LKpulfkx{{Y_+fAJJ@hcU55WBs1%{(?7u_rzcPMIUFn{{Wzk-~I6y{{Rt3D03SW
zRzKP9zvv@({{VbN{{X~M_It1T2;Khx-w}WD6mo|#u|;G3p6mXCH-GoUU;ITMXS)9Y
zppD=C@fZI95l1L<8x&SQ+3vsSBX|D*d`15N#8LKpulfkx{{Y_+fAJJ@hcU55WBs1%
z{(?7u_rzcPMIUFn{{Wzk-~I6y{{Rt3D03SWRzKP9zvv@({{VbN{{X~M_It1T2;Khx
z-w}WD6mo|#u|;G3p6mXCH-GoUU;ITMXS)9YppD=C@fZI95l1L<8x&SQ+3vsSBX|D*
zd`15N#8LKpulfkx{{Y_+fAJJ@hcU55WBs1%{(?7u_rzcPMIUFn{{Wzk-~I6y{{Rt3
zD03SWRzKP9zvv@({{VbN{{X~M_It1T2;Khx-w}WD6mo|#u|;G3p6mXCH-GoUU;ITM
zXS)9YppD=C@fZI95l1L<8x&SQ+3vsSBX|D*d`15N#8LKpulfkx{{Y_+fAJJ@hcU55
zWBs1%{(?7u_rzcPMIUFn{{Wzk-~I6y{{Rt3D03SWRzKP9zvv@({{VbN{{X~M_It1T
z2;Khx-w}WD6mo|#u|;G3p6mXCH-GoUU;ITMXS)9YppD=C@fZI95l1L<8x&DRNX(i4
z0OVu1{{XLOfAlG8YKDLL816so+8_N2TAH*VD6gIW0N|iswSSC%Wt}I&llW7^wmP`i
zZf-56p7PS}=?%i7n`;=-*lrWuNW~*|`4pkZIjp~qf3~-e{s;VL5nTKz)-?|R*myc`
z5^8t$mrxss401vCf(yE#7U=96A(<Syu)--Olp80RA1(g?!N{NUMt|-%{{Xo9Kj7QH
z`K;gf1pffsg;f6lgNgO4e-db)19clm^DS@S)-GXkF}WRd=2MTM6>t6xyZ->1&Hn&!
zPyNVO=fCq){{Ua}?EcgL0GxjQzvwjmGrHE+8>WI7C%c&dF0h6D-g;!Q03U4Tnf<eK
z{{TRpL;n6j{{Y7+JTSlLGq>?Q-N9q)iCstN0Q@Rld&D*#71CzE)bDLH>l<(kw>MKP
zF+>RfZgwCHk_RWL75V}ET1Wk}bN>K9okRZqLH_{9DE`^G{{Wy)q5lAXApZd4m3$nE
zS^&@f*}4A!piZIx0DmC=0OOQ@Y~23<&?iv;0Kbrb@ygJmfHVI9wr+pu6R3aR$Upey
zAKN!S^a<2I@8lo+a<ns9-V^bLljGkH!K-L`rk$+mcU!!R%L|max0`DeZL%RMaLT~o
z@If7@0e`k`f9Mmaf8WSI_~jqlH$U_V)Iaa!AN+E(D4-1g0PUNf`UL79_wo<^IY;)*
z&;0^*5BvEC{{S4V3Md0V`)23<fjWo%{Dc1hj#2%ybN>K9okRZqLH_{9D?*~Yyo*k>
zmg3@A;DQ7)NhFLFBTzC}lfVFSNu=GC*wx;Msr|Ea{{TRpL;n6j{{Y7*{@J<z0H98x
z{{Vj={{Z8Zo*(gklj6%;dGxJQPSl{gwTk))EiO`Jn%+=MQz=qGjld;XaM(B|mrC(w
zm#*sCorRXAVR?O`%8+U{&|D;v*hulLsFI*0#?2d}fWQ*2q;Nr}W}TRmy1EbTo1gjw
z>L2&=5B@nv_RY`z0(B4j`3L_19IXl{13&v_=l+2@hyDD6{{W6r{j+ob06?8X{`-Uf
z0FG9L6anPlwsxr=qx%<pVNf19V(?b7B#K4Drfet1eUD-|ufmVmhyG7T;Sc?ex;Orp
zLtnZ70Jkda{g(bJ5&r-!J|Ao0z4qE1ep{RKufq@6hyG7T;Sc?ex;OrpLtmfqXZ!Xa
z`s#maeH%aIk<Na9`e~ohg%!(dUm83$p!`+Qyb*D!C;TNk^|aTPntV~bvIrs>d1TrM
zi8$IB%7$;1a(J$$zd%2WLbI2|KWXOH&hGLo;7cEtsNX{DxgO(+cZy^%_+wFJIAyhz
zf;%0CuEPr3!m*&*hyth`fS?LL+c!V-3DiID<RAQUkL{bE`UL79_wo<^Ia(A@27mU=
z&;0^*5BvEC{{S4L`)23<fjWo%{Dc1hj#h;f0iXS|bN>K9okRZqLH_{9DE`^G{{Wy)
zq5lAXApZd4m7zrdXa4|f-2VX3Cs6+YzmR|N%0ISlf9Mmaf8WSI_~mF;M~eJ^p?D3n
z!LDmsPK<S{==9AzUtULV_WQXqW4DWW9%QYxu#1*EP6rfu0YCQ5&;0^*5BvEC{{S4L
z`)23<fjWo%{Dc1hj#K<e;!Qij-XFcywR`(5D@xN~dz;JK$<_;dSdbQZB$0?zRREI2
zfB@#A@du2wj|u2QRMj<IH%-%8NMaXvcPR`7=8<EGcd-kXk<k=q=4VhcNT6fCwr+pu
z6R3aR$UpeyAKN!S^a<2I@8lo+a;(|vR{DvUTh9#U-a`z&TZZzSV3lliVUfY-kyFqk
zKl^6q{((A&{rrRf0FF`pvvdCdK%GPW{z3l$$16gyw10@cAMqBat=Vb%?u~tU;i*;)
zUf$mJIc3tMXvB(_3am^_V`Xq31gQt1q%zO;&CmS;br1Xb2mb&Zqx)v({((A&{rrRf
z0FG97gFY?zQ{ptsABVh6;q7`yu(#D!H0?$kqSkjC{ELtgkM3pi<k=_PeT{-}YnAwy
z`)B+f_%Y(ibRQUeSNLn;J#qv|CDXN^6WLf@#;!LjG*Zg00UUxyBAe0K?j@?aJHPFl
zpZWyqANTSP{y9hX&CmS;br1Xb2mb&ZsJtoTtrN#^-N~Wr8dkEJeZjQ4Ya6)k1+>9c
z%uZ09t`*SjJmHk%ky^A^6HjA5`)23<fjWo%{Dc1hj#2%ybN>K9okRZqLH_{9DY}P@
zw2dRgntqLUs_C}czONk9SlG*QiF108?K3n{lexlgO~pYAy>pC;JR##fBjOK-t@V8e
zRnv97ChvEVd#Bu`&Ai)KqivB1R>La;gTVxLpa*|!-2VX3Cs6+YzmR|N%0ISlf9Mma
zf8WSI_~mF(KpFo4+c!V-3DiID<RAQUkL{a**Gber@3=qs<!Dhr5NZ01TAUl=C*@+S
zth-qlbp#%Ur>yHW+2Wh<IyJlwN2_j>XYx_`R*e7@QAGe0QCyFJemnS2;)jhqP2uee
zS4;h4!SkiIuWlfgKeD?Q00w0XAk1zFLckRukVYw8Uze``0N38W@?|*2+|Ji_UT)3V
zdD%DUnb%QR9}NB|Xnz=dBNn^i%kS+SDru*;N&J~1-0;fq$TrBT+(?W%VB;er29Ji{
z6f{4Jz8rm9!`I*18hm$i*tEV(kz!~iXr){_srg-4XBarhBy&kgOK#Wscl6bL;#DB+
zXSu&c1mdZ9f5du!i*$&!4J!W6Q?Q({j^@&Jni)2+R>P?v;eiJSf(Y$YUHTVjqKW`0
zqKW`0qKW`0pqy8k=-;)!gSGD-FNSU6@vzp9mRjC#1nW=;Qb%agSsm>HM-gOjBxVWn
zH_gGLcVrtYy^l<yvV0HYeKX=mgse5)7U%7nR;Lh}+J7zM^Ao0axC}aX0=1|BqKYU0
zqOv>_<E<~^HiP}Aqg{Qn$L$vuo^O=#{`Lu;30DpQ`DBgPIKjq7K?b$x0HTU00HU&D
z@y3@ojwbNh+~-=iu}w-#e=Yu7cah^)-Hp7mFvfGoOc7etbiei6^B&I6`s?`x6j4Be
ziYTB0ipcSIj&#2QL18AVb@o)$@8HudkCgA`+)Vo-Pm~;PV~m^u+=|zurT+l0>s9xM
zTYq2Hj3}at04SoWXnOsRiS)RywA<TFLdtykcNWtuu}Okd;gpbYK^z{S&;`0EqJRo0
ztb2bR=~wV+(^*`dPTN$uds};rJ{P=$%uW0E$q;0XL5<Y2l~BMgcMu2$#S~UgjXZIs
z{5;UVw6%+`vDtm5-qXzT-cR1oGC>mIK|eH-BIg(x$sht~@)@l~WcWwN8efj>uVvD%
ze$^hGeLkCTe78?7;uk3@e86XG0x~iWVryECmkzcHD58M{6j4A06jn{&jx@U;8`$`A
zTdlgzqh~&$ZExkd^B{rZNndt0jjcRG1cG;P4h{~s16qnGpaP00paP00paP00pbZKr
zqO&wIXa4|^j^qBlq5lBTrKzeJ{{ZA;xc>mJXn*u6YHHAf!oT34P+eR6D)6qe4xgy%
zHl7yo#)GbEDPd~&Q^jX*eH+ax#DKf)UPw?*0X+e)GWfy!eE3uLgZ+s<FG-_m`r1tQ
zH@*P1ON(P{mseMt?QLfBCi2!e*hr4zQmqikVV%3a!mLZbhQ1xtJTZNuTxdEy#*L~?
zEyeAG)^W*gcO<eIWqBhYtCx|Bu^{D%Cz_=t)P|Y)A^!jcg7}wX@pJZK{h4*mJ}ZcA
z<<oVGLmc5lq_*b5-cgk$Nb@3mFeEU+92)em_%`qUYd8JDKldS3f8gS+63@eWN5LBn
zI?~$0!p=Qv8+&VLmMCCAG~g8xKneip0L5DW0E2G-0OqrQ+!Ox*auxaW{{WJs`u_l*
zXZD}`<L~wV070kee}+Hg8z=pJ-2VXR`76tR;Gi;?KV#n;y10y`v@9H<eWYAP&e6&G
z4z=mN9=wj)TbmgfQsFKokRu!yM|N<-)O^_dD_Xw&AH~PWn$PV)sp$~-meWu8i$1&I
z`7bo<D-RYA?At4CBKBc$)7r~+ZDh7sqY*?h&`Tn;%8XfvB9Djv0BYYBzlHu9U-*N@
zHt`$#yQ>@hH$}M9#=ES|7Npk5>1}gt4aL61K4;mZf>FyVkGQ{N(N5reiSYaOjrfD&
z--_NOO<%@75%A5PoOO6_G&j2!dZvp60&lb3uAVFsVZtPZ<hzzBRQ!qy06Rb0{{Z5*
ziu@t)L*abh5b<;A`iG0WU*YW%=UYuO2_ELs?og9D!7?%<I-HM}<s^Dw{Sie=S8;uu
zTk}b#*Uc+GUZJlnlHI1g8%-zj-1tuS_L=y>AMM#EfQODe6{2bW9M`nnD&I!&Cb12s
ztK&T`NG;mqP>RMqA*8vPneH~rYk6-3PZrrB3XEICejWbQ9}~V7{?6YCd@JEk6?iM*
zwvBn={ZCZ0*St@y#id$n8kp8EBl`yVw9Dn2VhG&Z#BJx0OZ&M-(~s4vDX)ep^xw}$
zzdd_jWGgOrCDmDZYM<n-uD0E_d=cV*+l$9he%gK;(6sLuY4&z4;x+KEh<rP#T-te7
zu5?-N1@u;;#cyM@X=4R0C%;hPT|^(mytE&;*TidI*{bq=JI6L&Cf4BbR-dDIlgB^X
z8bkOyLASWJnn$?PwJSX`XybrO9C5L}wVmzE=q1XLC4P`mLilX=)9`7(zR%?Ct%ub=
zCcpHpepg>O`JPGp5%|l+K0N)Lbd6KR-Xid)i}h)yx>)s(4qpAX$56Lf<XBuzEv=)K
z{IH?qiU{I%1(8CKE9TD#e%t!2e*yeu;|~%1R=ocJgu>R{q1QYSXJw{Y&G6o7H5jd8
zk<8ZbEHK2bOtaqk@wzKb8f;ys>%SlT2hlzyc!C{IQNHn=wavV15~h{n{aZ=5Ay}|2
z4Xw;kGi02zDI{PLKmxlUFe%I4la}2r{ePC78VKp5*Hr%i;D28<etLWj{iyygd|~lN
zf&3RY#O1gC)bZDdd^>aEEh67e)h5(zE%a!wt!0XL)8Mv|gUSlZmT4QPUy?v~Hg&)4
zwc{U%pA5V|r}*3AVDJnVo(t9IgHne{vM=N9Ue{2(v1=fb!t0R?5lYtff;pr&Kf7gA
zBELsytgA!XE?$jU`TLx=`~B-|-uE3A>C2mUd#^8ln%{T3ev4}#nVt##qkK{Df57oJ
zjd!MKwwiasZ-#N*Yv0(`(_DCV%J%B+3)}aQ#$Hr{6*4N!UKogHDYVJEN5cOAv~c)r
z{{S0rw2z8c+L-Z2#4Qg;vG{=V={jwp4dL5K65{IaOBw8Ah5WB9O%<Cgj`4&*UnBI2
zit4Xd+SHXxTbZ}=a#FY8*UjGgBP={UloU6#Qu(Oz-|$Y`X{DXp{L}bF@t?<jJ^1bW
zKYT&)SB>>0)^!gB_`^zvOpELm+JA`kTP;cm;<E-zIOJ)rqlbG0SfBkHF{BITqk8`U
z{1XTEl=zwZLHL^b^Ts|n@DGSAuCz$+FLWI<S6j_n!rGCM16xgQnq8Y%#sf&E3#o2r
z4H(3%12OwHiipnJtu?om+@=2jw|)xNcWiKNZ?2c~vP<;*UGA)x#h>ubpSB<TH(&gm
z7yMWc`3e63$ho3_Y<>R#`38T-m;OwDbGG{XPKpV@s5Cr#_UHcqlUewq{{UqF0K`A~
zNneH^u@C&7kHR1O9dvK~E{4ByzioTO)jwr_i;V*bBeU=pyBv<EE4}R8?a!zPbM+PY
zYx@xY0Lke5A^!le*GB&U(&%gR{w)6he#8F&T~F;Vqi6h*InU4k08KOW{{Z3d?Dg?K
z;ZN<M;|(uR_@Clk7Wd*r@@jf7iS2wjr|MB^(8Q&UjM7gFy|j=Z%EkzZloFvx!TTTK
z2ZKCA;7<!lXX0NN-+1FtYlf9|3%x$p$<i{a1VJs)699s8Mo#0-0LN8DeuU+7_^~S)
z-Y)+DkyBIu0Ix}Z^aENoPsA3FsAxB^C*PjlNZ0CAflH)o5bHLJBu)v(&YAh6J;5D~
zNY5|*tUf1Sd^pqmFstGp_(JqOUsE=^$B9k6QjHoB4339%$nZtxNT{A<%E&ik86v!=
z;-BpkuXuY<zkz-xrj;(6;rm<v01B*nZKR*@u<l(XEr9V8C@iR+RiTZ>{n^^fkF02*
z50h^GG5k!{JW;M(MdHTM(@*j4o8hI>j+bjJFx%bPS~RN8Q_M0)B+lsDz|RgHa0EJ!
z?FHh04C?w0h2kHHhe6X~@kYO*YF;C_u&|10t?g~rNFGLLe$Nz&TxI;Qha9gsudXYb
z@lV3*4;Og%!yY2Jn(;4uCigFBkvfQ^GsWdUm<p0`y)Z{TbJCa}A$&;vvAl7kd@R$h
zZG2AlTK1o(-D=QHc(!&n{w%VN_E@5oAbUBao<@Q-mC^>bRaq6cs<6j(;?Is>5j2e>
z<3_)yYVUqLA+B5LI%b&Gut#a9+skibB-c{NkV!jvLTQ{Im?+#?Bme>RJrn`+uk6F|
zW5j+d)O1+2{{V?z7x4slm)EJMrim<i!s{@lye?K-=&bD_Ss`|I{oE=DWmA?@URV2j
zcvHtewTH*8TfzST5A+WVYpw9Z!y@e5>l*yJSkd+S=Mz}nLL;-e^Jlh>&v-^L4Yz~m
z`MCRfiisxO*6aM5{4aIcr1}*XZk@jdpXqN#&&<Et`}X0v{h)tm?}&o$$IbBfNY#E4
zCb8k~4T}p|CGnNb&867XB4(N=nf}W0h?y-~H;9IkLQsKMe`@~#kD8~9Vewyu_3wxW
zK)Uefj65A<qId-?El>8=nAiF=-`cG05xQ_^c~D6ds{(mD9ZQ_o={*&)np5Vsm%YF3
z>#w<Kt@nCf){S{%8~i<byQr>~{#)s0`n~V)M}$5w`1i!09^vqIh2pgEU9XD%E_laB
z)NeGM2Tc1^miC%rO#=fZyCY7n0rRCtX21`;00s|-{{U|f9Qd2TeiZ)zgsb9*{42H|
z5!G+3wODkE7k?e=R(h4)pV<U+Ln4+~t>Kle?L>0OZhk_lgjeXTdAG;!+1785kPBAv
z{{WACC8gY2Nnxp2Xcrc7L#sh2-bos3X=RM#E9P6gQUJ&2>5f^#e3676(NX!Te2MvM
z?`eH^y^E)1IZj<$e<wa>y!7{Vwwqe|W_%*}_5GRq3wUGVXN@%hBSYYOUlMC~rZkVt
zVPccdCe#5&PUD3DbAUTn${({ur;q*td`;0czaRKx!#*0f`0t=<R`<7Be~72lt~DKL
zjn=Vm_K0521h-{^YxqD}CgM1gb`f*-K8gD+_)o)HzLj^UN#gxIG)S$Wvaq%BhOZ8p
z1a|SHaYyzgxfaC&qJpL}8<N11bLf@6Ekdm7N*XC$CD}Wt>!Vt1oKsruo*SN>I&hw@
zHg8?pvtM&h&8F6!e?C9pjX&}_X@B-Xd;$Lep=#Ci7wvs#6u-3Z?8sUu*td>#0K}*{
zAMlOp{cG92BK$Yg{wU~ar|MT4^|TSpCl91+m%2RVfFJ`kq_Id><~dT^Nx>r^V$Xtn
z8ENqU0K-=LO@!L4_O`pWKBcN$>US-<iyhP4$t17IINaw00AK(srnV>ARh3q)cHiFH
z{Y>f7<b#5H#^3oOkLiEI%=kaR{yOoG!M}^XGw~LS;;V=>O;`4b9vIX-JN=((_L_tj
zw)Sy6uPY(ASy76z80194kjVMS>Hh%WpWn4V#h;I#AEzEJ@n3*pw`+U<0PU{=N3AW!
zx#4-@oFohOCDQHYwNL>L*Eg3dF7;@L2cNg=FUEclwDISLu5_E}bx194!iRl3Qn}M^
zR}2_zp55b>IRiUfWMmwIMRCwhojAek%9K~i5Qpa%EpKjXD_ZYau4&3kPG^6<bCdhj
zlJn)iT|OuO0D`r6KgJ$A{h>Y&>AneRWYs3{--{aR%Gy%}=C5L-OKZC;Y4iS%aXbP@
z(ozoAara3MyqCov+oQz#r;L0jqx==|N5hYX-w!|G6w|M~BAz4E(?++~t~}Y{pG^BZ
zX?Kr1+j%iW_IA?R+{VrKn{e6p&%>XFns>s@7F!K6=foFKO);IDSJ$t#iGvUq0$aJI
zkyi>nP{BdT#z`ljt!cFmRk}|8zZ18oy{DspX_YqT4qmov?`i&;+w@1r8t3f`@lwa*
zUy42$j}+-TMzi4=^=}y5c#BuDfi%J4*0U|9$8f<_QZ>DqqIVdO#ih)}fnwF%{{X=|
z{x<3#v@gK#5F76o>%Jw{G~G$`>yHqv#*creNinvC%js8k7O`7g+aZ(XGQ?z84w3`6
z73%*04Za0w{{RlWd*YuIHm9s>-XZa9v5TASO`$SdTEb*D_E3nUjaJ?hG`m3s$&rh@
zvCVe%H2v7w>v*N}U43n3F7EHGg+F=e(Z8C1rS8{dWzhJ`_F4U({{U<M01kfF8vNfB
z{yf9tFN8WIf%HpzPY&qz_r4_#2~@Z-+AG_veIH{2?Tv&kO?{h1Be;!8VgMYHPf9>%
z+keQ{d;b7lmj3|y9QC7FS~b$@dfoNZBt5^E6}m`1>y$27gWP=JXV})Q0C~6V6Z=H3
z?A;EBtLoYv?bm~@uA19h)~%m#@aS!#8Rdj2W`&rQcLaHS5)Nz0qL)(t0D_J9m0eBl
zlkg8nxeTOkg5%;0@wec~r>ifql#frl^yU488m)}hw@}4%ZF3t%G%}!cl^9`_l<+|W
zf)8BLVPOW9V-2mWF<V<(MzKQ-ND(4M7*$mq00001(-qHBjHfF}`@O&5_VWESJnHy5
zm8x2#{{VOVw%^IW<?7b$>3&@fSN4GTwQKMv;HQcFUw5>}plR~mA`||)KrtL+-JGhA
zcCV1W25H_t{g^&1{3F%;Y2j@*LDRfT1l|+YwJUve-$|(7UrhJVO*B44Vix;Rl}FC_
z6Oo=We(j>G**|Qm-)m{*s+XU=7T1=J%)Dj}RqWLHZMKVh#!C0yCl#Wzwbk`MH-BfZ
z9t{V;KM!rZDdS%iKg3zSAY5Dj0Kzd1+``IDE%jTEwKLiPB6tL5M>h-!SIUV7&8ufm
z_>JOE1N;i`MZLA}_D6#CFC2KCb?fHw6~~8R5-sfJ+9|adA(l&M*^8WjyUGPDqp#@A
z70XKnC{a}TwpQEzz4UkfOZv&a_v3j)n{8CKmeGHUSFWwz&%9DvZg|J+i*2p=+xAzt
zw(&oR;_(w+o6CD`S4q|GCX#DEIz@*UyC9ZHRX$%mRZDFQ2`4AyZ`t3*Rz3y&n*J7O
z()ho{9vkq9*R?B8h<Dc7&Eid<&W$;<wRuYur^PF6E@Ls|kVys0AJPgdqNNULb1uni
zt?c@~x7PjMyInn}mh(m)_OVS~-R<Y5*3;~^wB2|&>>J{(PsIKm@t_*cv*K?BSon%a
zJSD8^vpn}Yg^!aHITJV!JWDZ^QdTTjDfx~o=eylg#n)aIZxhGy7suARjK3OX@T5r|
zu_IdB>9gK>4G4kvM%zOYjOxZR7jDoi@7gGIFE~lRg(d50Q*FOh2N(V)=<23k=ZE$@
z_I~qCbaGO)mG*;@aaYrob=7<c@n_-}j{XoI8hB$)@h^xkyd9%_L9(^K)U{6$T|srF
z>C@@SIfeBh9P_~exGJVyq@ZkWUB!jZ3v2!_@nU=^(e6GXUR`J&Aozo*+Cy{U&lX+k
z4>p*(d&(^3)LJ-Xx!WLcCBbDIcE0rlecwez94m|W<;=a`{FjqYH2FXBX?J(Vrd26T
z$~78V>Dum3M|;_GTHAZ6^j7@p{iMDs-FQ>MzZ;iP_>J)s!@m&xEvSnx3uv}_)$D4z
zIxGtfz>E{;i4~-2E}XN5AAL{W+Wnw@Eqp?g_J{F?mfkJ0@P4UbE}j1X2w>EFVR@w6
z&k2q;G9`polE<l;B{C#|+?B@Asg1|#FNxo>J%`305KkwFd|~6O{{Ri$-bH(H;d6Zg
z=`*x@N}~Y?oW;2njDB{)dv>o_0|KI!8h4DREv<h$Z!Wfzd%ss?-k4O%>eQV`sdB}(
z*PgP{*R_&smu9(R(kl2K1^At#d_=j{?X;`ayt(k!pxRETs|=BgYo$bXj2BV63hHvX
z9QDXG!)Sl<dwwkc0I?%T{{Yh6PQ7M|?6vKE?fA6Q{O@m-`kwS|p(sATl9FrZWoG)l
zY_>i+{hjnX{{V+R3HS%B={oO;r@Qf7*Lr3Bjn=O;nr*~C+4r{*BHEMWL}QZLAhJe^
z<Zj;1S&72<1@S+`y5yg4)IK8kUqkT(S`Mc#i{Y2Yx4O=$VK9Y@Of(6tV~)-3t`&Yr
zil{)#nKvs}+*DP!erxqs^xtp4UiunJcaoCwe!AbU$u8fQ!|U;PQL*?Ddk=@TpSIZ8
zc#BN3@h6EQ_>rjUnkB`gkvWm!)*3mdu_i$ZP9s1d6Cn<}jDz2QVy#y9SNL_S$tQ^X
zH{x9<`(97%nRJgBP2#a-0gfWp^54xAa!Ttdk$`>7sUj}o6j!m)SI_Y`*Zv3jY1;1F
zyXMxBOQ-xF$6Ghn%ICx%1$<MZ>6(6v7l-_Ft<Ui-{vlq#JTo4*DU4~&t=#>rKAIRr
zU>2t0U$nes!-0u-L>)Gn;;1|!`!DKVC-D!6d{uLK;$Ict=<j!b<6F%p!ooQ9d!>b5
z=raol0z@NeVox-NL<HqP`sRwy?4{@aS6@3m`nTQQud9F8TYb&`3(DUT{2B3fvGHEh
z!FmMVEY}xBo8mUHrJ1yE7v5i+%LUSAx=045!aIwIcelwY!-WV@zEx`8kH-^uYe}{6
z{{V{oVd5<>;m(=kZD&W+b?c38;@;{Qq5?}BYn@Cw%@jr5m(6Kan8yrd&hi`U$|{_-
zzmi`y%df7F{{RAe>vi9~+xz*n^!Jzk0=%vAotMLp5Bya4-**;|;~yDaczz#;@k^)b
zT5pN&<G8vfP`&cyH>l!y)jnXGq-fnpW)k5TdGCupH29~*S_gq;@kfgEZx7h(Uk^0R
zM^4mrUx-(J3X11bl^gAIi7oA<j_y?d07pJVt+7Mr%V6Y>yQrj{moJ_F02#ge`^#VM
zuPa-X-R;pYxkY{6?%kVR@A8$e#A&q8+H1ph-XQUHuZny@d;OPXE|1~=02bZaPo!Km
zqP){ClDlBPuyV#$xsV2p9Dom$Hut}^CyVTKUx|JW)BIuLOYaAKI=;2OlJiry)+W(o
zn^8|E?AG&NMDe^RV{4aH5+|6^083+QdxaF-leV2(^4I*gUVGoHEk5MD^z-xo05jpA
z+N0y%o8gOShlG4vesvEGX&Oz&lXIzjM82`Q)nY8OCB?p+i0i8>#&I;aBm=dEM%HTU
zej@(>Yo(XQ9~npD&l$t1_%FuRaOn2%>z5Jf_OOU_#&}xQSVb&yd9S%;R|9b?u#!*L
zG*gVZUpHNU7Z-p0mfm;!$!n)gKLpjk8~Ir9-`nQq*3aR0h2_4~?sQuy{AZ&z#r?Yl
zlFmQ1F6jdmV7o?1Vm?p_;~B3a@vp?aLq_m_i_gQa7T)Xs01V>RbXX?WZ+usGHNBci
z<_$(T^^9EHM*srMJjh$@=6Q;|Wmw1deH9V+V&mRd{{Yf-eb>AA{q)`1f8Dp^Cw1BT
z-+|*Fu|BVPtoS2cl=zdwUL?_fwMf$2NAaBgE*1&o#ALUU{&=I6*hpExeax#U8@7c5
z#dJ@Oui|go@57P!dt03jv9IeIR;8v-<IB74K^7}Z(y4KxnEuVDs?BVMCr1(#3%C|{
z$J#VeJ4yVl_*;MK{Yj3IYv=j&`JW_wANcWY@i~3~_)&agsA^i{>6cbsFtxVTCl`=h
zrjsJc9qXe9ir`GHK#`VB(X+28SaQDzwO<eTC*W_x{UZCudftKH<<|8pUmD&giti(n
zNxqD~*{tqvjNWdY8=MlV@a}OMocY8*+%#3reA4Fczu$lOZ#{g0Xs!2s*8a9WNwU>-
z9~S8T718wH7<j6G1?pcDWz%$hUfWr?`&O@{e`Q?E@qM(hmUw>BCXHs^SgdHtCgn*2
zXxdh@;D79mXZ{mE8tPYCSH%(Gi%9P^yP0kO0J5Ixp!+P*7uj;bWM&i29(}<-d4y0t
zx1y9K%QY?SZ=Ja}^J+3r{BrZVpS=earj2@EpYn1}-`rkS_`}2h02-t5ukC-~t4$+Z
zyNcgm@dmM@>l$>Q5HD_ZIO2}h_vM>NR1j&QWw%odk;o<56rY*j5B;BSVek*bFNYde
zhPB;JO;mhF)U^F`PMgFRH*XA!4zB5IJaS6r5OzZ$jD_6Tkb=i?`!b53vZA!LzXyNm
ze@)$UId@O-O<&hl_kG_X_!HwNgmmwM`j?2cZytEFQTUWRJ3Dx<L{Ai4Lq3gg^2Hs&
zYbSFKnzr*WRheQ<kp_Ip%N{?&9}w<5SKuFr`fOUwp0T0nz9;Z?&Ysp@GrRG9tSvUD
zZnB8A3#3V1OG2clDv!Jal0f^iioSKt&2HLsR+l!OT|9-`$-kbTpPBMqhr|o7fj%G9
z{vjKUMZ7(sc>BaQJ|MD%o#T?$=INF>ghTI39m-p(oDvdgM|$-QOHJ`7!;jdH#FJ|J
zwxs?oUk++orQO-Pc9zoeSf!k#Pq>swUA9NGfU6qg72Etv_(f~+TKh)+)7154(sZk&
zy_-mZqDwtiSlM15v=bSXmN^w%B1nqF4dKTX*48dJq3o}%lzkG4UyHl@wKY{zuBzKh
zxm&&D-{76E_#Y`-d?&uW@nUIn`1j&Wnr5f){A;&Sj}zWUG@6<?QFfCgitvm`*@6<5
z<b@_9v}1(v*T!!X_?t`cM4lz_R*T`?KU(;ErfOPlp{jgByzo?48l1?+?sbyh+C;mN
zGj4o|TVjXLmchv%bWvMMcWw7~{AahyQCIB+ZkE9-CFyU%ADfGBzdOHM{Jzt8$5r@&
z<K0E|eOFlVM}&SK={lB|rs*2B%IOzcw2*2$<VX;rPO?cFZCMnl0ZCkdM<L;Fih6wB
zJn%34D=&yXB=NSjsrYkOywxmjd_{4o+smk>io62m7k67pywcdWQ5vt!h{nN>vhLw)
zn@M9yWVd%ht1Mwl#z_0aa4V75kVmLB!FV6w5BwuuJdeb>*NePY<6UCX(d=v`)_%nr
zX|YJk(|J)^TieE3LXm>*tiT`&R2B^~_ng+sUAlZ*eA?}@?2&PNysvwHKMwx@bNk<R
ze6jGe;;)US@GppUe+u}&!}`~WAn;w)&ZVW>c>4Fn8q;bZL{j8wHx`kL8Dn!WYk1XD
zbc-2}<WM?q0{lz(Yv8}yb4>9Uhx~o3_@~1<H^cpA{{U9MxYw?{Lk*Ejoi&_^9i?=X
zpatMV@_>X!rSjilQC8>g^QCS702L+oE^QZ=rJ^d)<$C`BQT%k@&H3IdJGk`=NT-Rn
z#WD#Iutw!0AoEhuMP~eluWdq#D4+t0D4+t0D4-1rD5A48GH2t&bNkyxkNfIcnx)jV
zzqdL_k{D-<5UvJ62eBQ+R{qMr{{Wx6Py7XM{yA54OH7iAkNYbB0RDdMKkya5_~jqj
zSN{O>_i6tCfUW-k$0)iLnfZtR00$y}%^CjyxZnQc=>GtNZvO!0vwz$Z{{V6n-}pHO
z)_ZUGQ(k=0OP}q%yCNx%`3LpO9M_ir0KpXh0Bnzkf3jEnEWh|qyj2&5f8ikh%li)f
zChq&~K2O^`%zd33X5ThHy^QYTp|8&>)~8E}eWghy71ij!hJSBm`ED~G;52ZU3R0_9
zSF~XlDLZ2>?G&4KNw;o^v-T@d(XBOg0_xr=!t~y`#Z><Qgda!$0HAH3{rVO2XZ$`x
z_ILjPqN{2D0EDKm{{Y6Q{{V-`e$M{@^i^#?@RZg60Ql8?r}nl7{(nRN00Lj;e=7d~
z#5UsZ`W0e-@I_z#MEXzu5Pcv1fwq75=u!Uw2tJSh06^P6`}8a3&-i?Y?C<{oMOM@Q
z00~WB{{W3q{{Rn={hj{+=&IU(;VG;C0P(6nwXh%a`XBfb{{S%m0ElhH-}EZP{{Y~M
zzx;{xpZp;DKm7x2{{ZjMqy7+mAO3;1fA{ED&7bi3582=Timj*q5}LpN02-tIA0hiY
z{{YcdwEqCYQ&;~0<5YiZU_a;dKky~~VgCRS+l#;GRf+!q!4-e`6X`$rLG*w62HF1r
z-=RnRAo@T318n~Q@6fNCKjHEpv%mcnTTlEYHGlp!NBllR_ILjPqN{2D0EDKm{{Y6Q
z{?@>M&**>POZ>zBA-5NQ(5n;w0D>z20P-i&fAE9o{{Zw2v;P3ULXY@C^ndyW+5Z6F
zp<gzC!{k3_fBGu6pZH2@{{Z}IkNA9t?C<{oMOM@Q00~WB{{W3q{jGri0H4tR0Kk{|
zhx|isF8=_bRww@e1Xce4<WHpk0O1GG{{ZM4Xa4|xg&**P=>Gup4YU6Mze2uj{{V-`
ze$M{@^i^#?@RZg60Ql7(@c9qf-~NiNr~VR}zyAOlqx)L{{{TOs{{Vq6^AGrj++F_w
zLaa~z2&?}9$e&670KyNW{{YZ7&;I=iKj8<_{{ZM4Xa4|xg?!on01uG;o&Nyns@i|y
zDXaeg@v1-J@*lIm{S{kJ{3SJi{xwJTwgdiuL;nB*U*;e24Y<4hg;<~b5m)~Jkv^0E
z0E8b${{WzEpZ)q2f5H!={{YZ7&;I=i`Lq5XA^SW30MS*n{{X^MSN{OxRDZ+dKWBgX
zDz=~aN^1WA{A!QwYzO@QhyDb=%s=8Aad-U+u|N1Cum1odeJB3_2tJSh06^P6`}8RP
z0E8b${{WzEpZ)q3^Jn}%L-u$70HUjD{{V!hum1qXsQ&<m$bQcM0Q6ODKk$^*{{Z;a
zAKKUt`TY<434fS>#5UsZ`W0e-@I_z#MEXzu5Pcv1fwq75=u!Uw2tJSh06^P6`}Qm5
z&-i?Y?C<{oMOM@Q00~WB{{W3q{{Rn={hj{+=&IU(;VG;C0P(6nwXh%a`XBfb{{S%m
z0ElhH-}EZP{{Y~Mzx;{npSGo>RzI;n#mM1}BaM6$tl?B(5A+$U@Q?N({{WNG_(T5y
zW3G+=0Hx5^>Tm5y{{RJE_!03J_GS2s;r%1xRjvN5uJ~h9)2ywBhIL4d#PeE99BIAc
z2)mhp+{6K#o-6Xp_99l3_R#o56oq5sT^IsJKtFDWw;#^FBZ+Y|YvX7-Gg3>lzh5Kz
z)4)C-%`&bO&MD@YYLq1_w5mc-ZF@JWQcCCaVMRy%m4E*LKX#w^3g7&4kL;`e0Qvj0
z{{X;N{{Z8a`Zdw~FJ?(pFT63QYIFIQ7FP2)>db(exBZoW{{TOBpZE&j{Bn=%tN#G`
z`?UW6z*heN<CI+mnVtUt2tJSh06^P6`}8RP0E8b${{WzEpZ)q3qy3eC{{TOBpZE&j
z{Bn=%tN#G``?UW6z*heN<CJI?W_SD``ak^xZ2ti7(4+nkeINdTwtx5NR*&{o{{Z~`
z+JE3HfAPvcvakOD=kC-000CS70FF_hS()GPgXsSN^bNEB0KY<y_(Al4`Uctm0N<fn
zKiOCR0Q2{0{{Vok{{Y7*{>s1q0H3>0`~`3RIYxnIXMe&EqyGTVHqZY33P0fo(f<JG
z8)yFjeuZfN0A*kQ0MFg0{sOoE034(HD*pife(gW-6~Fl98U>l1{{RR+kN*Hb+dupC
zDE|P2A4mTHplzT1`W2)7m4E*LKX#w^3g7&4kL;`e0Qvj0{{X;N{{Z8ZXclI7{2=;2
z{R3?O0PoPF{t$g1{(-iC_vluS_ErA?{QcU0;46Re%0IHN{{ZLi)BgYgTmJx#QJ`6w
z-|&Oz{{Zw2v;P3ULXY@C^ndyW+5Z6Fp;|xLSN{O>_i6tCfUW-k$0+{FzyAQAyHETD
zZ~i$(fo5la!VjbW0MIti{{0F+;Rn(G0O%WM{{Vi4X#W6ZU;hBl-KYKnxBmbfqx&lV
z0RDdMKkya5_~jY}nVtUt2tJSh06^P6`}8RP0E8b${{WzEpZ)q3qy3eC{{TOBpZE&j
z{Bn=%tN#G``?UW6z*heN<CJI?W_SD``ak^xZ2ti7(4+nkeINdTwtx5NR*&{o{{Z~`
z+JE3HfAPvcvakOD=kC-000CS70FF_hS()GPgXsSN^bNEB0KY<y_(Al4`Uctm0N<fn
zKiOCR0Q2{0{{Vok{{Y7*{>s1q0H3>0`~`3RIYxnIXMe&EqyGTVHqZY33I~ETg*pDt
zwEqCVVzhs<um1q&?$iGO0bBn7j#2%UfByhKcAxkP-~4io0?c$#ED?l73aT&w7y_M9
z{{UrQ{{YY3r~U%B{{S4L`zrqc{(kL0@D;!K<rhI_NkvEfm4E*LKX#w^3g7&4kL;`e
z0Qvj0{{X;N{{Z8ZT?LsX6(9Ch{{Z~`+JE3HfAPvcvakOD=kC-000CS70FF^~7G#uE
zf7w_60Q2{0{{Vok{{Y7*{>s1q0H3>0`~`3RIYrP}l2K9r0A*kQ0MFg0{sOoE034(H
zD*pife(gW-6~Fl97eQu8MMwRWfByhKcAxkP-~4iq?5qC(`TMm00KiuN0OOQh1(_uk
zANE!M0Q~*hf8Z;B@yb84um1q&?$iGO0bBn7j!|?LWRz5Y*;oGn^Y>~00D!Ik0LLi)
z%D?{rpSw@|1#kX2MbKH2QBnT@WncdQ&)ui~0=NGF9HaXx{{a4e?LY7pzxd@BL1sxs
zNBxz5{{TOBpZE&j{Bn=%tN#G``?UW6z*heN<CI+mnI#n;_ErA?{QcU0;46Re%0IHN
z{{ZLi)BgYgTmJx#QFIn$lvID&SN{O>_i6tCfUW-k$0+{FzyAQAyHETDZ~i$&&{>jE
zQU3sCU;hBl-KYKnxBmbfqx&lV0RDdMKkya5_~jQtW=Tay{gr?J06%u0_zK_ra*yn*
z{{Z>>wEqCWR{sFwlwAdxB^4j`RsR6|{n~%vD}V9IKeDg?0O#)0{{R77{{W6rbQWZk
zRDao5{{Zv%Y5xF#t^WYWDE`X7{{Wx6Py7XM{y9a^S&~sv{{UrQ{{YY3r~U%B{{S4L
z`zrqc{(kL0@D;!K<rhI_NkvEfm4E*LKX#w^3g7&4kL;`e0Qvj0{{X;N{{Z8ZT?LsX
z6(9Ch{{Z~`+JE3HfAPvcvakOD=kC-000CS70FF^~7G#uEf7w_60Q2{0{{Vok{{Y7*
z{>s1q0H3>0`~`3RIYrP}l2K9r0A*kQ0MFg0{sOoE034(HD*pife(gW-6~Fl97eQu8
zMMwRWfByhKcAxkP-~4iq?5qC(`TMm00KiuN0OOQh1(_ukANE!M0Q~*hf8Z;B@yb84
zum1q&?$iGO0bBn7j!|?LWRz5Y*;oGn^Y>~00D!Ik0LLi)%D?{rpSw@|1#kX2MbKH2
zQBnT@WncdQ&)ui~0=NGF9HaXx{{a4e?LY7pzxd@BL1sxsNBxz5{{TOBpZE&j{Bn=%
ztN#G``?UW6z*heN<CI+mnI#n;_ErA?{QcU0;46Re%0IHN{{ZLi)BgYgTmJx#QFIn$
zlvID&SN{O>_i6tCfUW-k$0+{FzyAQAyHETDZ~i$&&{>jEQU3sCU;hBl-KYKnxBmbf
zqx&lV0RDdMKkya5_~jQtW=Tay{gr?J06%u0_zK_ra*yn*{{Z>>wEqCWR{sFwlwAdx
zsYMi278FrlfAJ&sl<?QXZxk+tJePO6<3Mgc%WH1#kf_Ey*|FusPT)eb2ViolKqi1a
z0*d$t;NScfQ^lVd{ww@j@c#h(DqGJCT6{ge`zC{Te>9Sh94>BmNn}}JMgTyB?Pmke
zT%MWs9}E8g!9v>K#kx+B;(a4Z(=N4(0d)ns>PnZAOfY1II9nn^8nPB4$KPI{=96{<
z$-m&Y-?4AR&)WO`6_5NYzYTxFL;nB>_x7*$hx|+}Z9dQEeT&Nf0ADI@-Q`L5bB(;?
zBR>TH0K=C50BL{vCcpV`>0kVlU%B1@_?4vmO47d5rd)?*L}~4ufjy~Ua3oMpIv#o*
zrv&1+tLJh2F@?p~mLjC2o3_ncMQ+cr`>zK5Ah?T$vU)it0*x6{rOjtJ&CA}DrtZ~9
zt>o>Z(%z@wpZqy*_Lu(vqHF&EmkyQx0Le6e!<PR5X@B}Azxi<KU;L9_y_Hh-_Ca#C
z_Uer@F7{{pv9C;?=O>`{HOc;^;J=!GdjA0APpAI?iLT<``Uk^*;1z%Qariy|01jLI
zrT+lvn*RXh!=-=nO&{>(zuI5^iLd@#I#>SyB-ifuk*NOw&()Xy0yqBv9HYq8f9LAU
z{{R6S{{W6t{{T|(KhH0{fAS*#0Ew>R-}(l_f8Z5=`EmF|{{RkK{iXi^=$iik<-?_a
z@=YJ`<-gir{)w;tTsl|(03_G$_mQao0MFHz{sK4u034&p)PLvd%l`lY8~*@~QU0ai
zf1Y1@{{ZAe{wBMNf9M+x{{Vnh{{ZF3;Sc;dZ}yk}0HSOE0GAGx{{YD}f5Vpl0BL{v
zCcpV`>0kVlU%TE$qyGRuR$urC-~4iqBT@eVpQ|tY1aJO1NBWn6{&{`t{{WE>_?qr5
z{{WzDH~s-v{{WXCgg@}*zuI5^iLd@#I#>SyB+>r>4qN@D{{ZNk{{ZE~rGN5Ge(!l2
zkNo{vf8Zm3@ya}nNB(}Szwi;i_~jq!UI+Q*_pkm$KjLe+xBh{!-}nVz{#<?#{{X|5
z{{U%!`X;~maOq$ClSlkHZ}yk}0HSOE0GAGx{{YD~`@Q69KlAlv{{VoE{{Y7*@--j%
z`m+B3z()T7<CK4?cpvAN-oN<}{{V@u;@|oP!++ovfBA9vL;nB{Tm7Z~0O*?k0OiA_
zfAUQq@a4bSU;c@&{#-g&{{SS{?)Q<X{{YX`m;M4b{{S4L$kc!5>dXHC0UQ4Sj#2)l
z;D4T9djA0AL;fbai+|`F4gUauRsR6x$KenBIdArt{{W(E{{WW`mHz<AG=IaE{{U%!
z`X;~maOq$ClV7{uMx*}#KUQD(2;cm2k0Vk40H3Qb`~+|QIY;`Jf&O`Y>;C|e5BQqy
zE&l+ZY&ZS^SN{N)AA~>f<-gir{)w;tTsl|(03^}>01jLIrT+lvn*RXh!=-=nO@8lr
z8jt+_S%2UofAPvZjYs}|tiSLPzxd@J>Rt!=<@c}tL_gwdxVQd+u;2IvU;bQv5dQ$f
zmj3{0fBGiB`Eco9{F6ugIdArt{{W(E{{WW`mHz<AHT%8fYCrS!W&Z$xjsF10DDpKQ
z`TDZ|0Ki870OOQ@sdyjfm)^hm5dQ#)uHxVN2E%{g6@U40_(T5y4qN@D{{ZNk{{ZE~
zrGN5GcfYcy{1QL*g!payQ2aOX7PavI0PI>mf#RJrQop$V-P2_9E#bS0Ngrxl7Hle$
zg#?^%39s58BT@eVpQ|tY1aJO1N0F%i0MFHz{sK4u0355Q!PqEGO-@>Cy8i&=PHb<|
zkBaeFdYEdMd_OGW;_V8TvsQNf?&az#kCCYV0MFHz{sK4u034&p)PLvd%l`lY8~*@~
zSJj`*rRpk=k*NOw&()Xy0yqBv9HYq8f9LAU{{R6S{{W6q1?nn~k*NOw&()Xy0yqBv
z9HYq8f9LAU{{R6S{{W6q1?nn~k*NOw&()Xy0yqBv9HYq8f9LAU{{R6S{{W6q1?nn~
zk*NOw&()Xy0yqBv9HYq8f9LAU{{R6S{{W6q1?nn~k*NOw&()Xy0yqBv9HYq8f9LAU
z{{R6S{{W6q1?nn~k*NOw&()Xy0yqBv9HYq8f9LAU{{R6S{{W6q1?nn~k*NOw&()Xy
z0yqBv9HYq8f9LAU{{R6S{{W6q1?nn~k*NOw&()Xy0yqBv9HYq8f9LAU{{R6S{{W6q
z1?nn~k*NOw&()Xy0yqBv9HYq8f9LAU{{R6S{{W6q1?nn~k*NOw&()Xy0yqBv9HYq8
zf9LAU{{R6S{{W6q1?nn~k*NOw&()Xy0yqBv9HYq8f9LAU{{R6S{{W6q1?nn~k*NOw
z&()Xy0yqBv9HYq8f9LAU{{R6S{{W6q1?nn~k*NOw&()Xy0yqBv9HYq8f9LAU{{R6S
z{{W6q1?nn~k*NOw&()Xy0yqBv9HYq8f9LAU{{R6S{{W6q1?nn~k*NOw&()Xy0yqBv
z9HYq8f9LAU{{R6S{{W6q1?nn~k*NOw&()Xy0yqBv9HYq8f9LAU{{R6S{{W6q1?nn~
zk*NOw&()Xy0yqBv9HYq8f9LAU{{R6S{{W6q1?nn~k*NOw&()Xy0yqBv9HYq8f9LAU
z{{R6S{{W6q1?nn~k*NOw&()Xy0yqBv9HYq8f9LAU{{R6S{{W6q1?nn~k*NOw&()Xy
z0yqBv9HYq8f9LAU{{R6S{{W6q1?nn~k*NOw&()Xy0yqBv9HYq8f9LAU{{R6S{{W6q
z1?nn~k*NOw&()Xy0yqBv9HYq8f9LAU{{R6S{{W6q1?nn~k*NOw&()Xy0yqBv9HYq8
zf9LAU{{R6S{{W6q1?nn~k*NOw&()Xy0yqBv9HYq8f9LAU{{R6S{{W6q1?nn~k*NOw
z&()Xy0yqBv9HYq8f9LAU{{R6S{{W6q1?nn~k*NOw&()Xy0yqBv9HYq8f9LAU{{R6S
z{{W6q1?nn~k*NOw&()Xy0yqBv9HYq8f9LAU{{R6S{{W6q1?nn~k*NOw&()Xy0yqBv
z9HYq8f9LAU{{R6S{{W6q1?nn~k*NOw&()Xy0yqBv9HYq8f9LAU{{R6S{{W6q1?nn~
zk*NOw&()Xy0yqBv9HYq8f9LAU{{R6S{{W6q1?nn~k*NOw&()Xy0yqBv9HYq8f9LAU
z{{R6S{{W6q1?nn~k*NOw&()Xy0yqBv9HYq8f9LAU{{R6S{{W6q1?nn~k*NOw&()Xy
z0yqBv9HYq8f9LAU{{R6S{{W6q1?nn~k*NOw&()Xy0yqBv9HYq8f9LAU{{R6S{{W6q
z1?nn~k*NOw&()Xy0yqBv9HYq8f9LAU{{R6S{{W6q1?nn~k*NOw&()Xy0yqBv9HYq8
zf9LAU{{R6S{{W6q1?nn~k*NOw&()Xy0yqBv9HYq8f9LAU{{R6S{{W6q1?nn~k*NOw
z&()Xy0yqBv9HYq8f9LAU{{R6S{{W6q1?nn~k*NOw&()Xy0yqBv9HYq8f9LAU{{R6S
z{{W6q1?nn~k*NOw&()Xy0yqBv9HYq8f9LAU{{R6S{{W6q1?nn~k*NOw&()Xy0yqBv
z9HYq8f9LAU{{R6S{{W6q1?nn^hf-dC(PaMs?ERgWKaTT{%BIt=zTE*Oe7O;dNSV&Y
z9{&K5`VmMA6j4P06j4P0eC_`L1w8$`EWhBNpR*0mj3u}GUahF!N2KX69u(Y2uI5HN
zTMCiJ?a+e3RQ>GN;;)N;;JD-A)`k7As(3$I@muNAOCw(0>T*ukO>|U9Sp2Bql6Wh|
z2mn{zU+{C3$*lYq@HUZf?v~H4L-Qyn%V}Y{P1qdqupT+UHSqrc>_PC;;fKUu0n4Iz
zlS{Y0@k8n!U5SrTlwFt-*2`tOS}npmmyzx_OSGbtkdmWlUP`V`rz!K8tWF{0{f!yf
zB(%J3-Slqu)3M!t!+-EsZ4>sn{jGd0@X{}a)_Psdy`|0lrl&R~lTQz5ZXe5YmJay}
z_#-)NlUV*B{{VuUX*!mh{egY(!^8Tuovrw}iYx1h?hH3EzU6SvhYl4{vZsYA7e98q
zZ}vFxhlYP-PupWj9w+f$k$WYkv2|~LEbZ<kZ9Z9TrGv{Z$^#<E<8vlMbp-Ld&;I~o
zPY&yU7{B16Ha-&ZrjnBUKh^FpC$nUe%ll^307$NlyPbd%I{A3)MK?Lx*D$Gy$0$ND
zl2UzTXMcrs^SSlsf`8z@i}2IphMnSzKLKbrn#)8iWx0ysl38sTmEPT^bQn^=VRArp
z2LxcB+`oh06tusN9|`<5<1G#3eILbIUAC=cWL>Z1&l<>qhh_nQBe4d*8twl8Vh@CR
z28XF@-Xr)o2gB_vNz|Z%8=Yrgl4)-uXDDSwwUR=FKbMWiqh#O=*XlR?6RO7l06_hf
zbR8E_hefxOKrN@k4v{Rf*u?^cF)U3l&PK*xy`FQ)9M-hsH2vpu+rm=CLQPkfGW~k=
z>*~*Psy6Na02M9R@Ahao{{VqYPStfLvoS*whq}2XVpidJ<dS^{=4twFnl$ucSj#l0
zbh5Wu5A*}D?OPq;sp@N{#H6c8@*Sxf^>h9n^-KF={Qm&Ujlbh`fB1@at<Jq?{{UPj
zKlt=jB{Y?ZY=`?}Q2zj*8*lszKm0`>+Zu=b_}hQrS^ogyDvyY~ZKHTX>r8`I)wInn
zZEoyXY0=%?BrSh(Rh&ZzVhoZMM{SFfgky{YT9oX!71<B=#-aZJJ~rR@7JvAPKejaw
z`SG^@0Kl{V0K`@=g1#weUl8@L66xAK_uDT#AE}KWSC7e(KeAmLcy4^WvVi{pxwwV5
zA!YgToPq@p7W{bdr-8NoV@uUFU$Wn58VmTI{x7pk{zjaP>eJ;=hQW=-#U=RryoyqB
zicVTxU*&FV`f}@j+UzyV-IsfO?`wMBPhAeD`(sf50G}Ig{0l$)MIYN5hy3{4f8bgF
z0OBgAggjYc<If4{dghZq+O)l9(kuHp_A+_U%7No;tOE?I1A+k=<O<QNlpI@(m6{?m
zQi_ya(;@!Y)IaCO+y4Lp&;I}sNA|{{{{TKV-}n}P_==jU4R*=3#?uAmsnn7Ibk?3~
z`RfT{qC%P7u&^U`F_1@UoiAdp_a*+=)IaCO+y4Lp&;I}sNA|{{{{TKV-}n}P_=<~7
z*Q|Amo7inHEpDdMXZtnWaLlgOvg}Dbxd1sv*&;U6gSFK3BAen*5n1>{!?*gjqc_>~
z{Vv)|yQy|F`B6rt-LRmOg#_RNeFZ5v#yrx|Z}RRqsY&w3a)0fOL;ieizwj*o0Pz%m
zY-%6#<8A){foJ~!h^}A3za9K5@dv~f8eWmA{jU2|&~5xrYZuw3kImDkVzEz_KnCIn
z*hq2RMQumpZ5nS4T<b}zX^o@ViJId4T_LuBLd>%llRH<-WN_I(DMkkvHByf+#Jm0t
zr}s3|^Gy*MseCT`eknEgrke6-z5TJMf6tA#{so`@B9HBjL;ieizwj*o0Pz&~Crg-8
zNZDkLMGUN`A%Wx&eJdB@SH!&&;SYnZb^ibnUjG1R=@ybh6tnp<OR=SuA&hNBW;v2X
z91b&+fC;5!w<`D58vg*>8i)M&+kfC${{Z4B{@Bz%=f>Or00Phd01;DBMUY*P{{U=i
zAM@jF{{Vq!{{V=i`(sf50G}Ig{0l$)MPq7z6ZAbF;!cy{3ybeB#9Hl*)}>=<<j8#c
zduN3wec^U4*0_XWm=nK%aB;s*%Gdt8etHI^Kie9I{P^2{;936w;wb*u)IaCO+y4Lp
z&;I}sQ&CFDF35kjH4pjmw*LUYv;P3ZQT?%~f6tA#{so`@BBrXB8ug8)v2CZzd21G-
zdmNJ6+dRr9xJdSi8522RyVG$4jq9GGiy*rt{@Bz%=f>Or00Phd01-#_#-aZJJ~rR@
z7JvAPiVb?k>sq+eW4yJKQL~CU?k!ejGeI1M#BRx*%B*9MDI*7CW1*^E2>6Gfd`!^W
zQ}E`wqxgeOS>?5By*BncxCF5|Nn<Y=E4>{`vgay62Lw@|U7BCp8i)M&+kfC${{Z4B
z{@Bz%=f>Or00Phd01;JuE#kc|$37ji)$~nD!&uUF7=-qhwl@iJZ*>{y@yLX$DeOTa
zv?<vI*$?){q5l9rHsAObfB1?&wlxp=@wWc}z_b4V#8lK~mVtId{jsQj&yBbK1)u&R
zkL`^^{(Nn}@GSoT@fAb<6Ri{e5aZ%6?Tst`5%Fwq4yX3G{>C5!ahJ``&6wwQagOz<
z4n;d4yCVMB)IaCO+y4Lp&;I}sNA|{{{{TKV-}n}P_=?8(k?}u6_(kE^wQmsLe`o3Q
zUs`FYFOwv>xVpHG+62NYADUTXT;l_FNdOWz=(4r`U)SEg@YIL<V^IG9pBr!d3qSlt
zAKMy-{P^2{;936w;wow>Sq0e-_Qs+A06sR~_!fWoia)kB5Bc%7{{X<V{{X~P)KO#?
zWIx*)hy3{4f8bgF0OBbA*wjDg#@qh@0?+>d5mQk`kX?}f0BmX>^W$y*0D))!0Enae
zV^IG9pBr!d3qSltV|+;XpP~FB@a$T*h;P5M^!cx?G}M>Ll3d(fTt{sJVHJ<fEU~U}
zfx9Gt2?vCJC+L1V@fV47ohtk7T8D%$lTFp)@?=l4Ts^#3Dw$;g^AzzmP_X&2oPq;N
z`lbD8{%h}D(DmHe{@Bz%=f>Or00Phd01-#_#-aZJJ~rR@7JvAPnu=CJyCMGA)IaCO
z+y4Lp&;I}sNA|{{{{TKV-}n}P_==jmzv4gblko51KDXj44R2Y$h5R98m)hOMzKMT%
zXQZR-*&O#U!tlpCERnc@oJvvE!fhd_&^6rjukDRP{(Nn}@GSoT@f3e-Y9I6CZT|p)
zXa4|*sa3bABcbF{(PS4P{@Bz%=f>Or00Phd01-#_#-aZJJ~rR@7JvAPgT$U9v+#$9
zZ}n|PZ?oz8U9^{XQtW5)qK!+tVL>Mf3BUyU3Wvg;Fw?wm;QcpW(=J8Ek*nFos9IbU
zXvDBcf<$~U47pYZ3;`X$qfLCRe=FYKeVx4@V7t0q?{Af__g!DrcP{?`Y-%6#<8A){
zfoJ~!h@<;sQ2zj*8*lszKm0{yFT}qNKf~|%OGdw<9}4}5>R;O;`Y-JN0J4SO_K!bz
zm*s8wx9;1HbBg8uDE`+U3VsLcHoA9>ekXiA@P?s(Y`2!yy5ETG^!ctJVpU~CmPKYl
zRe)eHN}hP9%dai99=5;r{cHH0@Ak%_{{TKV-}n}P_=-QaH4pjmw*LUYv;P3ZRXMz6
zq+9E{c9$lrrlzH<!7a^&qg<e#_9(V_vP7BO>YikKnL!KYCULk{cf}u!J`(sH;g9XV
z8u+Kfo)FQz<+uBOx2Z#?+WC#0spd+`yN(V9a&T!oEyS+&H-EM@5Bc%7{{X<V{{X~M
z{jsQj&yBbK1)u&Rxotc4g76lv@VY-7T6o{W7hVdPf=A*Ab&Ge>-HhHq0^~oGPo4X}
zz4!iJyjI_cJa3}-Pf^mXHBDbj({A<aud!*6UEL%yYBw7iPbL*&43ca|ZL5>D7~=rb
zakH~tUp~U-(&g{%jYIx?ZNKm={{Zn6e{5<W^W$y*0D))!0EnrmrDQv@AMK4p{(Nn}
z@GSoT@f3e-Y9I6CZT|p)Xa4|*si>mJF35kjH4pjmw*LUYv;P3ZQT?%~f6tA#{so`@
zBBr8?AiE*{*wjDg#@qh@0?+>d5l8mMq5l9rHsAObfB1@;iY$Wchx=nt{{WvGZ~O~C
z{6!zz8i)M&+kfC${{Z4DYACV`vLEe@L;ieizwj*o0Pz%mY-%6#<8A){foJ~!h^eTe
z$S%l#wlxp=@wWc}z_b4V#8LgRsDICmxBdm6{vxKLiy*rp{@Bz%=f>Or00Phd01-#_
z#-aZJJ~rR@7JvAPnu;uf?1%efQ2zj*8*lszKm0`>+Zu=b_}hQrS^ogyDrzXQ3$h>W
zjYIx?ZNKm={{Zn6e{5<W^W$y*0D))!0EnrmqR1}Df3`Ib`SG^@0Kl{V0K`%Kv8aE~
zjko><pZ+4IqKhEAA^zCZKj+5V{{RBd{{Rt3_Qs+A06sR~_!fWoikgZng6xO;V^IG9
zpBr!d3qSltAKMy-{P^2{;936w;wow=vJ0{w?TthJd~Lt*EdK!U6n|`LAM@jF{{Vq!
z{{V=osG`U&$bYsq5Bc%7{{X<V{{X~M{jsQj&yBbK1)u&RrlN}=yCMGA)IaCO+y4Lp
z&;I}sNA|{{{{TKV-}n}P_==i}EQ0KZ`(sf50G}Ig{0l$)MIYN5hy3{4f8bgF0OBfY
zD6$K(AMK4p{(Nn}@GSoT@f3e-Y9I6CZT|p)Xa4|*si>mJF35kjH4pjmw*LUYv;P3Z
zQT?%~f6tA#{so`@BBr8?AiE*{*wjDg#@qh@0?+>d5l8mMq5l9rHsAObfB1@;iY$Wc
zhx=nt{{WvGZ~O~C{6!zz8i)M&+kfC${{Z4DYACV`vLEe@L;ieizwj*o0Pz%mY-%6#
z<8A){foJ~!h^eTe$S%l#wlxp=@wWc}z_b4V#8LgRsDICmxBdm6{vxKLiy*rp{@Bz%
z=f>Or00Phd01-#_<>X&9mI<(R@~$_x;0lcXbu|=O1=(`e<u5JLSkB~-Zd2`5bg%gS
z)W7TGf9RO0z8T|6`cE()_x0)8SNwnKU-j}o^h{Mf$}dqx6owR0MF4(if5FPW2bWs-
z6Y%=(KQ&hG#PMnD@x;=yv9-J^0s;#b4B!AkIN*bWUzGYU?8V}ZU*R-g5p<|yn%S?$
zgL6DLKj|fi4fCm03llV`H+h6*KqCwQ{*ixbPuZ8lAGPPfU0cAuErLljy-+JGu#hLS
znGRBD*n$Ho_Q3^#$Rt<iwz2;J1o*c7n|wv#Jr7DvU2VKAtY1vgYLTVP9xAuJw0LBM
zFxsI3TX_o<Av~fAlbmu^qNLoW^s(Ys$|_=Uyz+kIO<MY=qE=Sze!Wl2--dqyK0bH@
z<G+OUFB*6s!@3uN{5P#z>NlFr)E4pFC9G02i5!eb?BJCNl4K?*z+#ao#P~<?`p4k!
z?MI^cyxTRdpQX!oC4wnZ+TsH%N>nLwcQPrAWDE_Y72p>8bKp<HEn7hSsV+Vt-p{8?
z;3@n|d7)``O{9@)rg;;6o*C`D#5)+x9I2HmLa}1RDO&PB+GpW^?8Eyu{B`hWgM5AA
zABfO+r{Z<erk@s`_BSxY=Ugqi`OfUDzcYF<+t-|mm_id*r_j7kMeI3aNm|<c*4-KI
z-Uj`-`~l*xhyMU)@n46v%ek*@Ah*7UQ<u+c-zRBVCQJkjN`}D5{{X(5KdRrb?ydg-
z30Lgfp=<vDW17J{L?2O#34ZvAj@X;%(V{r^VP6saHU9vDN_cPf(wjlmJ|XE>w(xjm
zjfL!zK5w;HR7ONn+yYim+YyhJsIl*q518h^Omw|6-$c_b?5yC5+S1Y`f(T+zsS+p(
zs-SQH002FzaBmYP<yKdZMQeU1*5j&Ry_{*`=`}TL$<0YUHTQWVZG6~j77^-J{#=>s
zxmivb7<6EJ5m4!OlC<*L++fdcs@`IZEUMdrwmTn`<a>G=yHsHR0FjRC{=K390MMnc
zK=O!nU-=JOf7iU<`V>_qN2>9!S^ogn35WhY6-iXKA?|z?`*8e5(tb4l&>l3={>$Tw
ztKWp01aSCb??LcRyRN}$;<=s;MI@4I3t3`Df;)XUZD$R#@?|4y8udF5+G|$*t*^ci
zX&wvlW#7a5KZsrwz43mdsM%WD%d5loSG0kwAddDKp+;Hmm`c(@<wONQQrp+)KLC6%
z(Eb-et0sqJY{t8)-0N5D)5$a3-P}I;WGy2x<lqGdYAULzRZs^Ft^UMc4RzlS+v&$d
z)O7T+)^EH)Wp$<N+K!ulr(R!4B$sV%cW*p%z>_?(7m6tsHr#$pQ-zdNUaNQ0TRZvu
zO+9x|jC4)ePVP=iPM!49-kL3z&T^I8O8)>dd?oR(i@p-wd}8qBuZ%5c@mGufI9Yf}
zd{=d01aey}x(1ZZa$p0<YtJSUiZ%#Z;g!6VjQJyP#S!?k;3w@h@n+^<h&q>yHH{D8
zq?)FescO1)gj$WGrQPGFnk}J<+C>r}DgKU}0vpW1HShXo>^1PONcd~we+fb1NY_L0
zj;6ZauNz<8Joh?+qzJdd;iWT2bPc>RdGWf*=BJyx&1Q1G75#{Q8u&tOet0x(PWJx*
z#X2MScUaUlPY`N4rlF}=Gf3V{w^uXCGvmx~tY2~|3Zy6iXI)BBN)O&qvU`8ak7liH
ztvkx=TR$ro87_9@z1Jk|{{V4$->u_iZLYk}An><~J}Case;=R1_Ma4WZv^O8pA7sv
z;z?!E^ldV0`E@(VZ;{+R-L%mNSz#OF^0G=tvEl+jC2xa29=;%c)|zj^&kiS!B=8QS
zsdzGP6nKYL(5!4<QPn1j>1>fL<GqIF2w*SfOD<w|1j35yHx~L=!XE^DG2lNI%dTl!
zXW4a0v}-R9y#D}cmGfg}(zU!>S&ICId46neZQn6C81Y|^zq7xGd>^5B6GPCx40!(l
z#rjW%VZ2>7{{X>0F-;3u@bPw!bU$jBQn9#bCl2M6ZX6bYH%4%by%naNYr%W1$=m+`
z1Gc>_b*9giN3oSS%a+aRqZNNNprz}~)V1Anb1hDn_8Rzs;?EoC9}z74U*bsoSAF3>
z9O^m+uAr6>*>1LiI6Spz;`w)i?YX<LYy}uajelW34xid;Pl-}Bgs&~j%GxXG+0zE-
zvG$<>lgk>HoYFDA+2$Cfcu2wDR)1jcfEVAh{{X@LQaw{jvGD$<;_ndOc%J7*v!CrT
zXy)bDWwD$7TS~E{er&lR<}$D(5Kpz#?4bVAgj3soRHe3>wC>jZ$)|fwJ)ET0`*S{B
z_1UXmZzJZ<0e;Lr68(d8PaFI~xz}thEn?CxCzkGQ6{U;AXc)1NPlh*Vg2+W3oI=JP
z7+ArAUnKcwhyFGELw^!{L-1FL-{OVehjpKY`mczz`;Q-3cz)9V0L+D!9NVsuu%s@R
z3R*kJl5}KVpE{4UJa^!2BjR_0wO<bF`hC8uq3f2C*x%XQF6i!{kxDu+^eRZNJMeex
zKk(nd8pZylZ>4K`hOMdSv-o!FQPzA*s%sb1>C-a1+MA2JiDmNlE>v#)*=O0eduN)x
zIaQ}BZRp`BubgC;-6o!$FQd@tgw!P&t@)In%296Ku~Jsr_S;jze`oIm+WblJ{{V)x
z3)@X1`rB9io^(rBgH^Cw`zbd};Ca^UK$bk<lq7Bg869iC(m&vu9vIU83~Ig$n^BWi
zO;=I3ynTODfv&tnk*bxP4M5B137AcKu}q~+y52gXkU92$2K))|ufy*USZbO^mG(>R
zFG08P#jL++nolcEfr~{38OS?HCwT?Wb~V>mWqHPOZFO^heM!xK=}P{3YK}ZLIn$<~
z-pVUZ>YQNz0Q8q{F3jS70{j<);7`IU4+`4dM?2Xpo^GQRqFdZ*61%ZCS08vubomc7
zr~PcD+^X){J`c9|dE!3`f5AI`JIp+JulSPgUx}KPrJOqLrl0mpdzk!G7wt?fEv@8c
zmGIIpnX{;kVjNfLHF=fi?0xY5{!bS9+E%3Y-Z{L7QPwO@yMOixu40uYS>m?y{F`|i
zNYS04L^2VVEt6R4>N(4-TK@paqW=IS{{Rl!bW8Y3oO($=xk-QR%kf=V;(r$YJ$U!_
zGx48~W7IrXseDkgw)knOc;ipD)+}r+pHIE9oe`jo?ID00Sp~#=O}<F{f_&EAajE+)
zc%S2>-x>6@@jjFBGVj59wwFA*wdage!cfJhUJosx{>~aT)RTEKZkbswM9c!hMA;AK
zd-sSw4ftopel`C9gojhoE%gmh==UBUcepJiQrKKPa!mumPn7EI5@&LgfsEjgdGCV%
z0J4XI{s3w}Y4FruB~LEX>=w{!UMbZzdu=-3Dtwz*F773Y**-)YVN@7I9TWjn-IC_s
z&3-eso>6gE-s{TlY9`y|+UxR%{@kSP+4<@7xBL`a_J_IsnLlffg`Oj_u!8FDe+l@5
zOor<Do;@o@Ym5C7A$_PypqOl-EE-1xfB?#ZS#^Fjc>ChNfjn#AUxj);x$#HFnwjwJ
z*NAn`6L?z7!gku;qU&)SDH=tp7;Iv-Q!DNf!z{QKz_|I|Po=y|@OQ&rGV#Tai1ke>
z8~s~N(=Rl5B$?f#7MErda|=bEE!EAuS=^+6xC8>(;H3S6z8Iea_-DiLX?`Ko?ED$#
zriF8-_^(&8)U=3Y8(!KA=x$c(J7S?1?CUR*1aW|XMuAjrp$I;gzn$FLURH8af6VlH
zB+aKJ^^W#mrQgjayuKx=!h9<D$MIvp`iH|C?~4)5p=tggk67^btz~ruiIyw4UG8+<
zM&esZC59)O%Gza?IOS-B(x5=REpmP`_@(iVPldh<@pi4P`1eBaKZp*euWNdzg0u}c
zQrA2;Yc%n;lWg{P7S}B;s#-|qcY@w)kt!)WViFqkPuhp}a=G}C@Uz1I00%rf;oVdI
z5j*`-%JW(A1<t6mE}dy>dmY^9@=I`UXS}-D(fONSCV3uNGsF5P#n0J)!e1M2^y`gm
zc%I%(F4{{tS4HtosiDUt4pg*LC6&Z0I(&=r$`}qn05QvYu4Ub&>Al*$-Q?`GT&Y<;
zTO%c8?c|&F+R58QqvY=`Wv;8D_))DVi9QziZ%~U{UlT`trCQuBu&^uxRSy!k+C*vs
zr<tAmK)~IB(!8_cf9y4({7wC$H2(mIQ_p1t_A^?`HkbXH9>-ZR@gv{Iye-tBW3)E%
zy6(1;$`)O~6h4XIe}LW*_-W%!OT-!mhijzjdbXKiqg*w!Iz#q55h%2UA<vZ>#wU~w
zin$B{&eg|XS5i^-zS14;w*55xE#yoTl|D&zR)2QBd+n|I?s#Xz@7QBO_<j3GUi?Oa
zYbkCoE-t5wO8(AOu+o}AgqF@d<!!EWE$dA>4fhSGT<*XstMgy%M!)dJp9;J$@e<s5
zKMlSl>X+JojiOPAv|UxTJBTdxpGA&9Bel6b1}&r{EOHb24_tnS@C(8o9{4?R;0t{Y
z*}NTh1=XzjUBkW1Q^j)fJm|(oW?=0snFRj;76t$Ux#t(klzJ<Cp6TzueQfP5(k{wV
zZe4fv(#?8y()z8NK1uzGwT~G1*Wf3>KZZINi?4niTBpOI;vH8~u(7nb)-H^4$8R0A
zxV(mIc+pwere=ah<|SR5i&jtVL#cSr;-A2oyfv(N{{UJ|OX0u9?+kcoYr0*AofNv{
zQfeAR@LXIZmeN8lVEbC<$w=a9pe3U6$%ek4z5RuL7~Om}@K=Q)(Df}VO!#vFweZyX
zPlz=gGgHywG5JpvSN8Lz-p5P_Qz;L%HwG%CY~23JUIDuJDJR3zp)z=0X_o3p<G;C%
z@=K+eZUx(3EP~|S`RXM%CSN$nH<vBVbVg}ZRUWpNH*4Cen)I|+CYSCxHze<+)x9qV
z7yd7K^J{M151)QD{8RY7sC;qOd;#FuelO}U_ya)Gne}fA+xR)I^_%OImAw5$b!j1A
zD-f;{$_PPYar?o9Nc~Su_)qZ%<LAOgKM^l<T^{Ge{t(mc?))b<iEXIa_-|fDd1k#y
zgsf&OA&1LPFsyBCj;={2w|r;&7WfOtdWMsIc^8YVb!{6=O&%><OYxqwrRtY<h(SoM
z?=7yQp71MWhuR)O8QrtF*q*DyKLflg;Ljh;;*Bpzj>}u0MzrwrPaM*078b87!2pkU
zmZ2JHFhYhqut@*`7K@9FwYz_Jz5Z)Xnl$efa_;wCm**eydhYgmN!!K~{t2PsHTV}N
zfExN)Y+G9zfY&62o5X_CXO?ZwrRI6&Z?l)P7g-VuHu7<i<{x4BNAQY2gr5fV{{RWu
zT|sXxovXzrp{LkIXw%$CS){x%5b^o)NX;v=1`i{%Fgu8@%8DCpH2VJlmA^0Z+?yoR
z?SIAJ`t7pN{L%2&fILazulOc*tt1{g)^*$a?~I9WrzX8)V)j~X#9lshGwig2+F3m5
zF(jzc<2ey|EAo$R_^JCqd_nz=wV#T*Z2l_LzA1lWcoN^mnk1V2j-6|9Wq9{<S~M=!
zaaqG9wnS2V`x!z>nXtg8xW)S${5^&pb`hj%M$5!{-M5JEEL&aF8pSmTF2(9k1-YNe
zwqtTU*AOBst^Tk*be<*n7vV1%_@7kO^?eS{RJ_*oL*dKuce-dVH1h8uw|H2XnM+9d
z%H)Q@IO2)QQjNR0H}j^Vtox~?@4c6*G<MeA?!WLmyZ->&w^rK!0D1EVg>_%rWW(ZX
z8#`}_vB4*W?r*GhZyrJ64?5dgf=Hg;*4jN9R}F1)hGdh^iJm>EQe2!@uY4x><*NSB
ze;jms-w$6&Yv3I}!M6IYrEb>ImcG<ACP^(~XJO_>*4FS!&Wntj$hUpaD_g;zv*(9@
zWt{_3)%+o$`18d&g}sQjwbL$qUwN$Dn3S*jJ)icq@q*YLsgSZnt>q@-b|xVGiar9}
z`~&zmEIP%#owtenQLA3~lUs_`Upgymo4JgF*(4xuOL%;%bvOX53xEayzG(AZbX~f>
zW%JSA{{UsiI%{()J9)SN0LcB@ThE#H(}VrA{x5il_{MJv{5|mp#Z~ccgQ1;f`%LgY
zk)TcXXl7|r-sbw_TTyN0m$#545J;B|i5m={GIKu#{yqFg{i;4A{2vkczF!3BzAgAm
zW#heK(?-**<(6CNE-im|6qiuVvJ$dLj4)ei8(ACYuXgyg`y+S{<9~~nTk#f|smp%W
zLruH;7Q26^L91E@W)`=wTTL8SumdEYy17{s638~;*c~5+{{XXZg8mWR_<ny6Xy4iL
z_*=t~ct=Zbwa+ivbhw!rE&g|H*fFQh*>jFtlTk~SEjjnU{!3AO{pnM7f6Dxj@fVzJ
zPfZg40LiJh_$j3OHQlr2Z5Q^1`2F#B#u|r-{2k%1i5E6He~hlQOMNOo_(X?<XVdKU
zC$gQcB%0}UfpB7qX?G^Tvg}a=h^Ni^XZEc4ofpFY0EAOYHJx`w)is-_bgd=yJu)pv
zRl2*CzDO-0nOYA$)m$sirU?H4)=T@eYJmR79so~?_Z}{S!(6e{?==P0uI+4mOR3sv
z7uSoo7c=RxTrHH+l8D9Rg_)TZi7cSkQSp1=--o_B_&fUx#I~1LHY;-t>@R75ai`td
zTteaEnhTqEj(B8N96WBVf<|yiF|V_XJk|T#OY7*JuC0CdWq-@bPuAVKwWn=W^}AhB
z@dt~3FL>w1zXm*Y;cpzLi@wv~uZi9Vj>b<FL!-y7v==(2nLgWtq&rx)9KObgDcH&!
zZUmpA{{Uov`8coIPyWZ7Fa1aKs_8Tz*ni=dhjd+9#t#qOOCG(c>Dtz(HQuv*cXg=V
z>F*QTTupH-%`B25K@lv@OY8yn4A*nvABGwqfjmXxU0X`A`!1p4`{dNMd3@;~?RN=p
z6|%k=h)hKUON0tOT;n8@y*a4HN%c?h_CNfs-_>_^FYa=`>sf!9;8zXtJL8A#Bk`NV
zns>#GPrx1>@L|%1jC73`Ot`v=dG!APHeWtV%XyLQ_cFG?t0qCj%D*jge*!;f4~c)Z
zSH!P{kUxu?!Fpc3@X>r(twEvbwvrp$<kTUDb-b5xPEy)bFTo7PH(ji)^VeS|>?Ndp
zR{f>^FZhebx<0cGnc|1i?d&eJuM*yAEvwo^V6jaFz_GZA=734Oc~=0T+{7*zlkOTH
z!A}c#XU29K{+puO>H3zJq7M#Pn_|&JYp018MYl*)h?PSk;|q`!0CB~0(YlmnJ(b<R
z?a8J80FyYoZKqozYTi(kW4pGyeW<s$_f(bl*Ug_JXuq^C$M1{2Fw{Ix;O`B5NV&1o
z{AG2bTj^2%0Kz0ZBR-#JsXdhKaU|DEtP6t_Q%kuv1(#xoBt<@M4c*_2zh}eyVR+X@
z_>bbNtwTuhMU-~d*S0!K+N6@{+A|5rOC@sg#O4JB_IY3yN0&06tPkvQ-~{-eapLGK
zHOn1N^H5z{?$*b|x}BzxeR#WZb3U6D!r4tJD2!f6S(%YolFAKf_=EOi@IQ)le;U|d
z=$?J2#7oGp{6inxE*JYkXrh7?e1`@+M{NkiWkK1J2_&5<K1kcID_!+&4}PoNeve;5
zrRC3VuTL+F{Qm%}9ue{9<NpAU{vZC<Q2Zm){7hnt;+&S3nlFf&($UX>Ap%i#Z0cgz
z(p(E>`w6&NH_C29Z(DGU$$0+&_JH{P@e9X45H$~m{vG(0sK0`B`SdLpO4G-LQ^Pu|
zS`^+jDKBo5R92ab<*odHk-Q~RLJLduzlncjFNeM`)4X4Asc14?pB-v8+P1N9`jyzb
zmg?Kf`!tbU34GgcAjFLjf#VS{EP+cgHM~dr82mo*Kg6rA7E58TS!&vhuurK+rg)oF
z(`+@FApueEY_0Aiw!CeMsK(+c3&x6#xfCcUzF9@jTVDRRjlFD?mrLK7>e?M$Zlkle
z<nONQnc4pUcHFB&#eOU5{yP1jJOlCHU9<R?bKu<@z`xplAG7f7o|~uMSls=Z#60q9
zPc$uZT1S<zw)Ym{VpxwXS&z4V%jjhNjJ_SJg3R6v(?9@nPuOCrzY>38?}mRCyj`s8
zI_8CcEysy%#jdw&Yp&`RT6VmGGZ6c2loO@3+X&9U^TzBIPy>WqdPjsjDPiD03F&$s
zlLy&!y&BRh3ph8k`7p$RBVEi(94dj5NjT)1$wKreN?Xb>UpT3$Kbw`(>8PcDZwiZO
z^Zx+k&J8OqG*PpAy&FC=(l243{tfoZOB;sxJ0-X(z~)cv=8tFl+x}d2-N#zJ<5&2R
zZ~JoiipSyahI|jNYFB>;G+S$w@lLsOra@>;_Nu6SxUB9?z}!yg*u%ia{&@Eoe_=0%
z5O}=m>7r_j8)`q=$3-3@)W6{!H=F$5Kl>x?AKCtAo%`+IXV0Dc-}Rq8UHGs29QYgK
zH^fi)OEq=zeV>R9n;wrP=7r-eXF)d>k;yEn6su!(3dj}al#Sq@ob!s_ywz%sq?g3x
z+VzZ;ll7ODi@CC?YHph8xBdrCTKuW`>iZu${>?W!B%c!h0Ay=_4mPgZK9lh8#QIDh
z+L6T_;u}WM?VV&;nWGG^6AzJ@IQdwN8uh;cX!brQ{{VuE{6oLjBU_zw!k!t?;qbt?
zKz_le-J7FzHMl2(HN-n4Z~-FTB_x0V>b!OP6#O~y?WcsHlS$RI6!0aa_8JNB$B1<=
z4Yr$aFo;VEHlI8M#@<9(RwR6bj<oL-e#Tw_@t23ZJ!7a__@Y~%3W-xo)|18Bygnec
zNpfY2`&BMQ`$qh3ji)HvBgj5lZ6`M=bIW_l{{Y}lUw6f3yIowy-@8zKm)@FxJ+I{K
z`W|hs_)Eez-?o3n4HE9(OpC#OD)?}kpTrAS3muEfZYH;i=HmnfmRm)-M{)x^c9G?X
ziFWz7{1ZP|y!eChd(QFv+U4H4;eQOQe+;D7tyT%O4+%|h$eN=lcK-lQoJDON#zHtq
z?TJJ)y4TWA`xSgOm*F<A;F)|sJ;s6JJA}K|{QX+?Tit#{Wgy>PG{)xdArTl)D~63k
zYz%)TbRQIc3u)gFbuAZNf*U(e7<ff)U&ETL%W%=@(#;8p#IZp%4RLPYA$xX^Bbd<e
z$c(X0)Y7)L)6U-eTK8Q1ky|KTeWc<^Ik$Z-@9Csh-7a2fb>_3xMX7d_SDXAW@V~|F
zC&eo-jQnx%-(S&urVVML_#XF2x-xOKg!1awOSE&9^0I%tE7B=|QAHGn6j4P06j4P0
z6j4P06j4P06j4P06j4P06j4P06j4P06j4P06j4P06j4P06j4P06j4P06j4P06j4P0
z6j4P06j4P06j4P06j4P06j4P06j4P06j4P09vc4ukXio#uZjNv^lQ_!ulWA})W7TG
zf9RO0z8U`jkWu%ZbN>L5UY(_X$Nr`N0AC~j07S)8)t0tJ>L{Y5VMP>B0aScL;kzFd
z=~CG0Hn84W&ZQnX7a)Vj9l`e;)#@oUnzIDjcSp{CApZb@Tl_24d>+~zggzk9EDgoY
z(yfM~NsZ@wnIzliEPxI7Qn2H$-$7kX_v{Jqlf-@`)3u)vcqc*eUazDTYYW|K!W+4)
zim+f~W>1$40pqyOTJ}0BAxaSV6^oroPgy&W+S<iqZ5%L195BS85;Rb%iZ}oPz!fDF
zR)hsngZ@T4uln|f{{TXkuT>a7<YT)30Iz6&^eJheCDe4~)MH<nqmnbZ9eSz%01s-Z
z{gr+{<?`3@wQv48T9i?C7Bc?;vakOD=kC-000CS70FF`pm4E*LKX#w^3g7&4wJ4*R
zipb0U%D?{rpSw@|1#kX2NA^|!0Q~*hf8Z;B@ygVqj%F4{U-ni10Q~*hf8Z;B@yb84
zum1q&?$iGO0bBn7j#i}<b1<?p{{XVD{{ZLi)BgYgTmJx#QT>&F{{TOBpZE&j{BpG@
zqnU+~m;IH0{{TOBpZE&j{Bn=%tN#G``?UW6z*heN<CUpJ9Ly|?zwE330Qvj0{{X;N
z{{Z8Ze`R0)0MFg0{sOoE035AKDCS{gW&Z$WU;hBl-KYKnxBmbfqx&lV0RDdMKkya5
z_~mL*M>7i}FZ(M00RDdMKkya5_~jqjSN{O>_i6tCfUW-k$175bIha`)f7w_60Q2{0
z{{Vok{{Y7*{>s1q0H3>0`~`3RIa-ua%)-da{>s1q0H3>0`~`3RIY;(Y{{Z~`+JE3H
zfAPxHqK;-3Mql<-{{Z~`+JE3HfAPvcvakOD=kC-000CS70FG9r6mu}LGXDUwum1q&
z?$iGO0bBn7j#2%UfByhKcAxkP-~4j5D5IH$k(d3IfByhKcAxkP-~4iq?5qC(`TMm0
z0KiuN0OOUZMI6j5jKA!w{{Z>>wEqCWR{sFwlz(Mk{{YY3r~U%B{{S4VN+{-GWM%&V
zWncdQ&)ui~0=NGF9HaXx{{a4e?LY7pzxd^9QAaZiBQN_Z{{a4e?LY7pzxd@J*;oGn
z^Y>~00D!Ik0LLp*iaD5B8GqSV{{Zv%Y5xF#t^WYWDE`X7{{Wx6Py7XM{yAEdQOv@~
z%l^v0{{Wx6Py7XM{y9hXRsR6|{n~%vD}V9I)S`}N7Diw8RsR6|{n~%vD}V9IKeDg?
z0O#)0{{R77{{W6wr4(~8vNHbwvakOD=kC-000CS70FF`pm4E*LKX#w^3g7&4wJ4*R
zg^`#2m4E*LKX#w^3g7&4kL;`e0Qvj0{{X;N{{Z8asYM*jER4VGtN#G``?UW6z*heN
z<CK48U;hBl-KYKnxBmbftx727VPs|h0A*kQ0MFg0{sOoE034(HD*pife(gW-6~Fl9
zYEefs3nMT4D*pife(gW-6~Fl9AK6#`0Q2{0{{Vok{{Y7;Qi?g4Ss8!XSN{O>_i6tC
zfUW-k$0+{FzyAQAyHETDZ~i%2lu^vW$jko9zyAQAyHETDZ~i$)_ErA?{QcU0;46Re
z%G9EcW)?<Y_ErA?{QcU0;46Re%0IHN{{ZLi)BgYgTmJx#R;3hkFtRfL0J5+D0O#)0
z{{R77{{W6r{gr?J06%u0_zK_ra<wR<nT3&;{gr?J06%u0_zK_ra*yn*{{Z>>wEqCW
zR{sFwm8nG>%q)z*?5qC(`TMm00KiuN0OOQ@WncdQ&)ui~0=NGF9IZ+y=3!)I{{UrQ
z{{YY3r~U%B{{S4L`zrqc{(kL0@D;!K<!Vt!GYcax`zrqc{(kL0@D;!K<saEs{{Zv%
zY5xF#t^WYWD^iL%m{}Qr*;oGn^Y>~00D!Ik0LLi)%D?{rpSw@|1#kX2T9i@D!pO`1
z%D?{rpSw@|1#kX2NA^|!0Q~*hf8Z;B@ygVqj%F4{U-ni10Q~*hf8Z;B@yb84um1q&
z?$iGO0bBn7j#i}<b1<?p{{XVD{{ZLi)BgYgTmJx#QT>&F{{TOBpZE&j{BpG@qnU+~
zm;IH0{{TOBpZE&j{Bn=%tN#G``?UW6z*heN<CUpJ9Ly|?zwE330Qvj0{{X;N{{Z8Z
ze`R0)0MFg0{sOoE035AKDCS{gW&Z$WU;hBl-KYKnxBmbfqx&lV0RDdMKkya5_~mL*
zM>7i}FZ(M00RDdMKkya5_~jqjSN{O>_i6tCfUW-k$175bIha`)f7w_60Q2{0{{Vok
z{{Y7*{>s1q0H3>0`~`3RIa-ua%)-da{>s1q0H3>0`~`3RIY;(Y{{Z~`+JE3HfAPxH
zqK;-3Mql<-{{Z~`+JE3HfAPvcvakOD=kC-000CS70FG9r6mu}LGXDUwum1q&?$iGO
z0bBn7j#2%UfByhKcAxkP-~4j5D5IH$k(d3IfByhKcAxkP-~4iq?5qC(`TMm00KiuN
z0OOUZMI6j5jKA!w{{Z>>wEqCWR{sFwlz(Mk{{YY3r~U%B{{S4VN+{-GWM%&VWncdQ
z&)ui~0=NGF9HaXx{{a4e?LY7pzxd^9QAaZiBQN_Z{{a4e?LY7pzxd@J*;oGn^Y>~0
z0D!Ik0LLp*iaD5B8GqSV{{Zv%Y5xF#t^WYWDE`X7{{Wx6Py7XM{yAEdQOv@~%l^v0
z{{Wx6Py7XM{y9hXRsR6|{n~%vD}V9I)S`}N7Diw8RsR6|{n~%vD}V9IKe6v6;qPJ!
zdihr6Tks`_AC+oRMc7#p+S?_ax<we;k&UV<u9g1)ANrU5e2@JT6<(@3SNwnKU-j}o
z^h{I?y+ssK0HTU00HTU00HTU00HTU00ID#5$j5d60AA4l0O(TH>Z1qzjCWu4?GOHi
zEi?qz_u|P=1ZiZIwxTaqJ%0h}Y9F*}C;nY5{{S1N{{Z83Tyx?(Px|+m{{Z9BRq6nv
z=juQ6>t+7{fo=Z)#_03)ANlpN{{X<Y{{Z84dWry}=juQ6>t+7{fo=Z)#_03)ANlpN
z{{X<Y{{Z84dWry}=juQ6>t+7{fo=Z)#_03)ANlpN{{X<Y{{Z84dWrz07N;y%F~xNN
zgvxM^kG%=&f^Y~voO4%dkBC3x#y@MAKlEx<>Od4xMF130MF130MF130MF130MF130
zMF130MF130MF130MF130MF130MF130MF130MF130MF130MF130MF130MF130MF130
zMF130MF134JzK;!8Vt5+eSK$U`i;P}v{~j@&D6zNgi(S<=PHbLjGQSr;L)u3hQq^<
z!zQ79XJH-9#8!~C#LEztX&5ANDPl72#44!dk^mW?3zShs02EdqkNzh3Z{a?KHBS`y
zgGBJwn9{5Q?^V8v&I2O?LT{0kcMzuoIpF$LFNa?od=>G5t_Os?U*Ufgn@kzTk*dLa
z<Y%VuDVuNOMV{evsiKM~0HTWXCjGU(4XwwNel2`55{B4N_@c*fZkWfL)}5Q!E_!Vg
zQAh%cD4+t0$nhV<4F|#Z5yh)(dPbKltGyEP@;DjSra)pcDyE(Bd%}9X^j5Z>C-C*v
z%<d8>Vbq~_k&i&C8zlP*H3OoeiYNf0iYNf0iYNf0it_&ej9<2Q!%u*IFt*TqSK^2?
z%~Ikuo#I<*?gf-g+g4kLi5YF<Ex>t7spRJXkkW5py|+C=ie<ITcb4faPLjnchet--
zuBVVe9YLqk0HTU00HU*Qd}pLt>+hvYs_C(6ky)KZ?B3-T;VnaKGnmQTBMrv<ZO<93
zpZHz=3;zJ2zrz0j_%(z70E(kfI*KYgTez>SW1a~TXl79H$c!0XNXQ_L2qV2oKm`?>
z7mW0ajayT&O;=5O?G`BJ)Ge0f47L%-8KZeqIgMB&l`H@uTOAE#{{X`8@L&B6{uloM
z!K@$rRT_cRQBm66#eHiW@JN$GGKY>tV9M%7K?HC?9qLK|D6cj6&--3{KmDKlNo%9{
zqglJP)o(4n*&U^xk$b64<nAaWWwwe!idk3!*vV6lmB&l}00lDmId2m@n&*iljR9tN
z@MgBEpmijhOabpz%O}uW$oIM`mxlaDW#bPH*lOBk%y*h@scjwQrNn3Co*5K6IQA+*
zA6mOoFrtbm0HU~`ji0n1g}-O*BFg8)ceAAWwEqBP(=_`#SuZd3N%5a53wV{Jk-mci
zBP3?H4IlRU@bntqpK0Rn2mD9)Yj3K`w)T3DigZD1r^_o45;nMsNn?eZJPC?)Bd#*}
zThv!ay3s`xh7?yR@f+jEf&LF%TSemU8F*8|(%z|ibk+5HdlsEX1fZ4Ia2@ek8t3g<
z@b5(UNvU}4JXfY`9uU#w@~^c`47Rfks|~w@{g6sV(CS-{lrSd)ns#EkJqn8D{tSF)
z@Yn4J@YhZ8e}pwJ?SBsH{%_eX{?9GHo8`*zzsV}Aj67~RQJiFOL9U{Z!iuY{YgV2d
z(eAYkLh9be!p0_^;^KJ(aX}h_%<RX7Pyr;Kn558k+dmX&c6y$jbp`I9sKA$2w=lSP
z?jm&zj;uH;RDut1Xae07Q9uPz(!b;X08;+|uaW-%qGGGnM@s(ykNr#jzDNFvikbrT
z6j4Y5iYTB0iYTB0iYTB0iYTB0sKNgLBOTZMdqe*Kp-We)j34qb-GA4#Kl&83&;<Vg
z@-f=~0N1qN`V>`qsL%fZBOR~(drkiUp+#4z0mFQ4_{`r1Zaf_F>7Q-Wyi4LsUk_c~
zdFDUt&$O(G1lvM3@Yezua7qE^hTZb*Ja>n`ZH*UI{h>Z7cpmpoxzepZ7wK?nb8A-;
z;@?pQA3E)0QlR45WVYVGu+6|6W1gG#v-n+o@ssv)@os^nZ2sP!$lYkn`*9wlZp(3I
z`C<UuaTG^67{+os*UdgS{g8en_}}1P!|6tg4VR0&Uw5fl{6^DTR#{U`({=lWxzyuX
zLxr2{-du4Yk0gY`e5BHfZt=f=lafjs=+cstlfH?o+e^7wS^8hmHst+UYB63-tGy4Q
zyaW4I_<zJc2k?t{gHrIfgS>O%?H<=thr)W7h#^bZWuD!qSTI7!*b&Q?Sh_<Y3-X$y
z;Qs*IkKyNteluua4X!*_;Q`~lbHng!(Ad~(_ScYHiC1`v*~=uel7PyjLc8I_m;m5G
zrF;|AbpHU_YvP}YmqxaZ!^9pA(X>q}@mekOJ-g~{EC6SED*d7Z^8lxJ8NtVxd^r7{
zynW#PBjNs$E`_REz5f8g$b1Q?YL+*aOgt&6MF>7*;ip%THyx<f%QwuNg<LUpXYa~T
zj-3_ya#d+x{855$`^kFe4rY{Pqw4y6RMU3tX-%cO<$o`t{vP~&@Gr%`5bJtJg*<EF
zFB59s8Jq0-#g>z++uq!1GVWyAaU5>V6K+RbI0q=hs5REt$bYbZ?DOLP008*g!%}$0
z%i|uOKY+X{{v5DfYHtTWhSnxF%J5k>lMGky9&Mv&jm%MeiIzokw!XZrD#9^#i@*Fk
z`>wUOOWN;oQ<SBCWpDUp_v@v~J|O=9j|Be!ub4mda#iZ1;t%-nPx|?T{{TlNUa073
z6~TOb__eD1DzNb4XnH1}uIj!f)}qm^puW`KPPdJoDW&rsRDyQE5fOnI&U;sTURV24
zd>_2{%@2WWpo>s@Ejz_9Y8sT5I;5Iy#kI2A+^LZ!ib&;CxzK*?w|w52rS_t_b4LD`
zSNuNWm8~oGmA!23_>S;r?MI|0i>;p?&*AR?YMvX_q|x;V?)BJS#pPRg?t?*dAc)9@
z-c)nCIN5%1RBg%X=lIv)+g}>kcxq1;_+~#5>X5C)mXzA00`~GI48h}vcK1>hh$;xe
zpGx!J5&q3Ko*wb%!ms#7v|lqv@aKsyb)8z`>g?TId6MbZQ7z1}+&fJ?rdNq~mUjbh
zAy<z(y8WB{RUgJL5m{;@;&tDLJVE0qJWmzghc|}5ve2vB$rIdtsx{P6;V>!@5tA{*
zn-9!UZYnaGj>_Bp$^G|jdRwj3O6m?vfB1jO$$b2^`a<jCK8QRwX{p=mS`@b0rc+Iw
z^$611{#~rfi73cygk$oCI950~tb6Z|{u1zqguFee_@~953h@5`{3LKkC7a8yL-tG8
zWL6^9X*|C@K5>Q$HwII*XBFk%75$xjL8p9D)~#+d=vTp>78<4Zgh;qTZZ5S&4=>5P
zDfV`2$k%WHrP#;aIP<0bnLK;pJu|}3C7+M3E$==Y>3$Q{tUN6@hUJ>dTV!!O6Ae{N
zZ4{n&-nW;N5!|F~VKCKS(%&^Zr{{R9y?0)Y=8|?^f1GUo=H0Y<HR<)0*Thc`*ui%s
z+UAc8b{Dbfw@&x5s@q*j<%r;NTjiC!*tVhhkC>PrFwN@?e#ce6y|uNyw7I#{Bv@}D
zie-5%9g$>IkwMBaM@9hPm0)@iUod#*_Ab_ZSFhZ7W-)aqfwfHn()L^H>EL_#wW}*B
zEUnC;alS&WYd@HyXnP*NFcs`yvfqUKLE-O)lIk8Wv5QUde~I-Qonu$Fj%AozNh9rw
zE$B+Omu`?pl_Y$eRdUB&cKmvNl735<eqwqj)&3e^^-In3Xsmig6j4wCMHEm0MHEm0
zMHEm0MHEm0MHEm0MHEm0MHEm0MHEm0MHEm0MHEm0MHEm0MHEm0MHEm0MHEm0MHEm6
z&L8kmjZ;_AV)!d{plL8`y38LE?3&Y0n)mEc-9Pqrqw<-GKEc<Wr|DcD?MLw|;=hU|
z_+4w_{{V%$CxrB4@h`(n+J&!-7gLd3YB6nJBwELieRpx_Yw8b)-v_j>i#msd?sYjY
z5&RvlMdAw)Zz8CBh~b_U5@k+PZ0>L{au=SUpBBCkX<r$%{Sw<&lJYdrHOn6mTN`N=
z3AnSFW{5Ua<qIebI3yE-I@XFwScey>)zL*2nP<p9@L1Sox%gx7b~rpeYvSqT_^+a@
zdKJu(#SXN_E3hpcqy{xvPwvTZR0lZ(X1t@p_L}#?kK60u_ldRdfVxlY{o(CR?|d)+
z02KbAr{6`dUR^@Q2(Cq%rqv9Al$0lO<hBRP_CM`Y`zvUlwZDQijTc(g{7az!0ATAd
zYubLHpx!N|^`+b^BF5<>Bkd#2Vh9-o0th0we};eXPA?948{$rj;*D>|pBBC&-*|3w
zb)>=L4-y?t*H4_OUphGav>WhvCpaJx$Og8I(v6vugL1j_H55@;nuUD9`yhNQ@W;l#
zh+aSVxi^P2DRixWQU1j6sv8(uCDSY&<2Oh)^|-n-$&xd*W9Jp?{{SC;1I_W{NVTzF
z9QfzKmhhy}&OA4FZ*FgvK&y#bSS2`64&9}G`)532pX|r`Gh2Sko(}%N)4W^b9};O0
z!v(dCw!3j{D(R6#tf3+DV2c2PH*VdXqo+Bv(q3e}S?QEfML|JD6i^3*{93c{C&e$?
zH&^hUzwn#F{yOmnf#A4&LuYrW*jZf9bdPm)5?ID=6A}FIk{P54nND$nPn>8T6qmxf
z-KM9d{=^y<o2hB@Eyb<ft=EO&p4wF*mC@Ef%D{j@2Ox^~?PuT(wyW`rT=A@0&aI~E
zy4Qtc@ThA~EH#vAJ;cj#5p-ea2Dmuf8Gc2|o@<8x0EQ#gf9Sn@c>e&www?a~$TgyC
z`ne4r*Wt}V=T`9bh1KnZx>e=PymH)GODanCax#L^GodKONh(T`ryLS0?NadOlKKaS
ztSltGywsk`-aB@@yk%>PqKXvBAyri_*vl1AGEM;LS8FoQm49jNR_Ef^?R(*Gg?=}@
zpTfTkH5+8qZ2Y$<zCF|<aNpU|PB0=!@EF68((!}J<EsAvf`@3@Hi__>+sD&*qHhIw
zx4?3}$A)!iRLt_+$^x4M0RI4wgt^$L(Se==bW>in@oV7khQ2!ZHcbP?dQ>{Tl_asw
zBX@Y-8Bw<+k;sK!H&fA(gAAT|G<e70?}ol0_{+n3{<Wn;sOr8DmRa<PCU+@iEUK!~
z2=lR@3O2JTWanvIoZm9gj#sG{z~2^lgU4S7{5h<6uR{L-glEKhjf7L`8ef^e>{Bqy
zE_#n$r<KkRAlFw#6$PF{`$PWFI<JNNS*83w@D+`&v+*y)cFlQj9p3M-=yoCex72S6
zkbI?Yl~GRVU*#Rh`NzP1Ht~0jbf1WS4K$r1%U$?~<IBlx_3sc}cqZpSgGse$KF=-A
zpt2W+;lgBF#|(}n3=3@=^YlN*57~=e@rT8GUmo}i#|_{w7ykfde_-F-O{Au)X{cC<
zOsE<MbPFtUGcrgIMr9y_$9M2!;Z#2cejeHAQEHmTxhyR6-D*0m(_CHOPa_wWS7X53
z>`v7IS2zFxS}7#7BF(bT!as*r-v~Yxcx%FTbKG58cxOwt(x94inPx~LSe2W$NKj5V
z^sa`AD>A~0D4-8L@z$9w=fn+Tf5S~T#8xu+PH0<Jd96OtsxgtXqZs7@ytxO@x!gmR
z!w#mtdH(=~Yi<7kMknEa`}yHt{yASx_>bXp>;5jk)+6yhiuB1ZbU8FcwX?iIX=qu?
zi`e0GW&2v^3nK;_Km|yzGXDUEBh`QCy?l880KvAM{{YA}q*`CoA*0y532wH22hpNk
z89X?#SiplxPb+Sg1ZqCcJfdU7e{<wJeqK1mYgI1}X)mC7dcwj>+s#Srt>d?A%f?o?
zx+tMck`+}_?ToQi10>)Mm3Ff%@LAxoU)sCkY8$;T#J76)gKh1l@M-Yew({yRS^11V
z)907$mpjg+(a4(sMViz(P^8J`Kk%(>zv#sLFaH34JS+bI$1CU=KW7L(;cj@d#!>jI
z#Zc;gDbhc&(lFL<9*BVvM3zkU?JP~XJi@IbMA9*4jfh>mcl<FPtN#E+>*L4%4Ycq6
zL9JAg4IahdOLepGK8+IS$>GI{#snHld0TX_BT@Eo<r5ww`=24(^6|ziTB&$*Nqqyu
z))o?8-fB-}Zymc{UNW`C(M1YmkgBSeY-Nh587BaAtF@75%wH0Ge{t}$_VMwzh;6hT
zTg1|7KMHiqgQn?fuX%EVSiaxos}LELOE%o)w%}xtDz%TtuNHpRdLN2>SK+jm!~XyU
z^uG`4QCiD=W48OocMWYK`KYcp!D|zJ*5Rae=jF&9=f)q|pT*uL`0&3FJPq*%*TI^!
z`UGAcy^8n4tE<Ct1XmMWM#v2D6m8QuJhnhym^sDq5A5yn*Tp^`zSA#0I{0a=H5+*?
zX9@7_6^c5QY#+C9a8EU=aWmBIKVl#GGVg>x_9bZF`a=zRg>&Bs{vKQWA^1_@j|tjM
zCC#sfG@D%_8Kf9_Qr;AaSdUT=6ZNi!vwN1bK}8f&8S!_=-yG`R82HEgM0m=@*ZvZp
zhrS=tG_McL@f(AoY1f~;z0?vSHj<^Kb|ZF0l7q*~RW;uj_z&T4#@_^Z9)FAX9}&C{
z@ovjfu<;$2iabjWv2PL!V=Na@&5$kp$5RkRA~xUhAY{n;1LNQ9->G=p#+F_<@J7EE
zg?xLaSiYKOxwIF0ZntL5zwDQ=<yoT+30Fo}LheR$is3#Qe#@RPzSj+pi~JG$Iq1F$
zyqE1d)|a4oeoNUrK`N_=%!YX4jy<gV@={jg0Q|((%1XvocRJtrCvS?cJYoA9cqZoh
z?&DCF-W#1hJIUC*m#|x1&20?jk6$t<k@MenYuc&}J5IOJ^!RNpAcoe~*#uC-3IvWM
z0|8Y>00Gbnp0aN4=8HvR=UeXxX+AOk0D_t8QEK{LovOtL!yPr_OUq=PV`Hk{f<Rz!
zYTxZ2`!_d_=eN`E=hHMFf;t_Xn$EqU=<ygYJV|vKFXT<JRYj;oMj=~tjq;EJt5v_-
zGxj}?_JGivU+}@U(f%pvG1{hytxbJ*Z3-keX>eeiK*M}YJk|M;_W7lN&0_dl{t3t7
zzZ7WFY9AE!PZ4<c#+tje#;vF)h&3HL%)0<Qh%K$>jx>P)+MuZ<4tn5dn%?Bu?PJqF
zWjznVS|{x9;YaWun=X&x4PwY^nq7>e4QmziHSWT@m@XP~@`6J22LM;0RWA*Aa>v2`
z9k9}L%V_NM-7eZYJ4<-S$pkT|L_zEn06vv=vU`@cJ~jUUg16~DKDg4n8GUCakuSnc
zKK*9#g{|G4#nd2%1{tqnf<%^U6l@nnVS+a@xBw2`e;s^$_-*j%{97mdDSsJwTT0Wv
zw12bwJ8OTZ++JCvd-H2E%``;$V<@F|w*zp_Yv}u{Sg);Qf_TzsW>S(y>KR=~!2})%
zBeiF0ehky~9|YWZd0<ODDti{wgchnISRgT&_Qn9hfV=<(1_u?VK8X{{t<1RoA<yFv
zgO>g(@MV>^h$PjtxV23p*5>fo$9|H=vPPy|l6iZThdW3FjPcEQ-|S`kWPC&YsXSY*
z+iSlDZoVF9{v4i58@ug8U1_9ywcx=NKV?n$>d(9=1YnYJUg7Y+;q{loUxuC?@UEEm
zGHJdU(=D`{N4Q|qJWxcjA#wl(wxG!X4CjGcwKrQ>dWBKazvKS^QvU$2k^caqVyo3h
zO8)?l{Y(D7NB)V5k{No6D5L>J6i@+06i@+06i@+06i@+FVE+J-j_dxtq5lBTrK{DK
zDqO#a?mo{fF@K{&yUd8bera)xGUA#7Y5xG^W3~SPuW7&ZD5~{Qw$tu^w36cDcx3Y9
zc-3Qsr`{?_B(eVQ>sP4&QAHF0QAHF0QAHF1N5miT;GgyL2mX#qy;ZeaCe$qav~e4U
zNfnuQ09C_sGCe(NFC$U^0H3Qb`~+|QIZvP$sH#3jqyGRuR$urC-~4iqBT@eVpQ|tY
z1aJO1Ko_X0K1QSe06$h=_z2(pa*rcX{{Ww>FZ={={y9JwsH#3jqyGRuR$urC-~4iq
zBT@eVpQ|tY1aJO1Ko_X0K1QSe06$h=_z2(pa*rcX{{Ww>FZ={={y9JwsH#3jqyGRu
zR$urC-~4iqBT@eVpQ|tY1aJO1Ko_X0K1QSe06$h=_z2(pa*rcX{{Ww>FZ={={y9Jw
zsH#3jqyGRuR$urC-~4iqBT@eVpQ|tY1aJO1Ko_X0K1QSe06$h=_z2(pa*rcX{{Ww>
zFZ={={y9JwsH#3jqyGRuR$urC-~4iqBT@eVpQ|tY1aJO1Ko_X0K1QSe06$h=_z2(p
za*rcX{{Ww>FZ={={y9JwsH#3jqyGRuR$urC-~4iqBT@eVpQ|tY1aJO1Ko_X0K1QSe
z06$h=_z2(pa*rcX{{Ww>FZ={={y9JwsH#3jqyGRuR$urC-~4iqBT@eVpQ|tY1aJO1
zKo_X0K1QSe06$h=_z2(pa*rcX{{Ww>FZ={={y9JwsH#3jqyGRuR$urC-~4iqBT@eV
zpQ|tY1aJO1Ko_X0K1QSe06$h=_z2(pa*rcX{{Ww>FZ={={y9JwsH#3jqyGRuR$urC
z-~4iqBT@eVpQ|tY1aJO1Ko_X0K1QSe06$h=_z2(pa*rcX{{Ww>FZ={={y9JwsH#3j
zqyGRuR$urC-~4iqBT@eVpQ|tY1aJO1Ko_X0K1QSe06$h=_z2(pa*rcX{{Ww>FZ={=
z{y9JwsH#3jqyGRuR$urC-~4iqBT@eVpQ|tY1aJO1Ko_X0K1QSe06$h=_z2(pa*rcX
z{{Ww>FZ={={y9JwsH#3jqyGRuR$urC-~4iqBT@eVpQ|tY1aJO1Ko_X0K1QSe06$h=
z_z2(pa*rcX{{Ww>FZ={={y9JwsH#3jqyGRuR$urC-~4iqBT@eVpQ|tY1aJO1Ko_X0
zK1QSe06$h=_z2(pa*rcX{{Ww>FZ={={y9JwsH#3jqyGRuR$urC-~4iqBT@eVpQ|tY
z1aJO1Ko_X0K1QSe06$h=_z2(pa*rcX{{Ww>FZ={={y9JwsH#3jqyGRuR$urC-~4iq
zBT@eVpQ|tY1aJO1Ko_X0K1QSe06$h=_z2(pa*rcX{{Ww>FZ={={y9JwsH#3jqyGRu
zR$urC-~4iqBT@eVpQ|tY1aJO1Ko_X0K1QSe06$h=_z2(pa*rcX{{Ww>FZ={={y9Jw
zsH#3jqyGRuR$urC-~4iqBT@eVpQ|tY1aJO1Ko_X0K1QSe06$h=_z2(pa*rcX{{Ww>
zFZ={={y9JwsH#3jqyGRuR$urC-~4iqBT@eVpQ|tY1aJO1Ko_X0K1QSe06$h=_z2(p
za*rcX{{Ww>FZ={={y9JwsH#3jqyGRuR$urC-~4iqBT@eVpQ|tY1aJO1Ko_X0K1QSe
z06$h=_z2(pa*rcX{{Ww>FZ={={y9JwsH#3jqyGRuR$urC-~4iqBT@eVpQ|tY1aJO1
zKo_X0K1QSe06$h=_z2(pa*rcX{{Ww>FZ={={y9JwsH#3jqyGRuR$urC-~4iqBT@eV
zpQ|tY1aJO1Ko_X0K1QSe06$h=_z2(pa*rcX{{Ww>FZ={={y9JwsH#3jqyGRuR$urC
z-~4iqBT@eVpQ|tY1aJO1Ko_X0K1QSe06$h=_z2(pa*rcX{{Ww>FZ={={y9JwsH#3j
zqyGRuR$urC-~4iqBT@eVpQ|tY1aJO1Ko_X0K1QSe06$h=_z2(pa*rcX{{Ww>FZ={=
z{y9JwsH#3jqyGRuR$urC-~4iqBT@eVpQ|tY1aJO1Ko_cxmHz-A`j`EDkNp!B9!8`8
z06$h=_z2(pa+#p4i*cxlSsqWcjItq6e{~;XPxGKgjTBKxVMP>B0Ywy00Ywy00Ywy0
z0aRfB0FjRC{=K390MMnY)kY8b81BF8+8_N2T4)J1O;L2nl$B{7M%x@|)zA2Pny3A-
zet+f0-|@OX{6#xf=U%h_0Im}s{CX;qno7jBL;bO+f6tA#{so`@B9HBjL;ieizwj*o
z0Pz(y6zqj|L;bO+f6tA#{so`@B9HBjL;ieizwj*o0Pz(y6j=q?5BA2P{{TKV-}n}P
z_=-QaH4pjmw*LUYv;P3ZRMb&q7i2%%8i)M&+kfC${{Z4B{@Bz%=f>Or00Phd01;DB
zMUY*P{{U=iAM@jF{{Vq!{{V=i`(sf50G}Ig{0l$)MNLH(L3Ts^v8aE~jko><pZ+3`
z?TthJd~Lt*EdK!U6*UxD1=$bw#-aZJJ~rR@7JvAPKejaw`SG^@0Kl{V0K`<(QDhfn
zKie9I{P^2{;936w;wb*u)IaCO+y4Lp&;I}sQ&B~bU6B6(Y-%6#<8A){foJ~!h@<;s
zQ2zj*8*lszKm0{aMHWGJL;bO+f6tA#{so`@B9HBjL;ieizwj*o0Pz(y6j=q?5BA2P
z{{TKV-}n}P_=-QaH4pjmw*LUYv;P3ZRMb&q7i2%%8i)M&+kfC${{Z4B{@Bz%=f>Or
z00Phd01;DBMUY*P{{U=iAM@jF{{Vq!{{V=i`(sf50G}Ig{0l$)MNLH(L3Ts^v8aE~
zjko><pZ+3`?TthJd~Lt*EdK!U6*UxD1=$bw#-aZJJ~rR@7JvAPKejaw`SG^@0Kl{V
z0K`<(QDhfnKie9I{P^2{;936w;wb*u)IaCO+y4Lp&;I}sQ&B~bU6B6(Y-%6#<8A){
zfoJ~!h@<;sQ2zj*8*lszKm0{aMHWGJL;bO+f6tA#{so`@B9HBjL;ieizwj*o0Pz(y
z6j=q?5BA2P{{TKV-}n}P_=-QaH4pjmw*LUYv;P3ZRMb&q7i2%%8i)M&+kfC${{Z4B
z{@Bz%=f>Or00Phd01;DBMUY*P{{U=iAM@jF{{Vq!{{V=i`(sf50G}Ig{0l$)MNLH(
zL3Ts^v8aE~jko><pZ+3`?TthJd~Lt*EdK!U6*UxD1=$bw#-aZJJ~rR@7JvAPKejaw
z`SG^@0Kl{V0K`<(QDhfnKie9I{P^2{;936w;wb*u)IaCO+y4Lp&;I}sQ&B~bU6B6(
zY-%6#<8A){foJ~!h@<;sQ2zj*8*lszKm0{aMHWGJL;bO+f6tA#{so`@B9HBjL;iei
zzwj*o0Pz(y6j=q?5BA2P{{TKV-}n}P_=-QaH4pjmw*LUYv;P3ZRMb&q7i2%%8i)M&
z+kfC${{Z4B{@Bz%=f>Or00Phd01;DBMUY*P{{U=iAM@jF{{Vq!{{V=i`(sf50G}Ig
z{0l$)MNLH(L3Ts^v8aE~jko><pZ+3`?TthJd~Lt*EdK!U6*UxD1=$bw#-aZJJ~rR@
z7JvAPKejaw`SG^@0Kl{V0K`<(QDhfnKie9I{P^2{;936w;wb*u)IaCO+y4Lp&;I}s
zQ&B~bU6B6(Y-%6#<8A){foJ~!h@<;sQ2zj*8*lszKm0{aMHWGJL;bO+f6tA#{so`@
zB9HBjL;ieizwj*o0Pz(y6j=q?5BA2P{{TKV-}n}P_=-QaH4pjmw*LUYv;P3ZRMb&q
z7i2%%8i)M&+kfC${{Z4B{@Bz%=f>Or00Phd01;DBMUY*P{{U=iAM@jF{{Vq!{{V=i
z`(sf50G}Ig{0l$)MNLH(L3Ts^v8aE~jko><pZ+3`?TthJd~Lt*EdK!U6*UxD1=$bw
z#-aZJJ~rR@7JvAPKejaw`SG^@0Kl{V0K`<(QDhfnKie9I{P^2{;936w;wb*u)IaCO
z+y4Lp&;I}sQ&B~bU6B6(Y-%6#<8A){foJ~!h@<;sQ2zj*8*lszKm0{aMHWGJL;bO+
zf6tA#{so`@B9HBjL;ieizwj*o0Pz(y6j=q?5BA2P{{TKV-}n}P_=-QaH4pjmw*LUY
zv;P3ZRMb&q7i2%%8i)M&+kfC${{Z4B{@Bz%=f>Or00Phd01;DBMUY*P{{U=iAM@jF
z{{Vq!{{V=i`(sf50G}Ig{0l$)MNLH(L3Ts^v8aE~jko><pZ+3`?TthJd~Lt*EdK!U
z6*UxD1=$bw#-aZJJ~rR@7JvAPKejaw`SG^@0Kl{V0K`<(QDhfnKie9I{P^2{;936w
z;wb*u)IaCO+y4Lp&;I}sQ&B~bU6B6(Y-%6#<8A){foJ~!h@<;sQ2zj*8*lszKm0{a
zMHWGJL;bO+f6tA#{so`@B9HBjL;ieizwj*o0Pz(y6j=q?5BA2P{{TKV-}n}P_=*m@
zc?jJtf@~b0Dt+ybU{q)Gsi>mJF3Xm;DS2*^#&;xxa-V9erGLl%rT+k5BmV$I#ZB<f
z8duVJfd2r$uTIjx<Np9s{{XL%{{W(5sqRsFiYTNoqKYU0qKYU0qKYU0qKYU0sxW`Z
z$94YzUeNyl=u*|{qX+zqcVG4G5B`NMGz2=Y{D-YS>)vnu3M%A&IebIC_-Ekz9YVq@
zS!TJ`^u0Bf;aQYNbA1iGgkXcXB#c*_WDJ5huDezL0Fd>k{d>*-0HH-(Pwf%l9be)%
z!?>)pA*Q~kXRB$tq*348J-icrmhu~hMv)_tmvD@LLN*B;Rmb9u_PW2N)&BqkIc)8{
zpWkf_Z-`$OG(UywWHo8;KGCSVC8ec~pK+*OT<sg2q!#HUtg0|sg5h#9Mnz+Im-d+O
zcZGZ>rt6d6>K8g*tz`O*y!w8Rd#G);K&9o8V2Ro!UBf0oxH$)qK;eEUd=~My#ch8;
z@ipd^q1kIXB3<e2rs>{0)wK9-Eobsy%@@|T(Mqx`kbq(^x-y*Z3<fj2ar-oQzWc%2
zW`&_eWn-d^D&`5a!Q-uB*jQiBE6DdI>L|SZK~I=}cR7uCKi<l{qkg~e{{WtzS9W&X
z6`Z`k;IGSHJ1efot<CY%!jNb>_NH}+jgN+eXHb=5k-V`aQOy}Z7c%cjQ*V|Vac!e4
z2&(h`(7qD4@yd90wF{G|HPYA_7f!lsD6W}zExeavKeNX%1Y#zTK3PWGum^y!{gyRb
zeP6(e*Lq0OH2o_~wed~3-p5g&O&jdYUnm7c%*Bh~m5wok+Lf2=pMR!&P}C)w!X0nJ
znvaOjhy>Dj>shdCS83Mc2ThG$(q@ifxk+RU0&W0;$6i=_OJ7ZY2A86~t$8J`rd-qZ
zceb`)ihn&Flka^tJ&(uV5;VVtnsvR-sr{tl?r*cf6^5B}sN72XS;$yz<B~!Gs}gqL
z0m&6VgZy`-`1`@OULewMW4h7x2nEa+Bs5^h>cN0yBLon@6(E8E2DtwK+6%zGEAhf;
zsp09Omcrg?TT;{8#5bNFd%#c#nQtv4l4aQ0CNKbf!zbmzqwuTtf4uPj0PLp!01q|G
z*nZV{W2ji%-C4~n!3E5dw&i(oBM`EVSmcm$Pg9Hj8<O9r-TiqRD|4jw>S@{j)ZPfa
z(DfZp`%?A|FHN@>ZF_a3URzsT#LN*M+F2r0x(>{tJcB0k>9;$VFHhQo!7JfyXIQ$`
zZnUdE4?HQUE~%y6>DLxQW>tya3F1jaY+C|Nn-13J<!o}gzrzoRzBc%2Yoh9r_$yDp
z@XVGM+D+A^<;}zzrPZ9tBKh#NG5ww=5#Xw{#SEDRys#dxjQ#=mzv8@pBGq+-@Xn8|
z>agireXX69{P%XzTiM@zt=>u62$`f}&J{!;F46NH#IC%s+WmhHkLTNUyX<AnD_yO0
z`}(hz_u1{{bdCFC{5_A(5^DO45?W4{_pwi*U&St%UuTy0NYDnhiTuUeEWsmgcCp%V
zcg7#JKY;uL;*0GgSJzFI-jys7Y7W*n4Q-|w!kAj-;6`DAA9xD#I;lH`a;yd)#Xs5m
zRPnBv@nSnEbf{+W?v-t0X7aPH$BG#vCSnkfxp9ncIL{RyjQ;><jaS6_f5iv{+Dk8u
z<*<7tmE5di2qBHU-;m?xjFGo@80k~){{UYv_$6v}nh)(0;Qs&+=z8{|nyi*qz8MPo
zq13EyH0do7mwGu%h|$VA@~i<?!P-qzKea!B;PBP<t#zs2X_mTe-My94YC1*jjm#2U
zFjzN1G)XSm3t?Yo!b5ZNoO6E{{{Uu<N8*mB@d?HCrK~<F()5da0w$RrJBu5M=l$uA
zW2|h?7~LE1#_V8$oLx8eVAgLeeEIad4I^3p+0kz0xSPisw}}nSt(E868a?-sDTs{8
zu~ZODhb4N^6&EC)*N@!VyZrq;!dFpt-(Sk>@%#LakH=rOUxs`!@b2qh)2;QrU92^m
zJr?f3=-2kwmU7P|Lo&eD=4kO8q1SX^NOq!<&b8{gR;3=ZrQ6-Yw+R*0ODZhzJQAv~
z$PF8XbZ&W80E58**N}Wm{hqbo72bIM>c-<q^L#^lq3RlRbIl?tZ9Yh)Xy#!Xd11_Z
zLnwR(&eMz^U(%(zn@hKA=xy!qS|u~Z1jcBilOHmxl|sr6aK%)S&Id|ba=!QcEWca&
zb?6%3U+Z7;EKx-jB?S~wKm`<0Km`<0Km`<0Km`<0Km`<0Km`<0Km`<0Km`<0Km`<0
zKm`<0Km`<0Km`<0Km`<0Km`<0Km`<0Km`<0Km`<0Km`<0Km`<0Km`<0Km`<0Km`<0
zKm`<0Km`<0Km`<0Km`<0Km`<0Km`<0Km`<0Km`<0Km`<0Km`<0Km`<0Km`<0Km`<0
zKm`<0Km`<0Km`<0Km`<0Km`<0Km`<0Km`<0KnI4u<Q9MH;(z@b^zAGDKlLyA`5*cw
zDsP6r<Q9MH;(z@b^zAGDKlLyA`5*cwDxR#hvM*6Z6(b5LqJRo0qJRo0qJRo0qJRpc
z2mFk8U-j(|{)H`GsxW`Z$94YzUeNyl=u*=_L#qD($a>TMz2^S_(4wg-Jy-ri)}Qt7
zH~xhcNmRBW?i5i)F$EM+Km`<0Km`<0Km`<0Km`<0Km`<0Km`<0Km`<0Km`<0Km`<0
zKm`<0Km`<0Km`<0Km`<0Km`<0Km`<0Km`<0Km`<0Km`<0Km`<0Km`<0Km`<0Km`<0
zKm`<0Km`<0Km`<0Km`<0Km`<0Km`<0Km`<0Km`<0Km`<0Km`<0Km`<0Km`<0Km`<0
zKm`<0Km`<0Km`<0Km`<0Km`<0Km`<0Km`<0Km`<0Km`<0Km`<0Km`<0Km`<0Km`<0
zKm`<0KnI4u<Q9MH;(z@b^zAGDKlLyA`5*cwDsP6r<Q9MH;(z@b^zAGDKlLyA`5*cw
zDxR#hvM*6Z6(b5LqJRo0qJRo0qJRo0qJRpc2mFk8U-j(|{)H`GsxW`Z$94YzUeNyl
z=u*=_L#qD($a>TMz2^S_(4wg-Jy-ri)}Qt7H~xhcNmRBW?i5i)F$EM+Km`<0Km`<0
zKm`<0Km`<0Km`<0Km`<0Km`<0Km`<0Km`<0Km`<0Km`<0Km`<0Km`<0Km`<0Km`<0
zKm`<0Km`<0Km`<0Km`<0Km`<0Km`<0Km`<0Km`<0Km`<0Km`<0Km`<0Km`<0Km`<0
zKm`<0Km`<0Km`<0Km`<0Km`<0Km`<0Km`<0Km`<0Km`<0Km`<0Km`<0Km`<0Km`<0
zKm`<0Km`<0Km`<0Km`<0Km`<0Km`<0Km`<0Km`<0KnI4u<Q9MH;(z@b^zAGDKlLyA
z`5*cwDsP6r<Q9MH;(z@b^zAGDKlLyA`5*cwDxR#hvM*6Z6(b5LqJRo0qJRo0qJRo0
zqJRpc2mFk8U-j(|{)H`GsxW`Z$94YzUeNyl=u*=_L#qD($a>TMz2^S_(4wg-Jy-ri
z)}Qt7H~xhcNmRBW?i5i)F$EM+Km`<0Km`<0Km`<0Km`<0Km`<0Km`<0Km`<0Km`<0
zKm`<0Km`<0Km`<0Km`<0Km`<0Km`<0Km`<0Km`<0Km`<0Km`<0Km`<0Km`<0Km`<0
zKm`<0Km`<0Km`<0Km`<0Km`<0Km`<0Km`<0Km`<0Km`<0Km`<0Km`<0Km`<0Km`<0
zKm`<0Km`<0Km`<0Km`<0Km`<0Km`<0Km`<0Km`<0Km`<0Km`<0Km`<0Km`<0Km`<0
zKm`<0Km`<0KnI4u<Q9MH;(z@b^zAGDKlLyA`5*cwDsP6r<Q9MH;(z@b^zAGDKlLyA
z`5*cwDxR#hvM*6Z6(b5LqJRo0qJRo0qJRo0qJRpc2mFk8U-j(|{)H_RQ$Rzi{{YB(
z)Be5Y{{YaUsVJhUY(v~AqKaY)D58K0D58K0D58K0D58K0D58K0D58K0D58K0D58K0
zD58K0D58K0D58K0D58K0D58K0D58K0D58K0D58K0D58K0D58K0D58K0D58K0D58K0
zD58K0D58K0D58K0D58K0D58K0D58K0D58K0D58K0D58K0D58K0D58K0D58K0D58K0
zD58K0D58K0D58K0D58K0D58K0D58K0D58K0D58K0D58K0D58K0D58K0D58K0D58K0
zD58K0D58K0D58K54S&ci{{Yv-{{Z?m>DpKPf9hZL@;~%UR8dpambOLeD59ii|Jh!S
B`2zp|

diff --git a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/keywords.txt b/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/keywords.txt
deleted file mode 100644
index f320104..0000000
--- a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/keywords.txt
+++ /dev/null
@@ -1,628 +0,0 @@
-#######################################
-# Syntax Coloring Map
-#######################################
-
-#######################################
-# Datatypes (KEYWORD1)
-#######################################
-
-SFE_UBLOX_GNSS	KEYWORD1
-
-ubxPacket	KEYWORD1
-
-geofenceState	KEYWORD1
-
-UBX_ESF_MEAS_sensorData_t	KEYWORD1
-UBX_ESF_RAW_sensorData_t	KEYWORD1
-UBX_ESF_STATUS_sensorStatus_t	KEYWORD1
-
-UBX_NAV_POSECEF_data_t	KEYWORD1
-UBX_NAV_STATUS_data_t	KEYWORD1
-UBX_NAV_DOP_data_t	KEYWORD1
-UBX_NAV_ATT_data_t	KEYWORD1
-UBX_NAV_PVT_data_t	KEYWORD1
-UBX_NAV_ODO_data_t	KEYWORD1
-UBX_NAV_VELECEF_data_t	KEYWORD1
-UBX_NAV_VELNED_data_t	KEYWORD1
-UBX_NAV_HPPOSECEF_data_t	KEYWORD1
-UBX_NAV_HPPOSLLH_data_t	KEYWORD1
-UBX_NAV_CLOCK_data_t	KEYWORD1
-UBX_NAV_RELPOSNED_data_t	KEYWORD1
-
-UBX_RXM_SFRBX_data_t	KEYWORD1
-UBX_RXM_RAWX_data_t	KEYWORD1
-
-UBX_TIM_TM2_data_t	KEYWORD1
-
-UBX_ESF_ALG_data_t	KEYWORD1
-UBX_ESF_INS_data_t	KEYWORD1
-UBX_ESF_MEAS_data_t	KEYWORD1
-UBX_ESF_RAW_data_t	KEYWORD1
-UBX_ESF_STATUS_data_t	KEYWORD1
-
-UBX_HNR_PVT_data_t	KEYWORD1
-UBX_HNR_ATT_data_t	KEYWORD1
-UBX_HNR_INS_data_t	KEYWORD1
-
-#######################################
-# Methods and Functions (KEYWORD2)
-#######################################
-
-setPacketCfgPayloadSize	KEYWORD2
-begin	KEYWORD2
-end	KEYWORD2
-setI2CpollingWait	KEYWORD2
-setI2CTransactionSize	KEYWORD2
-getI2CTransactionSize	KEYWORD2
-isConnected	KEYWORD2
-enableDebugging	KEYWORD2
-disableDebugging	KEYWORD2
-debugPrint	KEYWORD2
-debugPrintln	KEYWORD2
-statusString	KEYWORD2
-disableUBX7Fcheck	KEYWORD2
-
-checkUblox	KEYWORD2
-checkUbloxI2C	KEYWORD2
-checkUbloxSerial	KEYWORD2
-
-process	KEYWORD2
-processNMEA	KEYWORD2
-processRTCMframe	KEYWORD2
-processRTCM	KEYWORD2
-processUBX	KEYWORD2
-processUBXpacket	KEYWORD2
-
-calcChecksum	KEYWORD2
-sendCommand	KEYWORD2
-printPacket	KEYWORD2
-
-checkCallbacks	KEYWORD2
-
-pushRawData	KEYWORD2
-
-setFileBufferSize	KEYWORD2
-getFileBufferSize	KEYWORD2
-extractFileBufferData	KEYWORD2
-fileBufferAvailable	KEYWORD2
-getMaxFileBufferAvail	KEYWORD2
-clearFileBuffer	KEYWORD2
-clearMaxFileBufferAvail	KEYWORD2
-
-getPortSettings	KEYWORD2
-setPortOutput	KEYWORD2
-setPortInput	KEYWORD2
-
-setI2CAddress	KEYWORD2
-setSerialRate	KEYWORD2
-
-setI2COutput	KEYWORD2
-setUART1Output	KEYWORD2
-setUART2Output	KEYWORD2
-setUSBOutput	KEYWORD2
-setSPIOutput	KEYWORD2
-setNMEAOutputPort	KEYWORD2
-
-factoryReset	KEYWORD2
-hardReset	KEYWORD2
-factoryDefault	KEYWORD2
-
-saveConfiguration	KEYWORD2
-saveConfigSelective	KEYWORD2
-
-configureMessage	KEYWORD2
-enableMessage	KEYWORD2
-disableMessage	KEYWORD2
-enableNMEAMessage	KEYWORD2
-disableNMEAMessage	KEYWORD2
-enableRTCMmessage	KEYWORD2
-disableRTCMmessage	KEYWORD2
-
-getSurveyMode	KEYWORD2
-setSurveyMode	KEYWORD2
-enableSurveyMode	KEYWORD2
-disableSurveyMode	KEYWORD2
-setStaticPosition	KEYWORD2
-
-getProtocolVersionHigh	KEYWORD2
-getProtocolVersionLow	KEYWORD2
-getProtocolVersion	KEYWORD2
-
-addGeofence	KEYWORD2
-clearGeofences	KEYWORD2
-clearAntPIO	KEYWORD2
-getGeofenceState	KEYWORD2
-
-powerSaveMode	KEYWORD2
-getPowerSaveMode	KEYWORD2
-powerOff	KEYWORD2
-powerOffWithInterrupt	KEYWORD2
-
-setDynamicModel	KEYWORD2
-getDynamicModel	KEYWORD2
-
-resetOdometer	KEYWORD2
-
-enableGNSS	KEYWORD2
-
-createKey	KEYWORD2
-getVal	KEYWORD2
-getVal8	KEYWORD2
-getVal16	KEYWORD2
-getVal32	KEYWORD2
-setVal	KEYWORD2
-setVal8	KEYWORD2
-setVal16	KEYWORD2
-setVal32	KEYWORD2
-newCfgValset8	KEYWORD2
-newCfgValset16	KEYWORD2
-newCfgValset32	KEYWORD2
-addCfgValset8	KEYWORD2
-addCfgValset16	KEYWORD2
-addCfgValset32	KEYWORD2
-sendCfgValset8	KEYWORD2
-sendCfgValset16	KEYWORD2
-sendCfgValset32	KEYWORD2
-
-getNAVPOSECEF	KEYWORD2
-setAutoNAVPOSECEF	KEYWORD2
-setAutoNAVPOSECEFrate	KEYWORD2
-setAutoNAVPOSECEFcallback	KEYWORD2
-assumeAutoNAVPOSECEF	KEYWORD2
-initPacketUBXNAVPOSECEF	KEYWORD2
-flushNAVPOSECEF	KEYWORD2
-logNAVPOSECEF	KEYWORD2
-
-getNAVSTATUS	KEYWORD2
-setAutoNAVSTATUS	KEYWORD2
-setAutoNAVSTATUSrate	KEYWORD2
-setAutoNAVSTATUScallback	KEYWORD2
-assumeAutoNAVSTATUS	KEYWORD2
-initPacketUBXNAVSTATUS	KEYWORD2
-flushNAVSTATUS	KEYWORD2
-logNAVSTATUS	KEYWORD2
-
-getDOP	KEYWORD2
-setAutoDOP	KEYWORD2
-setAutoDOPrate	KEYWORD2
-setAutoDOPcallback	KEYWORD2
-assumeAutoDOP	KEYWORD2
-initPacketUBXNAVDOP	KEYWORD2
-flushDOP	KEYWORD2
-logNAVDOP	KEYWORD2
-
-getVehAtt	KEYWORD2
-getNAVATT	KEYWORD2
-setAutoNAVATT	KEYWORD2
-setAutoNAVATTrate	KEYWORD2
-setAutoNAVATTcallback	KEYWORD2
-assumeAutoNAVATT	KEYWORD2
-initPacketUBXNAVATT	KEYWORD2
-flushNAVATT	KEYWORD2
-logNAVATT	KEYWORD2
-
-getPVT	KEYWORD2
-setAutoPVT	KEYWORD2
-setAutoPVTrate	KEYWORD2
-setAutoPVTcallback	KEYWORD2
-assumeAutoPVT	KEYWORD2
-initPacketUBXNAVPVT	KEYWORD2
-flushPVT	KEYWORD2
-logNAVPVT	KEYWORD2
-
-getNAVODO	KEYWORD2
-setAutoNAVODO	KEYWORD2
-setAutoNAVODOrate	KEYWORD2
-setAutoNAVODOcallback	KEYWORD2
-assumeAutoNAVODO	KEYWORD2
-initPacketUBXNAVODO	KEYWORD2
-flushNAVODO	KEYWORD2
-logNAVODO	KEYWORD2
-
-getNAVVELECEF	KEYWORD2
-setAutoNAVVELECEF	KEYWORD2
-setAutoNAVVELECEFrate	KEYWORD2
-setAutoNAVVELECEFcallback	KEYWORD2
-assumeAutoNAVVELECEF	KEYWORD2
-initPacketUBXNAVVELECEF	KEYWORD2
-flushNAVVELECEF	KEYWORD2
-logNAVVELECEF	KEYWORD2
-
-getNAVVELNED	KEYWORD2
-setAutoNAVVELNED	KEYWORD2
-setAutoNAVVELNEDrate	KEYWORD2
-setAutoNAVVELNEDcallback	KEYWORD2
-assumeAutoNAVVELNED	KEYWORD2
-initPacketUBXNAVVELNED	KEYWORD2
-flushNAVVELNED	KEYWORD2
-logNAVVELNED	KEYWORD2
-
-getNAVHPPOSECEF	KEYWORD2
-setAutoNAVHPPOSECEF	KEYWORD2
-setAutoNAVHPPOSECEFrate	KEYWORD2
-setAutoNAVHPPOSECEFcallback	KEYWORD2
-assumeAutoNAVHPPOSECEF	KEYWORD2
-initPacketUBXNAVHPPOSECEF	KEYWORD2
-flushNAVHPPOSECEF	KEYWORD2
-logNAVHPPOSECEF	KEYWORD2
-
-getHPPOSLLH	KEYWORD2
-setAutoHPPOSLLH	KEYWORD2
-setAutoHPPOSLLHrate	KEYWORD2
-setAutoHPPOSLLHcallback	KEYWORD2
-assumeAutoHPPOSLLH	KEYWORD2
-initPacketUBXNAVHPPOSLLH	KEYWORD2
-flushHPPOSLLH	KEYWORD2
-logNAVHPPOSLLH	KEYWORD2
-
-getNAVCLOCK	KEYWORD2
-setAutoNAVCLOCK	KEYWORD2
-setAutoNAVCLOCKrate	KEYWORD2
-setAutoNAVCLOCKcallback	KEYWORD2
-assumeAutoNAVCLOCK	KEYWORD2
-initPacketUBXNAVCLOCK	KEYWORD2
-flushNAVCLOCK	KEYWORD2
-logNAVCLOCK	KEYWORD2
-
-getSurveyStatus	KEYWORD2
-initPacketUBXNAVSVIN	KEYWORD2
-
-getRELPOSNED	KEYWORD2
-setAutoRELPOSNED	KEYWORD2
-setAutoRELPOSNEDrate	KEYWORD2
-setAutoRELPOSNEDcallback	KEYWORD2
-assumeAutoRELPOSNED	KEYWORD2
-initPacketUBXNAVRELPOSNED	KEYWORD2
-flushNAVRELPOSNED	KEYWORD2
-logNAVRELPOSNED	KEYWORD2
-
-getRXMSFRBX	KEYWORD2
-setAutoRXMSFRBX	KEYWORD2
-setAutoRXMSFRBXrate	KEYWORD2
-setAutoRXMSFRBXcallback	KEYWORD2
-assumeAutoRXMSFRBX	KEYWORD2
-initPacketUBXRXMSFRBX	KEYWORD2
-flushRXMSFRBX	KEYWORD2
-logRXMSFRBX	KEYWORD2
-
-getRXMRAWX	KEYWORD2
-setAutoRXMRAWX	KEYWORD2
-setAutoRXMRAWXrate	KEYWORD2
-setAutoRXMRAWXcallback	KEYWORD2
-assumeAutoRXMRAWX	KEYWORD2
-initPacketUBXRXMRAWX	KEYWORD2
-flushRXMRAWX	KEYWORD2
-logRXMRAWX	KEYWORD2
-
-getTIMTM2	KEYWORD2
-setAutoTIMTM2	KEYWORD2
-setAutoTIMTM2rate	KEYWORD2
-setAutoTIMTM2callback	KEYWORD2
-assumeAutoTIMTM2	KEYWORD2
-initPacketUBXTIMTM2	KEYWORD2
-flushTIMTM2	KEYWORD2
-logTIMTM2	KEYWORD2
-
-getEsfAlignment	KEYWORD2
-getESFALG	KEYWORD2
-setAutoESFALG	KEYWORD2
-setAutoESFALGrate	KEYWORD2
-setAutoESFALGcallback	KEYWORD2
-assumeAutoESFALG	KEYWORD2
-initPacketUBXESFALG	KEYWORD2
-flushESFALG	KEYWORD2
-logESFALG	KEYWORD2
-
-getEsfInfo	KEYWORD2
-getESFSTATUS	KEYWORD2
-setAutoESFSTATUS	KEYWORD2
-setAutoESFSTATUSrate	KEYWORD2
-setAutoESFSTATUScallback	KEYWORD2
-assumeAutoESFSTATUS	KEYWORD2
-initPacketUBXESFSTATUS	KEYWORD2
-flushESFSTATUS	KEYWORD2
-logESFSTATUS	KEYWORD2
-
-getEsfIns	KEYWORD2
-getESFINS	KEYWORD2
-setAutoESFINS	KEYWORD2
-setAutoESFINSrate	KEYWORD2
-setAutoESFINScallback	KEYWORD2
-assumeAutoESFINS	KEYWORD2
-initPacketUBXESFINS	KEYWORD2
-flushESFINS	KEYWORD2
-logESFINS	KEYWORD2
-
-getEsfDataInfo	KEYWORD2
-getESFMEAS	KEYWORD2
-setAutoESFMEAS	KEYWORD2
-setAutoESFMEASrate	KEYWORD2
-setAutoESFMEAScallback	KEYWORD2
-assumeAutoESFMEAS	KEYWORD2
-initPacketUBXESFMEAS	KEYWORD2
-flushESFMEAS	KEYWORD2
-logESFMEAS	KEYWORD2
-
-getEsfRawDataInfo	KEYWORD2
-getESFRAW	KEYWORD2
-setAutoESFRAW	KEYWORD2
-setAutoESFRAWrate	KEYWORD2
-setAutoESFRAWcallback	KEYWORD2
-assumeAutoESFRAW	KEYWORD2
-initPacketUBXESFRAW	KEYWORD2
-flushESFRAW	KEYWORD2
-logESFRAW	KEYWORD2
-
-getHNRAtt	KEYWORD2
-getHNRATT	KEYWORD2
-setAutoHNRATT	KEYWORD2
-setAutoHNRATTrate	KEYWORD2
-setAutoHNRATTcallback	KEYWORD2
-assumeAutoHNRATT	KEYWORD2
-initPacketUBXHNRATT	KEYWORD2
-flushHNRATT	KEYWORD2
-logHNRATT	KEYWORD2
-
-getHNRDyn	KEYWORD2
-getHNRINS	KEYWORD2
-setAutoHNRINS	KEYWORD2
-setAutoHNRINSrate	KEYWORD2
-setAutoHNRINScallback	KEYWORD2
-assumeAutoHNRINS	KEYWORD2
-initPacketUBXHNRINS	KEYWORD2
-flushHNRINS	KEYWORD2
-logHNRINS	KEYWORD2
-
-getHNRPVT	KEYWORD2
-setAutoHNRPVT	KEYWORD2
-setAutoHNRPVTrate	KEYWORD2
-setAutoHNRPVTcallback	KEYWORD2
-assumeAutoHNRPVT	KEYWORD2
-initPacketUBXHNRPVT	KEYWORD2
-flushHNRPVT	KEYWORD2
-logHNRPVT	KEYWORD2
-
-setNavigationFrequency	KEYWORD2
-getNavigationFrequency	KEYWORD2
-setMeasurementRate	KEYWORD2
-getMeasurementRate	KEYWORD2
-setNavigationRate	KEYWORD2
-getNavigationRate	KEYWORD2
-
-getGeometricDOP	KEYWORD2
-getPositionDOP	KEYWORD2
-getTimeDOP	KEYWORD2
-getVerticalDOP	KEYWORD2
-getHorizontalDOP	KEYWORD2
-getNorthingDOP	KEYWORD2
-getEastingDOP	KEYWORD2
-
-getATTroll	KEYWORD2
-getATTpitch	KEYWORD2
-getATTheading	KEYWORD2
-
-getTimeOfWeek	KEYWORD2
-getYear	KEYWORD2
-getMonth	KEYWORD2
-getDay	KEYWORD2
-getHour	KEYWORD2
-getMinute	KEYWORD2
-getSecond	KEYWORD2
-getMillisecond	KEYWORD2
-getNanosecond	KEYWORD2
-getUnixEpoch	KEYWORD2
-getDateValid	KEYWORD2
-getTimeValid	KEYWORD2
-getConfirmedDate	KEYWORD2
-getConfirmedTime	KEYWORD2
-getFixType	KEYWORD2
-getGnssFixOk	KEYWORD2
-getDiffSoln	KEYWORD2
-getHeadVehValid	KEYWORD2
-getCarrierSolutionType	KEYWORD2
-getSIV	KEYWORD2
-getLongitude	KEYWORD2
-getLatitude	KEYWORD2
-getAltitude	KEYWORD2
-getAltitudeMSL	KEYWORD2
-getHorizontalAccEst	KEYWORD2
-getVerticalAccEst	KEYWORD2
-getNedNorthVel	KEYWORD2
-getNedEastVel	KEYWORD2
-getNedDownVel	KEYWORD2
-getGroundSpeed	KEYWORD2
-getHeading	KEYWORD2
-getSpeedAccEst	KEYWORD2
-getHeadingAccEst	KEYWORD2
-getPDOP	KEYWORD2
-getInvalidLlh	KEYWORD2
-getHeadVeh	KEYWORD2
-getMagDec	KEYWORD2
-getMagAcc	KEYWORD2
-getHeadVehValid	KEYWORD2
-
-getPositionAccuracy	KEYWORD2
-
-getTimeOfWeekFromHPPOSLLH	KEYWORD2
-getHighResLongitude	KEYWORD2
-getHighResLatitude	KEYWORD2
-getElipsoid	KEYWORD2
-getMeanSeaLevel	KEYWORD2
-getHighResLongitudeHp	KEYWORD2
-getHighResLatitudeHp	KEYWORD2
-getElipsoidHp	KEYWORD2
-getMeanSeaLevelHp	KEYWORD2
-getHorizontalAccuracy	KEYWORD2
-getVerticalAccuracy	KEYWORD2
-
-getSurveyInActive	KEYWORD2
-getSurveyInValid	KEYWORD2
-getSurveyInObservationTime	KEYWORD2
-getSurveyInMeanAccuracy	KEYWORD2
-
-getRelPosN	KEYWORD2
-getRelPosE	KEYWORD2
-getRelPosD	KEYWORD2
-getRelPosAccN	KEYWORD2
-getRelPosAccE	KEYWORD2
-getRelPosAccD	KEYWORD2
-
-getESFroll	KEYWORD2
-getESFpitch	KEYWORD2
-getESFyaw	KEYWORD2
-getSensorFusionMeasurement	KEYWORD2
-getRawSensorMeasurement	KEYWORD2
-getSensorFusionStatus	KEYWORD2
-
-setHNRNavigationRate	KEYWORD2
-getHNRNavigationRate	KEYWORD2
-getHNRroll	KEYWORD2
-getHNRpitch	KEYWORD2
-getHNRheading	KEYWORD2
-
-extractLong	KEYWORD2
-extractSignedLong	KEYWORD2
-extractInt	KEYWORD2
-extractSignedInt	KEYWORD2
-extractByte	KEYWORD2
-extractSignedChar	KEYWORD2
-
-#######################################
-# Constants (LITERAL1)
-#######################################
-
-SFE_UBLOX_STATUS_SUCCESS	LITERAL1
-SFE_UBLOX_STATUS_FAIL	LITERAL1
-SFE_UBLOX_STATUS_CRC_FAIL	LITERAL1
-SFE_UBLOX_STATUS_TIMEOUT	LITERAL1
-SFE_UBLOX_STATUS_COMMAND_NACK	LITERAL1
-SFE_UBLOX_STATUS_OUT_OF_RANGE	LITERAL1
-SFE_UBLOX_STATUS_INVALID_ARG	LITERAL1
-SFE_UBLOX_STATUS_INVALID_OPERATION	LITERAL1
-SFE_UBLOX_STATUS_MEM_ERR	LITERAL1
-SFE_UBLOX_STATUS_HW_ERR	LITERAL1
-SFE_UBLOX_STATUS_DATA_SENT	LITERAL1
-SFE_UBLOX_STATUS_DATA_RECEIVED	LITERAL1
-SFE_UBLOX_STATUS_I2C_COMM_FAILURE	LITERAL1
-SFE_UBLOX_STATUS_DATA_OVERWRITTEN	LITERAL1
-
-COM_TYPE_UBX	LITERAL1
-COM_TYPE_NMEA	LITERAL1
-COM_TYPE_RTCM3	LITERAL1
-
-COM_PORT_I2C	LITERAL1
-COM_PORT_UART1	LITERAL1
-COM_PORT_UART2	LITERAL1
-COM_PORT_USB	LITERAL1
-COM_PORT_SPI	LITERAL1
-
-UBX_CLASS_NAV	LITERAL1
-UBX_CLASS_RXM	LITERAL1
-UBX_CLASS_INF	LITERAL1
-UBX_CLASS_ACK	LITERAL1
-UBX_CLASS_CFG	LITERAL1
-UBX_CLASS_UPD	LITERAL1
-UBX_CLASS_MON	LITERAL1
-UBX_CLASS_AID	LITERAL1
-UBX_CLASS_TIM	LITERAL1
-UBX_CLASS_ESF	LITERAL1
-UBX_CLASS_MGA	LITERAL1
-UBX_CLASS_LOG	LITERAL1
-UBX_CLASS_SEC	LITERAL1
-UBX_CLASS_HNR	LITERAL1
-UBX_CLASS_NMEA	LITERAL1
-
-UBX_NMEA_MSB	LITERAL1
-UBX_NMEA_DTM	LITERAL1
-UBX_NMEA_GAQ	LITERAL1
-UBX_NMEA_GBQ	LITERAL1
-UBX_NMEA_GBS	LITERAL1
-UBX_NMEA_GGA	LITERAL1
-UBX_NMEA_GLL	LITERAL1
-UBX_NMEA_GLQ	LITERAL1
-UBX_NMEA_GNQ	LITERAL1
-UBX_NMEA_GNS	LITERAL1
-UBX_NMEA_GPQ	LITERAL1
-UBX_NMEA_GRS	LITERAL1
-UBX_NMEA_GSA	LITERAL1
-UBX_NMEA_GST	LITERAL1
-UBX_NMEA_GSV	LITERAL1
-UBX_NMEA_RMC	LITERAL1
-UBX_NMEA_TXT	LITERAL1
-UBX_NMEA_VLW	LITERAL1
-UBX_NMEA_VTG	LITERAL1
-UBX_NMEA_ZDA	LITERAL1
-
-UBX_NAV_ATT	LITERAL1
-UBX_NAV_CLOCK	LITERAL1
-UBX_NAV_DOP	LITERAL1
-UBX_NAV_GEOFENCE	LITERAL1
-UBX_NAV_HPPOSECEF	LITERAL1
-UBX_NAV_HPPOSLLH	LITERAL1
-UBX_NAV_ODO	LITERAL1
-UBX_NAV_POSECEF	LITERAL1
-UBX_NAV_PVT	LITERAL1
-UBX_NAV_RELPOSNED	LITERAL1
-UBX_NAV_RESETODO	LITERAL1
-UBX_NAV_STATUS	LITERAL1
-UBX_NAV_SVIN	LITERAL1
-UBX_NAV_VELECEF	LITERAL1
-UBX_NAV_VELNED	LITERAL1
-
-UBX_RXM_RAWX	LITERAL1
-UBX_RXM_SFRBX	LITERAL1
-
-UBX_TIM_TM2	LITERAL1
-
-UBX_RTCM_MSB	LITERAL1
-UBX_RTCM_1005	LITERAL1
-UBX_RTCM_1074	LITERAL1
-UBX_RTCM_1077	LITERAL1
-UBX_RTCM_1084	LITERAL1
-UBX_RTCM_1087	LITERAL1
-UBX_RTCM_1094	LITERAL1
-UBX_RTCM_1097	LITERAL1
-UBX_RTCM_1124	LITERAL1
-UBX_RTCM_1127	LITERAL1
-UBX_RTCM_1230	LITERAL1
-UBX_RTCM_4072_0	LITERAL1
-UBX_RTCM_4072_1	LITERAL1
-
-UBX_ESF_MEAS	LITERAL1
-UBX_ESF_RAW	LITERAL1
-UBX_ESF_STATUS	LITERAL1
-UBX_ESF_ALG	LITERAL1
-UBX_ESF_INS	LITERAL1
-
-VAL_CFG_SUBSEC_IOPORT	LITERAL1
-VAL_CFG_SUBSEC_MSGCONF	LITERAL1
-VAL_CFG_SUBSEC_INFMSG	LITERAL1
-VAL_CFG_SUBSEC_NAVCONF	LITERAL1
-VAL_CFG_SUBSEC_RXMCONF	LITERAL1
-VAL_CFG_SUBSEC_SENCONF	LITERAL1
-VAL_CFG_SUBSEC_RINVCONF	LITERAL1
-VAL_CFG_SUBSEC_ANTCONF	LITERAL1
-VAL_CFG_SUBSEC_LOGCONF	LITERAL1
-VAL_CFG_SUBSEC_FTSCONF	LITERAL1
-
-DYN_MODEL_PORTABLE	LITERAL1
-DYN_MODEL_STATIONARY	LITERAL1
-DYN_MODEL_PEDESTRIAN	LITERAL1
-DYN_MODEL_AUTOMOTIVE	LITERAL1
-DYN_MODEL_SEA	LITERAL1
-DYN_MODEL_AIRBORNE1g	LITERAL1
-DYN_MODEL_AIRBORNE2g	LITERAL1
-DYN_MODEL_AIRBORNE4g	LITERAL1
-DYN_MODEL_WRIST	LITERAL1
-DYN_MODEL_BIKE	LITERAL1
-DYN_MODEL_UNKNOWN	LITERAL1
-
-SFE_UBLOX_GNSS_ID_GPS	LITERAL1
-SFE_UBLOX_GNSS_ID_SBAS	LITERAL1
-SFE_UBLOX_GNSS_ID_GALILEO	LITERAL1
-SFE_UBLOX_GNSS_ID_BEIDOU	LITERAL1
-SFE_UBLOX_GNSS_ID_IMES	LITERAL1
-SFE_UBLOX_GNSS_ID_QZSS	LITERAL1
-SFE_UBLOX_GNSS_ID_GLONASS	LITERAL1
-
-DAYS_SINCE_MONTH	LITERAL1
diff --git a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/library.properties b/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/library.properties
deleted file mode 100644
index 1e27608..0000000
--- a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/library.properties
+++ /dev/null
@@ -1,9 +0,0 @@
-name=SparkFun u-blox GNSS Arduino Library
-version=2.0.5
-author=SparkFun Electronics <techsupport@sparkfun.com>
-maintainer=SparkFun Electronics <sparkfun.com>
-sentence=Library for I2C and Serial Communication with u-blox GNSS modules<br/><br/>
-paragraph=An Arduino Library to enable both I2C and Serial communication for both NMEA reception and binary UBX sending to u-blox modules. Useful for interfacing to the <a href="https://www.sparkfun.com/products/15136">SparkFun GPS-RTK2</a> ZED-F9P, <a href="https://www.sparkfun.com/products/15005">SparkFun GPS-RTK</a> NEO-M8P-2, the <a href="https://www.sparkfun.com/products/15210">SparkFun SAM-M8Q</a>, and the <a href="https://www.sparkfun.com/products/15193">SparkFun ZOE-M8Q</a>. Library also works with other u-blox based boards.<br/><br/>The ZED-F9P and NEO-M8P-2 modules are top-of-the-line modules for high accuracy GNSS and GPS location solutions including RTK. The ZED-F9P is unique in that it is capable of both rover and base station operations allowing the module to become a base station and produce RTCM 3.x correction data.<br/>
-category=Sensors
-url=https://github.com/sparkfun/SparkFun_u-blox_GNSS_Arduino_Library
-architectures=*
diff --git a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/src/SparkFun_u-blox_GNSS_Arduino_Library.cpp b/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/src/SparkFun_u-blox_GNSS_Arduino_Library.cpp
deleted file mode 100644
index 2f71233..0000000
--- a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/src/SparkFun_u-blox_GNSS_Arduino_Library.cpp
+++ /dev/null
@@ -1,10502 +0,0 @@
-/*
-	This is a library written for the u-blox ZED-F9P and NEO-M8P-2
-	SparkFun sells these at its website: www.sparkfun.com
-	Do you like this library? Help support SparkFun. Buy a board!
-	https://www.sparkfun.com/products/16481
-	https://www.sparkfun.com/products/15136
-	https://www.sparkfun.com/products/15005
-	https://www.sparkfun.com/products/15733
-	https://www.sparkfun.com/products/15193
-	https://www.sparkfun.com/products/15210
-
-  Original version by Nathan Seidle @ SparkFun Electronics, September 6th, 2018
-	v2.0 rework by Paul Clark @ SparkFun Electronics, December 31st, 2020
-
-	This library handles configuring and handling the responses
-	from a u-blox GPS module. Works with most modules from u-blox including
-	the Zed-F9P, NEO-M8P-2, NEO-M9N, ZOE-M8Q, SAM-M8Q, and many others.
-
-	https://github.com/sparkfun/SparkFun_Ublox_Arduino_Library
-
-	Development environment specifics:
-	Arduino IDE 1.8.13
-
-	SparkFun code, firmware, and software is released under the MIT License(http://opensource.org/licenses/MIT).
-	The MIT License (MIT)
-	Copyright (c) 2016 SparkFun Electronics
-	Permission is hereby granted, free of charge, to any person obtaining a copy of this software and
-	associated documentation files (the "Software"), to deal in the Software without restriction,
-	including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
-	and/or sell copies of the Software, and to permit persons to whom the Software is furnished to
-	do so, subject to the following conditions:
-
-	The above copyright notice and this permission notice shall be included in all copies or substantial
-	portions of the Software.
-
-	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT
-	NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
-	IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
-	WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
-	SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-*/
-
-#include "SparkFun_u-blox_GNSS_Arduino_Library.h"
-
-SFE_UBLOX_GNSS::SFE_UBLOX_GNSS(void)
-{
-  // Constructor
-  if (debugPin >= 0)
-  {
-    pinMode((uint8_t)debugPin, OUTPUT);
-    digitalWrite((uint8_t)debugPin, HIGH);
-  }
-}
-
-//Stop all automatic message processing. Free all used RAM
-void SFE_UBLOX_GNSS::end(void)
-{
-  //Note: payloadCfg is not deleted
-
-  //Note: payloadAuto is not deleted
-
-  if (ubxFileBuffer != NULL)  // Check if RAM has been allocated for the file buffer
-  {
-    if (_printDebug == true)
-    {
-      _debugSerial->println(F("end: the file buffer has been deleted. You will need to call setFileBufferSize before .begin to create a new one."));
-    }
-    delete[] ubxFileBuffer;
-    ubxFileBuffer = NULL; // Redundant?
-    fileBufferSize = 0; // Reset file buffer size. User will have to call setFileBufferSize again
-    fileBufferMaxAvail = 0;
-  }
-
-  if (moduleSWVersion != NULL)
-  {
-    delete[] moduleSWVersion;
-    moduleSWVersion = NULL; // Redundant?
-  }
-
-  if (currentGeofenceParams != NULL)
-  {
-    delete[] currentGeofenceParams;
-    currentGeofenceParams = NULL; // Redundant?
-  }
-  
-  if (packetUBXNAVPOSECEF != NULL)
-  {
-    if (packetUBXNAVPOSECEF->callbackData != NULL)
-    {
-      delete[] packetUBXNAVPOSECEF->callbackData;
-    }
-    delete[] packetUBXNAVPOSECEF;
-    packetUBXNAVPOSECEF = NULL; // Redundant?  
-  }
-
-  if (packetUBXNAVSTATUS != NULL)
-  {
-    if (packetUBXNAVSTATUS->callbackData != NULL)
-    {
-      delete[] packetUBXNAVSTATUS->callbackData;
-    }
-    delete[] packetUBXNAVSTATUS;
-    packetUBXNAVSTATUS = NULL; // Redundant?  
-  }
-
-  if (packetUBXNAVDOP != NULL)
-  {
-    if (packetUBXNAVDOP->callbackData != NULL)
-    {
-      delete[] packetUBXNAVDOP->callbackData;
-    }
-    delete[] packetUBXNAVDOP;
-    packetUBXNAVDOP = NULL; // Redundant?  
-  }
-
-  if (packetUBXNAVATT != NULL)
-  {
-    if (packetUBXNAVATT->callbackData != NULL)
-    {
-      delete[] packetUBXNAVATT->callbackData;
-    }
-    delete[] packetUBXNAVATT;
-    packetUBXNAVATT = NULL; // Redundant?  
-  }
-
-  if (packetUBXNAVPVT != NULL)
-  {
-    if (packetUBXNAVPVT->callbackData != NULL)
-    {
-      delete[] packetUBXNAVPVT->callbackData;
-      if (_printDebug == true)
-      {
-        _debugSerial->println(F("end: packetUBXNAVPVT->callbackData has been deleted"));
-      }
-    }
-    delete[] packetUBXNAVPVT;
-    packetUBXNAVPVT = NULL; // Redundant?  
-    if (_printDebug == true)
-    {
-      _debugSerial->println(F("end: packetUBXNAVPVT has been deleted"));
-    }
-  }
-
-  if (packetUBXNAVODO != NULL)
-  {
-    if (packetUBXNAVODO->callbackData != NULL)
-    {
-      delete[] packetUBXNAVODO->callbackData;
-    }
-    delete[] packetUBXNAVODO;
-    packetUBXNAVODO = NULL; // Redundant?  
-  }
-
-  if (packetUBXNAVVELECEF != NULL)
-  {
-    if (packetUBXNAVVELECEF->callbackData != NULL)
-    {
-      delete[] packetUBXNAVVELECEF->callbackData;
-    }
-    delete[] packetUBXNAVVELECEF;
-    packetUBXNAVVELECEF = NULL; // Redundant?  
-  }
-
-  if (packetUBXNAVVELNED != NULL)
-  {
-    if (packetUBXNAVVELNED->callbackData != NULL)
-    {
-      delete[] packetUBXNAVVELNED->callbackData;
-    }
-    delete[] packetUBXNAVVELNED;
-    packetUBXNAVVELNED = NULL; // Redundant?  
-  }
-
-  if (packetUBXNAVHPPOSECEF != NULL)
-  {
-    if (packetUBXNAVHPPOSECEF->callbackData != NULL)
-    {
-      delete[] packetUBXNAVHPPOSECEF->callbackData;
-    }
-    delete[] packetUBXNAVHPPOSECEF;
-    packetUBXNAVHPPOSECEF = NULL; // Redundant?  
-  }
-
-  if (packetUBXNAVHPPOSLLH != NULL)
-  {
-    if (packetUBXNAVHPPOSLLH->callbackData != NULL)
-    {
-      delete[] packetUBXNAVHPPOSLLH->callbackData;
-    }
-    delete[] packetUBXNAVHPPOSLLH;
-    packetUBXNAVHPPOSLLH = NULL; // Redundant?  
-  }
-
-  if (packetUBXNAVCLOCK != NULL)
-  {
-    if (packetUBXNAVCLOCK->callbackData != NULL)
-    {
-      delete[] packetUBXNAVCLOCK->callbackData;
-    }
-    delete[] packetUBXNAVCLOCK;
-    packetUBXNAVCLOCK = NULL; // Redundant?  
-  }
-
-  if (packetUBXNAVSVIN != NULL)
-  {
-    if (packetUBXNAVSVIN->callbackData != NULL)
-    {
-      delete[] packetUBXNAVSVIN->callbackData;
-    }
-    delete[] packetUBXNAVSVIN;
-    packetUBXNAVSVIN = NULL; // Redundant?  
-  }
-
-  if (packetUBXNAVRELPOSNED != NULL)
-  {
-    if (packetUBXNAVRELPOSNED->callbackData != NULL)
-    {
-      delete[] packetUBXNAVRELPOSNED->callbackData;
-    }
-    delete[] packetUBXNAVRELPOSNED;
-    packetUBXNAVRELPOSNED = NULL; // Redundant?  
-  }
-
-  if (packetUBXRXMSFRBX != NULL)
-  {
-    if (packetUBXRXMSFRBX->callbackData != NULL)
-    {
-      delete[] packetUBXRXMSFRBX->callbackData;
-    }
-    delete[] packetUBXRXMSFRBX;
-    packetUBXRXMSFRBX = NULL; // Redundant?  
-  }
-
-  if (packetUBXRXMRAWX != NULL)
-  {
-    if (packetUBXRXMRAWX->callbackData != NULL)
-    {
-      delete[] packetUBXRXMRAWX->callbackData;
-    }
-    delete[] packetUBXRXMRAWX;
-    packetUBXRXMRAWX = NULL; // Redundant?  
-  }
-
-  if (packetUBXCFGRATE != NULL)
-  {
-    if (packetUBXCFGRATE->callbackData != NULL)
-    {
-      delete[] packetUBXCFGRATE->callbackData;
-    }
-    delete[] packetUBXCFGRATE;
-    packetUBXCFGRATE = NULL; // Redundant?  
-  }
-
-  if (packetUBXTIMTM2 != NULL)
-  {
-    if (packetUBXTIMTM2->callbackData != NULL)
-    {
-      delete[] packetUBXTIMTM2->callbackData;
-    }
-    delete[] packetUBXTIMTM2;
-    packetUBXTIMTM2 = NULL; // Redundant?  
-  }
-
-  if (packetUBXESFALG != NULL)
-  {
-    if (packetUBXESFALG->callbackData != NULL)
-    {
-      delete[] packetUBXESFALG->callbackData;
-    }
-    delete[] packetUBXESFALG;
-    packetUBXESFALG = NULL; // Redundant?  
-  }
-
-  if (packetUBXESFSTATUS != NULL)
-  {
-    if (packetUBXESFSTATUS->callbackData != NULL)
-    {
-      delete[] packetUBXESFSTATUS->callbackData;
-    }
-    delete[] packetUBXESFSTATUS;
-    packetUBXESFSTATUS = NULL; // Redundant?  
-  }
-
-  if (packetUBXESFINS != NULL)
-  {
-    if (packetUBXESFINS->callbackData != NULL)
-    {
-      delete[] packetUBXESFINS->callbackData;
-    }
-    delete[] packetUBXESFINS;
-    packetUBXESFINS = NULL; // Redundant?  
-  }
-
-  if (packetUBXESFMEAS != NULL)
-  {
-    if (packetUBXESFMEAS->callbackData != NULL)
-    {
-      delete[] packetUBXESFMEAS->callbackData;
-    }
-    delete[] packetUBXESFMEAS;
-    packetUBXESFMEAS = NULL; // Redundant?  
-  }
-
-  if (packetUBXESFRAW != NULL)
-  {
-    if (packetUBXESFRAW->callbackData != NULL)
-    {
-      delete[] packetUBXESFRAW->callbackData;
-    }
-    delete[] packetUBXESFRAW;
-    packetUBXESFRAW = NULL; // Redundant?  
-  }
-
-  if (packetUBXHNRATT != NULL)
-  {
-    if (packetUBXHNRATT->callbackData != NULL)
-    {
-      delete[] packetUBXHNRATT->callbackData;
-    }
-    delete[] packetUBXHNRATT;
-    packetUBXHNRATT = NULL; // Redundant?  
-  }
-
-  if (packetUBXHNRINS != NULL)
-  {
-    if (packetUBXHNRINS->callbackData != NULL)
-    {
-      delete[] packetUBXHNRINS->callbackData;
-    }
-    delete[] packetUBXHNRINS;
-    packetUBXHNRINS = NULL; // Redundant?  
-  }
-
-  if (packetUBXHNRPVT != NULL)
-  {
-    if (packetUBXHNRPVT->callbackData != NULL)
-    {
-      delete[] packetUBXHNRPVT->callbackData;
-    }
-    delete[] packetUBXHNRPVT;
-    packetUBXHNRPVT = NULL; // Redundant?  
-  }
-
-}
-
-//Allow the user to change packetCfgPayloadSize. Handy if you want to process big messages like RAWX
-//This can be called before .begin if required / desired
-void SFE_UBLOX_GNSS::setPacketCfgPayloadSize(size_t payloadSize)
-{
-  if ((payloadSize == 0) && (payloadCfg != NULL))
-  {
-    // Zero payloadSize? Dangerous! But we'll free the memory anyway...
-    delete[] payloadCfg;
-    payloadCfg = NULL; // Redundant?
-    packetCfg.payload = payloadCfg;
-    if ((_printDebug == true) || (_printLimitedDebug == true)) // This is important. Print this if doing limited debugging
-      _debugSerial->println(F("setPacketCfgPayloadSize: Zero payloadSize!"));
-  }
-
-  else if (payloadCfg == NULL) //Memory has not yet been allocated - so use new
-  {
-    payloadCfg = new uint8_t[payloadSize];
-    packetCfg.payload = payloadCfg;
-    if (payloadCfg == NULL)
-      if ((_printDebug == true) || (_printLimitedDebug == true)) // This is important. Print this if doing limited debugging
-        _debugSerial->println(F("setPacketCfgPayloadSize: PANIC! RAM allocation failed!"));
-  }
-
-  else //Memory has already been allocated - so resize
-  {
-    uint8_t *newPayload = new uint8_t[payloadSize];
-    for (size_t i = 0; (i < payloadSize) && (i < packetCfgPayloadSize); i++) // Copy as much existing data as we can
-      newPayload[i] = payloadCfg[i];
-    delete[] payloadCfg;
-    payloadCfg = newPayload;
-    packetCfg.payload = payloadCfg;
-    if (payloadCfg == NULL)
-      if ((_printDebug == true) || (_printLimitedDebug == true)) // This is important. Print this if doing limited debugging
-        _debugSerial->println(F("setPacketCfgPayloadSize: PANIC! RAM resize failed!"));
-  }
-
-  packetCfgPayloadSize = payloadSize;
-}
-
-//Initialize the I2C port
-boolean SFE_UBLOX_GNSS::begin(TwoWire &wirePort, uint8_t deviceAddress)
-{
-  commType = COMM_TYPE_I2C;
-  _i2cPort = &wirePort; //Grab which port the user wants us to use
-
-  //We expect caller to begin their I2C port, with the speed of their choice external to the library
-  //But if they forget, we start the hardware here.
-
-  //We're moving away from the practice of starting Wire hardware in a library. This is to avoid cross platform issues.
-  //ie, there are some platforms that don't handle multiple starts to the wire hardware. Also, every time you start the wire
-  //hardware the clock speed reverts back to 100kHz regardless of previous Wire.setClocks().
-  //_i2cPort->begin();
-
-  _gpsI2Caddress = deviceAddress; //Store the I2C address from user
-
-  //New in v2.0: allocate memory for the packetCfg payload here - if required. (The user may have called setPacketCfgPayloadSize already)
-  if (packetCfgPayloadSize == 0)
-    setPacketCfgPayloadSize(MAX_PAYLOAD_SIZE);
-
-  //New in v2.0: allocate memory for the file buffer - if required. (The user should have called setFileBufferSize already)
-  createFileBuffer();
-
-  // Call isConnected up to three times - tests on the NEO-M8U show the CFG RATE poll occasionally being ignored
-  boolean connected = isConnected();
-
-  if (!connected)
-    connected = isConnected();
-
-  if (!connected)
-    connected = isConnected();
-
-  return (connected);
-}
-
-//Initialize the Serial port
-boolean SFE_UBLOX_GNSS::begin(Stream &serialPort)
-{
-  commType = COMM_TYPE_SERIAL;
-  _serialPort = &serialPort; //Grab which port the user wants us to use
-
-  //New in v2.0: allocate memory for the packetCfg payload here - if required. (The user may have called setPacketCfgPayloadSize already)
-  if (packetCfgPayloadSize == 0)
-    setPacketCfgPayloadSize(MAX_PAYLOAD_SIZE);
-
-  //New in v2.0: allocate memory for the file buffer - if required. (The user should have called setFileBufferSize already)
-  createFileBuffer();
-
-  // Call isConnected up to three times - tests on the NEO-M8U show the CFG RATE poll occasionally being ignored
-  boolean connected = isConnected();
-
-  if (!connected)
-    connected = isConnected();
-
-  if (!connected)
-    connected = isConnected();
-
-  return (connected);
-}
-
-// Allow the user to change I2C polling wait (the minimum interval between I2C data requests - to avoid pounding the bus)
-// i2cPollingWait defaults to 100ms and is adjusted automatically when setNavigationFrequency()
-// or setHNRNavigationRate() are called. But if the user is using callbacks, it might be advantageous
-// to be able to set the polling wait manually.
-void SFE_UBLOX_GNSS::setI2CpollingWait(uint8_t newPollingWait_ms)
-{
-  i2cPollingWait = newPollingWait_ms;
-}
-
-//Sets the global size for I2C transactions
-//Most platforms use 32 bytes (the default) but this allows users to increase the transaction
-//size if the platform supports it
-//Note: If the transaction size is set larger than the platforms buffer size, bad things will happen.
-void SFE_UBLOX_GNSS::setI2CTransactionSize(uint8_t transactionSize)
-{
-  i2cTransactionSize = transactionSize;
-}
-uint8_t SFE_UBLOX_GNSS::getI2CTransactionSize(void)
-{
-  return (i2cTransactionSize);
-}
-
-//Returns true if I2C device ack's
-boolean SFE_UBLOX_GNSS::isConnected(uint16_t maxWait)
-{
-  if (commType == COMM_TYPE_I2C)
-  {
-    _i2cPort->beginTransmission((uint8_t)_gpsI2Caddress);
-    if (_i2cPort->endTransmission() != 0)
-      return false; //Sensor did not ack
-  }
-
-  // Query navigation rate to see whether we get a meaningful response
-  return (getNavigationFrequencyInternal(maxWait));
-}
-
-//Enable or disable the printing of sent/response HEX values.
-//Use this in conjunction with 'Transport Logging' from the Universal Reader Assistant to see what they're doing that we're not
-void SFE_UBLOX_GNSS::enableDebugging(Stream &debugPort, boolean printLimitedDebug)
-{
-  _debugSerial = &debugPort; //Grab which port the user wants us to use for debugging
-  if (printLimitedDebug == false)
-  {
-    _printDebug = true; //Should we print the commands we send? Good for debugging
-  }
-  else
-  {
-    _printLimitedDebug = true; //Should we print limited debug messages? Good for debugging high navigation rates
-  }
-}
-void SFE_UBLOX_GNSS::disableDebugging(void)
-{
-  _printDebug = false; //Turn off extra print statements
-  _printLimitedDebug = false;
-}
-
-//Safely print messages
-void SFE_UBLOX_GNSS::debugPrint(char *message)
-{
-  if (_printDebug == true)
-  {
-    _debugSerial->print(message);
-  }
-}
-//Safely print messages
-void SFE_UBLOX_GNSS::debugPrintln(char *message)
-{
-  if (_printDebug == true)
-  {
-    _debugSerial->println(message);
-  }
-}
-
-const char *SFE_UBLOX_GNSS::statusString(sfe_ublox_status_e stat)
-{
-  switch (stat)
-  {
-  case SFE_UBLOX_STATUS_SUCCESS:
-    return "Success";
-    break;
-  case SFE_UBLOX_STATUS_FAIL:
-    return "General Failure";
-    break;
-  case SFE_UBLOX_STATUS_CRC_FAIL:
-    return "CRC Fail";
-    break;
-  case SFE_UBLOX_STATUS_TIMEOUT:
-    return "Timeout";
-    break;
-  case SFE_UBLOX_STATUS_COMMAND_NACK:
-    return "Command not acknowledged (NACK)";
-    break;
-  case SFE_UBLOX_STATUS_OUT_OF_RANGE:
-    return "Out of range";
-    break;
-  case SFE_UBLOX_STATUS_INVALID_ARG:
-    return "Invalid Arg";
-    break;
-  case SFE_UBLOX_STATUS_INVALID_OPERATION:
-    return "Invalid operation";
-    break;
-  case SFE_UBLOX_STATUS_MEM_ERR:
-    return "Memory Error";
-    break;
-  case SFE_UBLOX_STATUS_HW_ERR:
-    return "Hardware Error";
-    break;
-  case SFE_UBLOX_STATUS_DATA_SENT:
-    return "Data Sent";
-    break;
-  case SFE_UBLOX_STATUS_DATA_RECEIVED:
-    return "Data Received";
-    break;
-  case SFE_UBLOX_STATUS_I2C_COMM_FAILURE:
-    return "I2C Comm Failure";
-    break;
-  case SFE_UBLOX_STATUS_DATA_OVERWRITTEN:
-    return "Data Packet Overwritten";
-    break;
-  default:
-    return "Unknown Status";
-    break;
-  }
-  return "None";
-}
-
-// Check for the arrival of new I2C/Serial data
-
-//Allow the user to disable the "7F" check (e.g.) when logging RAWX data
-void SFE_UBLOX_GNSS::disableUBX7Fcheck(boolean disabled)
-{
-  ubx7FcheckDisabled = disabled;
-}
-
-//Called regularly to check for available bytes on the user' specified port
-boolean SFE_UBLOX_GNSS::checkUblox(uint8_t requestedClass, uint8_t requestedID)
-{
-  return checkUbloxInternal(&packetCfg, requestedClass, requestedID);
-}
-
-//PRIVATE: Called regularly to check for available bytes on the user' specified port
-boolean SFE_UBLOX_GNSS::checkUbloxInternal(ubxPacket *incomingUBX, uint8_t requestedClass, uint8_t requestedID)
-{
-  if (commType == COMM_TYPE_I2C)
-    return (checkUbloxI2C(incomingUBX, requestedClass, requestedID));
-  else if (commType == COMM_TYPE_SERIAL)
-    return (checkUbloxSerial(incomingUBX, requestedClass, requestedID));
-  return false;
-}
-
-//Polls I2C for data, passing any new bytes to process()
-//Returns true if new bytes are available
-boolean SFE_UBLOX_GNSS::checkUbloxI2C(ubxPacket *incomingUBX, uint8_t requestedClass, uint8_t requestedID)
-{
-  if (millis() - lastCheck >= i2cPollingWait)
-  {
-    //Get the number of bytes available from the module
-    uint16_t bytesAvailable = 0;
-    _i2cPort->beginTransmission(_gpsI2Caddress);
-    _i2cPort->write(0xFD);                     //0xFD (MSB) and 0xFE (LSB) are the registers that contain number of bytes available
-    if (_i2cPort->endTransmission(false) != 0) //Send a restart command. Do not release bus.
-      return (false);                          //Sensor did not ACK
-
-    _i2cPort->requestFrom((uint8_t)_gpsI2Caddress, (uint8_t)2);
-    if (_i2cPort->available())
-    {
-      uint8_t msb = _i2cPort->read();
-      uint8_t lsb = _i2cPort->read();
-      if (lsb == 0xFF)
-      {
-        //I believe this is a u-blox bug. Device should never present an 0xFF.
-        if ((_printDebug == true) || (_printLimitedDebug == true)) // This is important. Print this if doing limited debugging
-        {
-          _debugSerial->println(F("checkUbloxI2C: u-blox bug, length lsb is 0xFF"));
-        }
-        if (debugPin >= 0)
-        {
-          digitalWrite((uint8_t)debugPin, LOW);
-          delay(10);
-          digitalWrite((uint8_t)debugPin, HIGH);
-        }
-        lastCheck = millis(); //Put off checking to avoid I2C bus traffic
-        return (false);
-      }
-      bytesAvailable = (uint16_t)msb << 8 | lsb;
-    }
-
-    if (bytesAvailable == 0)
-    {
-      if (_printDebug == true)
-      {
-        _debugSerial->println(F("checkUbloxI2C: OK, zero bytes available"));
-      }
-      lastCheck = millis(); //Put off checking to avoid I2C bus traffic
-      return (false);
-    }
-
-    //Check for undocumented bit error. We found this doing logic scans.
-    //This error is rare but if we incorrectly interpret the first bit of the two 'data available' bytes as 1
-    //then we have far too many bytes to check. May be related to I2C setup time violations: https://github.com/sparkfun/SparkFun_Ublox_Arduino_Library/issues/40
-    if (bytesAvailable & ((uint16_t)1 << 15))
-    {
-      //Clear the MSbit
-      bytesAvailable &= ~((uint16_t)1 << 15);
-
-      if ((_printDebug == true) || (_printLimitedDebug == true)) // This is important. Print this if doing limited debugging
-      {
-        _debugSerial->print(F("checkUbloxI2C: Bytes available error: "));
-        _debugSerial->println(bytesAvailable);
-        if (debugPin >= 0)
-        {
-          digitalWrite((uint8_t)debugPin, LOW);
-          delay(10);
-          digitalWrite((uint8_t)debugPin, HIGH);
-        }
-      }
-    }
-
-    if (bytesAvailable > 100)
-    {
-      if (_printDebug == true)
-      {
-        _debugSerial->print(F("checkUbloxI2C: Large packet of "));
-        _debugSerial->print(bytesAvailable);
-        _debugSerial->println(F(" bytes received"));
-      }
-    }
-    else
-    {
-      if (_printDebug == true)
-      {
-        _debugSerial->print(F("checkUbloxI2C: Reading "));
-        _debugSerial->print(bytesAvailable);
-        _debugSerial->println(F(" bytes"));
-      }
-    }
-
-    while (bytesAvailable)
-    {
-      _i2cPort->beginTransmission(_gpsI2Caddress);
-      _i2cPort->write(0xFF);                     //0xFF is the register to read data from
-      if (_i2cPort->endTransmission(false) != 0) //Send a restart command. Do not release bus.
-        return (false);                          //Sensor did not ACK
-
-      //Limit to 32 bytes or whatever the buffer limit is for given platform
-      uint16_t bytesToRead = bytesAvailable;
-      if (bytesToRead > i2cTransactionSize)
-        bytesToRead = i2cTransactionSize;
-
-    TRY_AGAIN:
-
-      _i2cPort->requestFrom((uint8_t)_gpsI2Caddress, (uint8_t)bytesToRead);
-      if (_i2cPort->available())
-      {
-        for (uint16_t x = 0; x < bytesToRead; x++)
-        {
-          uint8_t incoming = _i2cPort->read(); //Grab the actual character
-
-          //Check to see if the first read is 0x7F. If it is, the module is not ready
-          //to respond. Stop, wait, and try again
-          if (x == 0)
-          {
-            if ((incoming == 0x7F) && (ubx7FcheckDisabled == false))
-            {
-              if ((_printDebug == true) || (_printLimitedDebug == true)) // This is important. Print this if doing limited debugging
-              {
-                _debugSerial->println(F("checkUbloxU2C: u-blox error, module not ready with data (7F error)"));
-              }
-              delay(5); //In logic analyzation, the module starting responding after 1.48ms
-              if (debugPin >= 0)
-              {
-                digitalWrite((uint8_t)debugPin, LOW);
-                delay(10);
-                digitalWrite((uint8_t)debugPin, HIGH);
-              }
-              goto TRY_AGAIN;
-            }
-          }
-
-          process(incoming, incomingUBX, requestedClass, requestedID); //Process this valid character
-        }
-      }
-      else
-        return (false); //Sensor did not respond
-
-      bytesAvailable -= bytesToRead;
-    }
-  }
-
-  return (true);
-
-} //end checkUbloxI2C()
-
-//Checks Serial for data, passing any new bytes to process()
-boolean SFE_UBLOX_GNSS::checkUbloxSerial(ubxPacket *incomingUBX, uint8_t requestedClass, uint8_t requestedID)
-{
-  while (_serialPort->available())
-  {
-    process(_serialPort->read(), incomingUBX, requestedClass, requestedID);
-  }
-  return (true);
-
-} //end checkUbloxSerial()
-
-//PRIVATE: Check if we have storage allocated for an incoming "automatic" message
-boolean SFE_UBLOX_GNSS::checkAutomatic(uint8_t Class, uint8_t ID)
-{
-  boolean result = false;
-  switch (Class)
-  {
-    case UBX_CLASS_NAV:
-    {
-      switch (ID)
-      {
-        case UBX_NAV_POSECEF:
-          if (packetUBXNAVPOSECEF != NULL) result = true;
-        break;
-        case UBX_NAV_STATUS:
-          if (packetUBXNAVSTATUS != NULL) result = true;
-        break;
-        case UBX_NAV_DOP:
-          if (packetUBXNAVDOP != NULL) result = true;
-        break;
-        case UBX_NAV_ATT:
-          if (packetUBXNAVATT != NULL) result = true;
-        break;
-        case UBX_NAV_PVT:
-          if (packetUBXNAVPVT != NULL) result = true;
-        break;
-        case UBX_NAV_ODO:
-          if (packetUBXNAVODO != NULL) result = true;
-        break;
-        case UBX_NAV_VELECEF:
-          if (packetUBXNAVVELECEF != NULL) result = true;
-        break;
-        case UBX_NAV_VELNED:
-          if (packetUBXNAVVELNED != NULL) result = true;
-        break;
-        case UBX_NAV_HPPOSECEF:
-          if (packetUBXNAVHPPOSECEF != NULL) result = true;
-        break;
-        case UBX_NAV_HPPOSLLH:
-          if (packetUBXNAVHPPOSLLH != NULL) result = true;
-        break;
-        case UBX_NAV_CLOCK:
-          if (packetUBXNAVCLOCK != NULL) result = true;
-        break;
-        case UBX_NAV_SVIN:
-          if (packetUBXNAVSVIN != NULL) result = true;
-        break;
-        case UBX_NAV_RELPOSNED:
-          if (packetUBXNAVRELPOSNED != NULL) result = true;
-        break;
-      }
-    }
-    break;
-    case UBX_CLASS_RXM:
-    {
-      switch (ID)
-      {
-        case UBX_RXM_SFRBX:
-          if (packetUBXRXMSFRBX != NULL) result = true;
-        break;
-        case UBX_RXM_RAWX:
-          if (packetUBXRXMRAWX != NULL) result = true;
-        break;
-      }
-    }
-    break;
-    case UBX_CLASS_CFG:
-    {
-      switch (ID)
-      {
-        case UBX_CFG_RATE:
-          if (packetUBXCFGRATE != NULL) result = true;
-        break;
-      }
-    }
-    break;
-    case UBX_CLASS_TIM:
-    {
-      switch (ID)
-      {
-        case UBX_TIM_TM2:
-          if (packetUBXTIMTM2 != NULL) result = true;
-        break;
-      }
-    }
-    break;
-    case UBX_CLASS_ESF:
-    {
-      switch (ID)
-      {
-        case UBX_ESF_ALG:
-          if (packetUBXESFALG != NULL) result = true;
-        break;
-        case UBX_ESF_INS:
-          if (packetUBXESFINS != NULL) result = true;
-        break;
-        case UBX_ESF_MEAS:
-          if (packetUBXESFMEAS != NULL) result = true;
-        break;
-        case UBX_ESF_RAW:
-          if (packetUBXESFRAW != NULL) result = true;
-        break;
-        case UBX_ESF_STATUS:
-          if (packetUBXESFSTATUS != NULL) result = true;
-        break;
-      }
-    }
-    break;
-    case UBX_CLASS_HNR:
-    {
-      switch (ID)
-      {
-        case UBX_HNR_PVT:
-          if (packetUBXHNRPVT != NULL) result = true;
-        break;
-        case UBX_HNR_ATT:
-          if (packetUBXHNRATT != NULL) result = true;
-        break;
-        case UBX_HNR_INS:
-          if (packetUBXHNRINS != NULL) result = true;
-        break;
-      }
-    }
-    break;
-  }
-  return (result);
-}
-
-//PRIVATE: Calculate how much RAM is needed to store the payload for a given automatic message
-uint16_t SFE_UBLOX_GNSS::getMaxPayloadSize(uint8_t Class, uint8_t ID)
-{
-  uint16_t maxSize = 0;
-  switch (Class)
-  {
-    case UBX_CLASS_NAV:
-    {
-      switch (ID)
-      {
-        case UBX_NAV_POSECEF:
-          maxSize = UBX_NAV_POSECEF_LEN;
-        break;
-        case UBX_NAV_STATUS:
-          maxSize = UBX_NAV_STATUS_LEN;
-        break;
-        case UBX_NAV_DOP:
-          maxSize = UBX_NAV_DOP_LEN;
-        break;
-        case UBX_NAV_ATT:
-          maxSize = UBX_NAV_ATT_LEN;
-        break;
-        case UBX_NAV_PVT:
-          maxSize = UBX_NAV_PVT_LEN;
-        break;
-        case UBX_NAV_ODO:
-          maxSize = UBX_NAV_ODO_LEN;
-        break;
-        case UBX_NAV_VELECEF:
-          maxSize = UBX_NAV_VELECEF_LEN;
-        break;
-        case UBX_NAV_VELNED:
-          maxSize = UBX_NAV_VELNED_LEN;
-        break;
-        case UBX_NAV_HPPOSECEF:
-          maxSize = UBX_NAV_HPPOSECEF_LEN;
-        break;
-        case UBX_NAV_HPPOSLLH:
-          maxSize = UBX_NAV_HPPOSLLH_LEN;
-        break;
-        case UBX_NAV_CLOCK:
-          maxSize = UBX_NAV_CLOCK_LEN;
-        break;
-        case UBX_NAV_SVIN:
-          maxSize = UBX_NAV_SVIN_LEN;
-        break;
-        case UBX_NAV_RELPOSNED:
-          maxSize = UBX_NAV_RELPOSNED_LEN_F9;
-        break;
-      }
-    }
-    break;
-    case UBX_CLASS_RXM:
-    {
-      switch (ID)
-      {
-        case UBX_RXM_SFRBX:
-          maxSize = UBX_RXM_SFRBX_MAX_LEN;
-        break;
-        case UBX_RXM_RAWX:
-          maxSize = UBX_RXM_RAWX_MAX_LEN;
-        break;
-      }
-    }
-    break;
-    case UBX_CLASS_CFG:
-    {
-      switch (ID)
-      {
-        case UBX_CFG_RATE:
-          maxSize = UBX_CFG_RATE_LEN;
-        break;
-      }
-    }
-    break;
-    case UBX_CLASS_TIM:
-    {
-      switch (ID)
-      {
-        case UBX_TIM_TM2:
-          maxSize = UBX_TIM_TM2_LEN;
-        break;
-      }
-    }
-    break;
-    case UBX_CLASS_ESF:
-    {
-      switch (ID)
-      {
-        case UBX_ESF_ALG:
-          maxSize = UBX_ESF_ALG_LEN;
-        break;
-        case UBX_ESF_INS:
-          maxSize = UBX_ESF_INS_LEN;
-        break;
-        case UBX_ESF_MEAS:
-          maxSize = UBX_ESF_MEAS_MAX_LEN;
-        break;
-        case UBX_ESF_RAW:
-          maxSize = UBX_ESF_RAW_MAX_LEN;
-        break;
-        case UBX_ESF_STATUS:
-          maxSize = UBX_ESF_STATUS_MAX_LEN;
-        break;
-      }
-    }
-    break;
-    case UBX_CLASS_HNR:
-    {
-      switch (ID)
-      {
-        case UBX_HNR_PVT:
-          maxSize = UBX_HNR_PVT_LEN;
-        break;
-        case UBX_HNR_ATT:
-          maxSize = UBX_HNR_ATT_LEN;
-        break;
-        case UBX_HNR_INS:
-          maxSize = UBX_HNR_INS_LEN;
-        break;
-      }
-    }
-    break;
-  }
-  return (maxSize);
-}
-
-//Processes NMEA and UBX binary sentences one byte at a time
-//Take a given byte and file it into the proper array
-void SFE_UBLOX_GNSS::process(uint8_t incoming, ubxPacket *incomingUBX, uint8_t requestedClass, uint8_t requestedID)
-{
-  if ((currentSentence == NONE) || (currentSentence == NMEA))
-  {
-    if (incoming == 0xB5) //UBX binary frames start with 0xB5, aka μ
-    {
-      //This is the start of a binary sentence. Reset flags.
-      //We still don't know the response class
-      ubxFrameCounter = 0;
-      currentSentence = UBX;
-      //Reset the packetBuf.counter even though we will need to reset it again when ubxFrameCounter == 2
-      packetBuf.counter = 0;
-      ignoreThisPayload = false; //We should not ignore this payload - yet
-      //Store data in packetBuf until we know if we have a requested class and ID match
-      activePacketBuffer = SFE_UBLOX_PACKET_PACKETBUF;
-    }
-    else if (incoming == '$')
-    {
-      currentSentence = NMEA;
-    }
-    else if (incoming == 0xD3) //RTCM frames start with 0xD3
-    {
-      rtcmFrameCounter = 0;
-      currentSentence = RTCM;
-    }
-    else
-    {
-      //This character is unknown or we missed the previous start of a sentence
-    }
-  }
-
-  //Depending on the sentence, pass the character to the individual processor
-  if (currentSentence == UBX)
-  {
-    //Decide what type of response this is
-    if ((ubxFrameCounter == 0) && (incoming != 0xB5))      //ISO 'μ'
-      currentSentence = NONE;                              //Something went wrong. Reset.
-    else if ((ubxFrameCounter == 1) && (incoming != 0x62)) //ASCII 'b'
-      currentSentence = NONE;                              //Something went wrong. Reset.
-    // Note to future self:
-    // There may be some duplication / redundancy in the next few lines as processUBX will also
-    // load information into packetBuf, but we'll do it here too for clarity
-    else if (ubxFrameCounter == 2) //Class
-    {
-      // Record the class in packetBuf until we know what to do with it
-      packetBuf.cls = incoming; // (Duplication)
-      rollingChecksumA = 0;     //Reset our rolling checksums here (not when we receive the 0xB5)
-      rollingChecksumB = 0;
-      packetBuf.counter = 0;                                   //Reset the packetBuf.counter (again)
-      packetBuf.valid = SFE_UBLOX_PACKET_VALIDITY_NOT_DEFINED; // Reset the packet validity (redundant?)
-      packetBuf.startingSpot = incomingUBX->startingSpot;      //Copy the startingSpot
-    }
-    else if (ubxFrameCounter == 3) //ID
-    {
-      // Record the ID in packetBuf until we know what to do with it
-      packetBuf.id = incoming; // (Duplication)
-      //We can now identify the type of response
-      //If the packet we are receiving is not an ACK then check for a class and ID match
-      if (packetBuf.cls != UBX_CLASS_ACK)
-      {
-        //This is not an ACK so check for a class and ID match
-        if ((packetBuf.cls == requestedClass) && (packetBuf.id == requestedID))
-        {
-          //This is not an ACK and we have a class and ID match
-          //So start diverting data into incomingUBX (usually packetCfg)
-          activePacketBuffer = SFE_UBLOX_PACKET_PACKETCFG;
-          incomingUBX->cls = packetBuf.cls; //Copy the class and ID into incomingUBX (usually packetCfg)
-          incomingUBX->id = packetBuf.id;
-          incomingUBX->counter = packetBuf.counter; //Copy over the .counter too
-        }
-        //This is not an ACK and we do not have a complete class and ID match
-        //So let's check if this is an "automatic" message which has its own storage defined
-        else if (checkAutomatic(packetBuf.cls, packetBuf.id))
-        {
-          //This is not the message we were expecting but it has its own storage and so we should process it anyway.
-          //We'll try to use packetAuto to buffer the message (so it can't overwrite anything in packetCfg).
-          //We need to allocate memory for the packetAuto payload (payloadAuto) - and delete it once
-          //reception is complete.
-          uint16_t maxPayload = getMaxPayloadSize(packetBuf.cls, packetBuf.id); // Calculate how much RAM we need
-          if (maxPayload == 0)
-          {
-            if ((_printDebug == true) || (_printLimitedDebug == true)) // This is important. Print this if doing limited debugging
-            {
-              _debugSerial->print(F("process: getMaxPayloadSize returned ZERO!! Class: 0x"));
-              _debugSerial->print(packetBuf.cls);
-              _debugSerial->print(F(" ID: 0x"));
-              _debugSerial->println(packetBuf.id);
-            }
-          }
-          if (payloadAuto != NULL) // Check if memory is already allocated - this should be impossible!
-          {
-            if ((_printDebug == true) || (_printLimitedDebug == true)) // This is important. Print this if doing limited debugging
-            {
-              _debugSerial->println(F("process: memory is already allocated for payloadAuto! Deleting..."));
-            }
-            delete[] payloadAuto;
-            payloadAuto = NULL; // Redundant?
-            packetAuto.payload = payloadAuto;
-          }
-          payloadAuto = new uint8_t[maxPayload]; // Allocate RAM for payloadAuto
-          packetAuto.payload = payloadAuto;
-          if (payloadAuto == NULL) // Check if the alloc failed
-          {
-            if ((_printDebug == true) || (_printLimitedDebug == true)) // This is important. Print this if doing limited debugging
-            {
-              _debugSerial->print(F("process: memory allocation failed for \"automatic\" message: Class: 0x"));
-              _debugSerial->print(packetBuf.cls, HEX);
-              _debugSerial->print(F(" ID: 0x"));
-              _debugSerial->println(packetBuf.id, HEX);
-              _debugSerial->println(F("process: \"automatic\" message could overwrite data"));
-            }
-            // The RAM allocation failed so fall back to using incomingUBX (usually packetCfg) even though we risk overwriting data
-            activePacketBuffer = SFE_UBLOX_PACKET_PACKETCFG;
-            incomingUBX->cls = packetBuf.cls; //Copy the class and ID into incomingUBX (usually packetCfg)
-            incomingUBX->id = packetBuf.id;
-            incomingUBX->counter = packetBuf.counter; //Copy over the .counter too
-          }
-          else
-          {
-            //The RAM allocation was successful so we start diverting data into packetAuto and process it
-            activePacketBuffer = SFE_UBLOX_PACKET_PACKETAUTO;
-            packetAuto.cls = packetBuf.cls; //Copy the class and ID into packetAuto
-            packetAuto.id = packetBuf.id;
-            packetAuto.counter = packetBuf.counter; //Copy over the .counter too
-            packetAuto.startingSpot = packetBuf.startingSpot; //And the starting spot? (Probably redundant)
-            if (_printDebug == true)
-            {
-              _debugSerial->print(F("process: incoming \"automatic\" message: Class: 0x"));
-              _debugSerial->print(packetBuf.cls, HEX);
-              _debugSerial->print(F(" ID: 0x"));
-              _debugSerial->println(packetBuf.id, HEX);
-            }
-          }
-        }
-        else
-        {
-          //This is not an ACK and we do not have a class and ID match
-          //so we should keep diverting data into packetBuf and ignore the payload
-          ignoreThisPayload = true;
-        }
-      }
-      else
-      {
-        // This is an ACK so it is to early to do anything with it
-        // We need to wait until we have received the length and data bytes
-        // So we should keep diverting data into packetBuf
-      }
-    }
-    else if (ubxFrameCounter == 4) //Length LSB
-    {
-      //We should save the length in packetBuf even if activePacketBuffer == SFE_UBLOX_PACKET_PACKETCFG
-      packetBuf.len = incoming; // (Duplication)
-    }
-    else if (ubxFrameCounter == 5) //Length MSB
-    {
-      //We should save the length in packetBuf even if activePacketBuffer == SFE_UBLOX_PACKET_PACKETCFG
-      packetBuf.len |= incoming << 8; // (Duplication)
-    }
-    else if (ubxFrameCounter == 6) //This should be the first byte of the payload unless .len is zero
-    {
-      if (packetBuf.len == 0) // Check if length is zero (hopefully this is impossible!)
-      {
-        if ((_printDebug == true) || (_printLimitedDebug == true)) // This is important. Print this if doing limited debugging
-        {
-          _debugSerial->print(F("process: ZERO LENGTH packet received: Class: 0x"));
-          _debugSerial->print(packetBuf.cls, HEX);
-          _debugSerial->print(F(" ID: 0x"));
-          _debugSerial->println(packetBuf.id, HEX);
-        }
-        //If length is zero (!) this will be the first byte of the checksum so record it
-        packetBuf.checksumA = incoming;
-      }
-      else
-      {
-        //The length is not zero so record this byte in the payload
-        packetBuf.payload[0] = incoming;
-      }
-    }
-    else if (ubxFrameCounter == 7) //This should be the second byte of the payload unless .len is zero or one
-    {
-      if (packetBuf.len == 0) // Check if length is zero (hopefully this is impossible!)
-      {
-        //If length is zero (!) this will be the second byte of the checksum so record it
-        packetBuf.checksumB = incoming;
-      }
-      else if (packetBuf.len == 1) // Check if length is one
-      {
-        //The length is one so this is the first byte of the checksum
-        packetBuf.checksumA = incoming;
-      }
-      else // Length is >= 2 so this must be a payload byte
-      {
-        packetBuf.payload[1] = incoming;
-      }
-      // Now that we have received two payload bytes, we can check for a matching ACK/NACK
-      if ((activePacketBuffer == SFE_UBLOX_PACKET_PACKETBUF) // If we are not already processing a data packet
-          && (packetBuf.cls == UBX_CLASS_ACK)                // and if this is an ACK/NACK
-          && (packetBuf.payload[0] == requestedClass)        // and if the class matches
-          && (packetBuf.payload[1] == requestedID))          // and if the ID matches
-      {
-        if (packetBuf.len == 2) // Check if .len is 2
-        {
-          // Then this is a matching ACK so copy it into packetAck
-          activePacketBuffer = SFE_UBLOX_PACKET_PACKETACK;
-          packetAck.cls = packetBuf.cls;
-          packetAck.id = packetBuf.id;
-          packetAck.len = packetBuf.len;
-          packetAck.counter = packetBuf.counter;
-          packetAck.payload[0] = packetBuf.payload[0];
-          packetAck.payload[1] = packetBuf.payload[1];
-        }
-        else // Length is not 2 (hopefully this is impossible!)
-        {
-          if ((_printDebug == true) || (_printLimitedDebug == true)) // This is important. Print this if doing limited debugging
-          {
-            _debugSerial->print(F("process: ACK received with .len != 2: Class: 0x"));
-            _debugSerial->print(packetBuf.payload[0], HEX);
-            _debugSerial->print(F(" ID: 0x"));
-            _debugSerial->print(packetBuf.payload[1], HEX);
-            _debugSerial->print(F(" len: "));
-            _debugSerial->println(packetBuf.len);
-          }
-        }
-      }
-    }
-
-    //Divert incoming into the correct buffer
-    if (activePacketBuffer == SFE_UBLOX_PACKET_PACKETACK)
-      processUBX(incoming, &packetAck, requestedClass, requestedID);
-    else if (activePacketBuffer == SFE_UBLOX_PACKET_PACKETCFG)
-      processUBX(incoming, incomingUBX, requestedClass, requestedID);
-    else if (activePacketBuffer == SFE_UBLOX_PACKET_PACKETBUF)
-      processUBX(incoming, &packetBuf, requestedClass, requestedID);
-    else // if (activePacketBuffer == SFE_UBLOX_PACKET_PACKETAUTO)
-      processUBX(incoming, &packetAuto, requestedClass, requestedID);
-
-    //Finally, increment the frame counter
-    ubxFrameCounter++;
-  }
-  else if (currentSentence == NMEA)
-  {
-    processNMEA(incoming); //Process each NMEA character
-  }
-  else if (currentSentence == RTCM)
-  {
-    processRTCMframe(incoming); //Deal with RTCM bytes
-  }
-}
-
-//This is the default or generic NMEA processor. We're only going to pipe the data to serial port so we can see it.
-//User could overwrite this function to pipe characters to nmea.process(c) of tinyGPS or MicroNMEA
-//Or user could pipe each character to a buffer, radio, etc.
-void SFE_UBLOX_GNSS::processNMEA(char incoming)
-{
-  //If user has assigned an output port then pipe the characters there
-  if (_nmeaOutputPort != NULL)
-    _nmeaOutputPort->write(incoming); //Echo this byte to the serial port
-}
-
-//We need to be able to identify an RTCM packet and then the length
-//so that we know when the RTCM message is completely received and we then start
-//listening for other sentences (like NMEA or UBX)
-//RTCM packet structure is very odd. I never found RTCM STANDARD 10403.2 but
-//http://d1.amobbs.com/bbs_upload782111/files_39/ourdev_635123CK0HJT.pdf is good
-//https://dspace.cvut.cz/bitstream/handle/10467/65205/F3-BP-2016-Shkalikava-Anastasiya-Prenos%20polohove%20informace%20prostrednictvim%20datove%20site.pdf?sequence=-1
-//Lead me to: https://forum.u-blox.com/index.php/4348/how-to-read-rtcm-messages-from-neo-m8p
-//RTCM 3.2 bytes look like this:
-//Byte 0: Always 0xD3
-//Byte 1: 6-bits of zero
-//Byte 2: 10-bits of length of this packet including the first two-ish header bytes, + 6.
-//byte 3 + 4 bits: Msg type 12 bits
-//Example: D3 00 7C 43 F0 ... / 0x7C = 124+6 = 130 bytes in this packet, 0x43F = Msg type 1087
-void SFE_UBLOX_GNSS::processRTCMframe(uint8_t incoming)
-{
-  if (rtcmFrameCounter == 1)
-  {
-    rtcmLen = (incoming & 0x03) << 8; //Get the last two bits of this byte. Bits 8&9 of 10-bit length
-  }
-  else if (rtcmFrameCounter == 2)
-  {
-    rtcmLen |= incoming; //Bits 0-7 of packet length
-    rtcmLen += 6;        //There are 6 additional bytes of what we presume is header, msgType, CRC, and stuff
-  }
-  /*else if (rtcmFrameCounter == 3)
-  {
-    rtcmMsgType = incoming << 4; //Message Type, MS 4 bits
-  }
-  else if (rtcmFrameCounter == 4)
-  {
-    rtcmMsgType |= (incoming >> 4); //Message Type, bits 0-7
-  }*/
-
-  rtcmFrameCounter++;
-
-  processRTCM(incoming); //Here is where we expose this byte to the user
-
-  if (rtcmFrameCounter == rtcmLen)
-  {
-    //We're done!
-    currentSentence = NONE; //Reset and start looking for next sentence type
-  }
-}
-
-//This function is called for each byte of an RTCM frame
-//Ths user can overwrite this function and process the RTCM frame as they please
-//Bytes can be piped to Serial or other interface. The consumer could be a radio or the internet (Ntrip broadcaster)
-void SFE_UBLOX_GNSS::processRTCM(uint8_t incoming)
-{
-  //Radio.sendReliable((String)incoming); //An example of passing this byte to a radio
-
-  //_debugSerial->write(incoming); //An example of passing this byte out the serial port
-
-  //Debug printing
-  //  _debugSerial->print(F(" "));
-  //  if(incoming < 0x10) _debugSerial->print(F("0"));
-  //  if(incoming < 0x10) _debugSerial->print(F("0"));
-  //  _debugSerial->print(incoming, HEX);
-  //  if(rtcmFrameCounter % 16 == 0) _debugSerial->println();
-}
-
-//Given a character, file it away into the uxb packet structure
-//Set valid to VALID or NOT_VALID once sentence is completely received and passes or fails CRC
-//The payload portion of the packet can be 100s of bytes but the max array size is packetCfgPayloadSize bytes.
-//startingSpot can be set so we only record a subset of bytes within a larger packet.
-void SFE_UBLOX_GNSS::processUBX(uint8_t incoming, ubxPacket *incomingUBX, uint8_t requestedClass, uint8_t requestedID)
-{
-    //If incomingUBX is a user-defined custom packet, then the payload size could be different to packetCfgPayloadSize.
-    //TO DO: update this to prevent an overrun when receiving an automatic message
-    //       and the incomingUBX payload size is smaller than packetCfgPayloadSize.
-  size_t maximum_payload_size;
-  if (activePacketBuffer == SFE_UBLOX_PACKET_PACKETCFG)
-    maximum_payload_size = packetCfgPayloadSize;
-  else if (activePacketBuffer == SFE_UBLOX_PACKET_PACKETAUTO)
-  {
-    // Calculate maximum payload size once Class and ID have been received
-    // (This check is probably redundant as activePacketBuffer can only be SFE_UBLOX_PACKET_PACKETAUTO
-    //  when ubxFrameCounter >= 3)
-    //if (incomingUBX->counter >= 2)
-    //{
-      maximum_payload_size = getMaxPayloadSize(incomingUBX->cls, incomingUBX->id);
-      if (maximum_payload_size == 0)
-      {
-        if ((_printDebug == true) || (_printLimitedDebug == true)) // This is important. Print this if doing limited debugging
-        {
-          _debugSerial->print(F("processUBX: getMaxPayloadSize returned ZERO!! Class: 0x"));
-          _debugSerial->print(incomingUBX->cls);
-          _debugSerial->print(F(" ID: 0x"));
-          _debugSerial->println(incomingUBX->id);
-        }
-      }
-    //}
-    //else
-    //  maximum_payload_size = 2;
-  }
-  else
-    maximum_payload_size = 2;
-
-  bool overrun = false;
-
-  //Add all incoming bytes to the rolling checksum
-  //Stop at len+4 as this is the checksum bytes to that should not be added to the rolling checksum
-  if (incomingUBX->counter < incomingUBX->len + 4)
-    addToChecksum(incoming);
-
-  if (incomingUBX->counter == 0)
-  {
-    incomingUBX->cls = incoming;
-  }
-  else if (incomingUBX->counter == 1)
-  {
-    incomingUBX->id = incoming;
-  }
-  else if (incomingUBX->counter == 2) //Len LSB
-  {
-    incomingUBX->len = incoming;
-  }
-  else if (incomingUBX->counter == 3) //Len MSB
-  {
-    incomingUBX->len |= incoming << 8;
-  }
-  else if (incomingUBX->counter == incomingUBX->len + 4) //ChecksumA
-  {
-    incomingUBX->checksumA = incoming;
-  }
-  else if (incomingUBX->counter == incomingUBX->len + 5) //ChecksumB
-  {
-    incomingUBX->checksumB = incoming;
-
-    currentSentence = NONE; //We're done! Reset the sentence to being looking for a new start char
-
-    //Validate this sentence
-    if ((incomingUBX->checksumA == rollingChecksumA) && (incomingUBX->checksumB == rollingChecksumB))
-    {
-      incomingUBX->valid = SFE_UBLOX_PACKET_VALIDITY_VALID; // Flag the packet as valid
-
-      // Let's check if the class and ID match the requestedClass and requestedID
-      // Remember - this could be a data packet or an ACK packet
-      if ((incomingUBX->cls == requestedClass) && (incomingUBX->id == requestedID))
-      {
-        incomingUBX->classAndIDmatch = SFE_UBLOX_PACKET_VALIDITY_VALID; // If we have a match, set the classAndIDmatch flag to valid
-      }
-
-      // If this is an ACK then let's check if the class and ID match the requestedClass and requestedID
-      else if ((incomingUBX->cls == UBX_CLASS_ACK) && (incomingUBX->id == UBX_ACK_ACK) && (incomingUBX->payload[0] == requestedClass) && (incomingUBX->payload[1] == requestedID))
-      {
-        incomingUBX->classAndIDmatch = SFE_UBLOX_PACKET_VALIDITY_VALID; // If we have a match, set the classAndIDmatch flag to valid
-      }
-
-      // If this is a NACK then let's check if the class and ID match the requestedClass and requestedID
-      else if ((incomingUBX->cls == UBX_CLASS_ACK) && (incomingUBX->id == UBX_ACK_NACK) && (incomingUBX->payload[0] == requestedClass) && (incomingUBX->payload[1] == requestedID))
-      {
-        incomingUBX->classAndIDmatch = SFE_UBLOX_PACKET_NOTACKNOWLEDGED; // If we have a match, set the classAndIDmatch flag to NOTACKNOWLEDGED
-        if (_printDebug == true)
-        {
-          _debugSerial->print(F("processUBX: NACK received: Requested Class: 0x"));
-          _debugSerial->print(incomingUBX->payload[0], HEX);
-          _debugSerial->print(F(" Requested ID: 0x"));
-          _debugSerial->println(incomingUBX->payload[1], HEX);
-        }
-      }
-
-      //This is not an ACK and we do not have a complete class and ID match
-      //So let's check for an "automatic" message arriving
-      else if (checkAutomatic(incomingUBX->cls, incomingUBX->id))
-      {
-        // This isn't the message we are looking for...
-        // Let's say so and leave incomingUBX->classAndIDmatch _unchanged_
-        if (_printDebug == true)
-        {
-          _debugSerial->print(F("processUBX: incoming \"automatic\" message: Class: 0x"));
-          _debugSerial->print(incomingUBX->cls, HEX);
-          _debugSerial->print(F(" ID: 0x"));
-          _debugSerial->println(incomingUBX->id, HEX);
-        }
-      }
-
-      if (_printDebug == true)
-      {
-        _debugSerial->print(F("Incoming: Size: "));
-        _debugSerial->print(incomingUBX->len);
-        _debugSerial->print(F(" Received: "));
-        printPacket(incomingUBX);
-
-        if (incomingUBX->valid == SFE_UBLOX_PACKET_VALIDITY_VALID)
-        {
-          _debugSerial->println(F("packetCfg now valid"));
-        }
-        if (packetAck.valid == SFE_UBLOX_PACKET_VALIDITY_VALID)
-        {
-          _debugSerial->println(F("packetAck now valid"));
-        }
-        if (incomingUBX->classAndIDmatch == SFE_UBLOX_PACKET_VALIDITY_VALID)
-        {
-          _debugSerial->println(F("packetCfg classAndIDmatch"));
-        }
-        if (packetAck.classAndIDmatch == SFE_UBLOX_PACKET_VALIDITY_VALID)
-        {
-          _debugSerial->println(F("packetAck classAndIDmatch"));
-        }
-      }
-
-      //We've got a valid packet, now do something with it but only if ignoreThisPayload is false
-      if (ignoreThisPayload == false)
-      {
-        processUBXpacket(incomingUBX);
-      }
-    }
-    else // Checksum failure
-    {
-      incomingUBX->valid = SFE_UBLOX_PACKET_VALIDITY_NOT_VALID;
-
-      // Let's check if the class and ID match the requestedClass and requestedID.
-      // This is potentially risky as we are saying that we saw the requested Class and ID
-      // but that the packet checksum failed. Potentially it could be the class or ID bytes
-      // that caused the checksum error!
-      if ((incomingUBX->cls == requestedClass) && (incomingUBX->id == requestedID))
-      {
-        incomingUBX->classAndIDmatch = SFE_UBLOX_PACKET_VALIDITY_NOT_VALID; // If we have a match, set the classAndIDmatch flag to not valid
-      }
-      // If this is an ACK then let's check if the class and ID match the requestedClass and requestedID
-      else if ((incomingUBX->cls == UBX_CLASS_ACK) && (incomingUBX->payload[0] == requestedClass) && (incomingUBX->payload[1] == requestedID))
-      {
-        incomingUBX->classAndIDmatch = SFE_UBLOX_PACKET_VALIDITY_NOT_VALID; // If we have a match, set the classAndIDmatch flag to not valid
-      }
-
-      if ((_printDebug == true) || (_printLimitedDebug == true)) // This is important. Print this if doing limited debugging
-      {
-        //Drive an external pin to allow for easier logic analyzation
-        if (debugPin >= 0)
-        {
-          digitalWrite((uint8_t)debugPin, LOW);
-          delay(10);
-          digitalWrite((uint8_t)debugPin, HIGH);
-        }
-
-        _debugSerial->print(F("Checksum failed:"));
-        _debugSerial->print(F(" checksumA: "));
-        _debugSerial->print(incomingUBX->checksumA);
-        _debugSerial->print(F(" checksumB: "));
-        _debugSerial->print(incomingUBX->checksumB);
-
-        _debugSerial->print(F(" rollingChecksumA: "));
-        _debugSerial->print(rollingChecksumA);
-        _debugSerial->print(F(" rollingChecksumB: "));
-        _debugSerial->print(rollingChecksumB);
-        _debugSerial->println();
-      }
-    }
-
-    // Now that the packet is complete and has been processed, we need to delete the memory
-    // allocated for packetAuto
-    if (activePacketBuffer == SFE_UBLOX_PACKET_PACKETAUTO)
-    {
-      delete[] payloadAuto;
-      payloadAuto = NULL; // Redundant?
-      packetAuto.payload = payloadAuto;
-    }
-  }
-  else //Load this byte into the payload array
-  {
-    //If an automatic packet comes in asynchronously, we need to fudge the startingSpot
-    uint16_t startingSpot = incomingUBX->startingSpot;
-    if (checkAutomatic(incomingUBX->cls, incomingUBX->id))
-      startingSpot = 0;
-    // Check if this is payload data which should be ignored
-    if (ignoreThisPayload == false)
-    {
-      //Begin recording if counter goes past startingSpot
-      if ((incomingUBX->counter - 4) >= startingSpot)
-      {
-        //Check to see if we have room for this byte
-        if (((incomingUBX->counter - 4) - startingSpot) < maximum_payload_size) //If counter = 208, starting spot = 200, we're good to record.
-        {
-          incomingUBX->payload[(incomingUBX->counter - 4) - startingSpot] = incoming; //Store this byte into payload array
-        }
-        else
-        {
-          overrun = true;
-        }
-      }
-    }
-  }
-
-  // incomingUBX->counter should never reach maximum_payload_size + class + id + len[2] + checksum[2]
-  if (overrun || ((incomingUBX->counter == maximum_payload_size + 6) && (ignoreThisPayload == false)))
-  {
-    //Something has gone very wrong
-    currentSentence = NONE; //Reset the sentence to being looking for a new start char
-    if ((_printDebug == true) || (_printLimitedDebug == true)) // This is important. Print this if doing limited debugging
-    {
-      if (overrun)
-        _debugSerial->print(F("processUBX: buffer overrun detected!"));
-      else
-        _debugSerial->print(F("processUBX: counter hit maximum_payload_size + 6!"));
-      _debugSerial->print(F(" activePacketBuffer: "));
-      _debugSerial->print(activePacketBuffer);
-      _debugSerial->print(F(" maximum_payload_size: "));
-      _debugSerial->println(maximum_payload_size);
-    }
-  }
-
-  //Increment the counter
-  incomingUBX->counter++;
-}
-
-//Once a packet has been received and validated, identify this packet's class/id and update internal flags
-void SFE_UBLOX_GNSS::processUBXpacket(ubxPacket *msg)
-{
-  switch (msg->cls)
-  {
-  case UBX_CLASS_NAV:
-    if (msg->id == UBX_NAV_POSECEF && msg->len == UBX_NAV_POSECEF_LEN)
-    {
-      //Parse various byte fields into storage - but only if we have memory allocated for it
-      if (packetUBXNAVPOSECEF != NULL)
-      {
-        packetUBXNAVPOSECEF->data.iTOW = extractLong(msg, 0);
-        packetUBXNAVPOSECEF->data.ecefX = extractSignedLong(msg, 4);
-        packetUBXNAVPOSECEF->data.ecefY = extractSignedLong(msg, 8);
-        packetUBXNAVPOSECEF->data.ecefZ = extractSignedLong(msg, 12);
-        packetUBXNAVPOSECEF->data.pAcc = extractLong(msg, 16);
-
-        //Mark all datums as fresh (not read before)
-        packetUBXNAVPOSECEF->moduleQueried.moduleQueried.all = 0xFFFFFFFF;
-
-        //Check if we need to copy the data for the callback
-        if ((packetUBXNAVPOSECEF->callbackData != NULL) // If RAM has been allocated for the copy of the data
-          && (packetUBXNAVPOSECEF->automaticFlags.flags.bits.callbackCopyValid == false)) // AND the data is stale
-        {
-          memcpy(&packetUBXNAVPOSECEF->callbackData->iTOW, &packetUBXNAVPOSECEF->data.iTOW, sizeof(UBX_NAV_POSECEF_data_t));
-          packetUBXNAVPOSECEF->automaticFlags.flags.bits.callbackCopyValid = true;
-        }
-
-        //Check if we need to copy the data into the file buffer
-        if (packetUBXNAVPOSECEF->automaticFlags.flags.bits.addToFileBuffer)
-        {
-          storePacket(msg);
-        }
-      }
-    }
-    else if (msg->id == UBX_NAV_STATUS && msg->len == UBX_NAV_STATUS_LEN)
-    {
-      //Parse various byte fields into storage - but only if we have memory allocated for it
-      if (packetUBXNAVSTATUS != NULL)
-      {
-        packetUBXNAVSTATUS->data.iTOW = extractLong(msg, 0);
-        packetUBXNAVSTATUS->data.gpsFix = extractByte(msg, 4);
-        packetUBXNAVSTATUS->data.flags.all = extractByte(msg, 5);
-        packetUBXNAVSTATUS->data.fixStat.all = extractByte(msg, 6);
-        packetUBXNAVSTATUS->data.flags2.all = extractByte(msg, 7);
-        packetUBXNAVSTATUS->data.ttff = extractLong(msg, 8);
-        packetUBXNAVSTATUS->data.msss = extractLong(msg, 12);
-
-        //Mark all datums as fresh (not read before)
-        packetUBXNAVSTATUS->moduleQueried.moduleQueried.all = 0xFFFFFFFF;
-
-        //Check if we need to copy the data for the callback
-        if ((packetUBXNAVSTATUS->callbackData != NULL) // If RAM has been allocated for the copy of the data
-          && (packetUBXNAVSTATUS->automaticFlags.flags.bits.callbackCopyValid == false)) // AND the data is stale
-        {
-          memcpy(&packetUBXNAVSTATUS->callbackData->iTOW, &packetUBXNAVSTATUS->data.iTOW, sizeof(UBX_NAV_STATUS_data_t));
-          packetUBXNAVSTATUS->automaticFlags.flags.bits.callbackCopyValid = true;
-        }
-
-        //Check if we need to copy the data into the file buffer
-        if (packetUBXNAVSTATUS->automaticFlags.flags.bits.addToFileBuffer)
-        {
-          storePacket(msg);
-        }
-      }
-    }
-    else if (msg->id == UBX_NAV_DOP && msg->len == UBX_NAV_DOP_LEN)
-    {
-      //Parse various byte fields into storage - but only if we have memory allocated for it
-      if (packetUBXNAVDOP != NULL)
-      {
-        packetUBXNAVDOP->data.iTOW = extractLong(msg, 0);
-        packetUBXNAVDOP->data.gDOP = extractInt(msg, 4);
-        packetUBXNAVDOP->data.pDOP = extractInt(msg, 6);
-        packetUBXNAVDOP->data.tDOP = extractInt(msg, 8);
-        packetUBXNAVDOP->data.vDOP = extractInt(msg, 10);
-        packetUBXNAVDOP->data.hDOP = extractInt(msg, 12);
-        packetUBXNAVDOP->data.nDOP = extractInt(msg, 14);
-        packetUBXNAVDOP->data.eDOP = extractInt(msg, 16);
-
-        //Mark all datums as fresh (not read before)
-        packetUBXNAVDOP->moduleQueried.moduleQueried.all = 0xFFFFFFFF;
-
-        //Check if we need to copy the data for the callback
-        if ((packetUBXNAVDOP->callbackData != NULL) // If RAM has been allocated for the copy of the data
-          && (packetUBXNAVDOP->automaticFlags.flags.bits.callbackCopyValid == false)) // AND the data is stale
-        {
-          memcpy(&packetUBXNAVDOP->callbackData->iTOW, &packetUBXNAVDOP->data.iTOW, sizeof(UBX_NAV_DOP_data_t));
-          packetUBXNAVDOP->automaticFlags.flags.bits.callbackCopyValid = true;
-        }
-
-        //Check if we need to copy the data into the file buffer
-        if (packetUBXNAVDOP->automaticFlags.flags.bits.addToFileBuffer)
-        {
-          storePacket(msg);
-        }
-      }
-    }
-    else if (msg->id == UBX_NAV_ATT && msg->len == UBX_NAV_ATT_LEN)
-    {
-      //Parse various byte fields into storage - but only if we have memory allocated for it
-      if (packetUBXNAVATT != NULL)
-      {
-        packetUBXNAVATT->data.iTOW = extractLong(msg, 0);
-        packetUBXNAVATT->data.version = extractByte(msg, 4);
-        packetUBXNAVATT->data.roll = extractSignedLong(msg, 8);
-        packetUBXNAVATT->data.pitch = extractSignedLong(msg, 12);
-        packetUBXNAVATT->data.heading = extractSignedLong(msg, 16);
-        packetUBXNAVATT->data.accRoll = extractLong(msg, 20);
-        packetUBXNAVATT->data.accPitch = extractLong(msg, 24);
-        packetUBXNAVATT->data.accHeading = extractLong(msg, 28);
-
-        //Mark all datums as fresh (not read before)
-        packetUBXNAVATT->moduleQueried.moduleQueried.all = 0xFFFFFFFF;
-
-        //Check if we need to copy the data for the callback
-        if ((packetUBXNAVATT->callbackData != NULL) // If RAM has been allocated for the copy of the data
-          && (packetUBXNAVATT->automaticFlags.flags.bits.callbackCopyValid == false)) // AND the data is stale
-        {
-          memcpy(&packetUBXNAVATT->callbackData->iTOW, &packetUBXNAVATT->data.iTOW, sizeof(UBX_NAV_ATT_data_t));
-          packetUBXNAVATT->automaticFlags.flags.bits.callbackCopyValid = true;
-        }
-
-        //Check if we need to copy the data into the file buffer
-        if (packetUBXNAVATT->automaticFlags.flags.bits.addToFileBuffer)
-        {
-          storePacket(msg);
-        }
-      }
-    }
-    else if (msg->id == UBX_NAV_PVT && msg->len == UBX_NAV_PVT_LEN)
-    {
-      //Parse various byte fields into storage - but only if we have memory allocated for it
-      if (packetUBXNAVPVT != NULL)
-      {
-        packetUBXNAVPVT->data.iTOW = extractLong(msg, 0);
-        packetUBXNAVPVT->data.year = extractInt(msg, 4);
-        packetUBXNAVPVT->data.month = extractByte(msg, 6);
-        packetUBXNAVPVT->data.day = extractByte(msg, 7);
-        packetUBXNAVPVT->data.hour = extractByte(msg, 8);
-        packetUBXNAVPVT->data.min = extractByte(msg, 9);
-        packetUBXNAVPVT->data.sec = extractByte(msg, 10);
-        packetUBXNAVPVT->data.valid.all = extractByte(msg, 11);
-        packetUBXNAVPVT->data.tAcc = extractLong(msg, 12);
-        packetUBXNAVPVT->data.nano = extractSignedLong(msg, 16); //Includes milliseconds
-        packetUBXNAVPVT->data.fixType = extractByte(msg, 20);
-        packetUBXNAVPVT->data.flags.all = extractByte(msg, 21);
-        packetUBXNAVPVT->data.flags2.all = extractByte(msg, 22);
-        packetUBXNAVPVT->data.numSV = extractByte(msg, 23);
-        packetUBXNAVPVT->data.lon = extractSignedLong(msg, 24);
-        packetUBXNAVPVT->data.lat = extractSignedLong(msg, 28);
-        packetUBXNAVPVT->data.height = extractSignedLong(msg, 32);
-        packetUBXNAVPVT->data.hMSL = extractSignedLong(msg, 36);
-        packetUBXNAVPVT->data.hAcc = extractLong(msg, 40);
-        packetUBXNAVPVT->data.vAcc = extractLong(msg, 44);
-        packetUBXNAVPVT->data.velN = extractSignedLong(msg, 48);
-        packetUBXNAVPVT->data.velE = extractSignedLong(msg, 52);
-        packetUBXNAVPVT->data.velD = extractSignedLong(msg, 56);
-        packetUBXNAVPVT->data.gSpeed = extractSignedLong(msg, 60);
-        packetUBXNAVPVT->data.headMot = extractSignedLong(msg, 64);
-        packetUBXNAVPVT->data.sAcc = extractLong(msg, 68);
-        packetUBXNAVPVT->data.headAcc = extractLong(msg, 72);
-        packetUBXNAVPVT->data.pDOP = extractInt(msg, 76);
-        packetUBXNAVPVT->data.flags3.all = extractByte(msg, 78);
-        packetUBXNAVPVT->data.headVeh = extractSignedLong(msg, 84);
-        packetUBXNAVPVT->data.magDec = extractSignedInt(msg, 88);
-        packetUBXNAVPVT->data.magAcc = extractInt(msg, 90);
-
-        //Mark all datums as fresh (not read before)
-        packetUBXNAVPVT->moduleQueried.moduleQueried1.all = 0xFFFFFFFF;
-        packetUBXNAVPVT->moduleQueried.moduleQueried2.all = 0xFFFFFFFF;
-
-        //Check if we need to copy the data for the callback
-        if ((packetUBXNAVPVT->callbackData != NULL) // If RAM has been allocated for the copy of the data
-          && (packetUBXNAVPVT->automaticFlags.flags.bits.callbackCopyValid == false)) // AND the data is stale
-        {
-          memcpy(&packetUBXNAVPVT->callbackData->iTOW, &packetUBXNAVPVT->data.iTOW, sizeof(UBX_NAV_PVT_data_t));
-          packetUBXNAVPVT->automaticFlags.flags.bits.callbackCopyValid = true;
-        }
-
-        //Check if we need to copy the data into the file buffer
-        if (packetUBXNAVPVT->automaticFlags.flags.bits.addToFileBuffer)
-        {
-          storePacket(msg);
-        }
-      }
-    }
-    else if (msg->id == UBX_NAV_ODO && msg->len == UBX_NAV_ODO_LEN)
-    {
-      //Parse various byte fields into storage - but only if we have memory allocated for it
-      if (packetUBXNAVODO != NULL)
-      {
-        packetUBXNAVODO->data.version = extractByte(msg, 0);
-        packetUBXNAVODO->data.iTOW = extractLong(msg, 4);
-        packetUBXNAVODO->data.distance = extractLong(msg, 8);
-        packetUBXNAVODO->data.totalDistance = extractLong(msg, 12);
-        packetUBXNAVODO->data.distanceStd = extractLong(msg, 16);
-
-        //Mark all datums as fresh (not read before)
-        packetUBXNAVODO->moduleQueried.moduleQueried.all = 0xFFFFFFFF;
-
-        //Check if we need to copy the data for the callback
-        if ((packetUBXNAVODO->callbackData != NULL) // If RAM has been allocated for the copy of the data
-          && (packetUBXNAVODO->automaticFlags.flags.bits.callbackCopyValid == false)) // AND the data is stale
-        {
-          memcpy(&packetUBXNAVODO->callbackData->version, &packetUBXNAVODO->data.version, sizeof(UBX_NAV_ODO_data_t));
-          packetUBXNAVODO->automaticFlags.flags.bits.callbackCopyValid = true;
-        }
-
-        //Check if we need to copy the data into the file buffer
-        if (packetUBXNAVODO->automaticFlags.flags.bits.addToFileBuffer)
-        {
-          storePacket(msg);
-        }
-      }
-    }
-    else if (msg->id == UBX_NAV_VELECEF && msg->len == UBX_NAV_VELECEF_LEN)
-    {
-      //Parse various byte fields into storage - but only if we have memory allocated for it
-      if (packetUBXNAVVELECEF != NULL)
-      {
-        packetUBXNAVVELECEF->data.iTOW = extractLong(msg, 0);
-        packetUBXNAVVELECEF->data.ecefVX = extractSignedLong(msg, 4);
-        packetUBXNAVVELECEF->data.ecefVY = extractSignedLong(msg, 8);
-        packetUBXNAVVELECEF->data.ecefVZ = extractSignedLong(msg, 12);
-        packetUBXNAVVELECEF->data.sAcc = extractLong(msg, 16);
-
-        //Mark all datums as fresh (not read before)
-        packetUBXNAVVELECEF->moduleQueried.moduleQueried.all = 0xFFFFFFFF;
-
-        //Check if we need to copy the data for the callback
-        if ((packetUBXNAVVELECEF->callbackData != NULL) // If RAM has been allocated for the copy of the data
-          && (packetUBXNAVVELECEF->automaticFlags.flags.bits.callbackCopyValid == false)) // AND the data is stale
-        {
-          memcpy(&packetUBXNAVVELECEF->callbackData->iTOW, &packetUBXNAVVELECEF->data.iTOW, sizeof(UBX_NAV_VELECEF_data_t));
-          packetUBXNAVVELECEF->automaticFlags.flags.bits.callbackCopyValid = true;
-        }
-
-        //Check if we need to copy the data into the file buffer
-        if (packetUBXNAVVELECEF->automaticFlags.flags.bits.addToFileBuffer)
-        {
-          storePacket(msg);
-        }
-      }
-    }
-    else if (msg->id == UBX_NAV_VELNED && msg->len == UBX_NAV_VELNED_LEN)
-    {
-      //Parse various byte fields into storage - but only if we have memory allocated for it
-      if (packetUBXNAVVELNED != NULL)
-      {
-        packetUBXNAVVELNED->data.iTOW = extractLong(msg, 0);
-        packetUBXNAVVELNED->data.velN = extractSignedLong(msg, 4);
-        packetUBXNAVVELNED->data.velE = extractSignedLong(msg, 8);
-        packetUBXNAVVELNED->data.velD = extractSignedLong(msg, 12);
-        packetUBXNAVVELNED->data.speed = extractLong(msg, 16);
-        packetUBXNAVVELNED->data.gSpeed = extractLong(msg, 20);
-        packetUBXNAVVELNED->data.heading = extractSignedLong(msg, 24);
-        packetUBXNAVVELNED->data.sAcc = extractLong(msg, 28);
-        packetUBXNAVVELNED->data.cAcc = extractLong(msg, 32);
-
-        //Mark all datums as fresh (not read before)
-        packetUBXNAVVELNED->moduleQueried.moduleQueried.all = 0xFFFFFFFF;
-
-        //Check if we need to copy the data for the callback
-        if ((packetUBXNAVVELNED->callbackData != NULL) // If RAM has been allocated for the copy of the data
-          && (packetUBXNAVVELNED->automaticFlags.flags.bits.callbackCopyValid == false)) // AND the data is stale
-        {
-          memcpy(&packetUBXNAVVELNED->callbackData->iTOW, &packetUBXNAVVELNED->data.iTOW, sizeof(UBX_NAV_VELNED_data_t));
-          packetUBXNAVVELNED->automaticFlags.flags.bits.callbackCopyValid = true;
-        }
-
-        //Check if we need to copy the data into the file buffer
-        if (packetUBXNAVVELNED->automaticFlags.flags.bits.addToFileBuffer)
-        {
-          storePacket(msg);
-        }
-      }
-    }
-    else if (msg->id == UBX_NAV_HPPOSECEF && msg->len == UBX_NAV_HPPOSECEF_LEN)
-    {
-      //Parse various byte fields into storage - but only if we have memory allocated for it
-      if (packetUBXNAVHPPOSECEF != NULL)
-      {
-        packetUBXNAVHPPOSECEF->data.version = extractByte(msg, 0);
-        packetUBXNAVHPPOSECEF->data.iTOW = extractLong(msg, 4);
-        packetUBXNAVHPPOSECEF->data.ecefX = extractSignedLong(msg, 8);
-        packetUBXNAVHPPOSECEF->data.ecefY = extractSignedLong(msg, 12);
-        packetUBXNAVHPPOSECEF->data.ecefZ = extractSignedLong(msg, 16);
-        packetUBXNAVHPPOSECEF->data.ecefXHp = extractSignedChar(msg, 20);
-        packetUBXNAVHPPOSECEF->data.ecefYHp = extractSignedChar(msg, 21);
-        packetUBXNAVHPPOSECEF->data.ecefZHp = extractSignedChar(msg, 22);
-        packetUBXNAVHPPOSECEF->data.flags.all = extractByte(msg, 23);
-        packetUBXNAVHPPOSECEF->data.pAcc = extractLong(msg, 24);
-
-        //Mark all datums as fresh (not read before)
-        packetUBXNAVHPPOSECEF->moduleQueried.moduleQueried.all = 0xFFFFFFFF;
-
-        //Check if we need to copy the data for the callback
-        if ((packetUBXNAVHPPOSECEF->callbackData != NULL) // If RAM has been allocated for the copy of the data
-          && (packetUBXNAVHPPOSECEF->automaticFlags.flags.bits.callbackCopyValid == false)) // AND the data is stale
-        {
-          memcpy(&packetUBXNAVHPPOSECEF->callbackData->version, &packetUBXNAVHPPOSECEF->data.version, sizeof(UBX_NAV_HPPOSECEF_data_t));
-          packetUBXNAVHPPOSECEF->automaticFlags.flags.bits.callbackCopyValid = true;
-        }
-
-        //Check if we need to copy the data into the file buffer
-        if (packetUBXNAVHPPOSECEF->automaticFlags.flags.bits.addToFileBuffer)
-        {
-          storePacket(msg);
-        }
-      }
-    }
-    else if (msg->id == UBX_NAV_HPPOSLLH && msg->len == UBX_NAV_HPPOSLLH_LEN)
-    {
-      //Parse various byte fields into storage - but only if we have memory allocated for it
-      if (packetUBXNAVHPPOSLLH != NULL)
-      {
-        packetUBXNAVHPPOSLLH->data.version = extractByte(msg, 0);
-        packetUBXNAVHPPOSLLH->data.flags.all = extractByte(msg, 3);
-        packetUBXNAVHPPOSLLH->data.iTOW = extractLong(msg, 4);
-        packetUBXNAVHPPOSLLH->data.lon = extractSignedLong(msg, 8);
-        packetUBXNAVHPPOSLLH->data.lat = extractSignedLong(msg, 12);
-        packetUBXNAVHPPOSLLH->data.height = extractSignedLong(msg, 16);
-        packetUBXNAVHPPOSLLH->data.hMSL = extractSignedLong(msg, 20);
-        packetUBXNAVHPPOSLLH->data.lonHp = extractSignedChar(msg, 24);
-        packetUBXNAVHPPOSLLH->data.latHp = extractSignedChar(msg, 25);
-        packetUBXNAVHPPOSLLH->data.heightHp = extractSignedChar(msg, 26);
-        packetUBXNAVHPPOSLLH->data.hMSLHp = extractSignedChar(msg, 27);
-        packetUBXNAVHPPOSLLH->data.hAcc = extractLong(msg, 28);
-        packetUBXNAVHPPOSLLH->data.vAcc = extractLong(msg, 32);
-
-        //Mark all datums as fresh (not read before)
-        packetUBXNAVHPPOSLLH->moduleQueried.moduleQueried.all = 0xFFFFFFFF;
-
-        //Check if we need to copy the data for the callback
-        if ((packetUBXNAVHPPOSLLH->callbackData != NULL) // If RAM has been allocated for the copy of the data
-          && (packetUBXNAVHPPOSLLH->automaticFlags.flags.bits.callbackCopyValid == false)) // AND the data is stale
-        {
-          memcpy(&packetUBXNAVHPPOSLLH->callbackData->version, &packetUBXNAVHPPOSLLH->data.version, sizeof(UBX_NAV_HPPOSLLH_data_t));
-          packetUBXNAVHPPOSLLH->automaticFlags.flags.bits.callbackCopyValid = true;
-        }
-
-        //Check if we need to copy the data into the file buffer
-        if (packetUBXNAVHPPOSLLH->automaticFlags.flags.bits.addToFileBuffer)
-        {
-          storePacket(msg);
-        }
-      }
-    }
-    else if (msg->id == UBX_NAV_CLOCK && msg->len == UBX_NAV_CLOCK_LEN)
-    {
-      //Parse various byte fields into storage - but only if we have memory allocated for it
-      if (packetUBXNAVCLOCK != NULL)
-      {
-        packetUBXNAVCLOCK->data.iTOW = extractLong(msg, 0);
-        packetUBXNAVCLOCK->data.clkB = extractSignedLong(msg, 4);
-        packetUBXNAVCLOCK->data.clkD = extractSignedLong(msg, 8);
-        packetUBXNAVCLOCK->data.tAcc = extractLong(msg, 12);
-        packetUBXNAVCLOCK->data.fAcc = extractLong(msg, 16);
-
-        //Mark all datums as fresh (not read before)
-        packetUBXNAVCLOCK->moduleQueried.moduleQueried.all = 0xFFFFFFFF;
-
-        //Check if we need to copy the data for the callback
-        if ((packetUBXNAVCLOCK->callbackData != NULL) // If RAM has been allocated for the copy of the data
-          && (packetUBXNAVCLOCK->automaticFlags.flags.bits.callbackCopyValid == false)) // AND the data is stale
-        {
-          memcpy(&packetUBXNAVCLOCK->callbackData->iTOW, &packetUBXNAVCLOCK->data.iTOW, sizeof(UBX_NAV_CLOCK_data_t));
-          packetUBXNAVCLOCK->automaticFlags.flags.bits.callbackCopyValid = true;
-        }
-
-        //Check if we need to copy the data into the file buffer
-        if (packetUBXNAVCLOCK->automaticFlags.flags.bits.addToFileBuffer)
-        {
-          storePacket(msg);
-        }
-      }
-    }
-    else if (msg->id == UBX_NAV_SVIN && msg->len == UBX_NAV_SVIN_LEN)
-    {
-      //Parse various byte fields into storage - but only if we have memory allocated for it
-      if (packetUBXNAVSVIN != NULL)
-      {
-        packetUBXNAVSVIN->data.version = extractByte(msg, 0);
-        packetUBXNAVSVIN->data.iTOW = extractLong(msg, 4);
-        packetUBXNAVSVIN->data.dur = extractLong(msg, 8);
-        packetUBXNAVSVIN->data.meanX = extractSignedLong(msg, 12);
-        packetUBXNAVSVIN->data.meanY = extractSignedLong(msg, 16);
-        packetUBXNAVSVIN->data.meanZ = extractSignedLong(msg, 20);
-        packetUBXNAVSVIN->data.meanXHP = extractSignedChar(msg, 24);
-        packetUBXNAVSVIN->data.meanYHP = extractSignedChar(msg, 25);
-        packetUBXNAVSVIN->data.meanZHP = extractSignedChar(msg, 26);
-        packetUBXNAVSVIN->data.meanAcc = extractLong(msg, 28);
-        packetUBXNAVSVIN->data.obs = extractLong(msg, 32);
-        packetUBXNAVSVIN->data.valid = extractSignedChar(msg, 36);
-        packetUBXNAVSVIN->data.active = extractSignedChar(msg, 37);
-
-        //Mark all datums as fresh (not read before)
-        packetUBXNAVSVIN->moduleQueried.moduleQueried.all = 0xFFFFFFFF;
-      }
-    }
-    else if (msg->id == UBX_NAV_RELPOSNED && ((msg->len == UBX_NAV_RELPOSNED_LEN) || (msg->len == UBX_NAV_RELPOSNED_LEN_F9)))
-    {
-      //Parse various byte fields into storage - but only if we have memory allocated for it
-      if (packetUBXNAVRELPOSNED != NULL)
-      {
-        //Note:
-        //  RELPOSNED on the M8 is only 40 bytes long
-        //  RELPOSNED on the F9 is 64 bytes long and contains much more information
-
-        packetUBXNAVRELPOSNED->data.version = extractByte(msg, 0);
-        packetUBXNAVRELPOSNED->data.refStationId = extractInt(msg, 2);
-        packetUBXNAVRELPOSNED->data.iTOW = extractLong(msg, 4);
-        packetUBXNAVRELPOSNED->data.relPosN = extractSignedLong(msg, 8);
-        packetUBXNAVRELPOSNED->data.relPosE = extractSignedLong(msg, 12);
-        packetUBXNAVRELPOSNED->data.relPosD = extractSignedLong(msg, 16);
-
-        if (msg->len == UBX_NAV_RELPOSNED_LEN)
-        {
-          // The M8 version does not contain relPosLength or relPosHeading
-          packetUBXNAVRELPOSNED->data.relPosLength = 0;
-          packetUBXNAVRELPOSNED->data.relPosHeading = 0;
-          packetUBXNAVRELPOSNED->data.relPosHPN = extractSignedChar(msg, 20);
-          packetUBXNAVRELPOSNED->data.relPosHPE = extractSignedChar(msg, 21);
-          packetUBXNAVRELPOSNED->data.relPosHPD = extractSignedChar(msg, 22);
-          packetUBXNAVRELPOSNED->data.relPosHPLength = 0; // The M8 version does not contain relPosHPLength
-          packetUBXNAVRELPOSNED->data.accN = extractLong(msg, 24);
-          packetUBXNAVRELPOSNED->data.accE = extractLong(msg, 28);
-          packetUBXNAVRELPOSNED->data.accD = extractLong(msg, 32);
-          // The M8 version does not contain accLength or accHeading
-          packetUBXNAVRELPOSNED->data.accLength = 0;
-          packetUBXNAVRELPOSNED->data.accHeading = 0;
-          packetUBXNAVRELPOSNED->data.flags.all = extractLong(msg, 36);
-        }
-        else
-        {
-          packetUBXNAVRELPOSNED->data.relPosLength = extractSignedLong(msg, 20);
-          packetUBXNAVRELPOSNED->data.relPosHeading = extractSignedLong(msg, 24);
-          packetUBXNAVRELPOSNED->data.relPosHPN = extractSignedChar(msg, 32);
-          packetUBXNAVRELPOSNED->data.relPosHPE = extractSignedChar(msg, 33);
-          packetUBXNAVRELPOSNED->data.relPosHPD = extractSignedChar(msg, 34);
-          packetUBXNAVRELPOSNED->data.relPosHPLength = extractSignedChar(msg, 35);
-          packetUBXNAVRELPOSNED->data.accN = extractLong(msg, 36);
-          packetUBXNAVRELPOSNED->data.accE = extractLong(msg, 40);
-          packetUBXNAVRELPOSNED->data.accD = extractLong(msg, 44);
-          packetUBXNAVRELPOSNED->data.accLength = extractLong(msg, 48);
-          packetUBXNAVRELPOSNED->data.accHeading = extractLong(msg, 52);
-          packetUBXNAVRELPOSNED->data.flags.all = extractLong(msg, 60);
-        }
-
-        //Mark all datums as fresh (not read before)
-        packetUBXNAVRELPOSNED->moduleQueried.moduleQueried.all = 0xFFFFFFFF;
-
-        //Check if we need to copy the data for the callback
-        if ((packetUBXNAVRELPOSNED->callbackData != NULL) // If RAM has been allocated for the copy of the data
-          && (packetUBXNAVRELPOSNED->automaticFlags.flags.bits.callbackCopyValid == false)) // AND the data is stale
-        {
-          memcpy(&packetUBXNAVRELPOSNED->callbackData->version, &packetUBXNAVRELPOSNED->data.version, sizeof(UBX_NAV_RELPOSNED_data_t));
-          packetUBXNAVRELPOSNED->automaticFlags.flags.bits.callbackCopyValid = true;
-        }
-
-        //Check if we need to copy the data into the file buffer
-        if (packetUBXNAVRELPOSNED->automaticFlags.flags.bits.addToFileBuffer)
-        {
-          storePacket(msg);
-        }
-      }
-    }
-    break;
-  case UBX_CLASS_RXM:
-    if (msg->id == UBX_RXM_SFRBX)
-    // Note: length is variable
-    // Note: on protocol version 17: numWords is (0..16)
-    //       on protocol version 18+: numWords is (0..10)
-    {
-      //Parse various byte fields into storage - but only if we have memory allocated for it
-      if (packetUBXRXMSFRBX != NULL)
-      {
-        packetUBXRXMSFRBX->data.gnssId = extractByte(msg, 0);
-        packetUBXRXMSFRBX->data.svId = extractByte(msg, 1);
-        packetUBXRXMSFRBX->data.freqId = extractByte(msg, 3);
-        packetUBXRXMSFRBX->data.numWords = extractByte(msg, 4);
-        packetUBXRXMSFRBX->data.chn = extractByte(msg, 5);
-        packetUBXRXMSFRBX->data.version = extractByte(msg, 6);
-
-        for (uint8_t i = 0; (i < UBX_RXM_SFRBX_MAX_WORDS) && (i < packetUBXRXMSFRBX->data.numWords)
-          && ((i * 4) < (msg->len - 8)); i++)
-        {
-          packetUBXRXMSFRBX->data.dwrd[i] = extractLong(msg, 8 + (i * 4));
-        }
-
-        //Mark all datums as fresh (not read before)
-        packetUBXRXMSFRBX->moduleQueried = true;
-
-        //Check if we need to copy the data for the callback
-        if ((packetUBXRXMSFRBX->callbackData != NULL) // If RAM has been allocated for the copy of the data
-          && (packetUBXRXMSFRBX->automaticFlags.flags.bits.callbackCopyValid == false)) // AND the data is stale
-        {
-          memcpy(&packetUBXRXMSFRBX->callbackData->gnssId, &packetUBXRXMSFRBX->data.gnssId, sizeof(UBX_RXM_SFRBX_data_t));
-          packetUBXRXMSFRBX->automaticFlags.flags.bits.callbackCopyValid = true;
-        }
-
-        //Check if we need to copy the data into the file buffer
-        if (packetUBXRXMSFRBX->automaticFlags.flags.bits.addToFileBuffer)
-        {
-          storePacket(msg);
-        }
-      }
-    }
-    else if (msg->id == UBX_RXM_RAWX)
-    // Note: length is variable
-    {
-      //Parse various byte fields into storage - but only if we have memory allocated for it
-      if (packetUBXRXMRAWX != NULL)
-      {
-        for (uint8_t i = 0; i < 8; i++)
-        {
-          packetUBXRXMRAWX->data.header.rcvTow[i] = extractByte(msg, i);
-        }
-        packetUBXRXMRAWX->data.header.week = extractInt(msg, 8);
-        packetUBXRXMRAWX->data.header.leapS = extractSignedChar(msg, 10);
-        packetUBXRXMRAWX->data.header.numMeas = extractByte(msg, 11);
-        packetUBXRXMRAWX->data.header.recStat.all = extractByte(msg, 12);
-        packetUBXRXMRAWX->data.header.version = extractByte(msg, 13);
-
-        for (uint8_t i = 0; (i < UBX_RXM_RAWX_MAX_BLOCKS) && (i < packetUBXRXMRAWX->data.header.numMeas)
-          && ((((uint16_t)i) * 32) < (msg->len - 16)); i++)
-        {
-          uint16_t offset = (((uint16_t)i) * 32) + 16;
-          for (uint8_t j = 0; j < 8; j++)
-          {
-            packetUBXRXMRAWX->data.blocks[i].prMes[j] = extractByte(msg, offset + j);
-            packetUBXRXMRAWX->data.blocks[i].cpMes[j] = extractByte(msg, offset + 8 + j);
-            if (j < 4)
-              packetUBXRXMRAWX->data.blocks[i].doMes[j] = extractByte(msg, offset + 16 + j);
-          }
-          packetUBXRXMRAWX->data.blocks[i].gnssId = extractByte(msg, offset + 20);
-          packetUBXRXMRAWX->data.blocks[i].svId = extractByte(msg, offset + 21);
-          packetUBXRXMRAWX->data.blocks[i].sigId = extractByte(msg, offset + 22);
-          packetUBXRXMRAWX->data.blocks[i].freqId = extractByte(msg, offset + 23);
-          packetUBXRXMRAWX->data.blocks[i].lockTime = extractInt(msg, offset + 24);
-          packetUBXRXMRAWX->data.blocks[i].cno = extractByte(msg, offset + 26);
-          packetUBXRXMRAWX->data.blocks[i].prStdev = extractByte(msg, offset + 27);
-          packetUBXRXMRAWX->data.blocks[i].cpStdev = extractByte(msg, offset + 28);
-          packetUBXRXMRAWX->data.blocks[i].doStdev = extractByte(msg, offset + 29);
-          packetUBXRXMRAWX->data.blocks[i].trkStat.all = extractByte(msg, offset + 30);
-        }
-
-        //Mark all datums as fresh (not read before)
-        packetUBXRXMRAWX->moduleQueried = true;
-
-        //Check if we need to copy the data for the callback
-        if ((packetUBXRXMRAWX->callbackData != NULL) // If RAM has been allocated for the copy of the data
-          && (packetUBXRXMRAWX->automaticFlags.flags.bits.callbackCopyValid == false)) // AND the data is stale
-        {
-          memcpy(&packetUBXRXMRAWX->callbackData->header.rcvTow[0], &packetUBXRXMRAWX->data.header.rcvTow[0], sizeof(UBX_RXM_RAWX_data_t));
-          packetUBXRXMRAWX->automaticFlags.flags.bits.callbackCopyValid = true;
-        }
-
-        //Check if we need to copy the data into the file buffer
-        if (packetUBXRXMRAWX->automaticFlags.flags.bits.addToFileBuffer)
-        {
-          storePacket(msg);
-        }
-      }
-    }
-    break;
-  case UBX_CLASS_CFG:
-    if (msg->id == UBX_CFG_RATE && msg->len == UBX_CFG_RATE_LEN)
-    {
-      //Parse various byte fields into storage - but only if we have memory allocated for it
-      if (packetUBXCFGRATE != NULL)
-      {
-        packetUBXCFGRATE->data.measRate = extractInt(msg, 0);
-        packetUBXCFGRATE->data.navRate = extractInt(msg, 2);
-        packetUBXCFGRATE->data.timeRef = extractInt(msg, 4);
-
-        //Mark all datums as fresh (not read before)
-        packetUBXCFGRATE->moduleQueried.moduleQueried.all = 0xFFFFFFFF;
-      }
-    }
-    break;
-  case UBX_CLASS_TIM:
-    if (msg->id == UBX_TIM_TM2 && msg->len == UBX_TIM_TM2_LEN)
-    {
-      //Parse various byte fields into storage - but only if we have memory allocated for it
-      if (packetUBXTIMTM2 != NULL)
-      {
-        packetUBXTIMTM2->data.ch = extractByte(msg, 0);
-        packetUBXTIMTM2->data.flags.all = extractByte(msg, 1);
-        packetUBXTIMTM2->data.count = extractInt(msg, 2);
-        packetUBXTIMTM2->data.wnR = extractInt(msg, 4);
-        packetUBXTIMTM2->data.wnF = extractInt(msg, 6);
-        packetUBXTIMTM2->data.towMsR = extractLong(msg, 8);
-        packetUBXTIMTM2->data.towSubMsR = extractLong(msg, 12);
-        packetUBXTIMTM2->data.towMsF = extractLong(msg, 16);
-        packetUBXTIMTM2->data.towSubMsF = extractLong(msg, 20);
-        packetUBXTIMTM2->data.accEst = extractLong(msg, 24);
-
-        //Mark all datums as fresh (not read before)
-        packetUBXTIMTM2->moduleQueried.moduleQueried.all = 0xFFFFFFFF;
-
-        //Check if we need to copy the data for the callback
-        if ((packetUBXTIMTM2->callbackData != NULL) // If RAM has been allocated for the copy of the data
-          && (packetUBXTIMTM2->automaticFlags.flags.bits.callbackCopyValid == false)) // AND the data is stale
-        {
-          memcpy(&packetUBXTIMTM2->callbackData->ch, &packetUBXTIMTM2->data.ch, sizeof(UBX_TIM_TM2_data_t));
-          packetUBXTIMTM2->automaticFlags.flags.bits.callbackCopyValid = true;
-        }
-
-        //Check if we need to copy the data into the file buffer
-        if (packetUBXTIMTM2->automaticFlags.flags.bits.addToFileBuffer)
-        {
-          storePacket(msg);
-        }
-      }
-    }
-    break;
-  case UBX_CLASS_ESF:
-    if (msg->id == UBX_ESF_ALG && msg->len == UBX_ESF_ALG_LEN)
-    {
-      //Parse various byte fields into storage - but only if we have memory allocated for it
-      if (packetUBXESFALG != NULL)
-      {
-        packetUBXESFALG->data.iTOW = extractLong(msg, 0);
-        packetUBXESFALG->data.version = extractByte(msg, 4);
-        packetUBXESFALG->data.flags.all = extractByte(msg, 5);
-        packetUBXESFALG->data.error.all = extractByte(msg, 6);
-        packetUBXESFALG->data.yaw = extractLong(msg, 8);
-        packetUBXESFALG->data.pitch = extractSignedInt(msg, 12);
-        packetUBXESFALG->data.roll = extractSignedInt(msg, 14);
-
-        //Mark all datums as fresh (not read before)
-        packetUBXESFALG->moduleQueried.moduleQueried.all = 0xFFFFFFFF;
-
-        //Check if we need to copy the data for the callback
-        if ((packetUBXESFALG->callbackData != NULL) // If RAM has been allocated for the copy of the data
-          && (packetUBXESFALG->automaticFlags.flags.bits.callbackCopyValid == false)) // AND the data is stale
-        {
-          memcpy(&packetUBXESFALG->callbackData->iTOW, &packetUBXESFALG->data.iTOW, sizeof(UBX_ESF_ALG_data_t));
-          packetUBXESFALG->automaticFlags.flags.bits.callbackCopyValid = true;
-        }
-
-        //Check if we need to copy the data into the file buffer
-        if (packetUBXESFALG->automaticFlags.flags.bits.addToFileBuffer)
-        {
-          storePacket(msg);
-        }
-      }
-    }
-    else if (msg->id == UBX_ESF_INS && msg->len == UBX_ESF_INS_LEN)
-    {
-      //Parse various byte fields into storage - but only if we have memory allocated for it
-      if (packetUBXESFINS != NULL)
-      {
-        packetUBXESFINS->data.bitfield0.all = extractLong(msg, 0);
-        packetUBXESFINS->data.iTOW = extractLong(msg, 8);
-        packetUBXESFINS->data.xAngRate = extractSignedLong(msg, 12);
-        packetUBXESFINS->data.yAngRate = extractSignedLong(msg, 16);
-        packetUBXESFINS->data.zAngRate = extractSignedLong(msg, 20);
-        packetUBXESFINS->data.xAccel = extractSignedLong(msg, 24);
-        packetUBXESFINS->data.yAccel = extractSignedLong(msg, 28);
-        packetUBXESFINS->data.zAccel = extractSignedLong(msg, 32);
-
-        //Mark all datums as fresh (not read before)
-        packetUBXESFINS->moduleQueried.moduleQueried.all = 0xFFFFFFFF;
-
-        //Check if we need to copy the data for the callback
-        if ((packetUBXESFINS->callbackData != NULL) // If RAM has been allocated for the copy of the data
-          && (packetUBXESFINS->automaticFlags.flags.bits.callbackCopyValid == false)) // AND the data is stale
-        {
-          memcpy(&packetUBXESFINS->callbackData->bitfield0.all, &packetUBXESFINS->data.bitfield0.all, sizeof(UBX_ESF_INS_data_t));
-          packetUBXESFINS->automaticFlags.flags.bits.callbackCopyValid = true;
-        }
-
-        //Check if we need to copy the data into the file buffer
-        if (packetUBXESFINS->automaticFlags.flags.bits.addToFileBuffer)
-        {
-          storePacket(msg);
-        }
-      }
-    }
-    else if (msg->id == UBX_ESF_MEAS)
-    {
-      //Parse various byte fields into storage - but only if we have memory allocated for it
-      if (packetUBXESFMEAS != NULL)
-      {
-        packetUBXESFMEAS->data.timeTag = extractLong(msg, 0);
-        packetUBXESFMEAS->data.flags.all = extractInt(msg, 4);
-        packetUBXESFMEAS->data.id = extractInt(msg, 6);
-        for (int i = 0; (i < DEF_NUM_SENS) && (i < packetUBXESFMEAS->data.flags.bits.numMeas)
-          && ((i * 4) < (msg->len - 8)); i++)
-        {
-          packetUBXESFMEAS->data.data[i].data.all = extractLong(msg, 8 + (i * 4));
-        }
-        if (msg->len > (8 + (packetUBXESFMEAS->data.flags.bits.numMeas * 4)))
-          packetUBXESFMEAS->data.calibTtag = extractLong(msg, 8 + (packetUBXESFMEAS->data.flags.bits.numMeas * 4));
-
-        //Mark all datums as fresh (not read before)
-        packetUBXESFMEAS->moduleQueried.moduleQueried.all = 0xFFFFFFFF;
-
-        //Check if we need to copy the data for the callback
-        if ((packetUBXESFMEAS->callbackData != NULL) // If RAM has been allocated for the copy of the data
-          && (packetUBXESFMEAS->automaticFlags.flags.bits.callbackCopyValid == false)) // AND the data is stale
-        {
-          memcpy(&packetUBXESFMEAS->callbackData->timeTag, &packetUBXESFMEAS->data.timeTag, sizeof(UBX_ESF_MEAS_data_t));
-          packetUBXESFMEAS->automaticFlags.flags.bits.callbackCopyValid = true;
-        }
-
-        //Check if we need to copy the data into the file buffer
-        if (packetUBXESFMEAS->automaticFlags.flags.bits.addToFileBuffer)
-        {
-          storePacket(msg);
-        }
-      }
-    }
-    else if (msg->id == UBX_ESF_RAW)
-    {
-      //Parse various byte fields into storage - but only if we have memory allocated for it
-      if (packetUBXESFRAW != NULL)
-      {
-        for (int i = 0; (i < DEF_NUM_SENS) && ((i * 8) < (msg->len - 4)); i++)
-        {
-          packetUBXESFRAW->data.data[i].data.all = extractLong(msg, 8 + (i * 8));
-          packetUBXESFRAW->data.data[i].sTag = extractLong(msg, 8 + (i * 8) + 4);
-        }
-
-        //Mark all datums as fresh (not read before)
-        packetUBXESFRAW->moduleQueried.moduleQueried.all = 0xFFFFFFFF;
-
-        //Check if we need to copy the data for the callback
-        if ((packetUBXESFRAW->callbackData != NULL) // If RAM has been allocated for the copy of the data
-          && (packetUBXESFRAW->automaticFlags.flags.bits.callbackCopyValid == false)) // AND the data is stale
-        {
-          memcpy(&packetUBXESFRAW->callbackData->data[0].data.all, &packetUBXESFRAW->data.data[0].data.all, sizeof(UBX_ESF_RAW_data_t));
-          packetUBXESFRAW->automaticFlags.flags.bits.callbackCopyValid = true;
-        }
-
-        //Check if we need to copy the data into the file buffer
-        if (packetUBXESFRAW->automaticFlags.flags.bits.addToFileBuffer)
-        {
-          storePacket(msg);
-        }
-      }
-    }
-    else if (msg->id == UBX_ESF_STATUS)
-    {
-      //Parse various byte fields into storage - but only if we have memory allocated for it
-      if (packetUBXESFSTATUS != NULL)
-      {
-        packetUBXESFSTATUS->data.iTOW = extractLong(msg, 0);
-        packetUBXESFSTATUS->data.version = extractByte(msg, 4);
-        packetUBXESFSTATUS->data.fusionMode = extractByte(msg, 12);
-        packetUBXESFSTATUS->data.numSens = extractByte(msg, 15);
-        for (int i = 0; (i < DEF_NUM_SENS) && (i < packetUBXESFSTATUS->data.numSens)
-          && ((i * 4) < (msg->len - 16)); i++)
-        {
-          packetUBXESFSTATUS->data.status[i].sensStatus1.all = extractByte(msg, 16 + (i * 4) + 0);
-          packetUBXESFSTATUS->data.status[i].sensStatus2.all = extractByte(msg, 16 + (i * 4) + 1);
-          packetUBXESFSTATUS->data.status[i].freq = extractByte(msg, 16 + (i * 4) + 2);
-          packetUBXESFSTATUS->data.status[i].faults.all = extractByte(msg, 16 + (i * 4) + 3);
-        }
-
-        //Mark all datums as fresh (not read before)
-        packetUBXESFSTATUS->moduleQueried.moduleQueried.all = 0xFFFFFFFF;
-
-        //Check if we need to copy the data for the callback
-        if ((packetUBXESFSTATUS->callbackData != NULL) // If RAM has been allocated for the copy of the data
-          && (packetUBXESFSTATUS->automaticFlags.flags.bits.callbackCopyValid == false)) // AND the data is stale
-        {
-          memcpy(&packetUBXESFSTATUS->callbackData->iTOW, &packetUBXESFSTATUS->data.iTOW, sizeof(UBX_ESF_STATUS_data_t));
-          packetUBXESFSTATUS->automaticFlags.flags.bits.callbackCopyValid = true;
-        }
-
-        //Check if we need to copy the data into the file buffer
-        if (packetUBXESFSTATUS->automaticFlags.flags.bits.addToFileBuffer)
-        {
-          storePacket(msg);
-        }
-      }
-    }
-    break;
-  case UBX_CLASS_HNR:
-    if (msg->id == UBX_HNR_PVT && msg->len == UBX_HNR_PVT_LEN)
-    {
-      //Parse various byte fields into storage - but only if we have memory allocated for it
-      if (packetUBXHNRPVT != NULL)
-      {
-        packetUBXHNRPVT->data.iTOW = extractLong(msg, 0);
-        packetUBXHNRPVT->data.year = extractInt(msg, 4);
-        packetUBXHNRPVT->data.month = extractByte(msg, 6);
-        packetUBXHNRPVT->data.day = extractByte(msg, 7);
-        packetUBXHNRPVT->data.hour = extractByte(msg, 8);
-        packetUBXHNRPVT->data.min = extractByte(msg, 9);
-        packetUBXHNRPVT->data.sec = extractByte(msg, 10);
-        packetUBXHNRPVT->data.valid.all = extractByte(msg, 11);
-        packetUBXHNRPVT->data.nano = extractSignedLong(msg, 12);
-        packetUBXHNRPVT->data.gpsFix = extractByte(msg, 16);
-        packetUBXHNRPVT->data.flags.all = extractByte(msg, 17);
-        packetUBXHNRPVT->data.lon = extractSignedLong(msg, 20);
-        packetUBXHNRPVT->data.lat = extractSignedLong(msg, 24);
-        packetUBXHNRPVT->data.height = extractSignedLong(msg, 28);
-        packetUBXHNRPVT->data.hMSL = extractSignedLong(msg, 32);
-        packetUBXHNRPVT->data.gSpeed = extractSignedLong(msg, 36);
-        packetUBXHNRPVT->data.speed = extractSignedLong(msg, 40);
-        packetUBXHNRPVT->data.headMot = extractSignedLong(msg, 44);
-        packetUBXHNRPVT->data.headVeh = extractSignedLong(msg, 48);
-        packetUBXHNRPVT->data.hAcc = extractLong(msg, 52);
-        packetUBXHNRPVT->data.vAcc = extractLong(msg, 56);
-        packetUBXHNRPVT->data.sAcc = extractLong(msg, 60);
-        packetUBXHNRPVT->data.headAcc = extractLong(msg, 64);
-
-        //Mark all datums as fresh (not read before)
-        packetUBXHNRPVT->moduleQueried.moduleQueried.all = 0xFFFFFFFF;
-
-        //Check if we need to copy the data for the callback
-        if ((packetUBXHNRPVT->callbackData != NULL) // If RAM has been allocated for the copy of the data
-          && (packetUBXHNRPVT->automaticFlags.flags.bits.callbackCopyValid == false)) // AND the data is stale
-        {
-          memcpy(&packetUBXHNRPVT->callbackData->iTOW, &packetUBXHNRPVT->data.iTOW, sizeof(UBX_HNR_PVT_data_t));
-          packetUBXHNRPVT->automaticFlags.flags.bits.callbackCopyValid = true;
-        }
-
-        //Check if we need to copy the data into the file buffer
-        if (packetUBXHNRPVT->automaticFlags.flags.bits.addToFileBuffer)
-        {
-          storePacket(msg);
-        }
-      }
-    }
-    else if (msg->id == UBX_HNR_ATT && msg->len == UBX_HNR_ATT_LEN)
-    {
-      //Parse various byte fields into storage - but only if we have memory allocated for it
-      if (packetUBXHNRATT != NULL)
-      {
-        packetUBXHNRATT->data.iTOW = extractLong(msg, 0);
-        packetUBXHNRATT->data.version = extractByte(msg, 4);
-        packetUBXHNRATT->data.roll = extractSignedLong(msg, 8);
-        packetUBXHNRATT->data.pitch = extractSignedLong(msg, 12);
-        packetUBXHNRATT->data.heading = extractSignedLong(msg, 16);
-        packetUBXHNRATT->data.accRoll = extractLong(msg, 20);
-        packetUBXHNRATT->data.accPitch = extractLong(msg, 24);
-        packetUBXHNRATT->data.accHeading = extractLong(msg, 28);
-
-        //Mark all datums as fresh (not read before)
-        packetUBXHNRATT->moduleQueried.moduleQueried.all = 0xFFFFFFFF;
-
-        //Check if we need to copy the data for the callback
-        if ((packetUBXHNRATT->callbackData != NULL) // If RAM has been allocated for the copy of the data
-          && (packetUBXHNRATT->automaticFlags.flags.bits.callbackCopyValid == false)) // AND the data is stale
-        {
-          memcpy(&packetUBXHNRATT->callbackData->iTOW, &packetUBXHNRATT->data.iTOW, sizeof(UBX_HNR_ATT_data_t));
-          packetUBXHNRATT->automaticFlags.flags.bits.callbackCopyValid = true;
-        }
-
-        //Check if we need to copy the data into the file buffer
-        if (packetUBXHNRATT->automaticFlags.flags.bits.addToFileBuffer)
-        {
-          storePacket(msg);
-        }
-      }
-    }
-    else if (msg->id == UBX_HNR_INS && msg->len == UBX_HNR_INS_LEN)
-    {
-      //Parse various byte fields into storage - but only if we have memory allocated for it
-      if (packetUBXHNRINS != NULL)
-      {
-        packetUBXHNRINS->data.bitfield0.all = extractLong(msg, 0);
-        packetUBXHNRINS->data.iTOW = extractLong(msg, 8);
-        packetUBXHNRINS->data.xAngRate = extractSignedLong(msg, 12);
-        packetUBXHNRINS->data.yAngRate = extractSignedLong(msg, 16);
-        packetUBXHNRINS->data.zAngRate = extractSignedLong(msg, 20);
-        packetUBXHNRINS->data.xAccel = extractSignedLong(msg, 24);
-        packetUBXHNRINS->data.yAccel = extractSignedLong(msg, 28);
-        packetUBXHNRINS->data.zAccel = extractSignedLong(msg, 32);
-
-        //Mark all datums as fresh (not read before)
-        packetUBXHNRINS->moduleQueried.moduleQueried.all = 0xFFFFFFFF;
-
-        //Check if we need to copy the data for the callback
-        if ((packetUBXHNRINS->callbackData != NULL) // If RAM has been allocated for the copy of the data
-          && (packetUBXHNRINS->automaticFlags.flags.bits.callbackCopyValid == false)) // AND the data is stale
-        {
-          memcpy(&packetUBXHNRINS->callbackData->bitfield0.all, &packetUBXHNRINS->data.bitfield0.all, sizeof(UBX_HNR_INS_data_t));
-          packetUBXHNRINS->automaticFlags.flags.bits.callbackCopyValid = true;
-        }
-
-        //Check if we need to copy the data into the file buffer
-        if (packetUBXHNRINS->automaticFlags.flags.bits.addToFileBuffer)
-        {
-          storePacket(msg);
-        }
-      }
-    }
-    break;
-  }
-}
-
-//Given a message, calc and store the two byte "8-Bit Fletcher" checksum over the entirety of the message
-//This is called before we send a command message
-void SFE_UBLOX_GNSS::calcChecksum(ubxPacket *msg)
-{
-  msg->checksumA = 0;
-  msg->checksumB = 0;
-
-  msg->checksumA += msg->cls;
-  msg->checksumB += msg->checksumA;
-
-  msg->checksumA += msg->id;
-  msg->checksumB += msg->checksumA;
-
-  msg->checksumA += (msg->len & 0xFF);
-  msg->checksumB += msg->checksumA;
-
-  msg->checksumA += (msg->len >> 8);
-  msg->checksumB += msg->checksumA;
-
-  for (uint16_t i = 0; i < msg->len; i++)
-  {
-    msg->checksumA += msg->payload[i];
-    msg->checksumB += msg->checksumA;
-  }
-}
-
-//Given a message and a byte, add to rolling "8-Bit Fletcher" checksum
-//This is used when receiving messages from module
-void SFE_UBLOX_GNSS::addToChecksum(uint8_t incoming)
-{
-  rollingChecksumA += incoming;
-  rollingChecksumB += rollingChecksumA;
-}
-
-//Given a packet and payload, send everything including CRC bytes via I2C port
-sfe_ublox_status_e SFE_UBLOX_GNSS::sendCommand(ubxPacket *outgoingUBX, uint16_t maxWait, boolean expectACKonly)
-{
-  sfe_ublox_status_e retVal = SFE_UBLOX_STATUS_SUCCESS;
-
-  calcChecksum(outgoingUBX); //Sets checksum A and B bytes of the packet
-
-  if (_printDebug == true)
-  {
-    _debugSerial->print(F("\nSending: "));
-    printPacket(outgoingUBX, true); // Always print payload
-  }
-
-  if (commType == COMM_TYPE_I2C)
-  {
-    retVal = sendI2cCommand(outgoingUBX, maxWait);
-    if (retVal != SFE_UBLOX_STATUS_SUCCESS)
-    {
-      if (_printDebug == true)
-      {
-        _debugSerial->println(F("Send I2C Command failed"));
-      }
-      return retVal;
-    }
-  }
-  else if (commType == COMM_TYPE_SERIAL)
-  {
-    sendSerialCommand(outgoingUBX);
-  }
-
-  if (maxWait > 0)
-  {
-    //Depending on what we just sent, either we need to look for an ACK or not
-    if ((outgoingUBX->cls == UBX_CLASS_CFG) || (expectACKonly == true))
-    {
-      if (_printDebug == true)
-      {
-        _debugSerial->println(F("sendCommand: Waiting for ACK response"));
-      }
-      retVal = waitForACKResponse(outgoingUBX, outgoingUBX->cls, outgoingUBX->id, maxWait); //Wait for Ack response
-    }
-    else
-    {
-      if (_printDebug == true)
-      {
-        _debugSerial->println(F("sendCommand: Waiting for No ACK response"));
-      }
-      retVal = waitForNoACKResponse(outgoingUBX, outgoingUBX->cls, outgoingUBX->id, maxWait); //Wait for Ack response
-    }
-  }
-  return retVal;
-}
-
-//Returns false if sensor fails to respond to I2C traffic
-sfe_ublox_status_e SFE_UBLOX_GNSS::sendI2cCommand(ubxPacket *outgoingUBX, uint16_t maxWait)
-{
-  //Point at 0xFF data register
-  _i2cPort->beginTransmission((uint8_t)_gpsI2Caddress); //There is no register to write to, we just begin writing data bytes
-  _i2cPort->write(0xFF);
-  if (_i2cPort->endTransmission(false) != 0)         //Don't release bus
-    return (SFE_UBLOX_STATUS_I2C_COMM_FAILURE); //Sensor did not ACK
-
-  //Write header bytes
-  _i2cPort->beginTransmission((uint8_t)_gpsI2Caddress); //There is no register to write to, we just begin writing data bytes
-  _i2cPort->write(UBX_SYNCH_1);                         //μ - oh ublox, you're funny. I will call you micro-blox from now on.
-  _i2cPort->write(UBX_SYNCH_2);                         //b
-  _i2cPort->write(outgoingUBX->cls);
-  _i2cPort->write(outgoingUBX->id);
-  _i2cPort->write(outgoingUBX->len & 0xFF);     //LSB
-  _i2cPort->write(outgoingUBX->len >> 8);       //MSB
-  if (_i2cPort->endTransmission(false) != 0)    //Do not release bus
-    return (SFE_UBLOX_STATUS_I2C_COMM_FAILURE); //Sensor did not ACK
-
-  //Write payload. Limit the sends into 32 byte chunks
-  //This code based on ublox: https://forum.u-blox.com/index.php/20528/how-to-use-i2c-to-get-the-nmea-frames
-  uint16_t bytesToSend = outgoingUBX->len;
-
-  //"The number of data bytes must be at least 2 to properly distinguish
-  //from the write access to set the address counter in random read accesses."
-  uint16_t startSpot = 0;
-  while (bytesToSend > 1)
-  {
-    uint8_t len = bytesToSend;
-    if (len > i2cTransactionSize)
-      len = i2cTransactionSize;
-
-    _i2cPort->beginTransmission((uint8_t)_gpsI2Caddress);
-    //_i2cPort->write(outgoingUBX->payload, len); //Write a portion of the payload to the bus
-
-    for (uint16_t x = 0; x < len; x++)
-      _i2cPort->write(outgoingUBX->payload[startSpot + x]); //Write a portion of the payload to the bus
-
-    if (_i2cPort->endTransmission(false) != 0)    //Don't release bus
-      return (SFE_UBLOX_STATUS_I2C_COMM_FAILURE); //Sensor did not ACK
-
-    //*outgoingUBX->payload += len; //Move the pointer forward
-    startSpot += len; //Move the pointer forward
-    bytesToSend -= len;
-  }
-
-  //Write checksum
-  _i2cPort->beginTransmission((uint8_t)_gpsI2Caddress);
-  if (bytesToSend == 1)
-    _i2cPort->write(outgoingUBX->payload, 1);
-  _i2cPort->write(outgoingUBX->checksumA);
-  _i2cPort->write(outgoingUBX->checksumB);
-
-  //All done transmitting bytes. Release bus.
-  if (_i2cPort->endTransmission() != 0)
-    return (SFE_UBLOX_STATUS_I2C_COMM_FAILURE); //Sensor did not ACK
-  return (SFE_UBLOX_STATUS_SUCCESS);
-}
-
-//Given a packet and payload, send everything including CRC bytesA via Serial port
-void SFE_UBLOX_GNSS::sendSerialCommand(ubxPacket *outgoingUBX)
-{
-  //Write header bytes
-  _serialPort->write(UBX_SYNCH_1); //μ - oh ublox, you're funny. I will call you micro-blox from now on.
-  _serialPort->write(UBX_SYNCH_2); //b
-  _serialPort->write(outgoingUBX->cls);
-  _serialPort->write(outgoingUBX->id);
-  _serialPort->write(outgoingUBX->len & 0xFF); //LSB
-  _serialPort->write(outgoingUBX->len >> 8);   //MSB
-
-  //Write payload.
-  for (int i = 0; i < outgoingUBX->len; i++)
-  {
-    _serialPort->write(outgoingUBX->payload[i]);
-  }
-
-  //Write checksum
-  _serialPort->write(outgoingUBX->checksumA);
-  _serialPort->write(outgoingUBX->checksumB);
-}
-
-//Pretty prints the current ubxPacket
-void SFE_UBLOX_GNSS::printPacket(ubxPacket *packet, boolean alwaysPrintPayload)
-{
-  if (_printDebug == true)
-  {
-    _debugSerial->print(F("CLS:"));
-    if (packet->cls == UBX_CLASS_NAV) //1
-      _debugSerial->print(F("NAV"));
-    else if (packet->cls == UBX_CLASS_ACK) //5
-      _debugSerial->print(F("ACK"));
-    else if (packet->cls == UBX_CLASS_CFG) //6
-      _debugSerial->print(F("CFG"));
-    else if (packet->cls == UBX_CLASS_MON) //0x0A
-      _debugSerial->print(F("MON"));
-    else
-    {
-      _debugSerial->print(F("0x"));
-      _debugSerial->print(packet->cls, HEX);
-    }
-
-    _debugSerial->print(F(" ID:"));
-    if (packet->cls == UBX_CLASS_NAV && packet->id == UBX_NAV_PVT)
-      _debugSerial->print(F("PVT"));
-    else if (packet->cls == UBX_CLASS_CFG && packet->id == UBX_CFG_RATE)
-      _debugSerial->print(F("RATE"));
-    else if (packet->cls == UBX_CLASS_CFG && packet->id == UBX_CFG_CFG)
-      _debugSerial->print(F("SAVE"));
-    else
-    {
-      _debugSerial->print(F("0x"));
-      _debugSerial->print(packet->id, HEX);
-    }
-
-    _debugSerial->print(F(" Len: 0x"));
-    _debugSerial->print(packet->len, HEX);
-
-    // Only print the payload is ignoreThisPayload is false otherwise
-    // we could be printing gibberish from beyond the end of packetBuf
-    if ((alwaysPrintPayload == true) || (ignoreThisPayload == false))
-    {
-      _debugSerial->print(F(" Payload:"));
-
-      for (int x = 0; x < packet->len; x++)
-      {
-        _debugSerial->print(F(" "));
-        _debugSerial->print(packet->payload[x], HEX);
-      }
-    }
-    else
-    {
-      _debugSerial->print(F(" Payload: IGNORED"));
-    }
-    _debugSerial->println();
-  }
-}
-
-//When messages from the class CFG are sent to the receiver, the receiver will send an "acknowledge"(UBX - ACK - ACK) or a
-//"not acknowledge"(UBX-ACK-NAK) message back to the sender, depending on whether or not the message was processed correctly.
-//Some messages from other classes also use the same acknowledgement mechanism.
-
-//When we poll or get a setting, we will receive _both_ a config packet and an ACK
-//If the poll or get request is not valid, we will receive _only_ a NACK
-
-//If we are trying to get or poll a setting, then packetCfg.len will be 0 or 1 when the packetCfg is _sent_.
-//If we poll the setting for a particular port using UBX-CFG-PRT then .len will be 1 initially
-//For all other gets or polls, .len will be 0 initially
-//(It would be possible for .len to be 2 _if_ we were using UBX-CFG-MSG to poll the settings for a particular message - but we don't use that (currently))
-
-//If the get or poll _fails_, i.e. is NACK'd, then packetCfg.len could still be 0 or 1 after the NACK is received
-//But if the get or poll is ACK'd, then packetCfg.len will have been updated by the incoming data and will always be at least 2
-
-//If we are going to set the value for a setting, then packetCfg.len will be at least 3 when the packetCfg is _sent_.
-//(UBX-CFG-MSG appears to have the shortest set length of 3 bytes)
-
-//We need to think carefully about how interleaved PVT packets affect things.
-//It is entirely possible that our packetCfg and packetAck were received successfully
-//but while we are still in the "if (checkUblox() == true)" loop a PVT packet is processed
-//or _starts_ to arrive (remember that Serial data can arrive very slowly).
-
-//Returns SFE_UBLOX_STATUS_DATA_RECEIVED if we got an ACK and a valid packetCfg (module is responding with register content)
-//Returns SFE_UBLOX_STATUS_DATA_SENT if we got an ACK and no packetCfg (no valid packetCfg needed, module absorbs new register data)
-//Returns SFE_UBLOX_STATUS_FAIL if something very bad happens (e.g. a double checksum failure)
-//Returns SFE_UBLOX_STATUS_COMMAND_NACK if the packet was not-acknowledged (NACK)
-//Returns SFE_UBLOX_STATUS_CRC_FAIL if we had a checksum failure
-//Returns SFE_UBLOX_STATUS_TIMEOUT if we timed out
-//Returns SFE_UBLOX_STATUS_DATA_OVERWRITTEN if we got an ACK and a valid packetCfg but that the packetCfg has been
-// or is currently being overwritten (remember that Serial data can arrive very slowly)
-sfe_ublox_status_e SFE_UBLOX_GNSS::waitForACKResponse(ubxPacket *outgoingUBX, uint8_t requestedClass, uint8_t requestedID, uint16_t maxTime)
-{
-  outgoingUBX->valid = SFE_UBLOX_PACKET_VALIDITY_NOT_DEFINED; //This will go VALID (or NOT_VALID) when we receive a response to the packet we sent
-  packetAck.valid = SFE_UBLOX_PACKET_VALIDITY_NOT_DEFINED;
-  packetBuf.valid = SFE_UBLOX_PACKET_VALIDITY_NOT_DEFINED;
-  packetAuto.valid = SFE_UBLOX_PACKET_VALIDITY_NOT_DEFINED;
-  outgoingUBX->classAndIDmatch = SFE_UBLOX_PACKET_VALIDITY_NOT_DEFINED; // This will go VALID (or NOT_VALID) when we receive a packet that matches the requested class and ID
-  packetAck.classAndIDmatch = SFE_UBLOX_PACKET_VALIDITY_NOT_DEFINED;
-  packetBuf.classAndIDmatch = SFE_UBLOX_PACKET_VALIDITY_NOT_DEFINED;
-  packetAuto.classAndIDmatch = SFE_UBLOX_PACKET_VALIDITY_NOT_DEFINED;
-
-  unsigned long startTime = millis();
-  while (millis() - startTime < maxTime)
-  {
-    if (checkUbloxInternal(outgoingUBX, requestedClass, requestedID) == true) //See if new data is available. Process bytes as they come in.
-    {
-      // If both the outgoingUBX->classAndIDmatch and packetAck.classAndIDmatch are VALID
-      // and outgoingUBX->valid is _still_ VALID and the class and ID _still_ match
-      // then we can be confident that the data in outgoingUBX is valid
-      if ((outgoingUBX->classAndIDmatch == SFE_UBLOX_PACKET_VALIDITY_VALID) && (packetAck.classAndIDmatch == SFE_UBLOX_PACKET_VALIDITY_VALID) && (outgoingUBX->valid == SFE_UBLOX_PACKET_VALIDITY_VALID) && (outgoingUBX->cls == requestedClass) && (outgoingUBX->id == requestedID))
-      {
-        if (_printDebug == true)
-        {
-          _debugSerial->print(F("waitForACKResponse: valid data and valid ACK received after "));
-          _debugSerial->print(millis() - startTime);
-          _debugSerial->println(F(" msec"));
-        }
-        return (SFE_UBLOX_STATUS_DATA_RECEIVED); //We received valid data and a correct ACK!
-      }
-
-      // We can be confident that the data packet (if we are going to get one) will always arrive
-      // before the matching ACK. So if we sent a config packet which only produces an ACK
-      // then outgoingUBX->classAndIDmatch will be NOT_DEFINED and the packetAck.classAndIDmatch will VALID.
-      // We should not check outgoingUBX->valid, outgoingUBX->cls or outgoingUBX->id
-      // as these may have been changed by an automatic packet.
-      else if ((outgoingUBX->classAndIDmatch == SFE_UBLOX_PACKET_VALIDITY_NOT_DEFINED) && (packetAck.classAndIDmatch == SFE_UBLOX_PACKET_VALIDITY_VALID))
-      {
-        if (_printDebug == true)
-        {
-          _debugSerial->print(F("waitForACKResponse: no data and valid ACK after "));
-          _debugSerial->print(millis() - startTime);
-          _debugSerial->println(F(" msec"));
-        }
-        return (SFE_UBLOX_STATUS_DATA_SENT); //We got an ACK but no data...
-      }
-
-      // If both the outgoingUBX->classAndIDmatch and packetAck.classAndIDmatch are VALID
-      // but the outgoingUBX->cls or ID no longer match then we can be confident that we had
-      // valid data but it has been or is currently being overwritten by an automatic packet (e.g. PVT).
-      // If (e.g.) a PVT packet is _being_ received: outgoingUBX->valid will be NOT_DEFINED
-      // If (e.g.) a PVT packet _has been_ received: outgoingUBX->valid will be VALID (or just possibly NOT_VALID)
-      // So we cannot use outgoingUBX->valid as part of this check.
-      // Note: the addition of packetBuf should make this check redundant!
-      else if ((outgoingUBX->classAndIDmatch == SFE_UBLOX_PACKET_VALIDITY_VALID) && (packetAck.classAndIDmatch == SFE_UBLOX_PACKET_VALIDITY_VALID) && ((outgoingUBX->cls != requestedClass) || (outgoingUBX->id != requestedID)))
-      {
-        if (_printDebug == true)
-        {
-          _debugSerial->print(F("waitForACKResponse: data being OVERWRITTEN after "));
-          _debugSerial->print(millis() - startTime);
-          _debugSerial->println(F(" msec"));
-        }
-        return (SFE_UBLOX_STATUS_DATA_OVERWRITTEN); // Data was valid but has been or is being overwritten
-      }
-
-      // If packetAck.classAndIDmatch is VALID but both outgoingUBX->valid and outgoingUBX->classAndIDmatch
-      // are NOT_VALID then we can be confident we have had a checksum failure on the data packet
-      else if ((packetAck.classAndIDmatch == SFE_UBLOX_PACKET_VALIDITY_VALID) && (outgoingUBX->classAndIDmatch == SFE_UBLOX_PACKET_VALIDITY_NOT_VALID) && (outgoingUBX->valid == SFE_UBLOX_PACKET_VALIDITY_NOT_VALID))
-      {
-        if (_printDebug == true)
-        {
-          _debugSerial->print(F("waitForACKResponse: CRC failed after "));
-          _debugSerial->print(millis() - startTime);
-          _debugSerial->println(F(" msec"));
-        }
-        return (SFE_UBLOX_STATUS_CRC_FAIL); //Checksum fail
-      }
-
-      // If our packet was not-acknowledged (NACK) we do not receive a data packet - we only get the NACK.
-      // So you would expect outgoingUBX->valid and outgoingUBX->classAndIDmatch to still be NOT_DEFINED
-      // But if a full PVT packet arrives afterwards outgoingUBX->valid could be VALID (or just possibly NOT_VALID)
-      // but outgoingUBX->cls and outgoingUBX->id would not match...
-      // So I think this is telling us we need a special state for packetAck.classAndIDmatch to tell us
-      // the packet was definitely NACK'd otherwise we are possibly just guessing...
-      // Note: the addition of packetBuf changes the logic of this, but we'll leave the code as is for now.
-      else if (packetAck.classAndIDmatch == SFE_UBLOX_PACKET_NOTACKNOWLEDGED)
-      {
-        if (_printDebug == true)
-        {
-          _debugSerial->print(F("waitForACKResponse: data was NOTACKNOWLEDGED (NACK) after "));
-          _debugSerial->print(millis() - startTime);
-          _debugSerial->println(F(" msec"));
-        }
-        return (SFE_UBLOX_STATUS_COMMAND_NACK); //We received a NACK!
-      }
-
-      // If the outgoingUBX->classAndIDmatch is VALID but the packetAck.classAndIDmatch is NOT_VALID
-      // then the ack probably had a checksum error. We will take a gamble and return DATA_RECEIVED.
-      // If we were playing safe, we should return FAIL instead
-      else if ((outgoingUBX->classAndIDmatch == SFE_UBLOX_PACKET_VALIDITY_VALID) && (packetAck.classAndIDmatch == SFE_UBLOX_PACKET_VALIDITY_NOT_VALID) && (outgoingUBX->valid == SFE_UBLOX_PACKET_VALIDITY_VALID) && (outgoingUBX->cls == requestedClass) && (outgoingUBX->id == requestedID))
-      {
-        if (_printDebug == true)
-        {
-          _debugSerial->print(F("waitForACKResponse: VALID data and INVALID ACK received after "));
-          _debugSerial->print(millis() - startTime);
-          _debugSerial->println(F(" msec"));
-        }
-        return (SFE_UBLOX_STATUS_DATA_RECEIVED); //We received valid data and an invalid ACK!
-      }
-
-      // If the outgoingUBX->classAndIDmatch is NOT_VALID and the packetAck.classAndIDmatch is NOT_VALID
-      // then we return a FAIL. This must be a double checksum failure?
-      else if ((outgoingUBX->classAndIDmatch == SFE_UBLOX_PACKET_VALIDITY_NOT_VALID) && (packetAck.classAndIDmatch == SFE_UBLOX_PACKET_VALIDITY_NOT_VALID))
-      {
-        if (_printDebug == true)
-        {
-          _debugSerial->print(F("waitForACKResponse: INVALID data and INVALID ACK received after "));
-          _debugSerial->print(millis() - startTime);
-          _debugSerial->println(F(" msec"));
-        }
-        return (SFE_UBLOX_STATUS_FAIL); //We received invalid data and an invalid ACK!
-      }
-
-      // If the outgoingUBX->classAndIDmatch is VALID and the packetAck.classAndIDmatch is NOT_DEFINED
-      // then the ACK has not yet been received and we should keep waiting for it
-      else if ((outgoingUBX->classAndIDmatch == SFE_UBLOX_PACKET_VALIDITY_VALID) && (packetAck.classAndIDmatch == SFE_UBLOX_PACKET_VALIDITY_NOT_DEFINED))
-      {
-        // if (_printDebug == true)
-        // {
-        //   _debugSerial->print(F("waitForACKResponse: valid data after "));
-        //   _debugSerial->print(millis() - startTime);
-        //   _debugSerial->println(F(" msec. Waiting for ACK."));
-        // }
-      }
-
-    } //checkUbloxInternal == true
-
-    delayMicroseconds(500);
-  } //while (millis() - startTime < maxTime)
-
-  // We have timed out...
-  // If the outgoingUBX->classAndIDmatch is VALID then we can take a gamble and return DATA_RECEIVED
-  // even though we did not get an ACK
-  if ((outgoingUBX->classAndIDmatch == SFE_UBLOX_PACKET_VALIDITY_VALID) && (packetAck.classAndIDmatch == SFE_UBLOX_PACKET_VALIDITY_NOT_DEFINED) && (outgoingUBX->valid == SFE_UBLOX_PACKET_VALIDITY_VALID) && (outgoingUBX->cls == requestedClass) && (outgoingUBX->id == requestedID))
-  {
-    if (_printDebug == true)
-    {
-      _debugSerial->print(F("waitForACKResponse: TIMEOUT with valid data after "));
-      _debugSerial->print(millis() - startTime);
-      _debugSerial->println(F(" msec. "));
-    }
-    return (SFE_UBLOX_STATUS_DATA_RECEIVED); //We received valid data... But no ACK!
-  }
-
-  if (_printDebug == true)
-  {
-    _debugSerial->print(F("waitForACKResponse: TIMEOUT after "));
-    _debugSerial->print(millis() - startTime);
-    _debugSerial->println(F(" msec."));
-  }
-
-  return (SFE_UBLOX_STATUS_TIMEOUT);
-}
-
-//For non-CFG queries no ACK is sent so we use this function
-//Returns SFE_UBLOX_STATUS_DATA_RECEIVED if we got a config packet full of response data that has CLS/ID match to our query packet
-//Returns SFE_UBLOX_STATUS_CRC_FAIL if we got a corrupt config packet that has CLS/ID match to our query packet
-//Returns SFE_UBLOX_STATUS_TIMEOUT if we timed out
-//Returns SFE_UBLOX_STATUS_DATA_OVERWRITTEN if we got an a valid packetCfg but that the packetCfg has been
-// or is currently being overwritten (remember that Serial data can arrive very slowly)
-sfe_ublox_status_e SFE_UBLOX_GNSS::waitForNoACKResponse(ubxPacket *outgoingUBX, uint8_t requestedClass, uint8_t requestedID, uint16_t maxTime)
-{
-  outgoingUBX->valid = SFE_UBLOX_PACKET_VALIDITY_NOT_DEFINED; //This will go VALID (or NOT_VALID) when we receive a response to the packet we sent
-  packetAck.valid = SFE_UBLOX_PACKET_VALIDITY_NOT_DEFINED;
-  packetBuf.valid = SFE_UBLOX_PACKET_VALIDITY_NOT_DEFINED;
-  packetAuto.valid = SFE_UBLOX_PACKET_VALIDITY_NOT_DEFINED;
-  outgoingUBX->classAndIDmatch = SFE_UBLOX_PACKET_VALIDITY_NOT_DEFINED; // This will go VALID (or NOT_VALID) when we receive a packet that matches the requested class and ID
-  packetAck.classAndIDmatch = SFE_UBLOX_PACKET_VALIDITY_NOT_DEFINED;
-  packetBuf.classAndIDmatch = SFE_UBLOX_PACKET_VALIDITY_NOT_DEFINED;
-  packetAuto.classAndIDmatch = SFE_UBLOX_PACKET_VALIDITY_NOT_DEFINED;
-
-  unsigned long startTime = millis();
-  while (millis() - startTime < maxTime)
-  {
-    if (checkUbloxInternal(outgoingUBX, requestedClass, requestedID) == true) //See if new data is available. Process bytes as they come in.
-    {
-
-      // If outgoingUBX->classAndIDmatch is VALID
-      // and outgoingUBX->valid is _still_ VALID and the class and ID _still_ match
-      // then we can be confident that the data in outgoingUBX is valid
-      if ((outgoingUBX->classAndIDmatch == SFE_UBLOX_PACKET_VALIDITY_VALID) && (outgoingUBX->valid == SFE_UBLOX_PACKET_VALIDITY_VALID) && (outgoingUBX->cls == requestedClass) && (outgoingUBX->id == requestedID))
-      {
-        if (_printDebug == true)
-        {
-          _debugSerial->print(F("waitForNoACKResponse: valid data with CLS/ID match after "));
-          _debugSerial->print(millis() - startTime);
-          _debugSerial->println(F(" msec"));
-        }
-        return (SFE_UBLOX_STATUS_DATA_RECEIVED); //We received valid data!
-      }
-
-      // If the outgoingUBX->classAndIDmatch is VALID
-      // but the outgoingUBX->cls or ID no longer match then we can be confident that we had
-      // valid data but it has been or is currently being overwritten by another packet (e.g. PVT).
-      // If (e.g.) a PVT packet is _being_ received: outgoingUBX->valid will be NOT_DEFINED
-      // If (e.g.) a PVT packet _has been_ received: outgoingUBX->valid will be VALID (or just possibly NOT_VALID)
-      // So we cannot use outgoingUBX->valid as part of this check.
-      // Note: the addition of packetBuf should make this check redundant!
-      else if ((outgoingUBX->classAndIDmatch == SFE_UBLOX_PACKET_VALIDITY_VALID) && ((outgoingUBX->cls != requestedClass) || (outgoingUBX->id != requestedID)))
-      {
-        if (_printDebug == true)
-        {
-          _debugSerial->print(F("waitForNoACKResponse: data being OVERWRITTEN after "));
-          _debugSerial->print(millis() - startTime);
-          _debugSerial->println(F(" msec"));
-        }
-        return (SFE_UBLOX_STATUS_DATA_OVERWRITTEN); // Data was valid but has been or is being overwritten
-      }
-
-      // If outgoingUBX->classAndIDmatch is NOT_DEFINED
-      // and outgoingUBX->valid is VALID then this must be (e.g.) a PVT packet
-      else if ((outgoingUBX->classAndIDmatch == SFE_UBLOX_PACKET_VALIDITY_NOT_DEFINED) && (outgoingUBX->valid == SFE_UBLOX_PACKET_VALIDITY_VALID))
-      {
-        // if (_printDebug == true)
-        // {
-        //   _debugSerial->print(F("waitForNoACKResponse: valid but UNWANTED data after "));
-        //   _debugSerial->print(millis() - startTime);
-        //   _debugSerial->print(F(" msec. Class: "));
-        //   _debugSerial->print(outgoingUBX->cls);
-        //   _debugSerial->print(F(" ID: "));
-        //   _debugSerial->print(outgoingUBX->id);
-        // }
-      }
-
-      // If the outgoingUBX->classAndIDmatch is NOT_VALID then we return CRC failure
-      else if (outgoingUBX->classAndIDmatch == SFE_UBLOX_PACKET_VALIDITY_NOT_VALID)
-      {
-        if (_printDebug == true)
-        {
-          _debugSerial->print(F("waitForNoACKResponse: CLS/ID match but failed CRC after "));
-          _debugSerial->print(millis() - startTime);
-          _debugSerial->println(F(" msec"));
-        }
-        return (SFE_UBLOX_STATUS_CRC_FAIL); //We received invalid data
-      }
-    }
-
-    delayMicroseconds(500);
-  }
-
-  if (_printDebug == true)
-  {
-    _debugSerial->print(F("waitForNoACKResponse: TIMEOUT after "));
-    _debugSerial->print(millis() - startTime);
-    _debugSerial->println(F(" msec. No packet received."));
-  }
-
-  return (SFE_UBLOX_STATUS_TIMEOUT);
-}
-
-// Check if any callbacks are waiting to be processed
-void SFE_UBLOX_GNSS::checkCallbacks(void)
-{
-  if (checkCallbacksReentrant == true) // Check for reentry (i.e. checkCallbacks has been called from inside a callback)
-    return;
-
-  checkCallbacksReentrant = true;
-
-  if ((packetUBXNAVPOSECEF != NULL) // If RAM has been allocated for message storage
-    && (packetUBXNAVPOSECEF->callbackData != NULL) // If RAM has been allocated for the copy of the data
-    && (packetUBXNAVPOSECEF->callbackPointer != NULL) // If the pointer to the callback has been defined
-    && (packetUBXNAVPOSECEF->automaticFlags.flags.bits.callbackCopyValid == true)) // If the copy of the data is valid
-  {
-    // if (_printDebug == true)
-    //   _debugSerial->println(F("checkCallbacks: calling callback for NAV POSECEF"));
-    packetUBXNAVPOSECEF->callbackPointer(*packetUBXNAVPOSECEF->callbackData); // Call the callback
-    packetUBXNAVPOSECEF->automaticFlags.flags.bits.callbackCopyValid = false; // Mark the data as stale
-  }
-
-  if ((packetUBXNAVSTATUS != NULL) // If RAM has been allocated for message storage
-    && (packetUBXNAVSTATUS->callbackData != NULL) // If RAM has been allocated for the copy of the data
-    && (packetUBXNAVSTATUS->callbackPointer != NULL) // If the pointer to the callback has been defined
-    && (packetUBXNAVSTATUS->automaticFlags.flags.bits.callbackCopyValid == true)) // If the copy of the data is valid
-  {
-    // if (_printDebug == true)
-    //   _debugSerial->println(F("checkCallbacks: calling callback for NAV STATUS"));
-    packetUBXNAVSTATUS->callbackPointer(*packetUBXNAVSTATUS->callbackData); // Call the callback
-    packetUBXNAVSTATUS->automaticFlags.flags.bits.callbackCopyValid = false; // Mark the data as stale
-  }
-
-  if ((packetUBXNAVDOP != NULL) // If RAM has been allocated for message storage
-    && (packetUBXNAVDOP->callbackData != NULL) // If RAM has been allocated for the copy of the data
-    && (packetUBXNAVDOP->callbackPointer != NULL) // If the pointer to the callback has been defined
-    && (packetUBXNAVDOP->automaticFlags.flags.bits.callbackCopyValid == true)) // If the copy of the data is valid
-  {
-    // if (_printDebug == true)
-    //   _debugSerial->println(F("checkCallbacks: calling callback for NAV DOP"));
-    packetUBXNAVDOP->callbackPointer(*packetUBXNAVDOP->callbackData); // Call the callback
-    packetUBXNAVDOP->automaticFlags.flags.bits.callbackCopyValid = false; // Mark the data as stale
-  }
-
-  if ((packetUBXNAVATT != NULL) // If RAM has been allocated for message storage
-    && (packetUBXNAVATT->callbackData != NULL) // If RAM has been allocated for the copy of the data
-    && (packetUBXNAVATT->callbackPointer != NULL) // If the pointer to the callback has been defined
-    && (packetUBXNAVATT->automaticFlags.flags.bits.callbackCopyValid == true)) // If the copy of the data is valid
-  {
-    // if (_printDebug == true)
-    //   _debugSerial->println(F("checkCallbacks: calling callback for NAV ATT"));
-    packetUBXNAVATT->callbackPointer(*packetUBXNAVATT->callbackData); // Call the callback
-    packetUBXNAVATT->automaticFlags.flags.bits.callbackCopyValid = false; // Mark the data as stale
-  }
-
-  if ((packetUBXNAVPVT != NULL) // If RAM has been allocated for message storage
-    && (packetUBXNAVPVT->callbackData != NULL) // If RAM has been allocated for the copy of the data
-    && (packetUBXNAVPVT->callbackPointer != NULL) // If the pointer to the callback has been defined
-    && (packetUBXNAVPVT->automaticFlags.flags.bits.callbackCopyValid == true)) // If the copy of the data is valid
-  {
-    //if (_printDebug == true)
-    //  _debugSerial->println(F("checkCallbacks: calling callback for NAV PVT"));
-    packetUBXNAVPVT->callbackPointer(*packetUBXNAVPVT->callbackData); // Call the callback
-    packetUBXNAVPVT->automaticFlags.flags.bits.callbackCopyValid = false; // Mark the data as stale
-  }
-
-  if ((packetUBXNAVODO != NULL) // If RAM has been allocated for message storage
-    && (packetUBXNAVODO->callbackData != NULL) // If RAM has been allocated for the copy of the data
-    && (packetUBXNAVODO->callbackPointer != NULL) // If the pointer to the callback has been defined
-    && (packetUBXNAVODO->automaticFlags.flags.bits.callbackCopyValid == true)) // If the copy of the data is valid
-  {
-    // if (_printDebug == true)
-    //   _debugSerial->println(F("checkCallbacks: calling callback for NAV ODO"));
-    packetUBXNAVODO->callbackPointer(*packetUBXNAVODO->callbackData); // Call the callback
-    packetUBXNAVODO->automaticFlags.flags.bits.callbackCopyValid = false; // Mark the data as stale
-  }
-
-  if ((packetUBXNAVVELECEF != NULL) // If RAM has been allocated for message storage
-    && (packetUBXNAVVELECEF->callbackData != NULL) // If RAM has been allocated for the copy of the data
-    && (packetUBXNAVVELECEF->callbackPointer != NULL) // If the pointer to the callback has been defined
-    && (packetUBXNAVVELECEF->automaticFlags.flags.bits.callbackCopyValid == true)) // If the copy of the data is valid
-  {
-    // if (_printDebug == true)
-    //   _debugSerial->println(F("checkCallbacks: calling callback for NAV VELECEF"));
-    packetUBXNAVVELECEF->callbackPointer(*packetUBXNAVVELECEF->callbackData); // Call the callback
-    packetUBXNAVVELECEF->automaticFlags.flags.bits.callbackCopyValid = false; // Mark the data as stale
-  }
-
-  if ((packetUBXNAVVELNED != NULL) // If RAM has been allocated for message storage
-    && (packetUBXNAVVELNED->callbackData != NULL) // If RAM has been allocated for the copy of the data
-    && (packetUBXNAVVELNED->callbackPointer != NULL) // If the pointer to the callback has been defined
-    && (packetUBXNAVVELNED->automaticFlags.flags.bits.callbackCopyValid == true)) // If the copy of the data is valid
-  {
-    // if (_printDebug == true)
-    //   _debugSerial->println(F("checkCallbacks: calling callback for NAV VELNED"));
-    packetUBXNAVVELNED->callbackPointer(*packetUBXNAVVELNED->callbackData); // Call the callback
-    packetUBXNAVVELNED->automaticFlags.flags.bits.callbackCopyValid = false; // Mark the data as stale
-  }
-
-  if ((packetUBXNAVHPPOSECEF != NULL) // If RAM has been allocated for message storage
-    && (packetUBXNAVHPPOSECEF->callbackData != NULL) // If RAM has been allocated for the copy of the data
-    && (packetUBXNAVHPPOSECEF->callbackPointer != NULL) // If the pointer to the callback has been defined
-    && (packetUBXNAVHPPOSECEF->automaticFlags.flags.bits.callbackCopyValid == true)) // If the copy of the data is valid
-  {
-    // if (_printDebug == true)
-    //   _debugSerial->println(F("checkCallbacks: calling callback for NAV HPPOSECEF"));
-    packetUBXNAVHPPOSECEF->callbackPointer(*packetUBXNAVHPPOSECEF->callbackData); // Call the callback
-    packetUBXNAVHPPOSECEF->automaticFlags.flags.bits.callbackCopyValid = false; // Mark the data as stale
-  }
-
-  if ((packetUBXNAVHPPOSLLH != NULL) // If RAM has been allocated for message storage
-    && (packetUBXNAVHPPOSLLH->callbackData != NULL) // If RAM has been allocated for the copy of the data
-    && (packetUBXNAVHPPOSLLH->callbackPointer != NULL) // If the pointer to the callback has been defined
-    && (packetUBXNAVHPPOSLLH->automaticFlags.flags.bits.callbackCopyValid == true)) // If the copy of the data is valid
-  {
-    // if (_printDebug == true)
-    //   _debugSerial->println(F("checkCallbacks: calling callback for NAV HPPOSLLH"));
-    packetUBXNAVHPPOSLLH->callbackPointer(*packetUBXNAVHPPOSLLH->callbackData); // Call the callback
-    packetUBXNAVHPPOSLLH->automaticFlags.flags.bits.callbackCopyValid = false; // Mark the data as stale
-  }
-
-  if ((packetUBXNAVCLOCK != NULL) // If RAM has been allocated for message storage
-    && (packetUBXNAVCLOCK->callbackData != NULL) // If RAM has been allocated for the copy of the data
-    && (packetUBXNAVCLOCK->callbackPointer != NULL) // If the pointer to the callback has been defined
-    && (packetUBXNAVCLOCK->automaticFlags.flags.bits.callbackCopyValid == true)) // If the copy of the data is valid
-  {
-    // if (_printDebug == true)
-    //   _debugSerial->println(F("checkCallbacks: calling callback for NAV CLOCK"));
-    packetUBXNAVCLOCK->callbackPointer(*packetUBXNAVCLOCK->callbackData); // Call the callback
-    packetUBXNAVCLOCK->automaticFlags.flags.bits.callbackCopyValid = false; // Mark the data as stale
-  }
-
-  if ((packetUBXNAVRELPOSNED != NULL) // If RAM has been allocated for message storage
-    && (packetUBXNAVRELPOSNED->callbackData != NULL) // If RAM has been allocated for the copy of the data
-    && (packetUBXNAVRELPOSNED->callbackPointer != NULL) // If the pointer to the callback has been defined
-    && (packetUBXNAVRELPOSNED->automaticFlags.flags.bits.callbackCopyValid == true)) // If the copy of the data is valid
-  {
-    // if (_printDebug == true)
-    //   _debugSerial->println(F("checkCallbacks: calling callback for NAV RELPOSNED"));
-    packetUBXNAVRELPOSNED->callbackPointer(*packetUBXNAVRELPOSNED->callbackData); // Call the callback
-    packetUBXNAVRELPOSNED->automaticFlags.flags.bits.callbackCopyValid = false; // Mark the data as stale
-  }
-
-  if ((packetUBXRXMSFRBX != NULL) // If RAM has been allocated for message storage
-    && (packetUBXRXMSFRBX->callbackData != NULL) // If RAM has been allocated for the copy of the data
-    && (packetUBXRXMSFRBX->callbackPointer != NULL) // If the pointer to the callback has been defined
-    && (packetUBXRXMSFRBX->automaticFlags.flags.bits.callbackCopyValid == true)) // If the copy of the data is valid
-  {
-    // if (_printDebug == true)
-    //   _debugSerial->println(F("checkCallbacks: calling callback for RXM SFRBX"));
-    packetUBXRXMSFRBX->callbackPointer(*packetUBXRXMSFRBX->callbackData); // Call the callback
-    packetUBXRXMSFRBX->automaticFlags.flags.bits.callbackCopyValid = false; // Mark the data as stale
-  }
-
-  if ((packetUBXRXMRAWX != NULL) // If RAM has been allocated for message storage
-    && (packetUBXRXMRAWX->callbackData != NULL) // If RAM has been allocated for the copy of the data
-    && (packetUBXRXMRAWX->callbackPointer != NULL) // If the pointer to the callback has been defined
-    && (packetUBXRXMRAWX->automaticFlags.flags.bits.callbackCopyValid == true)) // If the copy of the data is valid
-  {
-    // if (_printDebug == true)
-    //   _debugSerial->println(F("checkCallbacks: calling callback for RXM RAWX"));
-    packetUBXRXMRAWX->callbackPointer(*packetUBXRXMRAWX->callbackData); // Call the callback
-    packetUBXRXMRAWX->automaticFlags.flags.bits.callbackCopyValid = false; // Mark the data as stale
-  }
-
-  if ((packetUBXTIMTM2 != NULL) // If RAM has been allocated for message storage
-    && (packetUBXTIMTM2->callbackData != NULL) // If RAM has been allocated for the copy of the data
-    && (packetUBXTIMTM2->callbackPointer != NULL) // If the pointer to the callback has been defined
-    && (packetUBXTIMTM2->automaticFlags.flags.bits.callbackCopyValid == true)) // If the copy of the data is valid
-  {
-    // if (_printDebug == true)
-    //   _debugSerial->println(F("checkCallbacks: calling callback for TIM TM2"));
-    packetUBXTIMTM2->callbackPointer(*packetUBXTIMTM2->callbackData); // Call the callback
-    packetUBXTIMTM2->automaticFlags.flags.bits.callbackCopyValid = false; // Mark the data as stale
-  }
-
-  if ((packetUBXESFALG != NULL) // If RAM has been allocated for message storage
-    && (packetUBXESFALG->callbackData != NULL) // If RAM has been allocated for the copy of the data
-    && (packetUBXESFALG->callbackPointer != NULL) // If the pointer to the callback has been defined
-    && (packetUBXESFALG->automaticFlags.flags.bits.callbackCopyValid == true)) // If the copy of the data is valid
-  {
-    // if (_printDebug == true)
-    //   _debugSerial->println(F("checkCallbacks: calling callback for ESF ALG"));
-    packetUBXESFALG->callbackPointer(*packetUBXESFALG->callbackData); // Call the callback
-    packetUBXESFALG->automaticFlags.flags.bits.callbackCopyValid = false; // Mark the data as stale
-  }
-
-  if ((packetUBXESFINS != NULL) // If RAM has been allocated for message storage
-    && (packetUBXESFINS->callbackData != NULL) // If RAM has been allocated for the copy of the data
-    && (packetUBXESFINS->callbackPointer != NULL) // If the pointer to the callback has been defined
-    && (packetUBXESFINS->automaticFlags.flags.bits.callbackCopyValid == true)) // If the copy of the data is valid
-  {
-    // if (_printDebug == true)
-    //   _debugSerial->println(F("checkCallbacks: calling callback for ESF INS"));
-    packetUBXESFINS->callbackPointer(*packetUBXESFINS->callbackData); // Call the callback
-    packetUBXESFINS->automaticFlags.flags.bits.callbackCopyValid = false; // Mark the data as stale
-  }
-
-  if ((packetUBXESFMEAS != NULL) // If RAM has been allocated for message storage
-    && (packetUBXESFMEAS->callbackData != NULL) // If RAM has been allocated for the copy of the data
-    && (packetUBXESFMEAS->callbackPointer != NULL) // If the pointer to the callback has been defined
-    && (packetUBXESFMEAS->automaticFlags.flags.bits.callbackCopyValid == true)) // If the copy of the data is valid
-  {
-    // if (_printDebug == true)
-    //   _debugSerial->println(F("checkCallbacks: calling callback for ESF MEAS"));
-    packetUBXESFMEAS->callbackPointer(*packetUBXESFMEAS->callbackData); // Call the callback
-    packetUBXESFMEAS->automaticFlags.flags.bits.callbackCopyValid = false; // Mark the data as stale
-  }
-
-  if ((packetUBXESFRAW != NULL) // If RAM has been allocated for message storage
-    && (packetUBXESFRAW->callbackData != NULL) // If RAM has been allocated for the copy of the data
-    && (packetUBXESFRAW->callbackPointer != NULL) // If the pointer to the callback has been defined
-    && (packetUBXESFRAW->automaticFlags.flags.bits.callbackCopyValid == true)) // If the copy of the data is valid
-  {
-    // if (_printDebug == true)
-    //   _debugSerial->println(F("checkCallbacks: calling callback for ESF RAW"));
-    packetUBXESFRAW->callbackPointer(*packetUBXESFRAW->callbackData); // Call the callback
-    packetUBXESFRAW->automaticFlags.flags.bits.callbackCopyValid = false; // Mark the data as stale
-  }
-
-  if ((packetUBXESFSTATUS != NULL) // If RAM has been allocated for message storage
-    && (packetUBXESFSTATUS->callbackData != NULL) // If RAM has been allocated for the copy of the data
-    && (packetUBXESFSTATUS->callbackPointer != NULL) // If the pointer to the callback has been defined
-    && (packetUBXESFSTATUS->automaticFlags.flags.bits.callbackCopyValid == true)) // If the copy of the data is valid
-  {
-    // if (_printDebug == true)
-    //   _debugSerial->println(F("checkCallbacks: calling callback for ESF STATUS"));
-    packetUBXESFSTATUS->callbackPointer(*packetUBXESFSTATUS->callbackData); // Call the callback
-    packetUBXESFSTATUS->automaticFlags.flags.bits.callbackCopyValid = false; // Mark the data as stale
-  }
-
-  if ((packetUBXHNRATT != NULL) // If RAM has been allocated for message storage
-    && (packetUBXHNRATT->callbackData != NULL) // If RAM has been allocated for the copy of the data
-    && (packetUBXHNRATT->callbackPointer != NULL) // If the pointer to the callback has been defined
-    && (packetUBXHNRATT->automaticFlags.flags.bits.callbackCopyValid == true)) // If the copy of the data is valid
-  {
-    // if (_printDebug == true)
-    //   _debugSerial->println(F("checkCallbacks: calling callback for HNR ATT"));
-    packetUBXHNRATT->callbackPointer(*packetUBXHNRATT->callbackData); // Call the callback
-    packetUBXHNRATT->automaticFlags.flags.bits.callbackCopyValid = false; // Mark the data as stale
-  }
-
-  if ((packetUBXHNRINS != NULL) // If RAM has been allocated for message storage
-    && (packetUBXHNRINS->callbackData != NULL) // If RAM has been allocated for the copy of the data
-    && (packetUBXHNRINS->callbackPointer != NULL) // If the pointer to the callback has been defined
-    && (packetUBXHNRINS->automaticFlags.flags.bits.callbackCopyValid == true)) // If the copy of the data is valid
-  {
-    // if (_printDebug == true)
-    //   _debugSerial->println(F("checkCallbacks: calling callback for HNR INS"));
-    packetUBXHNRINS->callbackPointer(*packetUBXHNRINS->callbackData); // Call the callback
-    packetUBXHNRINS->automaticFlags.flags.bits.callbackCopyValid = false; // Mark the data as stale
-  }
-
-  if ((packetUBXHNRPVT != NULL) // If RAM has been allocated for message storage
-    && (packetUBXHNRPVT->callbackData != NULL) // If RAM has been allocated for the copy of the data
-    && (packetUBXHNRPVT->callbackPointer != NULL) // If the pointer to the callback has been defined
-    && (packetUBXHNRPVT->automaticFlags.flags.bits.callbackCopyValid == true)) // If the copy of the data is valid
-  {
-    // if (_printDebug == true)
-    //   _debugSerial->println(F("checkCallbacks: calling callback for HNR PVT"));
-    packetUBXHNRPVT->callbackPointer(*packetUBXHNRPVT->callbackData); // Call the callback
-    packetUBXHNRPVT->automaticFlags.flags.bits.callbackCopyValid = false; // Mark the data as stale
-  }
-
-  checkCallbacksReentrant = false;
-}
-
-// Push (e.g.) RTCM data directly to the module
-// Returns true if all numDataBytes were pushed successfully
-// Warning: this function does not check that the data is valid. It is the user's responsibility to ensure the data is valid before pushing.
-boolean SFE_UBLOX_GNSS::pushRawData(uint8_t *dataBytes, size_t numDataBytes)
-{
-  if (commType == COMM_TYPE_SERIAL)
-  {
-    // Serial: write all the bytes in one go
-    size_t bytesWritten = _serialPort->write(dataBytes, numDataBytes);
-    return (bytesWritten == numDataBytes);
-  }
-  else
-  {
-    // I2C: split the data up into packets of i2cTransactionSize
-    size_t bytesLeftToWrite = numDataBytes;
-    size_t bytesWrittenTotal = 0;
-
-    while (bytesLeftToWrite > 0)
-    {
-      size_t bytesToWrite; // Limit bytesToWrite to i2cTransactionSize
-      if (bytesLeftToWrite > i2cTransactionSize)
-        bytesToWrite = i2cTransactionSize;
-      else
-        bytesToWrite = bytesLeftToWrite;
-
-      _i2cPort->beginTransmission(_gpsI2Caddress);
-      size_t bytesWritten = _i2cPort->write(dataBytes, bytesToWrite); // Write the bytes
-
-      bytesWrittenTotal += bytesWritten; // Update the totals
-      bytesLeftToWrite -= bytesToWrite;
-      dataBytes += bytesToWrite; // Point to fresh data
-
-      if (bytesLeftToWrite > 0)
-      {
-        if (_i2cPort->endTransmission(false) != 0) //Send a restart command. Do not release bus.
-          return (false);                          //Sensor did not ACK
-      }
-      else
-      {
-        if (_i2cPort->endTransmission() != 0) //We're done. Release bus.
-          return (false);                     //Sensor did not ACK
-      }
-    }
-
-    return (bytesWrittenTotal == numDataBytes);
-  }
-}
-
-// Support for data logging
-
-//Set the file buffer size. This must be called _before_ .begin
-void SFE_UBLOX_GNSS::setFileBufferSize(uint16_t bufferSize)
-{
-  fileBufferSize = bufferSize;
-}
-
-//Return the file buffer size
-uint16_t SFE_UBLOX_GNSS::getFileBufferSize(void)
-{
-  return (fileBufferSize);
-}
-
-// Extract numBytes of data from the file buffer. Copy it to destination.
-// It is the user's responsibility to ensure destination is large enough.
-// Returns the number of bytes extracted - which may be less than numBytes.
-uint16_t SFE_UBLOX_GNSS::extractFileBufferData(uint8_t *destination, uint16_t numBytes)
-{
-  // Check how many bytes are available in the buffer
-  uint16_t bytesAvailable = fileBufferSpaceUsed();
-  if (numBytes > bytesAvailable) // Limit numBytes if required
-    numBytes = bytesAvailable;
-
-  // Start copying at fileBufferTail. Wrap-around if required.
-  uint16_t bytesBeforeWrapAround = fileBufferSize - fileBufferTail; // How much space is available 'above' Tail?
-  if (bytesBeforeWrapAround > numBytes) // Will we need to wrap-around?
-  {
-    bytesBeforeWrapAround = numBytes; // We need to wrap-around
-  }
-  memcpy(destination, &ubxFileBuffer[fileBufferTail], bytesBeforeWrapAround); // Copy the data out of the buffer
-
-  // Is there any data leftover which we need to copy from the 'bottom' of the buffer?
-  uint16_t bytesLeftToCopy = numBytes - bytesBeforeWrapAround; // Calculate if there are any bytes left to copy
-  if (bytesLeftToCopy > 0) // If there are bytes left to copy
-  {
-    memcpy(&destination[bytesBeforeWrapAround], &ubxFileBuffer[0], bytesLeftToCopy); // Copy the remaining data out of the buffer
-    fileBufferTail = bytesLeftToCopy; // Update Tail. The next byte to be read will be read from here.
-  }
-  else
-  {
-    fileBufferTail += numBytes; // Only update Tail. The next byte to be read will be read from here.
-  }
-
-  return (numBytes); // Return the number of bytes extracted
-}
-
-// Returns the number of bytes available in file buffer which are waiting to be read
-uint16_t SFE_UBLOX_GNSS::fileBufferAvailable(void)
-{
-  return (fileBufferSpaceUsed());
-}
-
-// Returns the maximum number of bytes which the file buffer contained.
-// Handy for checking the buffer is large enough to handle all the incoming data.
-uint16_t SFE_UBLOX_GNSS::getMaxFileBufferAvail(void)
-{
-  return (fileBufferMaxAvail);
-}
-
-// Clear the file buffer - discard all contents
-void SFE_UBLOX_GNSS::clearFileBuffer(void)
-{
-  if (fileBufferSize == 0) // Bail if the user has not called setFileBufferSize (probably redundant)
-    return;
-  fileBufferTail = fileBufferHead;
-}
-
-// Reset fileBufferMaxAvail
-void SFE_UBLOX_GNSS::clearMaxFileBufferAvail(void)
-{
-  fileBufferMaxAvail = 0;
-}
-
-// PRIVATE: Create the file buffer. Called by .begin
-boolean SFE_UBLOX_GNSS::createFileBuffer(void)
-{
-  if (fileBufferSize == 0) // Bail if the user has not called setFileBufferSize
-  {
-    if (_printDebug == true)
-    {
-      _debugSerial->println(F("createFileBuffer: Warning. fileBufferSize is zero. Data logging is not possible."));
-    }
-    return(false);
-  }
-
-  if (ubxFileBuffer != NULL)  // Bail if RAM has already been allocated for the file buffer
-  {                           // This will happen if you call .begin more than once - without calling .end first
-    if (_printDebug == true)
-    {
-      _debugSerial->println(F("createFileBuffer: Warning. File buffer already exists. Skipping..."));
-    }
-    return(false);
-  }
-
-  ubxFileBuffer = new uint8_t[fileBufferSize]; // Allocate RAM for the buffer
-
-  if (ubxFileBuffer == NULL) // Check if the new (alloc) was successful
-  {
-    if ((_printDebug == true) || (_printLimitedDebug == true)) // This is important. Print this if doing limited debugging
-    {
-      _debugSerial->println(F("createFileBuffer: RAM alloc failed!"));
-    }
-    return(false);
-  }
-
-  if (_printDebug == true)
-  {
-    _debugSerial->print(F("createFileBuffer: fileBufferSize is: "));
-    _debugSerial->println(fileBufferSize);
-  }
-
-  fileBufferHead = 0; // Initialize head and tail
-  fileBufferTail = 0;
-
-  return (true);
-}
-
-// PRIVATE: Check how much space is available in the buffer
-uint16_t SFE_UBLOX_GNSS::fileBufferSpaceAvailable(void)
-{
-  return (fileBufferSize - fileBufferSpaceUsed());
-}
-
-// PRIVATE: Check how much space is used in the buffer
-uint16_t SFE_UBLOX_GNSS::fileBufferSpaceUsed(void)
-{
-  if (fileBufferHead >= fileBufferTail) // Check if wrap-around has occurred
-  {
-    // Wrap-around has not occurred so do a simple subtraction
-    return (fileBufferHead - fileBufferTail);
-  }
-  else
-  {
-    // Wrap-around has occurred so do a simple subtraction but add in the fileBufferSize
-    return ((uint16_t)(((uint32_t)fileBufferHead + (uint32_t)fileBufferSize) - (uint32_t)fileBufferTail));
-  }
-}
-
-// PRIVATE: Add a UBX packet to the file buffer
-boolean SFE_UBLOX_GNSS::storePacket(ubxPacket *msg)
-{
-  // First, check that the file buffer has been created
-  if ((ubxFileBuffer == NULL) || (fileBufferSize == 0))
-  {
-    if (_printDebug == true)
-    {
-      _debugSerial->println(F("storePacket: file buffer not available!"));
-    }
-    return(false);
-  }
-
-  // Now, check if there is enough space in the buffer for all of the data
-  uint16_t totalLength = msg->len + 8; // Total length. Include sync chars, class, id, length and checksum bytes
-  if (totalLength > fileBufferSpaceAvailable())
-  {
-    if ((_printDebug == true) || (_printLimitedDebug == true)) // This is important. Print this if doing limited debugging
-    {
-      _debugSerial->println(F("storePacket: insufficient space available! Data will be lost!"));
-    }
-    return(false);
-  }
-
-  //Store the two sync chars
-  uint8_t sync_chars[] = {0xB5, 0x62};
-  writeToFileBuffer(sync_chars, 2);
-
-  //Store the Class & ID
-  writeToFileBuffer(&msg->cls, 1);
-  writeToFileBuffer(&msg->id, 1);
-
-  //Store the length. Ensure length is little-endian
-  uint8_t msg_length[2];
-  msg_length[0] = msg->len & 0xFF;
-  msg_length[1] = msg->len >> 8;
-  writeToFileBuffer(msg_length, 2);
-
-  //Store the payload
-  writeToFileBuffer(msg->payload, msg->len);
-
-  //Store the checksum
-  writeToFileBuffer(&msg->checksumA, 1);
-  writeToFileBuffer(&msg->checksumB, 1);
-
-  return (true);
-}
-
-// PRIVATE: Add theBytes to the file buffer
-boolean SFE_UBLOX_GNSS::storeFileBytes(uint8_t *theBytes, uint16_t numBytes)
-{
-  // First, check that the file buffer has been created
-  if ((ubxFileBuffer == NULL) || (fileBufferSize == 0))
-  {
-    if (_printDebug == true)
-    {
-      _debugSerial->println(F("storeFileBytes: file buffer not available!"));
-    }
-    return(false);
-  }
-
-  // Now, check if there is enough space in the buffer for all of the data
-  if (numBytes > fileBufferSpaceAvailable())
-  {
-    if ((_printDebug == true) || (_printLimitedDebug == true)) // This is important. Print this if doing limited debugging
-    {
-      _debugSerial->println(F("storeFileBytes: insufficient space available! Data will be lost!"));
-    }
-    return(false);
-  }
-
-  // There is room for all the data in the buffer so copy the data into the buffer
-  writeToFileBuffer(theBytes, numBytes);
-
-  return (true);
-}
-
-// PRIVATE: Write theBytes to the file buffer
-void SFE_UBLOX_GNSS::writeToFileBuffer(uint8_t *theBytes, uint16_t numBytes)
-{
-  // Start writing at fileBufferHead. Wrap-around if required.
-  uint16_t bytesBeforeWrapAround = fileBufferSize - fileBufferHead; // How much space is available 'above' Head?
-  if (bytesBeforeWrapAround > numBytes) // Is there enough room for all the data?
-  {
-    bytesBeforeWrapAround = numBytes; // There is enough room for all the data
-  }
-  memcpy(&ubxFileBuffer[fileBufferHead], theBytes, bytesBeforeWrapAround); // Copy the data into the buffer
-
-  // Is there any data leftover which we need to copy to the 'bottom' of the buffer?
-  uint16_t bytesLeftToCopy = numBytes - bytesBeforeWrapAround; // Calculate if there are any bytes left to copy
-  if (bytesLeftToCopy > 0) // If there are bytes left to copy
-  {
-    memcpy(&ubxFileBuffer[0], &theBytes[bytesBeforeWrapAround], bytesLeftToCopy); // Copy the remaining data into the buffer
-    fileBufferHead = bytesLeftToCopy; // Update Head. The next byte written will be written here.
-  }
-  else
-  {
-    fileBufferHead += numBytes; // Only update Head. The next byte written will be written here.
-  }
-
-  //Update fileBufferMaxAvail if required
-  uint16_t bytesInBuffer = fileBufferSpaceUsed();
-  if (bytesInBuffer > fileBufferMaxAvail)
-    fileBufferMaxAvail = bytesInBuffer;
-}
-
-//=-=-=-=-=-=-=-= Specific commands =-=-=-=-=-=-=-==-=-=-=-=-=-=-=
-//=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-==-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
-
-//Loads the payloadCfg array with the current protocol bits located the UBX-CFG-PRT register for a given port
-boolean SFE_UBLOX_GNSS::getPortSettings(uint8_t portID, uint16_t maxWait)
-{
-  packetCfg.cls = UBX_CLASS_CFG;
-  packetCfg.id = UBX_CFG_PRT;
-  packetCfg.len = 1;
-  packetCfg.startingSpot = 0;
-
-  payloadCfg[0] = portID;
-
-  return ((sendCommand(&packetCfg, maxWait)) == SFE_UBLOX_STATUS_DATA_RECEIVED); // We are expecting data and an ACK
-}
-
-//Configure a given port to output UBX, NMEA, RTCM3 or a combination thereof
-//Port 0=I2c, 1=UART1, 2=UART2, 3=USB, 4=SPI
-//Bit:0 = UBX, :1=NMEA, :5=RTCM3
-boolean SFE_UBLOX_GNSS::setPortOutput(uint8_t portID, uint8_t outStreamSettings, uint16_t maxWait)
-{
-  //Get the current config values for this port ID
-  if (getPortSettings(portID, maxWait) == false)
-    return (false); //Something went wrong. Bail.
-
-  packetCfg.cls = UBX_CLASS_CFG;
-  packetCfg.id = UBX_CFG_PRT;
-  packetCfg.len = 20;
-  packetCfg.startingSpot = 0;
-
-  //payloadCfg is now loaded with current bytes. Change only the ones we need to
-  payloadCfg[14] = outStreamSettings; //OutProtocolMask LSB - Set outStream bits
-
-  return ((sendCommand(&packetCfg, maxWait)) == SFE_UBLOX_STATUS_DATA_SENT); // We are only expecting an ACK
-}
-
-//Configure a given port to input UBX, NMEA, RTCM3 or a combination thereof
-//Port 0=I2c, 1=UART1, 2=UART2, 3=USB, 4=SPI
-//Bit:0 = UBX, :1=NMEA, :5=RTCM3
-boolean SFE_UBLOX_GNSS::setPortInput(uint8_t portID, uint8_t inStreamSettings, uint16_t maxWait)
-{
-  //Get the current config values for this port ID
-  //This will load the payloadCfg array with current port settings
-  if (getPortSettings(portID, maxWait) == false)
-    return (false); //Something went wrong. Bail.
-
-  packetCfg.cls = UBX_CLASS_CFG;
-  packetCfg.id = UBX_CFG_PRT;
-  packetCfg.len = 20;
-  packetCfg.startingSpot = 0;
-
-  //payloadCfg is now loaded with current bytes. Change only the ones we need to
-  payloadCfg[12] = inStreamSettings; //InProtocolMask LSB - Set inStream bits
-
-  return ((sendCommand(&packetCfg, maxWait)) == SFE_UBLOX_STATUS_DATA_SENT); // We are only expecting an ACK
-}
-
-//Changes the I2C address that the u-blox module responds to
-//0x42 is the default but can be changed with this command
-boolean SFE_UBLOX_GNSS::setI2CAddress(uint8_t deviceAddress, uint16_t maxWait)
-{
-  //Get the current config values for the I2C port
-  //This will load the payloadCfg array with current port settings
-  if (getPortSettings(COM_PORT_I2C, maxWait) == false)
-    return (false); //Something went wrong. Bail.
-
-  packetCfg.cls = UBX_CLASS_CFG;
-  packetCfg.id = UBX_CFG_PRT;
-  packetCfg.len = 20;
-  packetCfg.startingSpot = 0;
-
-  //payloadCfg is now loaded with current bytes. Change only the ones we need to
-  payloadCfg[4] = deviceAddress << 1; //DDC mode LSB
-
-  if (sendCommand(&packetCfg, maxWait) == SFE_UBLOX_STATUS_DATA_SENT) // We are only expecting an ACK
-  {
-    //Success! Now change our internal global.
-    _gpsI2Caddress = deviceAddress; //Store the I2C address from user
-    return (true);
-  }
-  return (false);
-}
-
-//Changes the serial baud rate of the u-blox module, can't return success/fail 'cause ACK from modem
-//is lost due to baud rate change
-void SFE_UBLOX_GNSS::setSerialRate(uint32_t baudrate, uint8_t uartPort, uint16_t maxWait)
-{
-  //Get the current config values for the UART port
-  //This will load the payloadCfg array with current port settings
-  if (getPortSettings(uartPort, maxWait) == false)
-    return; //Something went wrong. Bail.
-
-  if (_printDebug == true)
-  {
-    _debugSerial->print(F("Current baud rate: "));
-    _debugSerial->println(((uint32_t)payloadCfg[10] << 16) | ((uint32_t)payloadCfg[9] << 8) | payloadCfg[8]);
-  }
-
-  packetCfg.cls = UBX_CLASS_CFG;
-  packetCfg.id = UBX_CFG_PRT;
-  packetCfg.len = 20;
-  packetCfg.startingSpot = 0;
-
-  //payloadCfg is now loaded with current bytes. Change only the ones we need to
-  payloadCfg[8] = baudrate;
-  payloadCfg[9] = baudrate >> 8;
-  payloadCfg[10] = baudrate >> 16;
-  payloadCfg[11] = baudrate >> 24;
-
-  if (_printDebug == true)
-  {
-    _debugSerial->print(F("New baud rate:"));
-    _debugSerial->println(((uint32_t)payloadCfg[10] << 16) | ((uint32_t)payloadCfg[9] << 8) | payloadCfg[8]);
-  }
-
-  sfe_ublox_status_e retVal = sendCommand(&packetCfg, maxWait);
-  if (_printDebug == true)
-  {
-    _debugSerial->print(F("setSerialRate: sendCommand returned: "));
-    _debugSerial->println(statusString(retVal));
-  }
-}
-
-//Configure a port to output UBX, NMEA, RTCM3 or a combination thereof
-boolean SFE_UBLOX_GNSS::setI2COutput(uint8_t comSettings, uint16_t maxWait)
-{
-  return (setPortOutput(COM_PORT_I2C, comSettings, maxWait));
-}
-boolean SFE_UBLOX_GNSS::setUART1Output(uint8_t comSettings, uint16_t maxWait)
-{
-  return (setPortOutput(COM_PORT_UART1, comSettings, maxWait));
-}
-boolean SFE_UBLOX_GNSS::setUART2Output(uint8_t comSettings, uint16_t maxWait)
-{
-  return (setPortOutput(COM_PORT_UART2, comSettings, maxWait));
-}
-boolean SFE_UBLOX_GNSS::setUSBOutput(uint8_t comSettings, uint16_t maxWait)
-{
-  return (setPortOutput(COM_PORT_USB, comSettings, maxWait));
-}
-boolean SFE_UBLOX_GNSS::setSPIOutput(uint8_t comSettings, uint16_t maxWait)
-{
-  return (setPortOutput(COM_PORT_SPI, comSettings, maxWait));
-}
-
-//Want to see the NMEA messages on the Serial port? Here's how
-void SFE_UBLOX_GNSS::setNMEAOutputPort(Stream &nmeaOutputPort)
-{
-  _nmeaOutputPort = &nmeaOutputPort; //Store the port from user
-}
-
-// Reset to defaults
-
-void SFE_UBLOX_GNSS::factoryReset()
-{
-  // Copy default settings to permanent
-  // Note: this does not load the permanent configuration into the current configuration. Calling factoryDefault() will do that.
-  packetCfg.cls = UBX_CLASS_CFG;
-  packetCfg.id = UBX_CFG_CFG;
-  packetCfg.len = 13;
-  packetCfg.startingSpot = 0;
-  for (uint8_t i = 0; i < 4; i++)
-  {
-    payloadCfg[0 + i] = 0xff; // clear mask: copy default config to permanent config
-    payloadCfg[4 + i] = 0x00; // save mask: don't save current to permanent
-    payloadCfg[8 + i] = 0x00; // load mask: don't copy permanent config to current
-  }
-  payloadCfg[12] = 0xff;      // all forms of permanent memory
-  sendCommand(&packetCfg, 0); // don't expect ACK
-  hardReset();                // cause factory default config to actually be loaded and used cleanly
-}
-
-void SFE_UBLOX_GNSS::hardReset()
-{
-  // Issue hard reset
-  packetCfg.cls = UBX_CLASS_CFG;
-  packetCfg.id = UBX_CFG_RST;
-  packetCfg.len = 4;
-  packetCfg.startingSpot = 0;
-  payloadCfg[0] = 0xff;       // cold start
-  payloadCfg[1] = 0xff;       // cold start
-  payloadCfg[2] = 0;          // 0=HW reset
-  payloadCfg[3] = 0;          // reserved
-  sendCommand(&packetCfg, 0); // don't expect ACK
-}
-
-//Reset module to factory defaults
-//This still works but it is the old way of configuring ublox modules. See getVal and setVal for the new methods
-boolean SFE_UBLOX_GNSS::factoryDefault(uint16_t maxWait)
-{
-  packetCfg.cls = UBX_CLASS_CFG;
-  packetCfg.id = UBX_CFG_CFG;
-  packetCfg.len = 12;
-  packetCfg.startingSpot = 0;
-
-  //Clear packet payload
-  memset(payloadCfg, 0, packetCfg.len);
-
-  packetCfg.payload[0] = 0xFF; //Set any bit in the clearMask field to clear saved config
-  packetCfg.payload[1] = 0xFF;
-  packetCfg.payload[8] = 0xFF; //Set any bit in the loadMask field to discard current config and rebuild from lower non-volatile memory layers
-  packetCfg.payload[9] = 0xFF;
-
-  return (sendCommand(&packetCfg, maxWait) == SFE_UBLOX_STATUS_DATA_SENT); // We are only expecting an ACK
-}
-
-//Save configuration to BBR / Flash
-
-//Save current configuration to flash and BBR (battery backed RAM)
-//This still works but it is the old way of configuring ublox modules. See getVal and setVal for the new methods
-boolean SFE_UBLOX_GNSS::saveConfiguration(uint16_t maxWait)
-{
-  packetCfg.cls = UBX_CLASS_CFG;
-  packetCfg.id = UBX_CFG_CFG;
-  packetCfg.len = 12;
-  packetCfg.startingSpot = 0;
-
-  //Clear packet payload
-  memset(payloadCfg, 0, packetCfg.len);
-
-  packetCfg.payload[4] = 0xFF; //Set any bit in the saveMask field to save current config to Flash and BBR
-  packetCfg.payload[5] = 0xFF;
-
-  return (sendCommand(&packetCfg, maxWait) == SFE_UBLOX_STATUS_DATA_SENT); // We are only expecting an ACK
-}
-
-//Save the selected configuration sub-sections to flash and BBR (battery backed RAM)
-//This still works but it is the old way of configuring ublox modules. See getVal and setVal for the new methods
-boolean SFE_UBLOX_GNSS::saveConfigSelective(uint32_t configMask, uint16_t maxWait)
-{
-  packetCfg.cls = UBX_CLASS_CFG;
-  packetCfg.id = UBX_CFG_CFG;
-  packetCfg.len = 12;
-  packetCfg.startingSpot = 0;
-
-  //Clear packet payload
-  memset(payloadCfg, 0, packetCfg.len);
-
-  packetCfg.payload[4] = configMask & 0xFF; //Set the appropriate bits in the saveMask field to save current config to Flash and BBR
-  packetCfg.payload[5] = (configMask >> 8) & 0xFF;
-  packetCfg.payload[6] = (configMask >> 16) & 0xFF;
-  packetCfg.payload[7] = (configMask >> 24) & 0xFF;
-
-  return (sendCommand(&packetCfg, maxWait) == SFE_UBLOX_STATUS_DATA_SENT); // We are only expecting an ACK
-}
-
-//Configure a given message type for a given port (UART1, I2C, SPI, etc)
-boolean SFE_UBLOX_GNSS::configureMessage(uint8_t msgClass, uint8_t msgID, uint8_t portID, uint8_t sendRate, uint16_t maxWait)
-{
-  //Poll for the current settings for a given message
-  packetCfg.cls = UBX_CLASS_CFG;
-  packetCfg.id = UBX_CFG_MSG;
-  packetCfg.len = 2;
-  packetCfg.startingSpot = 0;
-
-  payloadCfg[0] = msgClass;
-  payloadCfg[1] = msgID;
-
-  //This will load the payloadCfg array with current settings of the given register
-  if (sendCommand(&packetCfg, maxWait) != SFE_UBLOX_STATUS_DATA_RECEIVED) // We are expecting data and an ACK
-    return (false);                                                       //If command send fails then bail
-
-  //Now send it back with new mods
-  packetCfg.len = 8;
-
-  //payloadCfg is now loaded with current bytes. Change only the ones we need to
-  payloadCfg[2 + portID] = sendRate; //Send rate is relative to the event a message is registered on. For example, if the rate of a navigation message is set to 2, the message is sent every 2nd navigation solution.
-
-  return ((sendCommand(&packetCfg, maxWait)) == SFE_UBLOX_STATUS_DATA_SENT); // We are only expecting an ACK
-}
-
-//Enable a given message type, default of 1 per update rate (usually 1 per second)
-boolean SFE_UBLOX_GNSS::enableMessage(uint8_t msgClass, uint8_t msgID, uint8_t portID, uint8_t rate, uint16_t maxWait)
-{
-  return (configureMessage(msgClass, msgID, portID, rate, maxWait));
-}
-//Disable a given message type on a given port
-boolean SFE_UBLOX_GNSS::disableMessage(uint8_t msgClass, uint8_t msgID, uint8_t portID, uint16_t maxWait)
-{
-  return (configureMessage(msgClass, msgID, portID, 0, maxWait));
-}
-
-boolean SFE_UBLOX_GNSS::enableNMEAMessage(uint8_t msgID, uint8_t portID, uint8_t rate, uint16_t maxWait)
-{
-  return (configureMessage(UBX_CLASS_NMEA, msgID, portID, rate, maxWait));
-}
-boolean SFE_UBLOX_GNSS::disableNMEAMessage(uint8_t msgID, uint8_t portID, uint16_t maxWait)
-{
-  return (enableNMEAMessage(msgID, portID, 0, maxWait));
-}
-
-//Given a message number turns on a message ID for output over a given portID (UART, I2C, SPI, USB, etc)
-//To disable a message, set secondsBetween messages to 0
-//Note: This function will return false if the message is already enabled
-//For base station RTK output we need to enable various sentences
-
-//NEO-M8P has four:
-//1005 = 0xF5 0x05 - Stationary RTK reference ARP
-//1077 = 0xF5 0x4D - GPS MSM7
-//1087 = 0xF5 0x57 - GLONASS MSM7
-//1230 = 0xF5 0xE6 - GLONASS code-phase biases, set to once every 10 seconds
-
-//ZED-F9P has six:
-//1005, 1074, 1084, 1094, 1124, 1230
-
-//Much of this configuration is not documented and instead discerned from u-center binary console
-boolean SFE_UBLOX_GNSS::enableRTCMmessage(uint8_t messageNumber, uint8_t portID, uint8_t sendRate, uint16_t maxWait)
-{
-  return (configureMessage(UBX_RTCM_MSB, messageNumber, portID, sendRate, maxWait));
-}
-
-//Disable a given message on a given port by setting secondsBetweenMessages to zero
-boolean SFE_UBLOX_GNSS::disableRTCMmessage(uint8_t messageNumber, uint8_t portID, uint16_t maxWait)
-{
-  return (enableRTCMmessage(messageNumber, portID, 0, maxWait));
-}
-
-//Functions used for RTK and base station setup
-
-//Get the current TimeMode3 settings - these contain survey in statuses
-boolean SFE_UBLOX_GNSS::getSurveyMode(uint16_t maxWait)
-{
-  packetCfg.cls = UBX_CLASS_CFG;
-  packetCfg.id = UBX_CFG_TMODE3;
-  packetCfg.len = 0;
-  packetCfg.startingSpot = 0;
-
-  return ((sendCommand(&packetCfg, maxWait)) == SFE_UBLOX_STATUS_DATA_RECEIVED); // We are expecting data and an ACK
-}
-
-//Control Survey-In for NEO-M8P
-boolean SFE_UBLOX_GNSS::setSurveyMode(uint8_t mode, uint16_t observationTime, float requiredAccuracy, uint16_t maxWait)
-{
-  if (getSurveyMode(maxWait) == false) //Ask module for the current TimeMode3 settings. Loads into payloadCfg.
-    return (false);
-
-  packetCfg.cls = UBX_CLASS_CFG;
-  packetCfg.id = UBX_CFG_TMODE3;
-  packetCfg.len = 40;
-  packetCfg.startingSpot = 0;
-
-  //payloadCfg should be loaded with poll response. Now modify only the bits we care about
-  payloadCfg[2] = mode; //Set mode. Survey-In and Disabled are most common. Use ECEF (not LAT/LON/ALT).
-
-  //svinMinDur is U4 (uint32_t) but we'll only use a uint16_t (waiting more than 65535 seconds seems excessive!)
-  payloadCfg[24] = observationTime & 0xFF; //svinMinDur in seconds
-  payloadCfg[25] = observationTime >> 8;   //svinMinDur in seconds
-  payloadCfg[26] = 0;                      //Truncate to 16 bits
-  payloadCfg[27] = 0;                      //Truncate to 16 bits
-
-  //svinAccLimit is U4 (uint32_t) in 0.1mm.
-  uint32_t svinAccLimit = (uint32_t)(requiredAccuracy * 10000.0); //Convert m to 0.1mm
-  payloadCfg[28] = svinAccLimit & 0xFF;                           //svinAccLimit in 0.1mm increments
-  payloadCfg[29] = svinAccLimit >> 8;
-  payloadCfg[30] = svinAccLimit >> 16;
-  payloadCfg[31] = svinAccLimit >> 24;
-
-  return ((sendCommand(&packetCfg, maxWait)) == SFE_UBLOX_STATUS_DATA_SENT); // We are only expecting an ACK
-}
-
-//Begin Survey-In for NEO-M8P
-boolean SFE_UBLOX_GNSS::enableSurveyMode(uint16_t observationTime, float requiredAccuracy, uint16_t maxWait)
-{
-  return (setSurveyMode(SVIN_MODE_ENABLE, observationTime, requiredAccuracy, maxWait));
-}
-
-//Stop Survey-In for NEO-M8P
-boolean SFE_UBLOX_GNSS::disableSurveyMode(uint16_t maxWait)
-{
-  return (setSurveyMode(SVIN_MODE_DISABLE, 0, 0, maxWait));
-}
-
-//Set the ECEF or Lat/Long coordinates of a receiver
-//This imediately puts the receiver in TIME mode (fixed) and will begin outputting RTCM sentences if enabled
-//This is helpful once an antenna's position has been established. See this tutorial: https://learn.sparkfun.com/tutorials/how-to-build-a-diy-gnss-reference-station#gather-raw-gnss-data
-// For ECEF the units are: cm, 0.1mm, cm, 0.1mm, cm, 0.1mm
-// For Lat/Lon/Alt the units are: degrees^-7, degrees^-9, degrees^-7, degrees^-9, cm, 0.1mm
-bool SFE_UBLOX_GNSS::setStaticPosition(int32_t ecefXOrLat, int8_t ecefXOrLatHP, int32_t ecefYOrLon, int8_t ecefYOrLonHP, int32_t ecefZOrAlt, int8_t ecefZOrAltHP, bool latLong, uint16_t maxWait)
-{
-  packetCfg.cls = UBX_CLASS_CFG;
-  packetCfg.id = UBX_CFG_TMODE3;
-  packetCfg.len = 0;
-  packetCfg.startingSpot = 0;
-
-  //Ask module for the current TimeMode3 settings. Loads into payloadCfg.
-  if (sendCommand(&packetCfg, maxWait) != SFE_UBLOX_STATUS_DATA_RECEIVED)
-    return (false);
-
-  packetCfg.len = 40;
-
-  //customCfg should be loaded with poll response. Now modify only the bits we care about
-  payloadCfg[2] = 2; //Set mode to fixed. Use ECEF (not LAT/LON/ALT).
-
-  if (latLong == true)
-    payloadCfg[3] = (uint8_t)(1 << 0); //Set mode to fixed. Use LAT/LON/ALT.
-
-  //Set ECEF X or Lat
-  payloadCfg[4] = (ecefXOrLat >> 8 * 0) & 0xFF; //LSB
-  payloadCfg[5] = (ecefXOrLat >> 8 * 1) & 0xFF;
-  payloadCfg[6] = (ecefXOrLat >> 8 * 2) & 0xFF;
-  payloadCfg[7] = (ecefXOrLat >> 8 * 3) & 0xFF; //MSB
-
-  //Set ECEF Y or Long
-  payloadCfg[8] = (ecefYOrLon >> 8 * 0) & 0xFF; //LSB
-  payloadCfg[9] = (ecefYOrLon >> 8 * 1) & 0xFF;
-  payloadCfg[10] = (ecefYOrLon >> 8 * 2) & 0xFF;
-  payloadCfg[11] = (ecefYOrLon >> 8 * 3) & 0xFF; //MSB
-
-  //Set ECEF Z or Altitude
-  payloadCfg[12] = (ecefZOrAlt >> 8 * 0) & 0xFF; //LSB
-  payloadCfg[13] = (ecefZOrAlt >> 8 * 1) & 0xFF;
-  payloadCfg[14] = (ecefZOrAlt >> 8 * 2) & 0xFF;
-  payloadCfg[15] = (ecefZOrAlt >> 8 * 3) & 0xFF; //MSB
-
-  //Set high precision parts
-  payloadCfg[16] = ecefXOrLatHP;
-  payloadCfg[17] = ecefYOrLonHP;
-  payloadCfg[18] = ecefZOrAltHP;
-
-  return ((sendCommand(&packetCfg, maxWait)) == SFE_UBLOX_STATUS_DATA_SENT); // We are only expecting an ACK
-}
-
-bool SFE_UBLOX_GNSS::setStaticPosition(int32_t ecefXOrLat, int32_t ecefYOrLon, int32_t ecefZOrAlt, bool latlong, uint16_t maxWait)
-{
-  return (setStaticPosition(ecefXOrLat, 0, ecefYOrLon, 0, ecefZOrAlt, 0, latlong, maxWait));
-}
-
-// Module Protocol Version
-
-//Get the current protocol version of the u-blox module we're communicating with
-//This is helpful when deciding if we should call the high-precision Lat/Long (HPPOSLLH) or the regular (POSLLH)
-uint8_t SFE_UBLOX_GNSS::getProtocolVersionHigh(uint16_t maxWait)
-{
-  if (moduleSWVersion == NULL) initModuleSWVersion(); //Check that RAM has been allocated for the SW version
-  if (moduleSWVersion == NULL) //Bail if the RAM allocation failed
-    return (false);
-
-  if (moduleSWVersion->moduleQueried == false)
-    getProtocolVersion(maxWait);
-  return (moduleSWVersion->versionHigh);
-}
-
-//Get the current protocol version of the u-blox module we're communicating with
-//This is helpful when deciding if we should call the high-precision Lat/Long (HPPOSLLH) or the regular (POSLLH)
-uint8_t SFE_UBLOX_GNSS::getProtocolVersionLow(uint16_t maxWait)
-{
-  if (moduleSWVersion == NULL) initModuleSWVersion(); //Check that RAM has been allocated for the SW version
-  if (moduleSWVersion == NULL) //Bail if the RAM allocation failed
-    return (false);
-
-  if (moduleSWVersion->moduleQueried == false)
-    getProtocolVersion(maxWait);
-  return (moduleSWVersion->versionLow);
-}
-
-//Get the current protocol version of the u-blox module we're communicating with
-//This is helpful when deciding if we should call the high-precision Lat/Long (HPPOSLLH) or the regular (POSLLH)
-boolean SFE_UBLOX_GNSS::getProtocolVersion(uint16_t maxWait)
-{
-  if (moduleSWVersion == NULL) initModuleSWVersion(); //Check that RAM has been allocated for the SW version
-  if (moduleSWVersion == NULL) //Bail if the RAM allocation failed
-    return (false);
-
-  //Send packet with only CLS and ID, length of zero. This will cause the module to respond with the contents of that CLS/ID.
-  packetCfg.cls = UBX_CLASS_MON;
-  packetCfg.id = UBX_MON_VER;
-
-  packetCfg.len = 0;
-  packetCfg.startingSpot = 40; //Start at first "extended software information" string
-
-  if (sendCommand(&packetCfg, maxWait) != SFE_UBLOX_STATUS_DATA_RECEIVED) // We are only expecting data (no ACK)
-    return (false);                                                       //If command send fails then bail
-
-  //Payload should now contain ~220 characters (depends on module type)
-
-  // if (_printDebug == true)
-  // {
-  //   _debugSerial->print(F("MON VER Payload:"));
-  //   for (int location = 0; location < packetCfg.len; location++)
-  //   {
-  //     if (location % 30 == 0)
-  //       _debugSerial->println();
-  //     _debugSerial->write(payloadCfg[location]);
-  //   }
-  //   _debugSerial->println();
-  // }
-
-  //We will step through the payload looking at each extension field of 30 bytes
-  for (uint8_t extensionNumber = 0; extensionNumber < 10; extensionNumber++)
-  {
-    //Now we need to find "PROTVER=18.00" in the incoming byte stream
-    if ((payloadCfg[(30 * extensionNumber) + 0] == 'P') && (payloadCfg[(30 * extensionNumber) + 6] == 'R'))
-    {
-      moduleSWVersion->versionHigh = (payloadCfg[(30 * extensionNumber) + 8] - '0') * 10 + (payloadCfg[(30 * extensionNumber) + 9] - '0');  //Convert '18' to 18
-      moduleSWVersion->versionLow = (payloadCfg[(30 * extensionNumber) + 11] - '0') * 10 + (payloadCfg[(30 * extensionNumber) + 12] - '0'); //Convert '00' to 00
-      moduleSWVersion->moduleQueried = true; // Mark this data as new
-
-      if (_printDebug == true)
-      {
-        _debugSerial->print(F("Protocol version: "));
-        _debugSerial->print(moduleSWVersion->versionHigh);
-        _debugSerial->print(F("."));
-        _debugSerial->println(moduleSWVersion->versionLow);
-      }
-      return (true); //Success!
-    }
-  }
-
-  return (false); //We failed
-}
-
-// PRIVATE: Allocate RAM for moduleSWVersion and initialize it
-boolean SFE_UBLOX_GNSS::initModuleSWVersion()
-{
-  moduleSWVersion = new moduleSWVersion_t; //Allocate RAM for the main struct
-  if (moduleSWVersion == NULL)
-  {
-    if ((_printDebug == true) || (_printLimitedDebug == true)) // This is important. Print this if doing limited debugging
-      _debugSerial->println(F("initModuleSWVersion: PANIC! RAM allocation failed!"));
-    return (false);
-  }
-  moduleSWVersion->versionHigh = 0;
-  moduleSWVersion->versionLow = 0;
-  moduleSWVersion->moduleQueried = false;
-  return (true);
-}
-
-// Geofences
-
-//Add a new geofence using UBX-CFG-GEOFENCE
-boolean SFE_UBLOX_GNSS::addGeofence(int32_t latitude, int32_t longitude, uint32_t radius, byte confidence, byte pinPolarity, byte pin, uint16_t maxWait)
-{
-  if (currentGeofenceParams == NULL) initGeofenceParams(); // Check if RAM has been allocated for currentGeofenceParams
-  if (currentGeofenceParams == NULL) // Abort if the RAM allocation failed
-    return (false);
-
-  if (currentGeofenceParams->numFences >= 4)
-    return (false); // Quit if we already have four geofences defined
-
-  // Store the new geofence parameters
-  currentGeofenceParams->lats[currentGeofenceParams->numFences] = latitude;
-  currentGeofenceParams->longs[currentGeofenceParams->numFences] = longitude;
-  currentGeofenceParams->rads[currentGeofenceParams->numFences] = radius;
-  currentGeofenceParams->numFences = currentGeofenceParams->numFences + 1; // Increment the number of fences
-
-  packetCfg.cls = UBX_CLASS_CFG;
-  packetCfg.id = UBX_CFG_GEOFENCE;
-  packetCfg.len = (currentGeofenceParams->numFences * 12) + 8;
-  packetCfg.startingSpot = 0;
-
-  payloadCfg[0] = 0;                               // Message version = 0x00
-  payloadCfg[1] = currentGeofenceParams->numFences; // numFences
-  payloadCfg[2] = confidence;                      // confLvl = Confidence level 0-4 (none, 68%, 95%, 99.7%, 99.99%)
-  payloadCfg[3] = 0;                               // reserved1
-  if (pin > 0)
-  {
-    payloadCfg[4] = 1; // enable PIO combined fence state
-  }
-  else
-  {
-    payloadCfg[4] = 0; // disable PIO combined fence state
-  }
-  payloadCfg[5] = pinPolarity; // PIO pin polarity (0 = low means inside, 1 = low means outside (or unknown))
-  payloadCfg[6] = pin;         // PIO pin
-  payloadCfg[7] = 0;           //reserved2
-  payloadCfg[8] = currentGeofenceParams->lats[0] & 0xFF;
-  payloadCfg[9] = currentGeofenceParams->lats[0] >> 8;
-  payloadCfg[10] = currentGeofenceParams->lats[0] >> 16;
-  payloadCfg[11] = currentGeofenceParams->lats[0] >> 24;
-  payloadCfg[12] = currentGeofenceParams->longs[0] & 0xFF;
-  payloadCfg[13] = currentGeofenceParams->longs[0] >> 8;
-  payloadCfg[14] = currentGeofenceParams->longs[0] >> 16;
-  payloadCfg[15] = currentGeofenceParams->longs[0] >> 24;
-  payloadCfg[16] = currentGeofenceParams->rads[0] & 0xFF;
-  payloadCfg[17] = currentGeofenceParams->rads[0] >> 8;
-  payloadCfg[18] = currentGeofenceParams->rads[0] >> 16;
-  payloadCfg[19] = currentGeofenceParams->rads[0] >> 24;
-  if (currentGeofenceParams->numFences >= 2)
-  {
-    payloadCfg[20] = currentGeofenceParams->lats[1] & 0xFF;
-    payloadCfg[21] = currentGeofenceParams->lats[1] >> 8;
-    payloadCfg[22] = currentGeofenceParams->lats[1] >> 16;
-    payloadCfg[23] = currentGeofenceParams->lats[1] >> 24;
-    payloadCfg[24] = currentGeofenceParams->longs[1] & 0xFF;
-    payloadCfg[25] = currentGeofenceParams->longs[1] >> 8;
-    payloadCfg[26] = currentGeofenceParams->longs[1] >> 16;
-    payloadCfg[27] = currentGeofenceParams->longs[1] >> 24;
-    payloadCfg[28] = currentGeofenceParams->rads[1] & 0xFF;
-    payloadCfg[29] = currentGeofenceParams->rads[1] >> 8;
-    payloadCfg[30] = currentGeofenceParams->rads[1] >> 16;
-    payloadCfg[31] = currentGeofenceParams->rads[1] >> 24;
-  }
-  if (currentGeofenceParams->numFences >= 3)
-  {
-    payloadCfg[32] = currentGeofenceParams->lats[2] & 0xFF;
-    payloadCfg[33] = currentGeofenceParams->lats[2] >> 8;
-    payloadCfg[34] = currentGeofenceParams->lats[2] >> 16;
-    payloadCfg[35] = currentGeofenceParams->lats[2] >> 24;
-    payloadCfg[36] = currentGeofenceParams->longs[2] & 0xFF;
-    payloadCfg[37] = currentGeofenceParams->longs[2] >> 8;
-    payloadCfg[38] = currentGeofenceParams->longs[2] >> 16;
-    payloadCfg[39] = currentGeofenceParams->longs[2] >> 24;
-    payloadCfg[40] = currentGeofenceParams->rads[2] & 0xFF;
-    payloadCfg[41] = currentGeofenceParams->rads[2] >> 8;
-    payloadCfg[42] = currentGeofenceParams->rads[2] >> 16;
-    payloadCfg[43] = currentGeofenceParams->rads[2] >> 24;
-  }
-  if (currentGeofenceParams->numFences >= 4)
-  {
-    payloadCfg[44] = currentGeofenceParams->lats[3] & 0xFF;
-    payloadCfg[45] = currentGeofenceParams->lats[3] >> 8;
-    payloadCfg[46] = currentGeofenceParams->lats[3] >> 16;
-    payloadCfg[47] = currentGeofenceParams->lats[3] >> 24;
-    payloadCfg[48] = currentGeofenceParams->longs[3] & 0xFF;
-    payloadCfg[49] = currentGeofenceParams->longs[3] >> 8;
-    payloadCfg[50] = currentGeofenceParams->longs[3] >> 16;
-    payloadCfg[51] = currentGeofenceParams->longs[3] >> 24;
-    payloadCfg[52] = currentGeofenceParams->rads[3] & 0xFF;
-    payloadCfg[53] = currentGeofenceParams->rads[3] >> 8;
-    payloadCfg[54] = currentGeofenceParams->rads[3] >> 16;
-    payloadCfg[55] = currentGeofenceParams->rads[3] >> 24;
-  }
-  return ((sendCommand(&packetCfg, maxWait)) == SFE_UBLOX_STATUS_DATA_SENT); // We are only expecting an ACK
-}
-
-//Clear all geofences using UBX-CFG-GEOFENCE
-boolean SFE_UBLOX_GNSS::clearGeofences(uint16_t maxWait)
-{
-  if (currentGeofenceParams == NULL) initGeofenceParams(); // Check if RAM has been allocated for currentGeofenceParams
-  if (currentGeofenceParams == NULL) // Abort if the RAM allocation failed
-    return (false);
-
-  packetCfg.cls = UBX_CLASS_CFG;
-  packetCfg.id = UBX_CFG_GEOFENCE;
-  packetCfg.len = 8;
-  packetCfg.startingSpot = 0;
-
-  payloadCfg[0] = 0; // Message version = 0x00
-  payloadCfg[1] = 0; // numFences
-  payloadCfg[2] = 0; // confLvl
-  payloadCfg[3] = 0; // reserved1
-  payloadCfg[4] = 0; // disable PIO combined fence state
-  payloadCfg[5] = 0; // PIO pin polarity (0 = low means inside, 1 = low means outside (or unknown))
-  payloadCfg[6] = 0; // PIO pin
-  payloadCfg[7] = 0; //reserved2
-
-  currentGeofenceParams->numFences = 0; // Zero the number of geofences currently in use
-
-  return ((sendCommand(&packetCfg, maxWait)) == SFE_UBLOX_STATUS_DATA_SENT); // We are only expecting an ACK
-}
-
-//Clear the antenna control settings using UBX-CFG-ANT
-//This function is hopefully redundant but may be needed to release
-//any PIO pins pre-allocated for antenna functions
-boolean SFE_UBLOX_GNSS::clearAntPIO(uint16_t maxWait)
-{
-  packetCfg.cls = UBX_CLASS_CFG;
-  packetCfg.id = UBX_CFG_ANT;
-  packetCfg.len = 4;
-  packetCfg.startingSpot = 0;
-
-  payloadCfg[0] = 0x10; // Antenna flag mask: set the recovery bit
-  payloadCfg[1] = 0;
-  payloadCfg[2] = 0xFF; // Antenna pin configuration: set pinSwitch and pinSCD to 31
-  payloadCfg[3] = 0xFF; // Antenna pin configuration: set pinOCD to 31, set reconfig bit
-
-  return ((sendCommand(&packetCfg, maxWait)) == SFE_UBLOX_STATUS_DATA_SENT); // We are only expecting an ACK
-}
-
-//Returns the combined geofence state using UBX-NAV-GEOFENCE
-boolean SFE_UBLOX_GNSS::getGeofenceState(geofenceState &currentGeofenceState, uint16_t maxWait)
-{
-  packetCfg.cls = UBX_CLASS_NAV;
-  packetCfg.id = UBX_NAV_GEOFENCE;
-  packetCfg.len = 0;
-  packetCfg.startingSpot = 0;
-
-  //Ask module for the geofence status. Loads into payloadCfg.
-  if (sendCommand(&packetCfg, maxWait) != SFE_UBLOX_STATUS_DATA_RECEIVED) // We are expecting data and an ACK
-    return (false);
-
-  currentGeofenceState.status = payloadCfg[5];    // Extract the status
-  currentGeofenceState.numFences = payloadCfg[6]; // Extract the number of geofences
-  currentGeofenceState.combState = payloadCfg[7]; // Extract the combined state of all geofences
-  if (currentGeofenceState.numFences > 0)
-    currentGeofenceState.states[0] = payloadCfg[8]; // Extract geofence 1 state
-  if (currentGeofenceState.numFences > 1)
-    currentGeofenceState.states[1] = payloadCfg[10]; // Extract geofence 2 state
-  if (currentGeofenceState.numFences > 2)
-    currentGeofenceState.states[2] = payloadCfg[12]; // Extract geofence 3 state
-  if (currentGeofenceState.numFences > 3)
-    currentGeofenceState.states[3] = payloadCfg[14]; // Extract geofence 4 state
-
-  return (true);
-}
-
-// PRIVATE: Allocate RAM for currentGeofenceParams and initialize it
-boolean SFE_UBLOX_GNSS::initGeofenceParams()
-{
-  currentGeofenceParams = new geofenceParams_t; //Allocate RAM for the main struct
-  if (currentGeofenceParams == NULL)
-  {
-    if ((_printDebug == true) || (_printLimitedDebug == true)) // This is important. Print this if doing limited debugging
-      _debugSerial->println(F("initGeofenceParams: PANIC! RAM allocation failed!"));
-    return (false);
-  }
-  currentGeofenceParams->numFences = 0;
-  return (true);
-}
-
-//Power Save Mode
-//Enables/Disables Low Power Mode using UBX-CFG-RXM
-boolean SFE_UBLOX_GNSS::powerSaveMode(bool power_save, uint16_t maxWait)
-{
-  // Let's begin by checking the Protocol Version as UBX_CFG_RXM is not supported on the ZED (protocol >= 27)
-  uint8_t protVer = getProtocolVersionHigh(maxWait);
-  /*
-  if (_printDebug == true)
-  {
-    _debugSerial->print(F("Protocol version is "));
-    _debugSerial->println(protVer);
-  }
-  */
-  if (protVer >= 27)
-  {
-    if ((_printDebug == true) || (_printLimitedDebug == true)) // This is important. Print this if doing limited debugging
-    {
-      _debugSerial->println(F("powerSaveMode (UBX-CFG-RXM) is not supported by this protocol version"));
-    }
-    return (false);
-  }
-
-  // Now let's change the power setting using UBX-CFG-RXM
-  packetCfg.cls = UBX_CLASS_CFG;
-  packetCfg.id = UBX_CFG_RXM;
-  packetCfg.len = 0;
-  packetCfg.startingSpot = 0;
-
-  //Ask module for the current power management settings. Loads into payloadCfg.
-  if (sendCommand(&packetCfg, maxWait) != SFE_UBLOX_STATUS_DATA_RECEIVED) // We are expecting data and an ACK
-    return (false);
-
-  if (power_save)
-  {
-    payloadCfg[1] = 1; // Power Save Mode
-  }
-  else
-  {
-    payloadCfg[1] = 0; // Continuous Mode
-  }
-
-  packetCfg.len = 2;
-  packetCfg.startingSpot = 0;
-
-  return (sendCommand(&packetCfg, maxWait) == SFE_UBLOX_STATUS_DATA_SENT); // We are only expecting an ACK
-}
-
-// Get Power Save Mode
-// Returns the current Low Power Mode using UBX-CFG-RXM
-// Returns 255 if the sendCommand fails
-uint8_t SFE_UBLOX_GNSS::getPowerSaveMode(uint16_t maxWait)
-{
-  // Let's begin by checking the Protocol Version as UBX_CFG_RXM is not supported on the ZED (protocol >= 27)
-  uint8_t protVer = getProtocolVersionHigh(maxWait);
-  /*
-  if (_printDebug == true)
-  {
-    _debugSerial->print(F("Protocol version is "));
-    _debugSerial->println(protVer);
-  }
-  */
-  if (protVer >= 27)
-  {
-    if ((_printDebug == true) || (_printLimitedDebug == true)) // This is important. Print this if doing limited debugging
-    {
-      _debugSerial->println(F("powerSaveMode (UBX-CFG-RXM) is not supported by this protocol version"));
-    }
-    return (255);
-  }
-
-  // Now let's read the power setting using UBX-CFG-RXM
-  packetCfg.cls = UBX_CLASS_CFG;
-  packetCfg.id = UBX_CFG_RXM;
-  packetCfg.len = 0;
-  packetCfg.startingSpot = 0;
-
-  //Ask module for the current power management settings. Loads into payloadCfg.
-  if (sendCommand(&packetCfg, maxWait) != SFE_UBLOX_STATUS_DATA_RECEIVED) // We are expecting data and an ACK
-    return (255);
-
-  return (payloadCfg[1]); // Return the low power mode
-}
-
-// Powers off the GPS device for a given duration to reduce power consumption.
-// NOTE: Querying the device before the duration is complete, for example by "getLatitude()" will wake it up!
-// Returns true if command has not been not acknowledged.
-// Returns false if command has not been acknowledged or maxWait = 0.
-boolean SFE_UBLOX_GNSS::powerOff(uint32_t durationInMs, uint16_t maxWait)
-{
-  // use durationInMs = 0 for infinite duration
-  if (_printDebug == true)
-  {
-    _debugSerial->print(F("Powering off for "));
-    _debugSerial->print(durationInMs);
-    _debugSerial->println(" ms");
-  }
-
-  // Power off device using UBX-RXM-PMREQ
-  packetCfg.cls = UBX_CLASS_RXM; // 0x02
-  packetCfg.id = UBX_RXM_PMREQ;  // 0x41
-  packetCfg.len = 8;
-  packetCfg.startingSpot = 0;
-
-  // duration
-  // big endian to little endian, switch byte order
-  payloadCfg[0] = (durationInMs >> (8 * 0)) & 0xff;
-  payloadCfg[1] = (durationInMs >> (8 * 1)) & 0xff;
-  payloadCfg[2] = (durationInMs >> (8 * 2)) & 0xff;
-  payloadCfg[3] = (durationInMs >> (8 * 3)) & 0xff;
-
-  payloadCfg[4] = 0x02; //Flags : set the backup bit
-  payloadCfg[5] = 0x00; //Flags
-  payloadCfg[6] = 0x00; //Flags
-  payloadCfg[7] = 0x00; //Flags
-
-  if (maxWait != 0)
-  {
-    // check for "not acknowledged" command
-    return (sendCommand(&packetCfg, maxWait) != SFE_UBLOX_STATUS_COMMAND_NACK);
-  }
-  else
-  {
-    sendCommand(&packetCfg, maxWait);
-    return false; // can't tell if command not acknowledged if maxWait = 0
-  }
-}
-
-// Powers off the GPS device for a given duration to reduce power consumption.
-// While powered off it can be woken up by creating a falling or rising voltage edge on the specified pin.
-// NOTE: The GPS seems to be sensitve to signals on the pins while powered off. Works best when Microcontroller is in deepsleep.
-// NOTE: Querying the device before the duration is complete, for example by "getLatitude()" will wake it up!
-// Returns true if command has not been not acknowledged.
-// Returns false if command has not been acknowledged or maxWait = 0.
-boolean SFE_UBLOX_GNSS::powerOffWithInterrupt(uint32_t durationInMs, uint32_t wakeupSources, boolean forceWhileUsb, uint16_t maxWait)
-{
-  // use durationInMs = 0 for infinite duration
-  if (_printDebug == true)
-  {
-    _debugSerial->print(F("Powering off for "));
-    _debugSerial->print(durationInMs);
-    _debugSerial->println(" ms");
-  }
-
-  // Power off device using UBX-RXM-PMREQ
-  packetCfg.cls = UBX_CLASS_RXM; // 0x02
-  packetCfg.id = UBX_RXM_PMREQ;  // 0x41
-  packetCfg.len = 16;
-  packetCfg.startingSpot = 0;
-
-  payloadCfg[0] = 0x00; // message version
-
-  // bytes 1-3 are reserved - and must be set to zero
-  payloadCfg[1] = 0x00;
-  payloadCfg[2] = 0x00;
-  payloadCfg[3] = 0x00;
-
-  // duration
-  // big endian to little endian, switch byte order
-  payloadCfg[4] = (durationInMs >> (8 * 0)) & 0xff;
-  payloadCfg[5] = (durationInMs >> (8 * 1)) & 0xff;
-  payloadCfg[6] = (durationInMs >> (8 * 2)) & 0xff;
-  payloadCfg[7] = (durationInMs >> (8 * 3)) & 0xff;
-
-  // flags
-
-  // disables USB interface when powering off, defaults to true
-  if (forceWhileUsb)
-  {
-    payloadCfg[8] = 0x06; // force | backup
-  }
-  else
-  {
-    payloadCfg[8] = 0x02; // backup only (leave the force bit clear - module will stay on if USB is connected)
-  }
-
-  payloadCfg[9] = 0x00;
-  payloadCfg[10] = 0x00;
-  payloadCfg[11] = 0x00;
-
-  // wakeUpSources
-
-  // wakeupPin mapping, defaults to VAL_RXM_PMREQ_WAKEUPSOURCE_EXTINT0
-
-  // Possible values are:
-  // VAL_RXM_PMREQ_WAKEUPSOURCE_UARTRX
-  // VAL_RXM_PMREQ_WAKEUPSOURCE_EXTINT0
-  // VAL_RXM_PMREQ_WAKEUPSOURCE_EXTINT1
-  // VAL_RXM_PMREQ_WAKEUPSOURCE_SPICS
-
-  payloadCfg[12] = (wakeupSources >> (8 * 0)) & 0xff;
-  payloadCfg[13] = (wakeupSources >> (8 * 1)) & 0xff;
-  payloadCfg[14] = (wakeupSources >> (8 * 2)) & 0xff;
-  payloadCfg[15] = (wakeupSources >> (8 * 3)) & 0xff;
-
-  if (maxWait != 0)
-  {
-    // check for "not acknowledged" command
-    return (sendCommand(&packetCfg, maxWait) != SFE_UBLOX_STATUS_COMMAND_NACK);
-  }
-  else
-  {
-    sendCommand(&packetCfg, maxWait);
-    return false; // can't tell if command not acknowledged if maxWait = 0
-  }
-}
-
-//Dynamic Platform Model
-
-//Change the dynamic platform model using UBX-CFG-NAV5
-//Possible values are:
-//PORTABLE,STATIONARY,PEDESTRIAN,AUTOMOTIVE,SEA,
-//AIRBORNE1g,AIRBORNE2g,AIRBORNE4g,WRIST,BIKE
-//WRIST is not supported in protocol versions less than 18
-//BIKE is supported in protocol versions 19.2
-boolean SFE_UBLOX_GNSS::setDynamicModel(dynModel newDynamicModel, uint16_t maxWait)
-{
-  packetCfg.cls = UBX_CLASS_CFG;
-  packetCfg.id = UBX_CFG_NAV5;
-  packetCfg.len = 0;
-  packetCfg.startingSpot = 0;
-
-  //Ask module for the current navigation model settings. Loads into payloadCfg.
-  if (sendCommand(&packetCfg, maxWait) != SFE_UBLOX_STATUS_DATA_RECEIVED) // We are expecting data and an ACK
-    return (false);
-
-  payloadCfg[0] = 0x01;            // mask: set only the dyn bit (0)
-  payloadCfg[1] = 0x00;            // mask
-  payloadCfg[2] = newDynamicModel; // dynModel
-
-  packetCfg.len = 36;
-  packetCfg.startingSpot = 0;
-
-  return (sendCommand(&packetCfg, maxWait) == SFE_UBLOX_STATUS_DATA_SENT); // We are only expecting an ACK
-}
-
-//Get the dynamic platform model using UBX-CFG-NAV5
-//Returns DYN_MODEL_UNKNOWN (255) if the sendCommand fails
-uint8_t SFE_UBLOX_GNSS::getDynamicModel(uint16_t maxWait)
-{
-  packetCfg.cls = UBX_CLASS_CFG;
-  packetCfg.id = UBX_CFG_NAV5;
-  packetCfg.len = 0;
-  packetCfg.startingSpot = 0;
-
-  //Ask module for the current navigation model settings. Loads into payloadCfg.
-  if (sendCommand(&packetCfg, maxWait) != SFE_UBLOX_STATUS_DATA_RECEIVED) // We are expecting data and an ACK
-    return (DYN_MODEL_UNKNOWN);
-
-  return (payloadCfg[2]); // Return the dynamic model
-}
-
-//Reset the odometer
-boolean SFE_UBLOX_GNSS::resetOdometer(uint16_t maxWait)
-{
-  packetCfg.cls = UBX_CLASS_NAV;
-  packetCfg.id = UBX_NAV_RESETODO;
-  packetCfg.len = 0;
-  packetCfg.startingSpot = 0;
-
-  // This is a special case as we are only expecting an ACK but this is not a CFG message
-  return (sendCommand(&packetCfg, maxWait, true) == SFE_UBLOX_STATUS_DATA_SENT); // We are only expecting an ACK
-}
-
-//Enable/Disable individual GNSS systems using UBX-CFG-GNSS
-boolean SFE_UBLOX_GNSS::enableGNSS(boolean enable, sfe_ublox_gnss_ids_e id, uint16_t maxWait)
-{
-  packetCfg.cls = UBX_CLASS_CFG;
-  packetCfg.id = UBX_CFG_GNSS;
-  packetCfg.len = 0;
-  packetCfg.startingSpot = 0;
-
-  if (sendCommand(&packetCfg, maxWait) != SFE_UBLOX_STATUS_DATA_RECEIVED) // We are expecting data and an ACK
-    return (false);
-
-  uint8_t numConfigBlocks = payloadCfg[3]; // Extract the numConfigBlocks
-
-  for (uint8_t block = 0; block < numConfigBlocks; block++) // Check each configuration block
-  {
-    if (payloadCfg[(block * 8) + 4] == (uint8_t)id) // Check the gnssId for this block. Do we have a match?
-    {
-      // We have a match so set/clear the enable bit in flags
-      if (enable)
-        payloadCfg[(block * 8) + 4 + 4] |= 0x01; // Set the enable bit in flags (Little Endian)
-      else
-        payloadCfg[(block * 8) + 4 + 4] &= 0xFE; // Clear the enable bit in flags (Little Endian)
-    }
-  }
-
-  return (sendCommand(&packetCfg, maxWait) == SFE_UBLOX_STATUS_DATA_SENT); // We are only expecting an ACK
-}
-
-//Check if an individual GNSS system is enabled
-boolean SFE_UBLOX_GNSS::isGNSSenabled(sfe_ublox_gnss_ids_e id, uint16_t maxWait)
-{
-  packetCfg.cls = UBX_CLASS_CFG;
-  packetCfg.id = UBX_CFG_GNSS;
-  packetCfg.len = 0;
-  packetCfg.startingSpot = 0;
-
-  if (sendCommand(&packetCfg, maxWait) != SFE_UBLOX_STATUS_DATA_RECEIVED) // We are expecting data and an ACK
-    return (false);
-
-  boolean retVal = false;
-
-  uint8_t numConfigBlocks = payloadCfg[3]; // Extract the numConfigBlocks
-
-  for (uint8_t block = 0; block < numConfigBlocks; block++) // Check each configuration block
-  {
-    if (payloadCfg[(block * 8) + 4] == (uint8_t)id) // Check the gnssId for this block. Do we have a match?
-    {
-      // We have a match so check the enable bit in flags
-      if ((payloadCfg[(block * 8) + 4 + 4] & 0x01) > 0) // Check the enable bit in flags (Little Endian)
-        retVal = true;
-    }
-  }
-
-  return (retVal);
-}
-
-//Reset ESF automatic IMU-mount alignment
-boolean SFE_UBLOX_GNSS::resetIMUalignment(uint16_t maxWait)
-{
-  packetCfg.cls = UBX_CLASS_ESF;
-  packetCfg.id = UBX_ESF_RESETALG;
-  packetCfg.len = 0;
-  packetCfg.startingSpot = 0;
-
-  // This is a special case as we are only expecting an ACK but this is not a CFG message
-  return (sendCommand(&packetCfg, maxWait, true) == SFE_UBLOX_STATUS_DATA_SENT); // We are only expecting an ACK
-}
-
-//Get the time pulse parameters using UBX_CFG_TP5
-boolean SFE_UBLOX_GNSS::getTimePulseParameters(UBX_CFG_TP5_data_t *data, uint16_t maxWait)
-{
-  if (data == NULL) // Check if the user forgot to include the data pointer
-    return (false); // Bail
-
-  packetCfg.cls = UBX_CLASS_CFG;
-  packetCfg.id = UBX_CFG_TP5;
-  packetCfg.len = 0;
-  packetCfg.startingSpot = 0;
-
-  if (sendCommand(&packetCfg, maxWait) != SFE_UBLOX_STATUS_DATA_RECEIVED) // We are expecting data and an ACK
-    return (false);
-
-  // Extract the data
-  data->tpIdx = extractByte(&packetCfg, 0);
-  data->version = extractByte(&packetCfg, 1);
-  data->antCableDelay = extractSignedInt(&packetCfg, 4);
-  data->rfGroupDelay = extractSignedInt(&packetCfg, 6);
-  data->freqPeriod = extractLong(&packetCfg, 8);
-  data->freqPeriodLock = extractLong(&packetCfg, 12);
-  data->pulseLenRatio = extractLong(&packetCfg, 16);
-  data->pulseLenRatioLock = extractLong(&packetCfg, 20);
-  data->userConfigDelay = extractSignedLong(&packetCfg, 24);
-  data->flags.all = extractLong(&packetCfg, 28);
-
-  return(true);
-}
-
-//Set the time pulse parameters using UBX_CFG_TP5
-boolean SFE_UBLOX_GNSS::setTimePulseParameters(UBX_CFG_TP5_data_t *data, uint16_t maxWait)
-{
-  if (data == NULL) // Check if the user forgot to include the data pointer
-    return (false); // Bail
-
-  packetCfg.cls = UBX_CLASS_CFG;
-  packetCfg.id = UBX_CFG_TP5;
-  packetCfg.len = UBX_CFG_TP5_LEN;
-  packetCfg.startingSpot = 0;
-
-  // Insert the data
-  payloadCfg[0] = data->tpIdx;
-  payloadCfg[1] = data->version;
-  payloadCfg[4] = data->antCableDelay & 0xFF; // Little Endian
-  payloadCfg[5] = data->antCableDelay >> 8;
-  payloadCfg[6] = data->rfGroupDelay & 0xFF; // Little Endian
-  payloadCfg[7] = data->rfGroupDelay >> 8;
-  payloadCfg[8] = data->freqPeriod & 0xFF; // Little Endian
-  payloadCfg[9] = (data->freqPeriod >> 8) & 0xFF;
-  payloadCfg[10] = (data->freqPeriod >> 16) & 0xFF;
-  payloadCfg[11] = (data->freqPeriod >> 24) & 0xFF;
-  payloadCfg[12] = data->freqPeriodLock & 0xFF; // Little Endian
-  payloadCfg[13] = (data->freqPeriodLock >> 8) & 0xFF;
-  payloadCfg[14] = (data->freqPeriodLock >> 16) & 0xFF;
-  payloadCfg[15] = (data->freqPeriodLock >> 24) & 0xFF;
-  payloadCfg[16] = data->pulseLenRatio & 0xFF; // Little Endian
-  payloadCfg[17] = (data->pulseLenRatio >> 8) & 0xFF;
-  payloadCfg[18] = (data->pulseLenRatio >> 16) & 0xFF;
-  payloadCfg[19] = (data->pulseLenRatio >> 24) & 0xFF;
-  payloadCfg[20] = data->pulseLenRatioLock & 0xFF; // Little Endian
-  payloadCfg[21] = (data->pulseLenRatioLock >> 8) & 0xFF;
-  payloadCfg[22] = (data->pulseLenRatioLock >> 16) & 0xFF;
-  payloadCfg[23] = (data->pulseLenRatioLock >> 24) & 0xFF;
-  payloadCfg[24] = data->userConfigDelay & 0xFF; // Little Endian
-  payloadCfg[25] = (data->userConfigDelay >> 8) & 0xFF;
-  payloadCfg[26] = (data->userConfigDelay >> 16) & 0xFF;
-  payloadCfg[27] = (data->userConfigDelay >> 24) & 0xFF;
-  payloadCfg[28] = data->flags.all & 0xFF; // Little Endian
-  payloadCfg[29] = (data->flags.all >> 8) & 0xFF;
-  payloadCfg[30] = (data->flags.all >> 16) & 0xFF;
-  payloadCfg[31] = (data->flags.all >> 24) & 0xFF;
-
-  return (sendCommand(&packetCfg, maxWait) == SFE_UBLOX_STATUS_DATA_SENT); // We are only expecting an ACK
-}
-
-// CONFIGURATION INTERFACE (protocol v27 and above)
-
-//Form 32-bit key from group/id/size
-uint32_t SFE_UBLOX_GNSS::createKey(uint16_t group, uint16_t id, uint8_t size)
-{
-  uint32_t key = 0;
-  key |= (uint32_t)id;
-  key |= (uint32_t)group << 16;
-  key |= (uint32_t)size << 28;
-  return (key);
-}
-
-//Given a key, load the payload with data that can then be extracted to 8, 16, or 32 bits
-//This function takes a full 32-bit key
-//Default layer is RAM
-//Configuration of modern u-blox modules is now done via getVal/setVal/delVal, ie protocol v27 and above found on ZED-F9P
-sfe_ublox_status_e SFE_UBLOX_GNSS::getVal(uint32_t key, uint8_t layer, uint16_t maxWait)
-{
-  packetCfg.cls = UBX_CLASS_CFG;
-  packetCfg.id = UBX_CFG_VALGET;
-  packetCfg.len = 4 + 4 * 1; //While multiple keys are allowed, we will send only one key at a time
-  packetCfg.startingSpot = 0;
-
-  //Clear packet payload
-  memset(payloadCfg, 0, packetCfg.len);
-
-  //VALGET uses different memory layer definitions to VALSET
-  //because it can only return the value for one layer.
-  //So we need to fiddle the layer here.
-  //And just to complicate things further, the ZED-F9P only responds
-  //correctly to layer 0 (RAM) and layer 7 (Default)!
-  uint8_t getLayer = 7;                         // 7 is the "Default Layer"
-  if ((layer & VAL_LAYER_RAM) == VAL_LAYER_RAM) // Did the user request the RAM layer?
-  {
-    getLayer = 0; // Layer 0 is RAM
-  }
-
-  payloadCfg[0] = 0;        //Message Version - set to 0
-  payloadCfg[1] = getLayer; //Layer
-
-  //Load key into outgoing payload
-  payloadCfg[4] = key >> 8 * 0; //Key LSB
-  payloadCfg[5] = key >> 8 * 1;
-  payloadCfg[6] = key >> 8 * 2;
-  payloadCfg[7] = key >> 8 * 3;
-
-  if (_printDebug == true)
-  {
-    _debugSerial->print(F("key: 0x"));
-    _debugSerial->print(key, HEX);
-    _debugSerial->println();
-  }
-
-  //Send VALGET command with this key
-
-  sfe_ublox_status_e retVal = sendCommand(&packetCfg, maxWait);
-  if (_printDebug == true)
-  {
-    _debugSerial->print(F("getVal: sendCommand returned: "));
-    _debugSerial->println(statusString(retVal));
-  }
-
-  //Verify the response is the correct length as compared to what the user called (did the module respond with 8-bits but the user called getVal32?)
-  //Response is 8 bytes plus cfg data
-  //if(packet->len > 8+1)
-
-  //The response is now sitting in payload, ready for extraction
-  return (retVal);
-}
-
-//Given a key, return its value
-//This function takes a full 32-bit key
-//Default layer is RAM
-//Configuration of modern u-blox modules is now done via getVal/setVal/delVal, ie protocol v27 and above found on ZED-F9P
-uint8_t SFE_UBLOX_GNSS::getVal8(uint32_t key, uint8_t layer, uint16_t maxWait)
-{
-  if (getVal(key, layer, maxWait) != SFE_UBLOX_STATUS_DATA_RECEIVED)
-    return (0);
-
-  return (extractByte(&packetCfg, 8));
-}
-uint16_t SFE_UBLOX_GNSS::getVal16(uint32_t key, uint8_t layer, uint16_t maxWait)
-{
-  if (getVal(key, layer, maxWait) != SFE_UBLOX_STATUS_DATA_RECEIVED)
-    return (0);
-
-  return (extractInt(&packetCfg, 8));
-}
-uint32_t SFE_UBLOX_GNSS::getVal32(uint32_t key, uint8_t layer, uint16_t maxWait)
-{
-  if (getVal(key, layer, maxWait) != SFE_UBLOX_STATUS_DATA_RECEIVED)
-    return (0);
-
-  return (extractLong(&packetCfg, 8));
-}
-
-//Given a group, ID and size, return the value of this config spot
-//The 32-bit key is put together from group/ID/size. See other getVal to send key directly.
-//Configuration of modern u-blox modules is now done via getVal/setVal/delVal, ie protocol v27 and above found on ZED-F9P
-uint8_t SFE_UBLOX_GNSS::getVal8(uint16_t group, uint16_t id, uint8_t size, uint8_t layer, uint16_t maxWait)
-{
-  uint32_t key = createKey(group, id, size);
-  return getVal8(key, layer, maxWait);
-}
-uint16_t SFE_UBLOX_GNSS::getVal16(uint16_t group, uint16_t id, uint8_t size, uint8_t layer, uint16_t maxWait)
-{
-  uint32_t key = createKey(group, id, size);
-  return getVal16(key, layer, maxWait);
-}
-uint32_t SFE_UBLOX_GNSS::getVal32(uint16_t group, uint16_t id, uint8_t size, uint8_t layer, uint16_t maxWait)
-{
-  uint32_t key = createKey(group, id, size);
-  return getVal32(key, layer, maxWait);
-}
-
-//Given a key, set a 16-bit value
-//This function takes a full 32-bit key
-//Default layer is all: RAM+BBR+Flash
-//Configuration of modern u-blox modules is now done via getVal/setVal/delVal, ie protocol v27 and above found on ZED-F9P
-uint8_t SFE_UBLOX_GNSS::setVal(uint32_t key, uint16_t value, uint8_t layer, uint16_t maxWait)
-{
-  return setVal16(key, value, layer, maxWait);
-}
-
-//Given a key, set a 16-bit value
-//This function takes a full 32-bit key
-//Default layer is all: RAM+BBR+Flash
-//Configuration of modern u-blox modules is now done via getVal/setVal/delVal, ie protocol v27 and above found on ZED-F9P
-uint8_t SFE_UBLOX_GNSS::setVal16(uint32_t key, uint16_t value, uint8_t layer, uint16_t maxWait)
-{
-  packetCfg.cls = UBX_CLASS_CFG;
-  packetCfg.id = UBX_CFG_VALSET;
-  packetCfg.len = 4 + 4 + 2; //4 byte header, 4 byte key ID, 2 bytes of value
-  packetCfg.startingSpot = 0;
-
-  //Clear packet payload
-  memset(payloadCfg, 0, packetCfg.len);
-
-  payloadCfg[0] = 0;     //Message Version - set to 0
-  payloadCfg[1] = layer; //By default we ask for the BBR layer
-
-  //Load key into outgoing payload
-  payloadCfg[4] = key >> 8 * 0; //Key LSB
-  payloadCfg[5] = key >> 8 * 1;
-  payloadCfg[6] = key >> 8 * 2;
-  payloadCfg[7] = key >> 8 * 3;
-
-  //Load user's value
-  payloadCfg[8] = value >> 8 * 0; //Value LSB
-  payloadCfg[9] = value >> 8 * 1;
-
-  //Send VALSET command with this key and value
-  return (sendCommand(&packetCfg, maxWait) == SFE_UBLOX_STATUS_DATA_SENT); // We are only expecting an ACK
-}
-
-//Given a key, set an 8-bit value
-//This function takes a full 32-bit key
-//Default layer is all: RAM+BBR+Flash
-//Configuration of modern u-blox modules is now done via getVal/setVal/delVal, ie protocol v27 and above found on ZED-F9P
-uint8_t SFE_UBLOX_GNSS::setVal8(uint32_t key, uint8_t value, uint8_t layer, uint16_t maxWait)
-{
-  packetCfg.cls = UBX_CLASS_CFG;
-  packetCfg.id = UBX_CFG_VALSET;
-  packetCfg.len = 4 + 4 + 1; //4 byte header, 4 byte key ID, 1 byte value
-  packetCfg.startingSpot = 0;
-
-  //Clear packet payload
-  memset(payloadCfg, 0, packetCfg.len);
-
-  payloadCfg[0] = 0;     //Message Version - set to 0
-  payloadCfg[1] = layer; //By default we ask for the BBR layer
-
-  //Load key into outgoing payload
-  payloadCfg[4] = key >> 8 * 0; //Key LSB
-  payloadCfg[5] = key >> 8 * 1;
-  payloadCfg[6] = key >> 8 * 2;
-  payloadCfg[7] = key >> 8 * 3;
-
-  //Load user's value
-  payloadCfg[8] = value; //Value
-
-  //Send VALSET command with this key and value
-  return (sendCommand(&packetCfg, maxWait) == SFE_UBLOX_STATUS_DATA_SENT); // We are only expecting an ACK
-}
-
-//Given a key, set a 32-bit value
-//This function takes a full 32-bit key
-//Default layer is all: RAM+BBR+Flash
-//Configuration of modern u-blox modules is now done via getVal/setVal/delVal, ie protocol v27 and above found on ZED-F9P
-uint8_t SFE_UBLOX_GNSS::setVal32(uint32_t key, uint32_t value, uint8_t layer, uint16_t maxWait)
-{
-  packetCfg.cls = UBX_CLASS_CFG;
-  packetCfg.id = UBX_CFG_VALSET;
-  packetCfg.len = 4 + 4 + 4; //4 byte header, 4 byte key ID, 4 bytes of value
-  packetCfg.startingSpot = 0;
-
-  //Clear packet payload
-  memset(payloadCfg, 0, packetCfg.len);
-
-  payloadCfg[0] = 0;     //Message Version - set to 0
-  payloadCfg[1] = layer; //By default we ask for the BBR layer
-
-  //Load key into outgoing payload
-  payloadCfg[4] = key >> 8 * 0; //Key LSB
-  payloadCfg[5] = key >> 8 * 1;
-  payloadCfg[6] = key >> 8 * 2;
-  payloadCfg[7] = key >> 8 * 3;
-
-  //Load user's value
-  payloadCfg[8] = value >> 8 * 0; //Value LSB
-  payloadCfg[9] = value >> 8 * 1;
-  payloadCfg[10] = value >> 8 * 2;
-  payloadCfg[11] = value >> 8 * 3;
-
-  //Send VALSET command with this key and value
-  return (sendCommand(&packetCfg, maxWait) == SFE_UBLOX_STATUS_DATA_SENT); // We are only expecting an ACK
-}
-
-//Start defining a new UBX-CFG-VALSET ubxPacket
-//This function takes a full 32-bit key and 32-bit value
-//Default layer is BBR
-//Configuration of modern u-blox modules is now done via getVal/setVal/delVal, ie protocol v27 and above found on ZED-F9P
-uint8_t SFE_UBLOX_GNSS::newCfgValset32(uint32_t key, uint32_t value, uint8_t layer)
-{
-  packetCfg.cls = UBX_CLASS_CFG;
-  packetCfg.id = UBX_CFG_VALSET;
-  packetCfg.len = 4 + 4 + 4; //4 byte header, 4 byte key ID, 4 bytes of value
-  packetCfg.startingSpot = 0;
-
-  //Clear all of packet payload
-  memset(payloadCfg, 0, packetCfgPayloadSize);
-
-  payloadCfg[0] = 0;     //Message Version - set to 0
-  payloadCfg[1] = layer; //By default we ask for the BBR layer
-
-  //Load key into outgoing payload
-  payloadCfg[4] = key >> 8 * 0; //Key LSB
-  payloadCfg[5] = key >> 8 * 1;
-  payloadCfg[6] = key >> 8 * 2;
-  payloadCfg[7] = key >> 8 * 3;
-
-  //Load user's value
-  payloadCfg[8] = value >> 8 * 0; //Value LSB
-  payloadCfg[9] = value >> 8 * 1;
-  payloadCfg[10] = value >> 8 * 2;
-  payloadCfg[11] = value >> 8 * 3;
-
-  //All done
-  return (true);
-}
-
-//Start defining a new UBX-CFG-VALSET ubxPacket
-//This function takes a full 32-bit key and 16-bit value
-//Default layer is BBR
-//Configuration of modern u-blox modules is now done via getVal/setVal/delVal, ie protocol v27 and above found on ZED-F9P
-uint8_t SFE_UBLOX_GNSS::newCfgValset16(uint32_t key, uint16_t value, uint8_t layer)
-{
-  packetCfg.cls = UBX_CLASS_CFG;
-  packetCfg.id = UBX_CFG_VALSET;
-  packetCfg.len = 4 + 4 + 2; //4 byte header, 4 byte key ID, 2 bytes of value
-  packetCfg.startingSpot = 0;
-
-  //Clear all of packet payload
-  memset(payloadCfg, 0, packetCfgPayloadSize);
-
-  payloadCfg[0] = 0;     //Message Version - set to 0
-  payloadCfg[1] = layer; //By default we ask for the BBR layer
-
-  //Load key into outgoing payload
-  payloadCfg[4] = key >> 8 * 0; //Key LSB
-  payloadCfg[5] = key >> 8 * 1;
-  payloadCfg[6] = key >> 8 * 2;
-  payloadCfg[7] = key >> 8 * 3;
-
-  //Load user's value
-  payloadCfg[8] = value >> 8 * 0; //Value LSB
-  payloadCfg[9] = value >> 8 * 1;
-
-  //All done
-  return (true);
-}
-
-//Start defining a new UBX-CFG-VALSET ubxPacket
-//This function takes a full 32-bit key and 8-bit value
-//Default layer is BBR
-//Configuration of modern u-blox modules is now done via getVal/setVal/delVal, ie protocol v27 and above found on ZED-F9P
-uint8_t SFE_UBLOX_GNSS::newCfgValset8(uint32_t key, uint8_t value, uint8_t layer)
-{
-  packetCfg.cls = UBX_CLASS_CFG;
-  packetCfg.id = UBX_CFG_VALSET;
-  packetCfg.len = 4 + 4 + 1; //4 byte header, 4 byte key ID, 1 byte value
-  packetCfg.startingSpot = 0;
-
-  //Clear all of packet payload
-  memset(payloadCfg, 0, packetCfgPayloadSize);
-
-  payloadCfg[0] = 0;     //Message Version - set to 0
-  payloadCfg[1] = layer; //By default we ask for the BBR layer
-
-  //Load key into outgoing payload
-  payloadCfg[4] = key >> 8 * 0; //Key LSB
-  payloadCfg[5] = key >> 8 * 1;
-  payloadCfg[6] = key >> 8 * 2;
-  payloadCfg[7] = key >> 8 * 3;
-
-  //Load user's value
-  payloadCfg[8] = value; //Value
-
-  //All done
-  return (true);
-}
-
-//Add another keyID and value to an existing UBX-CFG-VALSET ubxPacket
-//This function takes a full 32-bit key and 32-bit value
-uint8_t SFE_UBLOX_GNSS::addCfgValset32(uint32_t key, uint32_t value)
-{
-  //Load key into outgoing payload
-  payloadCfg[packetCfg.len + 0] = key >> 8 * 0; //Key LSB
-  payloadCfg[packetCfg.len + 1] = key >> 8 * 1;
-  payloadCfg[packetCfg.len + 2] = key >> 8 * 2;
-  payloadCfg[packetCfg.len + 3] = key >> 8 * 3;
-
-  //Load user's value
-  payloadCfg[packetCfg.len + 4] = value >> 8 * 0; //Value LSB
-  payloadCfg[packetCfg.len + 5] = value >> 8 * 1;
-  payloadCfg[packetCfg.len + 6] = value >> 8 * 2;
-  payloadCfg[packetCfg.len + 7] = value >> 8 * 3;
-
-  //Update packet length: 4 byte key ID, 4 bytes of value
-  packetCfg.len = packetCfg.len + 4 + 4;
-
-  //All done
-  return (true);
-}
-
-//Add another keyID and value to an existing UBX-CFG-VALSET ubxPacket
-//This function takes a full 32-bit key and 16-bit value
-uint8_t SFE_UBLOX_GNSS::addCfgValset16(uint32_t key, uint16_t value)
-{
-  //Load key into outgoing payload
-  payloadCfg[packetCfg.len + 0] = key >> 8 * 0; //Key LSB
-  payloadCfg[packetCfg.len + 1] = key >> 8 * 1;
-  payloadCfg[packetCfg.len + 2] = key >> 8 * 2;
-  payloadCfg[packetCfg.len + 3] = key >> 8 * 3;
-
-  //Load user's value
-  payloadCfg[packetCfg.len + 4] = value >> 8 * 0; //Value LSB
-  payloadCfg[packetCfg.len + 5] = value >> 8 * 1;
-
-  //Update packet length: 4 byte key ID, 2 bytes of value
-  packetCfg.len = packetCfg.len + 4 + 2;
-
-  //All done
-  return (true);
-}
-
-//Add another keyID and value to an existing UBX-CFG-VALSET ubxPacket
-//This function takes a full 32-bit key and 8-bit value
-uint8_t SFE_UBLOX_GNSS::addCfgValset8(uint32_t key, uint8_t value)
-{
-  //Load key into outgoing payload
-  payloadCfg[packetCfg.len + 0] = key >> 8 * 0; //Key LSB
-  payloadCfg[packetCfg.len + 1] = key >> 8 * 1;
-  payloadCfg[packetCfg.len + 2] = key >> 8 * 2;
-  payloadCfg[packetCfg.len + 3] = key >> 8 * 3;
-
-  //Load user's value
-  payloadCfg[packetCfg.len + 4] = value; //Value
-
-  //Update packet length: 4 byte key ID, 1 byte value
-  packetCfg.len = packetCfg.len + 4 + 1;
-
-  //All done
-  return (true);
-}
-
-//Add a final keyID and value to an existing UBX-CFG-VALSET ubxPacket and send it
-//This function takes a full 32-bit key and 32-bit value
-uint8_t SFE_UBLOX_GNSS::sendCfgValset32(uint32_t key, uint32_t value, uint16_t maxWait)
-{
-  //Load keyID and value into outgoing payload
-  addCfgValset32(key, value);
-
-  //Send VALSET command with this key and value
-  return (sendCommand(&packetCfg, maxWait) == SFE_UBLOX_STATUS_DATA_SENT); // We are only expecting an ACK
-}
-
-//Add a final keyID and value to an existing UBX-CFG-VALSET ubxPacket and send it
-//This function takes a full 32-bit key and 16-bit value
-uint8_t SFE_UBLOX_GNSS::sendCfgValset16(uint32_t key, uint16_t value, uint16_t maxWait)
-{
-  //Load keyID and value into outgoing payload
-  addCfgValset16(key, value);
-
-  //Send VALSET command with this key and value
-  return (sendCommand(&packetCfg, maxWait) == SFE_UBLOX_STATUS_DATA_SENT); // We are only expecting an ACK
-}
-
-//Add a final keyID and value to an existing UBX-CFG-VALSET ubxPacket and send it
-//This function takes a full 32-bit key and 8-bit value
-uint8_t SFE_UBLOX_GNSS::sendCfgValset8(uint32_t key, uint8_t value, uint16_t maxWait)
-{
-  //Load keyID and value into outgoing payload
-  addCfgValset8(key, value);
-
-  //Send VALSET command with this key and value
-  return (sendCommand(&packetCfg, maxWait) == SFE_UBLOX_STATUS_DATA_SENT); // We are only expecting an ACK
-}
-
-//=-=-=-=-=-=-=-= "Automatic" Messages =-=-=-=-=-=-=-==-=-=-=-=-=-=-=
-//=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-==-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
-
-
-// ***** NAV POSECEF automatic support
-
-boolean SFE_UBLOX_GNSS::getNAVPOSECEF(uint16_t maxWait)
-{
-  if (packetUBXNAVPOSECEF == NULL) initPacketUBXNAVPOSECEF(); //Check that RAM has been allocated for the POSECEF data
-  if (packetUBXNAVPOSECEF == NULL) //Bail if the RAM allocation failed
-    return (false);
-
-  if (packetUBXNAVPOSECEF->automaticFlags.flags.bits.automatic && packetUBXNAVPOSECEF->automaticFlags.flags.bits.implicitUpdate)
-  {
-    //The GPS is automatically reporting, we just check whether we got unread data
-    checkUbloxInternal(&packetCfg, UBX_CLASS_NAV, UBX_NAV_POSECEF);
-    return packetUBXNAVPOSECEF->moduleQueried.moduleQueried.bits.all;
-  }
-  else if (packetUBXNAVPOSECEF->automaticFlags.flags.bits.automatic && !packetUBXNAVPOSECEF->automaticFlags.flags.bits.implicitUpdate)
-  {
-    //Someone else has to call checkUblox for us...
-    return (false);
-  }
-  else
-  {
-    //The GPS is not automatically reporting navigation position so we have to poll explicitly
-    packetCfg.cls = UBX_CLASS_NAV;
-    packetCfg.id = UBX_NAV_POSECEF;
-    packetCfg.len = 0;
-    packetCfg.startingSpot = 0;
-
-    //The data is parsed as part of processing the response
-    sfe_ublox_status_e retVal = sendCommand(&packetCfg, maxWait);
-
-    if (retVal == SFE_UBLOX_STATUS_DATA_RECEIVED)
-      return (true);
-
-    if (retVal == SFE_UBLOX_STATUS_DATA_OVERWRITTEN)
-    {
-      return (true);
-    }
-
-    return (false);
-  }
-}
-
-//Enable or disable automatic navigation message generation by the GNSS. This changes the way getPOSECEF
-//works.
-boolean SFE_UBLOX_GNSS::setAutoNAVPOSECEF(boolean enable, uint16_t maxWait)
-{
-  return setAutoNAVPOSECEFrate(enable ? 1 : 0, true, maxWait);
-}
-
-//Enable or disable automatic navigation message generation by the GNSS. This changes the way getPOSECEF
-//works.
-boolean SFE_UBLOX_GNSS::setAutoNAVPOSECEF(boolean enable, boolean implicitUpdate, uint16_t maxWait)
-{
-  return setAutoNAVPOSECEFrate(enable ? 1 : 0, implicitUpdate, maxWait);
-}
-
-//Enable or disable automatic navigation message generation by the GNSS. This changes the way getPOSECEF
-//works.
-boolean SFE_UBLOX_GNSS::setAutoNAVPOSECEFrate(uint8_t rate, boolean implicitUpdate, uint16_t maxWait)
-{
-  if (packetUBXNAVPOSECEF == NULL) initPacketUBXNAVPOSECEF(); //Check that RAM has been allocated for the data
-  if (packetUBXNAVPOSECEF == NULL) //Only attempt this if RAM allocation was successful
-    return false;
-
-  if (rate > 127) rate = 127;
-
-  packetCfg.cls = UBX_CLASS_CFG;
-  packetCfg.id = UBX_CFG_MSG;
-  packetCfg.len = 3;
-  packetCfg.startingSpot = 0;
-  payloadCfg[0] = UBX_CLASS_NAV;
-  payloadCfg[1] = UBX_NAV_POSECEF;
-  payloadCfg[2] = rate; // rate relative to navigation freq.
-
-  boolean ok = ((sendCommand(&packetCfg, maxWait)) == SFE_UBLOX_STATUS_DATA_SENT); // We are only expecting an ACK
-  if (ok)
-  {
-    packetUBXNAVPOSECEF->automaticFlags.flags.bits.automatic = (rate > 0);
-    packetUBXNAVPOSECEF->automaticFlags.flags.bits.implicitUpdate = implicitUpdate;
-  }
-  packetUBXNAVPOSECEF->moduleQueried.moduleQueried.bits.all = false;
-  return ok;
-}
-
-//Enable automatic navigation message generation by the GNSS.
-boolean SFE_UBLOX_GNSS::setAutoNAVPOSECEFcallback(void (*callbackPointer)(UBX_NAV_POSECEF_data_t), uint16_t maxWait)
-{
-  // Enable auto messages. Set implicitUpdate to false as we expect the user to call checkUblox manually.
-  boolean result = setAutoNAVPOSECEF(true, false, maxWait);
-  if (!result)
-    return (result); // Bail if setAuto failed
-
-  if (packetUBXNAVPOSECEF->callbackData == NULL) //Check if RAM has been allocated for the callback copy
-  {
-    packetUBXNAVPOSECEF->callbackData = new UBX_NAV_POSECEF_data_t; //Allocate RAM for the main struct
-  }
-
-  if (packetUBXNAVPOSECEF->callbackData == NULL)
-  {
-    if ((_printDebug == true) || (_printLimitedDebug == true)) // This is important. Print this if doing limited debugging
-      _debugSerial->println(F("setAutoNAVPOSECEFcallback: PANIC! RAM allocation failed!"));
-    return (false);
-  }
-
-  packetUBXNAVPOSECEF->callbackPointer = callbackPointer;
-  return (true);
-}
-
-//In case no config access to the GNSS is possible and POSECEF is send cyclically already
-//set config to suitable parameters
-boolean SFE_UBLOX_GNSS::assumeAutoNAVPOSECEF(boolean enabled, boolean implicitUpdate)
-{
-  if (packetUBXNAVPOSECEF == NULL) initPacketUBXNAVPOSECEF(); //Check that RAM has been allocated for the data
-  if (packetUBXNAVPOSECEF == NULL) //Only attempt this if RAM allocation was successful
-    return false;
-
-  boolean changes = packetUBXNAVPOSECEF->automaticFlags.flags.bits.automatic != enabled || packetUBXNAVPOSECEF->automaticFlags.flags.bits.implicitUpdate != implicitUpdate;
-  if (changes)
-  {
-    packetUBXNAVPOSECEF->automaticFlags.flags.bits.automatic = enabled;
-    packetUBXNAVPOSECEF->automaticFlags.flags.bits.implicitUpdate = implicitUpdate;
-  }
-  return changes;
-}
-
-// PRIVATE: Allocate RAM for packetUBXNAVPOSECEF and initialize it
-boolean SFE_UBLOX_GNSS::initPacketUBXNAVPOSECEF()
-{
-  packetUBXNAVPOSECEF = new UBX_NAV_POSECEF_t; //Allocate RAM for the main struct
-  if (packetUBXNAVPOSECEF == NULL)
-  {
-    if ((_printDebug == true) || (_printLimitedDebug == true)) // This is important. Print this if doing limited debugging
-      _debugSerial->println(F("initPacketUBXNAVPOSECEF: PANIC! RAM allocation failed!"));
-    return (false);
-  }
-  packetUBXNAVPOSECEF->automaticFlags.flags.all = 0;
-  packetUBXNAVPOSECEF->callbackPointer = NULL;
-  packetUBXNAVPOSECEF->callbackData = NULL;
-  packetUBXNAVPOSECEF->moduleQueried.moduleQueried.all = 0;
-  return (true);
-}
-
-//Mark all the data as read/stale. This is handy to get data alignment after CRC failure
-//or if there are no helper functions and the user wants to request fresh data
-void SFE_UBLOX_GNSS::flushNAVPOSECEF()
-{
-  if (packetUBXNAVPOSECEF == NULL) return; // Bail if RAM has not been allocated (otherwise we could be writing anywhere!)
-  packetUBXNAVPOSECEF->moduleQueried.moduleQueried.all = 0; //Mark all datums as stale (read before)
-}
-
-//Log this data in file buffer
-void SFE_UBLOX_GNSS::logNAVPOSECEF(boolean enabled)
-{
-  if (packetUBXNAVPOSECEF == NULL) return; // Bail if RAM has not been allocated (otherwise we could be writing anywhere!)
-  packetUBXNAVPOSECEF->automaticFlags.flags.bits.addToFileBuffer = (uint8_t)enabled;
-}
-
-// ***** NAV STATUS automatic support
-
-boolean SFE_UBLOX_GNSS::getNAVSTATUS(uint16_t maxWait)
-{
-  if (packetUBXNAVSTATUS == NULL) initPacketUBXNAVSTATUS(); //Check that RAM has been allocated for the STATUS data
-  if (packetUBXNAVSTATUS == NULL) //Bail if the RAM allocation failed
-    return (false);
-
-  if (packetUBXNAVSTATUS->automaticFlags.flags.bits.automatic && packetUBXNAVSTATUS->automaticFlags.flags.bits.implicitUpdate)
-  {
-    //The GPS is automatically reporting, we just check whether we got unread data
-    checkUbloxInternal(&packetCfg, UBX_CLASS_NAV, UBX_NAV_STATUS);
-    return packetUBXNAVSTATUS->moduleQueried.moduleQueried.bits.all;
-  }
-  else if (packetUBXNAVSTATUS->automaticFlags.flags.bits.automatic && !packetUBXNAVSTATUS->automaticFlags.flags.bits.implicitUpdate)
-  {
-    //Someone else has to call checkUblox for us...
-    return (false);
-  }
-  else
-  {
-    //The GPS is not automatically reporting navigation position so we have to poll explicitly
-    packetCfg.cls = UBX_CLASS_NAV;
-    packetCfg.id = UBX_NAV_STATUS;
-    packetCfg.len = 0;
-    packetCfg.startingSpot = 0;
-
-    //The data is parsed as part of processing the response
-    sfe_ublox_status_e retVal = sendCommand(&packetCfg, maxWait);
-
-    if (retVal == SFE_UBLOX_STATUS_DATA_RECEIVED)
-      return (true);
-
-    if (retVal == SFE_UBLOX_STATUS_DATA_OVERWRITTEN)
-    {
-      return (true);
-    }
-
-    return (false);
-  }
-}
-
-//Enable or disable automatic navigation message generation by the GNSS. This changes the way getNAVSTATUS
-//works.
-boolean SFE_UBLOX_GNSS::setAutoNAVSTATUS(boolean enable, uint16_t maxWait)
-{
-  return setAutoNAVSTATUSrate(enable ? 1 : 0, true, maxWait);
-}
-
-//Enable or disable automatic navigation message generation by the GNSS. This changes the way getNAVSTATUS
-//works.
-boolean SFE_UBLOX_GNSS::setAutoNAVSTATUS(boolean enable, boolean implicitUpdate, uint16_t maxWait)
-{
-  return setAutoNAVSTATUSrate(enable ? 1 : 0, implicitUpdate, maxWait);
-}
-
-//Enable or disable automatic navigation message generation by the GNSS. This changes the way getNAVSTATUS
-//works.
-boolean SFE_UBLOX_GNSS::setAutoNAVSTATUSrate(uint8_t rate, boolean implicitUpdate, uint16_t maxWait)
-{
-  if (packetUBXNAVSTATUS == NULL) initPacketUBXNAVSTATUS(); //Check that RAM has been allocated for the data
-  if (packetUBXNAVSTATUS == NULL) //Only attempt this if RAM allocation was successful
-    return false;
-
-  if (rate > 127) rate = 127;
-
-  packetCfg.cls = UBX_CLASS_CFG;
-  packetCfg.id = UBX_CFG_MSG;
-  packetCfg.len = 3;
-  packetCfg.startingSpot = 0;
-  payloadCfg[0] = UBX_CLASS_NAV;
-  payloadCfg[1] = UBX_NAV_STATUS;
-  payloadCfg[2] = rate; // rate relative to navigation freq.
-
-  boolean ok = ((sendCommand(&packetCfg, maxWait)) == SFE_UBLOX_STATUS_DATA_SENT); // We are only expecting an ACK
-  if (ok)
-  {
-    packetUBXNAVSTATUS->automaticFlags.flags.bits.automatic = (rate > 0);
-    packetUBXNAVSTATUS->automaticFlags.flags.bits.implicitUpdate = implicitUpdate;
-  }
-  packetUBXNAVSTATUS->moduleQueried.moduleQueried.bits.all = false;
-  return ok;
-}
-
-//Enable automatic navigation message generation by the GNSS.
-boolean SFE_UBLOX_GNSS::setAutoNAVSTATUScallback(void (*callbackPointer)(UBX_NAV_STATUS_data_t), uint16_t maxWait)
-{
-  // Enable auto messages. Set implicitUpdate to false as we expect the user to call checkUblox manually.
-  boolean result = setAutoNAVSTATUS(true, false, maxWait);
-  if (!result)
-    return (result); // Bail if setAuto failed
-
-  if (packetUBXNAVSTATUS->callbackData == NULL) //Check if RAM has been allocated for the callback copy
-  {
-    packetUBXNAVSTATUS->callbackData = new UBX_NAV_STATUS_data_t; //Allocate RAM for the main struct
-  }
-
-  if (packetUBXNAVSTATUS->callbackData == NULL)
-  {
-    if ((_printDebug == true) || (_printLimitedDebug == true)) // This is important. Print this if doing limited debugging
-      _debugSerial->println(F("setAutoNAVSTATUScallback: PANIC! RAM allocation failed!"));
-    return (false);
-  }
-
-  packetUBXNAVSTATUS->callbackPointer = callbackPointer;
-  return (true);
-}
-
-//In case no config access to the GNSS is possible and STATUS is send cyclically already
-//set config to suitable parameters
-boolean SFE_UBLOX_GNSS::assumeAutoNAVSTATUS(boolean enabled, boolean implicitUpdate)
-{
-  if (packetUBXNAVSTATUS == NULL) initPacketUBXNAVSTATUS(); //Check that RAM has been allocated for the data
-  if (packetUBXNAVSTATUS == NULL) //Only attempt this if RAM allocation was successful
-    return false;
-
-  boolean changes = packetUBXNAVSTATUS->automaticFlags.flags.bits.automatic != enabled || packetUBXNAVSTATUS->automaticFlags.flags.bits.implicitUpdate != implicitUpdate;
-  if (changes)
-  {
-    packetUBXNAVSTATUS->automaticFlags.flags.bits.automatic = enabled;
-    packetUBXNAVSTATUS->automaticFlags.flags.bits.implicitUpdate = implicitUpdate;
-  }
-  return changes;
-}
-
-// PRIVATE: Allocate RAM for packetUBXNAVSTATUS and initialize it
-boolean SFE_UBLOX_GNSS::initPacketUBXNAVSTATUS()
-{
-  packetUBXNAVSTATUS = new UBX_NAV_STATUS_t; //Allocate RAM for the main struct
-  if (packetUBXNAVSTATUS == NULL)
-  {
-    if ((_printDebug == true) || (_printLimitedDebug == true)) // This is important. Print this if doing limited debugging
-      _debugSerial->println(F("initPacketUBXNAVSTATUS: PANIC! RAM allocation failed!"));
-    return (false);
-  }
-  packetUBXNAVSTATUS->automaticFlags.flags.all = 0;
-  packetUBXNAVSTATUS->callbackPointer = NULL;
-  packetUBXNAVSTATUS->callbackData = NULL;
-  packetUBXNAVSTATUS->moduleQueried.moduleQueried.all = 0;
-  return (true);
-}
-
-//Mark all the data as read/stale. This is handy to get data alignment after CRC failure
-//or if there are no helper functions and the user wants to request fresh data
-void SFE_UBLOX_GNSS::flushNAVSTATUS()
-{
-  if (packetUBXNAVSTATUS == NULL) return; // Bail if RAM has not been allocated (otherwise we could be writing anywhere!)
-  packetUBXNAVSTATUS->moduleQueried.moduleQueried.all = 0; //Mark all datums as stale (read before)
-}
-
-//Log this data in file buffer
-void SFE_UBLOX_GNSS::logNAVSTATUS(boolean enabled)
-{
-  if (packetUBXNAVSTATUS == NULL) return; // Bail if RAM has not been allocated (otherwise we could be writing anywhere!)
-  packetUBXNAVSTATUS->automaticFlags.flags.bits.addToFileBuffer = (uint8_t)enabled;
-}
-
-// ***** DOP automatic support
-
-boolean SFE_UBLOX_GNSS::getDOP(uint16_t maxWait)
-{
-  if (packetUBXNAVDOP == NULL) initPacketUBXNAVDOP(); //Check that RAM has been allocated for the DOP data
-  if (packetUBXNAVDOP == NULL) //Bail if the RAM allocation failed
-    return (false);
-
-  if (packetUBXNAVDOP->automaticFlags.flags.bits.automatic && packetUBXNAVDOP->automaticFlags.flags.bits.implicitUpdate)
-  {
-    //The GPS is automatically reporting, we just check whether we got unread data
-    // if (_printDebug == true)
-    // {
-    //   _debugSerial->println(F("getDOP: Autoreporting"));
-    // }
-    checkUbloxInternal(&packetCfg, UBX_CLASS_NAV, UBX_NAV_DOP);
-    return packetUBXNAVDOP->moduleQueried.moduleQueried.bits.all;
-  }
-  else if (packetUBXNAVDOP->automaticFlags.flags.bits.automatic && !packetUBXNAVDOP->automaticFlags.flags.bits.implicitUpdate)
-  {
-    //Someone else has to call checkUblox for us...
-    // if (_printDebug == true)
-    // {
-    //   _debugSerial->println(F("getDOP: Exit immediately"));
-    // }
-    return (false);
-  }
-  else
-  {
-    // if (_printDebug == true)
-    // {
-    //   _debugSerial->println(F("getDOP: Polling"));
-    // }
-
-    //The GPS is not automatically reporting navigation position so we have to poll explicitly
-    packetCfg.cls = UBX_CLASS_NAV;
-    packetCfg.id = UBX_NAV_DOP;
-    packetCfg.len = 0;
-    packetCfg.startingSpot = 0;
-
-    //The data is parsed as part of processing the response
-    sfe_ublox_status_e retVal = sendCommand(&packetCfg, maxWait);
-
-    if (retVal == SFE_UBLOX_STATUS_DATA_RECEIVED)
-      return (true);
-
-    if (retVal == SFE_UBLOX_STATUS_DATA_OVERWRITTEN)
-    {
-      // if (_printDebug == true)
-      // {
-      //   _debugSerial->println(F("getDOP: data in packetCfg was OVERWRITTEN by another message (but that's OK)"));
-      // }
-      return (true);
-    }
-
-    // if (_printDebug == true)
-    // {
-    //   _debugSerial->print(F("getDOP retVal: "));
-    //   _debugSerial->println(statusString(retVal));
-    // }
-    return (false);
-  }
-}
-
-//Enable or disable automatic navigation message generation by the GNSS. This changes the way getDOP
-//works.
-boolean SFE_UBLOX_GNSS::setAutoDOP(boolean enable, uint16_t maxWait)
-{
-  return setAutoDOPrate(enable ? 1 : 0, true, maxWait);
-}
-
-//Enable or disable automatic navigation message generation by the GNSS. This changes the way getDOP
-//works.
-boolean SFE_UBLOX_GNSS::setAutoDOP(boolean enable, boolean implicitUpdate, uint16_t maxWait)
-{
-  return setAutoDOPrate(enable ? 1 : 0, implicitUpdate, maxWait);
-}
-
-//Enable or disable automatic navigation message generation by the GNSS. This changes the way getDOP
-//works.
-boolean SFE_UBLOX_GNSS::setAutoDOPrate(uint8_t rate, boolean implicitUpdate, uint16_t maxWait)
-{
-  if (packetUBXNAVDOP == NULL) initPacketUBXNAVDOP(); //Check that RAM has been allocated for the data
-  if (packetUBXNAVDOP == NULL) //Only attempt this if RAM allocation was successful
-    return false;
-
-  packetCfg.cls = UBX_CLASS_CFG;
-  packetCfg.id = UBX_CFG_MSG;
-  packetCfg.len = 3;
-  packetCfg.startingSpot = 0;
-  payloadCfg[0] = UBX_CLASS_NAV;
-  payloadCfg[1] = UBX_NAV_DOP;
-  payloadCfg[2] = rate; // rate relative to navigation freq.
-
-  boolean ok = ((sendCommand(&packetCfg, maxWait)) == SFE_UBLOX_STATUS_DATA_SENT); // We are only expecting an ACK
-  if (ok)
-  {
-    packetUBXNAVDOP->automaticFlags.flags.bits.automatic = (rate > 0);
-    packetUBXNAVDOP->automaticFlags.flags.bits.implicitUpdate = implicitUpdate;
-  }
-  packetUBXNAVDOP->moduleQueried.moduleQueried.bits.all = false;
-  return ok;
-}
-
-//Enable automatic navigation message generation by the GNSS.
-boolean SFE_UBLOX_GNSS::setAutoDOPcallback(void (*callbackPointer)(UBX_NAV_DOP_data_t), uint16_t maxWait)
-{
-  // Enable auto messages. Set implicitUpdate to false as we expect the user to call checkUblox manually.
-  boolean result = setAutoDOP(true, false, maxWait);
-  if (!result)
-    return (result); // Bail if setAuto failed
-
-  if (packetUBXNAVDOP->callbackData == NULL) //Check if RAM has been allocated for the callback copy
-  {
-    packetUBXNAVDOP->callbackData = new UBX_NAV_DOP_data_t; //Allocate RAM for the main struct
-  }
-
-  if (packetUBXNAVDOP->callbackData == NULL)
-  {
-    if ((_printDebug == true) || (_printLimitedDebug == true)) // This is important. Print this if doing limited debugging
-      _debugSerial->println(F("setAutoDOPcallback: PANIC! RAM allocation failed!"));
-    return (false);
-  }
-
-  packetUBXNAVDOP->callbackPointer = callbackPointer;
-  return (true);
-}
-
-//In case no config access to the GNSS is possible and DOP is send cyclically already
-//set config to suitable parameters
-boolean SFE_UBLOX_GNSS::assumeAutoDOP(boolean enabled, boolean implicitUpdate)
-{
-  if (packetUBXNAVDOP == NULL) initPacketUBXNAVDOP(); //Check that RAM has been allocated for the data
-  if (packetUBXNAVDOP == NULL) //Only attempt this if RAM allocation was successful
-    return false;
-
-  boolean changes = packetUBXNAVDOP->automaticFlags.flags.bits.automatic != enabled || packetUBXNAVDOP->automaticFlags.flags.bits.implicitUpdate != implicitUpdate;
-  if (changes)
-  {
-    packetUBXNAVDOP->automaticFlags.flags.bits.automatic = enabled;
-    packetUBXNAVDOP->automaticFlags.flags.bits.implicitUpdate = implicitUpdate;
-  }
-  return changes;
-}
-
-// PRIVATE: Allocate RAM for packetUBXNAVDOP and initialize it
-boolean SFE_UBLOX_GNSS::initPacketUBXNAVDOP()
-{
-  packetUBXNAVDOP = new UBX_NAV_DOP_t; //Allocate RAM for the main struct
-  if (packetUBXNAVDOP == NULL)
-  {
-    if ((_printDebug == true) || (_printLimitedDebug == true)) // This is important. Print this if doing limited debugging
-      _debugSerial->println(F("initPacketUBXNAVDOP: PANIC! RAM allocation failed!"));
-    return (false);
-  }
-  packetUBXNAVDOP->automaticFlags.flags.all = 0;
-  packetUBXNAVDOP->callbackPointer = NULL;
-  packetUBXNAVDOP->callbackData = NULL;
-  packetUBXNAVDOP->moduleQueried.moduleQueried.all = 0;
-  return (true);
-}
-
-//Mark all the DOP data as read/stale. This is handy to get data alignment after CRC failure
-void SFE_UBLOX_GNSS::flushDOP()
-{
-  if (packetUBXNAVDOP == NULL) return; // Bail if RAM has not been allocated (otherwise we could be writing anywhere!)
-  packetUBXNAVDOP->moduleQueried.moduleQueried.all = 0; //Mark all DOPs as stale (read before)
-}
-
-//Log this data in file buffer
-void SFE_UBLOX_GNSS::logNAVDOP(boolean enabled)
-{
-  if (packetUBXNAVDOP == NULL) return; // Bail if RAM has not been allocated (otherwise we could be writing anywhere!)
-  packetUBXNAVDOP->automaticFlags.flags.bits.addToFileBuffer = (uint8_t)enabled;
-}
-
-// ***** VEH ATT automatic support
-
-boolean SFE_UBLOX_GNSS::getVehAtt(uint16_t maxWait)
-{
-  return (getNAVATT(maxWait));
-}
-
-boolean SFE_UBLOX_GNSS::getNAVATT(uint16_t maxWait)
-{
-  if (packetUBXNAVATT == NULL) initPacketUBXNAVATT(); //Check that RAM has been allocated for the ESF RAW data
-  if (packetUBXNAVATT == NULL) //Only attempt this if RAM allocation was successful
-    return false;
-
-  if (packetUBXNAVATT->automaticFlags.flags.bits.automatic && packetUBXNAVATT->automaticFlags.flags.bits.implicitUpdate)
-  {
-    //The GPS is automatically reporting, we just check whether we got unread data
-    checkUbloxInternal(&packetCfg, UBX_CLASS_NAV, UBX_NAV_ATT);
-    return packetUBXNAVATT->moduleQueried.moduleQueried.bits.all;
-  }
-  else if (packetUBXNAVATT->automaticFlags.flags.bits.automatic && !packetUBXNAVATT->automaticFlags.flags.bits.implicitUpdate)
-  {
-    //Someone else has to call checkUblox for us...
-    return (false);
-  }
-  else
-  {
-    //The GPS is not automatically reporting HNR PVT so we have to poll explicitly
-    packetCfg.cls = UBX_CLASS_NAV;
-    packetCfg.id = UBX_NAV_ATT;
-    packetCfg.len = 0;
-    packetCfg.startingSpot = 0;
-
-    //The data is parsed as part of processing the response
-    sfe_ublox_status_e retVal = sendCommand(&packetCfg, maxWait);
-
-    if (retVal == SFE_UBLOX_STATUS_DATA_RECEIVED)
-      return (true);
-
-    if (retVal == SFE_UBLOX_STATUS_DATA_OVERWRITTEN)
-    {
-      return (true);
-    }
-
-    return (false);
-  }
-
-  return (false); // Trap. We should never get here...
-}
-
-//Enable or disable automatic NAV ATT message generation by the GNSS. This changes the way getVehAtt
-//works.
-boolean SFE_UBLOX_GNSS::setAutoNAVATT(boolean enable, uint16_t maxWait)
-{
-  return setAutoNAVATTrate(enable ? 1 : 0, true, maxWait);
-}
-
-//Enable or disable automatic NAV ATT message generation by the GNSS. This changes the way getVehAtt
-//works.
-boolean SFE_UBLOX_GNSS::setAutoNAVATT(boolean enable, boolean implicitUpdate, uint16_t maxWait)
-{
-  return setAutoNAVATTrate(enable ? 1 : 0, implicitUpdate, maxWait);
-}
-
-//Enable or disable automatic NAV ATT attitude message generation by the GNSS. This changes the way getVehAtt
-//works.
-boolean SFE_UBLOX_GNSS::setAutoNAVATTrate(uint8_t rate, boolean implicitUpdate, uint16_t maxWait)
-{
-  if (packetUBXNAVATT == NULL) initPacketUBXNAVATT(); //Check that RAM has been allocated for the data
-  if (packetUBXNAVATT == NULL) //Only attempt this if RAM allocation was successful
-    return false;
-
-  if (rate > 127) rate = 127;
-
-  packetCfg.cls = UBX_CLASS_CFG;
-  packetCfg.id = UBX_CFG_MSG;
-  packetCfg.len = 3;
-  packetCfg.startingSpot = 0;
-  payloadCfg[0] = UBX_CLASS_NAV;
-  payloadCfg[1] = UBX_NAV_ATT;
-  payloadCfg[2] = rate; // rate relative to navigation freq.
-
-  boolean ok = ((sendCommand(&packetCfg, maxWait)) == SFE_UBLOX_STATUS_DATA_SENT); // We are only expecting an ACK
-  if (ok)
-  {
-    packetUBXNAVATT->automaticFlags.flags.bits.automatic = (rate > 0);
-    packetUBXNAVATT->automaticFlags.flags.bits.implicitUpdate = implicitUpdate;
-  }
-  packetUBXNAVATT->moduleQueried.moduleQueried.bits.all = false; // Mark data as stale
-  return ok;
-}
-
-//Enable automatic navigation message generation by the GNSS.
-boolean SFE_UBLOX_GNSS::setAutoNAVATTcallback(void (*callbackPointer)(UBX_NAV_ATT_data_t), uint16_t maxWait)
-{
-  // Enable auto messages. Set implicitUpdate to false as we expect the user to call checkUblox manually.
-  boolean result = setAutoNAVATT(true, false, maxWait);
-  if (!result)
-    return (result); // Bail if setAuto failed
-
-  if (packetUBXNAVATT->callbackData == NULL) //Check if RAM has been allocated for the callback copy
-  {
-    packetUBXNAVATT->callbackData = new UBX_NAV_ATT_data_t; //Allocate RAM for the main struct
-  }
-
-  if (packetUBXNAVATT->callbackData == NULL)
-  {
-    if ((_printDebug == true) || (_printLimitedDebug == true)) // This is important. Print this if doing limited debugging
-      _debugSerial->println(F("setAutoNAVATTcallback: PANIC! RAM allocation failed!"));
-    return (false);
-  }
-
-  packetUBXNAVATT->callbackPointer = callbackPointer;
-  return (true);
-}
-
-//In case no config access to the GNSS is possible and NAV ATT attitude is send cyclically already
-//set config to suitable parameters
-boolean SFE_UBLOX_GNSS::assumeAutoNAVATT(boolean enabled, boolean implicitUpdate)
-{
-  if (packetUBXNAVATT == NULL) initPacketUBXNAVATT(); //Check that RAM has been allocated for the ESF RAW data
-  if (packetUBXNAVATT == NULL) //Only attempt this if RAM allocation was successful
-    return false;
-
-  boolean changes = packetUBXNAVATT->automaticFlags.flags.bits.automatic != enabled || packetUBXNAVATT->automaticFlags.flags.bits.implicitUpdate != implicitUpdate;
-  if (changes)
-  {
-    packetUBXNAVATT->automaticFlags.flags.bits.automatic = enabled;
-    packetUBXNAVATT->automaticFlags.flags.bits.implicitUpdate = implicitUpdate;
-  }
-  return changes;
-}
-
-// PRIVATE: Allocate RAM for packetUBXNAVATT and initialize it
-boolean SFE_UBLOX_GNSS::initPacketUBXNAVATT()
-{
-  packetUBXNAVATT = new UBX_NAV_ATT_t; //Allocate RAM for the main struct
-  if (packetUBXNAVATT == NULL)
-  {
-    if ((_printDebug == true) || (_printLimitedDebug == true)) // This is important. Print this if doing limited debugging
-      _debugSerial->println(F("initPacketUBXNAVATT: PANIC! RAM allocation failed!"));
-    return (false);
-  }
-  packetUBXNAVATT->automaticFlags.flags.all = 0;
-  packetUBXNAVATT->callbackPointer = NULL;
-  packetUBXNAVATT->callbackData = NULL;
-  packetUBXNAVATT->moduleQueried.moduleQueried.all = 0;
-  return (true);
-}
-
-//Mark all the DOP data as read/stale. This is handy to get data alignment after CRC failure
-void SFE_UBLOX_GNSS::flushNAVATT()
-{
-  if (packetUBXNAVATT == NULL) return; // Bail if RAM has not been allocated (otherwise we could be writing anywhere!)
-  packetUBXNAVATT->moduleQueried.moduleQueried.all = 0; //Mark all DOPs as stale (read before)
-}
-
-//Log this data in file buffer
-void SFE_UBLOX_GNSS::logNAVATT(boolean enabled)
-{
-  if (packetUBXNAVATT == NULL) return; // Bail if RAM has not been allocated (otherwise we could be writing anywhere!)
-  packetUBXNAVATT->automaticFlags.flags.bits.addToFileBuffer = (uint8_t)enabled;
-}
-
-// ***** PVT automatic support
-
-//Get the latest Position/Velocity/Time solution and fill all global variables
-boolean SFE_UBLOX_GNSS::getPVT(uint16_t maxWait)
-{
-  if (packetUBXNAVPVT == NULL) initPacketUBXNAVPVT(); //Check that RAM has been allocated for the PVT data
-  if (packetUBXNAVPVT == NULL) //Bail if the RAM allocation failed
-    return (false);
-
-  if (packetUBXNAVPVT->automaticFlags.flags.bits.automatic && packetUBXNAVPVT->automaticFlags.flags.bits.implicitUpdate)
-  {
-    //The GPS is automatically reporting, we just check whether we got unread data
-    // if (_printDebug == true)
-    // {
-    //   _debugSerial->println(F("getPVT: Autoreporting"));
-    // }
-    checkUbloxInternal(&packetCfg, UBX_CLASS_NAV, UBX_NAV_PVT);
-    return packetUBXNAVPVT->moduleQueried.moduleQueried1.bits.all;
-  }
-  else if (packetUBXNAVPVT->automaticFlags.flags.bits.automatic && !packetUBXNAVPVT->automaticFlags.flags.bits.implicitUpdate)
-  {
-    //Someone else has to call checkUblox for us...
-    // if (_printDebug == true)
-    // {
-    //   _debugSerial->println(F("getPVT: Exit immediately"));
-    // }
-    return (false);
-  }
-  else
-  {
-    // if (_printDebug == true)
-    // {
-    //   _debugSerial->println(F("getPVT: Polling"));
-    // }
-
-    //The GPS is not automatically reporting navigation position so we have to poll explicitly
-    packetCfg.cls = UBX_CLASS_NAV;
-    packetCfg.id = UBX_NAV_PVT;
-    packetCfg.len = 0;
-    packetCfg.startingSpot = 0;
-    //packetCfg.startingSpot = 20; //Begin listening at spot 20 so we can record up to 20+packetCfgPayloadSize = 84 bytes Note:now hard-coded in processUBX
-
-    //The data is parsed as part of processing the response
-    sfe_ublox_status_e retVal = sendCommand(&packetCfg, maxWait);
-
-    if (retVal == SFE_UBLOX_STATUS_DATA_RECEIVED)
-      return (true);
-
-    if (retVal == SFE_UBLOX_STATUS_DATA_OVERWRITTEN)
-    {
-      // if (_printDebug == true)
-      // {
-      //   _debugSerial->println(F("getPVT: data in packetCfg was OVERWRITTEN by another message (but that's OK)"));
-      // }
-      return (true);
-    }
-
-    // if (_printDebug == true)
-    // {
-    //   _debugSerial->print(F("getPVT retVal: "));
-    //   _debugSerial->println(statusString(retVal));
-    // }
-    return (false);
-  }
-}
-
-//Enable or disable automatic navigation message generation by the GNSS. This changes the way getPVT
-//works.
-boolean SFE_UBLOX_GNSS::setAutoPVT(boolean enable, uint16_t maxWait)
-{
-  return setAutoPVTrate(enable ? 1 : 0, true, maxWait);
-}
-
-//Enable or disable automatic navigation message generation by the GNSS. This changes the way getPVT
-//works.
-boolean SFE_UBLOX_GNSS::setAutoPVT(boolean enable, boolean implicitUpdate, uint16_t maxWait)
-{
-  return setAutoPVTrate(enable ? 1 : 0, implicitUpdate, maxWait);
-}
-
-//Enable or disable automatic navigation message generation by the GNSS. This changes the way getPVT
-//works.
-boolean SFE_UBLOX_GNSS::setAutoPVTrate(uint8_t rate, boolean implicitUpdate, uint16_t maxWait)
-{
-  if (packetUBXNAVPVT == NULL) initPacketUBXNAVPVT(); //Check that RAM has been allocated for the PVT data
-  if (packetUBXNAVPVT == NULL) //Only attempt this if RAM allocation was successful
-    return false;
-
-  if (rate > 127) rate = 127;
-
-  packetCfg.cls = UBX_CLASS_CFG;
-  packetCfg.id = UBX_CFG_MSG;
-  packetCfg.len = 3;
-  packetCfg.startingSpot = 0;
-  payloadCfg[0] = UBX_CLASS_NAV;
-  payloadCfg[1] = UBX_NAV_PVT;
-  payloadCfg[2] = rate; // rate relative to navigation freq.
-
-  boolean ok = ((sendCommand(&packetCfg, maxWait)) == SFE_UBLOX_STATUS_DATA_SENT); // We are only expecting an ACK
-  if (ok)
-  {
-    packetUBXNAVPVT->automaticFlags.flags.bits.automatic = (rate > 0);
-    packetUBXNAVPVT->automaticFlags.flags.bits.implicitUpdate = implicitUpdate;
-  }
-  packetUBXNAVPVT->moduleQueried.moduleQueried1.bits.all = false;
-  return ok;
-}
-
-//Enable automatic navigation message generation by the GNSS. This changes the way getPVT works.
-boolean SFE_UBLOX_GNSS::setAutoPVTcallback(void (*callbackPointer)(UBX_NAV_PVT_data_t), uint16_t maxWait)
-{
-  // Enable auto messages. Set implicitUpdate to false as we expect the user to call checkUblox manually.
-  boolean result = setAutoPVT(true, false, maxWait);
-  if (!result)
-    return (result); // Bail if setAutoPVT failed
-
-  if (packetUBXNAVPVT->callbackData == NULL) //Check if RAM has been allocated for the callback copy
-  {
-    packetUBXNAVPVT->callbackData = new UBX_NAV_PVT_data_t; //Allocate RAM for the main struct
-  }
-
-  if (packetUBXNAVPVT->callbackData == NULL)
-  {
-    if ((_printDebug == true) || (_printLimitedDebug == true)) // This is important. Print this if doing limited debugging
-      _debugSerial->println(F("setAutoPVTcallback: PANIC! RAM allocation failed!"));
-    return (false);
-  }
-
-  packetUBXNAVPVT->callbackPointer = callbackPointer; // RAM has been allocated so now update the pointer
-
-  return (true);
-}
-
-//In case no config access to the GNSS is possible and PVT is send cyclically already
-//set config to suitable parameters
-boolean SFE_UBLOX_GNSS::assumeAutoPVT(boolean enabled, boolean implicitUpdate)
-{
-  if (packetUBXNAVPVT == NULL) initPacketUBXNAVPVT(); //Check that RAM has been allocated for the PVT data
-  if (packetUBXNAVPVT == NULL) //Only attempt this if RAM allocation was successful
-    return false;
-
-  boolean changes = packetUBXNAVPVT->automaticFlags.flags.bits.automatic != enabled || packetUBXNAVPVT->automaticFlags.flags.bits.implicitUpdate != implicitUpdate;
-  if (changes)
-  {
-      packetUBXNAVPVT->automaticFlags.flags.bits.automatic = enabled;
-      packetUBXNAVPVT->automaticFlags.flags.bits.implicitUpdate = implicitUpdate;
-  }
-  return changes;
-}
-
-// PRIVATE: Allocate RAM for packetUBXNAVPVT and initialize it
-boolean SFE_UBLOX_GNSS::initPacketUBXNAVPVT()
-{
-  packetUBXNAVPVT = new UBX_NAV_PVT_t; //Allocate RAM for the main struct
-  if (packetUBXNAVPVT == NULL)
-  {
-    if ((_printDebug == true) || (_printLimitedDebug == true)) // This is important. Print this if doing limited debugging
-      _debugSerial->println(F("initPacketUBXNAVPVT: PANIC! RAM allocation failed!"));
-    return (false);
-  }
-  packetUBXNAVPVT->automaticFlags.flags.all = 0;
-  packetUBXNAVPVT->callbackPointer = NULL;
-  packetUBXNAVPVT->callbackData = NULL;
-  packetUBXNAVPVT->moduleQueried.moduleQueried1.all = 0;
-  packetUBXNAVPVT->moduleQueried.moduleQueried2.all = 0;
-  return (true);
-}
-
-//Mark all the PVT data as read/stale. This is handy to get data alignment after CRC failure
-void SFE_UBLOX_GNSS::flushPVT()
-{
-  if (packetUBXNAVPVT == NULL) return; // Bail if RAM has not been allocated (otherwise we could be writing anywhere!)
-  packetUBXNAVPVT->moduleQueried.moduleQueried1.all = 0; //Mark all datums as stale (read before)
-  packetUBXNAVPVT->moduleQueried.moduleQueried2.all = 0;
-}
-
-//Log this data in file buffer
-void SFE_UBLOX_GNSS::logNAVPVT(boolean enabled)
-{
-  if (packetUBXNAVPVT == NULL) return; // Bail if RAM has not been allocated (otherwise we could be writing anywhere!)
-  packetUBXNAVPVT->automaticFlags.flags.bits.addToFileBuffer = (uint8_t)enabled;
-}
-
-// ***** NAV ODO automatic support
-
-boolean SFE_UBLOX_GNSS::getNAVODO(uint16_t maxWait)
-{
-  if (packetUBXNAVODO == NULL) initPacketUBXNAVODO(); //Check that RAM has been allocated for the ODO data
-  if (packetUBXNAVODO == NULL) //Bail if the RAM allocation failed
-    return (false);
-
-  if (packetUBXNAVODO->automaticFlags.flags.bits.automatic && packetUBXNAVODO->automaticFlags.flags.bits.implicitUpdate)
-  {
-    //The GPS is automatically reporting, we just check whether we got unread data
-    checkUbloxInternal(&packetCfg, UBX_CLASS_NAV, UBX_NAV_ODO);
-    return packetUBXNAVODO->moduleQueried.moduleQueried.bits.all;
-  }
-  else if (packetUBXNAVODO->automaticFlags.flags.bits.automatic && !packetUBXNAVODO->automaticFlags.flags.bits.implicitUpdate)
-  {
-    //Someone else has to call checkUblox for us...
-    return (false);
-  }
-  else
-  {
-    //The GPS is not automatically reporting navigation position so we have to poll explicitly
-    packetCfg.cls = UBX_CLASS_NAV;
-    packetCfg.id = UBX_NAV_ODO;
-    packetCfg.len = 0;
-    packetCfg.startingSpot = 0;
-
-    //The data is parsed as part of processing the response
-    sfe_ublox_status_e retVal = sendCommand(&packetCfg, maxWait);
-
-    if (retVal == SFE_UBLOX_STATUS_DATA_RECEIVED)
-      return (true);
-
-    if (retVal == SFE_UBLOX_STATUS_DATA_OVERWRITTEN)
-    {
-      return (true);
-    }
-
-    return (false);
-  }
-}
-
-//Enable or disable automatic navigation message generation by the GNSS. This changes the way getODO
-//works.
-boolean SFE_UBLOX_GNSS::setAutoNAVODO(boolean enable, uint16_t maxWait)
-{
-  return setAutoNAVODOrate(enable ? 1 : 0, true, maxWait);
-}
-
-//Enable or disable automatic navigation message generation by the GNSS. This changes the way getODO
-//works.
-boolean SFE_UBLOX_GNSS::setAutoNAVODO(boolean enable, boolean implicitUpdate, uint16_t maxWait)
-{
-  return setAutoNAVODOrate(enable ? 1 : 0, implicitUpdate, maxWait);
-}
-
-//Enable or disable automatic navigation message generation by the GNSS. This changes the way getODO
-//works.
-boolean SFE_UBLOX_GNSS::setAutoNAVODOrate(uint8_t rate, boolean implicitUpdate, uint16_t maxWait)
-{
-  if (packetUBXNAVODO == NULL) initPacketUBXNAVODO(); //Check that RAM has been allocated for the data
-  if (packetUBXNAVODO == NULL) //Only attempt this if RAM allocation was successful
-    return false;
-
-  if (rate > 127) rate = 127;
-
-  packetCfg.cls = UBX_CLASS_CFG;
-  packetCfg.id = UBX_CFG_MSG;
-  packetCfg.len = 3;
-  packetCfg.startingSpot = 0;
-  payloadCfg[0] = UBX_CLASS_NAV;
-  payloadCfg[1] = UBX_NAV_ODO;
-  payloadCfg[2] = rate; // rate relative to navigation freq.
-
-  boolean ok = ((sendCommand(&packetCfg, maxWait)) == SFE_UBLOX_STATUS_DATA_SENT); // We are only expecting an ACK
-  if (ok)
-  {
-    packetUBXNAVODO->automaticFlags.flags.bits.automatic = (rate > 0);
-    packetUBXNAVODO->automaticFlags.flags.bits.implicitUpdate = implicitUpdate;
-  }
-  packetUBXNAVODO->moduleQueried.moduleQueried.bits.all = false;
-  return ok;
-}
-
-//Enable automatic navigation message generation by the GNSS.
-boolean SFE_UBLOX_GNSS::setAutoNAVODOcallback(void (*callbackPointer)(UBX_NAV_ODO_data_t), uint16_t maxWait)
-{
-  // Enable auto messages. Set implicitUpdate to false as we expect the user to call checkUblox manually.
-  boolean result = setAutoNAVODO(true, false, maxWait);
-  if (!result)
-    return (result); // Bail if setAuto failed
-
-  if (packetUBXNAVODO->callbackData == NULL) //Check if RAM has been allocated for the callback copy
-  {
-    packetUBXNAVODO->callbackData = new UBX_NAV_ODO_data_t; //Allocate RAM for the main struct
-  }
-
-  if (packetUBXNAVODO->callbackData == NULL)
-  {
-    if ((_printDebug == true) || (_printLimitedDebug == true)) // This is important. Print this if doing limited debugging
-      _debugSerial->println(F("setAutoNAVODOcallback: PANIC! RAM allocation failed!"));
-    return (false);
-  }
-
-  packetUBXNAVODO->callbackPointer = callbackPointer;
-  return (true);
-}
-
-//In case no config access to the GNSS is possible and ODO is send cyclically already
-//set config to suitable parameters
-boolean SFE_UBLOX_GNSS::assumeAutoNAVODO(boolean enabled, boolean implicitUpdate)
-{
-  if (packetUBXNAVODO == NULL) initPacketUBXNAVODO(); //Check that RAM has been allocated for the data
-  if (packetUBXNAVODO == NULL) //Only attempt this if RAM allocation was successful
-    return false;
-
-  boolean changes = packetUBXNAVODO->automaticFlags.flags.bits.automatic != enabled || packetUBXNAVODO->automaticFlags.flags.bits.implicitUpdate != implicitUpdate;
-  if (changes)
-  {
-    packetUBXNAVODO->automaticFlags.flags.bits.automatic = enabled;
-    packetUBXNAVODO->automaticFlags.flags.bits.implicitUpdate = implicitUpdate;
-  }
-  return changes;
-}
-
-// PRIVATE: Allocate RAM for packetUBXNAVODO and initialize it
-boolean SFE_UBLOX_GNSS::initPacketUBXNAVODO()
-{
-  packetUBXNAVODO = new UBX_NAV_ODO_t; //Allocate RAM for the main struct
-  if (packetUBXNAVODO == NULL)
-  {
-    if ((_printDebug == true) || (_printLimitedDebug == true)) // This is important. Print this if doing limited debugging
-      _debugSerial->println(F("initPacketUBXNAVODO: PANIC! RAM allocation failed!"));
-    return (false);
-  }
-  packetUBXNAVODO->automaticFlags.flags.all = 0;
-  packetUBXNAVODO->callbackPointer = NULL;
-  packetUBXNAVODO->callbackData = NULL;
-  packetUBXNAVODO->moduleQueried.moduleQueried.all = 0;
-  return (true);
-}
-
-//Mark all the data as read/stale
-void SFE_UBLOX_GNSS::flushNAVODO()
-{
-  if (packetUBXNAVODO == NULL) return; // Bail if RAM has not been allocated (otherwise we could be writing anywhere!)
-  packetUBXNAVODO->moduleQueried.moduleQueried.all = 0; //Mark all datums as stale (read before)
-}
-
-//Log this data in file buffer
-void SFE_UBLOX_GNSS::logNAVODO(boolean enabled)
-{
-  if (packetUBXNAVODO == NULL) return; // Bail if RAM has not been allocated (otherwise we could be writing anywhere!)
-  packetUBXNAVODO->automaticFlags.flags.bits.addToFileBuffer = (uint8_t)enabled;
-}
-
-// ***** NAV VELECEF automatic support
-
-boolean SFE_UBLOX_GNSS::getNAVVELECEF(uint16_t maxWait)
-{
-  if (packetUBXNAVVELECEF == NULL) initPacketUBXNAVVELECEF(); //Check that RAM has been allocated for the VELECEF data
-  if (packetUBXNAVVELECEF == NULL) //Bail if the RAM allocation failed
-    return (false);
-
-  if (packetUBXNAVVELECEF->automaticFlags.flags.bits.automatic && packetUBXNAVVELECEF->automaticFlags.flags.bits.implicitUpdate)
-  {
-    //The GPS is automatically reporting, we just check whether we got unread data
-    checkUbloxInternal(&packetCfg, UBX_CLASS_NAV, UBX_NAV_VELECEF);
-    return packetUBXNAVVELECEF->moduleQueried.moduleQueried.bits.all;
-  }
-  else if (packetUBXNAVVELECEF->automaticFlags.flags.bits.automatic && !packetUBXNAVVELECEF->automaticFlags.flags.bits.implicitUpdate)
-  {
-    //Someone else has to call checkUblox for us...
-    return (false);
-  }
-  else
-  {
-    //The GPS is not automatically reporting navigation position so we have to poll explicitly
-    packetCfg.cls = UBX_CLASS_NAV;
-    packetCfg.id = UBX_NAV_VELECEF;
-    packetCfg.len = 0;
-    packetCfg.startingSpot = 0;
-
-    //The data is parsed as part of processing the response
-    sfe_ublox_status_e retVal = sendCommand(&packetCfg, maxWait);
-
-    if (retVal == SFE_UBLOX_STATUS_DATA_RECEIVED)
-      return (true);
-
-    if (retVal == SFE_UBLOX_STATUS_DATA_OVERWRITTEN)
-    {
-      return (true);
-    }
-
-    return (false);
-  }
-}
-
-//Enable or disable automatic navigation message generation by the GNSS. This changes the way getVELECEF
-//works.
-boolean SFE_UBLOX_GNSS::setAutoNAVVELECEF(boolean enable, uint16_t maxWait)
-{
-  return setAutoNAVVELECEFrate(enable ? 1 : 0, true, maxWait);
-}
-
-//Enable or disable automatic navigation message generation by the GNSS. This changes the way getVELECEF
-//works.
-boolean SFE_UBLOX_GNSS::setAutoNAVVELECEF(boolean enable, boolean implicitUpdate, uint16_t maxWait)
-{
-  return setAutoNAVVELECEFrate(enable ? 1 : 0, implicitUpdate, maxWait);
-}
-
-//Enable or disable automatic navigation message generation by the GNSS. This changes the way getVELECEF
-//works.
-boolean SFE_UBLOX_GNSS::setAutoNAVVELECEFrate(uint8_t rate, boolean implicitUpdate, uint16_t maxWait)
-{
-  if (packetUBXNAVVELECEF == NULL) initPacketUBXNAVVELECEF(); //Check that RAM has been allocated for the data
-  if (packetUBXNAVVELECEF == NULL) //Only attempt this if RAM allocation was successful
-    return false;
-
-  if (rate > 127) rate = 127;
-
-  packetCfg.cls = UBX_CLASS_CFG;
-  packetCfg.id = UBX_CFG_MSG;
-  packetCfg.len = 3;
-  packetCfg.startingSpot = 0;
-  payloadCfg[0] = UBX_CLASS_NAV;
-  payloadCfg[1] = UBX_NAV_VELECEF;
-  payloadCfg[2] = rate; // rate relative to navigation freq.
-
-  boolean ok = ((sendCommand(&packetCfg, maxWait)) == SFE_UBLOX_STATUS_DATA_SENT); // We are only expecting an ACK
-  if (ok)
-  {
-    packetUBXNAVVELECEF->automaticFlags.flags.bits.automatic = (rate > 0);
-    packetUBXNAVVELECEF->automaticFlags.flags.bits.implicitUpdate = implicitUpdate;
-  }
-  packetUBXNAVVELECEF->moduleQueried.moduleQueried.bits.all = false;
-  return ok;
-}
-
-//Enable automatic navigation message generation by the GNSS.
-boolean SFE_UBLOX_GNSS::setAutoNAVVELECEFcallback(void (*callbackPointer)(UBX_NAV_VELECEF_data_t), uint16_t maxWait)
-{
-  // Enable auto messages. Set implicitUpdate to false as we expect the user to call checkUblox manually.
-  boolean result = setAutoNAVVELECEF(true, false, maxWait);
-  if (!result)
-    return (result); // Bail if setAuto failed
-
-  if (packetUBXNAVVELECEF->callbackData == NULL) //Check if RAM has been allocated for the callback copy
-  {
-    packetUBXNAVVELECEF->callbackData = new UBX_NAV_VELECEF_data_t; //Allocate RAM for the main struct
-  }
-
-  if (packetUBXNAVVELECEF->callbackData == NULL)
-  {
-    if ((_printDebug == true) || (_printLimitedDebug == true)) // This is important. Print this if doing limited debugging
-      _debugSerial->println(F("setAutoNAVVELECEFcallback: PANIC! RAM allocation failed!"));
-    return (false);
-  }
-
-  packetUBXNAVVELECEF->callbackPointer = callbackPointer;
-  return (true);
-}
-
-//In case no config access to the GNSS is possible and VELECEF is send cyclically already
-//set config to suitable parameters
-boolean SFE_UBLOX_GNSS::assumeAutoNAVVELECEF(boolean enabled, boolean implicitUpdate)
-{
-  if (packetUBXNAVVELECEF == NULL) initPacketUBXNAVVELECEF(); //Check that RAM has been allocated for the data
-  if (packetUBXNAVVELECEF == NULL) //Only attempt this if RAM allocation was successful
-    return false;
-
-  boolean changes = packetUBXNAVVELECEF->automaticFlags.flags.bits.automatic != enabled || packetUBXNAVVELECEF->automaticFlags.flags.bits.implicitUpdate != implicitUpdate;
-  if (changes)
-  {
-    packetUBXNAVVELECEF->automaticFlags.flags.bits.automatic = enabled;
-    packetUBXNAVVELECEF->automaticFlags.flags.bits.implicitUpdate = implicitUpdate;
-  }
-  return changes;
-}
-
-// PRIVATE: Allocate RAM for packetUBXNAVVELECEF and initialize it
-boolean SFE_UBLOX_GNSS::initPacketUBXNAVVELECEF()
-{
-  packetUBXNAVVELECEF = new UBX_NAV_VELECEF_t; //Allocate RAM for the main struct
-  if (packetUBXNAVVELECEF == NULL)
-  {
-    if ((_printDebug == true) || (_printLimitedDebug == true)) // This is important. Print this if doing limited debugging
-      _debugSerial->println(F("initPacketUBXNAVVELECEF: PANIC! RAM allocation failed!"));
-    return (false);
-  }
-  packetUBXNAVVELECEF->automaticFlags.flags.all = 0;
-  packetUBXNAVVELECEF->callbackPointer = NULL;
-  packetUBXNAVVELECEF->callbackData = NULL;
-  packetUBXNAVVELECEF->moduleQueried.moduleQueried.all = 0;
-  return (true);
-}
-
-//Mark all the data as read/stale
-void SFE_UBLOX_GNSS::flushNAVVELECEF()
-{
-  if (packetUBXNAVVELECEF == NULL) return; // Bail if RAM has not been allocated (otherwise we could be writing anywhere!)
-  packetUBXNAVVELECEF->moduleQueried.moduleQueried.all = 0; //Mark all datums as stale (read before)
-}
-
-//Log this data in file buffer
-void SFE_UBLOX_GNSS::logNAVVELECEF(boolean enabled)
-{
-  if (packetUBXNAVVELECEF == NULL) return; // Bail if RAM has not been allocated (otherwise we could be writing anywhere!)
-  packetUBXNAVVELECEF->automaticFlags.flags.bits.addToFileBuffer = (uint8_t)enabled;
-}
-
-// ***** NAV VELNED automatic support
-
-boolean SFE_UBLOX_GNSS::getNAVVELNED(uint16_t maxWait)
-{
-  if (packetUBXNAVVELNED == NULL) initPacketUBXNAVVELNED(); //Check that RAM has been allocated for the VELNED data
-  if (packetUBXNAVVELNED == NULL) //Bail if the RAM allocation failed
-    return (false);
-
-  if (packetUBXNAVVELNED->automaticFlags.flags.bits.automatic && packetUBXNAVVELNED->automaticFlags.flags.bits.implicitUpdate)
-  {
-    //The GPS is automatically reporting, we just check whether we got unread data
-    checkUbloxInternal(&packetCfg, UBX_CLASS_NAV, UBX_NAV_VELNED);
-    return packetUBXNAVVELNED->moduleQueried.moduleQueried.bits.all;
-  }
-  else if (packetUBXNAVVELNED->automaticFlags.flags.bits.automatic && !packetUBXNAVVELNED->automaticFlags.flags.bits.implicitUpdate)
-  {
-    //Someone else has to call checkUblox for us...
-    return (false);
-  }
-  else
-  {
-    //The GPS is not automatically reporting navigation position so we have to poll explicitly
-    packetCfg.cls = UBX_CLASS_NAV;
-    packetCfg.id = UBX_NAV_VELNED;
-    packetCfg.len = 0;
-    packetCfg.startingSpot = 0;
-
-    //The data is parsed as part of processing the response
-    sfe_ublox_status_e retVal = sendCommand(&packetCfg, maxWait);
-
-    if (retVal == SFE_UBLOX_STATUS_DATA_RECEIVED)
-      return (true);
-
-    if (retVal == SFE_UBLOX_STATUS_DATA_OVERWRITTEN)
-    {
-      return (true);
-    }
-
-    return (false);
-  }
-}
-
-//Enable or disable automatic navigation message generation by the GNSS. This changes the way getVELNED
-//works.
-boolean SFE_UBLOX_GNSS::setAutoNAVVELNED(boolean enable, uint16_t maxWait)
-{
-  return setAutoNAVVELNEDrate(enable ? 1 : 0, true, maxWait);
-}
-
-//Enable or disable automatic navigation message generation by the GNSS. This changes the way getVELNED
-//works.
-boolean SFE_UBLOX_GNSS::setAutoNAVVELNED(boolean enable, boolean implicitUpdate, uint16_t maxWait)
-{
-  return setAutoNAVVELNEDrate(enable ? 1 : 0, implicitUpdate, maxWait);
-}
-
-//Enable or disable automatic navigation message generation by the GNSS. This changes the way getVELNED
-//works.
-boolean SFE_UBLOX_GNSS::setAutoNAVVELNEDrate(uint8_t rate, boolean implicitUpdate, uint16_t maxWait)
-{
-  if (packetUBXNAVVELNED == NULL) initPacketUBXNAVVELNED(); //Check that RAM has been allocated for the data
-  if (packetUBXNAVVELNED == NULL) //Only attempt this if RAM allocation was successful
-    return false;
-
-  packetCfg.cls = UBX_CLASS_CFG;
-  packetCfg.id = UBX_CFG_MSG;
-  packetCfg.len = 3;
-  packetCfg.startingSpot = 0;
-  payloadCfg[0] = UBX_CLASS_NAV;
-  payloadCfg[1] = UBX_NAV_VELNED;
-  payloadCfg[2] = rate; // rate relative to navigation freq.
-
-  boolean ok = ((sendCommand(&packetCfg, maxWait)) == SFE_UBLOX_STATUS_DATA_SENT); // We are only expecting an ACK
-  if (ok)
-  {
-    packetUBXNAVVELNED->automaticFlags.flags.bits.automatic = (rate > 0);
-    packetUBXNAVVELNED->automaticFlags.flags.bits.implicitUpdate = implicitUpdate;
-  }
-  packetUBXNAVVELNED->moduleQueried.moduleQueried.bits.all = false;
-  return ok;
-}
-
-//Enable automatic navigation message generation by the GNSS.
-boolean SFE_UBLOX_GNSS::setAutoNAVVELNEDcallback(void (*callbackPointer)(UBX_NAV_VELNED_data_t), uint16_t maxWait)
-{
-  // Enable auto messages. Set implicitUpdate to false as we expect the user to call checkUblox manually.
-  boolean result = setAutoNAVVELNED(true, false, maxWait);
-  if (!result)
-    return (result); // Bail if setAuto failed
-
-  if (packetUBXNAVVELNED->callbackData == NULL) //Check if RAM has been allocated for the callback copy
-  {
-    packetUBXNAVVELNED->callbackData = new UBX_NAV_VELNED_data_t; //Allocate RAM for the main struct
-  }
-
-  if (packetUBXNAVVELNED->callbackData == NULL)
-  {
-    if ((_printDebug == true) || (_printLimitedDebug == true)) // This is important. Print this if doing limited debugging
-      _debugSerial->println(F("setAutoNAVVELNEDcallback: PANIC! RAM allocation failed!"));
-    return (false);
-  }
-
-  packetUBXNAVVELNED->callbackPointer = callbackPointer;
-  return (true);
-}
-
-//In case no config access to the GNSS is possible and VELNED is send cyclically already
-//set config to suitable parameters
-boolean SFE_UBLOX_GNSS::assumeAutoNAVVELNED(boolean enabled, boolean implicitUpdate)
-{
-  if (packetUBXNAVVELNED == NULL) initPacketUBXNAVVELNED(); //Check that RAM has been allocated for the data
-  if (packetUBXNAVVELNED == NULL) //Only attempt this if RAM allocation was successful
-    return false;
-
-  boolean changes = packetUBXNAVVELNED->automaticFlags.flags.bits.automatic != enabled || packetUBXNAVVELNED->automaticFlags.flags.bits.implicitUpdate != implicitUpdate;
-  if (changes)
-  {
-    packetUBXNAVVELNED->automaticFlags.flags.bits.automatic = enabled;
-    packetUBXNAVVELNED->automaticFlags.flags.bits.implicitUpdate = implicitUpdate;
-  }
-  return changes;
-}
-
-// PRIVATE: Allocate RAM for packetUBXNAVVELNED and initialize it
-boolean SFE_UBLOX_GNSS::initPacketUBXNAVVELNED()
-{
-  packetUBXNAVVELNED = new UBX_NAV_VELNED_t; //Allocate RAM for the main struct
-  if (packetUBXNAVVELNED == NULL)
-  {
-    if ((_printDebug == true) || (_printLimitedDebug == true)) // This is important. Print this if doing limited debugging
-      _debugSerial->println(F("initPacketUBXNAVVELNED: PANIC! RAM allocation failed!"));
-    return (false);
-  }
-  packetUBXNAVVELNED->automaticFlags.flags.all = 0;
-  packetUBXNAVVELNED->callbackPointer = NULL;
-  packetUBXNAVVELNED->callbackData = NULL;
-  packetUBXNAVVELNED->moduleQueried.moduleQueried.all = 0;
-  return (true);
-}
-
-//Mark all the data as read/stale
-void SFE_UBLOX_GNSS::flushNAVVELNED()
-{
-  if (packetUBXNAVVELNED == NULL) return; // Bail if RAM has not been allocated (otherwise we could be writing anywhere!
-  packetUBXNAVVELNED->moduleQueried.moduleQueried.all = 0; //Mark all datums as stale (read before)
-}
-
-//Log this data in file buffer
-void SFE_UBLOX_GNSS::logNAVVELNED(boolean enabled)
-{
-  if (packetUBXNAVVELNED == NULL) return; // Bail if RAM has not been allocated (otherwise we could be writing anywhere!)
-  packetUBXNAVVELNED->automaticFlags.flags.bits.addToFileBuffer = (uint8_t)enabled;
-}
-
-// ***** NAV HPPOSECEF automatic support
-
-boolean SFE_UBLOX_GNSS::getNAVHPPOSECEF(uint16_t maxWait)
-{
-  if (packetUBXNAVHPPOSECEF == NULL) initPacketUBXNAVHPPOSECEF(); //Check that RAM has been allocated for the HPPOSECEF data
-  if (packetUBXNAVHPPOSECEF == NULL) //Bail if the RAM allocation failed
-    return (false);
-
-  if (packetUBXNAVHPPOSECEF->automaticFlags.flags.bits.automatic && packetUBXNAVHPPOSECEF->automaticFlags.flags.bits.implicitUpdate)
-  {
-    //The GPS is automatically reporting, we just check whether we got unread data
-    checkUbloxInternal(&packetCfg, UBX_CLASS_NAV, UBX_NAV_HPPOSECEF);
-    return packetUBXNAVHPPOSECEF->moduleQueried.moduleQueried.bits.all;
-  }
-  else if (packetUBXNAVHPPOSECEF->automaticFlags.flags.bits.automatic && !packetUBXNAVHPPOSECEF->automaticFlags.flags.bits.implicitUpdate)
-  {
-    //Someone else has to call checkUblox for us...
-    return (false);
-  }
-  else
-  {
-    //The GPS is not automatically reporting navigation position so we have to poll explicitly
-    packetCfg.cls = UBX_CLASS_NAV;
-    packetCfg.id = UBX_NAV_HPPOSECEF;
-    packetCfg.len = 0;
-    packetCfg.startingSpot = 0;
-
-    //The data is parsed as part of processing the response
-    sfe_ublox_status_e retVal = sendCommand(&packetCfg, maxWait);
-
-    if (retVal == SFE_UBLOX_STATUS_DATA_RECEIVED)
-      return (true);
-
-    if (retVal == SFE_UBLOX_STATUS_DATA_OVERWRITTEN)
-    {
-      return (true);
-    }
-
-    return (false);
-  }
-}
-
-//Enable or disable automatic navigation message generation by the GNSS. This changes the way getHPPOSECEF
-//works.
-boolean SFE_UBLOX_GNSS::setAutoNAVHPPOSECEF(boolean enable, uint16_t maxWait)
-{
-  return setAutoNAVHPPOSECEFrate(enable ? 1 : 0, true, maxWait);
-}
-
-//Enable or disable automatic navigation message generation by the GNSS. This changes the way getHPPOSECEF
-//works.
-boolean SFE_UBLOX_GNSS::setAutoNAVHPPOSECEF(boolean enable, boolean implicitUpdate, uint16_t maxWait)
-{
-  return setAutoNAVHPPOSECEFrate(enable ? 1 : 0, implicitUpdate, maxWait);
-}
-
-//Enable or disable automatic navigation message generation by the GNSS. This changes the way getHPPOSECEF
-//works.
-boolean SFE_UBLOX_GNSS::setAutoNAVHPPOSECEFrate(uint8_t rate, boolean implicitUpdate, uint16_t maxWait)
-{
-  if (packetUBXNAVHPPOSECEF == NULL) initPacketUBXNAVHPPOSECEF(); //Check that RAM has been allocated for the data
-  if (packetUBXNAVHPPOSECEF == NULL) //Only attempt this if RAM allocation was successful
-    return false;
-
-  if (rate > 127) rate = 127;
-
-  packetCfg.cls = UBX_CLASS_CFG;
-  packetCfg.id = UBX_CFG_MSG;
-  packetCfg.len = 3;
-  packetCfg.startingSpot = 0;
-  payloadCfg[0] = UBX_CLASS_NAV;
-  payloadCfg[1] = UBX_NAV_HPPOSECEF;
-  payloadCfg[2] = rate; // rate relative to navigation freq.
-
-  boolean ok = ((sendCommand(&packetCfg, maxWait)) == SFE_UBLOX_STATUS_DATA_SENT); // We are only expecting an ACK
-  if (ok)
-  {
-    packetUBXNAVHPPOSECEF->automaticFlags.flags.bits.automatic = (rate > 0);
-    packetUBXNAVHPPOSECEF->automaticFlags.flags.bits.implicitUpdate = implicitUpdate;
-  }
-  packetUBXNAVHPPOSECEF->moduleQueried.moduleQueried.bits.all = false;
-  return ok;
-}
-
-//Enable automatic navigation message generation by the GNSS.
-boolean SFE_UBLOX_GNSS::setAutoNAVHPPOSECEFcallback(void (*callbackPointer)(UBX_NAV_HPPOSECEF_data_t), uint16_t maxWait)
-{
-  // Enable auto messages. Set implicitUpdate to false as we expect the user to call checkUblox manually.
-  boolean result = setAutoNAVHPPOSECEF(true, false, maxWait);
-  if (!result)
-    return (result); // Bail if setAuto failed
-
-  if (packetUBXNAVHPPOSECEF->callbackData == NULL) //Check if RAM has been allocated for the callback copy
-  {
-    packetUBXNAVHPPOSECEF->callbackData = new UBX_NAV_HPPOSECEF_data_t; //Allocate RAM for the main struct
-  }
-
-  if (packetUBXNAVHPPOSECEF->callbackData == NULL)
-  {
-    if ((_printDebug == true) || (_printLimitedDebug == true)) // This is important. Print this if doing limited debugging
-      _debugSerial->println(F("setAutoNAVHPPOSECEFcallback: PANIC! RAM allocation failed!"));
-    return (false);
-  }
-
-  packetUBXNAVHPPOSECEF->callbackPointer = callbackPointer;
-  return (true);
-}
-
-//In case no config access to the GNSS is possible and HPPOSECEF is send cyclically already
-//set config to suitable parameters
-boolean SFE_UBLOX_GNSS::assumeAutoNAVHPPOSECEF(boolean enabled, boolean implicitUpdate)
-{
-  if (packetUBXNAVHPPOSECEF == NULL) initPacketUBXNAVHPPOSECEF(); //Check that RAM has been allocated for the data
-  if (packetUBXNAVHPPOSECEF == NULL) //Only attempt this if RAM allocation was successful
-    return false;
-
-  boolean changes = packetUBXNAVHPPOSECEF->automaticFlags.flags.bits.automatic != enabled || packetUBXNAVHPPOSECEF->automaticFlags.flags.bits.implicitUpdate != implicitUpdate;
-  if (changes)
-  {
-    packetUBXNAVHPPOSECEF->automaticFlags.flags.bits.automatic = enabled;
-    packetUBXNAVHPPOSECEF->automaticFlags.flags.bits.implicitUpdate = implicitUpdate;
-  }
-  return changes;
-}
-
-// PRIVATE: Allocate RAM for packetUBXNAVHPPOSECEF and initialize it
-boolean SFE_UBLOX_GNSS::initPacketUBXNAVHPPOSECEF()
-{
-  packetUBXNAVHPPOSECEF = new UBX_NAV_HPPOSECEF_t; //Allocate RAM for the main struct
-  if (packetUBXNAVHPPOSECEF == NULL)
-  {
-    if ((_printDebug == true) || (_printLimitedDebug == true)) // This is important. Print this if doing limited debugging
-      _debugSerial->println(F("initPacketUBXNAVHPPOSECEF: PANIC! RAM allocation failed!"));
-    return (false);
-  }
-  packetUBXNAVHPPOSECEF->automaticFlags.flags.all = 0;
-  packetUBXNAVHPPOSECEF->callbackPointer = NULL;
-  packetUBXNAVHPPOSECEF->callbackData = NULL;
-  packetUBXNAVHPPOSECEF->moduleQueried.moduleQueried.all = 0;
-  return (true);
-}
-
-//Mark all the data as read/stale
-void SFE_UBLOX_GNSS::flushNAVHPPOSECEF()
-{
-  if (packetUBXNAVHPPOSECEF == NULL) return; // Bail if RAM has not been allocated (otherwise we could be writing anywhere!)
-  packetUBXNAVHPPOSECEF->moduleQueried.moduleQueried.all = 0; //Mark all datums as stale (read before)
-}
-
-//Log this data in file buffer
-void SFE_UBLOX_GNSS::logNAVHPPOSECEF(boolean enabled)
-{
-  if (packetUBXNAVHPPOSECEF == NULL) return; // Bail if RAM has not been allocated (otherwise we could be writing anywhere!)
-  packetUBXNAVHPPOSECEF->automaticFlags.flags.bits.addToFileBuffer = (uint8_t)enabled;
-}
-
-// ***** NAV HPPOSLLH automatic support
-
-boolean SFE_UBLOX_GNSS::getHPPOSLLH(uint16_t maxWait)
-{
-  if (packetUBXNAVHPPOSLLH == NULL) initPacketUBXNAVHPPOSLLH(); //Check that RAM has been allocated for the HPPOSLLH data
-  if (packetUBXNAVHPPOSLLH == NULL) //Bail if the RAM allocation failed
-    return (false);
-
-  if (packetUBXNAVHPPOSLLH->automaticFlags.flags.bits.automatic && packetUBXNAVHPPOSLLH->automaticFlags.flags.bits.implicitUpdate)
-  {
-    //The GPS is automatically reporting, we just check whether we got unread data
-    // if (_printDebug == true)
-    // {
-    //   _debugSerial->println(F("getHPPOSLLH: Autoreporting"));
-    // }
-    checkUbloxInternal(&packetCfg, UBX_CLASS_NAV, UBX_NAV_HPPOSLLH);
-    return packetUBXNAVHPPOSLLH->moduleQueried.moduleQueried.bits.all;
-  }
-  else if (packetUBXNAVHPPOSLLH->automaticFlags.flags.bits.automatic && !packetUBXNAVHPPOSLLH->automaticFlags.flags.bits.implicitUpdate)
-  {
-    //Someone else has to call checkUblox for us...
-    // if (_printDebug == true)
-    // {
-    //   _debugSerial->println(F("getHPPOSLLH: Exit immediately"));
-    // }
-    return (false);
-  }
-  else
-  {
-    // if (_printDebug == true)
-    // {
-    //   _debugSerial->println(F("getHPPOSLLH: Polling"));
-    // }
-
-    //The GPS is not automatically reporting navigation position so we have to poll explicitly
-    packetCfg.cls = UBX_CLASS_NAV;
-    packetCfg.id = UBX_NAV_HPPOSLLH;
-    packetCfg.len = 0;
-    packetCfg.startingSpot = 0;
-
-    //The data is parsed as part of processing the response
-    sfe_ublox_status_e retVal = sendCommand(&packetCfg, maxWait);
-
-    if (retVal == SFE_UBLOX_STATUS_DATA_RECEIVED)
-      return (true);
-
-    if (retVal == SFE_UBLOX_STATUS_DATA_OVERWRITTEN)
-    {
-      // if (_printDebug == true)
-      // {
-      //   _debugSerial->println(F("getHPPOSLLH: data in packetCfg was OVERWRITTEN by another message (but that's OK)"));
-      // }
-      return (true);
-    }
-
-    // if (_printDebug == true)
-    // {
-    //   _debugSerial->print(F("getHPPOSLLH retVal: "));
-    //   _debugSerial->println(statusString(retVal));
-    // }
-    return (false);
-  }
-}
-
-//Enable or disable automatic navigation message generation by the GNSS. This changes the way getHPPOSLLH
-//works.
-boolean SFE_UBLOX_GNSS::setAutoHPPOSLLH(boolean enable, uint16_t maxWait)
-{
-  return setAutoHPPOSLLHrate(enable ? 1 : 0, true, maxWait);
-}
-
-//Enable or disable automatic navigation message generation by the GNSS. This changes the way getHPPOSLLH
-//works.
-boolean SFE_UBLOX_GNSS::setAutoHPPOSLLH(boolean enable, boolean implicitUpdate, uint16_t maxWait)
-{
-  return setAutoHPPOSLLHrate(enable ? 1 : 0, implicitUpdate, maxWait);
-}
-
-//Enable or disable automatic navigation message generation by the GNSS. This changes the way getHPPOSLLH
-//works.
-boolean SFE_UBLOX_GNSS::setAutoHPPOSLLHrate(uint8_t rate, boolean implicitUpdate, uint16_t maxWait)
-{
-  if (packetUBXNAVHPPOSLLH == NULL) initPacketUBXNAVHPPOSLLH(); //Check that RAM has been allocated for the data
-  if (packetUBXNAVHPPOSLLH == NULL) //Only attempt this if RAM allocation was successful
-    return false;
-
-  if (rate > 127) rate = 127;
-
-  packetCfg.cls = UBX_CLASS_CFG;
-  packetCfg.id = UBX_CFG_MSG;
-  packetCfg.len = 3;
-  packetCfg.startingSpot = 0;
-  payloadCfg[0] = UBX_CLASS_NAV;
-  payloadCfg[1] = UBX_NAV_HPPOSLLH;
-  payloadCfg[2] = rate; // rate relative to navigation freq.
-
-  boolean ok = ((sendCommand(&packetCfg, maxWait)) == SFE_UBLOX_STATUS_DATA_SENT); // We are only expecting an ACK
-  if (ok)
-  {
-    packetUBXNAVHPPOSLLH->automaticFlags.flags.bits.automatic = (rate > 0);
-    packetUBXNAVHPPOSLLH->automaticFlags.flags.bits.implicitUpdate = implicitUpdate;
-  }
-  packetUBXNAVHPPOSLLH->moduleQueried.moduleQueried.bits.all = false;
-  return ok;
-}
-
-//Enable automatic navigation message generation by the GNSS.
-boolean SFE_UBLOX_GNSS::setAutoHPPOSLLHcallback(void (*callbackPointer)(UBX_NAV_HPPOSLLH_data_t), uint16_t maxWait)
-{
-  // Enable auto messages. Set implicitUpdate to false as we expect the user to call checkUblox manually.
-  boolean result = setAutoHPPOSLLH(true, false, maxWait);
-  if (!result)
-    return (result); // Bail if setAuto failed
-
-  if (packetUBXNAVHPPOSLLH->callbackData == NULL) //Check if RAM has been allocated for the callback copy
-  {
-    packetUBXNAVHPPOSLLH->callbackData = new UBX_NAV_HPPOSLLH_data_t; //Allocate RAM for the main struct
-  }
-
-  if (packetUBXNAVHPPOSLLH->callbackData == NULL)
-  {
-    if ((_printDebug == true) || (_printLimitedDebug == true)) // This is important. Print this if doing limited debugging
-      _debugSerial->println(F("setAutoHPPOSLLHcallback: PANIC! RAM allocation failed!"));
-    return (false);
-  }
-
-  packetUBXNAVHPPOSLLH->callbackPointer = callbackPointer;
-  return (true);
-}
-
-//In case no config access to the GNSS is possible and HPPOSLLH is send cyclically already
-//set config to suitable parameters
-boolean SFE_UBLOX_GNSS::assumeAutoHPPOSLLH(boolean enabled, boolean implicitUpdate)
-{
-  if (packetUBXNAVHPPOSLLH == NULL) initPacketUBXNAVHPPOSLLH(); //Check that RAM has been allocated for the data
-  if (packetUBXNAVHPPOSLLH == NULL) //Only attempt this if RAM allocation was successful
-    return false;
-
-  boolean changes = packetUBXNAVHPPOSLLH->automaticFlags.flags.bits.automatic != enabled || packetUBXNAVHPPOSLLH->automaticFlags.flags.bits.implicitUpdate != implicitUpdate;
-  if (changes)
-  {
-    packetUBXNAVHPPOSLLH->automaticFlags.flags.bits.automatic = enabled;
-    packetUBXNAVHPPOSLLH->automaticFlags.flags.bits.implicitUpdate = implicitUpdate;
-  }
-  return changes;
-}
-
-// PRIVATE: Allocate RAM for packetUBXNAVHPPOSLLH and initialize it
-boolean SFE_UBLOX_GNSS::initPacketUBXNAVHPPOSLLH()
-{
-  packetUBXNAVHPPOSLLH = new UBX_NAV_HPPOSLLH_t; //Allocate RAM for the main struct
-  if (packetUBXNAVHPPOSLLH == NULL)
-  {
-    if ((_printDebug == true) || (_printLimitedDebug == true)) // This is important. Print this if doing limited debugging
-      _debugSerial->println(F("initPacketUBXNAVHPPOSLLH: PANIC! RAM allocation failed!"));
-    return (false);
-  }
-  packetUBXNAVHPPOSLLH->automaticFlags.flags.all = 0;
-  packetUBXNAVHPPOSLLH->callbackPointer = NULL;
-  packetUBXNAVHPPOSLLH->callbackData = NULL;
-  packetUBXNAVHPPOSLLH->moduleQueried.moduleQueried.all = 0;
-  return (true);
-}
-
-//Mark all the HPPOSLLH data as read/stale. This is handy to get data alignment after CRC failure
-void SFE_UBLOX_GNSS::flushHPPOSLLH()
-{
-  if (packetUBXNAVHPPOSLLH == NULL) return; // Bail if RAM has not been allocated (otherwise we could be writing anywhere!
-  packetUBXNAVHPPOSLLH->moduleQueried.moduleQueried.all = 0;   //Mark all datums as stale (read before)
-}
-
-//Log this data in file buffer
-void SFE_UBLOX_GNSS::logNAVHPPOSLLH(boolean enabled)
-{
-  if (packetUBXNAVHPPOSLLH == NULL) return; // Bail if RAM has not been allocated (otherwise we could be writing anywhere!)
-  packetUBXNAVHPPOSLLH->automaticFlags.flags.bits.addToFileBuffer = (uint8_t)enabled;
-}
-
-// ***** NAV CLOCK automatic support
-
-boolean SFE_UBLOX_GNSS::getNAVCLOCK(uint16_t maxWait)
-{
-  if (packetUBXNAVCLOCK == NULL) initPacketUBXNAVCLOCK(); //Check that RAM has been allocated for the CLOCK data
-  if (packetUBXNAVCLOCK == NULL) //Bail if the RAM allocation failed
-    return (false);
-
-  if (packetUBXNAVCLOCK->automaticFlags.flags.bits.automatic && packetUBXNAVCLOCK->automaticFlags.flags.bits.implicitUpdate)
-  {
-    //The GPS is automatically reporting, we just check whether we got unread data
-    checkUbloxInternal(&packetCfg, UBX_CLASS_NAV, UBX_NAV_CLOCK);
-    return packetUBXNAVCLOCK->moduleQueried.moduleQueried.bits.all;
-  }
-  else if (packetUBXNAVCLOCK->automaticFlags.flags.bits.automatic && !packetUBXNAVCLOCK->automaticFlags.flags.bits.implicitUpdate)
-  {
-    //Someone else has to call checkUblox for us...
-    return (false);
-  }
-  else
-  {
-    //The GPS is not automatically reporting CLOCK so we have to poll explicitly
-    packetCfg.cls = UBX_CLASS_NAV;
-    packetCfg.id = UBX_NAV_CLOCK;
-    packetCfg.len = 0;
-    packetCfg.startingSpot = 0;
-
-    //The data is parsed as part of processing the response
-    sfe_ublox_status_e retVal = sendCommand(&packetCfg, maxWait);
-
-    if (retVal == SFE_UBLOX_STATUS_DATA_RECEIVED)
-      return (true);
-
-    if (retVal == SFE_UBLOX_STATUS_DATA_OVERWRITTEN)
-    {
-      return (true);
-    }
-
-    return (false);
-  }
-}
-
-//Enable or disable automatic CLOCK message generation by the GNSS. This changes the way getNAVCLOCK
-//works.
-boolean SFE_UBLOX_GNSS::setAutoNAVCLOCK(boolean enable, uint16_t maxWait)
-{
-  return setAutoNAVCLOCKrate(enable ? 1 : 0, true, maxWait);
-}
-
-//Enable or disable automatic CLOCK message generation by the GNSS. This changes the way getNAVCLOCK
-//works.
-boolean SFE_UBLOX_GNSS::setAutoNAVCLOCK(boolean enable, boolean implicitUpdate, uint16_t maxWait)
-{
-  return setAutoNAVCLOCKrate(enable ? 1 : 0, implicitUpdate, maxWait);
-}
-
-//Enable or disable automatic CLOCK attitude message generation by the GNSS. This changes the way getNAVCLOCK
-//works.
-boolean SFE_UBLOX_GNSS::setAutoNAVCLOCKrate(uint8_t rate, boolean implicitUpdate, uint16_t maxWait)
-{
-  if (packetUBXNAVCLOCK == NULL) initPacketUBXNAVCLOCK(); //Check that RAM has been allocated for the data
-  if (packetUBXNAVCLOCK == NULL) //Only attempt this if RAM allocation was successful
-    return false;
-
-  if (rate > 127) rate = 127;
-
-  packetCfg.cls = UBX_CLASS_CFG;
-  packetCfg.id = UBX_CFG_MSG;
-  packetCfg.len = 3;
-  packetCfg.startingSpot = 0;
-  payloadCfg[0] = UBX_CLASS_NAV;
-  payloadCfg[1] = UBX_NAV_CLOCK;
-  payloadCfg[2] = rate; // rate relative to navigation freq.
-
-  boolean ok = ((sendCommand(&packetCfg, maxWait)) == SFE_UBLOX_STATUS_DATA_SENT); // We are only expecting an ACK
-  if (ok)
-  {
-    packetUBXNAVCLOCK->automaticFlags.flags.bits.automatic = (rate > 0);
-    packetUBXNAVCLOCK->automaticFlags.flags.bits.implicitUpdate = implicitUpdate;
-  }
-  packetUBXNAVCLOCK->moduleQueried.moduleQueried.bits.all = false; // Mark data as stale
-  return ok;
-}
-
-//Enable automatic navigation message generation by the GNSS.
-boolean SFE_UBLOX_GNSS::setAutoNAVCLOCKcallback(void (*callbackPointer)(UBX_NAV_CLOCK_data_t), uint16_t maxWait)
-{
-  // Enable auto messages. Set implicitUpdate to false as we expect the user to call checkUblox manually.
-  boolean result = setAutoNAVCLOCK(true, false, maxWait);
-  if (!result)
-    return (result); // Bail if setAuto failed
-
-  if (packetUBXNAVCLOCK->callbackData == NULL) //Check if RAM has been allocated for the callback copy
-  {
-    packetUBXNAVCLOCK->callbackData = new UBX_NAV_CLOCK_data_t; //Allocate RAM for the main struct
-  }
-
-  if (packetUBXNAVCLOCK->callbackData == NULL)
-  {
-    if ((_printDebug == true) || (_printLimitedDebug == true)) // This is important. Print this if doing limited debugging
-      _debugSerial->println(F("setAutoNAVCLOCKcallback: PANIC! RAM allocation failed!"));
-    return (false);
-  }
-
-  packetUBXNAVCLOCK->callbackPointer = callbackPointer;
-  return (true);
-}
-
-//In case no config access to the GNSS is possible and HNR attitude is send cyclically already
-//set config to suitable parameters
-boolean SFE_UBLOX_GNSS::assumeAutoNAVCLOCK(boolean enabled, boolean implicitUpdate)
-{
-  if (packetUBXNAVCLOCK == NULL) initPacketUBXNAVCLOCK(); //Check that RAM has been allocated for the CLOCK data
-  if (packetUBXNAVCLOCK == NULL) //Bail if the RAM allocation failed
-    return (false);
-
-  boolean changes = packetUBXNAVCLOCK->automaticFlags.flags.bits.automatic != enabled || packetUBXNAVCLOCK->automaticFlags.flags.bits.implicitUpdate != implicitUpdate;
-  if (changes)
-  {
-    packetUBXNAVCLOCK->automaticFlags.flags.bits.automatic = enabled;
-    packetUBXNAVCLOCK->automaticFlags.flags.bits.implicitUpdate = implicitUpdate;
-  }
-  return changes;
-}
-
-// PRIVATE: Allocate RAM for packetUBXNAVCLOCK and initialize it
-boolean SFE_UBLOX_GNSS::initPacketUBXNAVCLOCK()
-{
-  packetUBXNAVCLOCK = new UBX_NAV_CLOCK_t ; //Allocate RAM for the main struct
-  if (packetUBXNAVCLOCK == NULL)
-  {
-    if ((_printDebug == true) || (_printLimitedDebug == true)) // This is important. Print this if doing limited debugging
-      _debugSerial->println(F("initPacketUBXNAVCLOCK: PANIC! RAM allocation failed!"));
-    return (false);
-  }
-  packetUBXNAVCLOCK->automaticFlags.flags.all = 0;
-  packetUBXNAVCLOCK->callbackPointer = NULL;
-  packetUBXNAVCLOCK->callbackData = NULL;
-  packetUBXNAVCLOCK->moduleQueried.moduleQueried.all = 0;
-  return (true);
-}
-
-//Mark all the data as read/stale
-void SFE_UBLOX_GNSS::flushNAVCLOCK()
-{
-  if (packetUBXNAVCLOCK == NULL) return; // Bail if RAM has not been allocated (otherwise we could be writing anywhere!)
-  packetUBXNAVCLOCK->moduleQueried.moduleQueried.all = 0; //Mark all datums as stale (read before)
-}
-
-//Log this data in file buffer
-void SFE_UBLOX_GNSS::logNAVCLOCK(boolean enabled)
-{
-  if (packetUBXNAVCLOCK == NULL) return; // Bail if RAM has not been allocated (otherwise we could be writing anywhere!)
-  packetUBXNAVCLOCK->automaticFlags.flags.bits.addToFileBuffer = (uint8_t)enabled;
-}
-
-// ***** NAV SVIN automatic support
-
-//Reads survey in status and sets the global variables
-//for status, position valid, observation time, and mean 3D StdDev
-//Returns true if commands was successful
-boolean SFE_UBLOX_GNSS::getSurveyStatus(uint16_t maxWait)
-{
-  if (packetUBXNAVSVIN == NULL) initPacketUBXNAVSVIN(); //Check that RAM has been allocated for the SVIN data
-  if (packetUBXNAVSVIN == NULL) // Abort if the RAM allocation failed
-    return (false);
-
-  packetCfg.cls = UBX_CLASS_NAV;
-  packetCfg.id = UBX_NAV_SVIN;
-  packetCfg.len = 0;
-  packetCfg.startingSpot = 0;
-
-  //The data is parsed as part of processing the response
-  sfe_ublox_status_e retVal = sendCommand(&packetCfg, maxWait);
-
-  if (retVal == SFE_UBLOX_STATUS_DATA_RECEIVED)
-    return (true);
-
-  if (retVal == SFE_UBLOX_STATUS_DATA_OVERWRITTEN)
-  {
-    return (true);
-  }
-
-  return (false);
-}
-
-// PRIVATE: Allocate RAM for packetUBXNAVSVIN and initialize it
-boolean SFE_UBLOX_GNSS::initPacketUBXNAVSVIN()
-{
-  packetUBXNAVSVIN = new UBX_NAV_SVIN_t; //Allocate RAM for the main struct
-  if (packetUBXNAVSVIN == NULL)
-  {
-    if ((_printDebug == true) || (_printLimitedDebug == true)) // This is important. Print this if doing limited debugging
-      _debugSerial->println(F("initPacketUBXNAVSVIN: PANIC! RAM allocation failed!"));
-    return (false);
-  }
-  packetUBXNAVSVIN->automaticFlags.flags.all = 0;
-  packetUBXNAVSVIN->callbackPointer = NULL;
-  packetUBXNAVSVIN->callbackData = NULL;
-  packetUBXNAVSVIN->moduleQueried.moduleQueried.all = 0;
-  return (true);
-}
-
-// ***** NAV RELPOSNED automatic support
-
-//Relative Positioning Information in NED frame
-//Returns true if commands was successful
-//Note:
-//  RELPOSNED on the M8 is only 40 bytes long
-//  RELPOSNED on the F9 is 64 bytes long and contains much more information
-boolean SFE_UBLOX_GNSS::getRELPOSNED(uint16_t maxWait)
-{
-  if (packetUBXNAVRELPOSNED == NULL) initPacketUBXNAVRELPOSNED(); //Check that RAM has been allocated for the RELPOSNED data
-  if (packetUBXNAVRELPOSNED == NULL) //Bail if the RAM allocation failed
-    return (false);
-
-  if (packetUBXNAVRELPOSNED->automaticFlags.flags.bits.automatic && packetUBXNAVRELPOSNED->automaticFlags.flags.bits.implicitUpdate)
-  {
-    //The GPS is automatically reporting, we just check whether we got unread data
-    checkUbloxInternal(&packetCfg, UBX_CLASS_NAV, UBX_NAV_RELPOSNED);
-    return packetUBXNAVRELPOSNED->moduleQueried.moduleQueried.bits.all;
-  }
-  else if (packetUBXNAVRELPOSNED->automaticFlags.flags.bits.automatic && !packetUBXNAVRELPOSNED->automaticFlags.flags.bits.implicitUpdate)
-  {
-    //Someone else has to call checkUblox for us...
-    return (false);
-  }
-  else
-  {
-    //The GPS is not automatically reporting RELPOSNED so we have to poll explicitly
-    packetCfg.cls = UBX_CLASS_NAV;
-    packetCfg.id = UBX_NAV_RELPOSNED;
-    packetCfg.len = 0;
-    packetCfg.startingSpot = 0;
-
-    //The data is parsed as part of processing the response
-    sfe_ublox_status_e retVal = sendCommand(&packetCfg, maxWait);
-
-    if (retVal == SFE_UBLOX_STATUS_DATA_RECEIVED)
-      return (true);
-
-    if (retVal == SFE_UBLOX_STATUS_DATA_OVERWRITTEN)
-    {
-      return (true);
-    }
-
-    return (false);
-  }
-}
-
-//Enable or disable automatic RELPOSNED message generation by the GNSS. This changes the way getRELPOSNED
-//works.
-boolean SFE_UBLOX_GNSS::setAutoRELPOSNED(boolean enable, uint16_t maxWait)
-{
-  return setAutoRELPOSNEDrate(enable ? 1 : 0, true, maxWait);
-}
-
-//Enable or disable automatic RELPOSNED message generation by the GNSS. This changes the way getRELPOSNED
-//works.
-boolean SFE_UBLOX_GNSS::setAutoRELPOSNED(boolean enable, boolean implicitUpdate, uint16_t maxWait)
-{
-  return setAutoRELPOSNEDrate(enable ? 1 : 0, implicitUpdate, maxWait);
-}
-
-//Enable or disable automatic HNR attitude message generation by the GNSS. This changes the way getRELPOSNED
-//works.
-boolean SFE_UBLOX_GNSS::setAutoRELPOSNEDrate(uint8_t rate, boolean implicitUpdate, uint16_t maxWait)
-{
-  if (packetUBXNAVRELPOSNED == NULL) initPacketUBXNAVRELPOSNED(); //Check that RAM has been allocated for the data
-  if (packetUBXNAVRELPOSNED == NULL) //Only attempt this if RAM allocation was successful
-    return false;
-
-  if (rate > 127) rate = 127;
-
-  packetCfg.cls = UBX_CLASS_CFG;
-  packetCfg.id = UBX_CFG_MSG;
-  packetCfg.len = 3;
-  packetCfg.startingSpot = 0;
-  payloadCfg[0] = UBX_CLASS_NAV;
-  payloadCfg[1] = UBX_NAV_RELPOSNED;
-  payloadCfg[2] = rate; // rate relative to navigation freq.
-
-  boolean ok = ((sendCommand(&packetCfg, maxWait)) == SFE_UBLOX_STATUS_DATA_SENT); // We are only expecting an ACK
-  if (ok)
-  {
-    packetUBXNAVRELPOSNED->automaticFlags.flags.bits.automatic = (rate > 0);
-    packetUBXNAVRELPOSNED->automaticFlags.flags.bits.implicitUpdate = implicitUpdate;
-  }
-  packetUBXNAVRELPOSNED->moduleQueried.moduleQueried.bits.all = false; // Mark data as stale
-  return ok;
-}
-
-//Enable automatic navigation message generation by the GNSS.
-boolean SFE_UBLOX_GNSS::setAutoRELPOSNEDcallback(void (*callbackPointer)(UBX_NAV_RELPOSNED_data_t), uint16_t maxWait)
-{
-  // Enable auto messages. Set implicitUpdate to false as we expect the user to call checkUblox manually.
-  boolean result = setAutoRELPOSNED(true, false, maxWait);
-  if (!result)
-    return (result); // Bail if setAuto failed
-
-  if (packetUBXNAVRELPOSNED->callbackData == NULL) //Check if RAM has been allocated for the callback copy
-  {
-    packetUBXNAVRELPOSNED->callbackData = new UBX_NAV_RELPOSNED_data_t; //Allocate RAM for the main struct
-  }
-
-  if (packetUBXNAVRELPOSNED->callbackData == NULL)
-  {
-    if ((_printDebug == true) || (_printLimitedDebug == true)) // This is important. Print this if doing limited debugging
-      _debugSerial->println(F("setAutoRELPOSNEDcallback: PANIC! RAM allocation failed!"));
-    return (false);
-  }
-
-  packetUBXNAVRELPOSNED->callbackPointer = callbackPointer;
-  return (true);
-}
-
-//In case no config access to the GNSS is possible and HNR attitude is send cyclically already
-//set config to suitable parameters
-boolean SFE_UBLOX_GNSS::assumeAutoRELPOSNED(boolean enabled, boolean implicitUpdate)
-{
-  if (packetUBXNAVRELPOSNED == NULL) initPacketUBXNAVRELPOSNED(); //Check that RAM has been allocated for the RELPOSNED data
-  if (packetUBXNAVRELPOSNED == NULL) //Bail if the RAM allocation failed
-    return (false);
-
-  boolean changes = packetUBXNAVRELPOSNED->automaticFlags.flags.bits.automatic != enabled || packetUBXNAVRELPOSNED->automaticFlags.flags.bits.implicitUpdate != implicitUpdate;
-  if (changes)
-  {
-    packetUBXNAVRELPOSNED->automaticFlags.flags.bits.automatic = enabled;
-    packetUBXNAVRELPOSNED->automaticFlags.flags.bits.implicitUpdate = implicitUpdate;
-  }
-  return changes;
-}
-
-// PRIVATE: Allocate RAM for packetUBXNAVRELPOSNED and initialize it
-boolean SFE_UBLOX_GNSS::initPacketUBXNAVRELPOSNED()
-{
-  packetUBXNAVRELPOSNED = new UBX_NAV_RELPOSNED_t ; //Allocate RAM for the main struct
-  if (packetUBXNAVRELPOSNED == NULL)
-  {
-    if ((_printDebug == true) || (_printLimitedDebug == true)) // This is important. Print this if doing limited debugging
-      _debugSerial->println(F("initPacketUBXNAVRELPOSNED: PANIC! RAM allocation failed!"));
-    return (false);
-  }
-  packetUBXNAVRELPOSNED->automaticFlags.flags.all = 0;
-  packetUBXNAVRELPOSNED->callbackPointer = NULL;
-  packetUBXNAVRELPOSNED->callbackData = NULL;
-  packetUBXNAVRELPOSNED->moduleQueried.moduleQueried.all = 0;
-  return (true);
-}
-
-//Mark all the data as read/stale
-void SFE_UBLOX_GNSS::flushNAVRELPOSNED()
-{
-  if (packetUBXNAVRELPOSNED == NULL) return; // Bail if RAM has not been allocated (otherwise we could be writing anywhere!)
-  packetUBXNAVRELPOSNED->moduleQueried.moduleQueried.all = 0; //Mark all datums as stale (read before)
-}
-
-//Log this data in file buffer
-void SFE_UBLOX_GNSS::logNAVRELPOSNED(boolean enabled)
-{
-  if (packetUBXNAVRELPOSNED == NULL) return; // Bail if RAM has not been allocated (otherwise we could be writing anywhere!)
-  packetUBXNAVRELPOSNED->automaticFlags.flags.bits.addToFileBuffer = (uint8_t)enabled;
-}
-
-// ***** RXM SFRBX automatic support
-
-boolean SFE_UBLOX_GNSS::getRXMSFRBX(uint16_t maxWait)
-{
-  if (packetUBXRXMSFRBX == NULL) initPacketUBXRXMSFRBX(); //Check that RAM has been allocated for the TM2 data
-  if (packetUBXRXMSFRBX == NULL) //Bail if the RAM allocation failed
-    return (false);
-
-  if (packetUBXRXMSFRBX->automaticFlags.flags.bits.automatic && packetUBXRXMSFRBX->automaticFlags.flags.bits.implicitUpdate)
-  {
-    //The GPS is automatically reporting, we just check whether we got unread data
-    checkUbloxInternal(&packetCfg, UBX_CLASS_TIM, UBX_TIM_TM2);
-    return packetUBXRXMSFRBX->moduleQueried;
-  }
-  else if (packetUBXRXMSFRBX->automaticFlags.flags.bits.automatic && !packetUBXRXMSFRBX->automaticFlags.flags.bits.implicitUpdate)
-  {
-    //Someone else has to call checkUblox for us...
-    return (false);
-  }
-  else
-  {
-    //The GPS is not automatically reporting navigation position so we have to poll explicitly
-    packetCfg.cls = UBX_CLASS_RXM;
-    packetCfg.id = UBX_RXM_SFRBX;
-    packetCfg.len = 0;
-    packetCfg.startingSpot = 0;
-
-    //The data is parsed as part of processing the response
-    sfe_ublox_status_e retVal = sendCommand(&packetCfg, maxWait);
-
-    if (retVal == SFE_UBLOX_STATUS_DATA_RECEIVED)
-      return (true);
-
-    if (retVal == SFE_UBLOX_STATUS_DATA_OVERWRITTEN)
-    {
-      return (true);
-    }
-
-    return (false);
-  }
-}
-
-//Enable or disable automatic navigation message generation by the GNSS. This changes the way getRXMSFRBX
-//works.
-boolean SFE_UBLOX_GNSS::setAutoRXMSFRBX(boolean enable, uint16_t maxWait)
-{
-  return setAutoRXMSFRBXrate(enable ? 1 : 0, true, maxWait);
-}
-
-//Enable or disable automatic navigation message generation by the GNSS. This changes the way getRXMSFRBX
-//works.
-boolean SFE_UBLOX_GNSS::setAutoRXMSFRBX(boolean enable, boolean implicitUpdate, uint16_t maxWait)
-{
-  return setAutoRXMSFRBXrate(enable ? 1 : 0, implicitUpdate, maxWait);
-}
-
-//Enable or disable automatic navigation message generation by the GNSS. This changes the way getRXMSFRBX
-//works.
-boolean SFE_UBLOX_GNSS::setAutoRXMSFRBXrate(uint8_t rate, boolean implicitUpdate, uint16_t maxWait)
-{
-  if (packetUBXRXMSFRBX == NULL) initPacketUBXRXMSFRBX(); //Check that RAM has been allocated for the data
-  if (packetUBXRXMSFRBX == NULL) //Only attempt this if RAM allocation was successful
-    return false;
-
-  if (rate > 127) rate = 127;
-
-  packetCfg.cls = UBX_CLASS_CFG;
-  packetCfg.id = UBX_CFG_MSG;
-  packetCfg.len = 3;
-  packetCfg.startingSpot = 0;
-  payloadCfg[0] = UBX_CLASS_RXM;
-  payloadCfg[1] = UBX_RXM_SFRBX;
-  payloadCfg[2] = rate; // rate relative to navigation freq.
-
-  boolean ok = ((sendCommand(&packetCfg, maxWait)) == SFE_UBLOX_STATUS_DATA_SENT); // We are only expecting an ACK
-  if (ok)
-  {
-    packetUBXRXMSFRBX->automaticFlags.flags.bits.automatic = (rate > 0);
-    packetUBXRXMSFRBX->automaticFlags.flags.bits.implicitUpdate = implicitUpdate;
-  }
-  packetUBXRXMSFRBX->moduleQueried = false;
-  return ok;
-}
-
-//Enable automatic navigation message generation by the GNSS.
-boolean SFE_UBLOX_GNSS::setAutoRXMSFRBXcallback(void (*callbackPointer)(UBX_RXM_SFRBX_data_t), uint16_t maxWait)
-{
-  // Enable auto messages. Set implicitUpdate to false as we expect the user to call checkUblox manually.
-  boolean result = setAutoRXMSFRBX(true, false, maxWait);
-  if (!result)
-    return (result); // Bail if setAuto failed
-
-  if (packetUBXRXMSFRBX->callbackData == NULL) //Check if RAM has been allocated for the callback copy
-  {
-    packetUBXRXMSFRBX->callbackData = new UBX_RXM_SFRBX_data_t; //Allocate RAM for the main struct
-  }
-
-  if (packetUBXRXMSFRBX->callbackData == NULL)
-  {
-    if ((_printDebug == true) || (_printLimitedDebug == true)) // This is important. Print this if doing limited debugging
-      _debugSerial->println(F("setAutoRXMSFRBXcallback: PANIC! RAM allocation failed!"));
-    return (false);
-  }
-
-  packetUBXRXMSFRBX->callbackPointer = callbackPointer;
-  return (true);
-}
-
-//In case no config access to the GNSS is possible and SFRBX is send cyclically already
-//set config to suitable parameters
-boolean SFE_UBLOX_GNSS::assumeAutoRXMSFRBX(boolean enabled, boolean implicitUpdate)
-{
-  if (packetUBXRXMSFRBX == NULL) initPacketUBXRXMSFRBX(); //Check that RAM has been allocated for the data
-  if (packetUBXRXMSFRBX == NULL) //Only attempt this if RAM allocation was successful
-    return false;
-
-  boolean changes = packetUBXRXMSFRBX->automaticFlags.flags.bits.automatic != enabled || packetUBXRXMSFRBX->automaticFlags.flags.bits.implicitUpdate != implicitUpdate;
-  if (changes)
-  {
-    packetUBXRXMSFRBX->automaticFlags.flags.bits.automatic = enabled;
-    packetUBXRXMSFRBX->automaticFlags.flags.bits.implicitUpdate = implicitUpdate;
-  }
-  return changes;
-}
-
-// PRIVATE: Allocate RAM for packetUBXRXMSFRBX and initialize it
-boolean SFE_UBLOX_GNSS::initPacketUBXRXMSFRBX()
-{
-  packetUBXRXMSFRBX = new UBX_RXM_SFRBX_t; //Allocate RAM for the main struct
-  if (packetUBXRXMSFRBX == NULL)
-  {
-    if ((_printDebug == true) || (_printLimitedDebug == true)) // This is important. Print this if doing limited debugging
-      _debugSerial->println(F("initPacketUBXRXMSFRBX: PANIC! RAM allocation failed!"));
-    return (false);
-  }
-  packetUBXRXMSFRBX->automaticFlags.flags.all = 0;
-  packetUBXRXMSFRBX->callbackPointer = NULL;
-  packetUBXRXMSFRBX->callbackData = NULL;
-  packetUBXRXMSFRBX->moduleQueried = false;
-  return (true);
-}
-
-//Mark all the data as read/stale
-void SFE_UBLOX_GNSS::flushRXMSFRBX()
-{
-  if (packetUBXRXMSFRBX == NULL) return; // Bail if RAM has not been allocated (otherwise we could be writing anywhere!)
-  packetUBXRXMSFRBX->moduleQueried = false; //Mark all datums as stale (read before)
-}
-
-//Log this data in file buffer
-void SFE_UBLOX_GNSS::logRXMSFRBX(boolean enabled)
-{
-  if (packetUBXRXMSFRBX == NULL) return; // Bail if RAM has not been allocated (otherwise we could be writing anywhere!)
-  packetUBXRXMSFRBX->automaticFlags.flags.bits.addToFileBuffer = (uint8_t)enabled;
-}
-
-// ***** RXM RAWX automatic support
-
-boolean SFE_UBLOX_GNSS::getRXMRAWX(uint16_t maxWait)
-{
-  if (packetUBXRXMRAWX == NULL) initPacketUBXRXMRAWX(); //Check that RAM has been allocated for the TM2 data
-  if (packetUBXRXMRAWX == NULL) //Bail if the RAM allocation failed
-    return (false);
-
-  if (packetUBXRXMRAWX->automaticFlags.flags.bits.automatic && packetUBXRXMRAWX->automaticFlags.flags.bits.implicitUpdate)
-  {
-    //The GPS is automatically reporting, we just check whether we got unread data
-    checkUbloxInternal(&packetCfg, UBX_CLASS_TIM, UBX_TIM_TM2);
-    return packetUBXRXMRAWX->moduleQueried;
-  }
-  else if (packetUBXRXMRAWX->automaticFlags.flags.bits.automatic && !packetUBXRXMRAWX->automaticFlags.flags.bits.implicitUpdate)
-  {
-    //Someone else has to call checkUblox for us...
-    return (false);
-  }
-  else
-  {
-    //The GPS is not automatically reporting navigation position so we have to poll explicitly
-    packetCfg.cls = UBX_CLASS_RXM;
-    packetCfg.id = UBX_RXM_RAWX;
-    packetCfg.len = 0;
-    packetCfg.startingSpot = 0;
-
-    //The data is parsed as part of processing the response
-    sfe_ublox_status_e retVal = sendCommand(&packetCfg, maxWait);
-
-    if (retVal == SFE_UBLOX_STATUS_DATA_RECEIVED)
-      return (true);
-
-    if (retVal == SFE_UBLOX_STATUS_DATA_OVERWRITTEN)
-    {
-      return (true);
-    }
-
-    return (false);
-  }
-}
-
-//Enable or disable automatic navigation message generation by the GNSS. This changes the way getRXMRAWX
-//works.
-boolean SFE_UBLOX_GNSS::setAutoRXMRAWX(boolean enable, uint16_t maxWait)
-{
-  return setAutoRXMRAWXrate(enable ? 1 : 0, true, maxWait);
-}
-
-//Enable or disable automatic navigation message generation by the GNSS. This changes the way getRXMRAWX
-//works.
-boolean SFE_UBLOX_GNSS::setAutoRXMRAWX(boolean enable, boolean implicitUpdate, uint16_t maxWait)
-{
-  return setAutoRXMRAWXrate(enable ? 1 : 0, implicitUpdate, maxWait);
-}
-
-//Enable or disable automatic navigation message generation by the GNSS. This changes the way getRXMRAWX
-//works.
-boolean SFE_UBLOX_GNSS::setAutoRXMRAWXrate(uint8_t rate, boolean implicitUpdate, uint16_t maxWait)
-{
-  if (packetUBXRXMRAWX == NULL) initPacketUBXRXMRAWX(); //Check that RAM has been allocated for the data
-  if (packetUBXRXMRAWX == NULL) //Only attempt this if RAM allocation was successful
-    return false;
-
-  if (rate > 127) rate = 127;
-
-  packetCfg.cls = UBX_CLASS_CFG;
-  packetCfg.id = UBX_CFG_MSG;
-  packetCfg.len = 3;
-  packetCfg.startingSpot = 0;
-  payloadCfg[0] = UBX_CLASS_RXM;
-  payloadCfg[1] = UBX_RXM_RAWX;
-  payloadCfg[2] = rate; // rate relative to navigation freq.
-
-  boolean ok = ((sendCommand(&packetCfg, maxWait)) == SFE_UBLOX_STATUS_DATA_SENT); // We are only expecting an ACK
-  if (ok)
-  {
-    packetUBXRXMRAWX->automaticFlags.flags.bits.automatic = (rate > 0);
-    packetUBXRXMRAWX->automaticFlags.flags.bits.implicitUpdate = implicitUpdate;
-  }
-  packetUBXRXMRAWX->moduleQueried = false;
-  return ok;
-}
-
-//Enable automatic navigation message generation by the GNSS.
-boolean SFE_UBLOX_GNSS::setAutoRXMRAWXcallback(void (*callbackPointer)(UBX_RXM_RAWX_data_t), uint16_t maxWait)
-{
-  // Enable auto messages. Set implicitUpdate to false as we expect the user to call checkUblox manually.
-  boolean result = setAutoRXMRAWX(true, false, maxWait);
-  if (!result)
-    return (result); // Bail if setAuto failed
-
-  if (packetUBXRXMRAWX->callbackData == NULL) //Check if RAM has been allocated for the callback copy
-  {
-    packetUBXRXMRAWX->callbackData = new UBX_RXM_RAWX_data_t; //Allocate RAM for the main struct
-  }
-
-  if (packetUBXRXMRAWX->callbackData == NULL)
-  {
-    if ((_printDebug == true) || (_printLimitedDebug == true)) // This is important. Print this if doing limited debugging
-      _debugSerial->println(F("setAutoRXMRAWXcallback: PANIC! RAM allocation failed!"));
-    return (false);
-  }
-
-  packetUBXRXMRAWX->callbackPointer = callbackPointer;
-  return (true);
-}
-
-//In case no config access to the GNSS is possible and VELNED is send cyclically already
-//set config to suitable parameters
-boolean SFE_UBLOX_GNSS::assumeAutoRXMRAWX(boolean enabled, boolean implicitUpdate)
-{
-  if (packetUBXRXMRAWX == NULL) initPacketUBXRXMRAWX(); //Check that RAM has been allocated for the data
-  if (packetUBXRXMRAWX == NULL) //Only attempt this if RAM allocation was successful
-    return false;
-
-  boolean changes = packetUBXRXMRAWX->automaticFlags.flags.bits.automatic != enabled || packetUBXRXMRAWX->automaticFlags.flags.bits.implicitUpdate != implicitUpdate;
-  if (changes)
-  {
-    packetUBXRXMRAWX->automaticFlags.flags.bits.automatic = enabled;
-    packetUBXRXMRAWX->automaticFlags.flags.bits.implicitUpdate = implicitUpdate;
-  }
-  return changes;
-}
-
-// PRIVATE: Allocate RAM for packetUBXRXMRAWX and initialize it
-boolean SFE_UBLOX_GNSS::initPacketUBXRXMRAWX()
-{
-  packetUBXRXMRAWX = new UBX_RXM_RAWX_t; //Allocate RAM for the main struct
-  if (packetUBXRXMRAWX == NULL)
-  {
-    if ((_printDebug == true) || (_printLimitedDebug == true)) // This is important. Print this if doing limited debugging
-      _debugSerial->println(F("initPacketUBXRXMRAWX: PANIC! RAM allocation failed!"));
-    return (false);
-  }
-  packetUBXRXMRAWX->automaticFlags.flags.all = 0;
-  packetUBXRXMRAWX->callbackPointer = NULL;
-  packetUBXRXMRAWX->callbackData = NULL;
-  packetUBXRXMRAWX->moduleQueried = false;
-  return (true);
-}
-
-//Mark all the data as read/stale
-void SFE_UBLOX_GNSS::flushRXMRAWX()
-{
-  if (packetUBXRXMRAWX == NULL) return; // Bail if RAM has not been allocated (otherwise we could be writing anywhere!)
-  packetUBXRXMRAWX->moduleQueried = false; //Mark all datums as stale (read before)
-}
-
-//Log this data in file buffer
-void SFE_UBLOX_GNSS::logRXMRAWX(boolean enabled)
-{
-  if (packetUBXRXMRAWX == NULL) return; // Bail if RAM has not been allocated (otherwise we could be writing anywhere!)
-  packetUBXRXMRAWX->automaticFlags.flags.bits.addToFileBuffer = (uint8_t)enabled;
-}
-
-// ***** CFG automatic support
-
-//Get the latest CFG RATE - as used by isConnected
-boolean SFE_UBLOX_GNSS::getNavigationFrequencyInternal(uint16_t maxWait)
-{
-  if (packetUBXCFGRATE == NULL) initPacketUBXCFGRATE(); //Check that RAM has been allocated for the data
-  if (packetUBXCFGRATE == NULL) //Bail if the RAM allocation failed
-    return (false);
-
-  if (packetUBXCFGRATE->automaticFlags.flags.bits.automatic && packetUBXCFGRATE->automaticFlags.flags.bits.implicitUpdate)
-  {
-    //The GPS is automatically reporting, we just check whether we got unread data
-    checkUbloxInternal(&packetCfg, UBX_CLASS_CFG, UBX_CFG_RATE);
-    return packetUBXCFGRATE->moduleQueried.moduleQueried.bits.all;
-  }
-  else if (packetUBXCFGRATE->automaticFlags.flags.bits.automatic && !packetUBXCFGRATE->automaticFlags.flags.bits.implicitUpdate)
-  {
-    //Someone else has to call checkUblox for us...
-    return (false);
-  }
-  else
-  {
-    //The GPS is not automatically reporting navigation rate so we have to poll explicitly
-    packetCfg.cls = UBX_CLASS_CFG;
-    packetCfg.id = UBX_CFG_RATE;
-    packetCfg.len = 0;
-    packetCfg.startingSpot = 0;
-
-    //The data is parsed as part of processing the response
-    sfe_ublox_status_e retVal = sendCommand(&packetCfg, maxWait);
-
-    if (retVal == SFE_UBLOX_STATUS_DATA_RECEIVED)
-      return (true);
-
-    if (retVal == SFE_UBLOX_STATUS_DATA_OVERWRITTEN)
-    {
-      return (true);
-    }
-
-    return (false);
-  }
-}
-
-// PRIVATE: Allocate RAM for packetUBXCFGRATE and initialize it
-boolean SFE_UBLOX_GNSS::initPacketUBXCFGRATE()
-{
-  packetUBXCFGRATE = new UBX_CFG_RATE_t; //Allocate RAM for the main struct
-  if (packetUBXCFGRATE == NULL)
-  {
-    if ((_printDebug == true) || (_printLimitedDebug == true)) // This is important. Print this if doing limited debugging
-      _debugSerial->println(F("initPacketUBXCFGRATE: PANIC! RAM allocation failed!"));
-    return (false);
-  }
-  packetUBXCFGRATE->automaticFlags.flags.all = 0;
-  packetUBXCFGRATE->callbackPointer = NULL;
-  packetUBXCFGRATE->callbackData = NULL;
-  packetUBXCFGRATE->moduleQueried.moduleQueried.all = 0;
-  return (true);
-}
-
-// ***** TIM TM2 automatic support
-
-boolean SFE_UBLOX_GNSS::getTIMTM2(uint16_t maxWait)
-{
-  if (packetUBXTIMTM2 == NULL) initPacketUBXTIMTM2(); //Check that RAM has been allocated for the TM2 data
-  if (packetUBXTIMTM2 == NULL) //Bail if the RAM allocation failed
-    return (false);
-
-  if (packetUBXTIMTM2->automaticFlags.flags.bits.automatic && packetUBXTIMTM2->automaticFlags.flags.bits.implicitUpdate)
-  {
-    //The GPS is automatically reporting, we just check whether we got unread data
-    checkUbloxInternal(&packetCfg, UBX_CLASS_TIM, UBX_TIM_TM2);
-    return packetUBXTIMTM2->moduleQueried.moduleQueried.bits.all;
-  }
-  else if (packetUBXTIMTM2->automaticFlags.flags.bits.automatic && !packetUBXTIMTM2->automaticFlags.flags.bits.implicitUpdate)
-  {
-    //Someone else has to call checkUblox for us...
-    return (false);
-  }
-  else
-  {
-    //The GPS is not automatically reporting navigation position so we have to poll explicitly
-    packetCfg.cls = UBX_CLASS_TIM;
-    packetCfg.id = UBX_TIM_TM2;
-    packetCfg.len = 0;
-    packetCfg.startingSpot = 0;
-
-    //The data is parsed as part of processing the response
-    sfe_ublox_status_e retVal = sendCommand(&packetCfg, maxWait);
-
-    if (retVal == SFE_UBLOX_STATUS_DATA_RECEIVED)
-      return (true);
-
-    if (retVal == SFE_UBLOX_STATUS_DATA_OVERWRITTEN)
-    {
-      return (true);
-    }
-
-    return (false);
-  }
-}
-
-//Enable or disable automatic navigation message generation by the GNSS. This changes the way getTIMTM2
-//works.
-boolean SFE_UBLOX_GNSS::setAutoTIMTM2(boolean enable, uint16_t maxWait)
-{
-  return setAutoTIMTM2rate(enable ? 1 : 0, true, maxWait);
-}
-
-//Enable or disable automatic navigation message generation by the GNSS. This changes the way getTIMTM2
-//works.
-boolean SFE_UBLOX_GNSS::setAutoTIMTM2(boolean enable, boolean implicitUpdate, uint16_t maxWait)
-{
-  return setAutoTIMTM2rate(enable ? 1 : 0, implicitUpdate, maxWait);
-}
-
-//Enable or disable automatic navigation message generation by the GNSS. This changes the way getTIMTM2
-//works.
-boolean SFE_UBLOX_GNSS::setAutoTIMTM2rate(uint8_t rate, boolean implicitUpdate, uint16_t maxWait)
-{
-  if (packetUBXTIMTM2 == NULL) initPacketUBXTIMTM2(); //Check that RAM has been allocated for the data
-  if (packetUBXTIMTM2 == NULL) //Only attempt this if RAM allocation was successful
-    return false;
-
-  if (rate > 127) rate = 127;
-
-  packetCfg.cls = UBX_CLASS_CFG;
-  packetCfg.id = UBX_CFG_MSG;
-  packetCfg.len = 3;
-  packetCfg.startingSpot = 0;
-  payloadCfg[0] = UBX_CLASS_TIM;
-  payloadCfg[1] = UBX_TIM_TM2;
-  payloadCfg[2] = rate; // rate relative to navigation freq.
-
-  boolean ok = ((sendCommand(&packetCfg, maxWait)) == SFE_UBLOX_STATUS_DATA_SENT); // We are only expecting an ACK
-  if (ok)
-  {
-    packetUBXTIMTM2->automaticFlags.flags.bits.automatic = (rate > 0);
-    packetUBXTIMTM2->automaticFlags.flags.bits.implicitUpdate = implicitUpdate;
-  }
-  packetUBXTIMTM2->moduleQueried.moduleQueried.bits.all = false;
-  return ok;
-}
-
-//Enable automatic navigation message generation by the GNSS.
-boolean SFE_UBLOX_GNSS::setAutoTIMTM2callback(void (*callbackPointer)(UBX_TIM_TM2_data_t), uint16_t maxWait)
-{
-  // Enable auto messages. Set implicitUpdate to false as we expect the user to call checkUblox manually.
-  boolean result = setAutoTIMTM2(true, false, maxWait);
-  if (!result)
-    return (result); // Bail if setAuto failed
-
-  if (packetUBXTIMTM2->callbackData == NULL) //Check if RAM has been allocated for the callback copy
-  {
-    packetUBXTIMTM2->callbackData = new UBX_TIM_TM2_data_t; //Allocate RAM for the main struct
-  }
-
-  if (packetUBXTIMTM2->callbackData == NULL)
-  {
-    if ((_printDebug == true) || (_printLimitedDebug == true)) // This is important. Print this if doing limited debugging
-      _debugSerial->println(F("setAutoTIMTM2callback: PANIC! RAM allocation failed!"));
-    return (false);
-  }
-
-  packetUBXTIMTM2->callbackPointer = callbackPointer;
-  return (true);
-}
-
-//In case no config access to the GNSS is possible and VELNED is send cyclically already
-//set config to suitable parameters
-boolean SFE_UBLOX_GNSS::assumeAutoTIMTM2(boolean enabled, boolean implicitUpdate)
-{
-  if (packetUBXTIMTM2 == NULL) initPacketUBXTIMTM2(); //Check that RAM has been allocated for the data
-  if (packetUBXTIMTM2 == NULL) //Only attempt this if RAM allocation was successful
-    return false;
-
-  boolean changes = packetUBXTIMTM2->automaticFlags.flags.bits.automatic != enabled || packetUBXTIMTM2->automaticFlags.flags.bits.implicitUpdate != implicitUpdate;
-  if (changes)
-  {
-    packetUBXTIMTM2->automaticFlags.flags.bits.automatic = enabled;
-    packetUBXTIMTM2->automaticFlags.flags.bits.implicitUpdate = implicitUpdate;
-  }
-  return changes;
-}
-
-// PRIVATE: Allocate RAM for packetUBXTIMTM2 and initialize it
-boolean SFE_UBLOX_GNSS::initPacketUBXTIMTM2()
-{
-  packetUBXTIMTM2 = new UBX_TIM_TM2_t; //Allocate RAM for the main struct
-  if (packetUBXTIMTM2 == NULL)
-  {
-    if ((_printDebug == true) || (_printLimitedDebug == true)) // This is important. Print this if doing limited debugging
-      _debugSerial->println(F("initPacketUBXTIMTM2: PANIC! RAM allocation failed!"));
-    return (false);
-  }
-  packetUBXTIMTM2->automaticFlags.flags.all = 0;
-  packetUBXTIMTM2->callbackPointer = NULL;
-  packetUBXTIMTM2->callbackData = NULL;
-  packetUBXTIMTM2->moduleQueried.moduleQueried.all = 0;
-  return (true);
-}
-
-//Mark all the data as read/stale
-void SFE_UBLOX_GNSS::flushTIMTM2()
-{
-  if (packetUBXTIMTM2 == NULL) return; // Bail if RAM has not been allocated (otherwise we could be writing anywhere!)
-  packetUBXTIMTM2->moduleQueried.moduleQueried.all = 0; //Mark all datums as stale (read before)
-}
-
-//Log this data in file buffer
-void SFE_UBLOX_GNSS::logTIMTM2(boolean enabled)
-{
-  if (packetUBXTIMTM2 == NULL) return; // Bail if RAM has not been allocated (otherwise we could be writing anywhere!)
-  packetUBXTIMTM2->automaticFlags.flags.bits.addToFileBuffer = (uint8_t)enabled;
-}
-
-// ***** ESF ALG automatic support
-
-boolean SFE_UBLOX_GNSS::getEsfAlignment(uint16_t maxWait)
-{
-  return (getESFALG(maxWait));
-}
-
-boolean SFE_UBLOX_GNSS::getESFALG(uint16_t maxWait)
-{
-  if (packetUBXESFALG == NULL) initPacketUBXESFALG(); //Check that RAM has been allocated for the ESF alignment data
-  if (packetUBXESFALG == NULL) //Only attempt this if RAM allocation was successful
-    return false;
-
-  if (packetUBXESFALG->automaticFlags.flags.bits.automatic && packetUBXESFALG->automaticFlags.flags.bits.implicitUpdate)
-  {
-    //The GPS is automatically reporting, we just check whether we got unread data
-    // if (_printDebug == true)
-    // {
-    //   _debugSerial->println(F("getEsfAlignment: Autoreporting"));
-    // }
-    checkUbloxInternal(&packetCfg, UBX_CLASS_ESF, UBX_ESF_ALG);
-    return packetUBXESFALG->moduleQueried.moduleQueried.bits.all;
-  }
-  else if (packetUBXESFALG->automaticFlags.flags.bits.automatic && !packetUBXESFALG->automaticFlags.flags.bits.implicitUpdate)
-  {
-    //Someone else has to call checkUblox for us...
-    // if (_printDebug == true)
-    // {
-    //   _debugSerial->println(F("getEsfAlignment: Exit immediately"));
-    // }
-    return (false);
-  }
-  else
-  {
-    // if (_printDebug == true)
-    // {
-    //   _debugSerial->println(F("getEsfAlignment: Polling"));
-    // }
-
-    //The GPS is not automatically reporting HNR PVT so we have to poll explicitly
-    packetCfg.cls = UBX_CLASS_ESF;
-    packetCfg.id = UBX_ESF_ALG;
-    packetCfg.len = 0;
-    packetCfg.startingSpot = 0;
-
-    //The data is parsed as part of processing the response
-    sfe_ublox_status_e retVal = sendCommand(&packetCfg, maxWait);
-
-    if (retVal == SFE_UBLOX_STATUS_DATA_RECEIVED)
-      return (true);
-
-    if (retVal == SFE_UBLOX_STATUS_DATA_OVERWRITTEN)
-    {
-      // if (_printDebug == true)
-      // {
-      //   _debugSerial->println(F("getEsfAlignment: data in packetCfg was OVERWRITTEN by another message (but that's OK)"));
-      // }
-      return (true);
-    }
-
-    // if (_printDebug == true)
-    // {
-    //   _debugSerial->print(F("getEsfAlignment retVal: "));
-    //   _debugSerial->println(statusString(retVal));
-    // }
-    return (false);
-  }
-
-  return (false); // Trap. We should never get here...
-}
-
-//Enable or disable automatic ESF ALG message generation by the GNSS. This changes the way getEsfAlignment
-//works.
-boolean SFE_UBLOX_GNSS::setAutoESFALG(boolean enable, uint16_t maxWait)
-{
-  return setAutoESFALGrate(enable ? 1 : 0, true, maxWait);
-}
-
-//Enable or disable automatic ESF ALG message generation by the GNSS. This changes the way getEsfAlignment
-//works.
-boolean SFE_UBLOX_GNSS::setAutoESFALG(boolean enable, boolean implicitUpdate, uint16_t maxWait)
-{
-  return setAutoESFALGrate(enable ? 1 : 0, implicitUpdate, maxWait);
-}
-
-//Enable or disable automatic ESF ALG message generation by the GNSS. This changes the way getEsfAlignment
-//works.
-boolean SFE_UBLOX_GNSS::setAutoESFALGrate(uint8_t rate, boolean implicitUpdate, uint16_t maxWait)
-{
-  if (packetUBXESFALG == NULL) initPacketUBXESFALG(); //Check that RAM has been allocated for the data
-  if (packetUBXESFALG == NULL) //Only attempt this if RAM allocation was successful
-    return false;
-
-  if (rate > 127) rate = 127;
-
-  packetCfg.cls = UBX_CLASS_CFG;
-  packetCfg.id = UBX_CFG_MSG;
-  packetCfg.len = 3;
-  packetCfg.startingSpot = 0;
-  payloadCfg[0] = UBX_CLASS_ESF;
-  payloadCfg[1] = UBX_ESF_ALG;
-  payloadCfg[2] = rate; // rate relative to navigation freq.
-
-  boolean ok = ((sendCommand(&packetCfg, maxWait)) == SFE_UBLOX_STATUS_DATA_SENT); // We are only expecting an ACK
-  if (ok)
-  {
-    packetUBXESFALG->automaticFlags.flags.bits.automatic = (rate > 0);
-    packetUBXESFALG->automaticFlags.flags.bits.implicitUpdate = implicitUpdate;
-  }
-  packetUBXESFALG->moduleQueried.moduleQueried.bits.all = false; // Mark data as stale
-  return ok;
-}
-
-//Enable automatic navigation message generation by the GNSS.
-boolean SFE_UBLOX_GNSS::setAutoESFALGcallback(void (*callbackPointer)(UBX_ESF_ALG_data_t), uint16_t maxWait)
-{
-  // Enable auto messages. Set implicitUpdate to false as we expect the user to call checkUblox manually.
-  boolean result = setAutoESFALG(true, false, maxWait);
-  if (!result)
-    return (result); // Bail if setAuto failed
-
-  if (packetUBXESFALG->callbackData == NULL) //Check if RAM has been allocated for the callback copy
-  {
-    packetUBXESFALG->callbackData = new UBX_ESF_ALG_data_t; //Allocate RAM for the main struct
-  }
-
-  if (packetUBXESFALG->callbackData == NULL)
-  {
-    if ((_printDebug == true) || (_printLimitedDebug == true)) // This is important. Print this if doing limited debugging
-      _debugSerial->println(F("setAutoESFALGcallback: PANIC! RAM allocation failed!"));
-    return (false);
-  }
-
-  packetUBXESFALG->callbackPointer = callbackPointer;
-  return (true);
-}
-
-//In case no config access to the GNSS is possible and ESF ALG is send cyclically already
-//set config to suitable parameters
-boolean SFE_UBLOX_GNSS::assumeAutoESFALG(boolean enabled, boolean implicitUpdate)
-{
-  if (packetUBXESFALG == NULL) initPacketUBXESFALG(); //Check that RAM has been allocated for the ESF alignment data
-  if (packetUBXESFALG == NULL) //Only attempt this if RAM allocation was successful
-    return false;
-
-  boolean changes = packetUBXESFALG->automaticFlags.flags.bits.automatic != enabled || packetUBXESFALG->automaticFlags.flags.bits.implicitUpdate != implicitUpdate;
-  if (changes)
-  {
-    packetUBXESFALG->automaticFlags.flags.bits.automatic = enabled;
-    packetUBXESFALG->automaticFlags.flags.bits.implicitUpdate = implicitUpdate;
-  }
-  return changes;
-}
-
-// PRIVATE: Allocate RAM for packetUBXESFALG and initialize it
-boolean SFE_UBLOX_GNSS::initPacketUBXESFALG()
-{
-  packetUBXESFALG = new UBX_ESF_ALG_t; //Allocate RAM for the main struct
-  if (packetUBXESFALG == NULL)
-  {
-    if ((_printDebug == true) || (_printLimitedDebug == true)) // This is important. Print this if doing limited debugging
-      _debugSerial->println(F("initPacketUBXESFALG: PANIC! RAM allocation failed!"));
-    return (false);
-  }
-  packetUBXESFALG->automaticFlags.flags.all = 0;
-  packetUBXESFALG->callbackPointer = NULL;
-  packetUBXESFALG->callbackData = NULL;
-  packetUBXESFALG->moduleQueried.moduleQueried.all = 0;
-  return (true);
-}
-
-//Mark all the data as read/stale
-void SFE_UBLOX_GNSS::flushESFALG()
-{
-  if (packetUBXESFALG == NULL) return; // Bail if RAM has not been allocated (otherwise we could be writing anywhere!)
-  packetUBXESFALG->moduleQueried.moduleQueried.all = 0; //Mark all datums as stale (read before)
-}
-
-//Log this data in file buffer
-void SFE_UBLOX_GNSS::logESFALG(boolean enabled)
-{
-  if (packetUBXESFALG == NULL) return; // Bail if RAM has not been allocated (otherwise we could be writing anywhere!)
-  packetUBXESFALG->automaticFlags.flags.bits.addToFileBuffer = (uint8_t)enabled;
-}
-
-// ***** ESF STATUS automatic support
-
-boolean SFE_UBLOX_GNSS::getEsfInfo(uint16_t maxWait)
-{
-  return (getESFSTATUS(maxWait));
-}
-
-boolean SFE_UBLOX_GNSS::getESFSTATUS(uint16_t maxWait)
-{
-  if (packetUBXESFSTATUS == NULL) initPacketUBXESFSTATUS(); //Check that RAM has been allocated for the ESF status data
-  if (packetUBXESFSTATUS == NULL) //Only attempt this if RAM allocation was successful
-    return false;
-
-  if (packetUBXESFSTATUS->automaticFlags.flags.bits.automatic && packetUBXESFSTATUS->automaticFlags.flags.bits.implicitUpdate)
-  {
-    //The GPS is automatically reporting, we just check whether we got unread data
-    // if (_printDebug == true)
-    // {
-    //   _debugSerial->println(F("getEsfInfo: Autoreporting"));
-    // }
-    checkUbloxInternal(&packetCfg, UBX_CLASS_ESF, UBX_ESF_STATUS);
-    return packetUBXESFSTATUS->moduleQueried.moduleQueried.bits.all;
-  }
-  else if (packetUBXESFSTATUS->automaticFlags.flags.bits.automatic && !packetUBXESFSTATUS->automaticFlags.flags.bits.implicitUpdate)
-  {
-    //Someone else has to call checkUblox for us...
-    // if (_printDebug == true)
-    // {
-    //   _debugSerial->println(F("getEsfInfo: Exit immediately"));
-    // }
-    return (false);
-  }
-  else
-  {
-    // if (_printDebug == true)
-    // {
-    //   _debugSerial->println(F("getEsfInfo: Polling"));
-    // }
-
-    //The GPS is not automatically reporting HNR PVT so we have to poll explicitly
-    packetCfg.cls = UBX_CLASS_ESF;
-    packetCfg.id = UBX_ESF_STATUS;
-    packetCfg.len = 0;
-    packetCfg.startingSpot = 0;
-
-    //The data is parsed as part of processing the response
-    sfe_ublox_status_e retVal = sendCommand(&packetCfg, maxWait);
-
-    if (retVal == SFE_UBLOX_STATUS_DATA_RECEIVED)
-      return (true);
-
-    if (retVal == SFE_UBLOX_STATUS_DATA_OVERWRITTEN)
-    {
-      // if (_printDebug == true)
-      // {
-      //   _debugSerial->println(F("getEsfInfo: data in packetCfg was OVERWRITTEN by another message (but that's OK)"));
-      // }
-      return (true);
-    }
-
-    // if (_printDebug == true)
-    // {
-    //   _debugSerial->print(F("getEsfInfo retVal: "));
-    //   _debugSerial->println(statusString(retVal));
-    // }
-    return (false);
-  }
-
-  return (false); // Trap. We should never get here...
-}
-
-//Enable or disable automatic ESF STATUS message generation by the GNSS. This changes the way getESFInfo
-//works.
-boolean SFE_UBLOX_GNSS::setAutoESFSTATUS(boolean enable, uint16_t maxWait)
-{
-  return setAutoESFSTATUSrate(enable ? 1 : 0, true, maxWait);
-}
-
-//Enable or disable automatic ESF STATUS message generation by the GNSS. This changes the way getESFInfo
-//works.
-boolean SFE_UBLOX_GNSS::setAutoESFSTATUS(boolean enable, boolean implicitUpdate, uint16_t maxWait)
-{
-  return setAutoESFSTATUSrate(enable ? 1 : 0, implicitUpdate, maxWait);
-}
-
-//Enable or disable automatic ESF STATUS message generation by the GNSS. This changes the way getESFInfo
-//works.
-boolean SFE_UBLOX_GNSS::setAutoESFSTATUSrate(uint8_t rate, boolean implicitUpdate, uint16_t maxWait)
-{
-  if (packetUBXESFSTATUS == NULL) initPacketUBXESFSTATUS(); //Check that RAM has been allocated for the data
-  if (packetUBXESFSTATUS == NULL) //Only attempt this if RAM allocation was successful
-    return false;
-
-  if (rate > 127) rate = 127;
-
-  packetCfg.cls = UBX_CLASS_CFG;
-  packetCfg.id = UBX_CFG_MSG;
-  packetCfg.len = 3;
-  packetCfg.startingSpot = 0;
-  payloadCfg[0] = UBX_CLASS_ESF;
-  payloadCfg[1] = UBX_ESF_STATUS;
-  payloadCfg[2] = rate; // rate relative to navigation freq.
-
-  boolean ok = ((sendCommand(&packetCfg, maxWait)) == SFE_UBLOX_STATUS_DATA_SENT); // We are only expecting an ACK
-  if (ok)
-  {
-    packetUBXESFSTATUS->automaticFlags.flags.bits.automatic = (rate > 0);
-    packetUBXESFSTATUS->automaticFlags.flags.bits.implicitUpdate = implicitUpdate;
-  }
-  packetUBXESFSTATUS->moduleQueried.moduleQueried.bits.all = false; // Mark data as stale
-  return ok;
-}
-
-//Enable automatic navigation message generation by the GNSS.
-boolean SFE_UBLOX_GNSS::setAutoESFSTATUScallback(void (*callbackPointer)(UBX_ESF_STATUS_data_t), uint16_t maxWait)
-{
-  // Enable auto messages. Set implicitUpdate to false as we expect the user to call checkUblox manually.
-  boolean result = setAutoESFSTATUS(true, false, maxWait);
-  if (!result)
-    return (result); // Bail if setAuto failed
-
-  if (packetUBXESFSTATUS->callbackData == NULL) //Check if RAM has been allocated for the callback copy
-  {
-    packetUBXESFSTATUS->callbackData = new UBX_ESF_STATUS_data_t; //Allocate RAM for the main struct
-  }
-
-  if (packetUBXESFSTATUS->callbackData == NULL)
-  {
-    if ((_printDebug == true) || (_printLimitedDebug == true)) // This is important. Print this if doing limited debugging
-      _debugSerial->println(F("setAutoESFSTATUScallback: PANIC! RAM allocation failed!"));
-    return (false);
-  }
-
-  packetUBXESFSTATUS->callbackPointer = callbackPointer;
-  return (true);
-}
-
-//In case no config access to the GNSS is possible and ESF STATUS is send cyclically already
-//set config to suitable parameters
-boolean SFE_UBLOX_GNSS::assumeAutoESFSTATUS(boolean enabled, boolean implicitUpdate)
-{
-  if (packetUBXESFSTATUS == NULL) initPacketUBXESFSTATUS(); //Check that RAM has been allocated for the ESF status data
-  if (packetUBXESFSTATUS == NULL) //Only attempt this if RAM allocation was successful
-    return false;
-
-  boolean changes = packetUBXESFSTATUS->automaticFlags.flags.bits.automatic != enabled || packetUBXESFSTATUS->automaticFlags.flags.bits.implicitUpdate != implicitUpdate;
-  if (changes)
-  {
-    packetUBXESFSTATUS->automaticFlags.flags.bits.automatic = enabled;
-    packetUBXESFSTATUS->automaticFlags.flags.bits.implicitUpdate = implicitUpdate;
-  }
-  return changes;
-}
-
-// PRIVATE: Allocate RAM for packetUBXESFSTATUS and initialize it
-boolean SFE_UBLOX_GNSS::initPacketUBXESFSTATUS()
-{
-  packetUBXESFSTATUS = new UBX_ESF_STATUS_t; //Allocate RAM for the main struct
-
-  if (packetUBXESFSTATUS == NULL)
-  {
-    if ((_printDebug == true) || (_printLimitedDebug == true)) // This is important. Print this if doing limited debugging
-      _debugSerial->println(F("initPacketUBXESFSTATUS: PANIC! RAM allocation failed!"));
-    return (false);
-  }
-  packetUBXESFSTATUS->automaticFlags.flags.all = 0;
-  packetUBXESFSTATUS->callbackPointer = NULL;
-  packetUBXESFSTATUS->callbackData = NULL;
-  packetUBXESFSTATUS->moduleQueried.moduleQueried.all = 0;
-  return (true);
-}
-
-//Mark all the data as read/stale
-void SFE_UBLOX_GNSS::flushESFSTATUS()
-{
-  if (packetUBXESFSTATUS == NULL) return; // Bail if RAM has not been allocated (otherwise we could be writing anywhere!)
-  packetUBXESFSTATUS->moduleQueried.moduleQueried.all = 0; //Mark all datums as stale (read before)
-}
-
-//Log this data in file buffer
-void SFE_UBLOX_GNSS::logESFSTATUS(boolean enabled)
-{
-  if (packetUBXESFSTATUS == NULL) return; // Bail if RAM has not been allocated (otherwise we could be writing anywhere!)
-  packetUBXESFSTATUS->automaticFlags.flags.bits.addToFileBuffer = (uint8_t)enabled;
-}
-
-// ***** ESF INS automatic support
-
-boolean SFE_UBLOX_GNSS::getEsfIns(uint16_t maxWait)
-{
-  return (getESFINS(maxWait));
-}
-
-boolean SFE_UBLOX_GNSS::getESFINS(uint16_t maxWait)
-{
-  if (packetUBXESFINS == NULL) initPacketUBXESFINS(); //Check that RAM has been allocated for the ESF INS data
-  if (packetUBXESFINS == NULL) //Only attempt this if RAM allocation was successful
-    return false;
-
-  if (packetUBXESFINS->automaticFlags.flags.bits.automatic && packetUBXESFINS->automaticFlags.flags.bits.implicitUpdate)
-  {
-    //The GPS is automatically reporting, we just check whether we got unread data
-    // if (_printDebug == true)
-    // {
-    //   _debugSerial->println(F("getEsfIns: Autoreporting"));
-    // }
-    checkUbloxInternal(&packetCfg, UBX_CLASS_ESF, UBX_ESF_INS);
-    return packetUBXESFINS->moduleQueried.moduleQueried.bits.all;
-  }
-  else if (packetUBXESFINS->automaticFlags.flags.bits.automatic && !packetUBXESFINS->automaticFlags.flags.bits.implicitUpdate)
-  {
-    //Someone else has to call checkUblox for us...
-    // if (_printDebug == true)
-    // {
-    //   _debugSerial->println(F("getEsfIns: Exit immediately"));
-    // }
-    return (false);
-  }
-  else
-  {
-    // if (_printDebug == true)
-    // {
-    //   _debugSerial->println(F("getEsfIns: Polling"));
-    // }
-
-    //The GPS is not automatically reporting HNR PVT so we have to poll explicitly
-    packetCfg.cls = UBX_CLASS_ESF;
-    packetCfg.id = UBX_ESF_INS;
-    packetCfg.len = 0;
-    packetCfg.startingSpot = 0;
-
-    //The data is parsed as part of processing the response
-    sfe_ublox_status_e retVal = sendCommand(&packetCfg, maxWait);
-
-    if (retVal == SFE_UBLOX_STATUS_DATA_RECEIVED)
-      return (true);
-
-    if (retVal == SFE_UBLOX_STATUS_DATA_OVERWRITTEN)
-    {
-      // if (_printDebug == true)
-      // {
-      //   _debugSerial->println(F("getEsfIns: data in packetCfg was OVERWRITTEN by another message (but that's OK)"));
-      // }
-      return (true);
-    }
-
-    // if (_printDebug == true)
-    // {
-    //   _debugSerial->print(F("getEsfIns retVal: "));
-    //   _debugSerial->println(statusString(retVal));
-    // }
-    return (false);
-  }
-
-  return (false); // Trap. We should never get here...
-}
-
-//Enable or disable automatic ESF INS message generation by the GNSS. This changes the way getESFIns
-//works.
-boolean SFE_UBLOX_GNSS::setAutoESFINS(boolean enable, uint16_t maxWait)
-{
-  return setAutoESFINSrate(enable ? 1 : 0, true, maxWait);
-}
-
-//Enable or disable automatic ESF INS message generation by the GNSS. This changes the way getESFIns
-//works.
-boolean SFE_UBLOX_GNSS::setAutoESFINS(boolean enable, boolean implicitUpdate, uint16_t maxWait)
-{
-  return setAutoESFINSrate(enable ? 1 : 0, implicitUpdate, maxWait);
-}
-
-//Enable or disable automatic ESF INS message generation by the GNSS. This changes the way getESFIns
-//works.
-boolean SFE_UBLOX_GNSS::setAutoESFINSrate(uint8_t rate, boolean implicitUpdate, uint16_t maxWait)
-{
-  if (packetUBXESFINS == NULL) initPacketUBXESFINS(); //Check that RAM has been allocated for the data
-  if (packetUBXESFINS == NULL) //Only attempt this if RAM allocation was successful
-    return false;
-
-  if (rate > 127) rate = 127;
-
-  packetCfg.cls = UBX_CLASS_CFG;
-  packetCfg.id = UBX_CFG_MSG;
-  packetCfg.len = 3;
-  packetCfg.startingSpot = 0;
-  payloadCfg[0] = UBX_CLASS_ESF;
-  payloadCfg[1] = UBX_ESF_INS;
-  payloadCfg[2] = rate; // rate relative to navigation freq.
-
-  boolean ok = ((sendCommand(&packetCfg, maxWait)) == SFE_UBLOX_STATUS_DATA_SENT); // We are only expecting an ACK
-  if (ok)
-  {
-    packetUBXESFINS->automaticFlags.flags.bits.automatic = (rate > 0);
-    packetUBXESFINS->automaticFlags.flags.bits.implicitUpdate = implicitUpdate;
-  }
-  packetUBXESFINS->moduleQueried.moduleQueried.bits.all = false; // Mark data as stale
-  return ok;
-}
-
-//Enable automatic navigation message generation by the GNSS.
-boolean SFE_UBLOX_GNSS::setAutoESFINScallback(void (*callbackPointer)(UBX_ESF_INS_data_t), uint16_t maxWait)
-{
-  // Enable auto messages. Set implicitUpdate to false as we expect the user to call checkUblox manually.
-  boolean result = setAutoESFINS(true, false, maxWait);
-  if (!result)
-    return (result); // Bail if setAuto failed
-
-  if (packetUBXESFINS->callbackData == NULL) //Check if RAM has been allocated for the callback copy
-  {
-    packetUBXESFINS->callbackData = new UBX_ESF_INS_data_t; //Allocate RAM for the main struct
-  }
-
-  if (packetUBXESFINS->callbackData == NULL)
-  {
-    if ((_printDebug == true) || (_printLimitedDebug == true)) // This is important. Print this if doing limited debugging
-      _debugSerial->println(F("setAutoESFINScallback: PANIC! RAM allocation failed!"));
-    return (false);
-  }
-
-  packetUBXESFINS->callbackPointer = callbackPointer;
-  return (true);
-}
-
-//In case no config access to the GNSS is possible and ESF INS is send cyclically already
-//set config to suitable parameters
-boolean SFE_UBLOX_GNSS::assumeAutoESFINS(boolean enabled, boolean implicitUpdate)
-{
-  if (packetUBXESFINS == NULL) initPacketUBXESFINS(); //Check that RAM has been allocated for the ESF INS data
-  if (packetUBXESFINS == NULL) //Only attempt this if RAM allocation was successful
-    return false;
-
-  boolean changes = packetUBXESFINS->automaticFlags.flags.bits.automatic != enabled || packetUBXESFINS->automaticFlags.flags.bits.implicitUpdate != implicitUpdate;
-  if (changes)
-  {
-    packetUBXESFINS->automaticFlags.flags.bits.automatic = enabled;
-    packetUBXESFINS->automaticFlags.flags.bits.implicitUpdate = implicitUpdate;
-  }
-  return changes;
-}
-
-// PRIVATE: Allocate RAM for packetUBXESFINS and initialize it
-boolean SFE_UBLOX_GNSS::initPacketUBXESFINS()
-{
-  packetUBXESFINS = new UBX_ESF_INS_t; //Allocate RAM for the main struct
-  if (packetUBXESFINS == NULL)
-  {
-    if ((_printDebug == true) || (_printLimitedDebug == true)) // This is important. Print this if doing limited debugging
-      _debugSerial->println(F("initPacketUBXESFINS: PANIC! RAM allocation failed!"));
-    return (false);
-  }
-  packetUBXESFINS->automaticFlags.flags.all = 0;
-  packetUBXESFINS->callbackPointer = NULL;
-  packetUBXESFINS->callbackData = NULL;
-  packetUBXESFINS->moduleQueried.moduleQueried.all = 0;
-  return (true);
-}
-
-//Mark all the data as read/stale
-void SFE_UBLOX_GNSS::flushESFINS()
-{
-  if (packetUBXESFINS == NULL) return; // Bail if RAM has not been allocated (otherwise we could be writing anywhere!)
-  packetUBXESFINS->moduleQueried.moduleQueried.all = 0; //Mark all datums as stale (read before)
-}
-
-//Log this data in file buffer
-void SFE_UBLOX_GNSS::logESFINS(boolean enabled)
-{
-  if (packetUBXESFINS == NULL) return; // Bail if RAM has not been allocated (otherwise we could be writing anywhere!)
-  packetUBXESFINS->automaticFlags.flags.bits.addToFileBuffer = (uint8_t)enabled;
-}
-
-// ***** ESF MEAS automatic support
-
-boolean SFE_UBLOX_GNSS::getEsfDataInfo(uint16_t maxWait)
-{
-  return (getESFMEAS(maxWait));
-}
-
-boolean SFE_UBLOX_GNSS::getESFMEAS(uint16_t maxWait)
-{
-  if (packetUBXESFMEAS == NULL) initPacketUBXESFMEAS(); //Check that RAM has been allocated for the ESF MEAS data
-  if (packetUBXESFMEAS == NULL) //Only attempt this if RAM allocation was successful
-    return false;
-
-  if (packetUBXESFMEAS->automaticFlags.flags.bits.automatic && packetUBXESFMEAS->automaticFlags.flags.bits.implicitUpdate)
-  {
-    //The GPS is automatically reporting, we just check whether we got unread data
-    // if (_printDebug == true)
-    // {
-    //   _debugSerial->println(F("getEsfDataInfo: Autoreporting"));
-    // }
-    checkUbloxInternal(&packetCfg, UBX_CLASS_ESF, UBX_ESF_MEAS);
-    return packetUBXESFMEAS->moduleQueried.moduleQueried.bits.all;
-  }
-  else if (packetUBXESFMEAS->automaticFlags.flags.bits.automatic && !packetUBXESFMEAS->automaticFlags.flags.bits.implicitUpdate)
-  {
-    //Someone else has to call checkUblox for us...
-    // if (_printDebug == true)
-    // {
-    //   _debugSerial->println(F("getEsfDataInfo: Exit immediately"));
-    // }
-    return (false);
-  }
-  else
-  {
-    // if (_printDebug == true)
-    // {
-    //   _debugSerial->println(F("getEsfDataInfo: Polling"));
-    // }
-
-    //The GPS is not automatically reporting HNR PVT so we have to poll explicitly
-    packetCfg.cls = UBX_CLASS_ESF;
-    packetCfg.id = UBX_ESF_MEAS;
-    packetCfg.len = 0;
-    packetCfg.startingSpot = 0;
-
-    //The data is parsed as part of processing the response
-    sfe_ublox_status_e retVal = sendCommand(&packetCfg, maxWait);
-
-    if (retVal == SFE_UBLOX_STATUS_DATA_RECEIVED)
-      return (true);
-
-    if (retVal == SFE_UBLOX_STATUS_DATA_OVERWRITTEN)
-    {
-      // if (_printDebug == true)
-      // {
-      //   _debugSerial->println(F("getEsfDataInfo: data in packetCfg was OVERWRITTEN by another message (but that's OK)"));
-      // }
-      return (true);
-    }
-
-    // if (_printDebug == true)
-    // {
-    //   _debugSerial->print(F("getEsfDataInfo retVal: "));
-    //   _debugSerial->println(statusString(retVal));
-    // }
-    return (false);
-  }
-
-  return (false); // Trap. We should never get here...
-}
-
-//Enable or disable automatic ESF MEAS message generation by the GNSS. This changes the way getESFDataInfo
-//works.
-boolean SFE_UBLOX_GNSS::setAutoESFMEAS(boolean enable, uint16_t maxWait)
-{
-  return setAutoESFMEASrate(enable ? 1 : 0, true, maxWait);
-}
-
-//Enable or disable automatic ESF MEAS message generation by the GNSS. This changes the way getESFDataInfo
-//works.
-boolean SFE_UBLOX_GNSS::setAutoESFMEAS(boolean enable, boolean implicitUpdate, uint16_t maxWait)
-{
-  return setAutoESFMEASrate(enable ? 1 : 0, implicitUpdate, maxWait);
-}
-
-//Enable or disable automatic ESF MEAS message generation by the GNSS. This changes the way getESFDataInfo
-//works.
-boolean SFE_UBLOX_GNSS::setAutoESFMEASrate(uint8_t rate, boolean implicitUpdate, uint16_t maxWait)
-{
-  if (packetUBXESFMEAS == NULL) initPacketUBXESFMEAS(); //Check that RAM has been allocated for the data
-  if (packetUBXESFMEAS == NULL) //Only attempt this if RAM allocation was successful
-    return false;
-
-  if (rate > 127) rate = 127;
-
-  packetCfg.cls = UBX_CLASS_CFG;
-  packetCfg.id = UBX_CFG_MSG;
-  packetCfg.len = 3;
-  packetCfg.startingSpot = 0;
-  payloadCfg[0] = UBX_CLASS_ESF;
-  payloadCfg[1] = UBX_ESF_MEAS;
-  payloadCfg[2] = rate; // rate relative to navigation freq.
-
-  boolean ok = ((sendCommand(&packetCfg, maxWait)) == SFE_UBLOX_STATUS_DATA_SENT); // We are only expecting an ACK
-  if (ok)
-  {
-    packetUBXESFMEAS->automaticFlags.flags.bits.automatic = (rate > 0);
-    packetUBXESFMEAS->automaticFlags.flags.bits.implicitUpdate = implicitUpdate;
-  }
-  packetUBXESFMEAS->moduleQueried.moduleQueried.bits.all = false; // Mark data as stale
-  return ok;
-}
-
-//Enable automatic navigation message generation by the GNSS.
-boolean SFE_UBLOX_GNSS::setAutoESFMEAScallback(void (*callbackPointer)(UBX_ESF_MEAS_data_t), uint16_t maxWait)
-{
-  // Enable auto messages. Set implicitUpdate to false as we expect the user to call checkUblox manually.
-  boolean result = setAutoESFMEAS(true, false, maxWait);
-  if (!result)
-    return (result); // Bail if setAuto failed
-
-  if (packetUBXESFMEAS->callbackData == NULL) //Check if RAM has been allocated for the callback copy
-  {
-    packetUBXESFMEAS->callbackData = new UBX_ESF_MEAS_data_t; //Allocate RAM for the main struct
-  }
-
-  if (packetUBXESFMEAS->callbackData == NULL)
-  {
-    if ((_printDebug == true) || (_printLimitedDebug == true)) // This is important. Print this if doing limited debugging
-      _debugSerial->println(F("setAutoESFMEAScallback: PANIC! RAM allocation failed!"));
-    return (false);
-  }
-
-  packetUBXESFMEAS->callbackPointer = callbackPointer;
-  return (true);
-}
-
-//In case no config access to the GNSS is possible and ESF MEAS is send cyclically already
-//set config to suitable parameters
-boolean SFE_UBLOX_GNSS::assumeAutoESFMEAS(boolean enabled, boolean implicitUpdate)
-{
-  if (packetUBXESFMEAS == NULL) initPacketUBXESFMEAS(); //Check that RAM has been allocated for the ESF MEAS data
-  if (packetUBXESFMEAS == NULL) //Only attempt this if RAM allocation was successful
-    return false;
-
-  boolean changes = packetUBXESFMEAS->automaticFlags.flags.bits.automatic != enabled || packetUBXESFMEAS->automaticFlags.flags.bits.implicitUpdate != implicitUpdate;
-  if (changes)
-  {
-    packetUBXESFMEAS->automaticFlags.flags.bits.automatic = enabled;
-    packetUBXESFMEAS->automaticFlags.flags.bits.implicitUpdate = implicitUpdate;
-  }
-  return changes;
-}
-
-// PRIVATE: Allocate RAM for packetUBXESFMEAS and initialize it
-boolean SFE_UBLOX_GNSS::initPacketUBXESFMEAS()
-{
-  packetUBXESFMEAS = new UBX_ESF_MEAS_t; //Allocate RAM for the main struct
-  if (packetUBXESFMEAS == NULL)
-  {
-    if ((_printDebug == true) || (_printLimitedDebug == true)) // This is important. Print this if doing limited debugging
-      _debugSerial->println(F("initPacketUBXESFMEAS: PANIC! RAM allocation failed!"));
-    return (false);
-  }
-  packetUBXESFMEAS->automaticFlags.flags.all = 0;
-  packetUBXESFMEAS->callbackPointer = NULL;
-  packetUBXESFMEAS->callbackData = NULL;
-  packetUBXESFMEAS->moduleQueried.moduleQueried.all = 0;
-  return (true);
-}
-
-//Mark all the data as read/stale
-void SFE_UBLOX_GNSS::flushESFMEAS()
-{
-  if (packetUBXESFMEAS == NULL) return; // Bail if RAM has not been allocated (otherwise we could be writing anywhere!)
-  packetUBXESFMEAS->moduleQueried.moduleQueried.all = 0; //Mark all datums as stale (read before)
-}
-
-//Log this data in file buffer
-void SFE_UBLOX_GNSS::logESFMEAS(boolean enabled)
-{
-  if (packetUBXESFMEAS == NULL) return; // Bail if RAM has not been allocated (otherwise we could be writing anywhere!)
-  packetUBXESFMEAS->automaticFlags.flags.bits.addToFileBuffer = (uint8_t)enabled;
-}
-
-// ***** ESF RAW automatic support
-
-boolean SFE_UBLOX_GNSS::getEsfRawDataInfo(uint16_t maxWait)
-{
-  return (getESFRAW(maxWait));
-}
-
-boolean SFE_UBLOX_GNSS::getESFRAW(uint16_t maxWait)
-{
-  if (packetUBXESFRAW == NULL) initPacketUBXESFRAW(); //Check that RAM has been allocated for the ESF RAW data
-  if (packetUBXESFRAW == NULL) //Only attempt this if RAM allocation was successful
-    return false;
-
-  if (packetUBXESFRAW->automaticFlags.flags.bits.automatic && packetUBXESFRAW->automaticFlags.flags.bits.implicitUpdate)
-  {
-    //The GPS is automatically reporting, we just check whether we got unread data
-    // if (_printDebug == true)
-    // {
-    //   _debugSerial->println(F("getEsfRawDataInfo: Autoreporting"));
-    // }
-    checkUbloxInternal(&packetCfg, UBX_CLASS_ESF, UBX_ESF_RAW);
-    return packetUBXESFRAW->moduleQueried.moduleQueried.bits.all;
-  }
-  else if (packetUBXESFRAW->automaticFlags.flags.bits.automatic && !packetUBXESFRAW->automaticFlags.flags.bits.implicitUpdate)
-  {
-    //Someone else has to call checkUblox for us...
-    // if (_printDebug == true)
-    // {
-    //   _debugSerial->println(F("getEsfRawDataInfo: Exit immediately"));
-    // }
-    return (false);
-  }
-  else
-  {
-    // if (_printDebug == true)
-    // {
-    //   _debugSerial->println(F("getEsfRawDataInfo: Polling"));
-    // }
-
-    //The GPS is not automatically reporting HNR PVT so we have to poll explicitly
-    packetCfg.cls = UBX_CLASS_ESF;
-    packetCfg.id = UBX_ESF_RAW;
-    packetCfg.len = 0;
-    packetCfg.startingSpot = 0;
-
-    //The data is parsed as part of processing the response
-    sfe_ublox_status_e retVal = sendCommand(&packetCfg, maxWait);
-
-    if (retVal == SFE_UBLOX_STATUS_DATA_RECEIVED)
-      return (true);
-
-    if (retVal == SFE_UBLOX_STATUS_DATA_OVERWRITTEN)
-    {
-      // if (_printDebug == true)
-      // {
-      //   _debugSerial->println(F("getEsfRawDataInfo: data in packetCfg was OVERWRITTEN by another message (but that's OK)"));
-      // }
-      return (true);
-    }
-
-    // if (_printDebug == true)
-    // {
-    //   _debugSerial->print(F("getEsfRawDataInfo retVal: "));
-    //   _debugSerial->println(statusString(retVal));
-    // }
-    return (false);
-  }
-
-  return (false); // Trap. We should never get here...
-}
-
-//Enable or disable automatic ESF RAW message generation by the GNSS. This changes the way getESFRawDataInfo
-//works.
-boolean SFE_UBLOX_GNSS::setAutoESFRAW(boolean enable, uint16_t maxWait)
-{
-  return setAutoESFRAWrate(enable ? 1 : 0, true, maxWait);
-}
-
-//Enable or disable automatic ESF RAW message generation by the GNSS. This changes the way getESFRawDataInfo
-//works.
-boolean SFE_UBLOX_GNSS::setAutoESFRAW(boolean enable, boolean implicitUpdate, uint16_t maxWait)
-{
-  return setAutoESFRAWrate(enable ? 1 : 0, implicitUpdate, maxWait);
-}
-
-//Enable or disable automatic ESF RAW message generation by the GNSS. This changes the way getESFRawDataInfo
-//works.
-boolean SFE_UBLOX_GNSS::setAutoESFRAWrate(uint8_t rate, boolean implicitUpdate, uint16_t maxWait)
-{
-  if (packetUBXESFRAW == NULL) initPacketUBXESFRAW(); //Check that RAM has been allocated for the data
-  if (packetUBXESFRAW == NULL) //Only attempt this if RAM allocation was successful
-    return false;
-
-  if (rate > 127) rate = 127;
-
-  packetCfg.cls = UBX_CLASS_CFG;
-  packetCfg.id = UBX_CFG_MSG;
-  packetCfg.len = 3;
-  packetCfg.startingSpot = 0;
-  payloadCfg[0] = UBX_CLASS_ESF;
-  payloadCfg[1] = UBX_ESF_RAW;
-  payloadCfg[2] = rate; // rate relative to navigation freq.
-
-  boolean ok = ((sendCommand(&packetCfg, maxWait)) == SFE_UBLOX_STATUS_DATA_SENT); // We are only expecting an ACK
-  if (ok)
-  {
-    packetUBXESFRAW->automaticFlags.flags.bits.automatic = (rate > 0);
-    packetUBXESFRAW->automaticFlags.flags.bits.implicitUpdate = implicitUpdate;
-  }
-  packetUBXESFRAW->moduleQueried.moduleQueried.bits.all = false; // Mark data as stale
-  return ok;
-}
-
-//Enable automatic navigation message generation by the GNSS.
-boolean SFE_UBLOX_GNSS::setAutoESFRAWcallback(void (*callbackPointer)(UBX_ESF_RAW_data_t), uint16_t maxWait)
-{
-  // Enable auto messages. Set implicitUpdate to false as we expect the user to call checkUblox manually.
-  boolean result = setAutoESFRAW(true, false, maxWait);
-  if (!result)
-    return (result); // Bail if setAuto failed
-
-  if (packetUBXESFRAW->callbackData == NULL) //Check if RAM has been allocated for the callback copy
-  {
-    packetUBXESFRAW->callbackData = new UBX_ESF_RAW_data_t; //Allocate RAM for the main struct
-  }
-
-  if (packetUBXESFRAW->callbackData == NULL)
-  {
-    if ((_printDebug == true) || (_printLimitedDebug == true)) // This is important. Print this if doing limited debugging
-      _debugSerial->println(F("setAutoESFRAWcallback: PANIC! RAM allocation failed!"));
-    return (false);
-  }
-
-  packetUBXESFRAW->callbackPointer = callbackPointer;
-  return (true);
-}
-
-//In case no config access to the GNSS is possible and ESF RAW is send cyclically already
-//set config to suitable parameters
-boolean SFE_UBLOX_GNSS::assumeAutoESFRAW(boolean enabled, boolean implicitUpdate)
-{
-  if (packetUBXESFRAW == NULL) initPacketUBXESFRAW(); //Check that RAM has been allocated for the ESF RAW data
-  if (packetUBXESFRAW == NULL) //Only attempt this if RAM allocation was successful
-    return false;
-
-  boolean changes = packetUBXESFRAW->automaticFlags.flags.bits.automatic != enabled || packetUBXESFRAW->automaticFlags.flags.bits.implicitUpdate != implicitUpdate;
-  if (changes)
-  {
-    packetUBXESFRAW->automaticFlags.flags.bits.automatic = enabled;
-    packetUBXESFRAW->automaticFlags.flags.bits.implicitUpdate = implicitUpdate;
-  }
-  return changes;
-}
-
-// PRIVATE: Allocate RAM for packetUBXESFRAW and initialize it
-boolean SFE_UBLOX_GNSS::initPacketUBXESFRAW()
-{
-  packetUBXESFRAW = new UBX_ESF_RAW_t; //Allocate RAM for the main struct
-  if (packetUBXESFRAW == NULL)
-  {
-    if ((_printDebug == true) || (_printLimitedDebug == true)) // This is important. Print this if doing limited debugging
-      _debugSerial->println(F("initPacketUBXESFRAW: PANIC! RAM allocation failed!"));
-    return (false);
-  }
-  packetUBXESFRAW->automaticFlags.flags.all = 0;
-  packetUBXESFRAW->callbackPointer = NULL;
-  packetUBXESFRAW->callbackData = NULL;
-  packetUBXESFRAW->moduleQueried.moduleQueried.all = 0;
-  return (true);
-}
-
-//Mark all the data as read/stale
-void SFE_UBLOX_GNSS::flushESFRAW()
-{
-  if (packetUBXESFRAW == NULL) return; // Bail if RAM has not been allocated (otherwise we could be writing anywhere!)
-  packetUBXESFRAW->moduleQueried.moduleQueried.all = 0; //Mark all datums as stale (read before)
-}
-
-//Log this data in file buffer
-void SFE_UBLOX_GNSS::logESFRAW(boolean enabled)
-{
-  if (packetUBXESFRAW == NULL) return; // Bail if RAM has not been allocated (otherwise we could be writing anywhere!)
-  packetUBXESFRAW->automaticFlags.flags.bits.addToFileBuffer = (uint8_t)enabled;
-}
-
-// ***** HNR ATT automatic support
-
-boolean SFE_UBLOX_GNSS::getHNRAtt(uint16_t maxWait)
-{
-  return (getHNRATT(maxWait));
-}
-
-//Get the HNR Attitude data
-// Returns true if the get HNR attitude is successful. Data is returned in hnrAtt
-// Note: if hnrAttQueried is true, it gets set to false by this function since we assume
-//       that the user will read hnrAtt immediately after this. I.e. this function will
-//       only return true _once_ after each auto HNR Att is processed
-boolean SFE_UBLOX_GNSS::getHNRATT(uint16_t maxWait)
-{
-  if (packetUBXHNRATT == NULL) initPacketUBXHNRATT(); //Check that RAM has been allocated for the data
-  if (packetUBXHNRATT == NULL) //Bail if the RAM allocation failed
-    return (false);
-
-  if (packetUBXHNRATT->automaticFlags.flags.bits.automatic && packetUBXHNRATT->automaticFlags.flags.bits.implicitUpdate)
-  {
-    //The GPS is automatically reporting, we just check whether we got unread data
-    // if (_printDebug == true)
-    // {
-    //   _debugSerial->println(F("getHNRAtt: Autoreporting"));
-    // }
-    checkUbloxInternal(&packetCfg, UBX_CLASS_HNR, UBX_HNR_ATT);
-    return packetUBXHNRATT->moduleQueried.moduleQueried.bits.all;
-  }
-  else if (packetUBXHNRATT->automaticFlags.flags.bits.automatic && !packetUBXHNRATT->automaticFlags.flags.bits.implicitUpdate)
-  {
-    //Someone else has to call checkUblox for us...
-    // if (_printDebug == true)
-    // {
-    //   _debugSerial->println(F("getHNRAtt: Exit immediately"));
-    // }
-    return (false);
-  }
-  else
-  {
-    // if (_printDebug == true)
-    // {
-    //   _debugSerial->println(F("getHNRAtt: Polling"));
-    // }
-
-    //The GPS is not automatically reporting HNR attitude so we have to poll explicitly
-    packetCfg.cls = UBX_CLASS_HNR;
-    packetCfg.id = UBX_HNR_ATT;
-    packetCfg.len = 0;
-    packetCfg.startingSpot = 0;
-
-    //The data is parsed as part of processing the response
-    sfe_ublox_status_e retVal = sendCommand(&packetCfg, maxWait);
-
-    if (retVal == SFE_UBLOX_STATUS_DATA_RECEIVED)
-      return (true);
-
-    if (retVal == SFE_UBLOX_STATUS_DATA_OVERWRITTEN)
-    {
-      // if (_printDebug == true)
-      // {
-      //   _debugSerial->println(F("getHNRAtt: data in packetCfg was OVERWRITTEN by another message (but that's OK)"));
-      // }
-      return (true);
-    }
-
-    // if (_printDebug == true)
-    // {
-    //   _debugSerial->print(F("getHNRAtt retVal: "));
-    //   _debugSerial->println(statusString(retVal));
-    // }
-    return (false);
-  }
-
-  return (false); // Trap. We should never get here...
-}
-
-//Enable or disable automatic HNR attitude message generation by the GNSS. This changes the way getHNRAtt
-//works.
-boolean SFE_UBLOX_GNSS::setAutoHNRATT(boolean enable, uint16_t maxWait)
-{
-  return setAutoHNRATTrate(enable ? 1 : 0, true, maxWait);
-}
-
-//Enable or disable automatic HNR attitude message generation by the GNSS. This changes the way getHNRAtt
-//works.
-boolean SFE_UBLOX_GNSS::setAutoHNRATT(boolean enable, boolean implicitUpdate, uint16_t maxWait)
-{
-  return setAutoHNRATTrate(enable ? 1 : 0, implicitUpdate, maxWait);
-}
-
-//Enable or disable automatic HNR attitude message generation by the GNSS. This changes the way getHNRAtt
-//works.
-boolean SFE_UBLOX_GNSS::setAutoHNRATTrate(uint8_t rate, boolean implicitUpdate, uint16_t maxWait)
-{
-  if (packetUBXHNRATT == NULL) initPacketUBXHNRATT(); //Check that RAM has been allocated for the data
-  if (packetUBXHNRATT == NULL) //Only attempt this if RAM allocation was successful
-    return false;
-
-  if (rate > 127) rate = 127;
-
-  packetCfg.cls = UBX_CLASS_CFG;
-  packetCfg.id = UBX_CFG_MSG;
-  packetCfg.len = 3;
-  packetCfg.startingSpot = 0;
-  payloadCfg[0] = UBX_CLASS_HNR;
-  payloadCfg[1] = UBX_HNR_ATT;
-  payloadCfg[2] = rate; // rate relative to navigation freq.
-
-  boolean ok = ((sendCommand(&packetCfg, maxWait)) == SFE_UBLOX_STATUS_DATA_SENT); // We are only expecting an ACK
-  if (ok)
-  {
-    packetUBXHNRATT->automaticFlags.flags.bits.automatic = (rate > 0);
-    packetUBXHNRATT->automaticFlags.flags.bits.implicitUpdate = implicitUpdate;
-  }
-  packetUBXHNRATT->moduleQueried.moduleQueried.bits.all = false; // Mark data as stale
-  return ok;
-}
-
-//Enable automatic navigation message generation by the GNSS.
-boolean SFE_UBLOX_GNSS::setAutoHNRATTcallback(void (*callbackPointer)(UBX_HNR_ATT_data_t), uint16_t maxWait)
-{
-  // Enable auto messages. Set implicitUpdate to false as we expect the user to call checkUblox manually.
-  boolean result = setAutoHNRATT(true, false, maxWait);
-  if (!result)
-    return (result); // Bail if setAuto failed
-
-  if (packetUBXHNRATT->callbackData == NULL) //Check if RAM has been allocated for the callback copy
-  {
-    packetUBXHNRATT->callbackData = new UBX_HNR_ATT_data_t; //Allocate RAM for the main struct
-  }
-
-  if (packetUBXHNRATT->callbackData == NULL)
-  {
-    if ((_printDebug == true) || (_printLimitedDebug == true)) // This is important. Print this if doing limited debugging
-      _debugSerial->println(F("setAutoHNRAttcallback: PANIC! RAM allocation failed!"));
-    return (false);
-  }
-
-  packetUBXHNRATT->callbackPointer = callbackPointer;
-  return (true);
-}
-
-//In case no config access to the GNSS is possible and HNR attitude is send cyclically already
-//set config to suitable parameters
-boolean SFE_UBLOX_GNSS::assumeAutoHNRATT(boolean enabled, boolean implicitUpdate)
-{
-  if (packetUBXHNRATT == NULL) initPacketUBXHNRATT(); //Check that RAM has been allocated for the data
-  if (packetUBXHNRATT == NULL) //Bail if the RAM allocation failed
-    return (false);
-
-  boolean changes = packetUBXHNRATT->automaticFlags.flags.bits.automatic != enabled || packetUBXHNRATT->automaticFlags.flags.bits.implicitUpdate != implicitUpdate;
-  if (changes)
-  {
-    packetUBXHNRATT->automaticFlags.flags.bits.automatic = enabled;
-    packetUBXHNRATT->automaticFlags.flags.bits.implicitUpdate = implicitUpdate;
-  }
-  return changes;
-}
-
-// PRIVATE: Allocate RAM for packetUBXHNRATT and initialize it
-boolean SFE_UBLOX_GNSS::initPacketUBXHNRATT()
-{
-  packetUBXHNRATT = new UBX_HNR_ATT_t; //Allocate RAM for the main struct
-  if (packetUBXHNRATT == NULL)
-  {
-    if ((_printDebug == true) || (_printLimitedDebug == true)) // This is important. Print this if doing limited debugging
-      _debugSerial->println(F("initPacketUBXHNRATT: PANIC! RAM allocation failed!"));
-    return (false);
-  }
-  packetUBXHNRATT->automaticFlags.flags.all = 0;
-  packetUBXHNRATT->callbackPointer = NULL;
-  packetUBXHNRATT->callbackData = NULL;
-  packetUBXHNRATT->moduleQueried.moduleQueried.all = 0;
-  return (true);
-}
-
-//Mark all the data as read/stale
-void SFE_UBLOX_GNSS::flushHNRATT()
-{
-  if (packetUBXHNRATT == NULL) return; // Bail if RAM has not been allocated (otherwise we could be writing anywhere!)
-  packetUBXHNRATT->moduleQueried.moduleQueried.all = 0; //Mark all datums as stale (read before)
-}
-
-
-//Log this data in file buffer
-void SFE_UBLOX_GNSS::logHNRATT(boolean enabled)
-{
-  if (packetUBXHNRATT == NULL) return; // Bail if RAM has not been allocated (otherwise we could be writing anywhere!)
-  packetUBXHNRATT->automaticFlags.flags.bits.addToFileBuffer = (uint8_t)enabled;
-}
-
-// ***** HNR DYN automatic support
-
-boolean SFE_UBLOX_GNSS::getHNRDyn(uint16_t maxWait)
-{
-  return (getHNRINS(maxWait));
-}
-
-//Get the HNR vehicle dynamics data
-// Returns true if the get HNR vehicle dynamics is successful. Data is returned in hnrVehDyn
-// Note: if hnrDynQueried is true, it gets set to false by this function since we assume
-//       that the user will read hnrVehDyn immediately after this. I.e. this function will
-//       only return true _once_ after each auto HNR Dyn is processed
-boolean SFE_UBLOX_GNSS::getHNRINS(uint16_t maxWait)
-{
-  if (packetUBXHNRINS == NULL) initPacketUBXHNRINS(); //Check that RAM has been allocated for the data
-  if (packetUBXHNRINS == NULL) //Bail if the RAM allocation failed
-    return (false);
-
-  if (packetUBXHNRINS->automaticFlags.flags.bits.automatic && packetUBXHNRINS->automaticFlags.flags.bits.implicitUpdate)
-  {
-    //The GPS is automatically reporting, we just check whether we got unread data
-    // if (_printDebug == true)
-    // {
-    //   _debugSerial->println(F("getHNRDyn: Autoreporting"));
-    // }
-    checkUbloxInternal(&packetCfg, UBX_CLASS_HNR, UBX_HNR_INS);
-    return packetUBXHNRINS->moduleQueried.moduleQueried.bits.all;
-  }
-  else if (packetUBXHNRINS->automaticFlags.flags.bits.automatic && !packetUBXHNRINS->automaticFlags.flags.bits.implicitUpdate)
-  {
-    //Someone else has to call checkUblox for us...
-    // if (_printDebug == true)
-    // {
-    //   _debugSerial->println(F("getHNRDyn: Exit immediately"));
-    // }
-    return (false);
-  }
-  else
-  {
-    // if (_printDebug == true)
-    // {
-    //   _debugSerial->println(F("getHNRDyn: Polling"));
-    // }
-
-    //The GPS is not automatically reporting HNR vehicle dynamics so we have to poll explicitly
-    packetCfg.cls = UBX_CLASS_HNR;
-    packetCfg.id = UBX_HNR_INS;
-    packetCfg.len = 0;
-    packetCfg.startingSpot = 0;
-
-    //The data is parsed as part of processing the response
-    sfe_ublox_status_e retVal = sendCommand(&packetCfg, maxWait);
-
-    if (retVal == SFE_UBLOX_STATUS_DATA_RECEIVED)
-      return (true);
-
-    if (retVal == SFE_UBLOX_STATUS_DATA_OVERWRITTEN)
-    {
-      // if (_printDebug == true)
-      // {
-      //   _debugSerial->println(F("getHNRDyn: data in packetCfg was OVERWRITTEN by another message (but that's OK)"));
-      // }
-      return (true);
-    }
-
-    // if (_printDebug == true)
-    // {
-    //   _debugSerial->print(F("getHNRDyn retVal: "));
-    //   _debugSerial->println(statusString(retVal));
-    // }
-    return (false);
-  }
-
-  return (false); // Trap. We should never get here...
-}
-
-//Enable or disable automatic HNR vehicle dynamics message generation by the GNSS. This changes the way getHNRDyn
-//works.
-boolean SFE_UBLOX_GNSS::setAutoHNRINS(boolean enable, uint16_t maxWait)
-{
-  return setAutoHNRINSrate(enable ? 1 : 0, true, maxWait);
-}
-
-//Enable or disable automatic HNR vehicle dynamics message generation by the GNSS. This changes the way getHNRDyn
-//works.
-boolean SFE_UBLOX_GNSS::setAutoHNRINS(boolean enable, boolean implicitUpdate, uint16_t maxWait)
-{
-  return setAutoHNRINSrate(enable ? 1 : 0, implicitUpdate, maxWait);
-}
-
-//Enable or disable automatic HNR vehicle dynamics message generation by the GNSS. This changes the way getHNRDyn
-//works.
-boolean SFE_UBLOX_GNSS::setAutoHNRINSrate(uint8_t rate, boolean implicitUpdate, uint16_t maxWait)
-{
-  if (packetUBXHNRINS == NULL) initPacketUBXHNRINS(); //Check that RAM has been allocated for the data
-  if (packetUBXHNRINS == NULL) //Only attempt this if RAM allocation was successful
-    return false;
-
-  if (rate > 127) rate = 127;
-
-  packetCfg.cls = UBX_CLASS_CFG;
-  packetCfg.id = UBX_CFG_MSG;
-  packetCfg.len = 3;
-  packetCfg.startingSpot = 0;
-  payloadCfg[0] = UBX_CLASS_HNR;
-  payloadCfg[1] = UBX_HNR_INS;
-  payloadCfg[2] = rate; // rate relative to navigation freq.
-
-  boolean ok = ((sendCommand(&packetCfg, maxWait)) == SFE_UBLOX_STATUS_DATA_SENT); // We are only expecting an ACK
-  if (ok)
-  {
-    packetUBXHNRINS->automaticFlags.flags.bits.automatic = (rate > 0);
-    packetUBXHNRINS->automaticFlags.flags.bits.implicitUpdate = implicitUpdate;
-  }
-  packetUBXHNRINS->moduleQueried.moduleQueried.bits.all = false; // Mark data as stale
-  return ok;
-}
-
-//Enable automatic navigation message generation by the GNSS.
-boolean SFE_UBLOX_GNSS::setAutoHNRINScallback(void (*callbackPointer)(UBX_HNR_INS_data_t), uint16_t maxWait)
-{
-  // Enable auto messages. Set implicitUpdate to false as we expect the user to call checkUblox manually.
-  boolean result = setAutoHNRINS(true, false, maxWait);
-  if (!result)
-    return (result); // Bail if setAuto failed
-
-  if (packetUBXHNRINS->callbackData == NULL) //Check if RAM has been allocated for the callback copy
-  {
-    packetUBXHNRINS->callbackData = new UBX_HNR_INS_data_t; //Allocate RAM for the main struct
-  }
-
-  if (packetUBXHNRINS->callbackData == NULL)
-  {
-    if ((_printDebug == true) || (_printLimitedDebug == true)) // This is important. Print this if doing limited debugging
-      _debugSerial->println(F("setAutoHNRDyncallback: PANIC! RAM allocation failed!"));
-    return (false);
-  }
-
-  packetUBXHNRINS->callbackPointer = callbackPointer;
-  return (true);
-}
-
-//In case no config access to the GNSS is possible and HNR vehicle dynamics is send cyclically already
-//set config to suitable parameters
-boolean SFE_UBLOX_GNSS::assumeAutoHNRINS(boolean enabled, boolean implicitUpdate)
-{
-  if (packetUBXHNRINS == NULL) initPacketUBXHNRINS(); //Check that RAM has been allocated for the data
-  if (packetUBXHNRINS == NULL) //Bail if the RAM allocation failed
-    return (false);
-
-  boolean changes = packetUBXHNRINS->automaticFlags.flags.bits.automatic != enabled || packetUBXHNRINS->automaticFlags.flags.bits.implicitUpdate != implicitUpdate;
-  if (changes)
-  {
-    packetUBXHNRINS->automaticFlags.flags.bits.automatic = enabled;
-    packetUBXHNRINS->automaticFlags.flags.bits.implicitUpdate = implicitUpdate;
-  }
-  return changes;
-}
-
-// PRIVATE: Allocate RAM for packetUBXHNRINS and initialize it
-boolean SFE_UBLOX_GNSS::initPacketUBXHNRINS()
-{
-  packetUBXHNRINS = new UBX_HNR_INS_t; //Allocate RAM for the main struct
-  if (packetUBXHNRINS == NULL)
-  {
-    if ((_printDebug == true) || (_printLimitedDebug == true)) // This is important. Print this if doing limited debugging
-      _debugSerial->println(F("initPacketUBXHNRINS: PANIC! RAM allocation failed!"));
-    return (false);
-  }
-  packetUBXHNRINS->automaticFlags.flags.all = 0;
-  packetUBXHNRINS->callbackPointer = NULL;
-  packetUBXHNRINS->callbackData = NULL;
-  packetUBXHNRINS->moduleQueried.moduleQueried.all = 0;
-  return (true);
-}
-
-//Mark all the data as read/stale
-void SFE_UBLOX_GNSS::flushHNRINS()
-{
-  if (packetUBXHNRINS == NULL) return; // Bail if RAM has not been allocated (otherwise we could be writing anywhere!)
-  packetUBXHNRINS->moduleQueried.moduleQueried.all = 0; //Mark all datums as stale (read before)
-}
-
-//Log this data in file buffer
-void SFE_UBLOX_GNSS::logHNRINS(boolean enabled)
-{
-  if (packetUBXHNRINS == NULL) return; // Bail if RAM has not been allocated (otherwise we could be writing anywhere!)
-  packetUBXHNRINS->automaticFlags.flags.bits.addToFileBuffer = (uint8_t)enabled;
-}
-
-// ***** HNR PVT automatic support
-
-//Get the HNR PVT data
-// Returns true if the get HNR PVT is successful. Data is returned in hnrPVT
-// Note: if hnrPVTQueried is true, it gets set to false by this function since we assume
-//       that the user will read hnrPVT immediately after this. I.e. this function will
-//       only return true _once_ after each auto HNR PVT is processed
-boolean SFE_UBLOX_GNSS::getHNRPVT(uint16_t maxWait)
-{
-  if (packetUBXHNRPVT == NULL) initPacketUBXHNRPVT(); //Check that RAM has been allocated for the PVT data
-  if (packetUBXHNRPVT == NULL) //Only attempt this if RAM allocation was successful
-    return false;
-
-  if (packetUBXHNRPVT->automaticFlags.flags.bits.automatic && packetUBXHNRPVT->automaticFlags.flags.bits.implicitUpdate)
-  {
-    //The GPS is automatically reporting, we just check whether we got unread data
-    // if (_printDebug == true)
-    // {
-    //   _debugSerial->println(F("getHNRPVT: Autoreporting"));
-    // }
-    checkUbloxInternal(&packetCfg, UBX_CLASS_HNR, UBX_HNR_PVT);
-    return packetUBXHNRPVT->moduleQueried.moduleQueried.bits.all;
-  }
-  else if (packetUBXHNRPVT->automaticFlags.flags.bits.automatic && !packetUBXHNRPVT->automaticFlags.flags.bits.implicitUpdate)
-  {
-    //Someone else has to call checkUblox for us...
-    // if (_printDebug == true)
-    // {
-    //   _debugSerial->println(F("getHNRPVT: Exit immediately"));
-    // }
-    return (false);
-  }
-  else
-  {
-    // if (_printDebug == true)
-    // {
-    //   _debugSerial->println(F("getHNRPVT: Polling"));
-    // }
-
-    //The GPS is not automatically reporting HNR PVT so we have to poll explicitly
-    packetCfg.cls = UBX_CLASS_HNR;
-    packetCfg.id = UBX_HNR_PVT;
-    packetCfg.len = 0;
-    packetCfg.startingSpot = 0;
-
-    //The data is parsed as part of processing the response
-    sfe_ublox_status_e retVal = sendCommand(&packetCfg, maxWait);
-
-    if (retVal == SFE_UBLOX_STATUS_DATA_RECEIVED)
-      return (true);
-
-    if (retVal == SFE_UBLOX_STATUS_DATA_OVERWRITTEN)
-    {
-      // if (_printDebug == true)
-      // {
-      //   _debugSerial->println(F("getHNRPVT: data in packetCfg was OVERWRITTEN by another message (but that's OK)"));
-      // }
-      return (true);
-    }
-
-    // if (_printDebug == true)
-    // {
-    //   _debugSerial->print(F("getHNRPVT retVal: "));
-    //   _debugSerial->println(statusString(retVal));
-    // }
-    return (false);
-  }
-
-  return (false); // Trap. We should never get here...
-}
-
-//Enable or disable automatic HNR PVT message generation by the GNSS. This changes the way getHNRPVT
-//works.
-boolean SFE_UBLOX_GNSS::setAutoHNRPVT(boolean enable, uint16_t maxWait)
-{
-  return setAutoHNRPVTrate(enable ? 1 : 0, true, maxWait);
-}
-
-//Enable or disable automatic HNR PVT message generation by the GNSS. This changes the way getHNRPVT
-//works.
-boolean SFE_UBLOX_GNSS::setAutoHNRPVT(boolean enable, boolean implicitUpdate, uint16_t maxWait)
-{
-  return setAutoHNRPVTrate(enable ? 1 : 0, implicitUpdate, maxWait);
-}
-
-//Enable or disable automatic HNR PVT message generation by the GNSS. This changes the way getHNRPVT
-//works.
-boolean SFE_UBLOX_GNSS::setAutoHNRPVTrate(uint8_t rate, boolean implicitUpdate, uint16_t maxWait)
-{
-  if (packetUBXHNRPVT == NULL) initPacketUBXHNRPVT(); //Check that RAM has been allocated for the data
-  if (packetUBXHNRPVT == NULL) //Only attempt this if RAM allocation was successful
-    return false;
-
-  if (rate > 127) rate = 127;
-
-  packetCfg.cls = UBX_CLASS_CFG;
-  packetCfg.id = UBX_CFG_MSG;
-  packetCfg.len = 3;
-  packetCfg.startingSpot = 0;
-  payloadCfg[0] = UBX_CLASS_HNR;
-  payloadCfg[1] = UBX_HNR_PVT;
-  payloadCfg[2] = rate; // rate relative to navigation freq.
-
-  boolean ok = ((sendCommand(&packetCfg, maxWait)) == SFE_UBLOX_STATUS_DATA_SENT); // We are only expecting an ACK
-  if (ok)
-  {
-    packetUBXHNRPVT->automaticFlags.flags.bits.automatic = (rate > 0);
-    packetUBXHNRPVT->automaticFlags.flags.bits.implicitUpdate = implicitUpdate;
-  }
-  packetUBXHNRPVT->moduleQueried.moduleQueried.bits.all = false; // Mark data as stale
-  return ok;
-}
-
-//Enable automatic navigation message generation by the GNSS.
-boolean SFE_UBLOX_GNSS::setAutoHNRPVTcallback(void (*callbackPointer)(UBX_HNR_PVT_data_t), uint16_t maxWait)
-{
-  // Enable auto messages. Set implicitUpdate to false as we expect the user to call checkUblox manually.
-  boolean result = setAutoHNRPVT(true, false, maxWait);
-  if (!result)
-    return (result); // Bail if setAuto failed
-
-  if (packetUBXHNRPVT->callbackData == NULL) //Check if RAM has been allocated for the callback copy
-  {
-    packetUBXHNRPVT->callbackData = new UBX_HNR_PVT_data_t; //Allocate RAM for the main struct
-  }
-
-  if (packetUBXHNRPVT->callbackData == NULL)
-  {
-    if ((_printDebug == true) || (_printLimitedDebug == true)) // This is important. Print this if doing limited debugging
-      _debugSerial->println(F("setAutoHNRPVTcallback: PANIC! RAM allocation failed!"));
-    return (false);
-  }
-
-  packetUBXHNRPVT->callbackPointer = callbackPointer;
-  return (true);
-}
-
-//In case no config access to the GNSS is possible and HNR PVT is send cyclically already
-//set config to suitable parameters
-boolean SFE_UBLOX_GNSS::assumeAutoHNRPVT(boolean enabled, boolean implicitUpdate)
-{
-  if (packetUBXHNRPVT == NULL) initPacketUBXHNRPVT(); //Check that RAM has been allocated for the PVT data
-  if (packetUBXHNRPVT == NULL) //Only attempt this if RAM allocation was successful
-    return false;
-
-  boolean changes = packetUBXHNRPVT->automaticFlags.flags.bits.automatic != enabled || packetUBXHNRPVT->automaticFlags.flags.bits.implicitUpdate != implicitUpdate;
-  if (changes)
-  {
-    packetUBXHNRPVT->automaticFlags.flags.bits.automatic = enabled;
-    packetUBXHNRPVT->automaticFlags.flags.bits.implicitUpdate = implicitUpdate;
-  }
-  return changes;
-}
-
-// PRIVATE: Allocate RAM for packetUBXHNRPVT and initialize it
-boolean SFE_UBLOX_GNSS::initPacketUBXHNRPVT()
-{
-  packetUBXHNRPVT = new UBX_HNR_PVT_t; //Allocate RAM for the main struct
-  if (packetUBXHNRPVT == NULL)
-  {
-    if ((_printDebug == true) || (_printLimitedDebug == true)) // This is important. Print this if doing limited debugging
-      _debugSerial->println(F("initPacketUBXHNRPVT: PANIC! RAM allocation failed!"));
-    return (false);
-  }
-  packetUBXHNRPVT->automaticFlags.flags.all = 0;
-  packetUBXHNRPVT->callbackPointer = NULL;
-  packetUBXHNRPVT->callbackData = NULL;
-  packetUBXHNRPVT->moduleQueried.moduleQueried.all = 0;
-  return (true);
-}
-
-//Mark all the data as read/stale
-void SFE_UBLOX_GNSS::flushHNRPVT()
-{
-  if (packetUBXHNRPVT == NULL) return; // Bail if RAM has not been allocated (otherwise we could be writing anywhere!)
-  packetUBXHNRPVT->moduleQueried.moduleQueried.all = 0; //Mark all datums as stale (read before)
-}
-
-//Log this data in file buffer
-void SFE_UBLOX_GNSS::logHNRPVT(boolean enabled)
-{
-  if (packetUBXHNRPVT == NULL) return; // Bail if RAM has not been allocated (otherwise we could be writing anywhere!)
-  packetUBXHNRPVT->automaticFlags.flags.bits.addToFileBuffer = (uint8_t)enabled;
-}
-
-// ***** CFG RATE Helper Functions
-
-//Set the rate at which the module will give us an updated navigation solution
-//Expects a number that is the updates per second. For example 1 = 1Hz, 2 = 2Hz, etc.
-//Max is 40Hz(?!)
-boolean SFE_UBLOX_GNSS::setNavigationFrequency(uint8_t navFreq, uint16_t maxWait)
-{
-  //if(updateRate > 40) updateRate = 40; //Not needed: module will correct out of bounds values
-
-  //Adjust the I2C polling timeout based on update rate
-  i2cPollingWait = 1000 / (((int)navFreq) * 4); //This is the number of ms to wait between checks for new I2C data
-
-  //Query the module
-  packetCfg.cls = UBX_CLASS_CFG;
-  packetCfg.id = UBX_CFG_RATE;
-  packetCfg.len = 0;
-  packetCfg.startingSpot = 0;
-
-  //This will load the payloadCfg array with current settings of the given register
-  if (sendCommand(&packetCfg, maxWait) != SFE_UBLOX_STATUS_DATA_RECEIVED) // We are expecting data and an ACK
-    return (false);                                                       //If command send fails then bail
-
-  uint16_t measurementRate = 1000 / navFreq;
-
-  //payloadCfg is now loaded with current bytes. Change only the ones we need to
-  payloadCfg[0] = measurementRate & 0xFF; //measRate LSB
-  payloadCfg[1] = measurementRate >> 8;   //measRate MSB
-
-  return ((sendCommand(&packetCfg, maxWait)) == SFE_UBLOX_STATUS_DATA_SENT); // We are only expecting an ACK
-}
-
-//Get the rate at which the module is outputting nav solutions
-uint8_t SFE_UBLOX_GNSS::getNavigationFrequency(uint16_t maxWait)
-{
-  if (packetUBXCFGRATE == NULL) initPacketUBXCFGRATE(); //Check that RAM has been allocated for the RATE data
-  if (packetUBXCFGRATE == NULL) //Bail if the RAM allocation failed
-    return 0;
-
-  if (packetUBXCFGRATE->moduleQueried.moduleQueried.bits.measRate == false)
-    getNavigationFrequencyInternal(maxWait);
-  packetUBXCFGRATE->moduleQueried.moduleQueried.bits.measRate = false; //Since we are about to give this to user, mark this data as stale
-  packetUBXCFGRATE->moduleQueried.moduleQueried.bits.all = false;
-
-  uint16_t measurementRate = packetUBXCFGRATE->data.measRate;
-
-  measurementRate = 1000 / measurementRate; //This may return an int when it's a float, but I'd rather not return 4 bytes
-  return (measurementRate);
-}
-
-//Set the elapsed time between GNSS measurements in milliseconds, which defines the rate
-boolean SFE_UBLOX_GNSS::setMeasurementRate(uint16_t rate, uint16_t maxWait)
-{
-  //Adjust the I2C polling timeout based on update rate
-  i2cPollingWait = rate / 4; //This is the number of ms to wait between checks for new I2C data
-
-  //Query the module
-  packetCfg.cls = UBX_CLASS_CFG;
-  packetCfg.id = UBX_CFG_RATE;
-  packetCfg.len = 0;
-  packetCfg.startingSpot = 0;
-
-  //This will load the payloadCfg array with current settings of the given register
-  if (sendCommand(&packetCfg, maxWait) != SFE_UBLOX_STATUS_DATA_RECEIVED) // We are expecting data and an ACK
-    return (false);                                                       //If command send fails then bail
-
-  //payloadCfg is now loaded with current bytes. Change only the ones we need to
-  payloadCfg[0] = rate & 0xFF; //measRate LSB
-  payloadCfg[1] = rate >> 8;   //measRate MSB
-
-  return ((sendCommand(&packetCfg, maxWait)) == SFE_UBLOX_STATUS_DATA_SENT); // We are only expecting an ACK
-}
-
-//Return the elapsed time between GNSS measurements in milliseconds, which defines the rate
-uint16_t SFE_UBLOX_GNSS::getMeasurementRate(uint16_t maxWait)
-{
-  if (packetUBXCFGRATE == NULL) initPacketUBXCFGRATE(); //Check that RAM has been allocated for the RATE data
-  if (packetUBXCFGRATE == NULL) //Bail if the RAM allocation failed
-    return 0;
-
-  if (packetUBXCFGRATE->moduleQueried.moduleQueried.bits.measRate == false)
-    getNavigationFrequencyInternal(maxWait);
-  packetUBXCFGRATE->moduleQueried.moduleQueried.bits.measRate = false; //Since we are about to give this to user, mark this data as stale
-  packetUBXCFGRATE->moduleQueried.moduleQueried.bits.all = false;
-
-  return (packetUBXCFGRATE->data.measRate);
-}
-
-//Set the ratio between the number of measurements and the number of navigation solutions. Unit is cycles. Max is 127.
-boolean SFE_UBLOX_GNSS::setNavigationRate(uint16_t rate, uint16_t maxWait)
-{
-  //Query the module
-  packetCfg.cls = UBX_CLASS_CFG;
-  packetCfg.id = UBX_CFG_RATE;
-  packetCfg.len = 0;
-  packetCfg.startingSpot = 0;
-
-  //This will load the payloadCfg array with current settings of the given register
-  if (sendCommand(&packetCfg, maxWait) != SFE_UBLOX_STATUS_DATA_RECEIVED) // We are expecting data and an ACK
-    return (false);                                                       //If command send fails then bail
-
-  //payloadCfg is now loaded with current bytes. Change only the ones we need to
-  payloadCfg[2] = rate & 0xFF; //navRate LSB
-  payloadCfg[3] = rate >> 8;   //navRate MSB
-
-  return ((sendCommand(&packetCfg, maxWait)) == SFE_UBLOX_STATUS_DATA_SENT); // We are only expecting an ACK
-}
-
-//Return the ratio between the number of measurements and the number of navigation solutions. Unit is cycles
-uint16_t SFE_UBLOX_GNSS::getNavigationRate(uint16_t maxWait)
-{
-  if (packetUBXCFGRATE == NULL) initPacketUBXCFGRATE(); //Check that RAM has been allocated for the RATE data
-  if (packetUBXCFGRATE == NULL) //Bail if the RAM allocation failed
-    return 0;
-
-  if (packetUBXCFGRATE->moduleQueried.moduleQueried.bits.navRate == false)
-    getNavigationFrequencyInternal(maxWait);
-  packetUBXCFGRATE->moduleQueried.moduleQueried.bits.navRate = false; //Since we are about to give this to user, mark this data as stale
-  packetUBXCFGRATE->moduleQueried.moduleQueried.bits.all = false;
-
-  return (packetUBXCFGRATE->data.navRate);
-}
-
-// ***** DOP Helper Functions
-
-uint16_t SFE_UBLOX_GNSS::getGeometricDOP(uint16_t maxWait)
-{
-  if (packetUBXNAVDOP == NULL) initPacketUBXNAVDOP(); //Check that RAM has been allocated for the DOP data
-  if (packetUBXNAVDOP == NULL) //Bail if the RAM allocation failed
-    return 0;
-
-  if (packetUBXNAVDOP->moduleQueried.moduleQueried.bits.gDOP == false)
-    getDOP(maxWait);
-  packetUBXNAVDOP->moduleQueried.moduleQueried.bits.gDOP = false; //Since we are about to give this to user, mark this data as stale
-  packetUBXNAVDOP->moduleQueried.moduleQueried.bits.all = false;
-  return (packetUBXNAVDOP->data.gDOP);
-}
-
-uint16_t SFE_UBLOX_GNSS::getPositionDOP(uint16_t maxWait)
-{
-  if (packetUBXNAVDOP == NULL) initPacketUBXNAVDOP(); //Check that RAM has been allocated for the DOP data
-  if (packetUBXNAVDOP == NULL) //Bail if the RAM allocation failed
-    return 0;
-
-  if (packetUBXNAVDOP->moduleQueried.moduleQueried.bits.pDOP == false)
-    getDOP(maxWait);
-  packetUBXNAVDOP->moduleQueried.moduleQueried.bits.pDOP = false; //Since we are about to give this to user, mark this data as stale
-  packetUBXNAVDOP->moduleQueried.moduleQueried.bits.all = false;
-  return (packetUBXNAVDOP->data.pDOP);
-}
-
-uint16_t SFE_UBLOX_GNSS::getTimeDOP(uint16_t maxWait)
-{
-  if (packetUBXNAVDOP == NULL) initPacketUBXNAVDOP(); //Check that RAM has been allocated for the DOP data
-  if (packetUBXNAVDOP == NULL) //Bail if the RAM allocation failed
-    return 0;
-
-  if (packetUBXNAVDOP->moduleQueried.moduleQueried.bits.tDOP == false)
-    getDOP(maxWait);
-  packetUBXNAVDOP->moduleQueried.moduleQueried.bits.tDOP = false; //Since we are about to give this to user, mark this data as stale
-  packetUBXNAVDOP->moduleQueried.moduleQueried.bits.all = false;
-  return (packetUBXNAVDOP->data.tDOP);
-}
-
-uint16_t SFE_UBLOX_GNSS::getVerticalDOP(uint16_t maxWait)
-{
-  if (packetUBXNAVDOP == NULL) initPacketUBXNAVDOP(); //Check that RAM has been allocated for the DOP data
-  if (packetUBXNAVDOP == NULL) //Bail if the RAM allocation failed
-    return 0;
-
-  if (packetUBXNAVDOP->moduleQueried.moduleQueried.bits.vDOP == false)
-    getDOP(maxWait);
-  packetUBXNAVDOP->moduleQueried.moduleQueried.bits.vDOP = false; //Since we are about to give this to user, mark this data as stale
-  packetUBXNAVDOP->moduleQueried.moduleQueried.bits.all = false;
-  return (packetUBXNAVDOP->data.vDOP);
-}
-
-uint16_t SFE_UBLOX_GNSS::getHorizontalDOP(uint16_t maxWait)
-{
-  if (packetUBXNAVDOP == NULL) initPacketUBXNAVDOP(); //Check that RAM has been allocated for the DOP data
-  if (packetUBXNAVDOP == NULL) //Bail if the RAM allocation failed
-    return 0;
-
-  if (packetUBXNAVDOP->moduleQueried.moduleQueried.bits.hDOP == false)
-    getDOP(maxWait);
-  packetUBXNAVDOP->moduleQueried.moduleQueried.bits.hDOP = false; //Since we are about to give this to user, mark this data as stale
-  packetUBXNAVDOP->moduleQueried.moduleQueried.bits.all = false;
-  return (packetUBXNAVDOP->data.hDOP);
-}
-
-uint16_t SFE_UBLOX_GNSS::getNorthingDOP(uint16_t maxWait)
-{
-  if (packetUBXNAVDOP == NULL) initPacketUBXNAVDOP(); //Check that RAM has been allocated for the DOP data
-  if (packetUBXNAVDOP == NULL) //Bail if the RAM allocation failed
-    return 0;
-
-  if (packetUBXNAVDOP->moduleQueried.moduleQueried.bits.nDOP == false)
-    getDOP(maxWait);
-  packetUBXNAVDOP->moduleQueried.moduleQueried.bits.nDOP = false; //Since we are about to give this to user, mark this data as stale
-  packetUBXNAVDOP->moduleQueried.moduleQueried.bits.all = false;
-  return (packetUBXNAVDOP->data.nDOP);
-}
-
-uint16_t SFE_UBLOX_GNSS::getEastingDOP(uint16_t maxWait)
-{
-  if (packetUBXNAVDOP == NULL) initPacketUBXNAVDOP(); //Check that RAM has been allocated for the DOP data
-  if (packetUBXNAVDOP == NULL) //Bail if the RAM allocation failed
-    return 0;
-
-  if (packetUBXNAVDOP->moduleQueried.moduleQueried.bits.eDOP == false)
-    getDOP(maxWait);
-  packetUBXNAVDOP->moduleQueried.moduleQueried.bits.eDOP = false; //Since we are about to give this to user, mark this data as stale
-  packetUBXNAVDOP->moduleQueried.moduleQueried.bits.all = false;
-  return (packetUBXNAVDOP->data.eDOP);
-}
-
-// ***** ATT Helper Functions
-
-float SFE_UBLOX_GNSS::getATTroll(uint16_t maxWait) // Returned as degrees
-{
-  if (packetUBXNAVATT == NULL) initPacketUBXNAVATT(); //Check that RAM has been allocated for the NAV ATT data
-  if (packetUBXNAVATT == NULL) //Bail if the RAM allocation failed
-    return (0);
-
-  if (packetUBXNAVATT->moduleQueried.moduleQueried.bits.roll == false)
-    getNAVATT(maxWait);
-  packetUBXNAVATT->moduleQueried.moduleQueried.bits.roll = false; //Since we are about to give this to user, mark this data as stale
-  packetUBXNAVATT->moduleQueried.moduleQueried.bits.all = false;
-  return (((float)packetUBXNAVATT->data.roll) / 100000.0); // Convert to degrees
-}
-
-float SFE_UBLOX_GNSS::getATTpitch(uint16_t maxWait) // Returned as degrees
-{
-  if (packetUBXNAVATT == NULL) initPacketUBXNAVATT(); //Check that RAM has been allocated for the NAV ATT data
-  if (packetUBXNAVATT == NULL) //Bail if the RAM allocation failed
-    return (0);
-
-  if (packetUBXNAVATT->moduleQueried.moduleQueried.bits.pitch == false)
-    getNAVATT(maxWait);
-  packetUBXNAVATT->moduleQueried.moduleQueried.bits.pitch = false; //Since we are about to give this to user, mark this data as stale
-  packetUBXNAVATT->moduleQueried.moduleQueried.bits.all = false;
-  return (((float)packetUBXNAVATT->data.pitch) / 100000.0); // Convert to degrees
-}
-
-float SFE_UBLOX_GNSS::getATTheading(uint16_t maxWait) // Returned as degrees
-{
-  if (packetUBXNAVATT == NULL) initPacketUBXNAVATT(); //Check that RAM has been allocated for the NAV ATT data
-  if (packetUBXNAVATT == NULL) //Bail if the RAM allocation failed
-    return (0);
-
-  if (packetUBXNAVATT->moduleQueried.moduleQueried.bits.heading == false)
-    getNAVATT(maxWait);
-  packetUBXNAVATT->moduleQueried.moduleQueried.bits.heading = false; //Since we are about to give this to user, mark this data as stale
-  packetUBXNAVATT->moduleQueried.moduleQueried.bits.all = false;
-  return (((float)packetUBXNAVATT->data.heading) / 100000.0); // Convert to degrees
-}
-
-// ***** PVT Helper Functions
-
-uint32_t SFE_UBLOX_GNSS::getTimeOfWeek(uint16_t maxWait)
-{
-  if (packetUBXNAVPVT == NULL) initPacketUBXNAVPVT(); //Check that RAM has been allocated for the PVT data
-  if (packetUBXNAVPVT == NULL) //Bail if the RAM allocation failed
-    return 0;
-
-  if (packetUBXNAVPVT->moduleQueried.moduleQueried1.bits.iTOW == false)
-    getPVT(maxWait);
-  packetUBXNAVPVT->moduleQueried.moduleQueried1.bits.iTOW = false; //Since we are about to give this to user, mark this data as stale
-  packetUBXNAVPVT->moduleQueried.moduleQueried1.bits.all = false;
-  return (packetUBXNAVPVT->data.iTOW);
-}
-
-//Get the current year
-uint16_t SFE_UBLOX_GNSS::getYear(uint16_t maxWait)
-{
-  if (packetUBXNAVPVT == NULL) initPacketUBXNAVPVT(); //Check that RAM has been allocated for the PVT data
-  if (packetUBXNAVPVT == NULL) //Bail if the RAM allocation failed
-    return 0;
-
-  if (packetUBXNAVPVT->moduleQueried.moduleQueried1.bits.year == false)
-    getPVT(maxWait);
-  packetUBXNAVPVT->moduleQueried.moduleQueried1.bits.year = false; //Since we are about to give this to user, mark this data as stale
-  packetUBXNAVPVT->moduleQueried.moduleQueried1.bits.all = false;
-  return (packetUBXNAVPVT->data.year);
-}
-
-//Get the current month
-uint8_t SFE_UBLOX_GNSS::getMonth(uint16_t maxWait)
-{
-  if (packetUBXNAVPVT == NULL) initPacketUBXNAVPVT(); //Check that RAM has been allocated for the PVT data
-  if (packetUBXNAVPVT == NULL) //Bail if the RAM allocation failed
-    return 0;
-
-  if (packetUBXNAVPVT->moduleQueried.moduleQueried1.bits.month == false)
-    getPVT(maxWait);
-  packetUBXNAVPVT->moduleQueried.moduleQueried1.bits.month = false; //Since we are about to give this to user, mark this data as stale
-  packetUBXNAVPVT->moduleQueried.moduleQueried1.bits.all = false;
-  return (packetUBXNAVPVT->data.month);
-}
-
-//Get the current day
-uint8_t SFE_UBLOX_GNSS::getDay(uint16_t maxWait)
-{
-  if (packetUBXNAVPVT == NULL) initPacketUBXNAVPVT(); //Check that RAM has been allocated for the PVT data
-  if (packetUBXNAVPVT == NULL) //Bail if the RAM allocation failed
-    return 0;
-
-  if (packetUBXNAVPVT->moduleQueried.moduleQueried1.bits.day == false)
-    getPVT(maxWait);
-  packetUBXNAVPVT->moduleQueried.moduleQueried1.bits.day = false; //Since we are about to give this to user, mark this data as stale
-  packetUBXNAVPVT->moduleQueried.moduleQueried1.bits.all = false;
-  return (packetUBXNAVPVT->data.day);
-}
-
-//Get the current hour
-uint8_t SFE_UBLOX_GNSS::getHour(uint16_t maxWait)
-{
-  if (packetUBXNAVPVT == NULL) initPacketUBXNAVPVT(); //Check that RAM has been allocated for the PVT data
-  if (packetUBXNAVPVT == NULL) //Bail if the RAM allocation failed
-    return 0;
-
-  if (packetUBXNAVPVT->moduleQueried.moduleQueried1.bits.hour == false)
-    getPVT(maxWait);
-  packetUBXNAVPVT->moduleQueried.moduleQueried1.bits.hour = false; //Since we are about to give this to user, mark this data as stale
-  packetUBXNAVPVT->moduleQueried.moduleQueried1.bits.all = false;
-  return (packetUBXNAVPVT->data.hour);
-}
-
-//Get the current minute
-uint8_t SFE_UBLOX_GNSS::getMinute(uint16_t maxWait)
-{
-  if (packetUBXNAVPVT == NULL) initPacketUBXNAVPVT(); //Check that RAM has been allocated for the PVT data
-  if (packetUBXNAVPVT == NULL) //Bail if the RAM allocation failed
-    return 0;
-
-  if (packetUBXNAVPVT->moduleQueried.moduleQueried1.bits.min == false)
-    getPVT(maxWait);
-  packetUBXNAVPVT->moduleQueried.moduleQueried1.bits.min = false; //Since we are about to give this to user, mark this data as stale
-  packetUBXNAVPVT->moduleQueried.moduleQueried1.bits.all = false;
-  return (packetUBXNAVPVT->data.min);
-}
-
-//Get the current second
-uint8_t SFE_UBLOX_GNSS::getSecond(uint16_t maxWait)
-{
-  if (packetUBXNAVPVT == NULL) initPacketUBXNAVPVT(); //Check that RAM has been allocated for the PVT data
-  if (packetUBXNAVPVT == NULL) //Bail if the RAM allocation failed
-    return 0;
-
-  if (packetUBXNAVPVT->moduleQueried.moduleQueried1.bits.sec == false)
-    getPVT(maxWait);
-  packetUBXNAVPVT->moduleQueried.moduleQueried1.bits.sec = false; //Since we are about to give this to user, mark this data as stale
-  packetUBXNAVPVT->moduleQueried.moduleQueried1.bits.all = false;
-  return (packetUBXNAVPVT->data.sec);
-}
-
-//Get the current millisecond
-uint16_t SFE_UBLOX_GNSS::getMillisecond(uint16_t maxWait)
-{
-  if (packetUBXNAVPVT == NULL) initPacketUBXNAVPVT(); //Check that RAM has been allocated for the PVT data
-  if (packetUBXNAVPVT == NULL) //Bail if the RAM allocation failed
-    return 0;
-
-  if (packetUBXNAVPVT->moduleQueried.moduleQueried1.bits.iTOW == false)
-    getPVT(maxWait);
-  packetUBXNAVPVT->moduleQueried.moduleQueried1.bits.iTOW = false; //Since we are about to give this to user, mark this data as stale
-  packetUBXNAVPVT->moduleQueried.moduleQueried1.bits.all = false;
-  return (packetUBXNAVPVT->data.iTOW % 1000);
-}
-
-//Get the current nanoseconds - includes milliseconds
-int32_t SFE_UBLOX_GNSS::getNanosecond(uint16_t maxWait)
-{
-  if (packetUBXNAVPVT == NULL) initPacketUBXNAVPVT(); //Check that RAM has been allocated for the PVT data
-  if (packetUBXNAVPVT == NULL) //Bail if the RAM allocation failed
-    return 0;
-
-  if (packetUBXNAVPVT->moduleQueried.moduleQueried1.bits.nano == false)
-    getPVT(maxWait);
-  packetUBXNAVPVT->moduleQueried.moduleQueried1.bits.nano = false; //Since we are about to give this to user, mark this data as stale
-  packetUBXNAVPVT->moduleQueried.moduleQueried1.bits.all = false;
-  return (packetUBXNAVPVT->data.nano);
-}
-
-//Get the current Unix epoch time rounded up to the nearest second
-uint32_t SFE_UBLOX_GNSS::getUnixEpoch(uint16_t maxWait)
-{
-  if (packetUBXNAVPVT == NULL) initPacketUBXNAVPVT(); //Check that RAM has been allocated for the PVT data
-  if (packetUBXNAVPVT == NULL) //Bail if the RAM allocation failed
-    return 0;
-
-  if (packetUBXNAVPVT->moduleQueried.moduleQueried1.bits.sec == false)
-    getPVT(maxWait);
-  packetUBXNAVPVT->moduleQueried.moduleQueried1.bits.year = false;
-  packetUBXNAVPVT->moduleQueried.moduleQueried1.bits.month = false;
-  packetUBXNAVPVT->moduleQueried.moduleQueried1.bits.day = false;
-  packetUBXNAVPVT->moduleQueried.moduleQueried1.bits.hour = false;
-  packetUBXNAVPVT->moduleQueried.moduleQueried1.bits.min = false;
-  packetUBXNAVPVT->moduleQueried.moduleQueried1.bits.sec = false;
-  packetUBXNAVPVT->moduleQueried.moduleQueried1.bits.all = false;
-  // assemble time elements into time_t - credits to Thomas Roell @ https://github.com/GrumpyOldPizza
-  uint32_t t = ((((((((uint32_t)packetUBXNAVPVT->data.year - 1970) * 365) + ((((uint32_t)packetUBXNAVPVT->data.year - 1970) + 3) / 4)) + 
-                            DAYS_SINCE_MONTH[((uint32_t)packetUBXNAVPVT->data.year - 1970) & 3][(uint32_t)packetUBXNAVPVT->data.month] +
-                          ((uint32_t)packetUBXNAVPVT->data.day - 1)) * 24 +
-                        (uint32_t)packetUBXNAVPVT->data.hour) * 60 +
-                      (uint32_t)packetUBXNAVPVT->data.min) * 60 +
-                    (uint32_t)packetUBXNAVPVT->data.sec);
-  return t;
-}
-
-//Get the current Unix epoch including microseconds
-uint32_t SFE_UBLOX_GNSS::getUnixEpoch(uint32_t& microsecond, uint16_t maxWait)
-{
-  if (packetUBXNAVPVT == NULL) initPacketUBXNAVPVT(); //Check that RAM has been allocated for the PVT data
-  if (packetUBXNAVPVT == NULL) //Bail if the RAM allocation failed
-    return 0;
-
-  if (packetUBXNAVPVT->moduleQueried.moduleQueried1.bits.nano == false)
-    getPVT(maxWait);
-  packetUBXNAVPVT->moduleQueried.moduleQueried1.bits.year = false;
-  packetUBXNAVPVT->moduleQueried.moduleQueried1.bits.month = false;
-  packetUBXNAVPVT->moduleQueried.moduleQueried1.bits.day = false;
-  packetUBXNAVPVT->moduleQueried.moduleQueried1.bits.hour = false;
-  packetUBXNAVPVT->moduleQueried.moduleQueried1.bits.min = false;
-  packetUBXNAVPVT->moduleQueried.moduleQueried1.bits.sec = false;
-  packetUBXNAVPVT->moduleQueried.moduleQueried1.bits.nano = false;
-  packetUBXNAVPVT->moduleQueried.moduleQueried1.bits.all = false;
-  // assemble time elements into time_t - credits to Thomas Roell @ https://github.com/GrumpyOldPizza
-  uint32_t t = ((((((((uint32_t)packetUBXNAVPVT->data.year - 1970) * 365) + ((((uint32_t)packetUBXNAVPVT->data.year - 1970) + 3) / 4)) + 
-                            DAYS_SINCE_MONTH[((uint32_t)packetUBXNAVPVT->data.year - 1970) & 3][(uint32_t)packetUBXNAVPVT->data.month] +
-                          ((uint32_t)packetUBXNAVPVT->data.day - 1)) * 24 +
-                        (uint32_t)packetUBXNAVPVT->data.hour) * 60 +
-                      (uint32_t)packetUBXNAVPVT->data.min) * 60 +
-                    (uint32_t)packetUBXNAVPVT->data.sec);
-  int32_t us = packetUBXNAVPVT->data.nano / 1000;
-  microsecond = (uint32_t)us;
-  // adjust t if nano is negative
-  if(us < 0) {
-    microsecond = (uint32_t)(us + 1000000);
-    t--;
-  }
-  return t;
-}
-
-//Get the current date validity
-bool SFE_UBLOX_GNSS::getDateValid(uint16_t maxWait)
-{
-  if (packetUBXNAVPVT == NULL) initPacketUBXNAVPVT(); //Check that RAM has been allocated for the PVT data
-  if (packetUBXNAVPVT == NULL) //Bail if the RAM allocation failed
-    return (false);
-
-  if (packetUBXNAVPVT->moduleQueried.moduleQueried1.bits.validDate == false)
-    getPVT(maxWait);
-  packetUBXNAVPVT->moduleQueried.moduleQueried1.bits.validDate = false; //Since we are about to give this to user, mark this data as stale
-  packetUBXNAVPVT->moduleQueried.moduleQueried1.bits.all = false;
-  return ((bool)packetUBXNAVPVT->data.valid.bits.validDate);
-}
-
-//Get the current time validity
-bool SFE_UBLOX_GNSS::getTimeValid(uint16_t maxWait)
-{
-  if (packetUBXNAVPVT == NULL) initPacketUBXNAVPVT(); //Check that RAM has been allocated for the PVT data
-  if (packetUBXNAVPVT == NULL) //Bail if the RAM allocation failed
-    return (false);
-
-  if (packetUBXNAVPVT->moduleQueried.moduleQueried1.bits.validTime == false)
-    getPVT(maxWait);
-  packetUBXNAVPVT->moduleQueried.moduleQueried1.bits.validTime = false; //Since we are about to give this to user, mark this data as stale
-  packetUBXNAVPVT->moduleQueried.moduleQueried1.bits.all = false;
-  return ((bool)packetUBXNAVPVT->data.valid.bits.validTime);
-}
-
-//Get the confirmed date validity
-bool SFE_UBLOX_GNSS:: getConfirmedDate(uint16_t maxWait)
-{
-  if (packetUBXNAVPVT == NULL) initPacketUBXNAVPVT(); //Check that RAM has been allocated for the PVT data
-  if (packetUBXNAVPVT == NULL) //Bail if the RAM allocation failed
-    return (false);
-
-  if (packetUBXNAVPVT->moduleQueried.moduleQueried1.bits.confirmedDate == false)
-    getPVT(maxWait);
-  packetUBXNAVPVT->moduleQueried.moduleQueried1.bits.confirmedDate = false; //Since we are about to give this to user, mark this data as stale
-  packetUBXNAVPVT->moduleQueried.moduleQueried1.bits.all = false;
-  return ((bool)packetUBXNAVPVT->data.flags2.bits.confirmedDate);
-}
-
-//Get the confirmed time validity
-bool SFE_UBLOX_GNSS:: getConfirmedTime(uint16_t maxWait)
-{
-  if (packetUBXNAVPVT == NULL) initPacketUBXNAVPVT(); //Check that RAM has been allocated for the PVT data
-  if (packetUBXNAVPVT == NULL) //Bail if the RAM allocation failed
-    return (false);
-
-  if (packetUBXNAVPVT->moduleQueried.moduleQueried1.bits.confirmedTime == false)
-    getPVT(maxWait);
-  packetUBXNAVPVT->moduleQueried.moduleQueried1.bits.confirmedTime = false; //Since we are about to give this to user, mark this data as stale
-  packetUBXNAVPVT->moduleQueried.moduleQueried1.bits.all = false;
-  return ((bool)packetUBXNAVPVT->data.flags2.bits.confirmedTime);
-}
-
-//Get the current fix type
-//0=no fix, 1=dead reckoning, 2=2D, 3=3D, 4=GNSS, 5=Time fix
-uint8_t SFE_UBLOX_GNSS::getFixType(uint16_t maxWait)
-{
-  if (packetUBXNAVPVT == NULL) initPacketUBXNAVPVT(); //Check that RAM has been allocated for the PVT data
-  if (packetUBXNAVPVT == NULL) //Bail if the RAM allocation failed
-    return 0;
-
-  if (packetUBXNAVPVT->moduleQueried.moduleQueried1.bits.fixType == false)
-    getPVT(maxWait);
-  packetUBXNAVPVT->moduleQueried.moduleQueried1.bits.fixType = false; //Since we are about to give this to user, mark this data as stale
-  packetUBXNAVPVT->moduleQueried.moduleQueried1.bits.all = false;
-  return (packetUBXNAVPVT->data.fixType);
-}
-
-//Get whether we have a valid fix (i.e within DOP & accuracy masks)
-bool SFE_UBLOX_GNSS::getGnssFixOk(uint16_t maxWait)
-{
-  if (packetUBXNAVPVT == NULL) initPacketUBXNAVPVT(); //Check that RAM has been allocated for the PVT data
-  if (packetUBXNAVPVT == NULL) //Bail if the RAM allocation failed
-    return 0;
-
-  if (packetUBXNAVPVT->moduleQueried.moduleQueried1.bits.gnssFixOK == false)
-    getPVT(maxWait);
-  packetUBXNAVPVT->moduleQueried.moduleQueried1.bits.gnssFixOK = false; //Since we are about to give this to user, mark this data as stale
-  packetUBXNAVPVT->moduleQueried.moduleQueried1.bits.all = false;
-  return (packetUBXNAVPVT->data.flags.bits.gnssFixOK);
-}
-
-//Get whether differential corrections were applied
-bool SFE_UBLOX_GNSS::getDiffSoln(uint16_t maxWait)
-{
-  if (packetUBXNAVPVT == NULL) initPacketUBXNAVPVT(); //Check that RAM has been allocated for the PVT data
-  if (packetUBXNAVPVT == NULL) //Bail if the RAM allocation failed
-    return 0;
-
-  if (packetUBXNAVPVT->moduleQueried.moduleQueried1.bits.diffSoln == false)
-    getPVT(maxWait);
-  packetUBXNAVPVT->moduleQueried.moduleQueried1.bits.diffSoln = false; //Since we are about to give this to user, mark this data as stale
-  packetUBXNAVPVT->moduleQueried.moduleQueried1.bits.all = false;
-  return (packetUBXNAVPVT->data.flags.bits.diffSoln);
-}
-
-//Get whether head vehicle valid or not
-bool SFE_UBLOX_GNSS::getHeadVehValid(uint16_t maxWait)
-{
-  if (packetUBXNAVPVT == NULL) initPacketUBXNAVPVT(); //Check that RAM has been allocated for the PVT data
-  if (packetUBXNAVPVT == NULL) //Bail if the RAM allocation failed
-    return 0;
-
-  if (packetUBXNAVPVT->moduleQueried.moduleQueried1.bits.headVehValid == false)
-    getPVT(maxWait);
-  packetUBXNAVPVT->moduleQueried.moduleQueried1.bits.headVehValid = false; //Since we are about to give this to user, mark this data as stale
-  packetUBXNAVPVT->moduleQueried.moduleQueried1.bits.all = false;
-  return (packetUBXNAVPVT->data.flags.bits.headVehValid);
-}
-
-//Get the carrier phase range solution status
-//Useful when querying module to see if it has high-precision RTK fix
-//0=No solution, 1=Float solution, 2=Fixed solution
-uint8_t SFE_UBLOX_GNSS::getCarrierSolutionType(uint16_t maxWait)
-{
-  if (packetUBXNAVPVT == NULL) initPacketUBXNAVPVT(); //Check that RAM has been allocated for the PVT data
-  if (packetUBXNAVPVT == NULL) //Bail if the RAM allocation failed
-    return 0;
-
-  if (packetUBXNAVPVT->moduleQueried.moduleQueried1.bits.carrSoln == false)
-    getPVT(maxWait);
-  packetUBXNAVPVT->moduleQueried.moduleQueried1.bits.carrSoln = false; //Since we are about to give this to user, mark this data as stale
-  packetUBXNAVPVT->moduleQueried.moduleQueried1.bits.all = false;
-  return (packetUBXNAVPVT->data.flags.bits.carrSoln);
-}
-
-//Get the number of satellites used in fix
-uint8_t SFE_UBLOX_GNSS::getSIV(uint16_t maxWait)
-{
-  if (packetUBXNAVPVT == NULL) initPacketUBXNAVPVT(); //Check that RAM has been allocated for the PVT data
-  if (packetUBXNAVPVT == NULL) //Bail if the RAM allocation failed
-    return 0;
-
-  if (packetUBXNAVPVT->moduleQueried.moduleQueried1.bits.numSV == false)
-    getPVT(maxWait);
-  packetUBXNAVPVT->moduleQueried.moduleQueried1.bits.numSV = false; //Since we are about to give this to user, mark this data as stale
-  packetUBXNAVPVT->moduleQueried.moduleQueried1.bits.all = false;
-  return (packetUBXNAVPVT->data.numSV);
-}
-
-//Get the current longitude in degrees
-//Returns a long representing the number of degrees *10^-7
-int32_t SFE_UBLOX_GNSS::getLongitude(uint16_t maxWait)
-{
-  if (packetUBXNAVPVT == NULL) initPacketUBXNAVPVT(); //Check that RAM has been allocated for the PVT data
-  if (packetUBXNAVPVT == NULL) //Bail if the RAM allocation failed
-    return 0;
-
-  if (packetUBXNAVPVT->moduleQueried.moduleQueried1.bits.lon == false)
-    getPVT(maxWait);
-  packetUBXNAVPVT->moduleQueried.moduleQueried1.bits.lon = false; //Since we are about to give this to user, mark this data as stale
-  packetUBXNAVPVT->moduleQueried.moduleQueried1.bits.all = false;
-  return (packetUBXNAVPVT->data.lon);
-}
-
-//Get the current latitude in degrees
-//Returns a long representing the number of degrees *10^-7
-int32_t SFE_UBLOX_GNSS::getLatitude(uint16_t maxWait)
-{
-  if (packetUBXNAVPVT == NULL) initPacketUBXNAVPVT(); //Check that RAM has been allocated for the PVT data
-  if (packetUBXNAVPVT == NULL) //Bail if the RAM allocation failed
-    return 0;
-
-  if (packetUBXNAVPVT->moduleQueried.moduleQueried1.bits.lat == false)
-    getPVT(maxWait);
-  packetUBXNAVPVT->moduleQueried.moduleQueried1.bits.lat = false; //Since we are about to give this to user, mark this data as stale
-  packetUBXNAVPVT->moduleQueried.moduleQueried1.bits.all = false;
-  return (packetUBXNAVPVT->data.lat);
-}
-
-//Get the current altitude in mm according to ellipsoid model
-int32_t SFE_UBLOX_GNSS::getAltitude(uint16_t maxWait)
-{
-  if (packetUBXNAVPVT == NULL) initPacketUBXNAVPVT(); //Check that RAM has been allocated for the PVT data
-  if (packetUBXNAVPVT == NULL) //Bail if the RAM allocation failed
-    return 0;
-
-  if (packetUBXNAVPVT->moduleQueried.moduleQueried1.bits.height == false)
-    getPVT(maxWait);
-  packetUBXNAVPVT->moduleQueried.moduleQueried1.bits.height = false; //Since we are about to give this to user, mark this data as stale
-  packetUBXNAVPVT->moduleQueried.moduleQueried1.bits.all = false;
-  return (packetUBXNAVPVT->data.height);
-}
-
-//Get the current altitude in mm according to mean sea level
-//Ellipsoid model: https://www.esri.com/news/arcuser/0703/geoid1of3.html
-//Difference between Ellipsoid Model and Mean Sea Level: https://eos-gnss.com/elevation-for-beginners/
-int32_t SFE_UBLOX_GNSS::getAltitudeMSL(uint16_t maxWait)
-{
-  if (packetUBXNAVPVT == NULL) initPacketUBXNAVPVT(); //Check that RAM has been allocated for the PVT data
-  if (packetUBXNAVPVT == NULL) //Bail if the RAM allocation failed
-    return 0;
-
-  if (packetUBXNAVPVT->moduleQueried.moduleQueried1.bits.hMSL == false)
-    getPVT(maxWait);
-  packetUBXNAVPVT->moduleQueried.moduleQueried1.bits.hMSL = false; //Since we are about to give this to user, mark this data as stale
-  packetUBXNAVPVT->moduleQueried.moduleQueried1.bits.all = false;
-  return (packetUBXNAVPVT->data.hMSL);
-}
-
-int32_t SFE_UBLOX_GNSS::getHorizontalAccEst(uint16_t maxWait)
-{
-  if (packetUBXNAVPVT == NULL) initPacketUBXNAVPVT(); //Check that RAM has been allocated for the PVT data
-  if (packetUBXNAVPVT == NULL) //Bail if the RAM allocation failed
-    return 0;
-
-  if (packetUBXNAVPVT->moduleQueried.moduleQueried1.bits.hAcc == false)
-    getPVT(maxWait);
-  packetUBXNAVPVT->moduleQueried.moduleQueried1.bits.hAcc = false; //Since we are about to give this to user, mark this data as stale
-  packetUBXNAVPVT->moduleQueried.moduleQueried1.bits.all = false;
-  return (packetUBXNAVPVT->data.hAcc);
-}
-
-int32_t SFE_UBLOX_GNSS::getVerticalAccEst(uint16_t maxWait)
-{
-  if (packetUBXNAVPVT == NULL) initPacketUBXNAVPVT(); //Check that RAM has been allocated for the PVT data
-  if (packetUBXNAVPVT == NULL) //Bail if the RAM allocation failed
-    return 0;
-
-  if (packetUBXNAVPVT->moduleQueried.moduleQueried1.bits.vAcc == false)
-    getPVT(maxWait);
-  packetUBXNAVPVT->moduleQueried.moduleQueried1.bits.vAcc = false; //Since we are about to give this to user, mark this data as stale
-  packetUBXNAVPVT->moduleQueried.moduleQueried1.bits.all = false;
-  return (packetUBXNAVPVT->data.vAcc);
-}
-
-int32_t SFE_UBLOX_GNSS::getNedNorthVel(uint16_t maxWait)
-{
-  if (packetUBXNAVPVT == NULL) initPacketUBXNAVPVT(); //Check that RAM has been allocated for the PVT data
-  if (packetUBXNAVPVT == NULL) //Bail if the RAM allocation failed
-    return 0;
-
-  if (packetUBXNAVPVT->moduleQueried.moduleQueried1.bits.velN == false)
-    getPVT(maxWait);
-  packetUBXNAVPVT->moduleQueried.moduleQueried1.bits.velN = false; //Since we are about to give this to user, mark this data as stale
-  packetUBXNAVPVT->moduleQueried.moduleQueried1.bits.all = false;
-  return (packetUBXNAVPVT->data.velN);
-}
-
-int32_t SFE_UBLOX_GNSS::getNedEastVel(uint16_t maxWait)
-{
-  if (packetUBXNAVPVT == NULL) initPacketUBXNAVPVT(); //Check that RAM has been allocated for the PVT data
-  if (packetUBXNAVPVT == NULL) //Bail if the RAM allocation failed
-    return 0;
-
-  if (packetUBXNAVPVT->moduleQueried.moduleQueried1.bits.velE == false)
-    getPVT(maxWait);
-  packetUBXNAVPVT->moduleQueried.moduleQueried1.bits.velE = false; //Since we are about to give this to user, mark this data as stale
-  packetUBXNAVPVT->moduleQueried.moduleQueried1.bits.all = false;
-  return (packetUBXNAVPVT->data.velE);
-}
-
-int32_t SFE_UBLOX_GNSS::getNedDownVel(uint16_t maxWait)
-{
-  if (packetUBXNAVPVT == NULL) initPacketUBXNAVPVT(); //Check that RAM has been allocated for the PVT data
-  if (packetUBXNAVPVT == NULL) //Bail if the RAM allocation failed
-    return 0;
-
-  if (packetUBXNAVPVT->moduleQueried.moduleQueried2.bits.velD == false)
-    getPVT(maxWait);
-  packetUBXNAVPVT->moduleQueried.moduleQueried2.bits.velD = false; //Since we are about to give this to user, mark this data as stale
-  packetUBXNAVPVT->moduleQueried.moduleQueried1.bits.all = false;
-  return (packetUBXNAVPVT->data.velD);
-}
-
-//Get the ground speed in mm/s
-int32_t SFE_UBLOX_GNSS::getGroundSpeed(uint16_t maxWait)
-{
-  if (packetUBXNAVPVT == NULL) initPacketUBXNAVPVT(); //Check that RAM has been allocated for the PVT data
-  if (packetUBXNAVPVT == NULL) //Bail if the RAM allocation failed
-    return 0;
-
-  if (packetUBXNAVPVT->moduleQueried.moduleQueried2.bits.gSpeed == false)
-    getPVT(maxWait);
-  packetUBXNAVPVT->moduleQueried.moduleQueried2.bits.gSpeed = false; //Since we are about to give this to user, mark this data as stale
-  packetUBXNAVPVT->moduleQueried.moduleQueried1.bits.all = false;
-  return (packetUBXNAVPVT->data.gSpeed);
-}
-
-//Get the heading of motion (as opposed to heading of car) in degrees * 10^-5
-int32_t SFE_UBLOX_GNSS::getHeading(uint16_t maxWait)
-{
-  if (packetUBXNAVPVT == NULL) initPacketUBXNAVPVT(); //Check that RAM has been allocated for the PVT data
-  if (packetUBXNAVPVT == NULL) //Bail if the RAM allocation failed
-    return 0;
-
-  if (packetUBXNAVPVT->moduleQueried.moduleQueried2.bits.headMot == false)
-    getPVT(maxWait);
-  packetUBXNAVPVT->moduleQueried.moduleQueried2.bits.headMot = false; //Since we are about to give this to user, mark this data as stale
-  packetUBXNAVPVT->moduleQueried.moduleQueried1.bits.all = false;
-  return (packetUBXNAVPVT->data.headMot);
-}
-
-uint32_t SFE_UBLOX_GNSS::getSpeedAccEst(uint16_t maxWait)
-{
-  if (packetUBXNAVPVT == NULL) initPacketUBXNAVPVT(); //Check that RAM has been allocated for the PVT data
-  if (packetUBXNAVPVT == NULL) //Bail if the RAM allocation failed
-    return 0;
-
-  if (packetUBXNAVPVT->moduleQueried.moduleQueried2.bits.sAcc == false)
-    getPVT(maxWait);
-  packetUBXNAVPVT->moduleQueried.moduleQueried2.bits.sAcc = false; //Since we are about to give this to user, mark this data as stale
-  packetUBXNAVPVT->moduleQueried.moduleQueried1.bits.all = false;
-  return (packetUBXNAVPVT->data.sAcc);
-}
-
-uint32_t SFE_UBLOX_GNSS::getHeadingAccEst(uint16_t maxWait)
-{
-  if (packetUBXNAVPVT == NULL) initPacketUBXNAVPVT(); //Check that RAM has been allocated for the PVT data
-  if (packetUBXNAVPVT == NULL) //Bail if the RAM allocation failed
-    return 0;
-
-  if (packetUBXNAVPVT->moduleQueried.moduleQueried2.bits.headAcc == false)
-    getPVT(maxWait);
-  packetUBXNAVPVT->moduleQueried.moduleQueried2.bits.headAcc = false; //Since we are about to give this to user, mark this data as stale
-  packetUBXNAVPVT->moduleQueried.moduleQueried1.bits.all = false;
-  return (packetUBXNAVPVT->data.headAcc);
-}
-
-//Get the positional dillution of precision * 10^-2 (dimensionless)
-uint16_t SFE_UBLOX_GNSS::getPDOP(uint16_t maxWait)
-{
-  if (packetUBXNAVPVT == NULL) initPacketUBXNAVPVT(); //Check that RAM has been allocated for the PVT data
-  if (packetUBXNAVPVT == NULL) //Bail if the RAM allocation failed
-    return 0;
-
-  if (packetUBXNAVPVT->moduleQueried.moduleQueried2.bits.pDOP == false)
-    getPVT(maxWait);
-  packetUBXNAVPVT->moduleQueried.moduleQueried2.bits.pDOP = false; //Since we are about to give this to user, mark this data as stale
-  packetUBXNAVPVT->moduleQueried.moduleQueried1.bits.all = false;
-  return (packetUBXNAVPVT->data.pDOP);
-}
-
-bool SFE_UBLOX_GNSS::getInvalidLlh(uint16_t maxWait)
-{
-  if (packetUBXNAVPVT == NULL) initPacketUBXNAVPVT(); //Check that RAM has been allocated for the PVT data
-  if (packetUBXNAVPVT == NULL) //Bail if the RAM allocation failed
-    return (false);
-
-  if (packetUBXNAVPVT->moduleQueried.moduleQueried2.bits.invalidLlh == false)
-    getPVT(maxWait);
-  packetUBXNAVPVT->moduleQueried.moduleQueried2.bits.invalidLlh = false; //Since we are about to give this to user, mark this data as stale
-  packetUBXNAVPVT->moduleQueried.moduleQueried1.bits.all = false;
-  return ((bool)packetUBXNAVPVT->data.flags3.bits.invalidLlh);
-}
-
-int32_t SFE_UBLOX_GNSS::getHeadVeh(uint16_t maxWait)
-{
-  if (packetUBXNAVPVT == NULL) initPacketUBXNAVPVT(); //Check that RAM has been allocated for the PVT data
-  if (packetUBXNAVPVT == NULL) //Bail if the RAM allocation failed
-    return 0;
-
-  if (packetUBXNAVPVT->moduleQueried.moduleQueried2.bits.headVeh == false)
-    getPVT(maxWait);
-  packetUBXNAVPVT->moduleQueried.moduleQueried2.bits.headVeh = false; //Since we are about to give this to user, mark this data as stale
-  packetUBXNAVPVT->moduleQueried.moduleQueried1.bits.all = false;
-  return (packetUBXNAVPVT->data.headVeh);
-}
-
-int16_t SFE_UBLOX_GNSS::getMagDec(uint16_t maxWait)
-{
-  if (packetUBXNAVPVT == NULL) initPacketUBXNAVPVT(); //Check that RAM has been allocated for the PVT data
-  if (packetUBXNAVPVT == NULL) //Bail if the RAM allocation failed
-    return 0;
-
-  if (packetUBXNAVPVT->moduleQueried.moduleQueried2.bits.magDec == false)
-    getPVT(maxWait);
-  packetUBXNAVPVT->moduleQueried.moduleQueried2.bits.magDec = false; //Since we are about to give this to user, mark this data as stale
-  packetUBXNAVPVT->moduleQueried.moduleQueried1.bits.all = false;
-  return (packetUBXNAVPVT->data.magDec);
-}
-
-uint16_t SFE_UBLOX_GNSS::getMagAcc(uint16_t maxWait)
-{
-  if (packetUBXNAVPVT == NULL) initPacketUBXNAVPVT(); //Check that RAM has been allocated for the PVT data
-  if (packetUBXNAVPVT == NULL) //Bail if the RAM allocation failed
-    return 0;
-
-  if (packetUBXNAVPVT->moduleQueried.moduleQueried2.bits.magAcc == false)
-    getPVT(maxWait);
-  packetUBXNAVPVT->moduleQueried.moduleQueried2.bits.magAcc = false; //Since we are about to give this to user, mark this data as stale
-  packetUBXNAVPVT->moduleQueried.moduleQueried1.bits.all = false;
-  return (packetUBXNAVPVT->data.magAcc);
-}
-
-// getGeoidSeparation is currently redundant. The geoid separation seems to only be provided in NMEA GGA and GNS messages.
-int32_t SFE_UBLOX_GNSS::getGeoidSeparation(uint16_t maxWait)
-{
-  return (0);
-}
-
-// ***** HPPOSECEF Helper Functions
-
-//Get the current 3D high precision positional accuracy - a fun thing to watch
-//Returns a long representing the 3D accuracy in millimeters
-uint32_t SFE_UBLOX_GNSS::getPositionAccuracy(uint16_t maxWait)
-{
-  if (packetUBXNAVHPPOSECEF == NULL) initPacketUBXNAVHPPOSECEF(); //Check that RAM has been allocated for the HPPOSECEF data
-  if (packetUBXNAVHPPOSECEF == NULL) //Bail if the RAM allocation failed
-    return 0;
-
-  if (packetUBXNAVHPPOSECEF->moduleQueried.moduleQueried.bits.pAcc == false)
-    getNAVHPPOSECEF(maxWait);
-  packetUBXNAVHPPOSECEF->moduleQueried.moduleQueried.bits.pAcc = false; //Since we are about to give this to user, mark this data as stale
-  packetUBXNAVHPPOSECEF->moduleQueried.moduleQueried.bits.all = false;
-
-  uint32_t tempAccuracy = packetUBXNAVHPPOSECEF->data.pAcc;
-
-  if ((tempAccuracy % 10) >= 5)
-    tempAccuracy += 5; //Round fraction of mm up to next mm if .5 or above
-  tempAccuracy /= 10;  //Convert 0.1mm units to mm
-
-  return (tempAccuracy);
-}
-
-// ***** HPPOSLLH Helper Functions
-
-uint32_t SFE_UBLOX_GNSS::getTimeOfWeekFromHPPOSLLH(uint16_t maxWait)
-{
-  if (packetUBXNAVHPPOSLLH == NULL) initPacketUBXNAVHPPOSLLH(); //Check that RAM has been allocated for the HPPOSLLH data
-  if (packetUBXNAVHPPOSLLH == NULL) //Bail if the RAM allocation failed
-    return 0;
-
-  if (packetUBXNAVHPPOSLLH->moduleQueried.moduleQueried.bits.iTOW == false)
-    getHPPOSLLH(maxWait);
-  packetUBXNAVHPPOSLLH->moduleQueried.moduleQueried.bits.iTOW = false; //Since we are about to give this to user, mark this data as stale
-  packetUBXNAVHPPOSLLH->moduleQueried.moduleQueried.bits.all = false;
-  return (packetUBXNAVHPPOSLLH->data.iTOW);
-}
-
-int32_t SFE_UBLOX_GNSS::getHighResLongitude(uint16_t maxWait)
-{
-  if (packetUBXNAVHPPOSLLH == NULL) initPacketUBXNAVHPPOSLLH(); //Check that RAM has been allocated for the HPPOSLLH data
-  if (packetUBXNAVHPPOSLLH == NULL) //Bail if the RAM allocation failed
-    return 0;
-
-  if (packetUBXNAVHPPOSLLH->moduleQueried.moduleQueried.bits.lon == false)
-    getHPPOSLLH(maxWait);
-  packetUBXNAVHPPOSLLH->moduleQueried.moduleQueried.bits.lon = false; //Since we are about to give this to user, mark this data as stale
-  packetUBXNAVHPPOSLLH->moduleQueried.moduleQueried.bits.all = false;
-  return (packetUBXNAVHPPOSLLH->data.lon);
-}
-
-int32_t SFE_UBLOX_GNSS::getHighResLatitude(uint16_t maxWait)
-{
-  if (packetUBXNAVHPPOSLLH == NULL) initPacketUBXNAVHPPOSLLH(); //Check that RAM has been allocated for the HPPOSLLH data
-  if (packetUBXNAVHPPOSLLH == NULL) //Bail if the RAM allocation failed
-    return 0;
-
-  if (packetUBXNAVHPPOSLLH->moduleQueried.moduleQueried.bits.lat == false)
-    getHPPOSLLH(maxWait);
-  packetUBXNAVHPPOSLLH->moduleQueried.moduleQueried.bits.lat = false; //Since we are about to give this to user, mark this data as stale
-  packetUBXNAVHPPOSLLH->moduleQueried.moduleQueried.bits.all = false;
-  return (packetUBXNAVHPPOSLLH->data.lat);
-}
-
-int32_t SFE_UBLOX_GNSS::getElipsoid(uint16_t maxWait)
-{
-  if (packetUBXNAVHPPOSLLH == NULL) initPacketUBXNAVHPPOSLLH(); //Check that RAM has been allocated for the HPPOSLLH data
-  if (packetUBXNAVHPPOSLLH == NULL) //Bail if the RAM allocation failed
-    return 0;
-
-  if (packetUBXNAVHPPOSLLH->moduleQueried.moduleQueried.bits.height == false)
-    getHPPOSLLH(maxWait);
-  packetUBXNAVHPPOSLLH->moduleQueried.moduleQueried.bits.height = false; //Since we are about to give this to user, mark this data as stale
-  packetUBXNAVHPPOSLLH->moduleQueried.moduleQueried.bits.all = false;
-  return (packetUBXNAVHPPOSLLH->data.height);
-}
-
-int32_t SFE_UBLOX_GNSS::getMeanSeaLevel(uint16_t maxWait)
-{
-  if (packetUBXNAVHPPOSLLH == NULL) initPacketUBXNAVHPPOSLLH(); //Check that RAM has been allocated for the HPPOSLLH data
-  if (packetUBXNAVHPPOSLLH == NULL) //Bail if the RAM allocation failed
-    return 0;
-
-  if (packetUBXNAVHPPOSLLH->moduleQueried.moduleQueried.bits.hMSL == false)
-    getHPPOSLLH(maxWait);
-  packetUBXNAVHPPOSLLH->moduleQueried.moduleQueried.bits.hMSL = false; //Since we are about to give this to user, mark this data as stale
-  packetUBXNAVHPPOSLLH->moduleQueried.moduleQueried.bits.all = false;
-  return (packetUBXNAVHPPOSLLH->data.hMSL);
-}
-
-int8_t SFE_UBLOX_GNSS::getHighResLongitudeHp(uint16_t maxWait)
-{
-  if (packetUBXNAVHPPOSLLH == NULL) initPacketUBXNAVHPPOSLLH(); //Check that RAM has been allocated for the HPPOSLLH data
-  if (packetUBXNAVHPPOSLLH == NULL) //Bail if the RAM allocation failed
-    return 0;
-
-  if (packetUBXNAVHPPOSLLH->moduleQueried.moduleQueried.bits.lonHp == false)
-    getHPPOSLLH(maxWait);
-  packetUBXNAVHPPOSLLH->moduleQueried.moduleQueried.bits.lonHp = false; //Since we are about to give this to user, mark this data as stale
-  packetUBXNAVHPPOSLLH->moduleQueried.moduleQueried.bits.all = false;
-  return (packetUBXNAVHPPOSLLH->data.lonHp);
-}
-
-int8_t SFE_UBLOX_GNSS::getHighResLatitudeHp(uint16_t maxWait)
-{
-  if (packetUBXNAVHPPOSLLH == NULL) initPacketUBXNAVHPPOSLLH(); //Check that RAM has been allocated for the HPPOSLLH data
-  if (packetUBXNAVHPPOSLLH == NULL) //Bail if the RAM allocation failed
-    return 0;
-
-  if (packetUBXNAVHPPOSLLH->moduleQueried.moduleQueried.bits.latHp == false)
-    getHPPOSLLH(maxWait);
-  packetUBXNAVHPPOSLLH->moduleQueried.moduleQueried.bits.latHp = false; //Since we are about to give this to user, mark this data as stale
-  packetUBXNAVHPPOSLLH->moduleQueried.moduleQueried.bits.all = false;
-  return (packetUBXNAVHPPOSLLH->data.latHp);
-}
-
-int8_t SFE_UBLOX_GNSS::getElipsoidHp(uint16_t maxWait)
-{
-  if (packetUBXNAVHPPOSLLH == NULL) initPacketUBXNAVHPPOSLLH(); //Check that RAM has been allocated for the HPPOSLLH data
-  if (packetUBXNAVHPPOSLLH == NULL) //Bail if the RAM allocation failed
-    return 0;
-
-  if (packetUBXNAVHPPOSLLH->moduleQueried.moduleQueried.bits.heightHp == false)
-    getHPPOSLLH(maxWait);
-  packetUBXNAVHPPOSLLH->moduleQueried.moduleQueried.bits.heightHp = false; //Since we are about to give this to user, mark this data as stale
-  packetUBXNAVHPPOSLLH->moduleQueried.moduleQueried.bits.all = false;
-  return (packetUBXNAVHPPOSLLH->data.heightHp);
-}
-
-int8_t SFE_UBLOX_GNSS::getMeanSeaLevelHp(uint16_t maxWait)
-{
-  if (packetUBXNAVHPPOSLLH == NULL) initPacketUBXNAVHPPOSLLH(); //Check that RAM has been allocated for the HPPOSLLH data
-  if (packetUBXNAVHPPOSLLH == NULL) //Bail if the RAM allocation failed
-    return 0;
-
-  if (packetUBXNAVHPPOSLLH->moduleQueried.moduleQueried.bits.hMSLHp == false)
-    getHPPOSLLH(maxWait);
-  packetUBXNAVHPPOSLLH->moduleQueried.moduleQueried.bits.hMSLHp = false; //Since we are about to give this to user, mark this data as stale
-  packetUBXNAVHPPOSLLH->moduleQueried.moduleQueried.bits.all = false;
-  return (packetUBXNAVHPPOSLLH->data.hMSLHp);
-}
-
-uint32_t SFE_UBLOX_GNSS::getHorizontalAccuracy(uint16_t maxWait)
-{
-  if (packetUBXNAVHPPOSLLH == NULL) initPacketUBXNAVHPPOSLLH(); //Check that RAM has been allocated for the HPPOSLLH data
-  if (packetUBXNAVHPPOSLLH == NULL) //Bail if the RAM allocation failed
-    return 0;
-
-  if (packetUBXNAVHPPOSLLH->moduleQueried.moduleQueried.bits.hAcc == false)
-    getHPPOSLLH(maxWait);
-  packetUBXNAVHPPOSLLH->moduleQueried.moduleQueried.bits.hAcc = false; //Since we are about to give this to user, mark this data as stale
-  packetUBXNAVHPPOSLLH->moduleQueried.moduleQueried.bits.all = false;
-  return (packetUBXNAVHPPOSLLH->data.hAcc);
-}
-
-uint32_t SFE_UBLOX_GNSS::getVerticalAccuracy(uint16_t maxWait)
-{
-  if (packetUBXNAVHPPOSLLH == NULL) initPacketUBXNAVHPPOSLLH(); //Check that RAM has been allocated for the HPPOSLLH data
-  if (packetUBXNAVHPPOSLLH == NULL) //Bail if the RAM allocation failed
-    return 0;
-
-  if (packetUBXNAVHPPOSLLH->moduleQueried.moduleQueried.bits.vAcc == false)
-    getHPPOSLLH(maxWait);
-  packetUBXNAVHPPOSLLH->moduleQueried.moduleQueried.bits.vAcc = false; //Since we are about to give this to user, mark this data as stale
-  packetUBXNAVHPPOSLLH->moduleQueried.moduleQueried.bits.all = false;
-  return (packetUBXNAVHPPOSLLH->data.vAcc);
-}
-
-// ***** SVIN Helper Functions
-
-boolean SFE_UBLOX_GNSS::getSurveyInActive(uint16_t maxWait)
-{
-  if (packetUBXNAVSVIN == NULL) initPacketUBXNAVSVIN(); //Check that RAM has been allocated for the SVIN data
-  if (packetUBXNAVSVIN == NULL) //Bail if the RAM allocation failed
-    return false;
-
-  if (packetUBXNAVSVIN->moduleQueried.moduleQueried.bits.active == false)
-    getSurveyStatus(maxWait);
-  packetUBXNAVSVIN->moduleQueried.moduleQueried.bits.active = false; //Since we are about to give this to user, mark this data as stale
-  packetUBXNAVSVIN->moduleQueried.moduleQueried.bits.all = false;
-  return ((boolean)packetUBXNAVSVIN->data.active);
-}
-
-boolean SFE_UBLOX_GNSS::getSurveyInValid(uint16_t maxWait)
-{
-  if (packetUBXNAVSVIN == NULL) initPacketUBXNAVSVIN(); //Check that RAM has been allocated for the SVIN data
-  if (packetUBXNAVSVIN == NULL) //Bail if the RAM allocation failed
-    return false;
-
-  if (packetUBXNAVSVIN->moduleQueried.moduleQueried.bits.valid == false)
-    getSurveyStatus(maxWait);
-  packetUBXNAVSVIN->moduleQueried.moduleQueried.bits.valid = false; //Since we are about to give this to user, mark this data as stale
-  packetUBXNAVSVIN->moduleQueried.moduleQueried.bits.all = false;
-  return ((boolean)packetUBXNAVSVIN->data.valid);
-}
-
-uint16_t SFE_UBLOX_GNSS::getSurveyInObservationTime(uint16_t maxWait) // Truncated to 65535 seconds
-{
-  if (packetUBXNAVSVIN == NULL) initPacketUBXNAVSVIN(); //Check that RAM has been allocated for the SVIN data
-  if (packetUBXNAVSVIN == NULL) //Bail if the RAM allocation failed
-    return 0;
-
-  if (packetUBXNAVSVIN->moduleQueried.moduleQueried.bits.dur == false)
-    getSurveyStatus(maxWait);
-  packetUBXNAVSVIN->moduleQueried.moduleQueried.bits.dur = false; //Since we are about to give this to user, mark this data as stale
-  packetUBXNAVSVIN->moduleQueried.moduleQueried.bits.all = false;
-
-  //dur (Passed survey-in observation time) is U4 (uint32_t) seconds. We truncate to 16 bits
-  //(waiting more than 65535 seconds (18.2 hours) seems excessive!)
-  uint32_t tmpObsTime = packetUBXNAVSVIN->data.dur;
-  if (tmpObsTime <= 0xFFFF)
-  {
-    return((uint16_t)tmpObsTime);
-  }
-  else
-  {
-    return(0xFFFF);
-  }
-}
-
-float SFE_UBLOX_GNSS::getSurveyInMeanAccuracy(uint16_t maxWait) // Returned as m
-{
-  if (packetUBXNAVSVIN == NULL) initPacketUBXNAVSVIN(); //Check that RAM has been allocated for the SVIN data
-  if (packetUBXNAVSVIN == NULL) //Bail if the RAM allocation failed
-    return 0;
-
-  if (packetUBXNAVSVIN->moduleQueried.moduleQueried.bits.meanAcc == false)
-    getSurveyStatus(maxWait);
-  packetUBXNAVSVIN->moduleQueried.moduleQueried.bits.meanAcc = false; //Since we are about to give this to user, mark this data as stale
-  packetUBXNAVSVIN->moduleQueried.moduleQueried.bits.all = false;
-
-  // meanAcc is U4 (uint32_t) in 0.1mm. We convert this to float.
-  uint32_t tempFloat = packetUBXNAVSVIN->data.meanAcc;
-  return (((float)tempFloat) / 10000.0); //Convert 0.1mm to m
-}
-
-// ***** RELPOSNED Helper Functions and automatic support
-
-float SFE_UBLOX_GNSS::getRelPosN(uint16_t maxWait) // Returned as m
-{
-  if (packetUBXNAVRELPOSNED == NULL) initPacketUBXNAVRELPOSNED(); //Check that RAM has been allocated for the RELPOSNED data
-  if (packetUBXNAVRELPOSNED == NULL) //Bail if the RAM allocation failed
-    return 0;
-
-  if (packetUBXNAVRELPOSNED->moduleQueried.moduleQueried.bits.relPosN == false)
-    getRELPOSNED(maxWait);
-  packetUBXNAVRELPOSNED->moduleQueried.moduleQueried.bits.relPosN = false; //Since we are about to give this to user, mark this data as stale
-  packetUBXNAVRELPOSNED->moduleQueried.moduleQueried.bits.all = false;
-  return (((float)packetUBXNAVRELPOSNED->data.relPosN) / 100.0); // Convert to m
-}
-
-float SFE_UBLOX_GNSS::getRelPosE(uint16_t maxWait) // Returned as m
-{
-  if (packetUBXNAVRELPOSNED == NULL) initPacketUBXNAVRELPOSNED(); //Check that RAM has been allocated for the RELPOSNED data
-  if (packetUBXNAVRELPOSNED == NULL) //Bail if the RAM allocation failed
-    return 0;
-
-  if (packetUBXNAVRELPOSNED->moduleQueried.moduleQueried.bits.relPosE == false)
-    getRELPOSNED(maxWait);
-  packetUBXNAVRELPOSNED->moduleQueried.moduleQueried.bits.relPosE = false; //Since we are about to give this to user, mark this data as stale
-  packetUBXNAVRELPOSNED->moduleQueried.moduleQueried.bits.all = false;
-  return (((float)packetUBXNAVRELPOSNED->data.relPosE) / 100.0); // Convert to m
-}
-
-float SFE_UBLOX_GNSS::getRelPosD(uint16_t maxWait) // Returned as m
-{
-  if (packetUBXNAVRELPOSNED == NULL) initPacketUBXNAVRELPOSNED(); //Check that RAM has been allocated for the RELPOSNED data
-  if (packetUBXNAVRELPOSNED == NULL) //Bail if the RAM allocation failed
-    return 0;
-
-  if (packetUBXNAVRELPOSNED->moduleQueried.moduleQueried.bits.relPosD == false)
-    getRELPOSNED(maxWait);
-  packetUBXNAVRELPOSNED->moduleQueried.moduleQueried.bits.relPosD = false; //Since we are about to give this to user, mark this data as stale
-  packetUBXNAVRELPOSNED->moduleQueried.moduleQueried.bits.all = false;
-  return (((float)packetUBXNAVRELPOSNED->data.relPosD) / 100.0); // Convert to m
-}
-
-float SFE_UBLOX_GNSS::getRelPosAccN(uint16_t maxWait) // Returned as m
-{
-  if (packetUBXNAVRELPOSNED == NULL) initPacketUBXNAVRELPOSNED(); //Check that RAM has been allocated for the RELPOSNED data
-  if (packetUBXNAVRELPOSNED == NULL) //Bail if the RAM allocation failed
-    return 0;
-
-  if (packetUBXNAVRELPOSNED->moduleQueried.moduleQueried.bits.accN == false)
-    getRELPOSNED(maxWait);
-  packetUBXNAVRELPOSNED->moduleQueried.moduleQueried.bits.accN = false; //Since we are about to give this to user, mark this data as stale
-  packetUBXNAVRELPOSNED->moduleQueried.moduleQueried.bits.all = false;
-  return (((float)packetUBXNAVRELPOSNED->data.accN) / 10000.0); // Convert to m
-}
-
-float SFE_UBLOX_GNSS::getRelPosAccE(uint16_t maxWait) // Returned as m
-{
-  if (packetUBXNAVRELPOSNED == NULL) initPacketUBXNAVRELPOSNED(); //Check that RAM has been allocated for the RELPOSNED data
-  if (packetUBXNAVRELPOSNED == NULL) //Bail if the RAM allocation failed
-    return 0;
-
-  if (packetUBXNAVRELPOSNED->moduleQueried.moduleQueried.bits.accE == false)
-    getRELPOSNED(maxWait);
-  packetUBXNAVRELPOSNED->moduleQueried.moduleQueried.bits.accE = false; //Since we are about to give this to user, mark this data as stale
-  packetUBXNAVRELPOSNED->moduleQueried.moduleQueried.bits.all = false;
-  return (((float)packetUBXNAVRELPOSNED->data.accE) / 10000.0); // Convert to m
-}
-
-float SFE_UBLOX_GNSS::getRelPosAccD(uint16_t maxWait) // Returned as m
-{
-  if (packetUBXNAVRELPOSNED == NULL) initPacketUBXNAVRELPOSNED(); //Check that RAM has been allocated for the RELPOSNED data
-  if (packetUBXNAVRELPOSNED == NULL) //Bail if the RAM allocation failed
-    return 0;
-
-  if (packetUBXNAVRELPOSNED->moduleQueried.moduleQueried.bits.accD == false)
-    getRELPOSNED(maxWait);
-  packetUBXNAVRELPOSNED->moduleQueried.moduleQueried.bits.accD = false; //Since we are about to give this to user, mark this data as stale
-  packetUBXNAVRELPOSNED->moduleQueried.moduleQueried.bits.all = false;
-  return (((float)packetUBXNAVRELPOSNED->data.accD) / 10000.0); // Convert to m
-}
-
-// ***** ESF Helper Functions
-
-float SFE_UBLOX_GNSS::getESFroll(uint16_t maxWait) // Returned as degrees
-{
-  if (packetUBXESFALG == NULL) initPacketUBXESFALG(); //Check that RAM has been allocated for the ESF ALG data
-  if (packetUBXESFALG == NULL) //Bail if the RAM allocation failed
-    return (0);
-
-  if (packetUBXESFALG->moduleQueried.moduleQueried.bits.roll == false)
-    getESFALG(maxWait);
-  packetUBXESFALG->moduleQueried.moduleQueried.bits.roll = false; //Since we are about to give this to user, mark this data as stale
-  packetUBXESFALG->moduleQueried.moduleQueried.bits.all = false;
-  return (((float)packetUBXESFALG->data.roll) / 100.0); // Convert to degrees
-}
-
-float SFE_UBLOX_GNSS::getESFpitch(uint16_t maxWait) // Returned as degrees
-{
-  if (packetUBXESFALG == NULL) initPacketUBXESFALG(); //Check that RAM has been allocated for the ESF ALG data
-  if (packetUBXESFALG == NULL) //Bail if the RAM allocation failed
-    return (0);
-
-  if (packetUBXESFALG->moduleQueried.moduleQueried.bits.pitch == false)
-    getESFALG(maxWait);
-  packetUBXESFALG->moduleQueried.moduleQueried.bits.pitch = false; //Since we are about to give this to user, mark this data as stale
-  packetUBXESFALG->moduleQueried.moduleQueried.bits.all = false;
-  return (((float)packetUBXESFALG->data.pitch) / 100.0); // Convert to degrees
-}
-
-float SFE_UBLOX_GNSS::getESFyaw(uint16_t maxWait) // Returned as degrees
-{
-  if (packetUBXESFALG == NULL) initPacketUBXESFALG(); //Check that RAM has been allocated for the ESF ALG data
-  if (packetUBXESFALG == NULL) //Bail if the RAM allocation failed
-    return (0);
-
-  if (packetUBXESFALG->moduleQueried.moduleQueried.bits.yaw == false)
-    getESFALG(maxWait);
-  packetUBXESFALG->moduleQueried.moduleQueried.bits.yaw = false; //Since we are about to give this to user, mark this data as stale
-  packetUBXESFALG->moduleQueried.moduleQueried.bits.all = false;
-  return (((float)packetUBXESFALG->data.yaw) / 100.0); // Convert to degrees
-}
-
-boolean SFE_UBLOX_GNSS::getSensorFusionMeasurement(UBX_ESF_MEAS_sensorData_t *sensorData, uint8_t sensor, uint16_t maxWait)
-{
-  if (packetUBXESFMEAS == NULL) initPacketUBXESFMEAS(); //Check that RAM has been allocated for the ESF MEAS data
-  if (packetUBXESFMEAS == NULL) //Bail if the RAM allocation failed
-    return (false);
-
-  if (packetUBXESFMEAS->moduleQueried.moduleQueried.bits.data & ((1 << sensor) == 0))
-    getESFMEAS(maxWait);
-  packetUBXESFMEAS->moduleQueried.moduleQueried.bits.data &= ~(1 << sensor); //Since we are about to give this to user, mark this data as stale
-  packetUBXESFMEAS->moduleQueried.moduleQueried.bits.all = false;
-  sensorData->data.all = packetUBXESFMEAS->data.data[sensor].data.all;
-  return (true);
-}
-
-boolean SFE_UBLOX_GNSS::getSensorFusionMeasurement(UBX_ESF_MEAS_sensorData_t *sensorData, UBX_ESF_MEAS_data_t ubxDataStruct, uint8_t sensor)
-{
-  sensorData->data.all = ubxDataStruct.data[sensor].data.all;
-  return (true);
-}
-
-boolean SFE_UBLOX_GNSS::getRawSensorMeasurement(UBX_ESF_RAW_sensorData_t *sensorData, uint8_t sensor, uint16_t maxWait)
-{
-  if (packetUBXESFRAW == NULL) initPacketUBXESFRAW(); //Check that RAM has been allocated for the ESF RAW data
-  if (packetUBXESFRAW == NULL) //Bail if the RAM allocation failed
-    return (false);
-
-  if (packetUBXESFRAW->moduleQueried.moduleQueried.bits.data & ((1 << sensor) == 0))
-    getESFRAW(maxWait);
-  packetUBXESFRAW->moduleQueried.moduleQueried.bits.data &= ~(1 << sensor); //Since we are about to give this to user, mark this data as stale
-  packetUBXESFRAW->moduleQueried.moduleQueried.bits.all = false;
-  sensorData->data.all = packetUBXESFRAW->data.data[sensor].data.all;
-  sensorData->sTag = packetUBXESFRAW->data.data[sensor].sTag;
-  return (true);
-}
-
-boolean SFE_UBLOX_GNSS::getRawSensorMeasurement(UBX_ESF_RAW_sensorData_t *sensorData, UBX_ESF_RAW_data_t ubxDataStruct, uint8_t sensor)
-{
-  sensorData->data.all = ubxDataStruct.data[sensor].data.all;
-  sensorData->sTag = ubxDataStruct.data[sensor].sTag;
-  return (true);
-}
-
-boolean SFE_UBLOX_GNSS::getSensorFusionStatus(UBX_ESF_STATUS_sensorStatus_t *sensorStatus, uint8_t sensor, uint16_t maxWait)
-{
-  if (packetUBXESFSTATUS == NULL) initPacketUBXESFSTATUS(); //Check that RAM has been allocated for the ESF STATUS data
-  if (packetUBXESFSTATUS == NULL) //Bail if the RAM allocation failed
-    return (false);
-
-  if (packetUBXESFSTATUS->moduleQueried.moduleQueried.bits.status & ((1 << sensor) == 0))
-    getESFSTATUS(maxWait);
-  packetUBXESFSTATUS->moduleQueried.moduleQueried.bits.status &= ~(1 << sensor); //Since we are about to give this to user, mark this data as stale
-  packetUBXESFSTATUS->moduleQueried.moduleQueried.bits.all = false;
-  sensorStatus->sensStatus1.all = packetUBXESFSTATUS->data.status[sensor].sensStatus1.all;
-  sensorStatus->sensStatus2.all = packetUBXESFSTATUS->data.status[sensor].sensStatus2.all;
-  sensorStatus->freq = packetUBXESFSTATUS->data.status[sensor].freq;
-  sensorStatus->faults.all = packetUBXESFSTATUS->data.status[sensor].faults.all;
-  return (true);
-}
-
-boolean SFE_UBLOX_GNSS::getSensorFusionStatus(UBX_ESF_STATUS_sensorStatus_t *sensorStatus, UBX_ESF_STATUS_data_t ubxDataStruct, uint8_t sensor)
-{
-  sensorStatus->sensStatus1.all = ubxDataStruct.status[sensor].sensStatus1.all;
-  sensorStatus->sensStatus2.all = ubxDataStruct.status[sensor].sensStatus2.all;
-  sensorStatus->freq = ubxDataStruct.status[sensor].freq;
-  sensorStatus->faults.all = ubxDataStruct.status[sensor].faults.all;
-  return (true);
-}
-
-// ***** HNR Helper Functions
-
-// Set the High Navigation Rate
-// Returns true if the setHNRNavigationRate is successful
-boolean SFE_UBLOX_GNSS::setHNRNavigationRate(uint8_t rate, uint16_t maxWait)
-{
-  packetCfg.cls = UBX_CLASS_CFG;
-  packetCfg.id = UBX_CFG_HNR;
-  packetCfg.len = 0;
-  packetCfg.startingSpot = 0;
-
-  //Ask module for the current HNR settings. Loads into payloadCfg.
-  if (sendCommand(&packetCfg, maxWait) != SFE_UBLOX_STATUS_DATA_RECEIVED)
-    return (false);
-
-  //Load the new navigation rate into payloadCfg
-  payloadCfg[0] = rate;
-
-  //Update the navigation rate
-  sfe_ublox_status_e result = sendCommand(&packetCfg, maxWait); // We are only expecting an ACK
-
-  //Adjust the I2C polling timeout based on update rate
-  if (result == SFE_UBLOX_STATUS_DATA_SENT)
-    i2cPollingWait = 1000 / (((int)rate) * 4); //This is the number of ms to wait between checks for new I2C data
-
-  return (result == SFE_UBLOX_STATUS_DATA_SENT);
-}
-
-// Get the High Navigation Rate
-// Returns 0 if the getHNRNavigationRate fails
-uint8_t SFE_UBLOX_GNSS::getHNRNavigationRate(uint16_t maxWait)
-{
-  packetCfg.cls = UBX_CLASS_CFG;
-  packetCfg.id = UBX_CFG_HNR;
-  packetCfg.len = 0;
-  packetCfg.startingSpot = 0;
-
-  //Ask module for the current HNR settings. Loads into payloadCfg.
-  if (sendCommand(&packetCfg, maxWait) != SFE_UBLOX_STATUS_DATA_RECEIVED)
-    return (0);
-
-  //Return the navigation rate
-  return (payloadCfg[0]);
-}
-
-float SFE_UBLOX_GNSS::getHNRroll(uint16_t maxWait) // Returned as degrees
-{
-  if (packetUBXHNRATT == NULL) initPacketUBXHNRATT(); //Check that RAM has been allocated for the HNR ATT data
-  if (packetUBXHNRATT == NULL) //Bail if the RAM allocation failed
-    return (0);
-
-  if (packetUBXHNRATT->moduleQueried.moduleQueried.bits.roll == false)
-    getHNRATT(maxWait);
-  packetUBXHNRATT->moduleQueried.moduleQueried.bits.roll = false; //Since we are about to give this to user, mark this data as stale
-  packetUBXHNRATT->moduleQueried.moduleQueried.bits.all = false;
-  return (((float)packetUBXHNRATT->data.roll) / 100000.0); // Convert to degrees
-}
-
-float SFE_UBLOX_GNSS::getHNRpitch(uint16_t maxWait) // Returned as degrees
-{
-  if (packetUBXHNRATT == NULL) initPacketUBXHNRATT(); //Check that RAM has been allocated for the HNR ATT data
-  if (packetUBXHNRATT == NULL) //Bail if the RAM allocation failed
-    return (0);
-
-  if (packetUBXHNRATT->moduleQueried.moduleQueried.bits.pitch == false)
-    getHNRATT(maxWait);
-  packetUBXHNRATT->moduleQueried.moduleQueried.bits.pitch = false; //Since we are about to give this to user, mark this data as stale
-  packetUBXHNRATT->moduleQueried.moduleQueried.bits.all = false;
-  return (((float)packetUBXHNRATT->data.pitch) / 100000.0); // Convert to degrees
-}
-
-float SFE_UBLOX_GNSS::getHNRheading(uint16_t maxWait) // Returned as degrees
-{
-  if (packetUBXHNRATT == NULL) initPacketUBXHNRATT(); //Check that RAM has been allocated for the HNR ATT data
-  if (packetUBXHNRATT == NULL) //Bail if the RAM allocation failed
-    return (0);
-
-  if (packetUBXHNRATT->moduleQueried.moduleQueried.bits.heading == false)
-    getHNRATT(maxWait);
-  packetUBXHNRATT->moduleQueried.moduleQueried.bits.heading = false; //Since we are about to give this to user, mark this data as stale
-  packetUBXHNRATT->moduleQueried.moduleQueried.bits.all = false;
-  return (((float)packetUBXHNRATT->data.heading) / 100000.0); // Convert to degrees
-}
-
-// Functions to extract signed and unsigned 8/16/32-bit data from a ubxPacket
-// From v2.0: These are public. The user can call these to extract data from custom packets
-
-//Given a spot in the payload array, extract four bytes and build a long
-uint32_t SFE_UBLOX_GNSS::extractLong(ubxPacket *msg, uint8_t spotToStart)
-{
-  uint32_t val = 0;
-  val |= (uint32_t)msg->payload[spotToStart + 0] << 8 * 0;
-  val |= (uint32_t)msg->payload[spotToStart + 1] << 8 * 1;
-  val |= (uint32_t)msg->payload[spotToStart + 2] << 8 * 2;
-  val |= (uint32_t)msg->payload[spotToStart + 3] << 8 * 3;
-  return (val);
-}
-
-//Just so there is no ambiguity about whether a uint32_t will cast to a int32_t correctly...
-int32_t SFE_UBLOX_GNSS::extractSignedLong(ubxPacket *msg, uint8_t spotToStart)
-{
-  union // Use a union to convert from uint32_t to int32_t
-  {
-      uint32_t unsignedLong;
-      int32_t signedLong;
-  } unsignedSigned;
-
-  unsignedSigned.unsignedLong = extractLong(msg, spotToStart);
-  return (unsignedSigned.signedLong);
-}
-
-//Given a spot in the payload array, extract two bytes and build an int
-uint16_t SFE_UBLOX_GNSS::extractInt(ubxPacket *msg, uint8_t spotToStart)
-{
-  uint16_t val = 0;
-  val |= (uint16_t)msg->payload[spotToStart + 0] << 8 * 0;
-  val |= (uint16_t)msg->payload[spotToStart + 1] << 8 * 1;
-  return (val);
-}
-
-//Just so there is no ambiguity about whether a uint16_t will cast to a int16_t correctly...
-int16_t SFE_UBLOX_GNSS::extractSignedInt(ubxPacket *msg, int8_t spotToStart)
-{
-  union // Use a union to convert from uint16_t to int16_t
-  {
-      uint16_t unsignedInt;
-      int16_t signedInt;
-  } stSignedInt;
-
-  stSignedInt.unsignedInt = extractInt(msg, spotToStart);
-  return (stSignedInt.signedInt);
-}
-
-//Given a spot, extract a byte from the payload
-uint8_t SFE_UBLOX_GNSS::extractByte(ubxPacket *msg, uint8_t spotToStart)
-{
-  return (msg->payload[spotToStart]);
-}
-
-//Given a spot, extract a signed 8-bit value from the payload
-int8_t SFE_UBLOX_GNSS::extractSignedChar(ubxPacket *msg, uint8_t spotToStart)
-{
-  union // Use a union to convert from uint8_t to int8_t
-  {
-      uint8_t unsignedByte;
-      int8_t signedByte;
-  } stSignedByte;
-
-  stSignedByte.unsignedByte = extractByte(msg, spotToStart);
-  return (stSignedByte.signedByte);
-}
diff --git a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/src/SparkFun_u-blox_GNSS_Arduino_Library.h b/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/src/SparkFun_u-blox_GNSS_Arduino_Library.h
deleted file mode 100644
index 8e8ab2d..0000000
--- a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/src/SparkFun_u-blox_GNSS_Arduino_Library.h
+++ /dev/null
@@ -1,1240 +0,0 @@
-/*
-	This is a library written for the u-blox ZED-F9P and NEO-M8P-2
-	SparkFun sells these at its website: www.sparkfun.com
-	Do you like this library? Help support SparkFun. Buy a board!
-	https://www.sparkfun.com/products/16481
-	https://www.sparkfun.com/products/15136
-	https://www.sparkfun.com/products/15005
-	https://www.sparkfun.com/products/15733
-	https://www.sparkfun.com/products/15193
-	https://www.sparkfun.com/products/15210
-
-	Original version by Nathan Seidle @ SparkFun Electronics, September 6th, 2018
-	v2.0 rework by Paul Clark @ SparkFun Electronics, December 31st, 2020
-
-	This library handles configuring and handling the responses
-	from a u-blox GPS module. Works with most modules from u-blox including
-	the Zed-F9P, NEO-M8P-2, NEO-M9N, ZOE-M8Q, SAM-M8Q, and many others.
-
-	https://github.com/sparkfun/SparkFun_Ublox_Arduino_Library
-
-	Development environment specifics:
-	Arduino IDE 1.8.13
-
-	SparkFun code, firmware, and software is released under the MIT License(http://opensource.org/licenses/MIT).
-	The MIT License (MIT)
-	Copyright (c) 2016 SparkFun Electronics
-	Permission is hereby granted, free of charge, to any person obtaining a copy of this software and
-	associated documentation files (the "Software"), to deal in the Software without restriction,
-	including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
-	and/or sell copies of the Software, and to permit persons to whom the Software is furnished to
-	do so, subject to the following conditions:
-
-	The above copyright notice and this permission notice shall be included in all copies or substantial
-	portions of the Software.
-
-	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT
-	NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
-	IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
-	WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
-	SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-*/
-
-#ifndef SPARKFUN_UBLOX_ARDUINO_LIBRARY_H
-#define SPARKFUN_UBLOX_ARDUINO_LIBRARY_H
-
-#if (ARDUINO >= 100)
-#include "Arduino.h"
-#else
-#include "WProgram.h"
-#endif
-
-#include <Wire.h>
-
-#include "u-blox_config_keys.h"
-#include "u-blox_structs.h"
-
-//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
-
-//Define a digital pin to aid debugging
-//Leave set to -1 if not needed
-const int debugPin = -1;
-
-// Global Status Returns
-typedef enum
-{
-	SFE_UBLOX_STATUS_SUCCESS,
-	SFE_UBLOX_STATUS_FAIL,
-	SFE_UBLOX_STATUS_CRC_FAIL,
-	SFE_UBLOX_STATUS_TIMEOUT,
-	SFE_UBLOX_STATUS_COMMAND_NACK, // Indicates that the command was unrecognised, invalid or that the module is too busy to respond
-	SFE_UBLOX_STATUS_OUT_OF_RANGE,
-	SFE_UBLOX_STATUS_INVALID_ARG,
-	SFE_UBLOX_STATUS_INVALID_OPERATION,
-	SFE_UBLOX_STATUS_MEM_ERR,
-	SFE_UBLOX_STATUS_HW_ERR,
-	SFE_UBLOX_STATUS_DATA_SENT,		// This indicates that a 'set' was successful
-	SFE_UBLOX_STATUS_DATA_RECEIVED, // This indicates that a 'get' (poll) was successful
-	SFE_UBLOX_STATUS_I2C_COMM_FAILURE,
-	SFE_UBLOX_STATUS_DATA_OVERWRITTEN // This is an error - the data was valid but has been or _is being_ overwritten by another packet
-} sfe_ublox_status_e;
-
-// ubxPacket validity
-typedef enum
-{
-	SFE_UBLOX_PACKET_VALIDITY_NOT_VALID,
-	SFE_UBLOX_PACKET_VALIDITY_VALID,
-	SFE_UBLOX_PACKET_VALIDITY_NOT_DEFINED,
-	SFE_UBLOX_PACKET_NOTACKNOWLEDGED // This indicates that we received a NACK
-} sfe_ublox_packet_validity_e;
-
-// Identify which packet buffer is in use:
-// packetCfg (or a custom packet), packetAck or packetBuf
-// packetAuto is used to store expected "automatic" messages
-typedef enum
-{
-	SFE_UBLOX_PACKET_PACKETCFG,
-	SFE_UBLOX_PACKET_PACKETACK,
-	SFE_UBLOX_PACKET_PACKETBUF,
-	SFE_UBLOX_PACKET_PACKETAUTO
-} sfe_ublox_packet_buffer_e;
-
-//Registers
-const uint8_t UBX_SYNCH_1 = 0xB5;
-const uint8_t UBX_SYNCH_2 = 0x62;
-
-//The following are UBX Class IDs. Descriptions taken from ZED-F9P Interface Description Document page 32, NEO-M8P Interface Description page 145
-const uint8_t UBX_CLASS_NAV = 0x01;	 //Navigation Results Messages: Position, Speed, Time, Acceleration, Heading, DOP, SVs used
-const uint8_t UBX_CLASS_RXM = 0x02;	 //Receiver Manager Messages: Satellite Status, RTC Status
-const uint8_t UBX_CLASS_INF = 0x04;	 //Information Messages: Printf-Style Messages, with IDs such as Error, Warning, Notice
-const uint8_t UBX_CLASS_ACK = 0x05;	 //Ack/Nak Messages: Acknowledge or Reject messages to UBX-CFG input messages
-const uint8_t UBX_CLASS_CFG = 0x06;	 //Configuration Input Messages: Configure the receiver.
-const uint8_t UBX_CLASS_UPD = 0x09;	 //Firmware Update Messages: Memory/Flash erase/write, Reboot, Flash identification, etc.
-const uint8_t UBX_CLASS_MON = 0x0A;	 //Monitoring Messages: Communication Status, CPU Load, Stack Usage, Task Status
-const uint8_t UBX_CLASS_AID = 0x0B;	 //(NEO-M8P ONLY!!!) AssistNow Aiding Messages: Ephemeris, Almanac, other A-GPS data input
-const uint8_t UBX_CLASS_TIM = 0x0D;	 //Timing Messages: Time Pulse Output, Time Mark Results
-const uint8_t UBX_CLASS_ESF = 0x10;	 //(NEO-M8P ONLY!!!) External Sensor Fusion Messages: External Sensor Measurements and Status Information
-const uint8_t UBX_CLASS_MGA = 0x13;	 //Multiple GNSS Assistance Messages: Assistance data for various GNSS
-const uint8_t UBX_CLASS_LOG = 0x21;	 //Logging Messages: Log creation, deletion, info and retrieval
-const uint8_t UBX_CLASS_SEC = 0x27;	 //Security Feature Messages
-const uint8_t UBX_CLASS_HNR = 0x28;	 //(NEO-M8P ONLY!!!) High Rate Navigation Results Messages: High rate time, position speed, heading
-const uint8_t UBX_CLASS_NMEA = 0xF0; //NMEA Strings: standard NMEA strings
-
-//Class: CFG
-//The following are used for configuration. Descriptions are from the ZED-F9P Interface Description pg 33-34 and NEO-M9N Interface Description pg 47-48
-const uint8_t UBX_CFG_ANT = 0x13;		//Antenna Control Settings. Used to configure the antenna control settings
-const uint8_t UBX_CFG_BATCH = 0x93;		//Get/set data batching configuration.
-const uint8_t UBX_CFG_CFG = 0x09;		//Clear, Save, and Load Configurations. Used to save current configuration
-const uint8_t UBX_CFG_DAT = 0x06;		//Set User-defined Datum or The currently defined Datum
-const uint8_t UBX_CFG_DGNSS = 0x70;		//DGNSS configuration
-const uint8_t UBX_CFG_ESFALG = 0x56;		//ESF alignment
-const uint8_t UBX_CFG_ESFA = 0x4C;		//ESF accelerometer
-const uint8_t UBX_CFG_ESFG = 0x4D;		//ESF gyro
-const uint8_t UBX_CFG_GEOFENCE = 0x69;	//Geofencing configuration. Used to configure a geofence
-const uint8_t UBX_CFG_GNSS = 0x3E;		//GNSS system configuration
-const uint8_t UBX_CFG_HNR = 0x5C;		//High Navigation Rate
-const uint8_t UBX_CFG_INF = 0x02;		//Depending on packet length, either: poll configuration for one protocol, or information message configuration
-const uint8_t UBX_CFG_ITFM = 0x39;		//Jamming/Interference Monitor configuration
-const uint8_t UBX_CFG_LOGFILTER = 0x47; //Data Logger Configuration
-const uint8_t UBX_CFG_MSG = 0x01;		//Poll a message configuration, or Set Message Rate(s), or Set Message Rate
-const uint8_t UBX_CFG_NAV5 = 0x24;		//Navigation Engine Settings. Used to configure the navigation engine including the dynamic model.
-const uint8_t UBX_CFG_NAVX5 = 0x23;		//Navigation Engine Expert Settings
-const uint8_t UBX_CFG_NMEA = 0x17;		//Extended NMEA protocol configuration V1
-const uint8_t UBX_CFG_ODO = 0x1E;		//Odometer, Low-speed COG Engine Settings
-const uint8_t UBX_CFG_PM2 = 0x3B;		//Extended power management configuration
-const uint8_t UBX_CFG_PMS = 0x86;		//Power mode setup
-const uint8_t UBX_CFG_PRT = 0x00;		//Used to configure port specifics. Polls the configuration for one I/O Port, or Port configuration for UART ports, or Port configuration for USB port, or Port configuration for SPI port, or Port configuration for DDC port
-const uint8_t UBX_CFG_PWR = 0x57;		//Put receiver in a defined power state
-const uint8_t UBX_CFG_RATE = 0x08;		//Navigation/Measurement Rate Settings. Used to set port baud rates.
-const uint8_t UBX_CFG_RINV = 0x34;		//Contents of Remote Inventory
-const uint8_t UBX_CFG_RST = 0x04;		//Reset Receiver / Clear Backup Data Structures. Used to reset device.
-const uint8_t UBX_CFG_RXM = 0x11;		//RXM configuration
-const uint8_t UBX_CFG_SBAS = 0x16;		//SBAS configuration
-const uint8_t UBX_CFG_TMODE3 = 0x71;	//Time Mode Settings 3. Used to enable Survey In Mode
-const uint8_t UBX_CFG_TP5 = 0x31;		//Time Pulse Parameters
-const uint8_t UBX_CFG_USB = 0x1B;		//USB Configuration
-const uint8_t UBX_CFG_VALDEL = 0x8C;	//Used for config of higher version u-blox modules (ie protocol v27 and above). Deletes values corresponding to provided keys/ provided keys with a transaction
-const uint8_t UBX_CFG_VALGET = 0x8B;	//Used for config of higher version u-blox modules (ie protocol v27 and above). Configuration Items
-const uint8_t UBX_CFG_VALSET = 0x8A;	//Used for config of higher version u-blox modules (ie protocol v27 and above). Sets values corresponding to provided key-value pairs/ provided key-value pairs within a transaction.
-
-//Class: NMEA
-//The following are used to enable NMEA messages. Descriptions come from the NMEA messages overview in the ZED-F9P Interface Description
-const uint8_t UBX_NMEA_MSB = 0xF0;	//All NMEA enable commands have 0xF0 as MSB
-const uint8_t UBX_NMEA_DTM = 0x0A;	//GxDTM (datum reference)
-const uint8_t UBX_NMEA_GAQ = 0x45;	//GxGAQ (poll a standard message (if the current talker ID is GA))
-const uint8_t UBX_NMEA_GBQ = 0x44;	//GxGBQ (poll a standard message (if the current Talker ID is GB))
-const uint8_t UBX_NMEA_GBS = 0x09;	//GxGBS (GNSS satellite fault detection)
-const uint8_t UBX_NMEA_GGA = 0x00;	//GxGGA (Global positioning system fix data)
-const uint8_t UBX_NMEA_GLL = 0x01;	//GxGLL (latitude and long, whith time of position fix and status)
-const uint8_t UBX_NMEA_GLQ = 0x43;	//GxGLQ (poll a standard message (if the current Talker ID is GL))
-const uint8_t UBX_NMEA_GNQ = 0x42;	//GxGNQ (poll a standard message (if the current Talker ID is GN))
-const uint8_t UBX_NMEA_GNS = 0x0D;	//GxGNS (GNSS fix data)
-const uint8_t UBX_NMEA_GPQ = 0x040; //GxGPQ (poll a standard message (if the current Talker ID is GP))
-const uint8_t UBX_NMEA_GRS = 0x06;	//GxGRS (GNSS range residuals)
-const uint8_t UBX_NMEA_GSA = 0x02;	//GxGSA (GNSS DOP and Active satellites)
-const uint8_t UBX_NMEA_GST = 0x07;	//GxGST (GNSS Pseudo Range Error Statistics)
-const uint8_t UBX_NMEA_GSV = 0x03;	//GxGSV (GNSS satellites in view)
-const uint8_t UBX_NMEA_RMC = 0x04;	//GxRMC (Recommended minimum data)
-const uint8_t UBX_NMEA_TXT = 0x41;	//GxTXT (text transmission)
-const uint8_t UBX_NMEA_VLW = 0x0F;	//GxVLW (dual ground/water distance)
-const uint8_t UBX_NMEA_VTG = 0x05;	//GxVTG (course over ground and Ground speed)
-const uint8_t UBX_NMEA_ZDA = 0x08;	//GxZDA (Time and Date)
-
-//The following are used to configure the NMEA protocol main talker ID and GSV talker ID
-const uint8_t UBX_NMEA_MAINTALKERID_NOTOVERRIDDEN = 0x00; //main talker ID is system dependent
-const uint8_t UBX_NMEA_MAINTALKERID_GP = 0x01;			  //main talker ID is GPS
-const uint8_t UBX_NMEA_MAINTALKERID_GL = 0x02;			  //main talker ID is GLONASS
-const uint8_t UBX_NMEA_MAINTALKERID_GN = 0x03;			  //main talker ID is combined receiver
-const uint8_t UBX_NMEA_MAINTALKERID_GA = 0x04;			  //main talker ID is Galileo
-const uint8_t UBX_NMEA_MAINTALKERID_GB = 0x05;			  //main talker ID is BeiDou
-const uint8_t UBX_NMEA_GSVTALKERID_GNSS = 0x00;			  //GNSS specific Talker ID (as defined by NMEA)
-const uint8_t UBX_NMEA_GSVTALKERID_MAIN = 0x01;			  //use the main Talker ID
-
-//Class: HNR
-//The following are used to configure the HNR message rates
-const uint8_t UBX_HNR_ATT = 0x01;			  //HNR Attitude
-const uint8_t UBX_HNR_INS = 0x02;			  //HNR Vehicle Dynamics
-const uint8_t UBX_HNR_PVT = 0x00;			  //HNR PVT
-
-//Class: INF
-//The following are used to configure INF UBX messages (information messages).  Descriptions from UBX messages overview (ZED_F9P Interface Description Document page 34)
-const uint8_t UBX_INF_CLASS = 0x04;	  //All INF messages have 0x04 as the class
-const uint8_t UBX_INF_DEBUG = 0x04;	  //ASCII output with debug contents
-const uint8_t UBX_INF_ERROR = 0x00;	  //ASCII output with error contents
-const uint8_t UBX_INF_NOTICE = 0x02;  //ASCII output with informational contents
-const uint8_t UBX_INF_TEST = 0x03;	  //ASCII output with test contents
-const uint8_t UBX_INF_WARNING = 0x01; //ASCII output with warning contents
-
-//Class: LOG
-//The following are used to configure LOG UBX messages (loggings messages).  Descriptions from UBX messages overview (ZED_F9P Interface Description Document page 34)
-const uint8_t UBX_LOG_CREATE = 0x07;		   //Create Log File
-const uint8_t UBX_LOG_ERASE = 0x03;			   //Erase Logged Data
-const uint8_t UBX_LOG_FINDTIME = 0x0E;		   //Find index of a log entry based on a given time, or response to FINDTIME requested
-const uint8_t UBX_LOG_INFO = 0x08;			   //Poll for log information, or Log information
-const uint8_t UBX_LOG_RETRIEVEPOSEXTRA = 0x0F; //Odometer log entry
-const uint8_t UBX_LOG_RETRIEVEPOS = 0x0B;	   //Position fix log entry
-const uint8_t UBX_LOG_RETRIEVESTRING = 0x0D;   //Byte string log entry
-const uint8_t UBX_LOG_RETRIEVE = 0x09;		   //Request log data
-const uint8_t UBX_LOG_STRING = 0x04;		   //Store arbitrary string on on-board flash
-
-//Class: MGA
-//The following are used to configure MGA UBX messages (Multiple GNSS Assistance Messages).  Descriptions from UBX messages overview (ZED_F9P Interface Description Document page 34)
-const uint8_t UBX_MGA_ACK_DATA0 = 0x60;		 //Multiple GNSS Acknowledge message
-const uint8_t UBX_MGA_BDS_EPH = 0x03;		 //BDS Ephemeris Assistance
-const uint8_t UBX_MGA_BDS_ALM = 0x03;		 //BDS Almanac Assistance
-const uint8_t UBX_MGA_BDS_HEALTH = 0x03;	 //BDS Health Assistance
-const uint8_t UBX_MGA_BDS_UTC = 0x03;		 //BDS UTC Assistance
-const uint8_t UBX_MGA_BDS_IONO = 0x03;		 //BDS Ionospheric Assistance
-const uint8_t UBX_MGA_DBD = 0x80;			 //Either: Poll the Navigation Database, or Navigation Database Dump Entry
-const uint8_t UBX_MGA_GAL_EPH = 0x02;		 //Galileo Ephemeris Assistance
-const uint8_t UBX_MGA_GAL_ALM = 0x02;		 //Galileo Almanac Assitance
-const uint8_t UBX_MGA_GAL_TIMOFFSET = 0x02;	 //Galileo GPS time offset assistance
-const uint8_t UBX_MGA_GAL_UTC = 0x02;		 //Galileo UTC Assistance
-const uint8_t UBX_MGA_GLO_EPH = 0x06;		 //GLONASS Ephemeris Assistance
-const uint8_t UBX_MGA_GLO_ALM = 0x06;		 //GLONASS Almanac Assistance
-const uint8_t UBX_MGA_GLO_TIMEOFFSET = 0x06; //GLONASS Auxiliary Time Offset Assistance
-const uint8_t UBX_MGA_GPS_EPH = 0x00;		 //GPS Ephemeris Assistance
-const uint8_t UBX_MGA_GPS_ALM = 0x00;		 //GPS Almanac Assistance
-const uint8_t UBX_MGA_GPS_HEALTH = 0x00;	 //GPS Health Assistance
-const uint8_t UBX_MGA_GPS_UTC = 0x00;		 //GPS UTC Assistance
-const uint8_t UBX_MGA_GPS_IONO = 0x00;		 //GPS Ionosphere Assistance
-const uint8_t UBX_MGA_INI_POS_XYZ = 0x40;	 //Initial Position Assistance
-const uint8_t UBX_MGA_INI_POS_LLH = 0x40;	 //Initial Position Assitance
-const uint8_t UBX_MGA_INI_TIME_UTC = 0x40;	 //Initial Time Assistance
-const uint8_t UBX_MGA_INI_TIME_GNSS = 0x40;	 //Initial Time Assistance
-const uint8_t UBX_MGA_INI_CLKD = 0x40;		 //Initial Clock Drift Assitance
-const uint8_t UBX_MGA_INI_FREQ = 0x40;		 //Initial Frequency Assistance
-const uint8_t UBX_MGA_INI_EOP = 0x40;		 //Earth Orientation Parameters Assistance
-const uint8_t UBX_MGA_QZSS_EPH = 0x05;		 //QZSS Ephemeris Assistance
-const uint8_t UBX_MGA_QZSS_ALM = 0x05;		 //QZSS Almanac Assistance
-const uint8_t UBX_MGA_QZAA_HEALTH = 0x05;	 //QZSS Health Assistance
-
-//Class: MON
-//The following are used to configure the MON UBX messages (monitoring messages). Descriptions from UBX messages overview (ZED_F9P Interface Description Document page 35)
-const uint8_t UBX_MON_COMMS = 0x36; //Comm port information
-const uint8_t UBX_MON_GNSS = 0x28;	//Information message major GNSS selection
-const uint8_t UBX_MON_HW2 = 0x0B;	//Extended Hardware Status
-const uint8_t UBX_MON_HW3 = 0x37;	//HW I/O pin information
-const uint8_t UBX_MON_HW = 0x09;	//Hardware Status
-const uint8_t UBX_MON_IO = 0x02;	//I/O Subsystem Status
-const uint8_t UBX_MON_MSGPP = 0x06; //Message Parse and Process Status
-const uint8_t UBX_MON_PATCH = 0x27; //Output information about installed patches
-const uint8_t UBX_MON_RF = 0x38;	//RF information
-const uint8_t UBX_MON_RXBUF = 0x07; //Receiver Buffer Status
-const uint8_t UBX_MON_RXR = 0x21;	//Receiver Status Information
-const uint8_t UBX_MON_TXBUF = 0x08; //Transmitter Buffer Status. Used for query tx buffer size/state.
-const uint8_t UBX_MON_VER = 0x04;	//Receiver/Software Version. Used for obtaining Protocol Version.
-
-//Class: NAV
-//The following are used to configure the NAV UBX messages (navigation results messages). Descriptions from UBX messages overview (ZED_F9P Interface Description Document page 35-36)
-const uint8_t UBX_NAV_ATT = 0x05;		//Vehicle "Attitude" Solution
-const uint8_t UBX_NAV_CLOCK = 0x22;		//Clock Solution
-const uint8_t UBX_NAV_DOP = 0x04;		//Dilution of precision
-const uint8_t UBX_NAV_EOE = 0x61;		//End of Epoch
-const uint8_t UBX_NAV_GEOFENCE = 0x39;	//Geofencing status. Used to poll the geofence status
-const uint8_t UBX_NAV_HPPOSECEF = 0x13; //High Precision Position Solution in ECEF. Used to find our positional accuracy (high precision).
-const uint8_t UBX_NAV_HPPOSLLH = 0x14;	//High Precision Geodetic Position Solution. Used for obtaining lat/long/alt in high precision
-const uint8_t UBX_NAV_ODO = 0x09;		//Odometer Solution
-const uint8_t UBX_NAV_ORB = 0x34;		//GNSS Orbit Database Info
-const uint8_t UBX_NAV_POSECEF = 0x01;	//Position Solution in ECEF
-const uint8_t UBX_NAV_POSLLH = 0x02;	//Geodetic Position Solution
-const uint8_t UBX_NAV_PVT = 0x07;		//All the things! Position, velocity, time, PDOP, height, h/v accuracies, number of satellites. Navigation Position Velocity Time Solution.
-const uint8_t UBX_NAV_RELPOSNED = 0x3C; //Relative Positioning Information in NED frame
-const uint8_t UBX_NAV_RESETODO = 0x10;	//Reset odometer
-const uint8_t UBX_NAV_SAT = 0x35;		//Satellite Information
-const uint8_t UBX_NAV_SIG = 0x43;		//Signal Information
-const uint8_t UBX_NAV_STATUS = 0x03;	//Receiver Navigation Status
-const uint8_t UBX_NAV_SVIN = 0x3B;		//Survey-in data. Used for checking Survey In status
-const uint8_t UBX_NAV_TIMEBDS = 0x24;	//BDS Time Solution
-const uint8_t UBX_NAV_TIMEGAL = 0x25;	//Galileo Time Solution
-const uint8_t UBX_NAV_TIMEGLO = 0x23;	//GLO Time Solution
-const uint8_t UBX_NAV_TIMEGPS = 0x20;	//GPS Time Solution
-const uint8_t UBX_NAV_TIMELS = 0x26;	//Leap second event information
-const uint8_t UBX_NAV_TIMEUTC = 0x21;	//UTC Time Solution
-const uint8_t UBX_NAV_VELECEF = 0x11;	//Velocity Solution in ECEF
-const uint8_t UBX_NAV_VELNED = 0x12;	//Velocity Solution in NED
-
-//Class: RXM
-//The following are used to configure the RXM UBX messages (receiver manager messages). Descriptions from UBX messages overview (ZED_F9P Interface Description Document page 36)
-const uint8_t UBX_RXM_MEASX = 0x14; //Satellite Measurements for RRLP
-const uint8_t UBX_RXM_PMREQ = 0x41; //Requests a Power Management task (two differenent packet sizes)
-const uint8_t UBX_RXM_RAWX = 0x15;	//Multi-GNSS Raw Measurement Data
-const uint8_t UBX_RXM_RLM = 0x59;	//Galileo SAR Short-RLM report (two different packet sizes)
-const uint8_t UBX_RXM_RTCM = 0x32;	//RTCM input status
-const uint8_t UBX_RXM_SFRBX = 0x13; //Boradcast Navigation Data Subframe
-
-//Class: SEC
-//The following are used to configure the SEC UBX messages (security feature messages). Descriptions from UBX messages overview (ZED_F9P Interface Description Document page 36)
-const uint8_t UBX_SEC_UNIQID = 0x03; //Unique chip ID
-
-//Class: TIM
-//The following are used to configure the TIM UBX messages (timing messages). Descriptions from UBX messages overview (ZED_F9P Interface Description Document page 36)
-const uint8_t UBX_TIM_TM2 = 0x03;  //Time mark data
-const uint8_t UBX_TIM_TP = 0x01;   //Time Pulse Timedata
-const uint8_t UBX_TIM_VRFY = 0x06; //Sourced Time Verification
-
-//Class: UPD
-//The following are used to configure the UPD UBX messages (firmware update messages). Descriptions from UBX messages overview (ZED-F9P Interface Description Document page 36)
-const uint8_t UBX_UPD_SOS = 0x14; //Poll Backup Fil Restore Status, Create Backup File in Flash, Clear Backup File in Flash, Backup File Creation Acknowledge, System Restored from Backup
-
-//The following are used to enable RTCM messages
-const uint8_t UBX_RTCM_MSB = 0xF5;	  //All RTCM enable commands have 0xF5 as MSB
-const uint8_t UBX_RTCM_1005 = 0x05;	  //Stationary RTK reference ARP
-const uint8_t UBX_RTCM_1074 = 0x4A;	  //GPS MSM4
-const uint8_t UBX_RTCM_1077 = 0x4D;	  //GPS MSM7
-const uint8_t UBX_RTCM_1084 = 0x54;	  //GLONASS MSM4
-const uint8_t UBX_RTCM_1087 = 0x57;	  //GLONASS MSM7
-const uint8_t UBX_RTCM_1094 = 0x5E;	  //Galileo MSM4
-const uint8_t UBX_RTCM_1097 = 0x61;	  //Galileo MSM7
-const uint8_t UBX_RTCM_1124 = 0x7C;	  //BeiDou MSM4
-const uint8_t UBX_RTCM_1127 = 0x7F;	  //BeiDou MSM7
-const uint8_t UBX_RTCM_1230 = 0xE6;	  //GLONASS code-phase biases, set to once every 10 seconds
-const uint8_t UBX_RTCM_4072_0 = 0xFE; //Reference station PVT (ublox proprietary RTCM message)
-const uint8_t UBX_RTCM_4072_1 = 0xFD; //Additional reference station information (ublox proprietary RTCM message)
-
-// Class: ACK
-const uint8_t UBX_ACK_NACK = 0x00;
-const uint8_t UBX_ACK_ACK = 0x01;
-const uint8_t UBX_ACK_NONE = 0x02; //Not a real value
-
-//Class: ESF
-// The following constants are used to get External Sensor Measurements and Status
-// Information.
-const uint8_t UBX_ESF_MEAS = 0x02;
-const uint8_t UBX_ESF_RAW = 0x03;
-const uint8_t UBX_ESF_STATUS = 0x10;
-const uint8_t UBX_ESF_RESETALG = 0x13;
-const uint8_t UBX_ESF_ALG = 0x14;
-const uint8_t UBX_ESF_INS = 0x15; //36 bytes
-
-const uint8_t SVIN_MODE_DISABLE = 0x00;
-const uint8_t SVIN_MODE_ENABLE = 0x01;
-
-//The following consts are used to configure the various ports and streams for those ports. See -CFG-PRT.
-const uint8_t COM_PORT_I2C = 0;
-const uint8_t COM_PORT_UART1 = 1;
-const uint8_t COM_PORT_UART2 = 2;
-const uint8_t COM_PORT_USB = 3;
-const uint8_t COM_PORT_SPI = 4;
-
-const uint8_t COM_TYPE_UBX = (1 << 0);
-const uint8_t COM_TYPE_NMEA = (1 << 1);
-const uint8_t COM_TYPE_RTCM3 = (1 << 5);
-
-// Configuration Sub-Section mask definitions for saveConfigSelective (UBX-CFG-CFG)
-const uint32_t VAL_CFG_SUBSEC_IOPORT = 0x00000001;	 // ioPort - communications port settings (causes IO system reset!)
-const uint32_t VAL_CFG_SUBSEC_MSGCONF = 0x00000002;	 // msgConf - message configuration
-const uint32_t VAL_CFG_SUBSEC_INFMSG = 0x00000004;	 // infMsg - INF message configuration
-const uint32_t VAL_CFG_SUBSEC_NAVCONF = 0x00000008;	 // navConf - navigation configuration
-const uint32_t VAL_CFG_SUBSEC_RXMCONF = 0x00000010;	 // rxmConf - receiver manager configuration
-const uint32_t VAL_CFG_SUBSEC_SENCONF = 0x00000100;	 // senConf - sensor interface configuration (requires protocol 19+)
-const uint32_t VAL_CFG_SUBSEC_RINVCONF = 0x00000200; // rinvConf - remove inventory configuration
-const uint32_t VAL_CFG_SUBSEC_ANTCONF = 0x00000400;	 // antConf - antenna configuration
-const uint32_t VAL_CFG_SUBSEC_LOGCONF = 0x00000800;	 // logConf - logging configuration
-const uint32_t VAL_CFG_SUBSEC_FTSCONF = 0x00001000;	 // ftsConf - FTS configuration (FTS products only)
-
-// Bitfield wakeupSources for UBX_RXM_PMREQ
-const uint32_t VAL_RXM_PMREQ_WAKEUPSOURCE_UARTRX = 0x00000008;	// uartrx
-const uint32_t VAL_RXM_PMREQ_WAKEUPSOURCE_EXTINT0 = 0x00000020; // extint0
-const uint32_t VAL_RXM_PMREQ_WAKEUPSOURCE_EXTINT1 = 0x00000040; // extint1
-const uint32_t VAL_RXM_PMREQ_WAKEUPSOURCE_SPICS = 0x00000080;	// spics
-
-enum dynModel // Possible values for the dynamic platform model, which provide more accuract position output for the situation. Description extracted from ZED-F9P Integration Manual
-{
-	DYN_MODEL_PORTABLE = 0, //Applications with low acceleration, e.g. portable devices. Suitable for most situations.
-	// 1 is not defined
-	DYN_MODEL_STATIONARY = 2, //Used in timing applications (antenna must be stationary) or other stationary applications. Velocity restricted to 0 m/s. Zero dynamics assumed.
-	DYN_MODEL_PEDESTRIAN,	  //Applications with low acceleration and speed, e.g. how a pedestrian would move. Low acceleration assumed.
-	DYN_MODEL_AUTOMOTIVE,	  //Used for applications with equivalent dynamics to those of a passenger car. Low vertical acceleration assumed
-	DYN_MODEL_SEA,			  //Recommended for applications at sea, with zero vertical velocity. Zero vertical velocity assumed. Sea level assumed.
-	DYN_MODEL_AIRBORNE1g,	  //Airborne <1g acceleration. Used for applications with a higher dynamic range and greater vertical acceleration than a passenger car. No 2D position fixes supported.
-	DYN_MODEL_AIRBORNE2g,	  //Airborne <2g acceleration. Recommended for typical airborne environments. No 2D position fixes supported.
-	DYN_MODEL_AIRBORNE4g,	  //Airborne <4g acceleration. Only recommended for extremely dynamic environments. No 2D position fixes supported.
-	DYN_MODEL_WRIST,		  // Not supported in protocol versions less than 18. Only recommended for wrist worn applications. Receiver will filter out arm motion.
-	DYN_MODEL_BIKE,			  // Supported in protocol versions 19.2
-	DYN_MODEL_UNKNOWN = 255 // getDynamicModel will return 255 if sendCommand fails
-};
-
-// The GNSS identifiers - used by UBX-CFG-GNSS (0x06 0x3E) GNSS system configuration
-enum sfe_ublox_gnss_ids_e
-{
-	SFE_UBLOX_GNSS_ID_GPS,
-	SFE_UBLOX_GNSS_ID_SBAS,
-	SFE_UBLOX_GNSS_ID_GALILEO,
-	SFE_UBLOX_GNSS_ID_BEIDOU,
-	SFE_UBLOX_GNSS_ID_IMES,
-	SFE_UBLOX_GNSS_ID_QZSS,
-	SFE_UBLOX_GNSS_ID_GLONASS
-};
-
-#ifndef MAX_PAYLOAD_SIZE
-// v2.0: keep this for backwards-compatibility, but this is largely superseded by setPacketCfgPayloadSize
-#define MAX_PAYLOAD_SIZE 256 //We need ~220 bytes for getProtocolVersion on most ublox modules
-//#define MAX_PAYLOAD_SIZE 768 //Worst case: UBX_CFG_VALSET packet with 64 keyIDs each with 64 bit values
-#endif
-
-//-=-=-=-=- UBX binary specific variables
-struct ubxPacket
-{
-	uint8_t cls;
-	uint8_t id;
-	uint16_t len; //Length of the payload. Does not include cls, id, or checksum bytes
-	uint16_t counter; //Keeps track of number of overall bytes received. Some responses are larger than 255 bytes.
-	uint16_t startingSpot; //The counter value needed to go past before we begin recording into payload array
-	uint8_t *payload; // We will allocate RAM for the payload if/when needed.
-	uint8_t checksumA; //Given to us from module. Checked against the rolling calculated A/B checksums.
-	uint8_t checksumB;
-	sfe_ublox_packet_validity_e valid;			 //Goes from NOT_DEFINED to VALID or NOT_VALID when checksum is checked
-	sfe_ublox_packet_validity_e classAndIDmatch; // Goes from NOT_DEFINED to VALID or NOT_VALID when the Class and ID match the requestedClass and requestedID
-};
-
-// Struct to hold the results returned by getGeofenceState (returned by UBX-NAV-GEOFENCE)
-typedef struct
-{
-	uint8_t status;	   // Geofencing status: 0 - Geofencing not available or not reliable; 1 - Geofencing active
-	uint8_t numFences; // Number of geofences
-	uint8_t combState; // Combined (logical OR) state of all geofences: 0 - Unknown; 1 - Inside; 2 - Outside
-	uint8_t states[4]; // Geofence states: 0 - Unknown; 1 - Inside; 2 - Outside
-} geofenceState;
-
-// Struct to hold the current geofence parameters
-typedef struct
-{
-	uint8_t numFences; // Number of active geofences
-	int32_t lats[4];   // Latitudes of geofences (in degrees * 10^-7)
-	int32_t longs[4];  // Longitudes of geofences (in degrees * 10^-7)
-	uint32_t rads[4];  // Radii of geofences (in m * 10^-2)
-} geofenceParams_t;
-
-// Struct to hold the module software version
-typedef struct
-{
-	uint8_t versionLow;		 //Loaded from getProtocolVersion().
-	uint8_t versionHigh;
-	bool moduleQueried;
-} moduleSWVersion_t;
-
-const uint16_t DAYS_SINCE_MONTH[4][16] = 
-{
-    {   0,   0,  31,  60,  91, 121, 152, 182, 213, 244, 274, 305, 335, 335, 335, 335 },
-    {   0,   0,  31,  59,  90, 120, 151, 181, 212, 243, 273, 304, 334, 334, 334, 334 },
-    {   0,   0,  31,  59,  90, 120, 151, 181, 212, 243, 273, 304, 334, 334, 334, 334 },
-    {   0,   0,  31,  59,  90, 120, 151, 181, 212, 243, 273, 304, 334, 334, 334, 334 },
-};
-
-class SFE_UBLOX_GNSS
-{
-public:
-	SFE_UBLOX_GNSS(void);
-
-// A default of 250ms for maxWait seems fine for I2C but is not enough for SerialUSB.
-// If you know you are only going to be using I2C / Qwiic communication, you can
-// safely reduce defaultMaxWait to 250.
-#ifndef defaultMaxWait // Let's allow the user to define their own value if they want to
-#define defaultMaxWait 1100
-#endif
-
-	//New in v2.0: allow the payload size for packetCfg to be changed
-	void setPacketCfgPayloadSize(size_t payloadSize); // Set packetCfgPayloadSize
-
-	//By default use the default I2C address, and use Wire port
-	boolean begin(TwoWire &wirePort = Wire, uint8_t deviceAddress = 0x42); //Returns true if module is detected
-	//serialPort needs to be perviously initialized to correct baud rate
-	boolean begin(Stream &serialPort); //Returns true if module is detected
-
-	void end(void); //Stop all automatic message processing. Free all used RAM
-
-	void setI2CpollingWait(uint8_t newPollingWait_ms); // Allow the user to change the I2C polling wait if required
-
-	//Control the size of the internal I2C transaction amount
-	void setI2CTransactionSize(uint8_t bufferSize);
-	uint8_t getI2CTransactionSize(void);
-
-	//Set the max number of bytes set in a given I2C transaction
-	uint8_t i2cTransactionSize = 32; //Default to ATmega328 limit
-
-	//Returns true if device answers on _gpsI2Caddress address or via Serial
-	boolean isConnected(uint16_t maxWait = 1100);
-
-	// Enable debug messages using the chosen Serial port (Stream)
-	// Boards like the RedBoard Turbo use SerialUSB (not Serial).
-	// But other boards like the SAMD51 Thing Plus use Serial (not SerialUSB).
-	// These lines let the code compile cleanly on as many SAMD boards as possible.
-	#if defined(ARDUINO_ARCH_SAMD)	// Is this a SAMD board?
-	#if defined(USB_VID)						// Is the USB Vendor ID defined?
-	#if (USB_VID == 0x1B4F)					// Is this a SparkFun board?
-	#if !defined(ARDUINO_SAMD51_THING_PLUS) & !defined(ARDUINO_SAMD51_MICROMOD) // If it is not a SAMD51 Thing Plus or SAMD51 MicroMod
-	void enableDebugging(Stream &debugPort = SerialUSB, boolean printLimitedDebug = false); //Given a port to print to, enable debug messages. Default to all, not limited.
-	#else
-	void enableDebugging(Stream &debugPort = Serial, boolean printLimitedDebug = false); //Given a port to print to, enable debug messages. Default to all, not limited.
-	#endif
-	#else
-	void enableDebugging(Stream &debugPort = Serial, boolean printLimitedDebug = false); //Given a port to print to, enable debug messages. Default to all, not limited.
-	#endif
-	#else
-	void enableDebugging(Stream &debugPort = Serial, boolean printLimitedDebug = false); //Given a port to print to, enable debug messages. Default to all, not limited.
-	#endif
-	#else
-	void enableDebugging(Stream &debugPort = Serial, boolean printLimitedDebug = false); //Given a port to print to, enable debug messages. Default to all, not limited.
-	#endif
-
-	void disableDebugging(void); //Turn off debug statements
-	void debugPrint(char *message); //Safely print debug statements
-	void debugPrintln(char *message); //Safely print debug statements
-	const char *statusString(sfe_ublox_status_e stat); //Pretty print the return value
-
-	// Check for the arrival of new I2C/Serial data
-
-	void disableUBX7Fcheck(boolean disabled = true); // When logging RAWX data, we need to be able to disable the "7F" check in checkUbloxI2C
-
-	//Changed in V1.8.1: provides backward compatibility for the examples that call checkUblox directly
-	//Will default to using packetCfg to look for explicit autoPVT packets so they get processed correctly by processUBX
-	boolean checkUblox(uint8_t requestedClass = 0, uint8_t requestedID = 0); //Checks module with user selected commType
-
-	boolean checkUbloxI2C(ubxPacket *incomingUBX, uint8_t requestedClass, uint8_t requestedID);	   //Method for I2C polling of data, passing any new bytes to process()
-	boolean checkUbloxSerial(ubxPacket *incomingUBX, uint8_t requestedClass, uint8_t requestedID); //Method for serial polling of data, passing any new bytes to process()
-
-	// Process the incoming data
-
-	void process(uint8_t incoming, ubxPacket *incomingUBX, uint8_t requestedClass, uint8_t requestedID);	//Processes NMEA and UBX binary sentences one byte at a time
-	void processNMEA(char incoming) __attribute__((weak)); //Given a NMEA character, do something with it. User can overwrite if desired to use something like tinyGPS or MicroNMEA libraries
-	void processRTCMframe(uint8_t incoming); //Monitor the incoming bytes for start and length bytes
-	void processRTCM(uint8_t incoming) __attribute__((weak)); //Given rtcm byte, do something with it. User can overwrite if desired to pipe bytes to radio, internet, etc.
-	void processUBX(uint8_t incoming, ubxPacket *incomingUBX, uint8_t requestedClass, uint8_t requestedID); //Given a character, file it away into the uxb packet structure
-	void processUBXpacket(ubxPacket *msg); //Once a packet has been received and validated, identify this packet's class/id and update internal flags
-
-	// Send I2C/Serial commands to the module
-
-	void calcChecksum(ubxPacket *msg); //Sets the checksumA and checksumB of a given messages
-	sfe_ublox_status_e sendCommand(ubxPacket *outgoingUBX, uint16_t maxWait = defaultMaxWait, boolean expectACKonly = false); //Given a packet and payload, send everything including CRC bytes, return true if we got a response
-	sfe_ublox_status_e sendI2cCommand(ubxPacket *outgoingUBX, uint16_t maxWait = defaultMaxWait);
-	void sendSerialCommand(ubxPacket *outgoingUBX);
-
-	void printPacket(ubxPacket *packet, boolean alwaysPrintPayload = false); //Useful for debugging
-
-	// After sending a message to the module, wait for the expected response (data+ACK or just data)
-
-	sfe_ublox_status_e waitForACKResponse(ubxPacket *outgoingUBX, uint8_t requestedClass, uint8_t requestedID, uint16_t maxTime = defaultMaxWait);	 //Poll the module until a config packet and an ACK is received, or just an ACK
-	sfe_ublox_status_e waitForNoACKResponse(ubxPacket *outgoingUBX, uint8_t requestedClass, uint8_t requestedID, uint16_t maxTime = defaultMaxWait); //Poll the module until a config packet is received
-
-	// Check if any callbacks need to be called
-	void checkCallbacks(void);
-
-	// Push (e.g.) RTCM data directly to the module
-	// Warning: this function does not check that the data is valid. It is the user's responsibility to ensure the data is valid before pushing.
-	boolean pushRawData(uint8_t *dataBytes, size_t numDataBytes);
-
-	// Support for data logging
-	void setFileBufferSize(uint16_t bufferSize); // Set the size of the file buffer. This must be called _before_ .begin.
-	uint16_t getFileBufferSize(void); // Return the size of the file buffer
-	uint16_t extractFileBufferData(uint8_t *destination, uint16_t numBytes); // Extract numBytes of data from the file buffer. Copy it to destination. It is the user's responsibility to ensure destination is large enough.
-	uint16_t fileBufferAvailable(void);		// Returns the number of bytes available in file buffer which are waiting to be read
-	uint16_t getMaxFileBufferAvail(void);	// Returns the maximum number of bytes which the file buffer has contained. Handy for checking the buffer is large enough to handle all the incoming data.
-	void clearFileBuffer(void);				// Empty the file buffer - discard all contents
-	void clearMaxFileBufferAvail(void);		// Reset fileBufferMaxAvail
-
-	// Specific commands
-
-	//Port configurations
-	boolean getPortSettings(uint8_t portID, uint16_t maxWait = defaultMaxWait);					   //Returns the current protocol bits in the UBX-CFG-PRT command for a given port
-	boolean setPortOutput(uint8_t portID, uint8_t comSettings, uint16_t maxWait = defaultMaxWait); //Configure a given port to output UBX, NMEA, RTCM3 or a combination thereof
-	boolean setPortInput(uint8_t portID, uint8_t comSettings, uint16_t maxWait = defaultMaxWait);  //Configure a given port to input UBX, NMEA, RTCM3 or a combination thereof
-
-	boolean setI2CAddress(uint8_t deviceAddress, uint16_t maxTime = defaultMaxWait);										 //Changes the I2C address of the u-blox module
-	void setSerialRate(uint32_t baudrate, uint8_t uartPort = COM_PORT_UART1, uint16_t maxTime = defaultMaxWait); //Changes the serial baud rate of the u-blox module, uartPort should be COM_PORT_UART1/2
-
-	boolean setI2COutput(uint8_t comSettings, uint16_t maxWait = defaultMaxWait);				//Configure I2C port to output UBX, NMEA, RTCM3 or a combination thereof
-	boolean setUART1Output(uint8_t comSettings, uint16_t maxWait = defaultMaxWait); //Configure UART1 port to output UBX, NMEA, RTCM3 or a combination thereof
-	boolean setUART2Output(uint8_t comSettings, uint16_t maxWait = defaultMaxWait); //Configure UART2 port to output UBX, NMEA, RTCM3 or a combination thereof
-	boolean setUSBOutput(uint8_t comSettings, uint16_t maxWait = defaultMaxWait);				//Configure USB port to output UBX, NMEA, RTCM3 or a combination thereof
-	boolean setSPIOutput(uint8_t comSettings, uint16_t maxWait = defaultMaxWait);				//Configure SPI port to output UBX, NMEA, RTCM3 or a combination thereof
-	void setNMEAOutputPort(Stream &nmeaOutputPort);																 //Sets the internal variable for the port to direct NMEA characters to
-
-	//Reset to defaults
-
-	void factoryReset(); //Send factory reset sequence (i.e. load "default" configuration and perform hardReset)
-	void hardReset();	 //Perform a reset leading to a cold start (zero info start-up)
-	boolean factoryDefault(uint16_t maxWait = defaultMaxWait);							 //Reset module to factory defaults
-
-	//Save configuration to BBR / Flash
-
-	boolean saveConfiguration(uint16_t maxWait = defaultMaxWait);						 //Save current configuration to flash and BBR (battery backed RAM)
-	boolean saveConfigSelective(uint32_t configMask, uint16_t maxWait = defaultMaxWait); //Save the selected configuration sub-sections to flash and BBR (battery backed RAM)
-
-	//Functions to turn on/off message types for a given port ID (see COM_PORT_I2C, etc above)
-	boolean configureMessage(uint8_t msgClass, uint8_t msgID, uint8_t portID, uint8_t sendRate, uint16_t maxWait = defaultMaxWait);
-	boolean enableMessage(uint8_t msgClass, uint8_t msgID, uint8_t portID, uint8_t sendRate = 1, uint16_t maxWait = defaultMaxWait);
-	boolean disableMessage(uint8_t msgClass, uint8_t msgID, uint8_t portID, uint16_t maxWait = defaultMaxWait);
-	boolean enableNMEAMessage(uint8_t msgID, uint8_t portID, uint8_t sendRate = 1, uint16_t maxWait = defaultMaxWait);
-	boolean disableNMEAMessage(uint8_t msgID, uint8_t portID, uint16_t maxWait = defaultMaxWait);
-	boolean enableRTCMmessage(uint8_t messageNumber, uint8_t portID, uint8_t sendRate, uint16_t maxWait = defaultMaxWait); //Given a message number turns on a message ID for output over given PortID
-	boolean disableRTCMmessage(uint8_t messageNumber, uint8_t portID, uint16_t maxWait = defaultMaxWait); //Turn off given RTCM message from a given port
-
-	//Functions used for RTK and base station setup
-	//It is probably safe to assume that users of the RTK will be using I2C / Qwiic. So let's leave maxWait set to 250ms.
-	boolean getSurveyMode(uint16_t maxWait = 250); //Get the current TimeMode3 settings
-	boolean setSurveyMode(uint8_t mode, uint16_t observationTime, float requiredAccuracy, uint16_t maxWait = 250); //Control survey in mode
-	boolean enableSurveyMode(uint16_t observationTime, float requiredAccuracy, uint16_t maxWait = 250); //Begin Survey-In for NEO-M8P
-	boolean disableSurveyMode(uint16_t maxWait = 250); //Stop Survey-In mode
-	// Given coordinates, put receiver into static position. Set latlong to true to pass in lat/long values instead of ecef.
-	// For ECEF the units are: cm, 0.1mm, cm, 0.1mm, cm, 0.1mm
-	// For Lat/Lon/Alt the units are: degrees^-7, degrees^-9, degrees^-7, degrees^-9, cm, 0.1mm
-	bool setStaticPosition(int32_t ecefXOrLat, int8_t ecefXOrLatHP, int32_t ecefYOrLon, int8_t ecefYOrLonHP, int32_t ecefZOrAlt, int8_t ecefZOrAltHP, bool latLong = false, uint16_t maxWait = 250);
-	bool setStaticPosition(int32_t ecefXOrLat, int32_t ecefYOrLon, int32_t ecefZOrAlt, bool latLong = false, uint16_t maxWait = 250);
-
-	//Read the module's protocol version
-	uint8_t getProtocolVersionHigh(uint16_t maxWait = defaultMaxWait); //Returns the PROTVER XX.00 from UBX-MON-VER register
-	uint8_t getProtocolVersionLow(uint16_t maxWait = defaultMaxWait);	//Returns the PROTVER 00.XX from UBX-MON-VER register
-	boolean getProtocolVersion(uint16_t maxWait = defaultMaxWait);		//Queries module, loads low/high bytes
-	moduleSWVersion_t *moduleSWVersion = NULL; // Pointer to struct. RAM will be allocated for this if/when necessary
-
-	//Support for geofences
-	boolean addGeofence(int32_t latitude, int32_t longitude, uint32_t radius, byte confidence = 0, byte pinPolarity = 0, byte pin = 0, uint16_t maxWait = defaultMaxWait); // Add a new geofence
-	boolean clearGeofences(uint16_t maxWait = defaultMaxWait); //Clears all geofences
-	boolean clearAntPIO(uint16_t maxWait = defaultMaxWait); //Clears the antenna control pin settings to release the PIOs
-	boolean getGeofenceState(geofenceState &currentGeofenceState, uint16_t maxWait = defaultMaxWait); //Returns the combined geofence state
-	// Storage for the geofence parameters. RAM is allocated for this if/when required.
-	geofenceParams_t *currentGeofenceParams = NULL; // Pointer to struct. RAM will be allocated for this if/when necessary
-
-	//Power save / off
-	boolean powerSaveMode(bool power_save = true, uint16_t maxWait = defaultMaxWait);
-	uint8_t getPowerSaveMode(uint16_t maxWait = defaultMaxWait); // Returns 255 if the sendCommand fails
-	boolean powerOff(uint32_t durationInMs, uint16_t maxWait = defaultMaxWait);
-	boolean powerOffWithInterrupt(uint32_t durationInMs, uint32_t wakeupSources = VAL_RXM_PMREQ_WAKEUPSOURCE_EXTINT0, boolean forceWhileUsb = true, uint16_t maxWait = 1100);
-
-	//Change the dynamic platform model using UBX-CFG-NAV5
-	boolean setDynamicModel(dynModel newDynamicModel = DYN_MODEL_PORTABLE, uint16_t maxWait = defaultMaxWait);
-	uint8_t getDynamicModel(uint16_t maxWait = defaultMaxWait); // Get the dynamic model - returns 255 if the sendCommand fails
-
-	//Reset the odometer
-	boolean resetOdometer(uint16_t maxWait = defaultMaxWait); // Reset the odometer
-
-	//Enable/Disable individual GNSS systems using UBX-CFG-GNSS
-	//Note: you must leave at least one major GNSS enabled! If in doubt, enable GPS before disabling the others
-	//TO DO: Add support for sigCfgMask and maxTrkCh. (Need to resolve ambiguity with maxWait)
-	boolean enableGNSS(boolean enable, sfe_ublox_gnss_ids_e id, uint16_t maxWait = defaultMaxWait);
-	boolean isGNSSenabled(sfe_ublox_gnss_ids_e id, uint16_t maxWait = defaultMaxWait);
-
-	//Reset ESF automatic IMU-mount alignment
-	boolean resetIMUalignment(uint16_t maxWait = defaultMaxWait);
-
-	//Configure Time Pulse Parameters
-	boolean getTimePulseParameters(UBX_CFG_TP5_data_t *data = NULL, uint16_t maxWait = defaultMaxWait); // Get the time pulse parameters using UBX_CFG_TP5
-	boolean setTimePulseParameters(UBX_CFG_TP5_data_t *data = NULL, uint16_t maxWait = defaultMaxWait); // Set the time pulse parameters using UBX_CFG_TP5
-
-	//General configuration (used only on protocol v27 and higher - ie, ZED-F9P)
-
-	//It is probably safe to assume that users of the ZED-F9P will be using I2C / Qwiic.
-	//If they are using Serial then the higher baud rate will also help. So let's leave maxWait set to 250ms.
-	uint32_t createKey(uint16_t group, uint16_t id, uint8_t size); //Form 32-bit key from group/id/size
-	sfe_ublox_status_e getVal(uint32_t keyID, uint8_t layer = VAL_LAYER_RAM, uint16_t maxWait = 250);					 //Load payload with response
-	uint8_t getVal8(uint32_t keyID, uint8_t layer = VAL_LAYER_RAM, uint16_t maxWait = 250);								 //Returns the value at a given key location
-	uint16_t getVal16(uint32_t keyID, uint8_t layer = VAL_LAYER_RAM, uint16_t maxWait = 250);							 //Returns the value at a given key location
-	uint32_t getVal32(uint32_t keyID, uint8_t layer = VAL_LAYER_RAM, uint16_t maxWait = 250);							 //Returns the value at a given key location
-	uint8_t getVal8(uint16_t group, uint16_t id, uint8_t size, uint8_t layer = VAL_LAYER_RAM, uint16_t maxWait = 250);	 //Returns the value at a given group/id/size location
-	uint16_t getVal16(uint16_t group, uint16_t id, uint8_t size, uint8_t layer = VAL_LAYER_RAM, uint16_t maxWait = 250); //Returns the value at a given group/id/size location
-	uint32_t getVal32(uint16_t group, uint16_t id, uint8_t size, uint8_t layer = VAL_LAYER_RAM, uint16_t maxWait = 250); //Returns the value at a given group/id/size location
-	uint8_t setVal(uint32_t keyID, uint16_t value, uint8_t layer = VAL_LAYER_ALL, uint16_t maxWait = 250);				 //Sets the 16-bit value at a given group/id/size location
-	uint8_t setVal8(uint32_t keyID, uint8_t value, uint8_t layer = VAL_LAYER_ALL, uint16_t maxWait = 250);				 //Sets the 8-bit value at a given group/id/size location
-	uint8_t setVal16(uint32_t keyID, uint16_t value, uint8_t layer = VAL_LAYER_ALL, uint16_t maxWait = 250);			 //Sets the 16-bit value at a given group/id/size location
-	uint8_t setVal32(uint32_t keyID, uint32_t value, uint8_t layer = VAL_LAYER_ALL, uint16_t maxWait = 250);			 //Sets the 32-bit value at a given group/id/size location
-	uint8_t newCfgValset8(uint32_t keyID, uint8_t value, uint8_t layer = VAL_LAYER_ALL);								 //Define a new UBX-CFG-VALSET with the given KeyID and 8-bit value
-	uint8_t newCfgValset16(uint32_t keyID, uint16_t value, uint8_t layer = VAL_LAYER_ALL);								 //Define a new UBX-CFG-VALSET with the given KeyID and 16-bit value
-	uint8_t newCfgValset32(uint32_t keyID, uint32_t value, uint8_t layer = VAL_LAYER_ALL);								 //Define a new UBX-CFG-VALSET with the given KeyID and 32-bit value
-	uint8_t addCfgValset8(uint32_t keyID, uint8_t value);																 //Add a new KeyID and 8-bit value to an existing UBX-CFG-VALSET ubxPacket
-	uint8_t addCfgValset16(uint32_t keyID, uint16_t value);																 //Add a new KeyID and 16-bit value to an existing UBX-CFG-VALSET ubxPacket
-	uint8_t addCfgValset32(uint32_t keyID, uint32_t value);																 //Add a new KeyID and 32-bit value to an existing UBX-CFG-VALSET ubxPacket
-	uint8_t sendCfgValset8(uint32_t keyID, uint8_t value, uint16_t maxWait = 250);										 //Add the final KeyID and 8-bit value to an existing UBX-CFG-VALSET ubxPacket and send it
-	uint8_t sendCfgValset16(uint32_t keyID, uint16_t value, uint16_t maxWait = 250);									 //Add the final KeyID and 16-bit value to an existing UBX-CFG-VALSET ubxPacket and send it
-	uint8_t sendCfgValset32(uint32_t keyID, uint32_t value, uint16_t maxWait = 250);									 //Add the final KeyID and 32-bit value to an existing UBX-CFG-VALSET ubxPacket and send it
-
-// getPVT will only return data once in each navigation cycle. By default, that is once per second.
-// Therefore we should set defaultMaxWait to slightly longer than that.
-// If you change the navigation frequency to (e.g.) 4Hz using setNavigationFrequency(4)
-// then you should use a shorter maxWait. 300msec would be about right: getPVT(300)
-
-	// get and set functions for all of the "automatic" message processing
-
-	// Navigation (NAV)
-
-	boolean getNAVPOSECEF(uint16_t maxWait = defaultMaxWait); // NAV POSECEF
-	boolean setAutoNAVPOSECEF(boolean enabled, uint16_t maxWait = defaultMaxWait);  //Enable/disable automatic POSECEF reports at the navigation frequency
-	boolean setAutoNAVPOSECEF(boolean enabled, boolean implicitUpdate, uint16_t maxWait = defaultMaxWait); //Enable/disable automatic POSECEF reports at the navigation frequency, with implicitUpdate == false accessing stale data will not issue parsing of data in the rxbuffer of your interface, instead you have to call checkUblox when you want to perform an update
-	boolean setAutoNAVPOSECEFrate(uint8_t rate, boolean implicitUpdate = true, uint16_t maxWait = defaultMaxWait); //Set the rate for automatic POSECEF reports
-	boolean setAutoNAVPOSECEFcallback(void (*callbackPointer)(UBX_NAV_POSECEF_data_t), uint16_t maxWait = defaultMaxWait); //Enable automatic POSECEF reports at the navigation frequency. Data is accessed from the callback.
-	boolean assumeAutoNAVPOSECEF(boolean enabled, boolean implicitUpdate = true); //In case no config access to the GPS is possible and POSECEF is send cyclically already
-	void flushNAVPOSECEF(); //Mark all the data as read/stale
-	void logNAVPOSECEF(boolean enabled = true); // Log data to file buffer
-
-	boolean getNAVSTATUS(uint16_t maxWait = defaultMaxWait); // NAV STATUS
-	boolean setAutoNAVSTATUS(boolean enabled, uint16_t maxWait = defaultMaxWait);  //Enable/disable automatic STATUS reports at the navigation frequency
-	boolean setAutoNAVSTATUS(boolean enabled, boolean implicitUpdate, uint16_t maxWait = defaultMaxWait); //Enable/disable automatic STATUS reports at the navigation frequency, with implicitUpdate == false accessing stale data will not issue parsing of data in the rxbuffer of your interface, instead you have to call checkUblox when you want to perform an update
-	boolean setAutoNAVSTATUSrate(uint8_t rate, boolean implicitUpdate = true, uint16_t maxWait = defaultMaxWait); //Set the rate for automatic STATUS reports
-	boolean setAutoNAVSTATUScallback(void (*callbackPointer)(UBX_NAV_STATUS_data_t), uint16_t maxWait = defaultMaxWait); //Enable automatic STATUS reports at the navigation frequency. Data is accessed from the callback.
-	boolean assumeAutoNAVSTATUS(boolean enabled, boolean implicitUpdate = true); //In case no config access to the GPS is possible and STATUS is send cyclically already
-	void flushNAVSTATUS(); //Mark all the data as read/stale
-	void logNAVSTATUS(boolean enabled = true); // Log data to file buffer
-
-	boolean getDOP(uint16_t maxWait = defaultMaxWait); //Query module for latest dilution of precision values and load global vars:. If autoDOP is disabled, performs an explicit poll and waits, if enabled does not block. Returns true if new DOP is available.
-	boolean setAutoDOP(boolean enabled, uint16_t maxWait = defaultMaxWait);  //Enable/disable automatic DOP reports at the navigation frequency
-	boolean setAutoDOP(boolean enabled, boolean implicitUpdate, uint16_t maxWait = defaultMaxWait); //Enable/disable automatic DOP reports at the navigation frequency, with implicitUpdate == false accessing stale data will not issue parsing of data in the rxbuffer of your interface, instead you have to call checkUblox when you want to perform an update
-	boolean setAutoDOPrate(uint8_t rate, boolean implicitUpdate = true, uint16_t maxWait = defaultMaxWait); //Set the rate for automatic DOP reports
-	boolean setAutoDOPcallback(void (*callbackPointer)(UBX_NAV_DOP_data_t), uint16_t maxWait = defaultMaxWait); //Enable automatic DOP reports at the navigation frequency. Data is accessed from the callback.
-	boolean assumeAutoDOP(boolean enabled, boolean implicitUpdate = true); //In case no config access to the GPS is possible and DOP is send cyclically already
-	void flushDOP(); //Mark all the DOP data as read/stale
-	void logNAVDOP(boolean enabled = true); // Log data to file buffer
-
-	boolean getVehAtt(uint16_t maxWait = defaultMaxWait); // NAV ATT Helper
-	boolean getNAVATT(uint16_t maxWait = defaultMaxWait); // NAV ATT
-	boolean setAutoNAVATT(boolean enabled, uint16_t maxWait = defaultMaxWait);  //Enable/disable automatic vehicle attitude reports at the navigation frequency
-	boolean setAutoNAVATT(boolean enabled, boolean implicitUpdate, uint16_t maxWait = defaultMaxWait); //Enable/disable automatic vehicle attitude reports at the navigation frequency, with implicitUpdate == false accessing stale data will not issue parsing of data in the rxbuffer of your interface, instead you have to call checkUblox when you want to perform an update
-	boolean setAutoNAVATTrate(uint8_t rate, boolean implicitUpdate = true, uint16_t maxWait = defaultMaxWait); //Set the rate for automatic ATT reports
-	boolean setAutoNAVATTcallback(void (*callbackPointer)(UBX_NAV_ATT_data_t), uint16_t maxWait = defaultMaxWait); //Enable automatic ATT reports at the navigation frequency. Data is accessed from the callback.
-	boolean assumeAutoNAVATT(boolean enabled, boolean implicitUpdate = true); //In case no config access to the GPS is possible and vehicle attitude is send cyclically already
-	void flushNAVATT(); //Mark all the data as read/stale
-	void logNAVATT(boolean enabled = true); // Log data to file buffer
-
-	boolean getPVT(uint16_t maxWait = defaultMaxWait);	//Query module for latest group of datums and load global vars: lat, long, alt, speed, SIV, accuracies, etc. If autoPVT is disabled, performs an explicit poll and waits, if enabled does not block. Returns true if new PVT is available.
-	boolean setAutoPVT(boolean enabled, uint16_t maxWait = defaultMaxWait); //Enable/disable automatic PVT reports at the navigation frequency
-	boolean setAutoPVT(boolean enabled, boolean implicitUpdate, uint16_t maxWait = defaultMaxWait); //Enable/disable automatic PVT reports at the navigation frequency, with implicitUpdate == false accessing stale data will not issue parsing of data in the rxbuffer of your interface, instead you have to call checkUblox when you want to perform an update
-	boolean setAutoPVTrate(uint8_t rate, boolean implicitUpdate = true, uint16_t maxWait = defaultMaxWait); //Set the rate for automatic PVT reports
-	boolean setAutoPVTcallback(void (*callbackPointer)(UBX_NAV_PVT_data_t), uint16_t maxWait = defaultMaxWait); //Enable automatic PVT reports at the navigation frequency. Data is accessed from the callback.
-	boolean assumeAutoPVT(boolean enabled, boolean implicitUpdate = true); //In case no config access to the GPS is possible and PVT is send cyclically already
-	void flushPVT(); //Mark all the PVT data as read/stale
-	void logNAVPVT(boolean enabled = true); // Log data to file buffer
-
-	boolean getNAVODO(uint16_t maxWait = defaultMaxWait); // NAV ODO
-	boolean setAutoNAVODO(boolean enabled, uint16_t maxWait = defaultMaxWait);  //Enable/disable automatic ODO reports at the navigation frequency
-	boolean setAutoNAVODO(boolean enabled, boolean implicitUpdate, uint16_t maxWait = defaultMaxWait); //Enable/disable automatic ODO reports at the navigation frequency, with implicitUpdate == false accessing stale data will not issue parsing of data in the rxbuffer of your interface, instead you have to call checkUblox when you want to perform an update
-	boolean setAutoNAVODOrate(uint8_t rate, boolean implicitUpdate = true, uint16_t maxWait = defaultMaxWait); //Set the rate for automatic ODO reports
-	boolean setAutoNAVODOcallback(void (*callbackPointer)(UBX_NAV_ODO_data_t), uint16_t maxWait = defaultMaxWait); //Enable automatic ODO reports at the navigation frequency. Data is accessed from the callback.
-	boolean assumeAutoNAVODO(boolean enabled, boolean implicitUpdate = true); //In case no config access to the GPS is possible and ODO is send cyclically already
-	void flushNAVODO(); //Mark all the data as read/stale
-	void logNAVODO(boolean enabled = true); // Log data to file buffer
-
-	boolean getNAVVELECEF(uint16_t maxWait = defaultMaxWait); // NAV VELECEF
-	boolean setAutoNAVVELECEF(boolean enabled, uint16_t maxWait = defaultMaxWait);  //Enable/disable automatic VELECEF reports at the navigation frequency
-	boolean setAutoNAVVELECEF(boolean enabled, boolean implicitUpdate, uint16_t maxWait = defaultMaxWait); //Enable/disable automatic VELECEF reports at the navigation frequency, with implicitUpdate == false accessing stale data will not issue parsing of data in the rxbuffer of your interface, instead you have to call checkUblox when you want to perform an update
-	boolean setAutoNAVVELECEFrate(uint8_t rate, boolean implicitUpdate = true, uint16_t maxWait = defaultMaxWait); //Set the rate for automatic VELECEF reports
-	boolean setAutoNAVVELECEFcallback(void (*callbackPointer)(UBX_NAV_VELECEF_data_t), uint16_t maxWait = defaultMaxWait); //Enable automatic VELECEF reports at the navigation frequency. Data is accessed from the callback.
-	boolean assumeAutoNAVVELECEF(boolean enabled, boolean implicitUpdate = true); //In case no config access to the GPS is possible and VELECEF is send cyclically already
-	void flushNAVVELECEF(); //Mark all the data as read/stale
-	void logNAVVELECEF(boolean enabled = true); // Log data to file buffer
-
-	boolean getNAVVELNED(uint16_t maxWait = defaultMaxWait); // NAV VELNED
-	boolean setAutoNAVVELNED(boolean enabled, uint16_t maxWait = defaultMaxWait);  //Enable/disable automatic VELNED reports at the navigation frequency
-	boolean setAutoNAVVELNED(boolean enabled, boolean implicitUpdate, uint16_t maxWait = defaultMaxWait); //Enable/disable automatic VELNED reports at the navigation frequency, with implicitUpdate == false accessing stale data will not issue parsing of data in the rxbuffer of your interface, instead you have to call checkUblox when you want to perform an update
-	boolean setAutoNAVVELNEDrate(uint8_t rate, boolean implicitUpdate = true, uint16_t maxWait = defaultMaxWait); //Set the rate for automatic VELNED reports
-	boolean setAutoNAVVELNEDcallback(void (*callbackPointer)(UBX_NAV_VELNED_data_t), uint16_t maxWait = defaultMaxWait); //Enable automatic VELNED reports at the navigation frequency. Data is accessed from the callback.
-	boolean assumeAutoNAVVELNED(boolean enabled, boolean implicitUpdate = true); //In case no config access to the GPS is possible and VELNED is send cyclically already
-	void flushNAVVELNED(); //Mark all the data as read/stale
-	void logNAVVELNED(boolean enabled = true); // Log data to file buffer
-
-	boolean getNAVHPPOSECEF(uint16_t maxWait = defaultMaxWait); // NAV HPPOSECEF
-	boolean setAutoNAVHPPOSECEF(boolean enabled, uint16_t maxWait = defaultMaxWait);  //Enable/disable automatic HPPOSECEF reports at the navigation frequency
-	boolean setAutoNAVHPPOSECEF(boolean enabled, boolean implicitUpdate, uint16_t maxWait = defaultMaxWait); //Enable/disable automatic HPPOSECEF reports at the navigation frequency, with implicitUpdate == false accessing stale data will not issue parsing of data in the rxbuffer of your interface, instead you have to call checkUblox when you want to perform an update
-	boolean setAutoNAVHPPOSECEFrate(uint8_t rate, boolean implicitUpdate = true, uint16_t maxWait = defaultMaxWait); //Set the rate for automatic HPPOSECEF reports
-	boolean setAutoNAVHPPOSECEFcallback(void (*callbackPointer)(UBX_NAV_HPPOSECEF_data_t), uint16_t maxWait = defaultMaxWait); //Enable automatic HPPOSECEF reports at the navigation frequency. Data is accessed from the callback.
-	boolean assumeAutoNAVHPPOSECEF(boolean enabled, boolean implicitUpdate = true); //In case no config access to the GPS is possible and HPPOSECEF is send cyclically already
-	void flushNAVHPPOSECEF(); //Mark all the data as read/stale
-	void logNAVHPPOSECEF(boolean enabled = true); // Log data to file buffer
-
-	boolean getHPPOSLLH(uint16_t maxWait = defaultMaxWait); //Query module for latest group of datums and load global vars: lat, long, alt, speed, SIV, accuracies, etc. If autoPVT is disabled, performs an explicit poll and waits, if enabled does not block. Returns true if new HPPOSLLH is available.
-	boolean setAutoHPPOSLLH(boolean enabled, uint16_t maxWait = defaultMaxWait); //Enable/disable automatic HPPOSLLH reports at the navigation frequency
-	boolean setAutoHPPOSLLH(boolean enabled, boolean implicitUpdate, uint16_t maxWait = defaultMaxWait); //Enable/disable automatic HPPOSLLH reports at the navigation frequency, with implicitUpdate == false accessing stale data will not issue parsing of data in the rxbuffer of your interface, instead you have to call checkUblox when you want to perform an update
-	boolean setAutoHPPOSLLHrate(uint8_t rate, boolean implicitUpdate = true, uint16_t maxWait = defaultMaxWait); //Set the rate for automatic HPPOSLLH reports
-	boolean setAutoHPPOSLLHcallback(void (*callbackPointer)(UBX_NAV_HPPOSLLH_data_t), uint16_t maxWait = defaultMaxWait); //Enable automatic HPPOSLLH reports at the navigation frequency. Data is accessed from the callback.
-	boolean assumeAutoHPPOSLLH(boolean enabled, boolean implicitUpdate = true); //In case no config access to the GPS is possible and HPPOSLLH is send cyclically already
-	void flushHPPOSLLH(); //Mark all the HPPPOSLLH data as read/stale. This is handy to get data alignment after CRC failure
-	void logNAVHPPOSLLH(boolean enabled = true); // Log data to file buffer
-
-	boolean getNAVCLOCK(uint16_t maxWait = defaultMaxWait); // NAV CLOCK
-	boolean setAutoNAVCLOCK(boolean enabled, uint16_t maxWait = defaultMaxWait);  //Enable/disable automatic clock reports at the navigation frequency
-	boolean setAutoNAVCLOCK(boolean enabled, boolean implicitUpdate, uint16_t maxWait = defaultMaxWait); //Enable/disable automatic clock reports at the navigation frequency, with implicitUpdate == false accessing stale data will not issue parsing of data in the rxbuffer of your interface, instead you have to call checkUblox when you want to perform an update
-	boolean setAutoNAVCLOCKrate(uint8_t rate, boolean implicitUpdate = true, uint16_t maxWait = defaultMaxWait); //Set the rate for automatic CLOCK reports
-	boolean setAutoNAVCLOCKcallback(void (*callbackPointer)(UBX_NAV_CLOCK_data_t), uint16_t maxWait = defaultMaxWait); //Enable automatic CLOCK reports at the navigation frequency. Data is accessed from the callback.
-	boolean assumeAutoNAVCLOCK(boolean enabled, boolean implicitUpdate = true); //In case no config access to the GPS is possible and clock is send cyclically already
-	void flushNAVCLOCK(); //Mark all the data as read/stale
-	void logNAVCLOCK(boolean enabled = true); // Log data to file buffer
-
-	// Add "auto" support for NAV SVIN - to avoid needing 'global' storage
-	boolean getSurveyStatus(uint16_t maxWait); //Reads survey in status
-
-	boolean getRELPOSNED(uint16_t maxWait = defaultMaxWait); //Get Relative Positioning Information of the NED frame
-	boolean setAutoRELPOSNED(boolean enabled, uint16_t maxWait = defaultMaxWait); //Enable/disable automatic RELPOSNED reports
-	boolean setAutoRELPOSNED(boolean enabled, boolean implicitUpdate, uint16_t maxWait = defaultMaxWait); //Enable/disable automatic RELPOSNED, with implicitUpdate == false accessing stale data will not issue parsing of data in the rxbuffer of your interface, instead you have to call checkUblox when you want to perform an update
-	boolean setAutoRELPOSNEDrate(uint8_t rate, boolean implicitUpdate = true, uint16_t maxWait = defaultMaxWait); //Set the rate for automatic RELPOSNEDreports
-	boolean setAutoRELPOSNEDcallback(void (*callbackPointer)(UBX_NAV_RELPOSNED_data_t), uint16_t maxWait = defaultMaxWait); //Enable automatic RELPOSNED reports at the navigation frequency. Data is accessed from the callback.
-	boolean assumeAutoRELPOSNED(boolean enabled, boolean implicitUpdate = true); //In case no config access to the GPS is possible and RELPOSNED is send cyclically already
-	void flushNAVRELPOSNED(); //Mark all the data as read/stale
-	void logNAVRELPOSNED(boolean enabled = true); // Log data to file buffer
-
-	// Receiver Manager Messages (RXM)
-
-	boolean getRXMSFRBX(uint16_t maxWait = defaultMaxWait); // RXM SFRBX
-	boolean setAutoRXMSFRBX(boolean enabled, uint16_t maxWait = defaultMaxWait);  //Enable/disable automatic RXM SFRBX reports at the navigation frequency
-	boolean setAutoRXMSFRBX(boolean enabled, boolean implicitUpdate, uint16_t maxWait = defaultMaxWait); //Enable/disable automatic RXM SFRBX reports at the navigation frequency, with implicitUpdate == false accessing stale data will not issue parsing of data in the rxbuffer of your interface, instead you have to call checkUblox when you want to perform an update
-	boolean setAutoRXMSFRBXrate(uint8_t rate, boolean implicitUpdate = true, uint16_t maxWait = defaultMaxWait); //Set the rate for automatic SFRBX reports
-	boolean setAutoRXMSFRBXcallback(void (*callbackPointer)(UBX_RXM_SFRBX_data_t), uint16_t maxWait = defaultMaxWait); //Enable automatic SFRBX reports at the navigation frequency. Data is accessed from the callback.
-	boolean assumeAutoRXMSFRBX(boolean enabled, boolean implicitUpdate = true); //In case no config access to the GPS is possible and RXM SFRBX is send cyclically already
-	void flushRXMSFRBX(); //Mark all the data as read/stale
-	void logRXMSFRBX(boolean enabled = true); // Log data to file buffer
-
-	boolean getRXMRAWX(uint16_t maxWait = defaultMaxWait); // RXM RAWX
-	boolean setAutoRXMRAWX(boolean enabled, uint16_t maxWait = defaultMaxWait);  //Enable/disable automatic RXM RAWX reports at the navigation frequency
-	boolean setAutoRXMRAWX(boolean enabled, boolean implicitUpdate, uint16_t maxWait = defaultMaxWait); //Enable/disable automatic RXM RAWX reports at the navigation frequency, with implicitUpdate == false accessing stale data will not issue parsing of data in the rxbuffer of your interface, instead you have to call checkUblox when you want to perform an update
-	boolean setAutoRXMRAWXrate(uint8_t rate, boolean implicitUpdate = true, uint16_t maxWait = defaultMaxWait); //Set the rate for automatic RAWX reports
-	boolean setAutoRXMRAWXcallback(void (*callbackPointer)(UBX_RXM_RAWX_data_t), uint16_t maxWait = defaultMaxWait); //Enable automatic RAWX reports at the navigation frequency. Data is accessed from the callback.
-	boolean assumeAutoRXMRAWX(boolean enabled, boolean implicitUpdate = true); //In case no config access to the GPS is possible and RXM RAWX is send cyclically already
-	void flushRXMRAWX(); //Mark all the data as read/stale
-	void logRXMRAWX(boolean enabled = true); // Log data to file buffer
-
-	// Configuration (CFG)
-
-	// Add "auto" support for CFG RATE - because we use it for isConnected (to stop it being mugged by other messages)
-	boolean getNavigationFrequencyInternal(uint16_t maxWait = defaultMaxWait); //Get the number of nav solutions sent per second currently being output by module
-
-	// Timing messages (TIM)
-
-	boolean getTIMTM2(uint16_t maxWait = defaultMaxWait); // TIM TM2
-	boolean setAutoTIMTM2(boolean enabled, uint16_t maxWait = defaultMaxWait);  //Enable/disable automatic TIM TM2 reports at the navigation frequency
-	boolean setAutoTIMTM2(boolean enabled, boolean implicitUpdate, uint16_t maxWait = defaultMaxWait); //Enable/disable automatic TIM TM2 reports at the navigation frequency, with implicitUpdate == false accessing stale data will not issue parsing of data in the rxbuffer of your interface, instead you have to call checkUblox when you want to perform an update
-	boolean setAutoTIMTM2rate(uint8_t rate, boolean implicitUpdate = true, uint16_t maxWait = defaultMaxWait); //Set the rate for automatic TIM TM2 reports
-	boolean setAutoTIMTM2callback(void (*callbackPointer)(UBX_TIM_TM2_data_t), uint16_t maxWait = defaultMaxWait); //Enable automatic TM2 reports at the navigation frequency. Data is accessed from the callback.
-	boolean assumeAutoTIMTM2(boolean enabled, boolean implicitUpdate = true); //In case no config access to the GPS is possible and TIM TM2 is send cyclically already
-	void flushTIMTM2(); //Mark all the data as read/stale
-	void logTIMTM2(boolean enabled = true); // Log data to file buffer
-
-	// Sensor fusion (dead reckoning) (ESF)
-
-	boolean getEsfAlignment(uint16_t maxWait = defaultMaxWait); // ESF ALG Helper
-	boolean getESFALG(uint16_t maxWait = defaultMaxWait); // ESF ALG
-	boolean setAutoESFALG(boolean enabled, uint16_t maxWait = defaultMaxWait); //Enable/disable automatic ESF ALG reports
-	boolean setAutoESFALG(boolean enabled, boolean implicitUpdate, uint16_t maxWait = defaultMaxWait); //Enable/disable automatic ESF ALG reports, with implicitUpdate == false accessing stale data will not issue parsing of data in the rxbuffer of your interface, instead you have to call checkUblox when you want to perform an update
-	boolean setAutoESFALGrate(uint8_t rate, boolean implicitUpdate = true, uint16_t maxWait = defaultMaxWait); //Set the rate for automatic ALG reports
-	boolean setAutoESFALGcallback(void (*callbackPointer)(UBX_ESF_ALG_data_t), uint16_t maxWait = defaultMaxWait); //Enable automatic ALG reports at the navigation frequency. Data is accessed from the callback.
-	boolean assumeAutoESFALG(boolean enabled, boolean implicitUpdate = true); //In case no config access to the GPS is possible and ESF ALG is send cyclically already
-	void flushESFALG(); //Mark all the data as read/stale
-	void logESFALG(boolean enabled = true); // Log data to file buffer
-
-	boolean getEsfInfo(uint16_t maxWait = defaultMaxWait); // ESF STATUS Helper
-	boolean getESFSTATUS(uint16_t maxWait = defaultMaxWait); // ESF STATUS
-	boolean setAutoESFSTATUS(boolean enabled, uint16_t maxWait = defaultMaxWait); //Enable/disable automatic ESF STATUS reports
-	boolean setAutoESFSTATUS(boolean enabled, boolean implicitUpdate, uint16_t maxWait = defaultMaxWait); //Enable/disable automatic ESF STATUS reports, with implicitUpdate == false accessing stale data will not issue parsing of data in the rxbuffer of your interface, instead you have to call checkUblox when you want to perform an update
-	boolean setAutoESFSTATUSrate(uint8_t rate, boolean implicitUpdate = true, uint16_t maxWait = defaultMaxWait); //Set the rate for automatic STATUS reports
-	boolean setAutoESFSTATUScallback(void (*callbackPointer)(UBX_ESF_STATUS_data_t), uint16_t maxWait = defaultMaxWait); //Enable automatic STATUS reports at the navigation frequency. Data is accessed from the callback.
-	boolean assumeAutoESFSTATUS(boolean enabled, boolean implicitUpdate = true); //In case no config access to the GPS is possible and ESF STATUS is send cyclically already
-	void flushESFSTATUS(); //Mark all the data as read/stale
-	void logESFSTATUS(boolean enabled = true); // Log data to file buffer
-
-	boolean getEsfIns(uint16_t maxWait = defaultMaxWait); // ESF INS Helper
-	boolean getESFINS(uint16_t maxWait = defaultMaxWait); // ESF INS
-	boolean setAutoESFINS(boolean enabled, uint16_t maxWait = defaultMaxWait); //Enable/disable automatic ESF INS reports
-	boolean setAutoESFINS(boolean enabled, boolean implicitUpdate, uint16_t maxWait = defaultMaxWait); //Enable/disable automatic ESF INS reports, with implicitUpdate == false accessing stale data will not issue parsing of data in the rxbuffer of your interface, instead you have to call checkUblox when you want to perform an update
-	boolean setAutoESFINSrate(uint8_t rate, boolean implicitUpdate = true, uint16_t maxWait = defaultMaxWait); //Set the rate for automatic INS reports
-	boolean setAutoESFINScallback(void (*callbackPointer)(UBX_ESF_INS_data_t), uint16_t maxWait = defaultMaxWait); //Enable automatic INS reports at the navigation frequency. Data is accessed from the callback.
-	boolean assumeAutoESFINS(boolean enabled, boolean implicitUpdate = true); //In case no config access to the GPS is possible and ESF INS is send cyclically already
-	void flushESFINS(); //Mark all the data as read/stale
-	void logESFINS(boolean enabled = true); // Log data to file buffer
-
-	boolean getEsfDataInfo(uint16_t maxWait = defaultMaxWait); // ESF MEAS Helper
-	boolean getESFMEAS(uint16_t maxWait = defaultMaxWait); // ESF MEAS
-	boolean setAutoESFMEAS(boolean enabled, uint16_t maxWait = defaultMaxWait); //Enable/disable automatic ESF MEAS reports
-	boolean setAutoESFMEAS(boolean enabled, boolean implicitUpdate, uint16_t maxWait = defaultMaxWait); //Enable/disable automatic ESF MEAS reports, with implicitUpdate == false accessing stale data will not issue parsing of data in the rxbuffer of your interface, instead you have to call checkUblox when you want to perform an update
-	boolean setAutoESFMEASrate(uint8_t rate, boolean implicitUpdate = true, uint16_t maxWait = defaultMaxWait); //Set the rate for automatic MEAS reports
-	boolean setAutoESFMEAScallback(void (*callbackPointer)(UBX_ESF_MEAS_data_t), uint16_t maxWait = defaultMaxWait); //Enable automatic MEAS reports at the navigation frequency. Data is accessed from the callback.
-	boolean assumeAutoESFMEAS(boolean enabled, boolean implicitUpdate = true); //In case no config access to the GPS is possible and ESF MEAS is send cyclically already
-	void flushESFMEAS(); //Mark all the data as read/stale
-	void logESFMEAS(boolean enabled = true); // Log data to file buffer
-
-	boolean getEsfRawDataInfo(uint16_t maxWait = defaultMaxWait); // ESF RAW Helper
-	boolean getESFRAW(uint16_t maxWait = defaultMaxWait); // ESF RAW
-	boolean setAutoESFRAW(boolean enabled, uint16_t maxWait = defaultMaxWait); //Enable/disable automatic ESF RAW reports
-	boolean setAutoESFRAW(boolean enabled, boolean implicitUpdate, uint16_t maxWait = defaultMaxWait); //Enable/disable automatic ESF RAW reports, with implicitUpdate == false accessing stale data will not issue parsing of data in the rxbuffer of your interface, instead you have to call checkUblox when you want to perform an update
-	boolean setAutoESFRAWrate(uint8_t rate, boolean implicitUpdate = true, uint16_t maxWait = defaultMaxWait); //Set the rate for automatic RAW reports
-	boolean setAutoESFRAWcallback(void (*callbackPointer)(UBX_ESF_RAW_data_t), uint16_t maxWait = defaultMaxWait); //Enable automatic RAW reports at the navigation frequency. Data is accessed from the callback.
-	boolean assumeAutoESFRAW(boolean enabled, boolean implicitUpdate = true); //In case no config access to the GPS is possible and ESF RAW is send cyclically already
-	void flushESFRAW(); //Mark all the data as read/stale
-	void logESFRAW(boolean enabled = true); // Log data to file buffer
-
-	// High navigation rate (HNR)
-
-	boolean getHNRAtt(uint16_t maxWait = defaultMaxWait); // HNR ATT Helper
-	boolean getHNRATT(uint16_t maxWait = defaultMaxWait); // Returns true if the get HNR attitude is successful
-	boolean setAutoHNRATT(boolean enabled, uint16_t maxWait = defaultMaxWait); //Enable/disable automatic HNR Attitude reports at the HNR rate
-	boolean setAutoHNRATT(boolean enabled, boolean implicitUpdate, uint16_t maxWait = defaultMaxWait); //Enable/disable automatic HNR Attitude reports at the HNR rate, with implicitUpdate == false accessing stale data will not issue parsing of data in the rxbuffer of your interface, instead you have to call checkUblox when you want to perform an update
-	boolean setAutoHNRATTrate(uint8_t rate, boolean implicitUpdate = true, uint16_t maxWait = defaultMaxWait); //Set the rate for automatic ATT reports
-	boolean setAutoHNRATTcallback(void (*callbackPointer)(UBX_HNR_ATT_data_t), uint16_t maxWait = defaultMaxWait); //Enable automatic ATT reports at the navigation frequency. Data is accessed from the callback.
-	boolean assumeAutoHNRATT(boolean enabled, boolean implicitUpdate = true); //In case no config access to the GPS is possible and HNR Attitude is send cyclically already
-	void flushHNRATT(); //Mark all the data as read/stale
-	void logHNRATT(boolean enabled = true); // Log data to file buffer
-
-	boolean getHNRDyn(uint16_t maxWait = defaultMaxWait); // HNR INS Helper
-	boolean getHNRINS(uint16_t maxWait = defaultMaxWait); // Returns true if the get HNR dynamics is successful
-	boolean setAutoHNRINS(boolean enabled, uint16_t maxWait = defaultMaxWait); //Enable/disable automatic HNR dynamics reports at the HNR rate
-	boolean setAutoHNRINS(boolean enabled, boolean implicitUpdate, uint16_t maxWait = defaultMaxWait); //Enable/disable automatic HNR dynamics reports at the HNR rate, with implicitUpdate == false accessing stale data will not issue parsing of data in the rxbuffer of your interface, instead you have to call checkUblox when you want to perform an update
-	boolean setAutoHNRINSrate(uint8_t rate, boolean implicitUpdate = true, uint16_t maxWait = defaultMaxWait); //Set the rate for automatic INS reports
-	boolean setAutoHNRINScallback(void (*callbackPointer)(UBX_HNR_INS_data_t), uint16_t maxWait = defaultMaxWait); //Enable automatic INS reports at the navigation frequency. Data is accessed from the callback.
-	boolean assumeAutoHNRINS(boolean enabled, boolean implicitUpdate = true); //In case no config access to the GPS is possible and HNR dynamics is send cyclically already
-	void flushHNRINS(); //Mark all the data as read/stale
-	void logHNRINS(boolean enabled = true); // Log data to file buffer
-
-	boolean getHNRPVT(uint16_t maxWait = defaultMaxWait); // Returns true if the get HNR PVT is successful
-	boolean setAutoHNRPVT(boolean enabled, uint16_t maxWait = defaultMaxWait); //Enable/disable automatic HNR PVT reports at the HNR rate
-	boolean setAutoHNRPVT(boolean enabled, boolean implicitUpdate, uint16_t maxWait = defaultMaxWait); //Enable/disable automatic HNR PVT reports at the HNR rate, with implicitUpdate == false accessing stale data will not issue parsing of data in the rxbuffer of your interface, instead you have to call checkUblox when you want to perform an update
-	boolean setAutoHNRPVTrate(uint8_t rate, boolean implicitUpdate = true, uint16_t maxWait = defaultMaxWait); //Set the rate for automatic PVT reports
-	boolean setAutoHNRPVTcallback(void (*callbackPointer)(UBX_HNR_PVT_data_t), uint16_t maxWait = defaultMaxWait); //Enable automatic PVT reports at the navigation frequency. Data is accessed from the callback.
-	boolean assumeAutoHNRPVT(boolean enabled, boolean implicitUpdate = true); //In case no config access to the GPS is possible and HNR PVT is send cyclically already
-	void flushHNRPVT(); //Mark all the data as read/stale
-	void logHNRPVT(boolean enabled = true); // Log data to file buffer
-
-	// Helper functions for CFG RATE
-
-	boolean setNavigationFrequency(uint8_t navFreq, uint16_t maxWait = defaultMaxWait);	//Set the number of nav solutions sent per second
-	uint8_t getNavigationFrequency(uint16_t maxWait = defaultMaxWait);					//Get the number of nav solutions sent per second currently being output by module
-	boolean setMeasurementRate(uint16_t rate, uint16_t maxWait = defaultMaxWait);		//Set the elapsed time between GNSS measurements in milliseconds, which defines the rate
-	uint16_t getMeasurementRate(uint16_t maxWait = defaultMaxWait);					 	//Return the elapsed time between GNSS measurements in milliseconds
-	boolean setNavigationRate(uint16_t rate, uint16_t maxWait = defaultMaxWait);		//Set the ratio between the number of measurements and the number of navigation solutions. Unit is cycles. Max is 127
-	uint16_t getNavigationRate(uint16_t maxWait = defaultMaxWait);					 	//Return the ratio between the number of measurements and the number of navigation solutions. Unit is cycles
-
-	// Helper functions for DOP
-
-	uint16_t getGeometricDOP(uint16_t maxWait = defaultMaxWait);
-	uint16_t getPositionDOP(uint16_t maxWait = defaultMaxWait);
-	uint16_t getTimeDOP(uint16_t maxWait = defaultMaxWait);
-	uint16_t getVerticalDOP(uint16_t maxWait = defaultMaxWait);
-	uint16_t getHorizontalDOP(uint16_t maxWait = defaultMaxWait);
-	uint16_t getNorthingDOP(uint16_t maxWait = defaultMaxWait);
-	uint16_t getEastingDOP(uint16_t maxWait = defaultMaxWait);
-
-	// Helper functions for ATT
-
-	float getATTroll(uint16_t maxWait = defaultMaxWait); // Returned as degrees
-	float getATTpitch(uint16_t maxWait = defaultMaxWait); // Returned as degrees
-	float getATTheading(uint16_t maxWait = defaultMaxWait); // Returned as degrees
-
-	// Helper functions for PVT
-
-	uint32_t getTimeOfWeek(uint16_t maxWait = defaultMaxWait);
-	uint16_t getYear(uint16_t maxWait = defaultMaxWait);
-	uint8_t getMonth(uint16_t maxWait = defaultMaxWait);
-	uint8_t getDay(uint16_t maxWait = defaultMaxWait);
-	uint8_t getHour(uint16_t maxWait = defaultMaxWait);
-	uint8_t getMinute(uint16_t maxWait = defaultMaxWait);
-	uint8_t getSecond(uint16_t maxWait = defaultMaxWait);
-	uint16_t getMillisecond(uint16_t maxWait = defaultMaxWait);
-	int32_t getNanosecond(uint16_t maxWait = defaultMaxWait);
-	uint32_t getUnixEpoch(uint16_t maxWait = defaultMaxWait);
-	uint32_t getUnixEpoch(uint32_t& microsecond, uint16_t maxWait = defaultMaxWait);
-
-	bool getDateValid(uint16_t maxWait = defaultMaxWait);
-	bool getTimeValid(uint16_t maxWait = defaultMaxWait);
-	bool getConfirmedDate(uint16_t maxWait = defaultMaxWait);
-	bool getConfirmedTime(uint16_t maxWait = defaultMaxWait);
-
-	uint8_t getFixType(uint16_t maxWait = defaultMaxWait); //Returns the type of fix: 0=no, 3=3D, 4=GNSS+Deadreckoning
-
-	bool getGnssFixOk(uint16_t maxWait = defaultMaxWait); //Get whether we have a valid fix (i.e within DOP & accuracy masks)
-	bool getDiffSoln(uint16_t maxWait = defaultMaxWait); //Get whether differential corrections were applied
-	bool getHeadVehValid(uint16_t maxWait = defaultMaxWait);
-	uint8_t getCarrierSolutionType(uint16_t maxWait = defaultMaxWait); //Returns RTK solution: 0=no, 1=float solution, 2=fixed solution
-
-	uint8_t getSIV(uint16_t maxWait = defaultMaxWait); //Returns number of sats used in fix
-	int32_t getLongitude(uint16_t maxWait = defaultMaxWait); //Returns the current longitude in degrees * 10-7. Auto selects between HighPrecision and Regular depending on ability of module.
-	int32_t getLatitude(uint16_t maxWait = defaultMaxWait); //Returns the current latitude in degrees * 10^-7. Auto selects between HighPrecision and Regular depending on ability of module.
-	int32_t getAltitude(uint16_t maxWait = defaultMaxWait); //Returns the current altitude in mm above ellipsoid
-	int32_t getAltitudeMSL(uint16_t maxWait = defaultMaxWait); //Returns the current altitude in mm above mean sea level
-	int32_t getHorizontalAccEst(uint16_t maxWait = defaultMaxWait);
-	int32_t getVerticalAccEst(uint16_t maxWait = defaultMaxWait);
-	int32_t getNedNorthVel(uint16_t maxWait = defaultMaxWait);
-	int32_t getNedEastVel(uint16_t maxWait = defaultMaxWait);
-	int32_t getNedDownVel(uint16_t maxWait = defaultMaxWait);
-	int32_t getGroundSpeed(uint16_t maxWait = defaultMaxWait); //Returns speed in mm/s
-	int32_t getHeading(uint16_t maxWait = defaultMaxWait); //Returns heading in degrees * 10^-5
-	uint32_t getSpeedAccEst(uint16_t maxWait = defaultMaxWait);
-	uint32_t getHeadingAccEst(uint16_t maxWait = defaultMaxWait);
-	uint16_t getPDOP(uint16_t maxWait = defaultMaxWait); //Returns positional dillution of precision * 10^-2 (dimensionless)
-
-	bool getInvalidLlh(uint16_t maxWait = defaultMaxWait);
-
-	int32_t getHeadVeh(uint16_t maxWait = defaultMaxWait);
-	int16_t getMagDec(uint16_t maxWait = defaultMaxWait);
-	uint16_t getMagAcc(uint16_t maxWait = defaultMaxWait);
-
-	int32_t getGeoidSeparation(uint16_t maxWait = defaultMaxWait);
-
-	// Helper functions for HPPOSECEF
-
-	uint32_t getPositionAccuracy(uint16_t maxWait = 1100); //Returns the 3D accuracy of the current high-precision fix, in mm. Supported on NEO-M8P, ZED-F9P,
-
-	// Helper functions for HPPOSLLH
-
-	uint32_t getTimeOfWeekFromHPPOSLLH(uint16_t maxWait = defaultMaxWait);
-	int32_t getHighResLongitude(uint16_t maxWait = defaultMaxWait);
-	int32_t getHighResLatitude(uint16_t maxWait = defaultMaxWait);
-	int32_t getElipsoid(uint16_t maxWait = defaultMaxWait);
-	int32_t getMeanSeaLevel(uint16_t maxWait = defaultMaxWait);
-	int8_t getHighResLongitudeHp(uint16_t maxWait = defaultMaxWait);
-	int8_t getHighResLatitudeHp(uint16_t maxWait = defaultMaxWait);
-	int8_t getElipsoidHp(uint16_t maxWait = defaultMaxWait);
-	int8_t getMeanSeaLevelHp(uint16_t maxWait = defaultMaxWait);
-	uint32_t getHorizontalAccuracy(uint16_t maxWait = defaultMaxWait);
-	uint32_t getVerticalAccuracy(uint16_t maxWait = defaultMaxWait);
-
-	// Helper functions for SVIN
-
-	boolean getSurveyInActive(uint16_t maxWait = defaultMaxWait);
-	boolean getSurveyInValid(uint16_t maxWait = defaultMaxWait);
-	uint16_t getSurveyInObservationTime(uint16_t maxWait = defaultMaxWait); // Truncated to 65535 seconds
-	float getSurveyInMeanAccuracy(uint16_t maxWait = defaultMaxWait); // Returned as m
-
-	// Helper functions for RELPOSNED
-
-	float getRelPosN(uint16_t maxWait = defaultMaxWait); // Returned as m
-	float getRelPosE(uint16_t maxWait = defaultMaxWait); // Returned as m
-	float getRelPosD(uint16_t maxWait = defaultMaxWait); // Returned as m
-	float getRelPosAccN(uint16_t maxWait = defaultMaxWait); // Returned as m
-	float getRelPosAccE(uint16_t maxWait = defaultMaxWait); // Returned as m
-	float getRelPosAccD(uint16_t maxWait = defaultMaxWait); // Returned as m
-
-	// Helper functions for ESF
-
-	float getESFroll(uint16_t maxWait = defaultMaxWait); // Returned as degrees
-	float getESFpitch(uint16_t maxWait = defaultMaxWait); // Returned as degrees
-	float getESFyaw(uint16_t maxWait = defaultMaxWait); // Returned as degrees
-	boolean getSensorFusionMeasurement(UBX_ESF_MEAS_sensorData_t *sensorData, uint8_t sensor, uint16_t maxWait = defaultMaxWait);
-	boolean getSensorFusionMeasurement(UBX_ESF_MEAS_sensorData_t *sensorData, UBX_ESF_MEAS_data_t ubxDataStruct, uint8_t sensor);
-	boolean getRawSensorMeasurement(UBX_ESF_RAW_sensorData_t *sensorData, uint8_t sensor, uint16_t maxWait = defaultMaxWait);
-	boolean getRawSensorMeasurement(UBX_ESF_RAW_sensorData_t *sensorData, UBX_ESF_RAW_data_t ubxDataStruct, uint8_t sensor);
-	boolean getSensorFusionStatus(UBX_ESF_STATUS_sensorStatus_t *sensorStatus, uint8_t sensor, uint16_t maxWait = defaultMaxWait);
-	boolean getSensorFusionStatus(UBX_ESF_STATUS_sensorStatus_t *sensorStatus, UBX_ESF_STATUS_data_t ubxDataStruct, uint8_t sensor);
-
-	// Helper functions for HNR
-
-	boolean setHNRNavigationRate(uint8_t rate, uint16_t maxWait = 1100); // Returns true if the setHNRNavigationRate is successful
-	uint8_t getHNRNavigationRate(uint16_t maxWait = 1100); // Returns 0 if the getHNRNavigationRate fails
-	float getHNRroll(uint16_t maxWait = defaultMaxWait); // Returned as degrees
-	float getHNRpitch(uint16_t maxWait = defaultMaxWait); // Returned as degrees
-	float getHNRheading(uint16_t maxWait = defaultMaxWait); // Returned as degrees
-
-	// Functions to extract signed and unsigned 8/16/32-bit data from a ubxPacket
-	// From v2.0: These are public. The user can call these to extract data from custom packets
-	uint32_t extractLong(ubxPacket *msg, uint8_t spotToStart); //Combine four bytes from payload into long
-	int32_t extractSignedLong(ubxPacket *msg, uint8_t spotToStart); //Combine four bytes from payload into signed long (avoiding any ambiguity caused by casting)
-	uint16_t extractInt(ubxPacket *msg, uint8_t spotToStart); //Combine two bytes from payload into int
-	int16_t extractSignedInt(ubxPacket *msg, int8_t spotToStart);
-	uint8_t extractByte(ubxPacket *msg, uint8_t spotToStart); //Get byte from payload
-	int8_t extractSignedChar(ubxPacket *msg, uint8_t spotToStart); //Get signed 8-bit value from payload
-
-	// Pointers to storage for the "automatic" messages
-	// RAM is allocated for these if/when required.
-
-	UBX_NAV_POSECEF_t *packetUBXNAVPOSECEF = NULL; // Pointer to struct. RAM will be allocated for this if/when necessary
-	UBX_NAV_STATUS_t *packetUBXNAVSTATUS = NULL; // Pointer to struct. RAM will be allocated for this if/when necessary
-	UBX_NAV_DOP_t *packetUBXNAVDOP = NULL; // Pointer to struct. RAM will be allocated for this if/when necessary
-	UBX_NAV_ATT_t *packetUBXNAVATT = NULL; // Pointer to struct. RAM will be allocated for this if/when necessary
-	UBX_NAV_PVT_t *packetUBXNAVPVT = NULL; // Pointer to struct. RAM will be allocated for this if/when necessary
-	UBX_NAV_ODO_t *packetUBXNAVODO = NULL; // Pointer to struct. RAM will be allocated for this if/when necessary
-	UBX_NAV_VELECEF_t *packetUBXNAVVELECEF = NULL; // Pointer to struct. RAM will be allocated for this if/when necessary
-	UBX_NAV_VELNED_t *packetUBXNAVVELNED = NULL; // Pointer to struct. RAM will be allocated for this if/when necessary
-	UBX_NAV_HPPOSECEF_t *packetUBXNAVHPPOSECEF = NULL; // Pointer to struct. RAM will be allocated for this if/when necessary
-	UBX_NAV_HPPOSLLH_t *packetUBXNAVHPPOSLLH = NULL; // Pointer to struct. RAM will be allocated for this if/when necessary
-	UBX_NAV_CLOCK_t *packetUBXNAVCLOCK = NULL; // Pointer to struct. RAM will be allocated for this if/when necessary
-	UBX_NAV_SVIN_t *packetUBXNAVSVIN = NULL; // Pointer to struct. RAM will be allocated for this if/when necessary
-	UBX_NAV_RELPOSNED_t *packetUBXNAVRELPOSNED = NULL; // Pointer to struct. RAM will be allocated for this if/when necessary
-
-	UBX_RXM_SFRBX_t *packetUBXRXMSFRBX = NULL; // Pointer to struct. RAM will be allocated for this if/when necessary
-	UBX_RXM_RAWX_t *packetUBXRXMRAWX = NULL; // Pointer to struct. RAM will be allocated for this if/when necessary
-
-	UBX_CFG_RATE_t *packetUBXCFGRATE = NULL; // Pointer to struct. RAM will be allocated for this if/when necessary
-
-	UBX_TIM_TM2_t *packetUBXTIMTM2 = NULL; // Pointer to struct. RAM will be allocated for this if/when necessary
-
-	UBX_ESF_ALG_t *packetUBXESFALG = NULL; // Pointer to struct. RAM will be allocated for this if/when necessary
-	UBX_ESF_INS_t *packetUBXESFINS = NULL; // Pointer to struct. RAM will be allocated for this if/when necessary
-	UBX_ESF_MEAS_t *packetUBXESFMEAS = NULL; // Pointer to struct. RAM will be allocated for this if/when necessary
-	UBX_ESF_RAW_t *packetUBXESFRAW = NULL; // Pointer to struct. RAM will be allocated for this if/when necessary
-	UBX_ESF_STATUS_t *packetUBXESFSTATUS = NULL; // Pointer to struct. RAM will be allocated for this if/when necessary
-
-	UBX_HNR_PVT_t *packetUBXHNRPVT = NULL; // Pointer to struct. RAM will be allocated for this if/when necessary
-	UBX_HNR_ATT_t *packetUBXHNRATT = NULL; // Pointer to struct. RAM will be allocated for this if/when necessary
-	UBX_HNR_INS_t *packetUBXHNRINS = NULL; // Pointer to struct. RAM will be allocated for this if/when necessary
-
-	uint16_t rtcmFrameCounter = 0; //Tracks the type of incoming byte inside RTCM frame
-
-private:
-	//Depending on the sentence type the processor will load characters into different arrays
-	enum SentenceTypes
-	{
-		NONE = 0,
-		NMEA,
-		UBX,
-		RTCM
-	} currentSentence = NONE;
-
-	//Depending on the ubx binary response class, store binary responses into different places
-	enum classTypes
-	{
-		CLASS_NONE = 0,
-		CLASS_ACK,
-		CLASS_NOT_AN_ACK
-	} ubxFrameClass = CLASS_NONE;
-
-	enum commTypes
-	{
-		COMM_TYPE_I2C = 0,
-		COMM_TYPE_SERIAL,
-		COMM_TYPE_SPI
-	} commType = COMM_TYPE_I2C; //Controls which port we look to for incoming bytes
-
-	//Functions
-	boolean checkUbloxInternal(ubxPacket *incomingUBX, uint8_t requestedClass = 255, uint8_t requestedID = 255); //Checks module with user selected commType
-	void addToChecksum(uint8_t incoming);																		 //Given an incoming byte, adjust rollingChecksumA/B
-
-	//Return true if this "automatic" message has storage allocated for it
-	boolean checkAutomatic(uint8_t Class, uint8_t ID);
-
-	//Calculate how much RAM is needed to store the payload for a given automatic message
-	uint16_t getMaxPayloadSize(uint8_t Class, uint8_t ID);
-
-	boolean initGeofenceParams(); // Allocate RAM for currentGeofenceParams and initialize it
-	boolean initModuleSWVersion(); // Allocate RAM for moduleSWVersion and initialize it
-
-	// The initPacket functions need to be private as they don't check if memory has already been allocated.
-	// Functions like setAutoNAVPOSECEF will check that memory has not been allocated before calling initPacket.
-	boolean initPacketUBXNAVPOSECEF(); // Allocate RAM for packetUBXNAVPOSECEF and initialize it
-	boolean initPacketUBXNAVSTATUS(); // Allocate RAM for packetUBXNAVSTATUS and initialize it
-	boolean initPacketUBXNAVDOP(); // Allocate RAM for packetUBXNAVDOP and initialize it
-	boolean initPacketUBXNAVATT(); // Allocate RAM for packetUBXNAVATT and initialize it
-	boolean initPacketUBXNAVPVT(); // Allocate RAM for packetUBXNAVPVT and initialize it
-	boolean initPacketUBXNAVODO(); // Allocate RAM for packetUBXNAVODO and initialize it
-	boolean initPacketUBXNAVVELECEF(); // Allocate RAM for packetUBXNAVVELECEF and initialize it
-	boolean initPacketUBXNAVVELNED(); // Allocate RAM for packetUBXNAVVELNED and initialize it
-	boolean initPacketUBXNAVHPPOSECEF(); // Allocate RAM for packetUBXNAVHPPOSECEF and initialize it
-	boolean initPacketUBXNAVHPPOSLLH(); // Allocate RAM for packetUBXNAVHPPOSLLH and initialize it
-	boolean initPacketUBXNAVCLOCK(); // Allocate RAM for packetUBXNAVCLOCK and initialize it
-	boolean initPacketUBXNAVSVIN(); // Allocate RAM for packetUBXNAVSVIN and initialize it
-	boolean initPacketUBXNAVRELPOSNED(); // Allocate RAM for packetUBXNAVRELPOSNED and initialize it
-	boolean initPacketUBXRXMSFRBX(); // Allocate RAM for packetUBXRXMSFRBX and initialize it
-	boolean initPacketUBXRXMRAWX(); // Allocate RAM for packetUBXRXMRAWX and initialize it
-	boolean initPacketUBXCFGRATE(); // Allocate RAM for packetUBXCFGRATE and initialize it
-	boolean initPacketUBXTIMTM2(); // Allocate RAM for packetUBXTIMTM2 and initialize it
-	boolean initPacketUBXESFALG(); // Allocate RAM for packetUBXESFALG and initialize it
-	boolean initPacketUBXESFSTATUS(); // Allocate RAM for packetUBXESFSTATUS and initialize it
-	boolean initPacketUBXESFINS(); // Allocate RAM for packetUBXESFINS and initialize it
-	boolean initPacketUBXESFMEAS(); // Allocate RAM for packetUBXESFMEAS and initialize it
-	boolean initPacketUBXESFRAW(); // Allocate RAM for packetUBXESFRAW and initialize it
-	boolean initPacketUBXHNRATT(); // Allocate RAM for packetUBXHNRATT and initialize it
-	boolean initPacketUBXHNRINS(); // Allocate RAM for packetUBXHNRINS and initialize it
-	boolean initPacketUBXHNRPVT(); // Allocate RAM for packetUBXHNRPVT and initialize it
-
-	//Variables
-	TwoWire *_i2cPort;				//The generic connection to user's chosen I2C hardware
-	Stream *_serialPort;			//The generic connection to user's chosen Serial hardware
-	Stream *_nmeaOutputPort = NULL; //The user can assign an output port to print NMEA sentences if they wish
-	Stream *_debugSerial;			//The stream to send debug messages to if enabled
-
-	uint8_t _gpsI2Caddress = 0x42; //Default 7-bit unshifted address of the ublox 6/7/8/M8/F9 series
-	//This can be changed using the ublox configuration software
-
-	boolean _printDebug = false;		//Flag to print the serial commands we are sending to the Serial port for debug
-	boolean _printLimitedDebug = false; //Flag to print limited debug messages. Useful for I2C debugging or high navigation rates
-
-	boolean ubx7FcheckDisabled = false; // Flag to indicate if the "7F" check should be ignored in checkUbloxI2C
-
-	//The packet buffers
-	//These are pointed at from within the ubxPacket
-	uint8_t payloadAck[2];				  // Holds the requested ACK/NACK
-	uint8_t payloadBuf[2];				  // Temporary buffer used to screen incoming packets or dump unrequested packets
-	size_t packetCfgPayloadSize = 0; // Size for the packetCfg payload. .begin will set this to MAX_PAYLOAD_SIZE if necessary. User can change with setPacketCfgPayloadSize
-	uint8_t *payloadCfg = NULL;
-	uint8_t *payloadAuto = NULL;
-
-	//Init the packet structures and init them with pointers to the payloadAck, payloadCfg, payloadBuf and payloadAuto arrays
-	ubxPacket packetAck = {0, 0, 0, 0, 0, payloadAck, 0, 0, SFE_UBLOX_PACKET_VALIDITY_NOT_DEFINED, SFE_UBLOX_PACKET_VALIDITY_NOT_DEFINED};
-	ubxPacket packetBuf = {0, 0, 0, 0, 0, payloadBuf, 0, 0, SFE_UBLOX_PACKET_VALIDITY_NOT_DEFINED, SFE_UBLOX_PACKET_VALIDITY_NOT_DEFINED};
-	ubxPacket packetCfg = {0, 0, 0, 0, 0, payloadCfg, 0, 0, SFE_UBLOX_PACKET_VALIDITY_NOT_DEFINED, SFE_UBLOX_PACKET_VALIDITY_NOT_DEFINED};
-	ubxPacket packetAuto = {0, 0, 0, 0, 0, payloadAuto, 0, 0, SFE_UBLOX_PACKET_VALIDITY_NOT_DEFINED, SFE_UBLOX_PACKET_VALIDITY_NOT_DEFINED};
-
-	//Flag if this packet is unrequested (and so should be ignored and not copied into packetCfg or packetAck)
-	boolean ignoreThisPayload = false;
-
-	//Identify which buffer is in use
-	//Data is stored in packetBuf until the requested class and ID can be validated
-	//If a match is seen, data is diverted into packetAck or packetCfg
-	//"Automatic" messages which have RAM allocated for them are diverted into packetAuto
-	sfe_ublox_packet_buffer_e activePacketBuffer = SFE_UBLOX_PACKET_PACKETBUF;
-
-	//Limit checking of new data to every X ms
-	//If we are expecting an update every X Hz then we should check every half that amount of time
-	//Otherwise we may block ourselves from seeing new data
-	uint8_t i2cPollingWait = 100; //Default to 100ms. Adjusted when user calls setNavigationFrequency() or setHNRNavigationRate() or setMeasurementRate()
-
-	unsigned long lastCheck = 0;
-
-	uint16_t ubxFrameCounter;			  //It counts all UBX frame. [Fixed header(2bytes), CLS(1byte), ID(1byte), length(2bytes), payload(x bytes), checksums(2bytes)]
-
-	uint8_t rollingChecksumA; //Rolls forward as we receive incoming bytes. Checked against the last two A/B checksum bytes
-	uint8_t rollingChecksumB; //Rolls forward as we receive incoming bytes. Checked against the last two A/B checksum bytes
-
-	uint16_t rtcmLen = 0;
-
-	// Flag to prevent reentry into checkCallbacks
-	// Prevent badness if the user accidentally calls checkCallbacks from inside a callback
-	volatile boolean checkCallbacksReentrant = false;
-
-	// Support for data logging
-	uint8_t *ubxFileBuffer = NULL; // Pointer to the file buffer. RAM is allocated for this if required in .begin
-	uint16_t fileBufferSize = 0; // The size of the file buffer. This can be changed by calling setFileBufferSize _before_ .begin
-	uint16_t fileBufferHead; // The incoming byte is written into the file buffer at this location
-	uint16_t fileBufferTail; // The next byte to be read from the buffer will be read from this location
-	uint16_t fileBufferMaxAvail = 0; // The maximum number of bytes the file buffer has contained. Handy for checking the buffer is large enough to handle all the incoming data.
-	boolean createFileBuffer(void); // Create the file buffer. Called by .begin
-	uint16_t fileBufferSpaceAvailable(void); // Check how much space is available in the buffer
-	uint16_t fileBufferSpaceUsed(void); // Check how much space is used in the buffer
-	boolean storePacket(ubxPacket *msg); // Add a UBX packet to the file buffer
-	boolean storeFileBytes(uint8_t *theBytes, uint16_t numBytes); // Add theBytes to the file buffer
-	void writeToFileBuffer(uint8_t *theBytes, uint16_t numBytes); // Write theBytes to the file buffer
-};
-
-#endif
diff --git a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/src/u-blox_config_keys.h b/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/src/u-blox_config_keys.h
deleted file mode 100644
index 9217d46..0000000
--- a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/src/u-blox_config_keys.h
+++ /dev/null
@@ -1,839 +0,0 @@
-/*
-	This is a library written for the u-blox ZED-F9P and NEO-M8P-2
-	SparkFun sells these at its website: www.sparkfun.com
-	Do you like this library? Help support SparkFun. Buy a board!
-	https://www.sparkfun.com/products/16481
-	https://www.sparkfun.com/products/15136
-	https://www.sparkfun.com/products/15005
-	https://www.sparkfun.com/products/15733
-	https://www.sparkfun.com/products/15193
-	https://www.sparkfun.com/products/15210
-
-  Original version by Nathan Seidle @ SparkFun Electronics, September 6th, 2018
-	v2.0 rework by Paul Clark @ SparkFun Electronics, December 31st, 2020
-
-	This library handles configuring and handling the responses
-	from a u-blox GPS module. Works with most modules from u-blox including
-	the Zed-F9P, NEO-M8P-2, NEO-M9N, ZOE-M8Q, SAM-M8Q, and many others.
-
-	https://github.com/sparkfun/SparkFun_Ublox_Arduino_Library
-
-	Development environment specifics:
-	Arduino IDE 1.8.13
-
-	SparkFun code, firmware, and software is released under the MIT License(http://opensource.org/licenses/MIT).
-	The MIT License (MIT)
-	Copyright (c) 2016 SparkFun Electronics
-	Permission is hereby granted, free of charge, to any person obtaining a copy of this software and
-	associated documentation files (the "Software"), to deal in the Software without restriction,
-	including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
-	and/or sell copies of the Software, and to permit persons to whom the Software is furnished to
-	do so, subject to the following conditions:
-
-	The above copyright notice and this permission notice shall be included in all copies or substantial
-	portions of the Software.
-
-	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT
-	NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
-	IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
-	WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
-	SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-*/
-
-#ifndef __u_blox_config_keys_h__
-#define __u_blox_config_keys_h__
-
-//The following consts are used to generate KEY values for the advanced protocol functions of VELGET/SET/DEL
-const uint8_t VAL_SIZE_1 = 0x01; //One bit
-const uint8_t VAL_SIZE_8 = 0x02;	 //One byte
-const uint8_t VAL_SIZE_16 = 0x03;	 //Two bytes
-const uint8_t VAL_SIZE_32 = 0x04;	 //Four bytes
-const uint8_t VAL_SIZE_64 = 0x05;	 //Eight bytes
-
-//These are the Bitfield layers definitions for the UBX-CFG-VALSET message (not to be confused with Bitfield deviceMask in UBX-CFG-CFG)
-const uint8_t VAL_LAYER_RAM = (1 << 0);
-const uint8_t VAL_LAYER_BBR = (1 << 1);
-const uint8_t VAL_LAYER_FLASH = (1 << 2);
-const uint8_t VAL_LAYER_ALL = VAL_LAYER_RAM | VAL_LAYER_BBR | VAL_LAYER_FLASH; //Not valid with getVal()
-
-//Below are various Groups, IDs, and sizes for various settings
-//These can be used to call getVal/setVal/delVal
-//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
-const uint8_t VAL_ID_PROT_UBX = 0x01;
-const uint8_t VAL_ID_PROT_NMEA = 0x02;
-const uint8_t VAL_ID_PROT_RTCM3 = 0x04;
-
-const uint8_t VAL_GROUP_I2C = 0x51;
-const uint8_t VAL_GROUP_I2COUTPROT = 0x72;
-const uint8_t VAL_GROUP_UART1INPROT = 0x73;
-const uint8_t VAL_GROUP_UART1OUTPROT = 0x74;
-const uint8_t VAL_GROUP_UART2INPROT = 0x75;
-const uint8_t VAL_GROUP_UART2OUTPROT = 0x76;
-const uint8_t VAL_GROUP_USBINPROT = 0x77;
-const uint8_t VAL_GROUP_USBOUTPROT = 0x78;
-
-const uint8_t VAL_GROUP_UART_SIZE = VAL_SIZE_1; //All fields in UART group are currently 1 bit
-const uint8_t VAL_GROUP_I2C_SIZE = VAL_SIZE_8;	//All fields in I2C group are currently 1 byte
-
-const uint8_t VAL_ID_I2C_ADDRESS = 0x01;
-
-//Below are the key values for a given configuration setting
-
-//CFG-BDS: BeiDou system configuration
-//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
-const uint32_t UBLOX_CFG_BDS_USE_PRN_1_TO_5 = 0x10340014; // Use BeiDou geostationary satellites (PRN 1-5)
-
-//CFG-GEOFENCE: Geofencing configuration
-//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
-const uint32_t UBLOX_CFG_GEOFENCE_CONFLVL = 0x20240011;	// Required confidence level for state evaluation
-const uint32_t UBLOX_CFG_GEOFENCE_USE_PIO = 0x10240012;	// Use PIO combined fence state output
-const uint32_t UBLOX_CFG_GEOFENCE_PINPOL = 0x20240013;	// PIO pin polarity
-const uint32_t UBLOX_CFG_GEOFENCE_PIN = 0x20240014;	// PIO pin number
-const uint32_t UBLOX_CFG_GEOFENCE_USE_FENCE1 = 0x10240020;	// Use frst geofence
-const uint32_t UBLOX_CFG_GEOFENCE_FENCE1_LAT = 0x40240021;	// Latitude of the first geofence circle center
-const uint32_t UBLOX_CFG_GEOFENCE_FENCE1_LON = 0x40240022;	// Longitude of the first geofence circle center
-const uint32_t UBLOX_CFG_GEOFENCE_FENCE1_RAD = 0x40240023;	// Radius of the first geofence circle
-const uint32_t UBLOX_CFG_GEOFENCE_USE_FENCE2 = 0x10240030;	// Use second geofence
-const uint32_t UBLOX_CFG_GEOFENCE_FENCE2_LAT = 0x40240031;	// Latitude of the second geofence circle center
-const uint32_t UBLOX_CFG_GEOFENCE_FENCE2_LON = 0x40240032;	// Longitude of the second geofence circle center
-const uint32_t UBLOX_CFG_GEOFENCE_FENCE2_RAD = 0x40240033;	// Radius of the second geofence circle
-const uint32_t UBLOX_CFG_GEOFENCE_USE_FENCE3 = 0x10240040;	// Use third geofence
-const uint32_t UBLOX_CFG_GEOFENCE_FENCE3_LAT = 0x40240041;	// Latitude of the third geofence circle center
-const uint32_t UBLOX_CFG_GEOFENCE_FENCE3_LON = 0x40240042;	// Longitude of the third geofence circle center
-const uint32_t UBLOX_CFG_GEOFENCE_FENCE3_RAD = 0x40240043;	// Radius of the third geofence circle
-const uint32_t UBLOX_CFG_GEOFENCE_USE_FENCE4 = 0x10240050;	// Use fourth geofence
-const uint32_t UBLOX_CFG_GEOFENCE_FENCE4_LAT = 0x40240051;	// Latitude of the fourth geofence circle center
-const uint32_t UBLOX_CFG_GEOFENCE_FENCE4_LON = 0x40240052;	// Longitude of the fourth geofence circle center
-const uint32_t UBLOX_CFG_GEOFENCE_FENCE4_RAD = 0x40240053;	// Radius of the fourth geofence circle
-
-//CFG-HW: Hardware configuration
-//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
-const uint32_t UBLOX_CFG_HW_ANT_CFG_VOLTCTRL = 0x10a3002e;	// Active antenna voltage control flag
-const uint32_t UBLOX_CFG_HW_ANT_CFG_SHORTDET = 0x10a3002f;	// Short antenna detection flag
-const uint32_t UBLOX_CFG_HW_ANT_CFG_SHORTDET_POL = 0x10a30030;	// Short antenna detection polarity
-const uint32_t UBLOX_CFG_HW_ANT_CFG_OPENDET = 0x10a30031;	// Open antenna detection flag
-const uint32_t UBLOX_CFG_HW_ANT_CFG_OPENDET_POL = 0x10a30032;	// Open antenna detection polarity
-const uint32_t UBLOX_CFG_HW_ANT_CFG_PWRDOWN = 0x10a30033;	// Power down antenna flag
-const uint32_t UBLOX_CFG_HW_ANT_CFG_PWRDOWN_POL = 0x10a30034;	// Power down antenna logic polarity
-const uint32_t UBLOX_CFG_HW_ANT_CFG_RECOVER = 0x10a30035;	// Automatic recovery from short state flag
-const uint32_t UBLOX_CFG_HW_ANT_SUP_SWITCH_PIN = 0x20a30036;	// ANT1 PIO number
-const uint32_t UBLOX_CFG_HW_ANT_SUP_SHORT_PIN = 0x20a30037;	// ANT0 PIO number
-const uint32_t UBLOX_CFG_HW_ANT_SUP_OPEN_PIN = 0x20a30038;	// ANT2 PIO number
-const uint32_t UBLOX_CFG_HW_ANT_SUP_ENGINE = 0x20a30054;	// Antenna supervisor engine selection
-const uint32_t UBLOX_CFG_HW_ANT_SUP_SHORT_THR = 0x20a30055;	// Antenna supervisor MADC engine short detection threshold
-const uint32_t UBLOX_CFG_HW_ANT_SUP_OPEN_THR = 0x20a30056;	// Antenna supervisor MADC engine open detection threshold
-
-//CFG-I2C: Configuration of the I2C interface
-//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
-const uint32_t UBLOX_CFG_I2C_ADDRESS = 0x20510001;	// I2C slave address of the receiver (7 bits)
-const uint32_t UBLOX_CFG_I2C_EXTENDEDTIMEOUT = 0x10510002;	// Flag to disable timeouting the interface after 1.5 s
-const uint32_t UBLOX_CFG_I2C_ENABLED = 0x10510003;	// Flag to indicate if the I2C interface should be enabled
-
-//CFG-I2CINPROT: Input protocol configuration of the I2C interface
-//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
-const uint32_t UBLOX_CFG_I2CINPROT_UBX = 0x10710001;	// Flag to indicate if UBX should be an input protocol on I2C
-const uint32_t UBLOX_CFG_I2CINPROT_NMEA = 0x10710002;	// Flag to indicate if NMEA should be an input protocol on I2C
-const uint32_t UBLOX_CFG_I2CINPROT_RTCM3X = 0x10710004;	// Flag to indicate if RTCM3X should be an input protocol on I2C
-
-//CFG-I2COUTPROT: Output protocol configuration of the I2C interface
-//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
-const uint32_t UBLOX_CFG_I2COUTPROT_UBX = 0x10720001;	// Flag to indicate if UBX should be an output protocol on I2C
-const uint32_t UBLOX_CFG_I2COUTPROT_NMEA = 0x10720002;	// Flag to indicate if NMEA should be an output protocol on I2C
-const uint32_t UBLOX_CFG_I2COUTPROT_RTCM3X = 0x10720004;	// Flag to indicate if RTCM3X should be an output protocol on I2C
-
-//CFG-INFMSG: Information message configuration
-//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
-const uint32_t UBLOX_CFG_INFMSG_UBX_I2C = 0x20920001;	// Information message enable flags for the UBX protocol on the I2C interface
-const uint32_t UBLOX_CFG_INFMSG_UBX_UART1 = 0x20920002;	// Information message enable flags for the UBX protocol on the UART1 interface
-const uint32_t UBLOX_CFG_INFMSG_UBX_UART2 = 0x20920003;	// Information message enable flags for the UBX protocol on the UART2 interface
-const uint32_t UBLOX_CFG_INFMSG_UBX_USB = 0x20920004;	// Information message enable flags for the UBX protocol on the USB interface
-const uint32_t UBLOX_CFG_INFMSG_UBX_SPI = 0x20920005;	// Information message enable flags for the UBX protocol on the SPI interface
-const uint32_t UBLOX_CFG_INFMSG_NMEA_I2C = 0x20920006;	// Information message enable flags for the NMEA protocol on the I2C interface
-const uint32_t UBLOX_CFG_INFMSG_NMEA_UART1 = 0x20920007;	// Information message enable flags for the NMEA protocol on the UART1 interface
-const uint32_t UBLOX_CFG_INFMSG_NMEA_UART2 = 0x20920008;	// Information message enable flags for the NMEA protocol on the UART2 interface
-const uint32_t UBLOX_CFG_INFMSG_NMEA_USB = 0x20920009;	// Information message enable flags for the NMEA protocol on the USB interface
-const uint32_t UBLOX_CFG_INFMSG_NMEA_SPI = 0x2092000a;	// Information message enable flags for the NMEA protocol on the SPI interface
-
-//CFG-ITFM: Jamming and interference monitor configuration
-//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
-const uint32_t UBLOX_CFG_ITFM_BBTHRESHOLD = 0x20410001;	// Broadband jamming detection threshold
-const uint32_t UBLOX_CFG_ITFM_CWTHRESHOLD = 0x20410002;	// CW jamming detection threshold
-const uint32_t UBLOX_CFG_ITFM_ENABLE = 0x1041000d;	// Enable interference detection
-const uint32_t UBLOX_CFG_ITFM_ANTSETTING = 0x20410010;	// Antenna setting
-const uint32_t UBLOX_CFG_ITFM_ENABLE_AUX = 0x10410013;	// Scan auxiliary bands
-
-//CFG-LOGFILTER: Data logger configuration
-//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
-const uint32_t UBLOX_CFG_LOGFILTER_RECORD_ENA = 0x10de0002;	// Recording enabled
-const uint32_t UBLOX_CFG_LOGFILTER_ONCE_PER_WAKE_UP_ENA = 0x10de0003;	// Once per wake up
-const uint32_t UBLOX_CFG_LOGFILTER_APPLY_ALL_FILTERS = 0x10de0004;	// Apply all filter settings
-const uint32_t UBLOX_CFG_LOGFILTER_MIN_INTERVAL = 0x30de0005;	// Minimum time interval between loggedpositions
-const uint32_t UBLOX_CFG_LOGFILTER_TIME_THRS = 0x30de0006;	// Time threshold
-const uint32_t UBLOX_CFG_LOGFILTER_SPEED_THRS = 0x30de0007;	// Speed threshold
-const uint32_t UBLOX_CFG_LOGFILTER_POSITION_THRS = 0x40de0008;	// Position threshold
-
-//CFG-MOT: Motion detector configuration
-//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
-const uint32_t UBLOX_CFG_MOT_GNSSSPEED_THRS = 0x20250038;	// GNSS speed threshold below which platform is considered as stationary (a.k.a. static hold threshold)
-const uint32_t UBLOX_CFG_MOT_GNSSDIST_THRS = 0x3025003b;	// Distance above which GNSS-based stationary motion is exit (a.k.a. static hold distance threshold)
-
-// CFG-MSGOUT: Message output configuration
-//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
-// For each message and port a separate output rate (per second, per epoch) can be configured.
-const uint32_t UBLOX_CFG_MSGOUT_NMEA_ID_DTM_I2C = 0x209100a6;				//Output rate of the NMEA-GX-DTM message on port I2C
-const uint32_t UBLOX_CFG_MSGOUT_NMEA_ID_DTM_SPI = 0x209100aa;				//Output rate of the NMEA-GX-DTM message on port SPI
-const uint32_t UBLOX_CFG_MSGOUT_NMEA_ID_DTM_UART1 = 0x209100a7;			//Output rate of the NMEA-GX-DTM message on port UART1
-const uint32_t UBLOX_CFG_MSGOUT_NMEA_ID_DTM_UART2 = 0x209100a8;			//Output rate of the NMEA-GX-DTM message on port UART2
-const uint32_t UBLOX_CFG_MSGOUT_NMEA_ID_DTM_USB = 0x209100a9;				//Output rate of the NMEA-GX-DTM message on port USB
-const uint32_t UBLOX_CFG_MSGOUT_NMEA_ID_GBS_I2C = 0x209100dd;				//Output rate of the NMEA-GX-GBS message on port I2C
-const uint32_t UBLOX_CFG_MSGOUT_NMEA_ID_GBS_SPI = 0x209100e1;				//Output rate of the NMEA-GX-GBS message on port SPI
-const uint32_t UBLOX_CFG_MSGOUT_NMEA_ID_GBS_UART1 = 0x209100de;			//Output rate of the NMEA-GX-GBS message on port UART1
-const uint32_t UBLOX_CFG_MSGOUT_NMEA_ID_GBS_UART2 = 0x209100df;			//Output rate of the NMEA-GX-GBS message on port UART2
-const uint32_t UBLOX_CFG_MSGOUT_NMEA_ID_GBS_USB = 0x209100e0;				//Output rate of the NMEA-GX-GBS message on port USB
-const uint32_t UBLOX_CFG_MSGOUT_NMEA_ID_GGA_I2C = 0x209100ba;				//Output rate of the NMEA-GX-GGA message on port I2C
-const uint32_t UBLOX_CFG_MSGOUT_NMEA_ID_GGA_SPI = 0x209100be;				//Output rate of the NMEA-GX-GGA message on port SPI
-const uint32_t UBLOX_CFG_MSGOUT_NMEA_ID_GGA_UART1 = 0x209100bb;			//Output rate of the NMEA-GX-GGA message on port UART1
-const uint32_t UBLOX_CFG_MSGOUT_NMEA_ID_GGA_UART2 = 0x209100bc;			//Output rate of the NMEA-GX-GGA message on port UART2
-const uint32_t UBLOX_CFG_MSGOUT_NMEA_ID_GGA_USB = 0x209100bd;				//Output rate of the NMEA-GX-GGA message on port USB
-const uint32_t UBLOX_CFG_MSGOUT_NMEA_ID_GLL_I2C = 0x209100c9;				//Output rate of the NMEA-GX-GLL message on port I2C
-const uint32_t UBLOX_CFG_MSGOUT_NMEA_ID_GLL_SPI = 0x209100cd;				//Output rate of the NMEA-GX-GLL message on port SPI
-const uint32_t UBLOX_CFG_MSGOUT_NMEA_ID_GLL_UART1 = 0x209100ca;			//Output rate of the NMEA-GX-GLL message on port UART1
-const uint32_t UBLOX_CFG_MSGOUT_NMEA_ID_GLL_UART2 = 0x209100cb;			//Output rate of the NMEA-GX-GLL message on port UART2
-const uint32_t UBLOX_CFG_MSGOUT_NMEA_ID_GLL_USB = 0x209100cc;				//Output rate of the NMEA-GX-GLL message on port USB
-const uint32_t UBLOX_CFG_MSGOUT_NMEA_ID_GNS_I2C = 0x209100b5;				//Output rate of the NMEA-GX-GNS message on port I2C
-const uint32_t UBLOX_CFG_MSGOUT_NMEA_ID_GNS_SPI = 0x209100b9;				//Output rate of the NMEA-GX-GNS message on port SPI
-const uint32_t UBLOX_CFG_MSGOUT_NMEA_ID_GNS_UART1 = 0x209100b6;			//Output rate of the NMEA-GX-GNS message on port UART1
-const uint32_t UBLOX_CFG_MSGOUT_NMEA_ID_GNS_UART2 = 0x209100b7;			//Output rate of the NMEA-GX-GNS message on port UART2
-const uint32_t UBLOX_CFG_MSGOUT_NMEA_ID_GNS_USB = 0x209100b8;				//Output rate of the NMEA-GX-GNS message on port USB
-const uint32_t UBLOX_CFG_MSGOUT_NMEA_ID_GRS_I2C = 0x209100ce;				//Output rate of the NMEA-GX-GRS message on port I2C
-const uint32_t UBLOX_CFG_MSGOUT_NMEA_ID_GRS_SPI = 0x209100d2;				//Output rate of the NMEA-GX-GRS message on port SPI
-const uint32_t UBLOX_CFG_MSGOUT_NMEA_ID_GRS_UART1 = 0x209100cf;			//Output rate of the NMEA-GX-GRS message on port UART1
-const uint32_t UBLOX_CFG_MSGOUT_NMEA_ID_GRS_UART2 = 0x209100d0;			//Output rate of the NMEA-GX-GRS message on port UART2
-const uint32_t UBLOX_CFG_MSGOUT_NMEA_ID_GRS_USB = 0x209100d1;				//Output rate of the NMEA-GX-GRS message on port USB
-const uint32_t UBLOX_CFG_MSGOUT_NMEA_ID_GSA_I2C = 0x209100bf;				//Output rate of the NMEA-GX-GSA message on port I2C
-const uint32_t UBLOX_CFG_MSGOUT_NMEA_ID_GSA_SPI = 0x209100c3;				//Output rate of the NMEA-GX-GSA message on port SPI
-const uint32_t UBLOX_CFG_MSGOUT_NMEA_ID_GSA_UART1 = 0x209100c0;			//Output rate of the NMEA-GX-GSA message on port UART1
-const uint32_t UBLOX_CFG_MSGOUT_NMEA_ID_GSA_UART2 = 0x209100c1;			//Output rate of the NMEA-GX-GSA message on port UART2
-const uint32_t UBLOX_CFG_MSGOUT_NMEA_ID_GSA_USB = 0x209100c2;				//Output rate of the NMEA-GX-GSA message on port USB
-const uint32_t UBLOX_CFG_MSGOUT_NMEA_ID_GST_I2C = 0x209100d3;				//Output rate of the NMEA-GX-GST message on port I2C
-const uint32_t UBLOX_CFG_MSGOUT_NMEA_ID_GST_SPI = 0x209100d7;				//Output rate of the NMEA-GX-GST message on port SPI
-const uint32_t UBLOX_CFG_MSGOUT_NMEA_ID_GST_UART1 = 0x209100d4;			//Output rate of the NMEA-GX-GST message on port UART1
-const uint32_t UBLOX_CFG_MSGOUT_NMEA_ID_GST_UART2 = 0x209100d5;			//Output rate of the NMEA-GX-GST message on port UART2
-const uint32_t UBLOX_CFG_MSGOUT_NMEA_ID_GST_USB = 0x209100d6;				//Output rate of the NMEA-GX-GST message on port USB
-const uint32_t UBLOX_CFG_MSGOUT_NMEA_ID_GSV_I2C = 0x209100c4;				//Output rate of the NMEA-GX-GSV message on port I2C
-const uint32_t UBLOX_CFG_MSGOUT_NMEA_ID_GSV_SPI = 0x209100c8;				//Output rate of the NMEA-GX-GSV message on port SPI
-const uint32_t UBLOX_CFG_MSGOUT_NMEA_ID_GSV_UART1 = 0x209100c5;			//Output rate of the NMEA-GX-GSV message on port UART1
-const uint32_t UBLOX_CFG_MSGOUT_NMEA_ID_GSV_UART2 = 0x209100c6;			//Output rate of the NMEA-GX-GSV message on port UART2
-const uint32_t UBLOX_CFG_MSGOUT_NMEA_ID_GSV_USB = 0x209100c7;				//Output rate of the NMEA-GX-GSV message on port USB
-const uint32_t UBLOX_CFG_MSGOUT_NMEA_ID_RLM_I2C = 0x20910400;				//Output rate of the NMEA-GX-RLM message on port I2C
-const uint32_t UBLOX_CFG_MSGOUT_NMEA_ID_RLM_SPI = 0x20910404;				//Output rate of the NMEA-GX-RLM message on port SPI
-const uint32_t UBLOX_CFG_MSGOUT_NMEA_ID_RLM_UART1 = 0x20910401;			//Output rate of the NMEA-GX-RLM message on port UART1
-const uint32_t UBLOX_CFG_MSGOUT_NMEA_ID_RLM_UART2 = 0x20910402;			//Output rate of the NMEA-GX-RLM message on port UART2
-const uint32_t UBLOX_CFG_MSGOUT_NMEA_ID_RLM_USB = 0x20910403;				//Output rate of the NMEA-GX-RLM message on port USB
-const uint32_t UBLOX_CFG_MSGOUT_NMEA_ID_RMC_I2C = 0x209100ab;				//Output rate of the NMEA-GX-RMC message on port I2C
-const uint32_t UBLOX_CFG_MSGOUT_NMEA_ID_RMC_SPI = 0x209100af;				//Output rate of the NMEA-GX-RMC message on port SPI
-const uint32_t UBLOX_CFG_MSGOUT_NMEA_ID_RMC_UART1 = 0x209100ac;			//Output rate of the NMEA-GX-RMC message on port UART1
-const uint32_t UBLOX_CFG_MSGOUT_NMEA_ID_RMC_UART2 = 0x209100ad;			//Output rate of the NMEA-GX-RMC message on port UART2
-const uint32_t UBLOX_CFG_MSGOUT_NMEA_ID_RMC_USB = 0x209100ae;				//Output rate of the NMEA-GX-RMC message on port USB
-const uint32_t UBLOX_CFG_MSGOUT_NMEA_ID_VLW_I2C = 0x209100e7;				//Output rate of the NMEA-GX-VLW message on port I2C
-const uint32_t UBLOX_CFG_MSGOUT_NMEA_ID_VLW_SPI = 0x209100eb;				//Output rate of the NMEA-GX-VLW message on port SPI
-const uint32_t UBLOX_CFG_MSGOUT_NMEA_ID_VLW_UART1 = 0x209100e8;			//Output rate of the NMEA-GX-VLW message on port UART1
-const uint32_t UBLOX_CFG_MSGOUT_NMEA_ID_VLW_UART2 = 0x209100e9;			//Output rate of the NMEA-GX-VLW message on port UART2
-const uint32_t UBLOX_CFG_MSGOUT_NMEA_ID_VLW_USB = 0x209100ea;				//Output rate of the NMEA-GX-VLW message on port USB
-const uint32_t UBLOX_CFG_MSGOUT_NMEA_ID_VTG_I2C = 0x209100b0;				//Output rate of the NMEA-GX-VTG message on port I2C
-const uint32_t UBLOX_CFG_MSGOUT_NMEA_ID_VTG_SPI = 0x209100b4;				//Output rate of the NMEA-GX-VTG message on port SPI
-const uint32_t UBLOX_CFG_MSGOUT_NMEA_ID_VTG_UART1 = 0x209100b1;			//Output rate of the NMEA-GX-VTG message on port UART1
-const uint32_t UBLOX_CFG_MSGOUT_NMEA_ID_VTG_UART2 = 0x209100b2;			//Output rate of the NMEA-GX-VTG message on port UART2
-const uint32_t UBLOX_CFG_MSGOUT_NMEA_ID_VTG_USB = 0x209100b3;				//Output rate of the NMEA-GX-VTG message on port USB
-const uint32_t UBLOX_CFG_MSGOUT_NMEA_ID_ZDA_I2C = 0x209100d8;				//Output rate of the NMEA-GX-ZDA message on port I2C
-const uint32_t UBLOX_CFG_MSGOUT_NMEA_ID_ZDA_SPI = 0x209100dc;				//Output rate of the NMEA-GX-ZDA message on port SPI
-const uint32_t UBLOX_CFG_MSGOUT_NMEA_ID_ZDA_UART1 = 0x209100d9;			//Output rate of the NMEA-GX-ZDA message on port UART1
-const uint32_t UBLOX_CFG_MSGOUT_NMEA_ID_ZDA_UART2 = 0x209100da;			//Output rate of the NMEA-GX-ZDA message on port UART2
-const uint32_t UBLOX_CFG_MSGOUT_NMEA_ID_ZDA_USB = 0x209100db;				//Output rate of the NMEA-GX-ZDA message on port USB
-const uint32_t UBLOX_CFG_MSGOUT_PUBX_ID_POLYP_I2C = 0x209100ec;			//Output rate of the NMEA-GX-PUBX00 message on port I2C
-const uint32_t UBLOX_CFG_MSGOUT_PUBX_ID_POLYP_SPI = 0x209100f0;			//Output rate of the NMEA-GX-PUBX00 message on port SPI
-const uint32_t UBLOX_CFG_MSGOUT_PUBX_ID_POLYP_UART1 = 0x209100ed;		//Output rate of the NMEA-GX-PUBX00 message on port UART1
-const uint32_t UBLOX_CFG_MSGOUT_PUBX_ID_POLYP_UART2 = 0x209100ee;	//Output rate of the NMEA-GX-PUBX00 message on port UART2
-const uint32_t UBLOX_CFG_MSGOUT_PUBX_ID_POLYP_USB = 0x209100ef;		//Output rate of the NMEA-GX-PUBX00 message on port USB
-const uint32_t UBLOX_CFG_MSGOUT_PUBX_ID_POLYS_I2C = 0x209100f1;			//Output rate of the NMEA-GX-PUBX03 message on port I2C
-const uint32_t UBLOX_CFG_MSGOUT_PUBX_ID_POLYS_SPI = 0x209100f5;			//Output rate of the NMEA-GX-PUBX03 message on port SPI
-const uint32_t UBLOX_CFG_MSGOUT_PUBX_ID_POLYS_UART1 = 0x209100f2;		//Output rate of the NMEA-GX-PUBX03 message on port UART1
-const uint32_t UBLOX_CFG_MSGOUT_PUBX_ID_POLYS_UART2 = 0x209100f3;	//Output rate of the NMEA-GX-PUBX03 message on port UART2
-const uint32_t UBLOX_CFG_MSGOUT_PUBX_ID_POLYS_USB = 0x209100f4;		//Output rate of the NMEA-GX-PUBX03 message on port USB
-const uint32_t UBLOX_CFG_MSGOUT_PUBX_ID_POLYT_I2C = 0x209100f6;			//Output rate of the NMEA-GX-PUBX04 message on port I2C
-const uint32_t UBLOX_CFG_MSGOUT_PUBX_ID_POLYT_SPI = 0x209100fa;			//Output rate of the NMEA-GX-PUBX04 message on port SPI
-const uint32_t UBLOX_CFG_MSGOUT_PUBX_ID_POLYT_UART1 = 0x209100f7;		//Output rate of the NMEA-GX-PUBX04 message on port UART1
-const uint32_t UBLOX_CFG_MSGOUT_PUBX_ID_POLYT_UART2 = 0x209100f8;	//Output rate of the NMEA-GX-PUBX04 message on port UART2
-const uint32_t UBLOX_CFG_MSGOUT_PUBX_ID_POLYT_USB = 0x209100f9;		//Output rate of the NMEA-GX-PUBX04 message on port USB
-const uint32_t UBLOX_CFG_MSGOUT_RTCM_3X_TYPE1005_I2C = 0x209102bd;		//Output rate of the RTCM-3X-TYPE1005 message on port I2C
-const uint32_t UBLOX_CFG_MSGOUT_RTCM_3X_TYPE1005_SPI = 0x209102c1;	//Output rate of the RTCM-3X-TYPE1005 message on port SPI
-const uint32_t UBLOX_CFG_MSGOUT_RTCM_3X_TYPE1005_UART1 = 0x209102be;//Output rate of the RTCM-3X-TYPE1005 message on port UART1
-const uint32_t UBLOX_CFG_MSGOUT_RTCM_3X_TYPE1005_UART2 = 0x209102bf;//Output rate of the RTCM-3X-TYPE1005 message on port UART2
-const uint32_t UBLOX_CFG_MSGOUT_RTCM_3X_TYPE1005_USB = 0x209102c0;	//Output rate of the RTCM-3X-TYPE1005 message on port USB
-const uint32_t UBLOX_CFG_MSGOUT_RTCM_3X_TYPE1074_I2C = 0x2091035e;	//Output rate of the RTCM-3X-TYPE1074 message on port I2C
-const uint32_t UBLOX_CFG_MSGOUT_RTCM_3X_TYPE1074_SPI = 0x20910362;	//Output rate of the RTCM-3X-TYPE1074 message on port SPI
-const uint32_t UBLOX_CFG_MSGOUT_RTCM_3X_TYPE1074_UART1 = 0x2091035f;//Output rate of the RTCM-3X-TYPE1074 message on port UART1
-const uint32_t UBLOX_CFG_MSGOUT_RTCM_3X_TYPE1074_UART2 = 0x20910360;//Output rate of the RTCM-3X-TYPE1074 message on port UART2
-const uint32_t UBLOX_CFG_MSGOUT_RTCM_3X_TYPE1074_USB = 0x20910361;	//Output rate of the RTCM-3X-TYPE1074 message on port USB
-const uint32_t UBLOX_CFG_MSGOUT_RTCM_3X_TYPE1077_I2C = 0x209102cc;	//Output rate of the RTCM-3X-TYPE1077 message on port I2C
-const uint32_t UBLOX_CFG_MSGOUT_RTCM_3X_TYPE1077_SPI = 0x209102d0;	//Output rate of the RTCM-3X-TYPE1077 message on port SPI
-const uint32_t UBLOX_CFG_MSGOUT_RTCM_3X_TYPE1077_UART1 = 0x209102cd;//Output rate of the RTCM-3X-TYPE1077 message on port UART1
-const uint32_t UBLOX_CFG_MSGOUT_RTCM_3X_TYPE1077_UART2 = 0x209102ce;//Output rate of the RTCM-3X-TYPE1077 message on port UART2
-const uint32_t UBLOX_CFG_MSGOUT_RTCM_3X_TYPE1077_USB = 0x209102cf;	//Output rate of the RTCM-3X-TYPE1077 message on port USB
-const uint32_t UBLOX_CFG_MSGOUT_RTCM_3X_TYPE1084_I2C = 0x20910363;	//Output rate of the RTCM-3X-TYPE1084 message on port I2C
-const uint32_t UBLOX_CFG_MSGOUT_RTCM_3X_TYPE1084_SPI = 0x20910367;	//Output rate of the RTCM-3X-TYPE1084 message on port SPI
-const uint32_t UBLOX_CFG_MSGOUT_RTCM_3X_TYPE1084_UART1 = 0x20910364;//Output rate of the RTCM-3X-TYPE1084 message on port UART1
-const uint32_t UBLOX_CFG_MSGOUT_RTCM_3X_TYPE1084_UART2 = 0x20910365;//Output rate of the RTCM-3X-TYPE1084 message on port UART2
-const uint32_t UBLOX_CFG_MSGOUT_RTCM_3X_TYPE1084_USB = 0x20910366;	//Output rate of the RTCM-3X-TYPE1084 message on port USB
-const uint32_t UBLOX_CFG_MSGOUT_RTCM_3X_TYPE1087_I2C = 0x209102d1;	//Output rate of the RTCM-3X-TYPE1087 message on port I2C
-const uint32_t UBLOX_CFG_MSGOUT_RTCM_3X_TYPE1087_SPI = 0x209102d5;	//Output rate of the RTCM-3X-TYPE1087 message on port SPI
-const uint32_t UBLOX_CFG_MSGOUT_RTCM_3X_TYPE1087_UART1 = 0x209102d2;//Output rate of the RTCM-3X-TYPE1087 message on port UART1
-const uint32_t UBLOX_CFG_MSGOUT_RTCM_3X_TYPE1087_UART2 = 0x209102d3;//Output rate of the RTCM-3X-TYPE1087 message on port UART2
-const uint32_t UBLOX_CFG_MSGOUT_RTCM_3X_TYPE1087_USB = 0x209102d4;	//Output rate of the RTCM-3X-TYPE1087 message on port USB
-const uint32_t UBLOX_CFG_MSGOUT_RTCM_3X_TYPE1094_I2C = 0x20910368;	//Output rate of the RTCM-3X-TYPE1094 message on port I2C
-const uint32_t UBLOX_CFG_MSGOUT_RTCM_3X_TYPE1094_SPI = 0x2091036c;	//Output rate of the RTCM-3X-TYPE1094 message on port SPI
-const uint32_t UBLOX_CFG_MSGOUT_RTCM_3X_TYPE1094_UART1 = 0x20910369;//Output rate of the RTCM-3X-TYPE1094 message on port UART1
-const uint32_t UBLOX_CFG_MSGOUT_RTCM_3X_TYPE1094_UART2 = 0x2091036a;//Output rate of the RTCM-3X-TYPE1094 message on port UART2
-const uint32_t UBLOX_CFG_MSGOUT_RTCM_3X_TYPE1094_USB = 0x2091036b;	//Output rate of the RTCM-3X-TYPE1094 message on port USB
-const uint32_t UBLOX_CFG_MSGOUT_RTCM_3X_TYPE1097_I2C = 0x20910318;	//Output rate of the RTCM-3X-TYPE1097 message on port I2C
-const uint32_t UBLOX_CFG_MSGOUT_RTCM_3X_TYPE1097_SPI = 0x2091031c;	//Output rate of the RTCM-3X-TYPE1097 message on port SPI
-const uint32_t UBLOX_CFG_MSGOUT_RTCM_3X_TYPE1097_UART1 = 0x20910319;//Output rate of the RTCM-3X-TYPE1097 message on port UART1
-const uint32_t UBLOX_CFG_MSGOUT_RTCM_3X_TYPE1097_UART2 = 0x2091031a;//Output rate of the RTCM-3X-TYPE1097 message on port UART2
-const uint32_t UBLOX_CFG_MSGOUT_RTCM_3X_TYPE1097_USB = 0x2091031b;	//Output rate of the RTCM-3X-TYPE1097 message on port USB
-const uint32_t UBLOX_CFG_MSGOUT_RTCM_3X_TYPE1124_I2C = 0x2091036d;	//Output rate of the RTCM-3X-TYPE1124 message on port I2C
-const uint32_t UBLOX_CFG_MSGOUT_RTCM_3X_TYPE1124_SPI = 0x20910371;	//Output rate of the RTCM-3X-TYPE1124 message on port SPI
-const uint32_t UBLOX_CFG_MSGOUT_RTCM_3X_TYPE1124_UART1 = 0x2091036e;//Output rate of the RTCM-3X-TYPE1124 message on port UART1
-const uint32_t UBLOX_CFG_MSGOUT_RTCM_3X_TYPE1124_UART2 = 0x2091036f;//Output rate of the RTCM-3X-TYPE1124 message on port UART2
-const uint32_t UBLOX_CFG_MSGOUT_RTCM_3X_TYPE1124_USB = 0x20910370;	//Output rate of the RTCM-3X-TYPE1124 message on port USB
-const uint32_t UBLOX_CFG_MSGOUT_RTCM_3X_TYPE1127_I2C = 0x209102d6;	//Output rate of the RTCM-3X-TYPE1127 message on port I2C
-const uint32_t UBLOX_CFG_MSGOUT_RTCM_3X_TYPE1127_SPI = 0x209102da;	//Output rate of the RTCM-3X-TYPE1127 message on port SPI
-const uint32_t UBLOX_CFG_MSGOUT_RTCM_3X_TYPE1127_UART1 = 0x209102d7;//Output rate of the RTCM-3X-TYPE1127 message on port UART1
-const uint32_t UBLOX_CFG_MSGOUT_RTCM_3X_TYPE1127_UART2 = 0x209102d8;//Output rate of the RTCM-3X-TYPE1127 message on port UART2
-const uint32_t UBLOX_CFG_MSGOUT_RTCM_3X_TYPE1127_USB = 0x209102d9;	//Output rate of the RTCM-3X-TYPE1127 message on port USB
-const uint32_t UBLOX_CFG_MSGOUT_RTCM_3X_TYPE1230_I2C = 0x20910303;	//Output rate of the RTCM-3X-TYPE1230 message on port I2C
-const uint32_t UBLOX_CFG_MSGOUT_RTCM_3X_TYPE1230_SPI = 0x20910307;	//Output rate of the RTCM-3X-TYPE1230 message on port SPI
-const uint32_t UBLOX_CFG_MSGOUT_RTCM_3X_TYPE1230_UART1 = 0x20910304;//Output rate of the RTCM-3X-TYPE1230 message on port UART1
-const uint32_t UBLOX_CFG_MSGOUT_RTCM_3X_TYPE1230_UART2 = 0x20910305;//Output rate of the RTCM-3X-TYPE1230 message on port UART2
-const uint32_t UBLOX_CFG_MSGOUT_RTCM_3X_TYPE1230_USB = 0x20910306;	//Output rate of the RTCM-3X-TYPE1230 message on port USB
-const uint32_t UBLOX_CFG_MSGOUT_RTCM_3X_TYPE4072_0_I2C = 0x209102fe;//Output rate of the RTCM-3X-TYPE4072_0 message on port I2C
-const uint32_t UBLOX_CFG_MSGOUT_RTCM_3X_TYPE4072_0_SPI = 0x20910302;//Output rate of the RTCM-3X-TYPE4072_0 message on port SPI
-const uint32_t UBLOX_CFG_MSGOUT_RTCM_3X_TYPE4072_0_UART1 = 0x209102ff; //Output rate of the RTCM-3X-TYPE4072_0 message on port UART1
-const uint32_t UBLOX_CFG_MSGOUT_RTCM_3X_TYPE4072_0_UART2 = 0x20910300; //Output rate of the RTCM-3X-TYPE4072_0 message on port UART2
-const uint32_t UBLOX_CFG_MSGOUT_RTCM_3X_TYPE4072_0_USB = 0x20910301;//Output rate of the RTCM-3X-TYPE4072_0 message on port USB
-const uint32_t UBLOX_CFG_MSGOUT_RTCM_3X_TYPE4072_1_I2C = 0x20910381;//Output rate of the RTCM-3X-TYPE4072_1 message on port I2C
-const uint32_t UBLOX_CFG_MSGOUT_RTCM_3X_TYPE4072_1_SPI = 0x20910385;//Output rate of the RTCM-3X-TYPE4072_1 message on port SPI
-const uint32_t UBLOX_CFG_MSGOUT_RTCM_3X_TYPE4072_1_UART1 = 0x20910382; //Output rate of the RTCM-3X-TYPE4072_1 message on port UART1
-const uint32_t UBLOX_CFG_MSGOUT_RTCM_3X_TYPE4072_1_UART2 = 0x20910383; //Output rate of the RTCM-3X-TYPE4072_1 message on port UART2
-const uint32_t UBLOX_CFG_MSGOUT_RTCM_3X_TYPE4072_1_USB = 0x20910384;//Output rate of the RTCM-3X-TYPE4072_1 message on port USB
-const uint32_t UBLOX_CFG_MSGOUT_UBX_LOG_INFO_I2C = 0x20910259;		//Output rate of the UBX-LOG-INFO message on port I2C
-const uint32_t UBLOX_CFG_MSGOUT_UBX_LOG_INFO_SPI = 0x2091025d;			//Output rate of the UBX-LOG-INFO message on port SPI
-const uint32_t UBLOX_CFG_MSGOUT_UBX_LOG_INFO_UART1 = 0x2091025a;		//Output rate of the UBX-LOG-INFO message on port UART1
-const uint32_t UBLOX_CFG_MSGOUT_UBX_LOG_INFO_UART2 = 0x2091025b;	//Output rate of the UBX-LOG-INFO message on port UART2
-const uint32_t UBLOX_CFG_MSGOUT_UBX_LOG_INFO_USB = 0x2091025c;		//Output rate of the UBX-LOG-INFO message on port USB
-const uint32_t UBLOX_CFG_MSGOUT_UBX_MON_COMMS_I2C = 0x2091034f;			//Output rate of the UBX-MON-COMMS message on port I2C
-const uint32_t UBLOX_CFG_MSGOUT_UBX_MON_COMMS_SPI = 0x20910353;			//Output rate of the UBX-MON-COMMS message on port SPI
-const uint32_t UBLOX_CFG_MSGOUT_UBX_MON_COMMS_UART1 = 0x20910350;		//Output rate of the UBX-MON-COMMS message on port UART1
-const uint32_t UBLOX_CFG_MSGOUT_UBX_MON_COMMS_UART2 = 0x20910351;	//Output rate of the UBX-MON-COMMS message on port UART2
-const uint32_t UBLOX_CFG_MSGOUT_UBX_MON_COMMS_USB = 0x20910352;		//Output rate of the UBX-MON-COMMS message on port USB
-const uint32_t UBLOX_CFG_MSGOUT_UBX_MON_HW2_I2C = 0x209101b9;				//Output rate of the UBX-MON-HW2 message on port I2C
-const uint32_t UBLOX_CFG_MSGOUT_UBX_MON_HW2_SPI = 0x209101bd;				//Output rate of the UBX-MON-HW2 message on port SPI
-const uint32_t UBLOX_CFG_MSGOUT_UBX_MON_HW2_UART1 = 0x209101ba;			//Output rate of the UBX-MON-HW2 message on port UART1
-const uint32_t UBLOX_CFG_MSGOUT_UBX_MON_HW2_UART2 = 0x209101bb;			//Output rate of the UBX-MON-HW2 message on port UART2
-const uint32_t UBLOX_CFG_MSGOUT_UBX_MON_HW2_USB = 0x209101bc;				//Output rate of the UBX-MON-HW2 message on port USB
-const uint32_t UBLOX_CFG_MSGOUT_UBX_MON_HW3_I2C = 0x20910354;				//Output rate of the UBX-MON-HW3 message on port I2C
-const uint32_t UBLOX_CFG_MSGOUT_UBX_MON_HW3_SPI = 0x20910358;				//Output rate of the UBX-MON-HW3 message on port SPI
-const uint32_t UBLOX_CFG_MSGOUT_UBX_MON_HW3_UART1 = 0x20910355;			//Output rate of the UBX-MON-HW3 message on port UART1
-const uint32_t UBLOX_CFG_MSGOUT_UBX_MON_HW3_UART2 = 0x20910356;			//Output rate of the UBX-MON-HW3 message on port UART2
-const uint32_t UBLOX_CFG_MSGOUT_UBX_MON_HW3_USB = 0x20910357;				//Output rate of the UBX-MON-HW3 message on port USB
-const uint32_t UBLOX_CFG_MSGOUT_UBX_MON_HW_I2C = 0x209101b4;				//Output rate of the UBX-MON-HW message on port I2C
-const uint32_t UBLOX_CFG_MSGOUT_UBX_MON_HW_SPI = 0x209101b8;				//Output rate of the UBX-MON-HW message on port SPI
-const uint32_t UBLOX_CFG_MSGOUT_UBX_MON_HW_UART1 = 0x209101b5;			//Output rate of the UBX-MON-HW message on port UART1
-const uint32_t UBLOX_CFG_MSGOUT_UBX_MON_HW_UART2 = 0x209101b6;			//Output rate of the UBX-MON-HW message on port UART2
-const uint32_t UBLOX_CFG_MSGOUT_UBX_MON_HW_USB = 0x209101b7;				//Output rate of the UBX-MON-HW message on port USB
-const uint32_t UBLOX_CFG_MSGOUT_UBX_MON_IO_I2C = 0x209101a5;				//Output rate of the UBX-MON-IO message on port I2C
-const uint32_t UBLOX_CFG_MSGOUT_UBX_MON_IO_SPI = 0x209101a9;				//Output rate of the UBX-MON-IO message on port SPI
-const uint32_t UBLOX_CFG_MSGOUT_UBX_MON_IO_UART1 = 0x209101a6;			//Output rate of the UBX-MON-IO message on port UART1
-const uint32_t UBLOX_CFG_MSGOUT_UBX_MON_IO_UART2 = 0x209101a7;			//Output rate of the UBX-MON-IO message on port UART2
-const uint32_t UBLOX_CFG_MSGOUT_UBX_MON_IO_USB = 0x209101a8;				//Output rate of the UBX-MON-IO message on port USB
-const uint32_t UBLOX_CFG_MSGOUT_UBX_MON_MSGPP_I2C = 0x20910196;			//Output rate of the UBX-MON-MSGPP message on port I2C
-const uint32_t UBLOX_CFG_MSGOUT_UBX_MON_MSGPP_SPI = 0x2091019a;			//Output rate of the UBX-MON-MSGPP message on port SPI
-const uint32_t UBLOX_CFG_MSGOUT_UBX_MON_MSGPP_UART1 = 0x20910197;		//Output rate of the UBX-MON-MSGPP message on port UART1
-const uint32_t UBLOX_CFG_MSGOUT_UBX_MON_MSGPP_UART2 = 0x20910198;	//Output rate of the UBX-MON-MSGPP message on port UART2
-const uint32_t UBLOX_CFG_MSGOUT_UBX_MON_MSGPP_USB = 0x20910199;		//Output rate of the UBX-MON-MSGPP message on port USB
-const uint32_t UBLOX_CFG_MSGOUT_UBX_MON_RF_I2C = 0x20910359;				//Output rate of the UBX-MON-RF message on port I2C
-const uint32_t UBLOX_CFG_MSGOUT_UBX_MON_RF_SPI = 0x2091035d;				//Output rate of the UBX-MON-RF message on port SPI
-const uint32_t UBLOX_CFG_MSGOUT_UBX_MON_RF_UART1 = 0x2091035a;			//Output rate of the UBX-MON-RF message on port UART1
-const uint32_t UBLOX_CFG_MSGOUT_UBX_MON_RF_UART2 = 0x2091035b;			//Output rate of the UBX-MON-RF message on port UART2
-const uint32_t UBLOX_CFG_MSGOUT_UBX_MON_RF_USB = 0x2091035c;				// Output rate of the UBX-MON-RF message on port USB
-const uint32_t UBLOX_CFG_MSGOUT_UBX_MON_RXBUF_I2C = 0x209101a0;			// Output rate of the UBX-MON-RXBUF message on port I2C
-const uint32_t UBLOX_CFG_MSGOUT_UBX_MON_RXBUF_SPI = 0x209101a4;			// Output rate of the UBX-MON-RXBUF message on port SPI
-const uint32_t UBLOX_CFG_MSGOUT_UBX_MON_RXBUF_UART1 = 0x209101a1;		// Output rate of the UBX-MON-RXBUF message on port UART1
-const uint32_t UBLOX_CFG_MSGOUT_UBX_MON_RXBUF_UART2 = 0x209101a2;	// Output rate of the UBX-MON-RXBUF message on port UART2
-const uint32_t UBLOX_CFG_MSGOUT_UBX_MON_RXBUF_USB = 0x209101a3;		// Output rate of the UBX-MON-RXBUF message on port USB
-const uint32_t UBLOX_CFG_MSGOUT_UBX_MON_RXR_I2C = 0x20910187;				// Output rate of the UBX-MON-RXR message on port I2C
-const uint32_t UBLOX_CFG_MSGOUT_UBX_MON_RXR_SPI = 0x2091018b;				// Output rate of the UBX-MON-RXR message on port SPI
-const uint32_t UBLOX_CFG_MSGOUT_UBX_MON_RXR_UART1 = 0x20910188;			// Output rate of the UBX-MON-RXR message on port UART1
-const uint32_t UBLOX_CFG_MSGOUT_UBX_MON_RXR_UART2 = 0x20910189;			// Output rate of the UBX-MON-RXR message on port UART2
-const uint32_t UBLOX_CFG_MSGOUT_UBX_MON_RXR_USB = 0x2091018a;				// Output rate of the UBX-MON-RXR message on port USB
-const uint32_t UBLOX_CFG_MSGOUT_UBX_MON_SPAN_I2C = 0x2091038b;			// Output rate of the UBX-MON-SPAN message on port I2C
-const uint32_t UBLOX_CFG_MSGOUT_UBX_MON_SPAN_SPI = 0x2091038f;			// Output rate of the UBX-MON-SPAN message on port SPI
-const uint32_t UBLOX_CFG_MSGOUT_UBX_MON_SPAN_UART1 = 0x2091038c;		// Output rate of the UBX-MON-SPAN message on port UART1
-const uint32_t UBLOX_CFG_MSGOUT_UBX_MON_SPAN_UART2 = 0x2091038d;	// Output rate of the UBX-MON-SPAN message on port UART2
-const uint32_t UBLOX_CFG_MSGOUT_UBX_MON_SPAN_USB = 0x2091038e;		// Output rate of the UBX-MON-SPAN message on port USB
-const uint32_t UBLOX_CFG_MSGOUT_UBX_MON_TXBUF_I2C = 0x2091019b;			// Output rate of the UBX-MON-TXBUF message on port I2C
-const uint32_t UBLOX_CFG_MSGOUT_UBX_MON_TXBUF_SPI = 0x2091019f;			// Output rate of the UBX-MON-TXBUF message on port SPI
-const uint32_t UBLOX_CFG_MSGOUT_UBX_MON_TXBUF_UART1 = 0x2091019c;		// Output rate of the UBX-MON-TXBUF message on port UART1
-const uint32_t UBLOX_CFG_MSGOUT_UBX_MON_TXBUF_UART2 = 0x2091019d;	// Output rate of the UBX-MON-TXBUF message on port UART2
-const uint32_t UBLOX_CFG_MSGOUT_UBX_MON_TXBUF_USB = 0x2091019e;		// Output rate of the UBX-MON-TXBUF message on port USB
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_ATT_I2C = 0x2091001f;		// Output rate of the UBX_NAV_ATT message on port I2C
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_ATT_SPI = 0x20910023;		// Output rate of the UBX_NAV_ATT message on port SPI
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_ATT_UART1 = 0x20910020;		// Output rate of the UBX_NAV_ATT message on port UART1
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_ATT_UART2 = 0x20910021;		// Output rate of the UBX_NAV_ATT message on port UART2
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_ATT_USB = 0x20910022;		// Output rate of the UBX_NAV_ATT message on port USB
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_CLOCK_I2C = 0x20910065;			// Output rate of the UBX-NAV-CLOCK message on port I2C
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_CLOCK_SPI = 0x20910069;			// Output rate of the UBX-NAV-CLOCK message on port SPI
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_CLOCK_UART1 = 0x20910066;		// Output rate of the UBX-NAV-CLOCK message on port UART1
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_CLOCK_UART2 = 0x20910067;	// Output rate of the UBX-NAV-CLOCK message on port UART2
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_CLOCK_USB = 0x20910068;		// Output rate of the UBX-NAV-CLOCK message on port USB
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_DOP_I2C = 0x20910038;				// Output rate of the UBX-NAV-DOP message on port I2C
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_DOP_SPI = 0x2091003c;				// Output rate of the UBX-NAV-DOP message on port SPI
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_DOP_UART1 = 0x20910039;			// Output rate of the UBX-NAV-DOP message on port UART1
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_DOP_UART2 = 0x2091003a;			// Output rate of the UBX-NAV-DOP message on port UART2
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_DOP_USB = 0x2091003b;				// Output rate of the UBX-NAV-DOP message on port USB
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_EOE_I2C = 0x2091015f;				// Output rate of the UBX-NAV-EOE message on port I2C
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_EOE_SPI = 0x20910163;				// Output rate of the UBX-NAV-EOE message on port SPI
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_EOE_UART1 = 0x20910160;			// Output rate of the UBX-NAV-EOE message on port UART1
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_EOE_UART2 = 0x20910161;			// Output rate of the UBX-NAV-EOE message on port UART2
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_EOE_USB = 0x20910162;				// Output rate of the UBX-NAV-EOE message on port USB
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_GEOFENCE_I2C = 0x209100a1;		// Output rate of the UBX-NAV-GEOFENCE message on port I2C
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_GEOFENCE_SPI = 0x209100a5;	// Output rate of the UBX-NAV-GEOFENCE message on port SPI
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_GEOFENCE_UART1 = 0x209100a2;// Output rate of the UBX-NAV-GEOFENCE message on port UART1
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_GEOFENCE_UART2 = 0x209100a3;// Output rate of the UBX-NAV-GEOFENCE message on port UART2
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_GEOFENCE_USB = 0x209100a4;	// Output rate of the UBX-NAV-GEOFENCE message on port USB
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_HPPOSECEF_I2C = 0x2091002e;// Output rate of the UBX-NAV-HPPOSECEF message on port I2C
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_HPPOSECEF_SPI = 0x20910032;// Output rate of the UBX-NAV-HPPOSECEF message on port SPI
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_HPPOSECEF_UART1 = 0x2091002f;// Output rate of the UBX-NAV-HPPOSECEF message on port UART1
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_HPPOSECEF_UART2 = 0x20910030;// Output rate of the UBX-NAV-HPPOSECEF message on port UART2
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_HPPOSECEF_USB = 0x20910031;// Output rate of the UBX-NAV-HPPOSECEF message on port USB
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_HPPOSLLH_I2C = 0x20910033;	// Output rate of the UBX-NAV-HPPOSLLH message on port I2C
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_HPPOSLLH_SPI = 0x20910037;	// Output rate of the UBX-NAV-HPPOSLLH message on port SPI
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_HPPOSLLH_UART1 = 0x20910034;// Output rate of the UBX-NAV-HPPOSLLH message on port UART1
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_HPPOSLLH_UART2 = 0x20910035;// Output rate of the UBX-NAV-HPPOSLLH message on port UART2
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_HPPOSLLH_USB = 0x20910036;	// Output rate of the UBX-NAV-HPPOSLLH message on port USB
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_ODO_I2C = 0x2091007e;			// Output rate of the UBX-NAV-ODO message on port I2C
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_ODO_SPI = 0x20910082;				// Output rate of the UBX-NAV-ODO message on port SPI
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_ODO_UART1 = 0x2091007f;			// Output rate of the UBX-NAV-ODO message on port UART1
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_ODO_UART2 = 0x20910080;			// Output rate of the UBX-NAV-ODO message on port UART2
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_ODO_USB = 0x20910081;				// Output rate of the UBX-NAV-ODO message on port USB
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_ORB_I2C = 0x20910010;				// Output rate of the UBX-NAV-ORB message on port I2C
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_ORB_SPI = 0x20910014;				// Output rate of the UBX-NAV-ORB message on port SPI
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_ORB_UART1 = 0x20910011;			// Output rate of the UBX-NAV-ORB message on port UART1
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_ORB_UART2 = 0x20910012;			// Output rate of the UBX-NAV-ORB message on port UART2
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_ORB_USB = 0x20910013;				// Output rate of the UBX-NAV-ORB message on port USB
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_POSECEF_I2C = 0x20910024;		// Output rate of the UBX-NAV-POSECEF message on port I2C
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_POSECEF_SPI = 0x20910028;	// Output rate of the UBX-NAV-POSECEF message on port SPI
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_POSECEF_UART1 = 0x20910025;// Output rate of the UBX-NAV-POSECEF message on port UART1
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_POSECEF_UART2 = 0x20910026;// Output rate of the UBX-NAV-POSECEF message on port UART2
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_POSECEF_USB = 0x20910027;	// Output rate of the UBX-NAV-POSECEF message on port USB
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_POSLLH_I2C = 0x20910029;	// Output rate of the UBX-NAV-POSLLH message on port I2C
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_POSLLH_SPI = 0x2091002d;	// Output rate of the UBX-NAV-POSLLH message on port SPI
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_POSLLH_UART1 = 0x2091002a;	// Output rate of the UBX-NAV-POSLLH message on port UART1
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_POSLLH_UART2 = 0x2091002b;	// Output rate of the UBX-NAV-POSLLH message on port UART2
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_POSLLH_USB = 0x2091002c;	// Output rate of the UBX-NAV-POSLLH message on port USB
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_PVT_I2C = 0x20910006;			// Output rate of the UBX-NAV-PVT message on port I2C
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_PVT_SPI = 0x2091000a;				// Output rate of the UBX-NAV-PVT message on port SPI
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_PVT_UART1 = 0x20910007;			// Output rate of the UBX-NAV-PVT message on port UART1
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_PVT_UART2 = 0x20910008;			// Output rate of the UBX-NAV-PVT message on port UART2
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_PVT_USB = 0x20910009;				// Output rate of the UBX-NAV-PVT message on port USB
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_RELPOSNED_I2C = 0x2091008d;	// Output rate of the UBX-NAV-RELPOSNED message on port I2C
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_RELPOSNED_SPI = 0x20910091;// Output rate of the UBX-NAV-RELPOSNED message on port SPI
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_RELPOSNED_UART1 = 0x2091008e;// Output rate of the UBX-NAV-RELPOSNED message on port UART1
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_RELPOSNED_UART2 = 0x2091008f;// Output rate of the UBX-NAV-RELPOSNED message on port UART2
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_RELPOSNED_USB = 0x20910090;// Output rate of the UBX-NAV-RELPOSNED message on port USB
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_SAT_I2C = 0x20910015;			// Output rate of the UBX-NAV-SAT message on port I2C
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_SAT_SPI = 0x20910019;				// Output rate of the UBX-NAV-SAT message on port SPI
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_SAT_UART1 = 0x20910016;			// Output rate of the UBX-NAV-SAT message on port UART1
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_SAT_UART2 = 0x20910017;			// Output rate of the UBX-NAV-SAT message on port UART2
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_SAT_USB = 0x20910018;				// Output rate of the UBX-NAV-SAT message on port USB
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_SBAS_I2C = 0x2091006a;			// Output rate of the UBX-NAV-SBAS message on port I2C
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_SBAS_SPI = 0x2091006e;			// Output rate of the UBX-NAV-SBAS message on port SPI
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_SBAS_UART1 = 0x2091006b;		// Output rate of the UBX-NAV-SBAS message on port UART1
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_SBAS_UART2 = 0x2091006c;	// Output rate of the UBX-NAV-SBAS message on port UART2
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_SBAS_USB = 0x2091006d;		// Output rate of the UBX-NAV-SBAS message on port USB
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_SIG_I2C = 0x20910345;				// Output rate of the UBX-NAV-SIG message on port I2C
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_SIG_SPI = 0x20910349;				// Output rate of the UBX-NAV-SIG message on port SPI
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_SIG_UART1 = 0x20910346;			// Output rate of the UBX-NAV-SIG message on port UART1
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_SIG_UART2 = 0x20910347;			// Output rate of the UBX-NAV-SIG message on port UART2
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_SIG_USB = 0x20910348;				// Output rate of the UBX-NAV-SIG message on port USB
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_SLAS_I2C = 0x20910336;			// Output rate of the UBX-NAV-SLAS message on port I2C
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_SLAS_SPI = 0x2091033a;			// Output rate of the UBX-NAV-SLAS message on port SPI
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_SLAS_UART1 = 0x20910337;		// Output rate of the UBX-NAV-SLAS message on port UART1
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_SLAS_UART2 = 0x20910338;	// Output rate of the UBX-NAV-SLAS message on port UART2
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_SLAS_USB = 0x20910339;		// Output rate of the UBX-NAV-SLAS message on port USB
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_STATUS_I2C = 0x2091001a;		// Output rate of the UBX-NAV-STATUS message on port I2C
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_STATUS_SPI = 0x2091001e;	// Output rate of the UBX-NAV-STATUS message on port SPI
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_STATUS_UART1 = 0x2091001b;	// Output rate of the UBX-NAV-STATUS message on port UART1
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_STATUS_UART2 = 0x2091001c;	// Output rate of the UBX-NAV-STATUS message on port UART2
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_STATUS_USB = 0x2091001d;	// Output rate of the UBX-NAV-STATUS message on port USB
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_SVIN_I2C = 0x20910088;		// Output rate of the UBX-NAV-SVIN message on port I2C
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_SVIN_SPI = 0x2091008c;			// Output rate of the UBX-NAV-SVIN message on port SPI
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_SVIN_UART1 = 0x20910089;		// Output rate of the UBX-NAV-SVIN message on port UART1
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_SVIN_UART2 = 0x2091008a;	// Output rate of the UBX-NAV-SVIN message on port UART2
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_SVIN_USB = 0x2091008b;		// Output rate of the UBX-NAV-SVIN message on port USB
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_TIMEBDS_I2C = 0x20910051;		// Output rate of the UBX-NAV-TIMEBDS message on port I2C
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_TIMEBDS_SPI = 0x20910055;	// Output rate of the UBX-NAV-TIMEBDS message on port SPI
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_TIMEBDS_UART1 = 0x20910052;// Output rate of the UBX-NAV-TIMEBDS message on port UART1
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_TIMEBDS_UART2 = 0x20910053;// Output rate of the UBX-NAV-TIMEBDS message on port UART2
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_TIMEBDS_USB = 0x20910054;	// Output rate of the UBX-NAV-TIMEBDS message on port USB
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_TIMEGAL_I2C = 0x20910056;	// Output rate of the UBX-NAV-TIMEGAL message on port I2C
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_TIMEGAL_SPI = 0x2091005a;	// Output rate of the UBX-NAV-TIMEGAL message on port SPI
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_TIMEGAL_UART1 = 0x20910057;// Output rate of the UBX-NAV-TIMEGAL message on port UART1
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_TIMEGAL_UART2 = 0x20910058;// Output rate of the UBX-NAV-TIMEGAL message on port UART2
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_TIMEGAL_USB = 0x20910059;	// Output rate of the UBX-NAV-TIMEGAL message on port USB
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_TIMEGLO_I2C = 0x2091004c;	// Output rate of the UBX-NAV-TIMEGLO message on port I2C
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_TIMEGLO_SPI = 0x20910050;	// Output rate of the UBX-NAV-TIMEGLO message on port SPI
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_TIMEGLO_UART1 = 0x2091004d;// Output rate of the UBX-NAV-TIMEGLO message on port UART1
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_TIMEGLO_UART2 = 0x2091004e;// Output rate of the UBX-NAV-TIMEGLO message on port UART2
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_TIMEGLO_USB = 0x2091004f;	// Output rate of the UBX-NAV-TIMEGLO message on port USB
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_TIMEGPS_I2C = 0x20910047;	// Output rate of the UBX-NAV-TIMEGPS message on port I2C
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_TIMEGPS_SPI = 0x2091004b;	// Output rate of the UBX-NAV-TIMEGPS message on port SPI
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_TIMEGPS_UART1 = 0x20910048;// Output rate of the UBX-NAV-TIMEGPS message on port UART1
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_TIMEGPS_UART2 = 0x20910049;// Output rate of the UBX-NAV-TIMEGPS message on port UART2
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_TIMEGPS_USB = 0x2091004a;	// Output rate of the UBX-NAV-TIMEGPS message on port USB
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_TIMELS_I2C = 0x20910060;	// Output rate of the UBX-NAV-TIMELS message on port I2C
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_TIMELS_SPI = 0x20910064;	// Output rate of the UBX-NAV-TIMELS message on port SPI
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_TIMELS_UART1 = 0x20910061;	// Output rate of the UBX-NAV-TIMELS message on port UART1
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_TIMELS_UART2 = 0x20910062;	// Output rate of the UBX-NAV-TIMELS message on port UART2
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_TIMELS_USB = 0x20910063;	// Output rate of the UBX-NAV-TIMELS message on port USB
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_TIMEQZSS_I2C = 0x20910386;	// Output rate of the UBX-NAV-TIMEQZSSmessage on port I2C
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_TIMEQZSS_SPI = 0x2091038a;	// Output rate of the UBX-NAV-TIMEQZSSmessage on port SPI
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_TIMEQZSS_UART1 = 0x20910387;// Output rate of the UBX-NAV-TIMEQZSSmessage on port UART1
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_TIMEQZSS_UART2 = 0x20910388;// Output rate of the UBX-NAV-TIMEQZSSmessage on port UART2
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_TIMEQZSS_USB = 0x20910389;	// Output rate of the UBX-NAV-TIMEQZSSmessage on port USB
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_TIMEUTC_I2C = 0x2091005b;	// Output rate of the UBX-NAV-TIMEUTC message on port I2C
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_TIMEUTC_SPI = 0x2091005f;	// Output rate of the UBX-NAV-TIMEUTC message on port SPI
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_TIMEUTC_UART1 = 0x2091005c;// Output rate of the UBX-NAV-TIMEUTC message on port UART1
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_TIMEUTC_UART2 = 0x2091005d;// Output rate of the UBX-NAV-TIMEUTC message on port UART2
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_TIMEUTC_USB = 0x2091005e;	// Output rate of the UBX-NAV-TIMEUTC message on port USB
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_VELECEF_I2C = 0x2091003d;	// Output rate of the UBX-NAV-VELECEF message on port I2C
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_VELECEF_SPI = 0x20910041;	// Output rate of the UBX-NAV-VELECEF message on port SPI
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_VELECEF_UART1 = 0x2091003e;// Output rate of the UBX-NAV-VELECEF message on port UART1
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_VELECEF_UART2 = 0x2091003f;// Output rate of the UBX-NAV-VELECEF message on port UART2
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_VELECEF_USB = 0x20910040;	// Output rate of the UBX-NAV-VELECEF message on port USB
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_VELNED_I2C = 0x20910042;	// Output rate of the UBX-NAV-VELNED message on port I2C
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_VELNED_SPI = 0x20910046;	// Output rate of the UBX-NAV-VELNED message on port SPI
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_VELNED_UART1 = 0x20910043;	// Output rate of the UBX-NAV-VELNED message on port UART1
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_VELNED_UART2 = 0x20910044;	// Output rate of the UBX-NAV-VELNED message on port UART2
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_VELNED_USB = 0x20910045;	// Output rate of the UBX-NAV-VELNED message on port USB
-const uint32_t UBLOX_CFG_MSGOUT_UBX_RXM_MEASX_I2C = 0x20910204;		// Output rate of the UBX-RXM-MEASX message on port I2C
-const uint32_t UBLOX_CFG_MSGOUT_UBX_RXM_MEASX_SPI = 0x20910208;			// Output rate of the UBX-RXM-MEASX message on port SPI
-const uint32_t UBLOX_CFG_MSGOUT_UBX_RXM_MEASX_UART1 = 0x20910205;		// Output rate of the UBX-RXM-MEASX message on port UART1
-const uint32_t UBLOX_CFG_MSGOUT_UBX_RXM_MEASX_UART2 = 0x20910206;	// Output rate of the UBX-RXM-MEASX message on port UART2
-const uint32_t UBLOX_CFG_MSGOUT_UBX_RXM_MEASX_USB = 0x20910207;		// Output rate of the UBX-RXM-MEASX message on port USB
-const uint32_t UBLOX_CFG_MSGOUT_UBX_RXM_RAWX_I2C = 0x209102a4;			// Output rate of the UBX-RXM-RAWX message on port I2C
-const uint32_t UBLOX_CFG_MSGOUT_UBX_RXM_RAWX_SPI = 0x209102a8;			// Output rate of the UBX-RXM-RAWX message on port SPI
-const uint32_t UBLOX_CFG_MSGOUT_UBX_RXM_RAWX_UART1 = 0x209102a5;		// Output rate of the UBX-RXM-RAWX message on port UART1
-const uint32_t UBLOX_CFG_MSGOUT_UBX_RXM_RAWX_UART2 = 0x209102a6;	// Output rate of the UBX-RXM-RAWX message on port UART2
-const uint32_t UBLOX_CFG_MSGOUT_UBX_RXM_RAWX_USB = 0x209102a7;		// Output rate of the UBX-RXM-RAWX message on port USB
-const uint32_t UBLOX_CFG_MSGOUT_UBX_RXM_RLM_I2C = 0x2091025e;				// Output rate of the UBX-RXM-RLM message on port I2C
-const uint32_t UBLOX_CFG_MSGOUT_UBX_RXM_RLM_SPI = 0x20910262;				// Output rate of the UBX-RXM-RLM message on port SPI
-const uint32_t UBLOX_CFG_MSGOUT_UBX_RXM_RLM_UART1 = 0x2091025f;			// Output rate of the UBX-RXM-RLM message on port UART1
-const uint32_t UBLOX_CFG_MSGOUT_UBX_RXM_RLM_UART2 = 0x20910260;			// Output rate of the UBX-RXM-RLM message on port UART2
-const uint32_t UBLOX_CFG_MSGOUT_UBX_RXM_RLM_USB = 0x20910261;				// Output rate of the UBX-RXM-RLM message on port USB
-const uint32_t UBLOX_CFG_MSGOUT_UBX_RXM_RTCM_I2C = 0x20910268;			// Output rate of the UBX-RXM-RTCM message on port I2C
-const uint32_t UBLOX_CFG_MSGOUT_UBX_RXM_RTCM_SPI = 0x2091026c;			// Output rate of the UBX-RXM-RTCM message on port SPI
-const uint32_t UBLOX_CFG_MSGOUT_UBX_RXM_RTCM_UART1 = 0x20910269;			// Output rate of the UBX-RXM-RTCM message on port UART1
-const uint32_t UBLOX_CFG_MSGOUT_UBX_RXM_RTCM_UART2 = 0x2091026a;		// Output rate of the UBX-RXM-RTCM message on port UART2
-const uint32_t UBLOX_CFG_MSGOUT_UBX_RXM_RTCM_USB = 0x2091026b;		// Output rate of the UBX-RXM-RTCM message on port USB
-const uint32_t UBLOX_CFG_MSGOUT_UBX_RXM_SFRBX_I2C = 0x20910231;			// Output rate of the UBX-RXM-SFRBX message on port I2C
-const uint32_t UBLOX_CFG_MSGOUT_UBX_RXM_SFRBX_SPI = 0x20910235;			// Output rate of the UBX-RXM-SFRBX message on port SPI
-const uint32_t UBLOX_CFG_MSGOUT_UBX_RXM_SFRBX_UART1 = 0x20910232;		// Output rate of the UBX-RXM-SFRBX message on port UART1
-const uint32_t UBLOX_CFG_MSGOUT_UBX_RXM_SFRBX_UART2 = 0x20910233;	// Output rate of the UBX-RXM-SFRBX message on port UART2
-const uint32_t UBLOX_CFG_MSGOUT_UBX_RXM_SFRBX_USB = 0x20910234;		// Output rate of the UBX-RXM-SFRBX message on port USB
-const uint32_t UBLOX_CFG_MSGOUT_UBX_TIM_TM2_I2C = 0x20910178;				// Output rate of the UBX-TIM-TM2 message on port I2C
-const uint32_t UBLOX_CFG_MSGOUT_UBX_TIM_TM2_SPI = 0x2091017c;				// Output rate of the UBX-TIM-TM2 message on port SPI
-const uint32_t UBLOX_CFG_MSGOUT_UBX_TIM_TM2_UART1 = 0x20910179;			// Output rate of the UBX-TIM-TM2 message on port UART1
-const uint32_t UBLOX_CFG_MSGOUT_UBX_TIM_TM2_UART2 = 0x2091017a;			// Output rate of the UBX-TIM-TM2 message on port UART2
-const uint32_t UBLOX_CFG_MSGOUT_UBX_TIM_TM2_USB = 0x2091017b;				// Output rate of the UBX-TIM-TM2 message on port USB
-const uint32_t UBLOX_CFG_MSGOUT_UBX_TIM_TP_I2C = 0x2091017d;				// Output rate of the UBX-TIM-TP message on port I2C
-const uint32_t UBLOX_CFG_MSGOUT_UBX_TIM_TP_SPI = 0x20910181;				// Output rate of the UBX-TIM-TP message on port SPI
-const uint32_t UBLOX_CFG_MSGOUT_UBX_TIM_TP_UART1 = 0x2091017e;			// Output rate of the UBX-TIM-TP message on port UART1
-const uint32_t UBLOX_CFG_MSGOUT_UBX_TIM_TP_UART2 = 0x2091017f;			// Output rate of the UBX-TIM-TP message on port UART2
-const uint32_t UBLOX_CFG_MSGOUT_UBX_TIM_TP_USB = 0x20910180;				// Output rate of the UBX-TIM-TP message on port USB
-const uint32_t UBLOX_CFG_MSGOUT_UBX_TIM_VRFY_I2C = 0x20910092;			// Output rate of the UBX-TIM-VRFY message on port I2C
-const uint32_t UBLOX_CFG_MSGOUT_UBX_TIM_VRFY_SPI = 0x20910096;			// Output rate of the UBX-TIM-VRFY message on port SPI
-const uint32_t UBLOX_CFG_MSGOUT_UBX_TIM_VRFY_UART1 = 0x20910093;			// Output rate of the UBX-TIM-VRFY message on port UART1
-const uint32_t UBLOX_CFG_MSGOUT_UBX_TIM_VRFY_UART2 = 0x20910094;		// Output rate of the UBX-TIM-VRFY message on port UART2
-const uint32_t UBLOX_CFG_MSGOUT_UBX_TIM_VRFY_USB = 0x20910095;		// Output rate of the UBX-TIM-VRFY message on port USB
-
-//CFG-NAVHPG: High precision navigation configuration
-//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
-const uint32_t UBLOX_CFG_NAVHPG_DGNSSMODE = 0x20140011;	// Diﬀerential corrections mode
-
-//CFG-NAVSPG: Standard precision navigation configuration
-//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
-const uint32_t UBLOX_CFG_NAVSPG_FIXMODE = 0x20110011;	// Position fix mode
-const uint32_t UBLOX_CFG_NAVSPG_INIFIX3D = 0x10110013;	// Initial fix must be a 3D fix
-const uint32_t UBLOX_CFG_NAVSPG_WKNROLLOVER = 0x30110017;	// GPS week rollover number
-const uint32_t UBLOX_CFG_NAVSPG_UTCSTANDARD = 0x2011001c;	// UTC standard to be used
-const uint32_t UBLOX_CFG_NAVSPG_DYNMODEL = 0x20110021;	// Dynamic platform model
-const uint32_t UBLOX_CFG_NAVSPG_ACKAIDING = 0x10110025;	// Acknowledge assistance input messages
-const uint32_t UBLOX_CFG_NAVSPG_USE_USRDAT = 0x10110061;	// Use user geodetic datum parameters
-const uint32_t UBLOX_CFG_NAVSPG_USRDAT_MAJA = 0x50110062;	// Geodetic datum semi-major axis
-const uint32_t UBLOX_CFG_NAVSPG_USRDAT_FLAT = 0x50110063;	// Geodetic datum 1.0 flattening
-const uint32_t UBLOX_CFG_NAVSPG_USRDAT_DX = 0x40110064;	// Geodetic datum X axis shift at the origin
-const uint32_t UBLOX_CFG_NAVSPG_USRDAT_DY = 0x40110065;	// Geodetic datum Y axis shift at the origin
-const uint32_t UBLOX_CFG_NAVSPG_USRDAT_DZ = 0x40110066;	// Geodetic datum Z axis shift at the origin
-const uint32_t UBLOX_CFG_NAVSPG_USRDAT_ROTX = 0x40110067;	// arcsec Geodetic datum rotation about the X axis
-const uint32_t UBLOX_CFG_NAVSPG_USRDAT_ROTY = 0x40110068;	// arcsec Geodetic datum rotation about the Y axis
-const uint32_t UBLOX_CFG_NAVSPG_USRDAT_ROTZ = 0x40110069;	// arcsec Geodetic datum rotation about the Z axis
-const uint32_t UBLOX_CFG_NAVSPG_USRDAT_SCALE = 0x4011006a;	// ppm Geodetic datum scale factor
-const uint32_t UBLOX_CFG_NAVSPG_INFIL_MINSVS = 0x201100a1;	// Minimum number of satellites for navigation
-const uint32_t UBLOX_CFG_NAVSPG_INFIL_MAXSVS = 0x201100a2;	// Maximum number of satellites for navigation
-const uint32_t UBLOX_CFG_NAVSPG_INFIL_MINCNO = 0x201100a3;	// Minimum satellite signal level for navigation
-const uint32_t UBLOX_CFG_NAVSPG_INFIL_MINELEV = 0x201100a4;	// Minimum elevation for a GNSS satellite to be used in navigation
-const uint32_t UBLOX_CFG_NAVSPG_INFIL_NCNOTHRS = 0x201100aa;	// Number of satellites required to have C/N0 above const uint32_t UBLOX_CFG_NAVSPG-INFIL_CNOTHRS for a fix to be attempted
-const uint32_t UBLOX_CFG_NAVSPG_INFIL_CNOTHRS = 0x201100ab;	// C/N0 threshold for deciding whether to attempt a fix
-const uint32_t UBLOX_CFG_NAVSPG_OUTFIL_PDOP = 0x301100b1;	// Output filter position DOP mask (threshold)
-const uint32_t UBLOX_CFG_NAVSPG_OUTFIL_TDOP = 0x301100b2;	// Output filter time DOP mask (threshold)
-const uint32_t UBLOX_CFG_NAVSPG_OUTFIL_PACC = 0x301100b3;	// Output filter position accuracy mask (threshold)
-const uint32_t UBLOX_CFG_NAVSPG_OUTFIL_TACC = 0x301100b4;	// Output filter time accuracy mask (threshold)
-const uint32_t UBLOX_CFG_NAVSPG_OUTFIL_FACC = 0x301100b5;	// Output filter frequency accuracy mask (threshold)
-const uint32_t UBLOX_CFG_NAVSPG_CONSTR_ALT = 0x401100c1;	// Fixed altitude (mean sea level) for 2D fix mode
-const uint32_t UBLOX_CFG_NAVSPG_CONSTR_ALTVAR = 0x401100c2;	// Fixed altitude variance for 2D mode
-const uint32_t UBLOX_CFG_NAVSPG_CONSTR_DGNSSTO = 0x201100c4;	// DGNSS timeout
-
-//CFG-NMEA: NMEA protocol configuration
-//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
-const uint32_t UBLOX_CFG_NMEA_PROTVER = 0x20930001;	// NMEA protocol version
-const uint32_t UBLOX_CFG_NMEA_MAXSVS = 0x20930002;	// Maximum number of SVs to report per Talker ID
-const uint32_t UBLOX_CFG_NMEA_COMPAT = 0x10930003;	// Enable compatibility mode
-const uint32_t UBLOX_CFG_NMEA_CONSIDER = 0x10930004;	// Enable considering mode
-const uint32_t UBLOX_CFG_NMEA_LIMIT82 = 0x10930005;	// Enable strict limit to 82 characters maximum NMEA message length
-const uint32_t UBLOX_CFG_NMEA_HIGHPREC = 0x10930006;	// Enable high precision mode
-const uint32_t UBLOX_CFG_NMEA_SVNUMBERING = 0x20930007;	// Display configuration for SVs that do not have value defined in NMEA
-const uint32_t UBLOX_CFG_NMEA_FILT_GPS = 0x10930011;	// Disable reporting of GPS satellites
-const uint32_t UBLOX_CFG_NMEA_FILT_SBAS = 0x10930012;	// Disable reporting of SBAS satellites
-const uint32_t UBLOX_CFG_NMEA_FILT_GAL = 0x10930013;	// Disable reporting of Galileo satellites
-const uint32_t UBLOX_CFG_NMEA_FILT_QZSS = 0x10930015;	// Disable reporting of QZSS satellites
-const uint32_t UBLOX_CFG_NMEA_FILT_GLO = 0x10930016;	// Disable reporting of GLONASS satellites
-const uint32_t UBLOX_CFG_NMEA_FILT_BDS = 0x10930017;	// Disable reporting of BeiDou satellites
-const uint32_t UBLOX_CFG_NMEA_OUT_INVFIX = 0x10930021;	// Enable position output for failed or invalid fixes
-const uint32_t UBLOX_CFG_NMEA_OUT_MSKFIX = 0x10930022;	// Enable position output for invalid fixes
-const uint32_t UBLOX_CFG_NMEA_OUT_INVTIME = 0x10930023;	// Enable time output for invalid times
-const uint32_t UBLOX_CFG_NMEA_OUT_INVDATE = 0x10930024;	// Enable date output for invalid dates
-const uint32_t UBLOX_CFG_NMEA_OUT_ONLYGPS = 0x10930025;	// Restrict output to GPS satellites only
-const uint32_t UBLOX_CFG_NMEA_OUT_FROZENCOG = 0x10930026;	// Enable course over ground output even if it is frozen
-const uint32_t UBLOX_CFG_NMEA_MAINTALKERID = 0x20930031;	// Main Talker ID
-const uint32_t UBLOX_CFG_NMEA_GSVTALKERID = 0x20930032;	// Talker ID for GSV NMEA messages
-const uint32_t UBLOX_CFG_NMEA_BDSTALKERID = 0x30930033;	// BeiDou Talker ID
-
-//CFG-ODO: Odometer and low-speed course over ground filter
-//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
-const uint32_t UBLOX_CFG_ODO_USE_ODO = 0x10220001;	// Use odometer
-const uint32_t UBLOX_CFG_ODO_USE_COG = 0x10220002;	// Use low-speed course over ground filter
-const uint32_t UBLOX_CFG_ODO_OUTLPVEL = 0x10220003;	// Output low-pass filtered velocity
-const uint32_t UBLOX_CFG_ODO_OUTLPCOG = 0x10220004;	// Output low-pass filtered course over ground (heading)
-const uint32_t UBLOX_CFG_ODO_PROFILE = 0x20220005;	// Odometer profile configuration
-const uint32_t UBLOX_CFG_ODO_COGMAXSPEED = 0x20220021;	// Upper speed limit for low-speed course over ground filter
-const uint32_t UBLOX_CFG_ODO_COGMAXPOSACC = 0x20220022;	// Maximum acceptable position accuracy for computing low-speed filtered course over ground
-const uint32_t UBLOX_CFG_ODO_VELLPGAIN = 0x20220031;	// Velocity low-pass filter level
-const uint32_t UBLOX_CFG_ODO_COGLPGAIN = 0x20220032;	// Course over ground low-pass filter level (at speed < 8 m/s)
-
-//CFG-QZSS: QZSS system configuration
-//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
-const uint32_t UBLOX_CFG_QZSS_USE_SLAS_DGNSS = 0x10370005;	// Apply QZSS SLAS DGNSS corrections
-const uint32_t UBLOX_CFG_QZSS_USE_SLAS_TESTMODE = 0x10370006;	// Use QZSS SLAS data when it is in test mode (SLAS msg 0)
-const uint32_t UBLOX_CFG_QZSS_USE_SLAS_RAIM_UNCORR = 0x10370007;	// Raim out measurements that are not corrected by QZSS SLAS, if at least 5 measurements are corrected
-
-//CFG-RATE: Navigation and measurement rate configuration
-//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
-const uint32_t UBLOX_CFG_RATE_MEAS = 0x30210001;	// Nominal time between GNSS measurements
-const uint32_t UBLOX_CFG_RATE_NAV = 0x30210002;	// Ratio of number of measurements to number of navigation solutions
-const uint32_t UBLOX_CFG_RATE_TIMEREF = 0x20210003;	// Time system to which measurements are aligned
-
-//CFG-RINV: Remote inventory
-//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
-const uint32_t UBLOX_CFG_RINV_DUMP = 0x10c70001;	// Dump data at startup
-const uint32_t UBLOX_CFG_RINV_BINARY = 0x10c70002;	// Data is binary
-const uint32_t UBLOX_CFG_RINV_DATA_SIZE = 0x20c70003;	// Size of data
-const uint32_t UBLOX_CFG_RINV_CHUNK0 = 0x50c70004;	// Data bytes 1-8 (LSB)
-const uint32_t UBLOX_CFG_RINV_CHUNK1 = 0x50c70005;	// Data bytes 9-16
-const uint32_t UBLOX_CFG_RINV_CHUNK2 = 0x50c70006;	// Data bytes 17-240x44434241.
-const uint32_t UBLOX_CFG_RINV_CHUNK3 = 0x50c70007;	// Data bytes 25-30 (MSB)
-
-//CFG-RTCM: RTCM protocol configuration
-//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
-const uint32_t UBLOX_CFG_RTCM_DF003_OUT = 0x30090001;	// RTCM DF003 (Reference station ID) output value
-const uint32_t UBLOX_CFG_RTCM_DF003_IN = 0x30090008;	// RTCM DF003 (Reference station ID) input value
-const uint32_t UBLOX_CFG_RTCM_DF003_IN_FILTER = 0x20090009;	// RTCM input filter configuration based on RTCM DF003 (Reference station ID) value
-
-//CFG-SBAS: SBAS configuration
-//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
-const uint32_t UBLOX_CFG_SBAS_USE_TESTMODE = 0x10360002;	// Use SBAS data when it is in test mode (SBAS msg 0)
-const uint32_t UBLOX_CFG_SBAS_USE_RANGING = 0x10360003;	// Use SBAS GEOs as a ranging source (for navigation)
-const uint32_t UBLOX_CFG_SBAS_USE_DIFFCORR = 0x10360004;	// Use SBAS diﬀerential corrections
-const uint32_t UBLOX_CFG_SBAS_USE_INTEGRITY = 0x10360005;	// Use SBAS integrity information
-const uint32_t UBLOX_CFG_SBAS_PRNSCANMASK = 0x50360006;	// SBAS PRN search configuration
-
-//CFG-SIGNAL: Satellite systems (GNSS) signal configuration
-//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
-const uint32_t UBLOX_CFG_SIGNAL_GPS_ENA = 0x1031001f;	// GPS enable
-const uint32_t UBLOX_CFG_SIGNAL_GPS_L1CA_ENA = 0x10310001;	// GPS L1C/A
-const uint32_t UBLOX_CFG_SIGNAL_GPS_L2C_ENA = 0x10310003;	// GPS L2C (only on u-blox F9 platform products)
-const uint32_t UBLOX_CFG_SIGNAL_SBAS_ENA = 0x10310020;	// SBAS enable
-const uint32_t UBLOX_CFG_SIGNAL_SBAS_L1CA_ENA = 0x10310005;	// SBAS L1C/A
-const uint32_t UBLOX_CFG_SIGNAL_GAL_ENA = 0x10310021;	// Galileo enable
-const uint32_t UBLOX_CFG_SIGNAL_GAL_E1_ENA = 0x10310007;	// Galileo E1
-const uint32_t UBLOX_CFG_SIGNAL_GAL_E5B_ENA = 0x1031000a;	// Galileo E5b (only on u-blox F9 platform products)
-const uint32_t UBLOX_CFG_SIGNAL_BDS_ENA = 0x10310022;	// BeiDou Enable
-const uint32_t UBLOX_CFG_SIGNAL_BDS_B1_ENA = 0x1031000d;	// BeiDou B1I
-const uint32_t UBLOX_CFG_SIGNAL_BDS_B2_ENA = 0x1031000e;	// BeiDou B2I (only on u-blox F9 platform products)
-const uint32_t UBLOX_CFG_SIGNAL_QZSS_ENA = 0x10310024;	// QZSS enable
-const uint32_t UBLOX_CFG_SIGNAL_QZSS_L1CA_ENA = 0x10310012;	// QZSS L1C/A
-const uint32_t UBLOX_CFG_SIGNAL_QZSS_L1S_ENA = 0x10310014;	// QZSS L1S
-const uint32_t UBLOX_CFG_SIGNAL_QZSS_L2C_ENA = 0x10310015;	// QZSS L2C (only on u-blox F9 platform products)
-const uint32_t UBLOX_CFG_SIGNAL_GLO_ENA = 0x10310025;	// GLONASS enable
-const uint32_t UBLOX_CFG_SIGNAL_GLO_L1_ENA = 0x10310018;	// GLONASS L1
-const uint32_t UBLOX_CFG_SIGNAL_GLO_L2_ENA = 0x1031001a;	// GLONASS L2 (only on u-blox F9 platform products)
-
-//CFG-SPI: Configuration of the SPI interface
-//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
-const uint32_t UBLOX_CFG_SPI_MAXFF = 0x20640001;	// Number of bytes containing 0xFF to receive before switching oﬀ reception. Range: 0 (mechanism oﬀ) - 63
-const uint32_t UBLOX_CFG_SPI_CPOLARITY = 0x10640002;	// Clock polarity select: 0: Active Hight Clock, SCLK idles low, 1: Active Low Clock, SCLK idles high
-const uint32_t UBLOX_CFG_SPI_CPHASE = 0x10640003;	// Clock phase select: 0: Data captured on first edge of SCLK, 1: Data captured on second edge of SCLK
-const uint32_t UBLOX_CFG_SPI_EXTENDEDTIMEOUT = 0x10640005;	// Flag to disable timeouting the interface after 1.5s
-const uint32_t UBLOX_CFG_SPI_ENABLED = 0x10640006;	// Flag to indicate if the SPI interface should be enabled
-
-//CFG-SPIINPROT: Input protocol configuration of the SPI interface
-//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
-const uint32_t UBLOX_CFG_SPIINPROT_UBX = 0x10790001;	// Flag to indicate if UBX should be an input protocol on SPI
-const uint32_t UBLOX_CFG_SPIINPROT_NMEA = 0x10790002;	// Flag to indicate if NMEA should be an input protocol on SPI
-const uint32_t UBLOX_CFG_SPIINPROT_RTCM3X = 0x10790004;	// Flag to indicate if RTCM3X should be an input protocol on SPI
-
-//CFG-SPIOUTPROT: Output protocol configuration of the SPI interface
-//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
-const uint32_t UBLOX_CFG_SPIOUTPROT_UBX = 0x107a0001;	// Flag to indicate if UBX should be an output protocol on SPI
-const uint32_t UBLOX_CFG_SPIOUTPROT_NMEA = 0x107a0002;	// Flag to indicate if NMEA should be an output protocol on SPI
-const uint32_t UBLOX_CFG_SPIOUTPROT_RTCM3X = 0x107a0004;	// Flag to indicate if RTCM3X should be an output protocol on SPI
-
-//CFG-TMODE: Time mode configuration
-//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
-const uint32_t UBLOX_CFG_TMODE_MODE = 0x20030001;	// Receiver mode
-const uint32_t UBLOX_CFG_TMODE_POS_TYPE = 0x20030002;	// Determines whether the ARP position is given in ECEF or LAT/LON/HEIGHT?
-const uint32_t UBLOX_CFG_TMODE_ECEF_X = 0x40030003;	// ECEF X coordinate of the ARP position.
-const uint32_t UBLOX_CFG_TMODE_ECEF_Y = 0x40030004;	// ECEF Y coordinate of the ARP position.
-const uint32_t UBLOX_CFG_TMODE_ECEF_Z = 0x40030005;	// ECEF Z coordinate of the ARP position.
-const uint32_t UBLOX_CFG_TMODE_ECEF_X_HP = 0x20030006;	// High-precision ECEF X coordinate of the ARP position.
-const uint32_t UBLOX_CFG_TMODE_ECEF_Y_HP = 0x20030007;	// High-precision ECEF Y coordinate of the ARP position.
-const uint32_t UBLOX_CFG_TMODE_ECEF_Z_HP = 0x20030008;	// High-precision ECEF Z coordinate of the ARP position.
-const uint32_t UBLOX_CFG_TMODE_LAT = 0x40030009;	// Latitude of the ARP position.
-const uint32_t UBLOX_CFG_TMODE_LON = 0x4003000a;	// Longitude of the ARP position.
-const uint32_t UBLOX_CFG_TMODE_HEIGHT = 0x4003000b;	// Height of the ARP position.
-const uint32_t UBLOX_CFG_TMODE_LAT_HP = 0x2003000c;	// High-precision latitude of the ARP position
-const uint32_t UBLOX_CFG_TMODE_LON_HP = 0x2003000d;	// High-precision longitude of the ARP position.
-const uint32_t UBLOX_CFG_TMODE_HEIGHT_HP = 0x2003000e;	// High-precision height of the ARP position.
-const uint32_t UBLOX_CFG_TMODE_FIXED_POS_ACC = 0x4003000f;	// Fixed position 3D accuracy
-const uint32_t UBLOX_CFG_TMODE_SVIN_MIN_DUR = 0x40030010;	// Survey-in minimum duration
-const uint32_t UBLOX_CFG_TMODE_SVIN_ACC_LIMIT = 0x40030011;	// Survey-in position accuracy limit
-
-//CFG-TP: Timepulse configuration
-//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
-const uint32_t UBLOX_CFG_TP_PULSE_DEF = 0x20050023;	// Determines whether the time pulse is interpreted as frequency or period
-const uint32_t UBLOX_CFG_TP_PULSE_LENGTH_DEF = 0x20050030;	// Determines whether the time pulse length is interpreted as length[us] or pulse ratio[%]
-const uint32_t UBLOX_CFG_TP_FREQ_TP1 = 0x40050024;	// Time pulse frequency (TP1)
-const uint32_t UBLOX_CFG_TP_FREQ_LOCK_TP1 = 0x40050025;	// Time pulse frequency when locked to GNSS time (TP1)
-const uint32_t UBLOX_CFG_TP_LEN_TP1 = 0x40050004;	// Time pulse length (TP1)
-const uint32_t UBLOX_CFG_TP_LEN_LOCK_TP1 = 0x40050005;	// Time pulse length when locked to GNSS time (TP1)
-const uint32_t UBLOX_CFG_TP_DUTY_TP1 = 0x5005002a;	// Time pulse duty cycle (TP1)
-const uint32_t UBLOX_CFG_TP_DUTY_LOCK_TP1 = 0x5005002b;	// Time pulse duty cycle when locked to GNSS time (TP1)
-const uint32_t UBLOX_CFG_TP_USER_DELAY_TP1 = 0x40050006;	// User-configurable time pulse delay (TP1)
-const uint32_t UBLOX_CFG_TP_TP1_ENA = 0x10050007;	// Enable the first timepulse
-const uint32_t UBLOX_CFG_TP_SYNC_GNSS_TP1 = 0x10050008;	// Sync time pulse to GNSS time or local clock (TP1)
-const uint32_t UBLOX_CFG_TP_USE_LOCKED_TP1 = 0x10050009;	// Use locked parameters when possible (TP1)
-const uint32_t UBLOX_CFG_TP_ALIGN_TO_TOW_TP1 = 0x1005000a;	// Align time pulse to top of second (TP1)
-const uint32_t UBLOX_CFG_TP_POL_TP1 = 0x1005000b;	// Set time pulse polarity (TP1)
-const uint32_t UBLOX_CFG_TP_TIMEGRID_TP1 = 0x2005000c;	// Time grid to use (TP1)
-
-//CFG-TXREADY: TX ready configuration
-//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
-const uint32_t UBLOX_CFG_TXREADY_ENABLED = 0x10a20001;	// Flag to indicate if TX ready pin mechanism should be enabled
-const uint32_t UBLOX_CFG_TXREADY_POLARITY = 0x10a20002;	// The polarity of the TX ready pin: false:high- active, true:low-active
-const uint32_t UBLOX_CFG_TXREADY_PIN = 0x20a20003;	// Pin number to use for the TX ready functionality
-const uint32_t UBLOX_CFG_TXREADY_THRESHOLD = 0x30a20004;	// Amount of data that should be ready on the interface before triggering the TX ready pin
-const uint32_t UBLOX_CFG_TXREADY_INTERFACE = 0x20a20005;	// Interface where the TX ready feature should be linked to
-
-//CFG-UART1: Configuration of the UART1 interface
-//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
-const uint32_t UBLOX_CFG_UART1_BAUDRATE = 0x40520001;	// The baud rate that should be configured on the UART1
-const uint32_t UBLOX_CFG_UART1_STOPBITS = 0x20520002;	// Number of stopbits that should be used on UART1
-const uint32_t UBLOX_CFG_UART1_DATABITS = 0x20520003;	// Number of databits that should be used on UART1
-const uint32_t UBLOX_CFG_UART1_PARITY = 0x20520004;	// Parity mode that should be used on UART1
-const uint32_t UBLOX_CFG_UART1_ENABLED = 0x10520005;	// Flag to indicate if the UART1 should be enabled
-
-//CFG-UART1INPROT: Input protocol configuration of the UART1 interface
-//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
-const uint32_t UBLOX_CFG_UART1INPROT_UBX = 0x10730001;	// Flag to indicate if UBX should be an input protocol on UART1
-const uint32_t UBLOX_CFG_UART1INPROT_NMEA = 0x10730002;	// Flag to indicate if NMEA should be an input protocol on UART1
-const uint32_t UBLOX_CFG_UART1INPROT_RTCM3X = 0x10730004;	// Flag to indicate if RTCM3X should be an input protocol on UART1
-
-//CFG-UART1OUTPROT: Output protocol configuration of the UART1 interface
-//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
-const uint32_t UBLOX_CFG_UART1OUTPROT_UBX = 0x10740001;	// Flag to indicate if UBX should be an output protocol on UART1
-const uint32_t UBLOX_CFG_UART1OUTPROT_NMEA = 0x10740002;	// Flag to indicate if NMEA should be an output protocol on UART1
-const uint32_t UBLOX_CFG_UART1OUTPROT_RTCM3X = 0x10740004;	// Flag to indicate if RTCM3X should be an output protocol on UART1
-
-//CFG-UART2: Configuration of the UART2 interface
-//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
-const uint32_t UBLOX_CFG_UART2_BAUDRATE = 0x40530001;	// The baud rate that should be configured on the UART2
-const uint32_t UBLOX_CFG_UART2_STOPBITS = 0x20530002;	// Number of stopbits that should be used on UART2
-const uint32_t UBLOX_CFG_UART2_DATABITS = 0x20530003;	// Number of databits that should be used on UART2
-const uint32_t UBLOX_CFG_UART2_PARITY = 0x20530004;	// Parity mode that should be used on UART2
-const uint32_t UBLOX_CFG_UART2_ENABLED = 0x10530005;	// Flag to indicate if the UART2 should be enabled
-const uint32_t UBLOX_CFG_UART2_REMAP = 0x10530006;	// UART2 Remapping
-
-//CFG-UART2INPROT: Input protocol configuration of the UART2 interface
-//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
-const uint32_t UBLOX_CFG_UART2INPROT_UBX = 0x10750001;	// Flag to indicate if UBX should be an input protocol on UART2
-const uint32_t UBLOX_CFG_UART2INPROT_NMEA = 0x10750002;	// Flag to indicate if NMEA should be an input protocol on UART2
-const uint32_t UBLOX_CFG_UART2INPROT_RTCM3X = 0x10750004;	// Flag to indicate if RTCM3X should be an input protocol on UART2
-
-//CFG-UART2OUTPROT: Output protocol configuration of the UART2 interface
-//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
-const uint32_t UBLOX_CFG_UART2OUTPROT_UBX = 0x10760001;	// Flag to indicate if UBX should be an output protocol on UART2
-const uint32_t UBLOX_CFG_UART2OUTPROT_NMEA = 0x10760002;	// Flag to indicate if NMEA should be an output protocol on UART2
-const uint32_t UBLOX_CFG_UART2OUTPROT_RTCM3X = 0x10760004;	// Flag to indicate if RTCM3X should be an output protocol on UART2
-
-//CFG-USB: Configuration of the USB interface
-//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
-const uint32_t UBLOX_CFG_USB_ENABLED = 0x10650001;	// Flag to indicate if the USB interface should be enabled
-const uint32_t UBLOX_CFG_USB_SELFPOW = 0x10650002;	// Self-powered device
-const uint32_t UBLOX_CFG_USB_VENDOR_ID = 0x3065000a;	// Vendor ID
-const uint32_t UBLOX_CFG_USB_PRODUCT_ID = 0x3065000b;	// Vendor ID
-const uint32_t UBLOX_CFG_USB_POWER = 0x3065000c;	// Power consumption
-const uint32_t UBLOX_CFG_USB_VENDOR_STR0 = 0x5065000d;	// Vendor string characters 0-7
-const uint32_t UBLOX_CFG_USB_VENDOR_STR1 = 0x5065000e;	// Vendor string characters 8-15
-const uint32_t UBLOX_CFG_USB_VENDOR_STR2 = 0x5065000f;	// Vendor string characters 16-23
-const uint32_t UBLOX_CFG_USB_VENDOR_STR3 = 0x50650010;	// Vendor string characters 24-31
-const uint32_t UBLOX_CFG_USB_PRODUCT_STR0 = 0x50650011;	// Product string characters 0-7
-const uint32_t UBLOX_CFG_USB_PRODUCT_STR1 = 0x50650012;	// Product string characters 8-15
-const uint32_t UBLOX_CFG_USB_PRODUCT_STR2 = 0x50650013;	// Product string characters 16-23
-const uint32_t UBLOX_CFG_USB_PRODUCT_STR3 = 0x50650014;	// Product string characters 24-31
-const uint32_t UBLOX_CFG_USB_SERIAL_NO_STR0 = 0x50650015;	// Serial number string characters 0-7
-const uint32_t UBLOX_CFG_USB_SERIAL_NO_STR1 = 0x50650016;	// Serial number string characters 8-15
-const uint32_t UBLOX_CFG_USB_SERIAL_NO_STR2 = 0x50650017;	// Serial number string characters 16-23
-const uint32_t UBLOX_CFG_USB_SERIAL_NO_STR3 = 0x50650018;	// Serial number string characters 24-31
-
-//CFG-USBINPROT: Input protocol configuration of the USB interface
-//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
-const uint32_t UBLOX_CFG_USBINPROT_UBX = 0x10770001;	// Flag to indicate if UBX should be an input protocol on USB
-const uint32_t UBLOX_CFG_USBINPROT_NMEA = 0x10770002;	// Flag to indicate if NMEA should be an input protocol on USB
-const uint32_t UBLOX_CFG_USBINPROT_RTCM3X = 0x10770004;	// Flag to indicate if RTCM3X should be an input protocol on USB
-
-//CFG-USBOUTPROT: Output protocol configuration of the USB interface
-//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
-const uint32_t UBLOX_CFG_USBOUTPROT_UBX = 0x10780001;	// Flag to indicate if UBX should be an output protocol on USB
-const uint32_t UBLOX_CFG_USBOUTPROT_NMEA = 0x10780002;	// Flag to indicate if NMEA should be an output protocol on USB
-const uint32_t UBLOX_CFG_USBOUTPROT_RTCM3X = 0x10780004;	// Flag to indicate if RTCM3X should be an output protocol on USB
-
-#endif
diff --git a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/src/u-blox_structs.h b/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/src/u-blox_structs.h
deleted file mode 100644
index 50611bf..0000000
--- a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/src/u-blox_structs.h
+++ /dev/null
@@ -1,1827 +0,0 @@
-/*
-	This is a library written for the u-blox ZED-F9P and NEO-M8P-2
-	SparkFun sells these at its website: www.sparkfun.com
-	Do you like this library? Help support SparkFun. Buy a board!
-	https://www.sparkfun.com/products/16481
-	https://www.sparkfun.com/products/15136
-	https://www.sparkfun.com/products/15005
-	https://www.sparkfun.com/products/15733
-	https://www.sparkfun.com/products/15193
-	https://www.sparkfun.com/products/15210
-
-  Original version by Nathan Seidle @ SparkFun Electronics, September 6th, 2018
-	v2.0 rework by Paul Clark @ SparkFun Electronics, December 31st, 2020
-
-	This library handles configuring and handling the responses
-	from a u-blox GPS module. Works with most modules from u-blox including
-	the Zed-F9P, NEO-M8P-2, NEO-M9N, ZOE-M8Q, SAM-M8Q, and many others.
-
-	https://github.com/sparkfun/SparkFun_Ublox_Arduino_Library
-
-	Development environment specifics:
-	Arduino IDE 1.8.13
-
-	SparkFun code, firmware, and software is released under the MIT License(http://opensource.org/licenses/MIT).
-	The MIT License (MIT)
-	Copyright (c) 2016 SparkFun Electronics
-	Permission is hereby granted, free of charge, to any person obtaining a copy of this software and
-	associated documentation files (the "Software"), to deal in the Software without restriction,
-	including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
-	and/or sell copies of the Software, and to permit persons to whom the Software is furnished to
-	do so, subject to the following conditions:
-
-	The above copyright notice and this permission notice shall be included in all copies or substantial
-	portions of the Software.
-
-	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT
-	NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
-	IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
-	WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
-	SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-*/
-
-#ifndef __u_blox_structs_h__
-#define __u_blox_structs_h__
-
-#include "SparkFun_u-blox_GNSS_Arduino_Library.h"
-
-#ifndef DEF_NUM_SENS
-#define DEF_NUM_SENS 7 // The maximum number of ESF sensors
-#endif
-
-//Additional flags and pointers that need to be stored with each message type
-struct ubxAutomaticFlags
-{
-  union
-  {
-    uint8_t all;
-    struct
-    {
-      uint8_t automatic : 1; // Will this message be delivered and parsed "automatically" (without polling)
-      uint8_t implicitUpdate : 1; // Is the update triggered by accessing stale data (=true) or by a call to checkUblox (=false)
-      uint8_t addToFileBuffer : 1; // Should the raw UBX data be added to the file buffer?
-      uint8_t callbackCopyValid : 1; // Is the copy of the data struct used by the callback valid/fresh?
-    } bits;
-  } flags;
-};
-
-// UBX-NAV-POSECEF (0x01 0x01): Position solution in ECEF
-const uint16_t UBX_NAV_POSECEF_LEN = 20;
-
-typedef struct
-{
-  uint32_t iTOW; // GPS time of week of the navigation epoch: ms
-  int32_t ecefX; // ECEF X coordinate: cm
-  int32_t ecefY; // ECEF Y coordinate: cm
-  int32_t ecefZ; // ECEF Z coordinate: cm
-  uint32_t pAcc; // Position Accuracy Estimate: cm
-} UBX_NAV_POSECEF_data_t;
-
-typedef struct
-{
-  union
-  {
-    uint32_t all;
-    struct
-    {
-      uint32_t all : 1;
-
-      uint32_t iTOW : 1;
-      uint32_t ecefX : 1;
-      uint32_t ecefY : 1;
-      uint32_t ecefZ : 1;
-      uint32_t pAcc : 1;
-    } bits;
-  } moduleQueried;
-} UBX_NAV_POSECEF_moduleQueried_t;
-
-typedef struct
-{
-	ubxAutomaticFlags automaticFlags;
-  UBX_NAV_POSECEF_data_t data;
-  UBX_NAV_POSECEF_moduleQueried_t moduleQueried;
-  void (*callbackPointer)(UBX_NAV_POSECEF_data_t);
-  UBX_NAV_POSECEF_data_t  *callbackData;
-} UBX_NAV_POSECEF_t;
-
-// UBX-NAV-POSLLH (0x01 0x02): Geodetic position solution
-const uint16_t UBX_NAV_POSLLH_LEN = 28;
-
-typedef struct
-{
-  uint32_t iTOW; // GPS time of week of the navigation epoch: ms
-  int32_t lon; // Longitude: Degrees * 1e-7
-  int32_t lat; // Latitude: Degrees * 1e-7
-  int32_t height; // Height above ellipsoid: mm
-  int32_t hMSL; // Height above mean sea level: mm
-  uint32_t hAcc; // Horizontal Accuracy Estimate: mm
-  uint32_t vAcc; // Vertical Accuracy Estimate: mm
-} UBX_NAV_POSLLH_data_t;
-
-typedef struct
-{
-  union
-  {
-    uint32_t all;
-    struct
-    {
-      uint32_t all : 1;
-
-      uint32_t iTOW : 1;
-      uint32_t lon : 1;
-      uint32_t lat : 1;
-      uint32_t height : 1;
-      uint32_t hMSL : 1;
-      uint32_t hAcc : 1;
-      uint32_t vAcc : 1;
-    } bits;
-  } moduleQueried;
-} UBX_NAV_POSLLH_moduleQueried_t;
-
-typedef struct
-{
-	ubxAutomaticFlags automaticFlags;
-  UBX_NAV_POSLLH_data_t data;
-  UBX_NAV_POSLLH_moduleQueried_t moduleQueried;
-  void (*callbackPointer)(UBX_NAV_POSLLH_data_t);
-  UBX_NAV_POSLLH_data_t  *callbackData;
-} UBX_NAV_POSLLH_t;
-
-// UBX-NAV-STATUS (0x01 0x03): Receiver navigation status
-const uint16_t UBX_NAV_STATUS_LEN = 16;
-
-typedef struct
-{
-  uint32_t iTOW; // GPS time of week of the navigation epoch: ms
-  uint8_t gpsFix; // GPSfix Type: 0x00 = no fix; 0x01 = dead reckoning only; 0x02 = 2D-fix; 0x03 = 3D-fix
-                  // 0x04 = GPS + dead reckoning combined; 0x05 = Time only fix; 0x06..0xff = reserved
-  union
-  {
-    uint8_t all;
-    struct
-    {
-      uint8_t gpsFixOk : 1; // 1 = position and velocity valid and within DOP and ACC Masks.
-      uint8_t diffSoln : 1; // 1 = differential corrections were applied
-      uint8_t wknSet : 1; // 1 = Week Number valid (see Time Validity section for details)
-      uint8_t towSet : 1; // 1 = Time of Week valid (see Time Validity section for details)
-    } bits;
-  } flags;
-  union
-  {
-    uint8_t all;
-    struct
-    {
-      uint8_t diffCorr : 1; // 1 = differential corrections available
-      uint8_t carrSolnValid : 1; // 1 = valid carrSoln
-      uint8_t reserved : 4;
-      uint8_t mapMatching : 2; // map matching status: 00: none
-                               // 01: valid but not used, i.e. map matching data was received, but was too old
-                               // 10: valid and used, map matching data was applied
-                               // 11: valid and used, map matching data was applied.
-    } bits;
-  } fixStat;
-  union
-  {
-    uint8_t all;
-    struct
-    {
-      uint8_t psmState : 2; // power save mode state
-                            // 0: ACQUISITION [or when psm disabled]
-                            // 1: TRACKING
-                            // 2: POWER OPTIMIZED TRACKING
-                            // 3: INACTIVE
-      uint8_t reserved1 : 1;
-      uint8_t spoofDetState : 2; // Spoofing detection state
-                                 // 0: Unknown or deactivated
-                                 // 1: No spoofing indicated
-                                 // 2: Spoofing indicated
-                                 // 3: Multiple spoofing indications
-      uint8_t reserved2 : 1;
-      uint8_t carrSoln : 2; // Carrier phase range solution status:
-                            // 0: no carrier phase range solution
-                            // 1: carrier phase range solution with floating ambiguities
-                            // 2: carrier phase range solution with fixed ambiguities
-    } bits;
-  } flags2;
-  uint32_t ttff; // Time to first fix (millisecond time tag): ms
-  uint32_t msss; // Milliseconds since Startup / Reset: ms
-} UBX_NAV_STATUS_data_t;
-
-typedef struct
-{
-  union
-  {
-    uint32_t all;
-    struct
-    {
-      uint32_t all : 1;
-
-      uint32_t iTOW : 1;
-      uint32_t gpsFix : 1;
-
-      uint32_t gpsFixOk : 1;
-      uint32_t diffSoln : 1;
-      uint32_t wknSet : 1;
-      uint32_t towSet : 1;
-
-      uint32_t diffCorr : 1;
-      uint32_t carrSolnValid : 1;
-      uint32_t mapMatching : 1;
-
-      uint32_t psmState : 1;
-      uint32_t spoofDetState : 1;
-      uint32_t carrSoln : 1;
-
-      uint32_t ttff : 1;
-      uint32_t msss : 1;
-    } bits;
-  } moduleQueried;
-} UBX_NAV_STATUS_moduleQueried_t;
-
-typedef struct
-{
-	ubxAutomaticFlags automaticFlags;
-  UBX_NAV_STATUS_data_t data;
-  UBX_NAV_STATUS_moduleQueried_t moduleQueried;
-  void (*callbackPointer)(UBX_NAV_STATUS_data_t);
-  UBX_NAV_STATUS_data_t  *callbackData;
-} UBX_NAV_STATUS_t;
-
-// UBX-NAV-DOP (0x01 0x04): Dilution of precision
-const uint16_t UBX_NAV_DOP_LEN = 18;
-
-typedef struct
-{
-  uint32_t iTOW; // GPS time of week of the navigation epoch: ms
-  uint16_t gDOP; // Geometric DOP: * 0.01
-  uint16_t pDOP; // Position DOP: * 0.01
-  uint16_t tDOP; // Time DOP: * 0.01
-  uint16_t vDOP; // Vertical DOP: * 0.01
-  uint16_t hDOP; // Horizontal DOP: * 0.01
-  uint16_t nDOP; // Northing DOP: * 0.01
-  uint16_t eDOP; // Easting DOP: * 0.01
-} UBX_NAV_DOP_data_t;
-
-typedef struct
-{
-  union
-  {
-    uint32_t all;
-    struct
-    {
-      uint32_t all : 1;
-
-      uint32_t iTOW : 1;
-      uint32_t gDOP : 1;
-      uint32_t pDOP : 1;
-      uint32_t tDOP : 1;
-      uint32_t vDOP : 1;
-      uint32_t hDOP : 1;
-      uint32_t nDOP : 1;
-      uint32_t eDOP : 1;
-    } bits;
-  } moduleQueried;
-} UBX_NAV_DOP_moduleQueried_t;
-
-typedef struct
-{
-  ubxAutomaticFlags automaticFlags;
-  UBX_NAV_DOP_data_t data;
-  UBX_NAV_DOP_moduleQueried_t moduleQueried;
-  void (*callbackPointer)(UBX_NAV_DOP_data_t);
-  UBX_NAV_DOP_data_t  *callbackData;
-} UBX_NAV_DOP_t;
-
-// UBX-NAV-ATT (0x01 0x05): Attitude solution
-const uint16_t UBX_NAV_ATT_LEN = 32;
-
-typedef struct
-{
-  uint32_t iTOW; // GPS time of week of the navigation epoch: ms
-  uint8_t version; // Message version (0x00 for this version)
-  uint8_t reserved1[3];
-  int32_t roll; // Vehicle roll: Degrees * 1e-5
-  int32_t pitch; // Vehicle pitch: Degrees * 1e-5
-  int32_t heading; // Vehicle heading: Degrees * 1e-5
-  uint32_t accRoll; // Vehicle roll accuracy (if null, roll angle is not available): Degrees * 1e-5
-  uint32_t accPitch; // Vehicle pitch accuracy (if null, roll angle is not available): Degrees * 1e-5
-  uint32_t accHeading; // Vehicle heading accuracy (if null, roll angle is not available): Degrees * 1e-5
-} UBX_NAV_ATT_data_t;
-
-typedef struct
-{
-  union
-  {
-    uint32_t all;
-    struct
-    {
-      uint32_t all : 1;
-
-      uint32_t iTOW : 1;
-      uint32_t version : 1;
-      uint32_t roll : 1;
-      uint32_t pitch : 1;
-      uint32_t heading : 1;
-      uint32_t accRoll : 1;
-      uint32_t accPitch : 1;
-      uint32_t accHeading : 1;
-    } bits;
-  } moduleQueried;
-} UBX_NAV_ATT_moduleQueried_t;
-
-typedef struct
-{
-  ubxAutomaticFlags automaticFlags;
-  UBX_NAV_ATT_data_t data;
-  UBX_NAV_ATT_moduleQueried_t moduleQueried;
-  void (*callbackPointer)(UBX_NAV_ATT_data_t);
-  UBX_NAV_ATT_data_t  *callbackData;
-} UBX_NAV_ATT_t;
-
-// UBX-NAV-PVT (0x01 0x07): Navigation position velocity time solution
-const uint16_t UBX_NAV_PVT_LEN = 92;
-
-typedef struct
-{
-  uint32_t iTOW; // GPS time of week of the navigation epoch: ms
-  uint16_t year; // Year (UTC)
-  uint8_t month; // Month, range 1..12 (UTC)
-  uint8_t day; // Day of month, range 1..31 (UTC)
-  uint8_t hour; // Hour of day, range 0..23 (UTC)
-  uint8_t min; // Minute of hour, range 0..59 (UTC)
-  uint8_t sec; // Seconds of minute, range 0..60 (UTC)
-  union
-  {
-    uint8_t all;
-    struct
-    {
-      uint8_t validDate : 1; // 1 = valid UTC Date
-      uint8_t validTime : 1; // 1 = valid UTC time of day
-      uint8_t fullyResolved : 1; // 1 = UTC time of day has been fully resolved (no seconds uncertainty).
-      uint8_t validMag : 1; // 1 = valid magnetic declination
-    } bits;
-  } valid;
-  uint32_t tAcc; // Time accuracy estimate (UTC): ns
-  int32_t nano; // Fraction of second, range -1e9 .. 1e9 (UTC): ns
-  uint8_t fixType; // GNSSfix Type:
-                      // 0: no fix
-                      // 1: dead reckoning only
-                      // 2: 2D-fix
-                      // 3: 3D-fix
-                      // 4: GNSS + dead reckoning combined
-                      // 5: time only fix
-  union
-  {
-    uint8_t all;
-    struct
-    {
-      uint8_t gnssFixOK : 1; // 1 = valid fix (i.e within DOP & accuracy masks)
-      uint8_t diffSoln : 1; // 1 = differential corrections were applied
-      uint8_t psmState : 3;
-      uint8_t headVehValid : 1; // 1 = heading of vehicle is valid, only set if the receiver is in sensor fusion mode
-      uint8_t carrSoln : 2; // Carrier phase range solution status:
-                              // 0: no carrier phase range solution
-                              // 1: carrier phase range solution with floating ambiguities
-                              // 2: carrier phase range solution with fixed ambiguities
-    } bits;
-  } flags;
-  union
-  {
-    uint8_t all;
-    struct
-    {
-      uint8_t reserved : 5;
-      uint8_t confirmedAvai : 1; // 1 = information about UTC Date and Time of Day validity confirmation is available
-      uint8_t confirmedDate : 1; // 1 = UTC Date validity could be confirmed
-      uint8_t confirmedTime : 1; // 1 = UTC Time of Day could be confirmed
-    } bits;
-  } flags2;
-  uint8_t numSV; // Number of satellites used in Nav Solution
-  int32_t lon; // Longitude: deg * 1e-7
-  int32_t lat; // Latitude: deg * 1e-7
-  int32_t height; // Height above ellipsoid: mm
-  int32_t hMSL; // Height above mean sea level: mm
-  uint32_t hAcc; // Horizontal accuracy estimate: mm
-  uint32_t vAcc; // Vertical accuracy estimate: mm
-  int32_t velN; // NED north velocity: mm/s
-  int32_t velE; // NED east velocity: mm/s
-  int32_t velD; // NED down velocity: mm/s
-  int32_t gSpeed; // Ground Speed (2-D): mm/s
-  int32_t headMot; // Heading of motion (2-D): deg * 1e-5
-  uint32_t sAcc; // Speed accuracy estimate: mm/s
-  uint32_t headAcc; // Heading accuracy estimate (both motion and vehicle): deg * 1e-5
-  uint16_t pDOP; // Position DOP * 0.01
-  union
-  {
-    uint8_t all;
-    struct
-    {
-      uint8_t invalidLlh : 1; // 1 = Invalid lon, lat, height and hMSL
-    } bits;
-  } flags3;
-  uint8_t reserved1[5];
-  int32_t headVeh; // Heading of vehicle (2-D): deg * 1e-5
-  int16_t magDec; // Magnetic declination: deg * 1e-2
-  uint16_t magAcc; // Magnetic declination accuracy: deg * 1e-2
-} UBX_NAV_PVT_data_t;
-
-typedef struct
-{
-  union
-  {
-    uint32_t all;
-    struct
-    {
-      uint32_t all : 1;
-
-      uint32_t iTOW : 1;
-      uint32_t year : 1;
-      uint32_t month : 1;
-      uint32_t day : 1;
-      uint32_t hour : 1;
-      uint32_t min : 1;
-      uint32_t sec : 1;
-
-      uint32_t validDate : 1;
-      uint32_t validTime : 1;
-      uint32_t fullyResolved : 1;
-      uint32_t validMag : 1;
-
-      uint32_t tAcc : 1;
-      uint32_t nano : 1;
-      uint32_t fixType : 1;
-      uint32_t gnssFixOK : 1;
-      uint32_t diffSoln : 1;
-      uint32_t psmState : 1;
-      uint32_t headVehValid : 1;
-      uint32_t carrSoln : 1;
-
-      uint32_t confirmedAvai : 1;
-      uint32_t confirmedDate : 1;
-      uint32_t confirmedTime : 1;
-
-      uint32_t numSV : 1;
-      uint32_t lon : 1;
-      uint32_t lat : 1;
-      uint32_t height : 1;
-      uint32_t hMSL : 1;
-      uint32_t hAcc : 1;
-      uint32_t vAcc : 1;
-      uint32_t velN : 1;
-      uint32_t velE : 1;
-    } bits;
-  }  moduleQueried1;
-  union
-  {
-    uint32_t all;
-    struct
-    {
-      uint32_t velD : 1;
-      uint32_t gSpeed : 1;
-      uint32_t headMot : 1;
-      uint32_t sAcc : 1;
-      uint32_t headAcc : 1;
-      uint32_t pDOP : 1;
-
-      uint32_t invalidLlh : 1;
-
-      uint32_t headVeh : 1;
-      uint32_t magDec : 1;
-      uint32_t magAcc : 1;
-    } bits;
-  } moduleQueried2;
-} UBX_NAV_PVT_moduleQueried_t;
-
-typedef struct
-{
-	ubxAutomaticFlags automaticFlags;
-  UBX_NAV_PVT_data_t data;
-  UBX_NAV_PVT_moduleQueried_t moduleQueried;
-  void (*callbackPointer)(UBX_NAV_PVT_data_t);
-  UBX_NAV_PVT_data_t  *callbackData;
-} UBX_NAV_PVT_t;
-
-// UBX-NAV-ODO (0x01 0x09): Odometer solution
-const uint16_t UBX_NAV_ODO_LEN = 20;
-
-typedef struct
-{
-  uint8_t version; // Message version (0x00 for this version)
-  uint8_t reserved1[3];
-  uint32_t iTOW; // GPS time of week of the navigation epoch: ms
-  uint32_t distance; // Ground distance since last reset: m
-  uint32_t totalDistance; // Total cumulative ground distance: m
-  uint32_t distanceStd; // Ground distance accuracy (1-sigma): m
-} UBX_NAV_ODO_data_t;
-
-typedef struct
-{
-  union
-  {
-    uint32_t all;
-    struct
-    {
-      uint32_t all : 1;
-
-      uint32_t version : 1;
-      uint32_t iTOW : 1;
-      uint32_t distance : 1;
-      uint32_t totalDistance : 1;
-      uint32_t distanceStd : 1;
-    } bits;
-  } moduleQueried;
-} UBX_NAV_ODO_moduleQueried_t;
-
-typedef struct
-{
-	ubxAutomaticFlags automaticFlags;
-  UBX_NAV_ODO_data_t data;
-  UBX_NAV_ODO_moduleQueried_t moduleQueried;
-  void (*callbackPointer)(UBX_NAV_ODO_data_t);
-  UBX_NAV_ODO_data_t  *callbackData;
-} UBX_NAV_ODO_t;
-
-// UBX-NAV-VELECEF (0x01 0x11): Velocity solution in ECEF
-const uint16_t UBX_NAV_VELECEF_LEN = 20;
-
-typedef struct
-{
-  uint32_t iTOW; // GPS time of week of the navigation epoch: ms
-  int32_t ecefVX; // ECEF X velocity: cm/s
-  int32_t ecefVY; // ECEF Y velocity: cm/s
-  int32_t ecefVZ; // ECEF Z velocity: cm/s
-  uint32_t sAcc; // Speed accuracy estimate: cm/s
-} UBX_NAV_VELECEF_data_t;
-
-typedef struct
-{
-  union
-  {
-    uint32_t all;
-    struct
-    {
-      uint32_t all : 1;
-
-      uint32_t iTOW : 1;
-      uint32_t ecefVX : 1;
-      uint32_t ecefVY : 1;
-      uint32_t ecefVZ : 1;
-      uint32_t sAcc : 1;
-    } bits;
-  } moduleQueried;
-} UBX_NAV_VELECEF_moduleQueried_t;
-
-typedef struct
-{
-	ubxAutomaticFlags automaticFlags;
-  UBX_NAV_VELECEF_data_t data;
-  UBX_NAV_VELECEF_moduleQueried_t moduleQueried;
-  void (*callbackPointer)(UBX_NAV_VELECEF_data_t);
-  UBX_NAV_VELECEF_data_t  *callbackData;
-} UBX_NAV_VELECEF_t;
-
-// UBX-NAV-VELNED (0x01 0x12): Velocity solution in NED frame
-const uint16_t UBX_NAV_VELNED_LEN = 36;
-
-typedef struct
-{
-  uint32_t iTOW; // GPS time of week of the navigation epoch: ms
-  int32_t velN; // North velocity component: cm/s
-  int32_t velE; // East velocity component: cm/s
-  int32_t velD; // Down velocity component: cm/s
-  uint32_t speed; // Speed (3-D): cm/s
-  uint32_t gSpeed; // Ground Speed (2-D): cm/s
-  int32_t heading; // Heading of motion 2-D: Degrees * 1e-5
-  uint32_t sAcc; // Speed accuracy estimate: cm/s
-  uint32_t cAcc; // Course/Heading accuracy estimate: Degrees * 1e-5
-} UBX_NAV_VELNED_data_t;
-
-typedef struct
-{
-  union
-  {
-    uint32_t all;
-    struct
-    {
-      uint32_t all : 1;
-
-      uint32_t iTOW : 1;
-      uint32_t velN : 1;
-      uint32_t velE : 1;
-      uint32_t velD : 1;
-      uint32_t speed : 1;
-      uint32_t gSpeed : 1;
-      uint32_t heading : 1;
-      uint32_t sAcc : 1;
-      uint32_t cAcc : 1;
-    } bits;
-  } moduleQueried;
-} UBX_NAV_VELNED_moduleQueried_t;
-
-typedef struct
-{
-	ubxAutomaticFlags automaticFlags;
-  UBX_NAV_VELNED_data_t data;
-  UBX_NAV_VELNED_moduleQueried_t moduleQueried;
-  void (*callbackPointer)(UBX_NAV_VELNED_data_t);
-  UBX_NAV_VELNED_data_t  *callbackData;
-} UBX_NAV_VELNED_t;
-
-// UBX-NAV-HPPOSECEF (0x01 0x13): High precision position solution in ECEF
-const uint16_t UBX_NAV_HPPOSECEF_LEN = 28;
-
-typedef struct
-{
-  uint8_t version; // Message version (0x00 for this version)
-  uint8_t reserved1[3];
-  uint32_t iTOW; // GPS time of week of the navigation epoch: ms
-  int32_t ecefX; // ECEF X coordinate: cm
-  int32_t ecefY; // ECEF Y coordinate: cm
-  int32_t ecefZ; // ECEF Z coordinate: cm
-  int8_t ecefXHp; // High precision component of ECEF X coordinate: mm * 0.1
-  int8_t ecefYHp; // High precision component of ECEF Y coordinate: mm * 0.1
-  int8_t ecefZHp; // High precision component of ECEF Z coordinate: mm * 0.1
-  union
-  {
-    uint8_t all;
-    struct
-    {
-      uint8_t invalidEcef : 1; // 1 = Invalid ecefX, ecefY, ecefZ, ecefXHp, ecefYHp and ecefZHp
-    } bits;
-  } flags;
-  uint32_t pAcc; // Position Accuracy Estimate: mm * 0.1
-} UBX_NAV_HPPOSECEF_data_t;
-
-typedef struct
-{
-  union
-  {
-    uint32_t all;
-    struct
-    {
-      uint32_t all : 1;
-
-      uint32_t version : 1;
-      uint32_t iTOW : 1;
-      uint32_t ecefX : 1;
-      uint32_t ecefY : 1;
-      uint32_t ecefZ : 1;
-      uint32_t ecefXHp : 1;
-      uint32_t ecefYHp : 1;
-      uint32_t ecefZHp : 1;
-
-      uint32_t invalidEcef : 1;
-
-      uint32_t pAcc : 1;
-    } bits;
-  } moduleQueried;
-} UBX_NAV_HPPOSECEF_moduleQueried_t;
-
-typedef struct
-{
-	ubxAutomaticFlags automaticFlags;
-  UBX_NAV_HPPOSECEF_data_t data;
-  UBX_NAV_HPPOSECEF_moduleQueried_t moduleQueried;
-  void (*callbackPointer)(UBX_NAV_HPPOSECEF_data_t);
-  UBX_NAV_HPPOSECEF_data_t  *callbackData;
-} UBX_NAV_HPPOSECEF_t;
-
-// UBX-NAV-HPPOSLLH (0x01 0x14): High precision geodetic position solution
-const uint16_t UBX_NAV_HPPOSLLH_LEN = 36;
-
-typedef struct
-{
-  uint8_t version; // Message version (0x00 for this version)
-  uint8_t reserved1[2];
-  union
-  {
-    uint8_t all;
-    struct
-    {
-      uint8_t invalidLlh : 1; // 1 = Invalid lon, lat, height, hMSL, lonHp, latHp, heightHp and hMSLHp
-    } bits;
-  } flags;
-  uint32_t iTOW; // GPS time of week of the navigation epoch: ms
-  int32_t lon; // Longitude: deg * 1e-7
-  int32_t lat; // Latitude: deg * 1e-7
-  int32_t height; // Height above ellipsoid: mm
-  int32_t hMSL; // Height above mean sea level: mm
-  int8_t lonHp; // High precision component of longitude: deg * 1e-9
-  int8_t latHp; // High precision component of latitude: deg * 1e-9
-  int8_t heightHp; // High precision component of height above ellipsoid: mm * 0.1
-  int8_t hMSLHp; // High precision component of height above mean sea level: mm * 0.1
-  uint32_t hAcc; // Horizontal accuracy estimate: mm * 0.1
-  uint32_t vAcc; // Vertical accuracy estimate: mm * 0.1
-} UBX_NAV_HPPOSLLH_data_t;
-
-typedef struct
-{
-  union
-  {
-    uint32_t all;
-    struct
-    {
-      uint32_t all : 1;
-
-      uint32_t version : 1;
-
-      uint32_t invalidLlh : 1;
-
-      uint32_t iTOW : 1;
-      uint32_t lon : 1;
-      uint32_t lat : 1;
-      uint32_t height : 1;
-      uint32_t hMSL : 1;
-      uint32_t lonHp : 1;
-      uint32_t latHp : 1;
-      uint32_t heightHp : 1;
-      uint32_t hMSLHp : 1;
-      uint32_t hAcc : 1;
-      uint32_t vAcc : 1;
-    } bits;
-  } moduleQueried;
-} UBX_NAV_HPPOSLLH_moduleQueried_t;
-
-typedef struct
-{
-	ubxAutomaticFlags automaticFlags;
-  UBX_NAV_HPPOSLLH_data_t data;
-  UBX_NAV_HPPOSLLH_moduleQueried_t moduleQueried;
-  void (*callbackPointer)(UBX_NAV_HPPOSLLH_data_t);
-  UBX_NAV_HPPOSLLH_data_t  *callbackData;
-} UBX_NAV_HPPOSLLH_t;
-
-// UBX-NAV-TIMEUTC (0x01 0x21): UTC time solution
-const uint16_t UBX_NAV_TIMEUTC_LEN = 20;
-
-typedef struct
-{
-  uint32_t iTOW; // GPS time of week of the navigation epoch: ms
-  uint32_t tAcc; // Time accuracy estimate (UTC): ns
-  int32_t nano; // Fraction of second, range -1e9 .. 1e9 (UTC): ns
-  uint16_t year; // Year (UTC)
-  uint8_t month; // Month, range 1..12 (UTC)
-  uint8_t day; // Day of month, range 1..31 (UTC)
-  uint8_t hour; // Hour of day, range 0..23 (UTC)
-  uint8_t min; // Minute of hour, range 0..59 (UTC)
-  uint8_t sec; // Seconds of minute, range 0..60 (UTC)
-  union
-  {
-    uint8_t all;
-    struct
-    {
-      uint8_t validTOW : 1; // 1 = Valid Time of Week
-      uint8_t validWKN : 1; // 1 = Valid Week Number
-      uint8_t validUTC : 1; // 1 = Valid UTC Time
-      uint8_t reserved : 1;
-      uint8_t utcStandard : 4; // UTC standard identifier
-    } bits;
-  } valid;
-} UBX_NAV_TIMEUTC_data_t;
-
-typedef struct
-{
-  union
-  {
-    uint32_t all;
-    struct
-    {
-      uint32_t all : 1;
-
-      uint32_t iTOW : 1;
-      uint32_t tAcc : 1;
-      uint32_t nano : 1;
-      uint32_t year : 1;
-      uint32_t month : 1;
-      uint32_t day : 1;
-      uint32_t hour : 1;
-      uint32_t min : 1;
-      uint32_t sec : 1;
-
-      uint32_t validTOW : 1;
-      uint32_t validWKN : 1;
-      uint32_t validUTC : 1;
-      uint32_t utcStandard : 1;
-    } bits;
-  }  moduleQueried;
-} UBX_NAV_TIMEUTC_moduleQueried_t;
-
-typedef struct
-{
-	ubxAutomaticFlags automaticFlags;
-  UBX_NAV_TIMEUTC_data_t data;
-  UBX_NAV_TIMEUTC_moduleQueried_t moduleQueried;
-  void (*callbackPointer)(UBX_NAV_TIMEUTC_data_t);
-  UBX_NAV_TIMEUTC_data_t  *callbackData;
-} UBX_NAV_TIMEUTC_t;
-
-// UBX-NAV-CLOCK (0x01 0x22): Clock solution
-const uint16_t UBX_NAV_CLOCK_LEN = 20;
-
-typedef struct
-{
-  uint32_t iTOW; // GPS time of week of the navigation epoch: ms
-  int32_t clkB; // Clock bias: ns
-  int32_t clkD; // Clock drift: ns/s
-  uint32_t tAcc; // Time accuracy estimate: ns
-  uint32_t fAcc; // Frequency accuracy estimate: ps/s
-} UBX_NAV_CLOCK_data_t;
-
-typedef struct
-{
-  union
-  {
-    uint32_t all;
-    struct
-    {
-      uint32_t all : 1;
-
-      uint32_t iTOW : 1;
-      uint32_t clkB : 1;
-      uint32_t clkD : 1;
-      uint32_t tAcc : 1;
-      uint32_t fAcc : 1;
-    } bits;
-  } moduleQueried;
-} UBX_NAV_CLOCK_moduleQueried_t;
-
-typedef struct
-{
-	ubxAutomaticFlags automaticFlags;
-  UBX_NAV_CLOCK_data_t data;
-  UBX_NAV_CLOCK_moduleQueried_t moduleQueried;
-  void (*callbackPointer)(UBX_NAV_CLOCK_data_t);
-  UBX_NAV_CLOCK_data_t  *callbackData;
-} UBX_NAV_CLOCK_t;
-
-// UBX-NAV-SVIN (0x01 0x3B): Survey-in data
-const uint16_t UBX_NAV_SVIN_LEN = 40;
-
-typedef struct
-{
-  uint8_t version; // Message version (0x00 for this version)
-  uint8_t reserved1[3];
-  uint32_t iTOW; // GPS time of week of the navigation epoch: ms
-  uint32_t dur; // Passed survey-in observation time: s
-  int32_t meanX; // Current survey-in mean position ECEF X coordinate: cm
-  int32_t meanY; // Current survey-in mean position ECEF Y coordinate: cm
-  int32_t meanZ; // Current survey-in mean position ECEF Z coordinate: cm
-  int8_t meanXHP; // Current high-precision survey-in mean position ECEF X coordinate: mm * 0.1
-  int8_t meanYHP; // Current high-precision survey-in mean position ECEF Y coordinate: mm * 0.1
-  int8_t meanZHP; // Current high-precision survey-in mean position ECEF Z coordinate: mm * 0.1
-  uint8_t reserved2;
-  uint32_t meanAcc; // Current survey-in mean position accuracy: mm * 0.1
-  uint32_t obs; // Number of position observations used during survey-in
-  int8_t valid; // Survey-in position validity flag, 1 = valid, otherwise 0
-  int8_t active; // Survey-in in progress flag, 1 = in-progress, otherwise 0
-  uint8_t reserved3[2];
-} UBX_NAV_SVIN_data_t;
-
-typedef struct
-{
-  union
-  {
-    uint32_t all;
-    struct
-    {
-      uint32_t all : 1;
-
-      uint32_t version : 1;
-      uint32_t iTOW : 1;
-      uint32_t dur : 1;
-      uint32_t meanX : 1;
-      uint32_t meanY : 1;
-      uint32_t meanZ : 1;
-      uint32_t meanXHP : 1;
-      uint32_t meanYHP : 1;
-      uint32_t meanZHP : 1;
-      uint32_t meanAcc : 1;
-      uint32_t obs : 1;
-      uint32_t valid : 1;
-      uint32_t active : 1;
-    } bits;
-  } moduleQueried;
-} UBX_NAV_SVIN_moduleQueried_t;
-
-typedef struct
-{
-	ubxAutomaticFlags automaticFlags;
-  UBX_NAV_SVIN_data_t data;
-  UBX_NAV_SVIN_moduleQueried_t moduleQueried;
-  void (*callbackPointer)(UBX_NAV_SVIN_data_t);
-  UBX_NAV_SVIN_data_t  *callbackData;
-} UBX_NAV_SVIN_t;
-
-// UBX-NAV-RELPOSNED (0x01 0x3C): Relative positioning information in NED frame
-// Note:
-//  RELPOSNED on the M8 is only 40 bytes long
-//  RELPOSNED on the F9 is 64 bytes long and contains much more information
-const uint16_t UBX_NAV_RELPOSNED_LEN = 40;
-const uint16_t UBX_NAV_RELPOSNED_LEN_F9 = 64;
-
-typedef struct
-{
-  uint8_t version; // Message version (0x00 for this version)
-  uint8_t reserved0;
-  uint16_t refStationId; // Reference Station ID
-  uint32_t iTOW; // GPS time of week of the navigation epoch: ms
-  int32_t relPosN; // North component of relative position vector: cm
-  int32_t relPosE; // East component of relative position vector: cm
-  int32_t relPosD; // Down component of relative position vector: cm
-  int32_t relPosLength; // Length of the relative position vector: cm
-  int32_t relPosHeading; // Heading of the relative position vector: Degrees * 1e-5
-  uint8_t reserved1[4];
-  int8_t relPosHPN; // High-precision North component of relative position vector: mm * 0.1
-  int8_t relPosHPE; // High-precision East component of relative position vector: mm * 0.1
-  int8_t relPosHPD; // High-precision Down component of relative position vector: mm * 0.1
-  int8_t relPosHPLength; // High-precision component of the length of the relative position vector: mm * 0.1
-  uint32_t accN; // Accuracy of relative position North component: mm * 0.1
-  uint32_t accE; // Accuracy of relative position East component: mm * 0.1
-  uint32_t accD; // Accuracy of relative position Down component: mm * 0.1
-  uint32_t accLength; // Accuracy of length of the relative position vector: mm * 0.1
-  uint32_t accHeading; // Accuracy of heading of the relative position vector: Degrees * 1e-5
-  uint8_t reserved2[4];
-  union
-  {
-    uint32_t all;
-    struct
-    {
-      uint32_t gnssFixOK : 1; // A valid fix (i.e within DOP & accuracy masks)
-      uint32_t diffSoln : 1; // 1 if differential corrections were applied
-      uint32_t relPosValid : 1; // 1 if relative position components and accuracies are valid
-      uint32_t carrSoln : 2; // Carrier phase range solution status:
-                              // 0 = no carrier phase range solution
-                              // 1 = carrier phase range solution with floating ambiguities
-                              // 2 = carrier phase range solution with fixed ambiguities
-      uint32_t isMoving : 1; // 1 if the receiver is operating in moving baseline mode
-      uint32_t refPosMiss : 1; // 1 if extrapolated reference position was used to compute moving baseline solution this epoch
-      uint32_t refObsMiss : 1; // 1 if extrapolated reference observations were used to compute moving baseline solution this epoch
-      uint32_t relPosHeadingValid : 1; // 1 if relPosHeading is valid
-      uint32_t relPosNormalized : 1; // 1 if the components of the relative position vector (including the high-precision parts) are normalized
-    } bits;
-  } flags;
-} UBX_NAV_RELPOSNED_data_t;
-
-typedef struct
-{
-  union
-  {
-    uint32_t all;
-    struct
-    {
-      uint32_t all : 1;
-
-      uint32_t version : 1;
-      uint32_t refStationId : 1;
-      uint32_t iTOW : 1;
-      uint32_t relPosN : 1;
-      uint32_t relPosE : 1;
-      uint32_t relPosD : 1;
-      uint32_t relPosLength : 1;
-      uint32_t relPosHeading : 1;
-      uint32_t relPosHPN : 1;
-      uint32_t relPosHPE : 1;
-      uint32_t relPosHPD : 1;
-      uint32_t relPosHPLength : 1;
-      uint32_t accN : 1;
-      uint32_t accE : 1;
-      uint32_t accD : 1;
-      uint32_t accLength : 1;
-      uint32_t accHeading : 1;
-
-      uint32_t gnssFixOK : 1;
-      uint32_t diffSoln : 1;
-      uint32_t relPosValid : 1;
-      uint32_t carrSoln : 1;
-      uint32_t isMoving : 1;
-      uint32_t refPosMiss : 1;
-      uint32_t refObsMiss : 1;
-      uint32_t relPosHeadingValid : 1;
-      uint32_t relPosNormalized : 1;
-    } bits;
-  } moduleQueried;
-} UBX_NAV_RELPOSNED_moduleQueried_t;
-
-typedef struct
-{
-	ubxAutomaticFlags automaticFlags;
-  UBX_NAV_RELPOSNED_data_t data;
-  UBX_NAV_RELPOSNED_moduleQueried_t moduleQueried;
-  void (*callbackPointer)(UBX_NAV_RELPOSNED_data_t);
-  UBX_NAV_RELPOSNED_data_t  *callbackData;
-} UBX_NAV_RELPOSNED_t;
-
-// RXM-specific structs
-
-// UBX-RXM-SFRBX (0x02 0x13): Broadcast navigation data subframe
-// Note: length is variable
-// Note: on protocol version 17: numWords is (0..16)
-//       on protocol version 18+: numWords is (0..10)
-const uint8_t UBX_RXM_SFRBX_MAX_WORDS = 16;
-const uint16_t UBX_RXM_SFRBX_MAX_LEN = 8 + (4 * UBX_RXM_SFRBX_MAX_WORDS);
-
-typedef struct
-{
-  uint8_t gnssId; // GNSS identifier
-  uint8_t svId; // Satellite identifier
-  uint8_t reserved1;
-  uint8_t freqId; // GLONASS frequency slot
-  uint8_t numWords; // The number of data words contained in this message (0..16)
-  uint8_t chn; // The tracking channel number the message was received on
-  uint8_t version; // Message version (0x01 for this version)
-  uint8_t reserved2;
-  uint32_t dwrd[UBX_RXM_SFRBX_MAX_WORDS]; // The data words
-} UBX_RXM_SFRBX_data_t;
-
-typedef struct
-{
-	ubxAutomaticFlags automaticFlags;
-  UBX_RXM_SFRBX_data_t data;
-  boolean moduleQueried;
-  void (*callbackPointer)(UBX_RXM_SFRBX_data_t);
-  UBX_RXM_SFRBX_data_t  *callbackData;
-} UBX_RXM_SFRBX_t;
-
-// UBX-RXM-RAWX (0x02 0x15): Multi-GNSS raw measurement data
-// Note: length is variable
-const uint8_t UBX_RXM_RAWX_MAX_BLOCKS = 64; // GUESS! TO DO: find the correct value for this
-const uint16_t UBX_RXM_RAWX_MAX_LEN = 16 + (32 * UBX_RXM_RAWX_MAX_BLOCKS);
-
-typedef struct
-{
-  uint8_t rcvTow[8]; // Measurement time of week in receiver local time [64-bit float]
-  uint16_t week; // GPS week number
-  int8_t leapS; // GPS leap seconds
-  uint8_t numMeas; // Number of measurements to follow
-  union
-  {
-    uint8_t all;
-    struct
-    {
-      uint8_t leapSec : 1; // Leap seconds have been determined
-      uint8_t clkReset : 1; // Clock reset applied
-    } bits;
-  } recStat;
-  uint8_t version; // Message version (0x01 for this version)
-  uint8_t reserved1[2];
-} UBX_RXM_RAWX_header_t;
-
-typedef struct
-{
-  uint8_t prMes[8]; // Pseudorange measurement: m [64-bit float]
-  uint8_t cpMes[8]; // Carrier phase measurement: cycles [64-bit float]
-  uint8_t doMes[4]; // Doppler measurement: Hz [32-bit float]
-  uint8_t gnssId; // GNSS identifier
-  uint8_t svId; // Satellite identifier
-  uint8_t sigId; // New signal identifier
-  uint8_t freqId; // GLONASS frequency slot
-  uint16_t lockTime; // Carrier phase locktime counter: ms
-  uint8_t cno; // Carrier-to-noise density ratio: dB-Hz
-  uint8_t prStdev; // Estimated pseudorange measurement standard deviation: m * 0.01 * 2^n [4-bit]
-  uint8_t cpStdev; // Estimated carrier phase measurement standard deviation: cycles * 0.004 [4-bit]
-  uint8_t doStdev; // Estimated Doppler measurement standard deviation: Hz * 0.002 * 2^n [4-bit]
-  union
-  {
-    uint8_t all;
-    struct
-    {
-      uint8_t prValid : 1; // Pseudorange valid
-      uint8_t cpValid : 1; // Carrier phase valid
-      uint8_t halfCyc : 1; // Half cycle valid
-      uint8_t subHalfCyc : 1; // Half cycle subtracted from phase
-    } bits;
-  } trkStat;
-  uint8_t reserved2;
-} UBX_RXM_RAWX_block_t;
-
-typedef struct
-{
-  UBX_RXM_RAWX_header_t header;
-  UBX_RXM_RAWX_block_t blocks[UBX_RXM_RAWX_MAX_BLOCKS];
-} UBX_RXM_RAWX_data_t;
-
-typedef struct
-{
-	ubxAutomaticFlags automaticFlags;
-  UBX_RXM_RAWX_data_t data;
-  boolean moduleQueried;
-  void (*callbackPointer)(UBX_RXM_RAWX_data_t);
-  UBX_RXM_RAWX_data_t  *callbackData;
-} UBX_RXM_RAWX_t;
-
-// CFG-specific structs
-
-// UBX-CFG-RATE (0x06 0x08): Navigation/measurement rate settings
-const uint16_t UBX_CFG_RATE_LEN = 6;
-
-typedef struct
-{
-  uint16_t measRate; // The elapsed time between GNSS measurements, which defines the rate: ms
-  uint16_t navRate; // The ratio between the number of measurements and the number of navigation solutions: cycles
-  uint16_t timeRef; // The time system to which measurements are aligned: 0: UTC; 1: GPS; 2: GLONASS; 3: BeiDou; 4: Galileo
-} UBX_CFG_RATE_data_t;
-
-typedef struct
-{
-  union
-  {
-    uint32_t all;
-    struct
-    {
-      uint32_t all : 1;
-
-      uint32_t measRate : 1;
-      uint32_t navRate : 1;
-      uint32_t timeRef : 1;
-    } bits;
-  } moduleQueried;
-} UBX_CFG_RATE_moduleQueried_t;
-
-typedef struct
-{
-	ubxAutomaticFlags automaticFlags;
-  UBX_CFG_RATE_data_t data;
-  UBX_CFG_RATE_moduleQueried_t moduleQueried;
-  void (*callbackPointer)(UBX_CFG_RATE_data_t);
-  UBX_CFG_RATE_data_t  *callbackData;
-} UBX_CFG_RATE_t;
-
-// TIM-specific structs
-
-// UBX-TIM-TM2 (0x0D 0x03): Time mark data
-const uint16_t UBX_TIM_TM2_LEN = 28;
-
-typedef struct
-{
-  uint8_t ch; // Channel (i.e. EXTINT) upon which the pulse was measured
-  union
-  {
-    uint8_t all;
-    struct
-    {
-      uint8_t mode : 1; // 0=single; 1=running
-      uint8_t run : 1; // 0=armed; 1=stopped
-      uint8_t newFallingEdge : 1; // New falling edge detected
-      uint8_t timeBase : 2; // 0=Time base is Receiver time; 1=Time base is GNSS time; 2=Time base is UTC
-      uint8_t utc : 1; // 0=UTC not available; 1=UTC available
-      uint8_t time : 1; // 0=Time is not valid; 1=Time is valid (Valid GNSS fix)
-      uint8_t newRisingEdge : 1; // New rising edge detected
-    } bits;
-  } flags;
-  uint16_t count; // Rising edge counter
-  uint16_t wnR; // Week number of last rising edge
-  uint16_t wnF; // Week number of last falling edge
-  uint32_t towMsR; // TOW of rising edge: ms
-  uint32_t towSubMsR; // Millisecond fraction of tow of rising edge: ns
-  uint32_t towMsF; // TOW of falling edge: ms
-  uint32_t towSubMsF; // Millisecond fraction of tow of falling edge: ns
-  uint32_t accEst; // Accuracy estimate: ns
-} UBX_TIM_TM2_data_t;
-
-typedef struct
-{
-  union
-  {
-    uint32_t all;
-    struct
-    {
-      uint32_t all : 1;
-
-      uint32_t ch : 1;
-      uint32_t mode : 1;
-      uint32_t run : 1;
-      uint32_t newFallingEdge : 1;
-      uint32_t timeBase : 1;
-      uint32_t utc : 1;
-      uint32_t time : 1;
-      uint32_t newRisingEdge : 1;
-
-      uint32_t count : 1;
-      uint32_t wnR : 1;
-      uint32_t wnF : 1;
-      uint32_t towMsR : 1;
-      uint32_t towSubMsR : 1;
-      uint32_t towMsF : 1;
-      uint32_t towSubMsF : 1;
-      uint32_t accEst : 1;
-    } bits;
-  } moduleQueried;
-} UBX_TIM_TM2_moduleQueried_t;
-
-typedef struct
-{
-	ubxAutomaticFlags automaticFlags;
-  UBX_TIM_TM2_data_t data;
-  UBX_TIM_TM2_moduleQueried_t moduleQueried;
-  void (*callbackPointer)(UBX_TIM_TM2_data_t);
-  UBX_TIM_TM2_data_t  *callbackData;
-} UBX_TIM_TM2_t;
-
-// ESF-specific structs
-
-// UBX-ESF-ALG (0x10 0x14): IMU alignment information
-const uint16_t UBX_ESF_ALG_LEN = 16;
-
-typedef struct
-{
-  uint32_t iTOW; // GPS time of week of the HNR epoch: ms
-  uint8_t version; // Message version (0x01 for this version)
-  union
-  {
-    uint8_t all;
-    struct
-    {
-      uint8_t autoMntAlgOn : 1; // Automatic IMU-mount alignment on/off bit
-      uint8_t status : 3; // Status of the IMU-mount alignment
-                          //   0: user-defined/fixed angles are used
-                          //   1: IMU-mount roll/pitch angles alignment is ongoing
-                          //   2: IMU-mount roll/pitch/yaw angles alignment is ongoing
-                          //   3: coarse IMU-mount alignment are used
-                          //   4: fine IMU-mount alignment are used
-    } bits;
-  } flags;
-  union
-  {
-    uint8_t all;
-    struct
-    {
-      uint8_t tiltAlgError : 1; // IMU-mount tilt (roll and/or pitch) alignment error (0: no error, 1: error)
-      uint8_t yawAlgError : 1; // IMU-mount yaw alignment error (0: no error, 1: error)
-      uint8_t angleError : 1; // IMU-mount misalignment Euler angle singularity error (0: no error, 1: error)
-    } bits;
-  } error;
-  uint8_t reserved1;
-  uint32_t yaw; // IMU-mount yaw angle [0, 360]: Degrees * 1e-2
-  int16_t pitch; // IMU-mount pitch angle [-90, 90]: Degrees * 1e-2
-  int16_t roll; // IMU-mount roll angle [-180, 180]: Degrees * 1e-2
-} UBX_ESF_ALG_data_t;
-
-typedef struct
-{
-  union
-  {
-    uint32_t all;
-    struct
-    {
-      uint32_t all : 1;
-
-      uint32_t iTOW : 1;
-      uint32_t version : 1;
-
-      uint32_t autoMntAlgOn : 1;
-      uint32_t status : 1;
-
-      uint32_t tiltAlgError : 1;
-      uint32_t yawAlgError : 1;
-      uint32_t angleError : 1;
-
-      uint32_t yaw : 1;
-      uint32_t pitch : 1;
-      uint32_t roll : 1;
-    } bits;
-  } moduleQueried;
-} UBX_ESF_ALG_moduleQueried_t;
-
-typedef struct
-{
-	ubxAutomaticFlags automaticFlags;
-  UBX_ESF_ALG_data_t data;
-  UBX_ESF_ALG_moduleQueried_t moduleQueried;
-  void (*callbackPointer)(UBX_ESF_ALG_data_t);
-  UBX_ESF_ALG_data_t  *callbackData;
-} UBX_ESF_ALG_t;
-
-// UBX-ESF-INS (0x10 0x15): Vehicle dynamics information
-const uint16_t UBX_ESF_INS_LEN = 36;
-
-typedef struct
-{
-  union
-  {
-    uint32_t all;
-    struct
-    {
-      uint32_t version : 8; // Message version (0x01 for this version)
-      uint32_t xAngRateValid : 1; // Compensated x-axis angular rate data validity flag (0: not valid, 1: valid)
-      uint32_t yAngRateValid : 1; // Compensated y-axis angular rate data validity flag (0: not valid, 1: valid)
-      uint32_t zAngRateValid : 1; // Compensated z-axis angular rate data validity flag (0: not valid, 1: valid)
-      uint32_t xAccelValid : 1; // Compensated x-axis acceleration data validity flag (0: not valid, 1: valid)
-      uint32_t yAccelValid : 1; // Compensated y-axis acceleration data validity flag (0: not valid, 1: valid)
-      uint32_t zAccelValid : 1; // Compensated z-axis acceleration data validity flag (0: not valid, 1: valid)
-    } bits;
-  } bitfield0;
-  uint8_t reserved1[4];
-  uint32_t iTOW; // GPS time of week of the HNR epoch: ms
-  int32_t xAngRate; // Compensated x-axis angular rate: Degrees/s * 1e-3
-  int32_t yAngRate; // Compensated y-axis angular rate: Degrees/s * 1e-3
-  int32_t zAngRate; // Compensated z-axis angular rate: Degrees/s * 1e-3
-  int32_t xAccel; // Compensated x-axis acceleration (gravity-free): m/s^2 * 1e-2
-  int32_t yAccel; // Compensated y-axis acceleration (gravity-free): m/s^2 * 1e-2
-  int32_t zAccel; // Compensated z-axis acceleration (gravity-free): m/s^2 * 1e-2
-} UBX_ESF_INS_data_t;
-
-typedef struct
-{
-  union
-  {
-    uint32_t all;
-    struct
-    {
-      uint32_t all : 1;
-
-      uint32_t version : 1;
-      uint32_t xAngRateValid : 1;
-      uint32_t yAngRateValid : 1;
-      uint32_t zAngRateValid : 1;
-      uint32_t xAccelValid : 1;
-      uint32_t yAccelValid : 1;
-      uint32_t zAccelValid : 1;
-
-      uint32_t iTOW : 1;
-      uint32_t xAngRate : 1;
-      uint32_t yAngRate : 1;
-      uint32_t zAngRate : 1;
-      uint32_t xAccel : 1;
-      uint32_t yAccel : 1;
-      uint32_t zAccel : 1;
-    } bits;
-  } moduleQueried;
-} UBX_ESF_INS_moduleQueried_t;
-
-typedef struct
-{
-	ubxAutomaticFlags automaticFlags;
-  UBX_ESF_INS_data_t data;
-  UBX_ESF_INS_moduleQueried_t moduleQueried;
-  void (*callbackPointer)(UBX_ESF_INS_data_t);
-  UBX_ESF_INS_data_t  *callbackData;
-} UBX_ESF_INS_t;
-
-// UBX-ESF-MEAS (0x10 0x02): External sensor fusion measurements
-// Note: length is variable
-const uint16_t UBX_ESF_MEAS_MAX_LEN = 8 + (4 * DEF_NUM_SENS) + 4;
-
-typedef struct
-{
-  union
-  {
-    uint32_t all;
-    struct
-    {
-      uint32_t dataField : 24; // Data
-      uint32_t dataType : 6; // Type of data (0 = no data; 1..63 = data type)
-    } bits;
-  } data;
-} UBX_ESF_MEAS_sensorData_t;
-
-typedef struct
-{
-  uint32_t timeTag; // Time tag of measurement generated by external sensor
-  union
-  {
-    uint16_t all;
-    struct
-    {
-      uint16_t timeMarkSent : 2; // Time mark signal was supplied just prior to sending this message:
-                                 //   0 = none, 1 = on Ext0, 2 = on Ext1
-      uint16_t timeMarkEdge : 1; // Trigger on rising (0) or falling (1) edge of time mark signal
-      uint16_t calibTtagValid : 1; // Calibration time tag available. Always set to zero.
-      uint16_t reserved : 7;
-      uint16_t numMeas : 5;  // Number of measurements contained in this message (optional, can be obtained from message size)
-    } bits;
-  } flags;
-  uint16_t id; // Identification number of data provider
-  UBX_ESF_MEAS_sensorData_t data[DEF_NUM_SENS];
-  uint32_t calibTtag; // OPTIONAL: Receiver local time calibrated: ms
-} UBX_ESF_MEAS_data_t;
-
-typedef struct
-{
-  union
-  {
-    uint32_t all;
-    struct
-    {
-      uint32_t all : 1;
-
-      uint32_t timeMarkSent : 1;
-      uint32_t timeMarkEdge : 1;
-      uint32_t calibTtagValid : 1;
-      uint32_t numMeas : 1;
-
-      uint32_t id : 1;
-
-      uint32_t data : DEF_NUM_SENS;
-
-      uint32_t calibTtag : 1;
-    } bits;
-  } moduleQueried;
-} UBX_ESF_MEAS_moduleQueried_t;
-
-typedef struct
-{
-	ubxAutomaticFlags automaticFlags;
-  UBX_ESF_MEAS_data_t data;
-  UBX_ESF_MEAS_moduleQueried_t moduleQueried;
-  void (*callbackPointer)(UBX_ESF_MEAS_data_t);
-  UBX_ESF_MEAS_data_t  *callbackData;
-} UBX_ESF_MEAS_t;
-
-// UBX-ESF-RAW (0x10 0x03): Raw sensor measurements
-// Note: length is variable
-const uint16_t UBX_ESF_RAW_MAX_LEN = 4 + (8 * DEF_NUM_SENS);
-
-typedef struct
-{
-  union
-  {
-    uint32_t all;
-    struct
-    {
-      uint32_t dataField : 24; // Data
-      uint32_t dataType : 8; // Type of data (0 = no data; 1..255 = data type)
-    } bits;
-  } data;
-  uint32_t sTag; // Sensor time tag
-} UBX_ESF_RAW_sensorData_t;
-
-typedef struct
-{
-  uint8_t reserved1[4];
-  UBX_ESF_RAW_sensorData_t data[DEF_NUM_SENS];
-} UBX_ESF_RAW_data_t;
-
-typedef struct
-{
-  union
-  {
-    uint32_t all;
-    struct
-    {
-      uint32_t all : 1;
-
-      uint32_t data : DEF_NUM_SENS;
-    } bits;
-  } moduleQueried;
-} UBX_ESF_RAW_moduleQueried_t;
-
-typedef struct
-{
-	ubxAutomaticFlags automaticFlags;
-  UBX_ESF_RAW_data_t data;
-  UBX_ESF_RAW_moduleQueried_t moduleQueried;
-  void (*callbackPointer)(UBX_ESF_RAW_data_t);
-  UBX_ESF_RAW_data_t  *callbackData;
-} UBX_ESF_RAW_t;
-
-// UBX-ESF-STATUS (0x10 0x10): External sensor fusion status
-// Note: length is variable
-const uint16_t UBX_ESF_STATUS_MAX_LEN = 16 + (4 * DEF_NUM_SENS);
-
-typedef struct
-{
-  union
-  {
-    uint8_t all;
-    struct
-    {
-      uint8_t type : 6; // Sensor data type
-      uint8_t used : 1; // If set, sensor data is used for the current sensor fusion solution
-      uint8_t ready : 1; // If set, sensor is set up (configuration is available or not required) but not used for computing the current sensor fusion solution.
-    } bits;
-  } sensStatus1;
-  union
-  {
-    uint8_t all;
-    struct
-    {
-      uint8_t calibStatus : 2; // 00: Sensor is not calibrated
-                               // 01: Sensor is calibrating
-                               // 10/11: Sensor is calibrated
-      uint8_t timeStatus : 2; // 00: No data
-                              // 01: Reception of the first byte used to tag the measurement
-                              // 10: Event input used to tag the measurement
-                              // 11: Time tag provided with the data
-    } bits;
-  } sensStatus2;
-  uint8_t freq; // Observation frequency: Hz
-  union
-  {
-    uint8_t all;
-    struct
-    {
-      uint8_t badMeas : 1; // Bad measurements detected
-      uint8_t badTTag : 1; // Bad measurement time-tags detected
-      uint8_t missingMeas : 1; // Missing or time-misaligned measurements detected
-      uint8_t noisyMeas : 1; // High measurement noise-level detected
-    } bits;
-  } faults;
-} UBX_ESF_STATUS_sensorStatus_t;
-
-typedef struct
-{
-  uint32_t iTOW; // GPS time of week of the HNR epoch: ms
-  uint8_t version; // Message version (0x02 for this version)
-  uint8_t reserved1[7];
-  uint8_t fusionMode; // Fusion mode:
-                      //  0: Initialization mode: receiver is initializing some unknown values required for doing sensor fusion
-                      //  1: Fusion mode: GNSS and sensor data are used for navigation solution computation
-                      //  2: Suspended fusion mode: sensor fusion is temporarily disabled due to e.g. invalid sensor data or detected ferry
-                      //  3: Disabled fusion mode: sensor fusion is permanently disabled until receiver reset due e.g. to sensor error
-  uint8_t reserved2[2];
-  uint8_t numSens; // Number of sensors
-  UBX_ESF_STATUS_sensorStatus_t status[DEF_NUM_SENS];
-} UBX_ESF_STATUS_data_t;
-
-typedef struct
-{
-  union
-  {
-    uint32_t all;
-    struct
-    {
-      uint32_t all : 1;
-
-      uint32_t iTOW : 1;
-      uint32_t version : 1;
-      uint32_t fusionMode : 1;
-      uint32_t numSens : 1;
-
-      uint32_t status : DEF_NUM_SENS;
-    } bits;
-  } moduleQueried;
-} UBX_ESF_STATUS_moduleQueried_t;
-
-typedef struct
-{
-	ubxAutomaticFlags automaticFlags;
-  UBX_ESF_STATUS_data_t data;
-  UBX_ESF_STATUS_moduleQueried_t moduleQueried;
-  void (*callbackPointer)(UBX_ESF_STATUS_data_t);
-  UBX_ESF_STATUS_data_t  *callbackData;
-} UBX_ESF_STATUS_t;
-
-// HNR-specific structs
-
-// UBX-HNR-PVT (0x28 0x00): High rate output of PVT solution
-const uint16_t UBX_HNR_PVT_LEN = 72;
-
-typedef struct
-{
-  uint32_t iTOW; // GPS time of week of the HNR epoch: ms
-  uint16_t year; // Year (UTC)
-  uint8_t month; // Month, range 1..12 (UTC)
-  uint8_t day; // Day of month, range 1..31 (UTC)
-  uint8_t hour; // Hour of day, range 0..23 (UTC)
-  uint8_t min; // Minute of hour, range 0..59 (UTC)
-  uint8_t sec; // Seconds of minute, range 0..60 (UTC)
-  union
-  {
-    uint8_t all;
-    struct
-    {
-      uint8_t validDate : 1; // 1 = Valid UTC Date
-      uint8_t validTime : 1; // 1 = Valid UTC Time of Day
-      uint8_t fullyResolved : 1; // 1 = UTC Time of Day has been fully resolved
-    } bits;
-  } valid;
-  int32_t nano; // Fraction of second (UTC): ns
-  uint8_t gpsFix; // GPSfix Type, range 0..5
-                    // 0x00 = No Fix
-                    // 0x01 = Dead Reckoning only
-                    // 0x02 = 2D-Fix
-                    // 0x03 = 3D-Fix
-                    // 0x04 = GPS + dead reckoning combined
-                    // 0x05 = Time only fix
-                    // 0x06..0xff: reserved
-  union
-  {
-    uint8_t all;
-    struct
-    {
-      uint8_t gpsFixOK : 1; // >1 = Fix within limits (e.g. DOP & accuracy)
-      uint8_t diffSoln : 1; // 1 = DGPS used
-      uint8_t WKNSET : 1; // 1 = Valid GPS week number
-      uint8_t TOWSET : 1; // 1 = Valid GPS time of week (iTOW & fTOW)
-      uint8_t headVehValid : 1; // 1= Heading of vehicle is valid
-    } bits;
-  } flags;
-  uint8_t reserved1[2];
-  int32_t lon; // Longitude: Degrees * 1e-7
-  int32_t lat; // Latitude: Degrees * 1e-7
-  int32_t height; // Height above ellipsoid: mm
-  int32_t hMSL; // Height above MSL: mm
-  int32_t gSpeed; // Ground Speed (2-D): mm/s
-  int32_t speed; // Speed (3-D): mm/s
-  int32_t headMot; // Heading of motion (2-D): Degrees * 1e-5
-  int32_t headVeh; // Heading of vehicle (2-D): Degrees * 1e-5
-  uint32_t hAcc; // Horizontal accuracy: mm
-  uint32_t vAcc; // Vertical accuracy: mm
-  uint32_t sAcc; // Speed accuracy: mm/s
-  uint32_t headAcc; // Heading accuracy: Degrees * 1e-5
-  uint8_t reserved2[4];
-} UBX_HNR_PVT_data_t;
-
-typedef struct
-{
-  union
-  {
-    uint32_t all;
-    struct
-    {
-      uint32_t all : 1;
-
-      uint32_t iTOW : 1;
-      uint32_t year : 1;
-      uint32_t month : 1;
-      uint32_t day : 1;
-      uint32_t hour : 1;
-      uint32_t min : 1;
-      uint32_t sec : 1;
-
-      uint32_t validDate : 1;
-      uint32_t validTime : 1;
-      uint32_t fullyResolved : 1;
-
-      uint32_t nano : 1;
-      uint32_t gpsFix : 1;
-
-      uint32_t gpsFixOK : 1;
-      uint32_t diffSoln : 1;
-      uint32_t WKNSET : 1;
-      uint32_t TOWSET : 1;
-      uint32_t headVehValid : 1;
-
-      uint32_t lon : 1;
-      uint32_t lat : 1;
-      uint32_t height : 1;
-      uint32_t hMSL : 1;
-      uint32_t gSpeed : 1;
-      uint32_t speed : 1;
-      uint32_t headMot : 1;
-      uint32_t headVeh : 1;
-      uint32_t hAcc : 1;
-      uint32_t vAcc : 1;
-      uint32_t sAcc : 1;
-      uint32_t headAcc : 1;
-    } bits;
-  } moduleQueried;
-} UBX_HNR_PVT_moduleQueried_t;
-
-typedef struct
-{
-	ubxAutomaticFlags automaticFlags;
-  UBX_HNR_PVT_data_t data;
-  UBX_HNR_PVT_moduleQueried_t moduleQueried;
-  void (*callbackPointer)(UBX_HNR_PVT_data_t);
-  UBX_HNR_PVT_data_t  *callbackData;
-} UBX_HNR_PVT_t;
-
-// UBX-HNR-ATT (0x28 0x01): Attitude solution
-const uint16_t UBX_HNR_ATT_LEN = 32;
-
-typedef struct
-{
-  uint32_t iTOW; // GPS time of week of the navigation epoch: ms
-  uint8_t version;
-  uint8_t reserved1[3];
-  int32_t roll; // Vehicle roll: Degrees * 1e-5
-  int32_t pitch; // Vehicle pitch: Degrees * 1e-5
-  int32_t heading; // Vehicle heading: Degrees * 1e-5
-  uint32_t accRoll; // Vehicle roll accuracy: Degrees * 1e-5
-  uint32_t accPitch; // Vehicle pitch accuracy: Degrees * 1e-5
-  uint32_t accHeading; // Vehicle heading accuracy: Degrees * 1e-5
-} UBX_HNR_ATT_data_t;
-
-typedef struct
-{
-  union
-  {
-    uint32_t all;
-    struct
-    {
-      uint32_t all : 1;
-
-      uint32_t iTOW : 1;
-      uint32_t version : 1;
-      uint32_t roll : 1;
-      uint32_t pitch : 1;
-      uint32_t heading : 1;
-      uint32_t accRoll : 1;
-      uint32_t accPitch : 1;
-      uint32_t accHeading : 1;
-    } bits;
-  } moduleQueried;
-} UBX_HNR_ATT_moduleQueried_t;
-
-typedef struct
-{
-	ubxAutomaticFlags automaticFlags;
-  UBX_HNR_ATT_data_t data;
-  UBX_HNR_ATT_moduleQueried_t moduleQueried;
-  void (*callbackPointer)(UBX_HNR_ATT_data_t);
-  UBX_HNR_ATT_data_t  *callbackData;
-} UBX_HNR_ATT_t;
-
-// UBX-HNR-INS (0x28 0x02): Vehicle dynamics information
-const uint16_t UBX_HNR_INS_LEN = 36;
-
-typedef struct
-{
-  union
-  {
-    uint32_t all;
-    struct
-    {
-      uint32_t version : 8; // Message version (0x00 for this version)
-      uint32_t xAngRateValid : 1; // Compensated x-axis angular rate data validity flag (0: not valid, 1: valid)
-      uint32_t yAngRateValid : 1; // Compensated y-axis angular rate data validity flag (0: not valid, 1: valid)
-      uint32_t zAngRateValid : 1; // Compensated z-axis angular rate data validity flag (0: not valid, 1: valid)
-      uint32_t xAccelValid : 1; // Compensated x-axis acceleration data validity flag (0: not valid, 1: valid)
-      uint32_t yAccelValid : 1; // Compensated y-axis acceleration data validity flag (0: not valid, 1: valid)
-      uint32_t zAccelValid : 1; // Compensated z-axis acceleration data validity flag (0: not valid, 1: valid)
-    } bits;
-  } bitfield0;
-  uint8_t reserved1[4];
-  uint32_t iTOW; // GPS time of week of the HNR epoch: ms
-  int32_t xAngRate; // Compensated x-axis angular rate: Degrees/s * 1e-3
-  int32_t yAngRate; // Compensated y-axis angular rate: Degrees/s * 1e-3
-  int32_t zAngRate; // Compensated z-axis angular rate: Degrees/s * 1e-3
-  int32_t xAccel; // Compensated x-axis acceleration (with gravity): m/s^2 * 1e-2
-  int32_t yAccel; // Compensated y-axis acceleration (with gravity): m/s^2 * 1e-2
-  int32_t zAccel; // Compensated z-axis acceleration (with gravity): m/s^2 * 1e-2
-} UBX_HNR_INS_data_t;
-
-typedef struct
-{
-  union
-  {
-    uint32_t all;
-    struct
-    {
-      uint32_t all : 1;
-
-      uint32_t version : 1;
-      uint32_t xAngRateValid : 1;
-      uint32_t yAngRateValid : 1;
-      uint32_t zAngRateValid : 1;
-      uint32_t xAccelValid : 1;
-      uint32_t yAccelValid : 1;
-      uint32_t zAccelValid : 1;
-
-      uint32_t iTOW : 1;
-      uint32_t xAngRate : 1;
-      uint32_t yAngRate : 1;
-      uint32_t zAngRate : 1;
-      uint32_t xAccel : 1;
-      uint32_t yAccel : 1;
-      uint32_t zAccel : 1;
-    } bits;
-  } moduleQueried;
-} UBX_HNR_INS_moduleQueried_t;
-
-typedef struct
-{
-	ubxAutomaticFlags automaticFlags;
-  UBX_HNR_INS_data_t data;
-  UBX_HNR_INS_moduleQueried_t moduleQueried;
-  void (*callbackPointer)(UBX_HNR_INS_data_t);
-  UBX_HNR_INS_data_t  *callbackData;
-} UBX_HNR_INS_t;
-
-// UBX-CFG-TP5 (0x06 0x31): Time pulse parameters
-const uint16_t UBX_CFG_TP5_LEN = 32;
-
-typedef struct
-{
-  uint8_t tpIdx; // Time pulse selection (0 = TIMEPULSE, 1 = TIMEPULSE2)
-  uint8_t version; // Message version (0x01 for this version)
-  uint8_t reserved1[2];
-  int16_t antCableDelay; // Antenna cable delay: ns
-  int16_t rfGroupDelay; // RF group delay: ns
-  uint32_t freqPeriod; // Frequency or period time, depending on setting of bit 'isFreq': Hz_or_us
-  uint32_t freqPeriodLock; // Frequency or period time when locked to GNSS time, only used if 'lockedOtherSet' is set: Hz_or_us
-  uint32_t pulseLenRatio; // Pulse length or duty cycle, depending on 'isLength': us_or_2^-32
-  uint32_t pulseLenRatioLock; // Pulse length or duty cycle when locked to GNSS time, only used if 'lockedOtherSet' is set: us_or_2^-32
-  int32_t userConfigDelay; // User-configurable time pulse delay: ns
-  union
-  {
-    uint32_t all;
-    struct
-    {
-      uint32_t active : 1; // If set enable time pulse; if pin assigned to another function, other function takes precedence.
-      uint32_t lockGnssFreq : 1; // If set, synchronize time pulse to GNSS as soon as GNSS time is valid. If not set, or before GNSS time is valid, use local clock.
-      uint32_t lockedOtherSet : 1; // If set the receiver switches between the timepulse settings given by 'freqPeriodLocked' & 'pulseLenLocked' and those given by 'freqPeriod' & 'pulseLen'.
-      uint32_t isFreq : 1; // If set 'freqPeriodLock' and 'freqPeriod' are interpreted as frequency, otherwise interpreted as period.
-      uint32_t isLength : 1; // If set 'pulseLenRatioLock' and 'pulseLenRatio' interpreted as pulse length, otherwise interpreted as duty cycle.
-      uint32_t alignToTow : 1; // Align pulse to top of second (period time must be integer fraction of 1s). Also set 'lockGnssFreq' to use this feature.
-      uint32_t polarity : 1; // Pulse polarity: 0: falling edge at top of second; 1: rising edge at top of second
-      uint32_t gridUtcGnss : 4; // Timegrid to use: 0: UTC; 1: GPS; 2: GLONASS; 3: BeiDou; 4: Galileo
-      uint32_t syncMode : 3; // Sync Manager lock mode to use:
-                             // 0: switch to 'freqPeriodLock' and 'pulseLenRatioLock' as soon as Sync Manager has an accurate time, never switch back to 'freqPeriod' and 'pulseLenRatio'
-                             // 1: switch to 'freqPeriodLock' and 'pulseLenRatioLock' as soon as Sync Manager has an accurate time, and switch back to 'freqPeriod' and 'pulseLenRatio' as soon as time gets inaccurate
-    } bits;
-  } flags;
-} UBX_CFG_TP5_data_t;
-
-#endif
diff --git a/Ublox_Linux_Library/android_build/Android.mk b/Ublox_Linux_Library/android_build/Android.mk
deleted file mode 100644
index caac7b2..0000000
--- a/Ublox_Linux_Library/android_build/Android.mk
+++ /dev/null
@@ -1,48 +0,0 @@
-LOCAL_PATH := $(call my-dir)
-
-################################################################
-############# Build ublox shared library #######################
-################################################################
-include $(CLEAR_VARS)
-LOCAL_C_INCLUDES := ../inc \
-					../SparkFun_u-blox_GNSS_Arduino_Library/src
-LOCAL_SRC_FILES  := ../SparkFun_u-blox_GNSS_Arduino_Library/src/SparkFun_u-blox_GNSS_Arduino_Library.cpp \
-					../src/Print.cpp \
-					../src/Utils.cpp
-LOCAL_MODULE     :=  ublox
-LOCAL_CFLAGS := -std=gnu++11 -DANDROID
-LOCAL_CFLAGS += -fPIE
-LOCAL_ARM_MODE := arm
-LOCAL_ARM_NEON := true
-
-include $(BUILD_SHARED_LIBRARY)
-
-#################################################################
-################ ublox_f9p_test #################################
-#################################################################
-include $(CLEAR_VARS)
-LOCAL_MODULE := ublox_f9p_test
-LOCAL_C_INCLUDES := ../inc \
-					../SparkFun_u-blox_GNSS_Arduino_Library/src
-LOCAL_SRC_FILES:= ../linux_examples/ublox_f9p_test.cpp
-LOCAL_LDFLAGS := -L./libs/$(TARGET_ARCH_ABI) -fPIE -pie
-LOCAL_SHARED_LIBRARIES := ublox
-LOCAL_CXXFLAGS += -fPIE
-LOCAL_ARM_MODE := arm
-LOCAL_ARM_NEON := true
-include $(BUILD_EXECUTABLE)
-
-#################################################################
-################ ublox_f9p i2c test #############################
-#################################################################
-include $(CLEAR_VARS)
-LOCAL_MODULE := ublox_f9p_i2c_test
-LOCAL_C_INCLUDES := ../inc \
-					../SparkFun_u-blox_GNSS_Arduino_Library/src
-LOCAL_SRC_FILES:= ../linux_examples/ublox_f9p_i2c_test.cpp
-LOCAL_LDFLAGS := -L./libs/$(TARGET_ARCH_ABI) -fPIE -pie
-LOCAL_SHARED_LIBRARIES := ublox
-LOCAL_CXXFLAGS += -fPIE
-LOCAL_ARM_MODE := arm
-LOCAL_ARM_NEON := true
-include $(BUILD_EXECUTABLE)
\ No newline at end of file
diff --git a/Ublox_Linux_Library/android_build/Application.mk b/Ublox_Linux_Library/android_build/Application.mk
deleted file mode 100644
index 258b935..0000000
--- a/Ublox_Linux_Library/android_build/Application.mk
+++ /dev/null
@@ -1,14 +0,0 @@
-# Application make file to enable STL 
-APP_BUILD_SCRIPT := $(call my-dir)/Android.mk
-APP_PROJECT_PATH := $(call my-dir)
-
-# Disable run time type info
-#APP_CPPFLAGS += -fno-rtti
-APP_CPPFLAGS += -O0
-APP_OPTIM := release
-NDK_TOOLCHAIN_VERSION=4.9
-
-# Use GNU our STL
-APP_STL := gnustl_shared
-APP_ABI := armeabi-v7a
-APP_PLATFORM := android-123
diff --git a/Ublox_Linux_Library/linux_build/CMakeLists.txt b/Ublox_Linux_Library/linux_build/CMakeLists.txt
deleted file mode 100644
index 9701edc..0000000
--- a/Ublox_Linux_Library/linux_build/CMakeLists.txt
+++ /dev/null
@@ -1,71 +0,0 @@
-project (ublox_linux)
-cmake_minimum_required(VERSION 2.8)
-
-set(
-    CMAKE_RUNTIME_OUTPUT_DIRECTORY
-    ${CMAKE_HOME_DIRECTORY}/bin
-    )
-
-set(
-    CMAKE_LIBRARY_OUTPUT_DIRECTORY
-    ${CMAKE_HOME_DIRECTORY}/lib
-    )
-
-add_definitions(
-    -std=c++11 -Wno-deprecated -fconcepts -Wall -DLINUX_PLATFORM
-    )
-
-link_directories(
-    /usr/local/lib
-    /usr/lib
-    ${CMAKE_HOME_DIRECTORY}/lib
-    )
-
-include_directories(
-    ${CMAKE_HOME_DIRECTORY}/../inc
-    #${CMAKE_HOME_DIRECTORY}/../SparkFun_Ublox_Arduino_Library/src
-    ${CMAKE_HOME_DIRECTORY}/../SparkFun_u-blox_GNSS_Arduino_Library/src
-    )
-
-set(
-    ublox_parser_src
-    ../SparkFun_u-blox_GNSS_Arduino_Library/src/SparkFun_u-blox_GNSS_Arduino_Library.cpp
-    ../src/Print.cpp
-    ../src/Utils.cpp
-    )
-
-add_library(
-    ublox_linux SHARED ${ublox_parser_src}
-    )
-
-#
-# Ublox f9p Test
-#
-
-set(
-    ublox_f9p_test_src
-    ../linux_examples/ublox_f9p_test.cpp
-    )
-
-add_executable(
-    ublox_f9p_test ${ublox_f9p_test_src}
-    )
-
-target_link_libraries(ublox_f9p_test ublox_linux util)
-
-
-
-#
-# Ublox f9p i2c Test
-#
-
-set(
-    ublox_f9p_i2c_test_src
-    ../linux_examples/ublox_f9p_i2c_test.cpp
-    )
-
-add_executable(
-    ublox_f9p_i2c_test ${ublox_f9p_i2c_test_src}
-    )
-
-target_link_libraries(ublox_f9p_i2c_test ublox_linux util)
\ No newline at end of file
diff --git a/Ublox_Linux_Library/linux_examples/ublox_f9p_i2c_test.cpp b/Ublox_Linux_Library/linux_examples/ublox_f9p_i2c_test.cpp
deleted file mode 100755
index 7044569..0000000
--- a/Ublox_Linux_Library/linux_examples/ublox_f9p_i2c_test.cpp
+++ /dev/null
@@ -1,101 +0,0 @@
-/*
-Copyright (c) 2020 Balamurugan Kandan
-
-Permission is hereby granted, free of charge, to any person obtaining a copy
-of this software and associated documentation files (the "Software"), to deal
-in the Software without restriction, including without limitation the rights
-to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-copies of the Software, and to permit persons to whom the Software is
-furnished to do so, subject to the following conditions:
-
-The above copyright notice and this permission notice shall be included in all
-copies or substantial portions of the Software.
-
-THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
-SOFTWARE.
-*/
-
-#include "SparkFun_u-blox_GNSS_Arduino_Library.h"
-SFE_UBLOX_GNSS myGPS;
-
-#include <string>
-
-int main(int argc, char** argv)
-{
-    printf("Starting uBlox ZED-F9P\n");
-
-    std::string  port = "/dev/ublox_i2c";
-    int address = 0x42;
-
-    if(argc == 1) {
-        printf("\nStarting with default port and address.\n"); 
-        return 0;
-    } else if (argc == 3) {
-
-            port = argv[1];
-            address = std::stoi(argv[2], 0, 16);
-       
-    } else if(argc >= 4) {
-        printf ("\nShould give the port and address as input arguments. Currently giving more arguments...\n");
-        return 0;
-    } 
-
-
-    printf("Looking for GPS on port %s at address 0x%02X\n", port.c_str(), address);
-
-    TwoWire wireCom(address);
-    wireCom.init(port.c_str());
-
-
-    if (!(wireCom.available())) {
-      printf("Failed to init i2c,  Please connect ublox GNSS module and try again... \n");
-      return 0;
-    }
-
-    myGPS.begin(wireCom);
-    myGPS.setNavigationFrequency(8); //Set output to 8 times a second
-    myGPS.saveConfiguration(); //Save the current settings to flash and BBR
-    
-    printf ("\n--------------------------------------------------------\n");
-    while(true) {
-        if (myGPS.getPVT()) {
-          printf ("%02d/%02d/%02d %02d:%02d:%02d %d:%d\n", myGPS.getDay(), myGPS.getMonth(), myGPS.getYear(), 
-                                                           myGPS.getHour(), myGPS.getMinute(), myGPS.getSecond(), 
-                                                           myGPS.getMillisecond(), myGPS.getNanosecond());
-          printf("Latitude                : %2.8f (deg)\n", myGPS.getLatitude() * 1e-7);
-          printf("Longitude               : %2.8f (deg)\n", myGPS.getLongitude() * 1e-7);
-          printf("Altitude                : %d (mm)\n", myGPS.getAltitude());
-          printf("Altitude MSL            : %d (mm)\n", myGPS.getAltitudeMSL());
-          printf("SIV                     : %d\n", myGPS.getSIV());
-          printf("PDOP                    : %f\n", myGPS.getPDOP() * 1e-2); 
-          printf("Fix type                : %d\n", myGPS.getFixType());
-          printf("Ground Speed            : %d\n", myGPS.getGroundSpeed());
-          printf("VelN                    : %08d (mm/s)\n", myGPS.getNedNorthVel());
-          printf("VelE                    : %08d (mm/s)\n", myGPS.getNedEastVel());
-          printf("VelD                    : %08d (mm/s)\n", myGPS.getNedDownVel());
-          printf("VAcc                    : %08d (mm)\n", myGPS.getVerticalAccEst());
-          printf("HAcc                    : %08d (mm)\n", myGPS.getHorizontalAccEst());
-          printf("SpeedAccEst             : %08d (mm/s)\n", myGPS.getSpeedAccEst());
-          printf("HeadAccEst              : %08d (degrees * 10^-5)\n", myGPS.getHeadingAccEst());
-          printf("HeadVehValid            : %s\n", myGPS.getHeadVehValid() ? "true" : "false");
-          printf("HeadVeh                 : %08d (degrees * 10^-5)\n", myGPS.getHeadVeh());
-          printf("MagDec                  : %08d (degrees * 10^-2)\n", myGPS.getMagDec());
-          printf("MagAcc                  : %08d (degrees * 10^-2)\n", myGPS.getMagAcc());
-          int solnType = myGPS.getCarrierSolutionType();
-          if (solnType == 0) printf ("### No RTK Fix yet ###\n");
-          else if (solnType == 1) printf ("&&& DGNSS/Float &&&\n");
-          else if (solnType == 2) printf ("*** DGNSS/Fix ***\n");
-          printf ("\n--------------------------------------------------------\n");
-          usleep(50);
-        }
-
-        usleep(25);
-    }
-
-    return 1;
-}
diff --git a/Ublox_Linux_Library/linux_examples/ublox_f9p_test.cpp b/Ublox_Linux_Library/linux_examples/ublox_f9p_test.cpp
deleted file mode 100644
index a1bb75f..0000000
--- a/Ublox_Linux_Library/linux_examples/ublox_f9p_test.cpp
+++ /dev/null
@@ -1,87 +0,0 @@
-/*
-Copyright (c) 2020 Balamurugan Kandan
-
-Permission is hereby granted, free of charge, to any person obtaining a copy
-of this software and associated documentation files (the "Software"), to deal
-in the Software without restriction, including without limitation the rights
-to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-copies of the Software, and to permit persons to whom the Software is
-furnished to do so, subject to the following conditions:
-
-The above copyright notice and this permission notice shall be included in all
-copies or substantial portions of the Software.
-
-THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
-SOFTWARE.
-*/
-
-#include "SparkFun_u-blox_GNSS_Arduino_Library.h"
-SFE_UBLOX_GNSS myGPS;
-
-int main(int argc, char** argv)
-{
-    if(argc == 1) {
-        printf("\nublox_f9p_test <ublox_com> <pseudo_com> (ublox_f9p_test '/dev/ttyACM0')"); 
-        return 0;
-    } else if (argc == 2) {
-        for(int counter=0;counter<argc;counter++) 
-            printf("\nargv[%d]: %s",counter,argv[counter]);        
-    } else if(argc >= 3) {
-        printf ("\nMore number of arguments...");
-        return 0;
-    } 
-
-    Stream seriComm(argv[1]);
-    seriComm.begin(38400);
-    if (!seriComm.isConnected()) {
-        printf ("Ublox is not connected. Please connect ublox GNSS module and try again...\n");
-        return 0;
-    }
-
-    myGPS.begin(seriComm);
-    myGPS.setNavigationFrequency(8); //Set output to 8 times a second
-    myGPS.saveConfiguration(); //Save the current settings to flash and BBR
-    
-    printf ("\n--------------------------------------------------------\n");
-    while(true) {
-        if (myGPS.getPVT()) {
-          printf ("%02d/%02d/%02d %02d:%02d:%02d %d:%d\n", myGPS.getDay(), myGPS.getMonth(), myGPS.getYear(), 
-                                                           myGPS.getHour(), myGPS.getMinute(), myGPS.getSecond(), 
-                                                           myGPS.getMillisecond(), myGPS.getNanosecond());
-          printf("Latitude                : %2.8f (deg)\n", myGPS.getLatitude() * 1e-7);
-          printf("Longitude               : %2.8f (deg)\n", myGPS.getLongitude() * 1e-7);
-          printf("Altitude                : %d (mm)\n", myGPS.getAltitude());
-          printf("Altitude MSL            : %d (mm)\n", myGPS.getAltitudeMSL());
-          printf("SIV                     : %d\n", myGPS.getSIV());
-          printf("PDOP                    : %f\n", myGPS.getPDOP() * 1e-2); 
-          printf("Fix type                : %d\n", myGPS.getFixType());
-          printf("Ground Speed            : %d\n", myGPS.getGroundSpeed());
-          printf("VelN                    : %08d (mm/s)\n", myGPS.getNedNorthVel());
-          printf("VelE                    : %08d (mm/s)\n", myGPS.getNedEastVel());
-          printf("VelD                    : %08d (mm/s)\n", myGPS.getNedDownVel());
-          printf("VAcc                    : %08d (mm)\n", myGPS.getVerticalAccEst());
-          printf("HAcc                    : %08d (mm)\n", myGPS.getHorizontalAccEst());
-          printf("SpeedAccEst             : %08d (mm/s)\n", myGPS.getSpeedAccEst());
-          printf("HeadAccEst              : %08d (degrees * 10^-5)\n", myGPS.getHeadingAccEst());
-          printf("HeadVehValid            : %s\n", myGPS.getHeadVehValid() ? "true" : "false");
-          printf("HeadVeh                 : %08d (degrees * 10^-5)\n", myGPS.getHeadVeh());
-          printf("MagDec                  : %08d (degrees * 10^-2)\n", myGPS.getMagDec());
-          printf("MagAcc                  : %08d (degrees * 10^-2)\n", myGPS.getMagAcc());
-          int solnType = myGPS.getCarrierSolutionType();
-          if (solnType == 0) printf ("### No RTK Fix yet ###\n");
-          else if (solnType == 1) printf ("&&& DGNSS/Float &&&\n");
-          else if (solnType == 2) printf ("*** DGNSS/Fix ***\n");
-          printf ("\n--------------------------------------------------------\n");
-          usleep(50);
-        }
-
-        usleep(25);
-    }
-
-    return 1;
-}
diff --git a/ekf_nav_ins/inc/ekfNavINS.h b/ekf_nav_ins/inc/ekfNavINS.h
index ddfe482..760bd8d 100644
--- a/ekf_nav_ins/inc/ekfNavINS.h
+++ b/ekf_nav_ins/inc/ekfNavINS.h
@@ -32,6 +32,34 @@ Original Author: Adhika Lie
 #include <mutex>
 #include <shared_mutex>
 
+
+static const double DEG_TO_RAD = 0.017453292519943295769236907684886;
+static const double EARTH_RADIUS_IN_METERS = 6372797.560856;
+static const double RAD_TO_DEG = (double)180/(double)3.14159265359;
+
+#if 0
+double ArcInRadians(const Position& from, const Position& to) {
+    double latitudeArc  = (from.lat - to.lat) * DEG_TO_RAD;
+    double longitudeArc = (from.lon - to.lon) * DEG_TO_RAD;
+    double latitudeH = sin(latitudeArc * 0.5);
+    latitudeH *= latitudeH;
+    double lontitudeH = sin(longitudeArc * 0.5);
+    lontitudeH *= lontitudeH;
+    double tmp = cos(from.lat*DEG_TO_RAD) * cos(to.lat*DEG_TO_RAD);
+    return 2.0 * asin(sqrt(latitudeH + tmp*lontitudeH));
+}
+
+/** @brief Computes the distance, in meters, between two WGS-84 positions.
+  *
+  * The result is equal to <code>EARTH_RADIUS_IN_METERS*ArcInRadians(from,to)</code>
+  *
+  * @sa ArcInRadians
+  */
+double DistanceInMeters(const Position& from, const Position& to) {
+    return EARTH_RADIUS_IN_METERS*ArcInRadians(from, to);
+}
+#endif
+
 constexpr float SIG_W_A = 0.05f;
 // Std dev of gyro output noise (rad/s)
 constexpr float SIG_W_G = 0.00175f;
@@ -63,6 +91,7 @@ constexpr double ECC2 = 0.0066943799901;
 // earth semi-major axis radius (m)
 constexpr double EARTH_RADIUS = 6378137.0;
 
+
 class gpsCoordinate {
     public:
         double lat;
diff --git a/ekf_nav_ins/src/ekfNavINS.cpp b/ekf_nav_ins/src/ekfNavINS.cpp
index 9fe7e20..f4830db 100644
--- a/ekf_nav_ins/src/ekfNavINS.cpp
+++ b/ekf_nav_ins/src/ekfNavINS.cpp
@@ -186,6 +186,10 @@ std::tuple<float,float,float> ekfNavINS::getPitchRollYaw(float ax, float ay, flo
   Bxc = hx*cosf(theta) + (hy*sinf(phi) + hz*cosf(phi))*sinf(theta);
   Byc = hy*cosf(phi) - hz*sinf(phi);
   // finding initial heading
+ // printf("\nax:%f,ay:%f,az:%f\n",ax,ay,az);
+  //printf("\nhx:%f,hy:%f,hz:%f\n",hx,hy,hz);
+  //printf("\npitch:%f,roll:%f,yaw:%f\n",theta,phi,psi);
+  sleep(2);
   psi = -atan2f(Byc,Bxc);
   return (std::make_tuple(theta,phi,psi));
 }
diff --git a/ekf_test/CMakeLists.txt b/ekf_test/CMakeLists.txt
deleted file mode 100644
index 8822e9e..0000000
--- a/ekf_test/CMakeLists.txt
+++ /dev/null
@@ -1,17 +0,0 @@
-project (ekf_test)
-cmake_minimum_required(VERSION 2.8)
-
-add_definitions(
-    -std=c++17 -O3 -Wno-deprecated -v -ftime-report
-    )
-
-set(
-    ekf_test_src
-    src/ekf_test.cpp
-    )
-
-add_executable(
-    ekf_test ${ekf_test_src} 
-    )
-
-target_link_libraries(ekf_test robotcontrol ekf_nav_ins ublox_linux Boost::system util)
diff --git a/ekf_test/src/ekf_test.cpp b/ekf_test/src/ekf_test.cpp
deleted file mode 100644
index 789847a..0000000
--- a/ekf_test/src/ekf_test.cpp
+++ /dev/null
@@ -1,146 +0,0 @@
-#include <stdio.h>
-#include <signal.h>
-#include <getopt.h>
-#include <time.h>
-#include <rc/mpu.h>
-#include <rc/time.h>
-
-#include "ekfNavINS.h"
-#include "SparkFun_u-blox_GNSS_Arduino_Library.h"
-
-#include <iostream>
-#include <fstream>
-#include <string>
-#include <iomanip>
-#include <tuple>
-
-using namespace std;
-
-#define I2C_BUS 2
-
-static int running = 0;
-
-SFE_UBLOX_GNSS gps;
-
-// interrupt handler to catch ctrl-c
-static void __signal_handler(__attribute__ ((unused)) int dummy)
-{
-	running=0;
-	return;
-}
-
-// file pointer
-fstream fout;
-inline void open_file(std::string file_name) {
-    fout.open(file_name, ios::out | ios::app);
-    fout << std::fixed <<"time" << "," << "latitude" << "," << "longitude" << "," 
-    								   << "roll" << "," << "pitch" << "," << "yaw" << "," 
-    								   << "filtered_latitude" << "," << "filtered_longitude" << ","
-    								   << "filtered_roll" << "," << "filtered_pitch" << "," << "filtered_yaw" << std::endl;
-}
-
-inline void update_file(long int time, double latitude, double longitude,
-						float roll, float pitch, float yaw, 
-						double filtered_latitude, double filtered_longitude,
-						float filtered_roll, float filtered_pitch, float filtered_yaw) {
-	fout << time << "," << std::setprecision(7) << latitude << "," << std::setprecision(7) << longitude 
-				 << "," << roll << "," << pitch << "," << yaw
-				 << "," << std::setprecision(7) << filtered_latitude << "," << std::setprecision(7) << filtered_longitude 
-				 << "," << filtered_roll << "," << filtered_pitch << "," << filtered_yaw << std::endl;
-}
-
-inline void close_file() {
-	fout.close();
-}
-
-int main(int argc, char *argv[])
-{
-	// MPU9560
-	rc_mpu_data_t data; //struct to hold new data
-	// Ublox GPS
-	Stream serialComm("/dev/ttyACM0");
-    gps.begin(serialComm);
-    // EKF
-    ekfNavINS ekf;
-
-    float ax, ay, az, hx, hy, hz, pitch, roll, yaw;
-
-	// parse arguments
-	opterr = 0;
-
-	// set signal handler so the loop can exit cleanly
-	signal(SIGINT, __signal_handler);
-	running = 1;
-
-	// use defaults for now, except also enable magnetometer.
-	rc_mpu_config_t conf = rc_mpu_default_config();
-	conf.i2c_bus = I2C_BUS;
-	conf.enable_magnetometer = 1; // Enable magnetometer
-	conf.show_warnings = 1; // Enable warnings
-
-	if(rc_mpu_initialize(&data, conf)){
-		fprintf(stderr,"rc_mpu_initialize_failed\n");
-		return -1;
-	}
-
-	open_file(std::string("./gnss.csv"));
-
-	//now just wait, print_data will run
-	while (running) {
-		// read sensor data
-		if(rc_mpu_read_accel(&data)<0){
-			printf("read accel data failed\n");
-		}
-		if(rc_mpu_read_gyro(&data)<0){
-			printf("read gyro data failed\n");
-		}
-		if(rc_mpu_read_mag(&data)){
-			printf("read mag data failed\n");
-		}
-
-		// update the filter
-		if (gps.getPVT()) {
-			ax = data.accel[0];
-			ay = -1*data.accel[1];
-			az = data.accel[2];
-			hx = data.mag[0]; 
-			hy = data.mag[1]; 
-			hz = data.mag[2];
-			std::tie(pitch,roll,yaw) = ekf.getPitchRollYaw(ax, ay, az, hx, hy, hz);
-			ekf.ekf_update(time(NULL) /*,gps.getTimeOfWeek()*/, gps.getNedNorthVel()*1e-3, gps.getNedEastVel()*1e-3, gps.getNedDownVel()*1e-3,
-				gps.getLatitude()*1e-7*DEG_TO_RAD, gps.getLongitude()*1e-7*DEG_TO_RAD, (gps.getAltitude()*1e-3),
-				data.gyro[0]*DEG_TO_RAD, -1*data.gyro[1]*DEG_TO_RAD, data.gyro[2]*DEG_TO_RAD,
-				ax, ay, az, hx, hy, hz);
-
-			update_file(time(NULL), 
-						gps.getLatitude()*1e-7, gps.getLongitude()*1e-7,
-						roll, pitch, yaw,
-						ekf.getLatitude_rad()*RAD_TO_DEG, ekf.getLongitude_rad()*RAD_TO_DEG,
-						ekf.getRoll_rad(), ekf.getPitch_rad(), ekf.getHeading_rad());
-
-			printf("------------------------- %ld -------------------------- \n", gps.getTimeOfWeek());
-			printf("Latitude  : %2.7f %2.7f\n", gps.getLatitude()*1e-7, ekf.getLatitude_rad()*RAD_TO_DEG);
-			printf("Longitute : %2.7f %2.7f\n", gps.getLongitude()*1e-7, ekf.getLongitude_rad()*RAD_TO_DEG);
-			printf("Altitude  : %2.3f %2.3f\n", gps.getAltitude()*1e-3, ekf.getAltitude_m());
-			printf("Speed (N) : %2.3f %2.3f\n", gps.getNedNorthVel()*1e-3, ekf.getVelNorth_ms());
-			printf("Speed (E) : %2.3f %2.3f\n", gps.getNedEastVel()*1e-3, ekf.getVelEast_ms());
-			printf("Speed (D) : %2.3f %2.3f\n", gps.getNedDownVel()*1e-3, ekf.getVelDown_ms());
-			printf("Roll 	  : %2.3f %2.3f\n", roll, ekf.getRoll_rad());
-			printf("Pitch     : %2.3f %2.3f\n", pitch, ekf.getPitch_rad());
-			printf("Yaw       : %2.3f %2.3f\n", yaw, ekf.getHeading_rad());
-			/*printf("Gyro X    : %f  %f\n", data.gyro[0]*DEG_TO_RAD, ekf.getGyroBiasX_rads());
-			printf("Gyro Y    : %f  %f\n", data.gyro[1]*DEG_TO_RAD, ekf.getGyroBiasY_rads());
-			printf("Gyro Z    : %f  %f\n", data.gyro[2]*DEG_TO_RAD, ekf.getGyroBiasZ_rads());
-			printf("Accel X   : %f  %f\n", data.accel[0], ekf.getAccelBiasX_mss());
-			printf("Accel Y   : %f  %f\n", data.accel[1], ekf.getAccelBiasY_mss());
-			printf("Accel Z   : %f  %f\n", data.accel[2], ekf.getAccelBiasZ_mss());*/
-			printf("-----------------------------------------------------------------\n");
-		}
-		rc_usleep(100000);
-	}
-	printf("\n");
-	close_file();
-	rc_mpu_power_off();
-	return 0;
-}
-
diff --git a/python_utils/plot_coords.py b/python_utils/plot_coords.py
index 149fb67..5f76d9f 100755
--- a/python_utils/plot_coords.py
+++ b/python_utils/plot_coords.py
@@ -1,5 +1,13 @@
 #!/usr/bin/python
 
+# -Refactor the code to remove reduentent part. 
+# -Compiled for Linux with C++14 standard
+#Copyright (c) 2021 Balamurugan Kandan.
+#MIT License; See LICENSE.md for complete details
+#Author: 2021 Balamurugan Kandan
+
+
+
 import numpy as np
 import pandas as pd
 import matplotlib.pyplot as plt
diff --git a/python_utils/test_data/gnss.csv b/python_utils/test_data/gnss.csv
deleted file mode 100644
index 4421dad..0000000
--- a/python_utils/test_data/gnss.csv
+++ /dev/null
@@ -1,1444 +0,0 @@
-time,latitude,longitude,roll,pitch,yaw,filtered_latitude,filtered_longitude,filtered_roll,filtered_pitch,filtered_yaw
-1615570112,52.1324433,-2.3275946,0.1365605,0.0691891,-2.2407906,52.1324432,-2.3275947,0.1365605,0.0691891,-2.2407906
-1615570112,52.1324434,-2.3275946,0.1340892,0.0682131,-2.7572372,52.1324433,-2.3275946,0.1365605,0.0691891,-2.2407908
-1615570112,52.1324435,-2.3275945,0.1338566,0.0696771,-1.8723956,52.1324434,-2.3275946,0.1365605,0.0691891,-2.2407908
-1615570113,52.1324436,-2.3275944,0.1333118,0.0638218,-2.8005414,52.1324435,-2.3275945,0.1365605,0.0691890,-2.2407899
-1615570113,52.1324438,-2.3275946,0.1333507,0.0682131,-2.2868481,52.1324435,-2.3275945,0.1365601,0.0691889,-2.2407899
-1615570114,52.1324438,-2.3275944,0.1346022,0.0704092,-2.0697327,52.1324436,-2.3275945,0.1365605,0.0691894,-2.2407949
-1615570114,52.1324439,-2.3275944,0.1304020,0.0687011,-2.7398136,52.1324436,-2.3275945,0.1365602,0.0691891,-2.2407928
-1615570114,52.1324440,-2.3275944,0.1321335,0.0696771,-2.1701632,52.1324437,-2.3275945,0.1365608,0.0691894,-2.2407928
-1615570115,52.1324441,-2.3275943,0.1365288,0.0657733,-2.4712753,52.1324437,-2.3275945,0.1365601,0.0691892,-2.2407937
-1615570115,52.1324442,-2.3275943,0.1331273,0.0706532,-2.6613951,52.1324438,-2.3275944,0.1365608,0.0691899,-2.2407990
-1615570115,52.1324443,-2.3275944,0.1326057,0.0674811,-1.8899647,52.1324438,-2.3275944,0.1365613,0.0691895,-2.2407901
-1615570116,52.1324444,-2.3275944,0.1264791,0.0701652,3.1318076,52.1324439,-2.3275944,0.1365615,0.0691903,-2.2407994
-1615570116,52.1324445,-2.3275944,0.1355641,0.0679691,-1.8491921,52.1324439,-2.3275944,0.1365612,0.0691909,-2.2408094
-1615570117,52.1324446,-2.3275945,0.1327933,0.0606510,-2.5310159,52.1324440,-2.3275944,0.1365626,0.0691904,-2.2407939
-1615570117,52.1324447,-2.3275944,0.1355942,0.0711413,-2.4990492,52.1324440,-2.3275944,0.1365621,0.0691898,-2.2407889
-1615570117,52.1324448,-2.3275945,0.1382569,0.0662612,-2.0044122,52.1324441,-2.3275944,0.1365614,0.0691908,-2.2408068
-1615570118,52.1324449,-2.3275946,0.1298948,0.0669931,-2.0588455,52.1324441,-2.3275944,0.1365623,0.0691888,-2.2407749
-1615570118,52.1324450,-2.3275947,0.1330935,0.0669931,-2.3462670,52.1324442,-2.3275944,0.1365608,0.0691881,-2.2407751
-1615570118,52.1324451,-2.3275947,0.1313581,0.0655293,-2.6412582,52.1324442,-2.3275945,0.1365594,0.0691874,-2.2407753
-1615570119,52.1324452,-2.3275949,0.1338188,0.0655293,-2.5469532,52.1324443,-2.3275945,0.1365581,0.0691851,-2.2407539
-1615570119,52.1324454,-2.3275949,0.1340870,0.0679691,-2.4326451,52.1324443,-2.3275945,0.1365589,0.0691860,-2.2407606
-1615570120,52.1324455,-2.3275950,0.1340542,0.0643096,-2.5627654,52.1324444,-2.3275945,0.1365601,0.0691882,-2.2407823
-1615570120,52.1324456,-2.3275952,0.1326035,0.0672371,-2.1893497,52.1324444,-2.3275946,0.1365599,0.0691861,-2.2407551
-1615570120,52.1324458,-2.3275953,0.1320795,0.0635778,-2.8578076,52.1324445,-2.3275946,0.1365604,0.0691875,-2.2407701
-1615570121,52.1324459,-2.3275953,0.1343286,0.0674811,-1.8786298,52.1324445,-2.3275946,0.1365589,0.0691869,-2.2407722
-1615570121,52.1324460,-2.3275955,0.1325862,0.0652854,-2.2686071,52.1324446,-2.3275946,0.1365579,0.0691839,-2.2407401
-1615570121,52.1324462,-2.3275956,0.1325695,0.0633339,-2.6468408,52.1324447,-2.3275947,0.1365585,0.0691859,-2.2407620
-1615570122,52.1324463,-2.3275957,0.1347990,0.0650414,-2.0563416,52.1324447,-2.3275947,0.1365557,0.0691849,-2.2407672
-1615570122,52.1324465,-2.3275959,0.1357946,0.0662612,-2.1452272,52.1324448,-2.3275948,0.1365564,0.0691860,-2.2407761
-1615570123,52.1324466,-2.3275958,0.1333689,0.0701652,-2.6254356,52.1324448,-2.3275948,0.1365563,0.0691848,-2.2407622
-1615570123,52.1324467,-2.3275959,0.1318523,0.0657733,-2.0507545,52.1324449,-2.3275948,0.1365558,0.0691843,-2.2407594
-1615570123,52.1324469,-2.3275959,0.1311037,0.0645536,-2.3500288,52.1324450,-2.3275949,0.1365593,0.0691846,-2.2407398
-1615570124,52.1324470,-2.3275959,0.1284189,0.0669931,-2.6694312,52.1324450,-2.3275949,0.1365579,0.0691827,-2.2407250
-1615570124,52.1324472,-2.3275960,0.1338659,0.0706532,-2.4068012,52.1324451,-2.3275949,0.1365607,0.0691845,-2.2407293
-1615570124,52.1324473,-2.3275962,0.1365244,0.0652854,-2.1654580,52.1324452,-2.3275950,0.1365622,0.0691838,-2.2407105
-1615570125,52.1324474,-2.3275962,0.1277002,0.0691891,-1.9626653,52.1324452,-2.3275950,0.1365632,0.0691823,-2.2406857
-1615570125,52.1324476,-2.3275963,0.1298758,0.0647975,-2.0059075,52.1324453,-2.3275950,0.1365657,0.0691833,-2.2406816
-1615570126,52.1324477,-2.3275963,0.1311121,0.0655293,-2.3602629,52.1324453,-2.3275951,0.1365695,0.0691821,-2.2406418
-1615570126,52.1324479,-2.3275965,0.1311185,0.0662612,-2.2893839,52.1324454,-2.3275951,0.1365712,0.0691872,-2.2406964
-1615570126,52.1324480,-2.3275965,0.1311163,0.0660173,-1.4433578,52.1324455,-2.3275951,0.1365660,0.0691862,-2.2407167
-1615570127,52.1324481,-2.3275966,0.1333288,0.0657733,-1.9112874,52.1324455,-2.3275952,0.1365599,0.0691838,-2.2407253
-1615570127,52.1324483,-2.3275967,0.1345726,0.0672371,-1.8623101,52.1324456,-2.3275952,0.1365628,0.0691811,-2.2406716
-1615570127,52.1324484,-2.3275967,0.1343286,0.0674811,-2.4235797,52.1324457,-2.3275953,0.1365639,0.0691829,-2.2406874
-1615570128,52.1324485,-2.3275968,0.1316020,0.0652854,-2.0769830,52.1324457,-2.3275953,0.1365611,0.0691831,-2.2407084
-1615570128,52.1324486,-2.3275969,0.1299143,0.0691891,-2.0812764,52.1324458,-2.3275953,0.1365628,0.0691837,-2.2407043
-1615570129,52.1324488,-2.3275969,0.1328218,0.0640657,-1.7022964,52.1324459,-2.3275954,0.1365666,0.0691847,-2.2406936
-1615570129,52.1324489,-2.3275969,0.1345380,0.0633339,-2.1313219,52.1324459,-2.3275954,0.1365654,0.0691853,-2.2407084
-1615570129,52.1324490,-2.3275970,0.1335880,0.0672371,-2.0986137,52.1324460,-2.3275954,0.1365639,0.0691882,-2.2407560
-1615570130,52.1324491,-2.3275969,0.1293985,0.0665052,-2.7453120,52.1324461,-2.3275955,0.1365593,0.0691834,-2.2407234
-1615570130,52.1324492,-2.3275969,0.1328518,0.0674811,-2.6649857,52.1324461,-2.3275955,0.1365587,0.0691807,-2.2406933
-1615570130,52.1324493,-2.3275969,0.1328811,0.0706532,-2.4315560,52.1324462,-2.3275955,0.1365585,0.0691806,-2.2406933
-1615570131,52.1324494,-2.3275969,0.1321135,0.0674811,-2.1128454,52.1324463,-2.3275955,0.1365587,0.0691835,-2.2407291
-1615570131,52.1324496,-2.3275969,0.1338636,0.0704092,-2.3470364,52.1324463,-2.3275956,0.1365612,0.0691854,-2.2407370
-1615570132,52.1324496,-2.3275969,0.1328260,0.0645536,-2.1646590,52.1324464,-2.3275956,0.1365649,0.0691853,-2.2407122
-1615570132,52.1324498,-2.3275969,0.1335642,0.0645536,-2.0166535,52.1324464,-2.3275956,0.1365663,0.0691801,-2.2406361
-1615570132,52.1324498,-2.3275970,0.1301344,0.0662612,-2.8263724,52.1324465,-2.3275956,0.1365653,0.0691756,-2.2405841
-1615570133,52.1324499,-2.3275970,0.1316257,0.0679691,-2.1179304,52.1324466,-2.3275957,0.1365698,0.0691789,-2.2405980
-1615570133,52.1324500,-2.3275969,0.1294028,0.0669931,-2.0297194,52.1324466,-2.3275957,0.1365741,0.0691789,-2.2405689
-1615570133,52.1324502,-2.3275969,0.1303740,0.0655293,-2.4296386,52.1324467,-2.3275957,0.1365787,0.0691828,-2.2405903
-1615570134,52.1324503,-2.3275968,0.1328540,0.0677251,-2.5316756,52.1324467,-2.3275957,0.1365821,0.0691789,-2.2405171
-1615570134,52.1324503,-2.3275967,0.1328811,0.0706532,-2.1892042,52.1324468,-2.3275957,0.1365800,0.0691820,-2.2405705
-1615570135,52.1324504,-2.3275967,0.1310975,0.0638218,-1.4268085,52.1324469,-2.3275958,0.1365715,0.0691755,-2.2405417
-1615570135,52.1324506,-2.3275966,0.1350970,0.0706532,-2.3131793,52.1324469,-2.3275958,0.1365804,0.0691705,-2.2404203
-1615570135,52.1324507,-2.3275966,0.1348255,0.0679691,-2.1541965,52.1324470,-2.3275958,0.1365826,0.0691705,-2.2404053
-1615570136,52.1324508,-2.3275966,0.1313645,0.0662612,-2.3496885,52.1324470,-2.3275958,0.1365801,0.0691730,-2.2404544
-1615570136,52.1324509,-2.3275966,0.1271933,0.0674811,-2.6104813,52.1324471,-2.3275958,0.1365725,0.0691645,-2.2403932
-1615570136,52.1324510,-2.3275966,0.1284231,0.0674811,-2.4143517,52.1324472,-2.3275958,0.1365778,0.0691673,-2.2403953
-1615570137,52.1324512,-2.3275965,0.1310955,0.0635778,-2.6334715,52.1324472,-2.3275958,0.1365764,0.0691670,-2.2403998
-1615570137,52.1324513,-2.3275965,0.1350923,0.0701652,-2.1102154,52.1324473,-2.3275958,0.1365840,0.0691680,-2.2403646
-1615570138,52.1324515,-2.3275964,0.1296509,0.0672371,-2.3421731,52.1324473,-2.3275958,0.1365885,0.0691727,-2.2403955
-1615570138,52.1324516,-2.3275964,0.1348555,0.0711413,-2.8645546,52.1324474,-2.3275959,0.1365885,0.0691689,-2.2403462
-1615570138,52.1324517,-2.3275963,0.1318502,0.0655293,-2.4888752,52.1324475,-2.3275959,0.1365973,0.0691631,-2.2402143
-1615570139,52.1324519,-2.3275964,0.1318631,0.0669931,-2.4119592,52.1324475,-2.3275959,0.1365965,0.0691651,-2.2402453
-1615570139,52.1324520,-2.3275962,0.1328302,0.0650414,-2.3279402,52.1324476,-2.3275959,0.1365904,0.0691620,-2.2402446
-1615570139,52.1324521,-2.3275962,0.1311228,0.0667492,-2.1999719,52.1324476,-2.3275959,0.1365876,0.0691636,-2.2402833
-1615570140,52.1324522,-2.3275961,0.1348034,0.0655293,-2.3662961,52.1324477,-2.3275959,0.1365810,0.0691719,-2.2404332
-1615570140,52.1324524,-2.3275960,0.1338297,0.0667492,-2.5057240,52.1324478,-2.3275959,0.1365814,0.0691801,-2.2405369
-1615570141,52.1324525,-2.3275959,0.1348187,0.0672371,-2.1167111,52.1324478,-2.3275959,0.1365833,0.0691796,-2.2405186
-1615570141,52.1324526,-2.3275958,0.1313863,0.0687011,-3.0249515,52.1324479,-2.3275959,0.1365817,0.0691743,-2.2404604
-1615570141,52.1324528,-2.3275958,0.1289368,0.0699211,-3.0053842,52.1324479,-2.3275959,0.1365799,0.0691745,-2.2404747
-1615570142,52.1324529,-2.3275957,0.1333224,0.0650414,-2.5427642,52.1324480,-2.3275959,0.1365734,0.0691689,-2.2404439
-1615570142,52.1324530,-2.3275957,0.1345380,0.0633339,-2.5885124,52.1324481,-2.3275959,0.1365735,0.0691697,-2.2404542
-1615570142,52.1324531,-2.3275956,0.1323574,0.0672371,-1.6751237,52.1324481,-2.3275959,0.1365670,0.0691728,-2.2405360
-1615570143,52.1324532,-2.3275956,0.1316214,0.0674811,-1.9684552,52.1324482,-2.3275959,0.1365631,0.0691683,-2.2405033
-1615570143,52.1324533,-2.3275955,0.1303636,0.0643096,-2.4149766,52.1324482,-2.3275959,0.1365715,0.0691731,-2.2405105
-1615570144,52.1324534,-2.3275954,0.1323596,0.0674811,-2.5633664,52.1324483,-2.3275959,0.1365729,0.0691802,-2.2405932
-1615570144,52.1324535,-2.3275953,0.1343354,0.0682131,-2.0951362,52.1324484,-2.3275959,0.1365771,0.0691803,-2.2405672
-1615570144,52.1324536,-2.3275951,0.1299210,0.0699211,-2.2883799,52.1324484,-2.3275958,0.1365724,0.0691773,-2.2405591
-1615570145,52.1324537,-2.3275951,0.1360915,0.0716294,-2.3243790,52.1324485,-2.3275958,0.1365678,0.0691659,-2.2404423
-1615570145,52.1324539,-2.3275950,0.1313581,0.0655293,-1.4779078,52.1324485,-2.3275958,0.1365682,0.0691686,-2.2404737
-1615570145,52.1324540,-2.3275949,0.1318631,0.0669931,-2.2876916,52.1324486,-2.3275958,0.1365707,0.0691650,-2.2404118
-1615570146,52.1324541,-2.3275949,0.1306637,0.0704092,-2.2942529,52.1324487,-2.3275958,0.1365713,0.0691698,-2.2404702
-1615570146,52.1324541,-2.3275948,0.1326013,0.0669931,-2.1643457,52.1324487,-2.3275958,0.1365696,0.0691756,-2.2405548
-1615570147,52.1324542,-2.3275947,0.1320754,0.0630900,-1.9254153,52.1324488,-2.3275958,0.1365615,0.0691818,-2.2406867
-1615570147,52.1324543,-2.3275947,0.1328562,0.0679691,-2.9302478,52.1324488,-2.3275958,0.1365620,0.0691815,-2.2406797
-1615570147,52.1324544,-2.3275945,0.1370168,0.0652854,-2.0170598,52.1324489,-2.3275958,0.1365707,0.0691799,-2.2406027
-1615570148,52.1324545,-2.3275944,0.1331068,0.0684571,-1.7620080,52.1324490,-2.3275957,0.1365697,0.0691859,-2.2406864
-1615570148,52.1324546,-2.3275944,0.1350452,0.0650414,-2.3920588,52.1324490,-2.3275957,0.1365621,0.0691763,-2.2406125
-1615570148,52.1324546,-2.3275943,0.1323934,0.0711413,-2.5726929,52.1324491,-2.3275957,0.1365662,0.0691855,-2.2407041
-1615570149,52.1324547,-2.3275943,0.1333441,0.0674811,-2.2675862,52.1324491,-2.3275957,0.1365536,0.0691866,-2.2407997
-1615570149,52.1324547,-2.3275941,0.1345704,0.0669931,-2.3421917,52.1324492,-2.3275957,0.1365537,0.0691827,-2.2407498
-1615570150,52.1324547,-2.3275939,0.1316257,0.0679691,-2.2523510,52.1324492,-2.3275957,0.1365589,0.0691754,-2.2406220
-1615570150,52.1324548,-2.3275939,0.1328053,0.0621144,-2.3802977,52.1324493,-2.3275957,0.1365515,0.0691786,-2.2407107
-1615570150,52.1324548,-2.3275938,0.1328905,0.0716294,-2.5453339,52.1324493,-2.3275956,0.1365574,0.0691774,-2.2406569
-1615570151,52.1324548,-2.3275937,0.1308598,0.0647975,-1.8173083,52.1324494,-2.3275956,0.1365710,0.0691786,-2.2405849
-1615570151,52.1324548,-2.3275937,0.1306525,0.0691891,-2.4269395,52.1324495,-2.3275956,0.1365795,0.0691928,-2.2407112
-1615570151,52.1324548,-2.3275936,0.1368021,0.0687011,-2.1099958,52.1324495,-2.3275956,0.1365712,0.0691953,-2.2407975
-1615570152,52.1324547,-2.3275935,0.1343025,0.0645536,-2.8171000,52.1324495,-2.3275956,0.1365738,0.0691858,-2.2406580
-1615570152,52.1324547,-2.3275933,0.1315895,0.0638218,-2.1470723,52.1324496,-2.3275955,0.1365750,0.0691886,-2.2406871
-1615570153,52.1324547,-2.3275932,0.1306285,0.0665052,-2.0586441,52.1324496,-2.3275955,0.1365837,0.0691952,-2.2407146
-1615570153,52.1324547,-2.3275932,0.1303846,0.0667492,-1.9961468,52.1324497,-2.3275955,0.1365867,0.0691968,-2.2407172
-1615570153,52.1324547,-2.3275930,0.1355396,0.0652854,-2.3752279,52.1324497,-2.3275955,0.1365903,0.0691940,-2.2406564
-1615570154,52.1324547,-2.3275929,0.1338543,0.0694331,-1.9694464,52.1324498,-2.3275955,0.1365804,0.0691827,-2.2405767
-1615570154,52.1324547,-2.3275929,0.1338543,0.0694331,-2.5141602,52.1324498,-2.3275954,0.1365856,0.0691772,-2.2404714
-1615570154,52.1324546,-2.3275928,0.1304042,0.0689451,-2.0157888,52.1324499,-2.3275954,0.1365867,0.0691719,-2.2403963
-1615570155,52.1324546,-2.3275927,0.1328453,0.0667492,-2.1834416,52.1324499,-2.3275954,0.1365846,0.0691770,-2.2404761
-1615570155,52.1324546,-2.3275926,0.1323981,0.0716294,-2.6166158,52.1324499,-2.3275954,0.1365944,0.0691799,-2.2404490
-1615570156,52.1324546,-2.3275926,0.1369910,0.0623583,-1.7140676,52.1324500,-2.3275953,0.1366026,0.0691796,-2.2403924
-1615570156,52.1324545,-2.3275924,0.1323509,0.0665052,-1.9572725,52.1324500,-2.3275953,0.1365927,0.0691749,-2.2403955
-1615570156,52.1324545,-2.3275923,0.1326350,0.0706532,-2.5905612,52.1324501,-2.3275953,0.1365941,0.0691680,-2.2402978
-1615570157,52.1324544,-2.3275921,0.1294333,0.0704092,-2.4004693,52.1324501,-2.3275953,0.1366079,0.0691781,-2.2403390
-1615570157,52.1324544,-2.3275919,0.1335814,0.0665052,-2.5066123,52.1324501,-2.3275952,0.1365988,0.0691848,-2.2404842
-1615570157,52.1324544,-2.3275919,0.1338039,0.0638218,-2.3639362,52.1324502,-2.3275952,0.1366012,0.0691773,-2.2403717
-1615570158,52.1324543,-2.3275917,0.1330870,0.0662612,-2.2830789,52.1324502,-2.3275952,0.1365860,0.0691666,-2.2403338
-1615570158,52.1324543,-2.3275916,0.1331250,0.0704092,-2.5217464,52.1324502,-2.3275952,0.1365881,0.0691734,-2.2404070
-1615570159,52.1324543,-2.3275915,0.1323552,0.0669931,-2.1908271,52.1324503,-2.3275951,0.1365891,0.0691686,-2.2403381
-1615570159,52.1324543,-2.3275914,0.1323381,0.0650414,-2.3816442,52.1324503,-2.3275951,0.1365844,0.0691653,-2.2403259
-1615570159,52.1324542,-2.3275912,0.1340758,0.0667492,-2.2649431,52.1324503,-2.3275951,0.1365912,0.0691661,-2.2402930
-1615570160,52.1324542,-2.3275911,0.1333620,0.0694331,-3.0157323,52.1324504,-2.3275950,0.1365929,0.0691740,-2.2403824
-1615570160,52.1324542,-2.3275909,0.1313775,0.0677251,-2.0350714,52.1324504,-2.3275950,0.1366013,0.0691684,-2.2402570
-1615570160,52.1324541,-2.3275908,0.1318740,0.0682131,-2.0407996,52.1324504,-2.3275950,0.1365983,0.0691724,-2.2403271
-1615570161,52.1324540,-2.3275906,0.1303889,0.0672371,-2.8254428,52.1324505,-2.3275949,0.1366123,0.0691794,-2.2403266
-1615570161,52.1324539,-2.3275906,0.1289480,0.0711413,-2.2397137,52.1324505,-2.3275949,0.1366322,0.0691775,-2.2401731
-1615570162,52.1324539,-2.3275904,0.1298758,0.0647975,-2.2217121,52.1324505,-2.3275949,0.1366412,0.0691777,-2.2401171
-1615570162,52.1324538,-2.3275903,0.1338232,0.0660173,-2.6996467,52.1324505,-2.3275948,0.1366357,0.0691745,-2.2401116
-1615570162,52.1324536,-2.3275902,0.1358013,0.0669931,-2.2160804,52.1324505,-2.3275948,0.1366305,0.0691826,-2.2402496
-1615570163,52.1324536,-2.3275901,0.1318609,0.0667492,-2.3649721,52.1324506,-2.3275948,0.1366356,0.0691751,-2.2401204
-1615570163,52.1324535,-2.3275900,0.1306503,0.0689451,-2.1441526,52.1324506,-2.3275947,0.1366301,0.0691736,-2.2401361
-1615570163,52.1324534,-2.3275899,0.1330741,0.0647975,-2.0008790,52.1324506,-2.3275947,0.1366231,0.0691750,-2.2401998
-1615570164,52.1324533,-2.3275897,0.1333015,0.0626022,-2.1749415,52.1324506,-2.3275947,0.1366233,0.0691721,-2.2401609
-1615570164,52.1324532,-2.3275894,0.1326101,0.0679691,-2.4070923,52.1324507,-2.3275946,0.1366082,0.0691742,-2.2402864
-1615570165,52.1324532,-2.3275893,0.1372786,0.0669931,-2.2870653,52.1324507,-2.3275946,0.1366021,0.0691707,-2.2402806
-1615570165,52.1324532,-2.3275890,0.1358357,0.0706532,-2.2221096,52.1324507,-2.3275946,0.1365910,0.0691719,-2.2403686
-1615570165,52.1324530,-2.3275890,0.1313930,0.0694331,-1.9523715,52.1324507,-2.3275945,0.1365978,0.0691779,-2.2404010
-1615570166,52.1324529,-2.3275888,0.1316459,0.0701652,-2.2655714,52.1324507,-2.3275945,0.1365957,0.0691832,-2.2404821
-1615570166,52.1324529,-2.3275885,0.1338188,0.0655293,-2.3220558,52.1324507,-2.3275944,0.1365958,0.0691841,-2.2404928
-1615570166,52.1324528,-2.3275883,0.1301365,0.0665052,-2.3778412,52.1324508,-2.3275944,0.1365939,0.0691736,-2.2403710
-1615570167,52.1324528,-2.3275881,0.1301302,0.0657733,-1.8334335,52.1324508,-2.3275944,0.1365916,0.0691600,-2.2402117
-1615570167,52.1324527,-2.3275879,0.1363378,0.0716294,-2.2457335,52.1324508,-2.3275943,0.1366021,0.0691586,-2.2401257
-1615570168,52.1324527,-2.3275877,0.1355506,0.0665052,-1.9171042,52.1324508,-2.3275943,0.1366012,0.0691429,-2.2399302
-1615570168,52.1324526,-2.3275875,0.1333530,0.0684571,-2.3090680,52.1324508,-2.3275942,0.1365967,0.0691405,-2.2399271
-1615570168,52.1324526,-2.3275873,0.1323729,0.0689451,-2.4165301,52.1324508,-2.3275942,0.1366141,0.0691486,-2.2399187
-1615570169,52.1324525,-2.3275871,0.1343354,0.0682131,-2.0109262,52.1324508,-2.3275941,0.1366080,0.0691427,-2.2398827
-1615570169,52.1324525,-2.3275868,0.1313775,0.0677251,-1.9127351,52.1324508,-2.3275941,0.1366089,0.0691470,-2.2399325
-1615570169,52.1324525,-2.3275866,0.1355332,0.0645536,-2.5088451,52.1324508,-2.3275940,0.1366064,0.0691584,-2.2400939
-1615570170,52.1324525,-2.3275864,0.1301516,0.0682131,-2.7318234,52.1324509,-2.3275940,0.1366200,0.0691503,-2.2399030
-1615570170,52.1324524,-2.3275863,0.1350282,0.0630900,-2.5715742,52.1324509,-2.3275939,0.1366134,0.0691486,-2.2399235
-1615570171,52.1324525,-2.3275861,0.1343653,0.0713854,-2.2604742,52.1324509,-2.3275939,0.1366290,0.0691430,-2.2397504
-1615570171,52.1324525,-2.3275859,0.1325948,0.0662612,-1.9844140,52.1324509,-2.3275938,0.1366251,0.0691456,-2.2398090
-1615570171,52.1324525,-2.3275857,0.1321201,0.0682131,-2.3210015,52.1324509,-2.3275938,0.1366341,0.0691598,-2.2399333
-1615570172,52.1324524,-2.3275855,0.1335749,0.0657733,-2.5355263,52.1324509,-2.3275937,0.1366300,0.0691649,-2.2400243
-1615570172,52.1324524,-2.3275853,0.1338275,0.0665052,-2.2476704,52.1324509,-2.3275937,0.1366325,0.0691643,-2.2400005
-1615570172,52.1324525,-2.3275851,0.1311536,0.0701652,-2.2183847,52.1324509,-2.3275936,0.1366384,0.0691867,-2.2402487
-1615570173,52.1324525,-2.3275850,0.1321070,0.0667492,-2.2982335,52.1324509,-2.3275936,0.1366445,0.0691952,-2.2403183
-1615570173,52.1324525,-2.3275849,0.1350240,0.0626022,-2.2136791,52.1324509,-2.3275935,0.1366521,0.0692036,-2.2403758
-1615570174,52.1324525,-2.3275847,0.1291740,0.0689451,-2.2968860,52.1324510,-2.3275935,0.1366475,0.0692001,-2.2403610
-1615570174,52.1324526,-2.3275846,0.1313731,0.0672371,-2.3246839,52.1324510,-2.3275934,0.1366615,0.0691974,-2.2402360
-1615570174,52.1324525,-2.3275846,0.1286712,0.0677251,-2.9724810,52.1324510,-2.3275934,0.1366508,0.0692000,-2.2403383
-1615570175,52.1324526,-2.3275846,0.1311292,0.0674811,-2.4919851,52.1324510,-2.3275933,0.1366453,0.0691973,-2.2403393
-1615570175,52.1324527,-2.3275845,0.1345529,0.0650414,-2.0921221,52.1324510,-2.3275933,0.1366437,0.0691862,-2.2402084
-1615570175,52.1324527,-2.3275846,0.1311228,0.0667492,-2.1829970,52.1324510,-2.3275932,0.1366371,0.0691959,-2.2403746
-1615570176,52.1324527,-2.3275845,0.1340825,0.0674811,-2.7984738,52.1324510,-2.3275932,0.1366420,0.0692005,-2.2404022
-1615570176,52.1324528,-2.3275844,0.1286798,0.0687011,-2.4209366,52.1324510,-2.3275931,0.1366531,0.0691968,-2.2402830
-1615570177,52.1324528,-2.3275843,0.1363142,0.0691891,-1.6483883,52.1324510,-2.3275931,0.1366552,0.0692002,-2.2403123
-1615570177,52.1324529,-2.3275842,0.1367952,0.0679691,-2.4058571,52.1324510,-2.3275930,0.1366505,0.0692064,-2.2404227
-1615570177,52.1324529,-2.3275841,0.1363166,0.0694331,-2.3605881,52.1324511,-2.3275930,0.1366508,0.0692070,-2.2404282
-1615570178,52.1324529,-2.3275839,0.1313581,0.0655293,-2.0211000,52.1324511,-2.3275929,0.1366450,0.0692175,-2.2405999
-1615570178,52.1324531,-2.3275837,0.1355204,0.0630900,-2.1710260,52.1324511,-2.3275929,0.1366468,0.0692118,-2.2405152
-1615570178,52.1324532,-2.3275836,0.1333375,0.0667492,-2.5156808,52.1324511,-2.3275928,0.1366471,0.0692046,-2.2404218
-1615570179,52.1324533,-2.3275835,0.1308986,0.0691891,-2.2075405,52.1324511,-2.3275928,0.1366374,0.0692023,-2.2404544
-1615570179,52.1324533,-2.3275834,0.1289390,0.0701652,-2.4062722,52.1324511,-2.3275927,0.1366402,0.0691901,-2.2402811
-1615570180,52.1324534,-2.3275833,0.1320962,0.0655293,-2.3578486,52.1324511,-2.3275927,0.1366377,0.0691728,-2.2400746
-1615570180,52.1324535,-2.3275833,0.1330914,0.0667492,-2.4887967,52.1324511,-2.3275926,0.1366339,0.0691752,-2.2401304
-1615570180,52.1324535,-2.3275832,0.1325799,0.0645536,-2.0185785,52.1324511,-2.3275925,0.1366519,0.0691828,-2.2401121
-1615570181,52.1324535,-2.3275831,0.1338566,0.0696771,-2.2975347,52.1324512,-2.3275925,0.1366354,0.0691990,-2.2404253
-1615570181,52.1324535,-2.3275831,0.1313863,0.0687011,-2.2631330,52.1324512,-2.3275924,0.1366560,0.0691999,-2.2403028
-1615570181,52.1324536,-2.3275830,0.1335902,0.0674811,-2.1770658,52.1324512,-2.3275924,0.1366751,0.0692003,-2.2401848
-1615570182,52.1324536,-2.3275830,0.1333309,0.0660173,-2.3493211,52.1324512,-2.3275923,0.1366666,0.0691848,-2.2400422
-1615570182,52.1324536,-2.3275830,0.1321246,0.0687011,-2.5082340,52.1324512,-2.3275923,0.1366498,0.0691905,-2.2402236
-1615570183,52.1324537,-2.3275828,0.1308598,0.0647975,-2.6083040,52.1324512,-2.3275922,0.1366417,0.0691870,-2.2402306
-1615570183,52.1324537,-2.3275827,0.1311037,0.0645536,-2.2972150,52.1324512,-2.3275922,0.1366372,0.0691827,-2.2402050
-1615570183,52.1324538,-2.3275826,0.1281150,0.0599194,-2.3047895,52.1324513,-2.3275921,0.1366264,0.0691802,-2.2402425
-1615570184,52.1324539,-2.3275825,0.1382524,0.0657733,-2.4432697,52.1324513,-2.3275921,0.1366338,0.0691745,-2.2401218
-1615570184,52.1324539,-2.3275824,0.1328323,0.0652854,-2.2512569,52.1324513,-2.3275920,0.1366214,0.0691952,-2.2404659
-1615570184,52.1324539,-2.3275823,0.1328366,0.0657733,-2.1699266,52.1324513,-2.3275920,0.1366068,0.0691884,-2.2404742
-1615570185,52.1324540,-2.3275822,0.1318875,0.0696771,-2.1599135,52.1324513,-2.3275919,0.1366196,0.0691959,-2.2404864
-1615570185,52.1324541,-2.3275820,0.1340758,0.0667492,-2.4239812,52.1324513,-2.3275919,0.1366110,0.0691767,-2.2402978
-1615570186,52.1324541,-2.3275819,0.1321005,0.0660173,-2.4149854,52.1324513,-2.3275918,0.1366119,0.0691852,-2.2403998
-1615570186,52.1324542,-2.3275817,0.1313645,0.0662612,-2.0389190,52.1324513,-2.3275918,0.1366227,0.0691927,-2.2404261
-1615570186,52.1324542,-2.3275815,0.1303846,0.0667492,-1.9688252,52.1324514,-2.3275917,0.1366258,0.0692029,-2.2405362
-1615570187,52.1324542,-2.3275813,0.1338341,0.0672371,-2.6255960,52.1324514,-2.3275917,0.1366410,0.0692168,-2.2406156
-1615570187,52.1324543,-2.3275813,0.1357968,0.0665052,-2.1048677,52.1324514,-2.3275916,0.1366519,0.0692357,-2.2407856
-1615570187,52.1324543,-2.3275812,0.1318674,0.0674811,-1.7796772,52.1324514,-2.3275916,0.1366605,0.0692462,-2.2408643
-1615570188,52.1324543,-2.3275812,0.1343198,0.0665052,-2.2412047,52.1324514,-2.3275915,0.1366632,0.0692544,-2.2409518
-1615570188,52.1324543,-2.3275811,0.1301538,0.0684571,-2.4969780,52.1324514,-2.3275915,0.1366761,0.0692534,-2.2408566
-1615570189,52.1324544,-2.3275811,0.1318588,0.0665052,-2.3383005,52.1324514,-2.3275914,0.1366909,0.0692419,-2.2406135
-1615570189,52.1324543,-2.3275810,0.1308661,0.0655293,-2.0703378,52.1324515,-2.3275914,0.1366984,0.0692543,-2.2407231
-1615570189,52.1324544,-2.3275809,0.1333375,0.0667492,-2.8387351,52.1324515,-2.3275913,0.1366796,0.0692673,-2.2410102
-1615570190,52.1324545,-2.3275808,0.1343286,0.0674811,-2.3503270,52.1324515,-2.3275913,0.1366872,0.0692771,-2.2410865
-1615570190,52.1324545,-2.3275808,0.1333331,0.0662612,-2.2559257,52.1324515,-2.3275912,0.1366795,0.0692798,-2.2411699
-1615570190,52.1324546,-2.3275807,0.1313841,0.0684571,-2.5324993,52.1324515,-2.3275912,0.1366769,0.0692642,-2.2409887
-1615570191,52.1324546,-2.3275806,0.1313602,0.0657733,-2.1866543,52.1324515,-2.3275911,0.1366552,0.0692656,-2.2411454
-1615570191,52.1324547,-2.3275806,0.1326079,0.0677251,-2.1945779,52.1324515,-2.3275911,0.1366599,0.0692507,-2.2409246
-1615570192,52.1324547,-2.3275807,0.1337874,0.0618705,-2.2473733,52.1324516,-2.3275910,0.1366618,0.0692381,-2.2407520
-1615570192,52.1324548,-2.3275806,0.1360386,0.0660173,-2.4784210,52.1324516,-2.3275910,0.1366585,0.0692443,-2.2408528
-1615570192,52.1324548,-2.3275806,0.1313930,0.0694331,-1.5640712,52.1324516,-2.3275909,0.1366745,0.0692427,-2.2407293
-1615570193,52.1324549,-2.3275808,0.1316257,0.0679691,-2.1582682,52.1324516,-2.3275909,0.1366624,0.0692335,-2.2406893
-1615570193,52.1324550,-2.3275809,0.1306180,0.0652854,-2.4556203,52.1324516,-2.3275908,0.1366591,0.0692330,-2.2407043
-1615570193,52.1324551,-2.3275810,0.1318418,0.0645536,-2.1739211,52.1324516,-2.3275908,0.1366628,0.0692454,-2.2408390
-1615570194,52.1324553,-2.3275811,0.1301344,0.0662612,-2.1698589,52.1324517,-2.3275908,0.1366683,0.0692433,-2.2407765
-1615570194,52.1324554,-2.3275813,0.1350808,0.0689451,-2.2851436,52.1324517,-2.3275907,0.1366850,0.0692204,-2.2403769
-1615570195,52.1324555,-2.3275813,0.1343176,0.0662612,-2.1598876,52.1324517,-2.3275907,0.1366740,0.0692220,-2.2404683
-1615570195,52.1324556,-2.3275814,0.1282166,0.0718735,-2.4704435,52.1324517,-2.3275906,0.1366768,0.0692248,-2.2404852
-1615570195,52.1324557,-2.3275816,0.1313731,0.0672371,-2.6784453,52.1324517,-2.3275906,0.1367023,0.0692411,-2.2405298
-1615570196,52.1324558,-2.3275818,0.1335621,0.0643096,-2.5641968,52.1324517,-2.3275905,0.1367007,0.0692454,-2.2405949
-1615570196,52.1324558,-2.3275819,0.1323729,0.0689451,-2.4532020,52.1324518,-2.3275905,0.1366942,0.0692504,-2.2407000
-1615570196,52.1324560,-2.3275820,0.1306180,0.0652854,-2.0331974,52.1324518,-2.3275905,0.1367145,0.0692659,-2.2407672
-1615570197,52.1324561,-2.3275820,0.1313753,0.0674811,-2.7194386,52.1324518,-2.3275904,0.1367055,0.0692608,-2.2407608
-1615570197,52.1324562,-2.3275822,0.1311058,0.0647975,-2.1955631,52.1324518,-2.3275904,0.1367013,0.0692622,-2.2408049
-1615570198,52.1324562,-2.3275823,0.1296340,0.0652854,-2.5116186,52.1324518,-2.3275904,0.1366809,0.0692530,-2.2408197
-1615570198,52.1324563,-2.3275824,0.1316170,0.0669931,-2.1880031,52.1324519,-2.3275903,0.1366806,0.0692693,-2.2410293
-1615570198,52.1324564,-2.3275826,0.1328585,0.0682131,-1.8102790,52.1324519,-2.3275903,0.1366843,0.0692549,-2.2408216
-1615570199,52.1324563,-2.3275826,0.1320941,0.0652854,-1.9279186,52.1324519,-2.3275903,0.1366927,0.0692908,-2.2412262
-1615570199,52.1324564,-2.3275826,0.1281771,0.0674811,-1.8788208,52.1324519,-2.3275902,0.1366758,0.0692833,-2.2412386
-1615570199,52.1324564,-2.3275827,0.1298863,0.0660173,-2.2142694,52.1324519,-2.3275902,0.1366723,0.0692753,-2.2411594
-1615570200,52.1324564,-2.3275827,0.1323402,0.0652854,-2.3680644,52.1324520,-2.3275902,0.1366628,0.0692884,-2.2413878
-1615570200,52.1324564,-2.3275828,0.1333441,0.0674811,-2.1416981,52.1324520,-2.3275901,0.1366585,0.0692735,-2.2412245
-1615570201,52.1324564,-2.3275829,0.1342878,0.0628461,-1.4787588,52.1324520,-2.3275901,0.1366605,0.0692953,-2.2414918
-1615570201,52.1324564,-2.3275830,0.1284360,0.0689451,3.1156123,52.1324520,-2.3275901,0.1366543,0.0692983,-2.2415693
-1615570201,52.1324565,-2.3275831,0.1301451,0.0674811,-2.6404147,52.1324520,-2.3275900,0.1366426,0.0693070,-2.2417562
-1615570202,52.1324565,-2.3275831,0.1333353,0.0665052,-1.9200867,52.1324520,-2.3275900,0.1366279,0.0693166,-2.2419729
-1615570202,52.1324565,-2.3275833,0.1345572,0.0655293,-2.4814672,52.1324521,-2.3275900,0.1366126,0.0693010,-2.2418718
-1615570202,52.1324565,-2.3275834,0.1338408,0.0679691,-2.0950692,52.1324521,-2.3275900,0.1366350,0.0693054,-2.2417841
-1615570203,52.1324565,-2.3275833,0.1318481,0.0652854,-1.6532971,52.1324521,-2.3275899,0.1366369,0.0693031,-2.2417419
-1615570203,52.1324566,-2.3275834,0.1318631,0.0669931,-2.2908843,52.1324521,-2.3275899,0.1366214,0.0693125,-2.2419620
-1615570204,52.1324565,-2.3275836,0.1337854,0.0616266,-2.2467303,52.1324521,-2.3275899,0.1366036,0.0693051,-2.2419829
-1615570204,52.1324566,-2.3275836,0.1333441,0.0674811,-2.2654483,52.1324522,-2.3275899,0.1366060,0.0693052,-2.2419684
-1615570204,52.1324566,-2.3275836,0.1301693,0.0701652,-2.4788494,52.1324522,-2.3275898,0.1366236,0.0692959,-2.2417355
-1615570205,52.1324566,-2.3275837,0.1320857,0.0643096,-1.9615943,52.1324522,-2.3275898,0.1366213,0.0693079,-2.2419043
-1615570205,52.1324567,-2.3275836,0.1303595,0.0638218,3.0139654,52.1324522,-2.3275898,0.1366010,0.0693100,-2.2420611
-1615570205,52.1324567,-2.3275835,0.1355204,0.0630900,-2.3336208,52.1324522,-2.3275897,0.1366089,0.0693201,-2.2421403
-1615570206,52.1324568,-2.3275834,0.1306200,0.0655293,-2.4698887,52.1324522,-2.3275897,0.1366214,0.0693451,-2.2423797
-1615570206,52.1324568,-2.3275834,0.1338297,0.0667492,-2.2689328,52.1324523,-2.3275897,0.1366103,0.0693528,-2.2425506
-1615570207,52.1324568,-2.3275833,0.1313710,0.0669931,-2.8692055,52.1324523,-2.3275897,0.1365873,0.0693494,-2.2426543
-1615570207,52.1324568,-2.3275835,0.1316235,0.0677251,-2.3238697,52.1324523,-2.3275896,0.1365913,0.0693394,-2.2425003
-1615570207,52.1324568,-2.3275835,0.1333309,0.0660173,-2.2724562,52.1324523,-2.3275896,0.1365978,0.0693523,-2.2426243
-1615570208,52.1324567,-2.3275835,0.1323707,0.0687011,-2.0868592,52.1324523,-2.3275896,0.1365993,0.0693294,-2.2423205
-1615570208,52.1324568,-2.3275836,0.1301494,0.0679691,-2.3781524,52.1324524,-2.3275896,0.1366159,0.0693198,-2.2420909
-1615570208,52.1324567,-2.3275838,0.1328155,0.0633339,-1.5882745,52.1324524,-2.3275896,0.1366253,0.0692938,-2.2416980
-1615570209,52.1324567,-2.3275838,0.1325799,0.0645536,-2.5377560,52.1324524,-2.3275895,0.1366279,0.0692737,-2.2414231
-1615570209,52.1324568,-2.3275839,0.1365536,0.0684571,-2.3686609,52.1324524,-2.3275895,0.1366158,0.0692883,-2.2416878
-1615570210,52.1324568,-2.3275839,0.1316235,0.0677251,-2.3299279,52.1324524,-2.3275895,0.1365879,0.0693224,-2.2423048
-1615570210,52.1324568,-2.3275840,0.1330935,0.0669931,-2.2977495,52.1324524,-2.3275895,0.1365724,0.0693278,-2.2424738
-1615570210,52.1324568,-2.3275840,0.1291421,0.0652854,-2.6600530,52.1324525,-2.3275894,0.1365784,0.0693369,-2.2425520
-1615570211,52.1324568,-2.3275842,0.1350946,0.0704092,-1.7540790,52.1324525,-2.3275894,0.1365960,0.0693254,-2.2422915
-1615570211,52.1324569,-2.3275842,0.1338124,0.0647975,-2.1093497,52.1324525,-2.3275894,0.1366107,0.0693529,-2.2425487
-1615570211,52.1324570,-2.3275843,0.1323381,0.0650414,-2.1402543,52.1324525,-2.3275894,0.1366012,0.0693872,-2.2430491
-1615570212,52.1324570,-2.3275844,0.1326213,0.0691891,-2.5511227,52.1324525,-2.3275894,0.1365807,0.0693644,-2.2428882
-1615570212,52.1324570,-2.3275845,0.1311358,0.0682131,-2.2543743,52.1324525,-2.3275894,0.1366040,0.0693409,-2.2424383
-1615570213,52.1324571,-2.3275846,0.1340915,0.0684571,-2.5072351,52.1324526,-2.3275893,0.1365483,0.0693477,-2.2428842
-1615570213,52.1324572,-2.3275847,0.1367448,0.0623583,-1.7807058,52.1324526,-2.3275893,0.1365664,0.0693436,-2.2427149
-1615570213,52.1324572,-2.3275848,0.1318588,0.0665052,-2.8461485,52.1324526,-2.3275893,0.1365575,0.0693638,-2.2430296
-1615570214,52.1324572,-2.3275849,0.1338341,0.0672371,-2.4392536,52.1324526,-2.3275893,0.1365685,0.0693737,-2.2430854
-1615570214,52.1324572,-2.3275850,0.1316257,0.0679691,-2.2942030,52.1324526,-2.3275893,0.1365514,0.0693719,-2.2431743
-1615570214,52.1324573,-2.3275851,0.1333202,0.0647975,-2.3524060,52.1324526,-2.3275893,0.1365334,0.0693377,-2.2428510
-1615570215,52.1324573,-2.3275852,0.1328176,0.0635778,-2.3557246,52.1324527,-2.3275892,0.1365180,0.0693366,-2.2429368
-1615570215,52.1324573,-2.3275853,0.1328431,0.0665052,-2.4654365,52.1324527,-2.3275892,0.1365422,0.0693573,-2.2430458
-1615570216,52.1324574,-2.3275854,0.1355462,0.0660173,-1.8300527,52.1324527,-2.3275892,0.1365638,0.0693739,-2.2431192
-1615570216,52.1324574,-2.3275854,0.1311336,0.0679691,-1.8636492,52.1324527,-2.3275892,0.1365425,0.0693467,-2.2429080
-1615570216,52.1324574,-2.3275855,0.1299165,0.0694331,-2.5343645,52.1324527,-2.3275892,0.1365058,0.0693560,-2.2432632
-1615570217,52.1324574,-2.3275856,0.1323487,0.0662612,-2.5803475,52.1324527,-2.3275892,0.1364894,0.0693414,-2.2431822
-1615570217,52.1324575,-2.3275857,0.1358453,0.0716294,-2.4607196,52.1324528,-2.3275892,0.1364744,0.0693378,-2.2432327
-1615570217,52.1324575,-2.3275859,0.1331136,0.0691891,-2.3807130,52.1324528,-2.3275891,0.1364688,0.0693536,-2.2434707
-1615570218,52.1324576,-2.3275861,0.1331068,0.0684571,-2.1032009,52.1324528,-2.3275891,0.1364740,0.0693700,-2.2436471
-1615570218,52.1324576,-2.3275861,0.1303998,0.0684571,-1.9752029,52.1324528,-2.3275891,0.1364908,0.0693799,-2.2436662
-1615570219,52.1324577,-2.3275861,0.1350561,0.0662612,-2.2550347,52.1324528,-2.3275891,0.1364800,0.0693909,-2.2438765
-1615570219,52.1324577,-2.3275862,0.1340758,0.0667492,-1.3892667,52.1324528,-2.3275891,0.1364864,0.0693897,-2.2438204
-1615570219,52.1324578,-2.3275863,0.1340376,0.0623583,-2.1711519,52.1324529,-2.3275891,0.1364962,0.0694039,-2.2439382
-1615570220,52.1324578,-2.3275864,0.1328344,0.0655293,-2.3652000,52.1324529,-2.3275891,0.1364656,0.0693947,-2.2440181
-1615570220,52.1324579,-2.3275865,0.1328743,0.0699211,-2.3456264,52.1324529,-2.3275891,0.1364763,0.0693929,-2.2439263
-1615570220,52.1324580,-2.3275866,0.1340937,0.0687011,-2.5344665,52.1324529,-2.3275891,0.1364540,0.0693799,-2.2439027
-1615570221,52.1324580,-2.3275867,0.1335946,0.0679691,-2.4674587,52.1324529,-2.3275891,0.1364449,0.0693797,-2.2439587
-1615570221,52.1324581,-2.3275866,0.1335969,0.0682131,-2.2929771,52.1324529,-2.3275890,0.1364371,0.0693744,-2.2439411
-1615570222,52.1324581,-2.3275866,0.1338659,0.0706532,-2.6802871,52.1324530,-2.3275890,0.1364429,0.0693906,-2.2441108
-1615570222,52.1324583,-2.3275867,0.1318035,0.0599194,-2.1151710,52.1324530,-2.3275890,0.1364264,0.0694076,-2.2444344
-1615570222,52.1324583,-2.3275867,0.1352956,0.0655293,-2.2244890,52.1324530,-2.3275890,0.1364158,0.0693967,-2.2443643
-1615570223,52.1324583,-2.3275868,0.1298842,0.0657733,-2.5973349,52.1324530,-2.3275890,0.1364354,0.0693601,-2.2437682
-1615570223,52.1324584,-2.3275869,0.1293964,0.0662612,-2.7956066,52.1324530,-2.3275890,0.1364433,0.0693584,-2.2436953
-1615570223,52.1324584,-2.3275871,0.1321048,0.0665052,-2.2914295,52.1324531,-2.3275890,0.1364288,0.0693807,-2.2440758
-1615570224,52.1324585,-2.3275872,0.1325991,0.0667492,-2.4679234,52.1324531,-2.3275890,0.1364247,0.0693454,-2.2436495
-1615570224,52.1324585,-2.3275873,0.1330699,0.0643096,-2.2262337,52.1324531,-2.3275890,0.1364333,0.0693505,-2.2436588
-1615570225,52.1324586,-2.3275874,0.1313624,0.0660173,-2.7503817,52.1324531,-2.3275890,0.1364467,0.0693674,-2.2437892
-1615570225,52.1324586,-2.3275876,0.1279248,0.0667492,-2.8183186,52.1324531,-2.3275890,0.1364619,0.0693356,-2.2432828
-1615570225,52.1324586,-2.3275877,0.1330827,0.0657733,-2.4318881,52.1324531,-2.3275890,0.1364662,0.0693319,-2.2432089
-1615570226,52.1324587,-2.3275877,0.1313710,0.0669931,-2.1235209,52.1324532,-2.3275890,0.1364737,0.0693282,-2.2431128
-1615570226,52.1324588,-2.3275879,0.1333552,0.0687011,-2.0740891,52.1324532,-2.3275890,0.1364618,0.0692837,-2.2426188
-1615570226,52.1324588,-2.3275880,0.1333160,0.0643096,-2.0375166,52.1324532,-2.3275890,0.1364463,0.0692773,-2.2426369
-1615570227,52.1324589,-2.3275880,0.1330935,0.0669931,-2.1179461,52.1324532,-2.3275890,0.1364493,0.0692888,-2.2427645
-1615570227,52.1324589,-2.3275880,0.1338521,0.0691891,-2.7987201,52.1324532,-2.3275890,0.1364151,0.0692692,-2.2427349
-1615570228,52.1324590,-2.3275882,0.1325905,0.0657733,-2.4269123,52.1324533,-2.3275890,0.1364197,0.0692560,-2.2425351
-1615570228,52.1324590,-2.3275883,0.1333876,0.0721175,-2.1853187,52.1324533,-2.3275890,0.1364060,0.0692734,-2.2428470
-1615570228,52.1324591,-2.3275884,0.1347969,0.0647975,-2.2975640,52.1324533,-2.3275890,0.1363862,0.0692754,-2.2430000
-1615570229,52.1324592,-2.3275884,0.1306285,0.0665052,-2.3398316,52.1324533,-2.3275890,0.1363870,0.0692785,-2.2430351
-1615570229,52.1324594,-2.3275884,0.1311424,0.0689451,-2.2676022,52.1324533,-2.3275889,0.1363997,0.0692646,-2.2427740
-1615570229,52.1324594,-2.3275883,0.1333309,0.0660173,-2.7396483,52.1324533,-2.3275889,0.1363949,0.0692817,-2.2430246
-1615570230,52.1324594,-2.3275885,0.1318852,0.0694331,-2.6909285,52.1324534,-2.3275889,0.1363803,0.0692932,-2.2432666
-1615570230,52.1324595,-2.3275885,0.1323685,0.0684571,-2.5161014,52.1324534,-2.3275889,0.1364026,0.0692572,-2.2426608
-1615570231,52.1324596,-2.3275885,0.1330827,0.0657733,-2.1751575,52.1324534,-2.3275889,0.1363886,0.0692372,-2.2424948
-1615570231,52.1324596,-2.3275887,0.1326258,0.0696771,-2.2430964,52.1324534,-2.3275889,0.1363855,0.0692095,-2.2421598
-1615570231,52.1324597,-2.3275888,0.1328540,0.0677251,-2.0616441,52.1324534,-2.3275889,0.1363461,0.0692122,-2.2424481
-1615570232,52.1324599,-2.3275888,0.1333463,0.0677251,-2.4517143,52.1324535,-2.3275889,0.1363411,0.0692310,-2.2427211
-1615570232,52.1324600,-2.3275889,0.1335684,0.0650414,-1.7105603,52.1324535,-2.3275889,0.1364031,0.0692640,-2.2427447
-1615570232,52.1324600,-2.3275890,0.1333552,0.0687011,-2.5806451,52.1324535,-2.3275889,0.1364350,0.0692552,-2.2424266
-1615570233,52.1324601,-2.3275891,0.1330892,0.0665052,-2.3380773,52.1324535,-2.3275889,0.1364117,0.0692192,-2.2421145
-1615570233,52.1324601,-2.3275892,0.1350539,0.0660173,-2.3158622,52.1324535,-2.3275889,0.1364186,0.0692163,-2.2420330
-1615570234,52.1324602,-2.3275892,0.1303535,0.0630900,-1.9863197,52.1324536,-2.3275889,0.1364473,0.0691941,-2.2415626
-1615570234,52.1324603,-2.3275893,0.1338167,0.0652854,-1.8673408,52.1324536,-2.3275889,0.1364601,0.0691756,-2.2412434
-1615570234,52.1324604,-2.3275895,0.1336082,0.0694331,-2.1393948,52.1324536,-2.3275889,0.1365054,0.0691504,-2.2406273
-1615570235,52.1324606,-2.3275895,0.1291525,0.0665052,-2.8617196,52.1324536,-2.3275889,0.1365375,0.0691581,-2.2405186
-1615570235,52.1324607,-2.3275897,0.1338475,0.0687011,-2.4351029,52.1324537,-2.3275889,0.1365403,0.0691665,-2.2406092
-1615570235,52.1324608,-2.3275898,0.1350517,0.0657733,-2.2187335,52.1324537,-2.3275890,0.1364978,0.0691506,-2.2406788
-1615570236,52.1324610,-2.3275898,0.1348187,0.0672371,-1.9825875,52.1324537,-2.3275890,0.1365083,0.0691613,-2.2407486
-1615570236,52.1324610,-2.3275899,0.1335836,0.0667492,-2.1700604,52.1324537,-2.3275890,0.1364966,0.0691573,-2.2407732
-1615570237,52.1324612,-2.3275899,0.1291504,0.0662612,-1.8709248,52.1324537,-2.3275890,0.1364654,0.0691696,-2.2411327
-1615570237,52.1324613,-2.3275901,0.1318439,0.0647975,-2.1578612,52.1324538,-2.3275890,0.1364693,0.0691795,-2.2412338
-1615570237,52.1324614,-2.3275900,0.1325948,0.0662612,-2.1949804,52.1324538,-2.3275890,0.1365095,0.0691550,-2.2406607
-1615570238,52.1324616,-2.3275903,0.1294113,0.0679691,-2.1424787,52.1324538,-2.3275890,0.1364930,0.0691549,-2.2407658
-1615570238,52.1324617,-2.3275904,0.1320899,0.0647975,-2.3477659,52.1324538,-2.3275890,0.1364933,0.0691291,-2.2404332
-1615570238,52.1324618,-2.3275905,0.1291441,0.0655293,-2.1189046,52.1324539,-2.3275890,0.1364985,0.0691280,-2.2403851
-1615570239,52.1324619,-2.3275906,0.1320632,0.0616266,-2.1993330,52.1324539,-2.3275890,0.1365286,0.0691235,-2.2401321
-1615570239,52.1324621,-2.3275908,0.1330827,0.0657733,-2.3691382,52.1324539,-2.3275890,0.1365339,0.0691319,-2.2402062
-1615570240,52.1324623,-2.3275908,0.1318785,0.0687011,-2.6221287,52.1324539,-2.3275890,0.1365410,0.0690916,-2.2396436
-1615570240,52.1324624,-2.3275909,0.1296299,0.0647975,-2.0527639,52.1324540,-2.3275890,0.1365411,0.0690763,-2.2394462
-1615570240,52.1324624,-2.3275910,0.1363027,0.0679691,-2.4082704,52.1324540,-2.3275890,0.1365443,0.0690683,-2.2393236
-1615570241,52.1324625,-2.3275911,0.1340803,0.0672371,-2.1582947,52.1324540,-2.3275890,0.1365589,0.0690895,-2.2395008
-1615570241,52.1324627,-2.3275913,0.1343286,0.0674811,-2.3369367,52.1324540,-2.3275890,0.1365746,0.0690592,-2.2390108
-1615570241,52.1324627,-2.3275913,0.1328474,0.0669931,-2.1919184,52.1324541,-2.3275890,0.1366098,0.0690906,-2.2391865
-1615570242,52.1324628,-2.3275913,0.1345748,0.0674811,-2.0547817,52.1324541,-2.3275890,0.1366026,0.0690577,-2.2388110
-1615570242,52.1324630,-2.3275913,0.1335770,0.0660173,3.1227989,52.1324541,-2.3275890,0.1365939,0.0690528,-2.2388039
-1615570243,52.1324630,-2.3275914,0.1328302,0.0650414,-2.6326632,52.1324541,-2.3275890,0.1366398,0.0690417,-2.2383647
-1615570243,52.1324631,-2.3275914,0.1330957,0.0672371,-2.1703658,52.1324542,-2.3275891,0.1366473,0.0690196,-2.2380331
-1615570243,52.1324632,-2.3275914,0.1303678,0.0647975,-2.5406733,52.1324542,-2.3275891,0.1366298,0.0690144,-2.2380795
-1615570244,52.1324633,-2.3275914,0.1335749,0.0657733,-2.8111417,52.1324542,-2.3275891,0.1366099,0.0690351,-2.2384729
-1615570244,52.1324634,-2.3275914,0.1338145,0.0650414,-1.6873610,52.1324542,-2.3275891,0.1366348,0.0690564,-2.2385862
-1615570244,52.1324634,-2.3275914,0.1345770,0.0677251,-2.3927081,52.1324543,-2.3275891,0.1366499,0.0690440,-2.2383304
-1615570245,52.1324635,-2.3275913,0.1338232,0.0660173,-1.9919409,52.1324543,-2.3275891,0.1366712,0.0690544,-2.2383268
-1615570245,52.1324636,-2.3275912,0.1330784,0.0652854,-2.4736111,52.1324543,-2.3275891,0.1366948,0.0690700,-2.2383728
-1615570246,52.1324637,-2.3275912,0.1318718,0.0679691,-2.4593029,52.1324543,-2.3275891,0.1366710,0.0690943,-2.2388387
-1615570246,52.1324637,-2.3275912,0.1313666,0.0665052,-2.0195782,52.1324544,-2.3275891,0.1367012,0.0690994,-2.2387090
-1615570246,52.1324637,-2.3275912,0.1308703,0.0660173,-2.0813401,52.1324544,-2.3275891,0.1366829,0.0690949,-2.2387695
-1615570247,52.1324639,-2.3275913,0.1309143,0.0708973,-2.6203997,52.1324544,-2.3275891,0.1366427,0.0691180,-2.2393250
-1615570247,52.1324639,-2.3275912,0.1293985,0.0665052,-2.3742430,52.1324544,-2.3275891,0.1366220,0.0690913,-2.2391162
-1615570247,52.1324640,-2.3275912,0.1298948,0.0669931,-2.2680912,52.1324545,-2.3275891,0.1366349,0.0691003,-2.2391486
-1615570248,52.1324641,-2.3275911,0.1298863,0.0660173,-2.3172717,52.1324545,-2.3275891,0.1366081,0.0690876,-2.2391591
-1615570248,52.1324642,-2.3275911,0.1346022,0.0704092,2.5933774,52.1324545,-2.3275891,0.1366163,0.0691067,-2.2393503
-1615570249,52.1324642,-2.3275911,0.1308536,0.0640657,-2.1946912,52.1324545,-2.3275891,0.1366119,0.0690970,-2.2392540
-1615570249,52.1324643,-2.3275910,0.1325905,0.0657733,-2.3713048,52.1324546,-2.3275891,0.1365683,0.0691057,-2.2396474
-1615570249,52.1324643,-2.3275910,0.1335579,0.0638218,-2.4825187,52.1324546,-2.3275892,0.1365839,0.0690996,-2.2394674
-1615570250,52.1324644,-2.3275910,0.1340417,0.0628461,-2.4643645,52.1324546,-2.3275892,0.1365647,0.0691143,-2.2397814
-1615570250,52.1324644,-2.3275910,0.1320754,0.0630900,-2.2792120,52.1324547,-2.3275892,0.1365641,0.0691390,-2.2401023
-1615570250,52.1324645,-2.3275910,0.1335792,0.0662612,-2.0057530,52.1324547,-2.3275892,0.1365710,0.0691371,-2.2400324
-1615570251,52.1324646,-2.3275910,0.1323662,0.0682131,-2.3833389,52.1324547,-2.3275892,0.1365546,0.0691504,-2.2403090
-1615570251,52.1324646,-2.3275910,0.1348077,0.0660173,-1.9387301,52.1324547,-2.3275892,0.1365122,0.0691688,-2.2408187
-1615570252,52.1324646,-2.3275910,0.1288961,0.0652854,-2.0830896,52.1324548,-2.3275892,0.1364861,0.0691336,-2.2405362
-1615570252,52.1324647,-2.3275910,0.1350539,0.0660173,-1.9342046,52.1324548,-2.3275892,0.1364629,0.0691030,-2.2402916
-1615570252,52.1324647,-2.3275911,0.1333353,0.0665052,-2.1627121,52.1324548,-2.3275892,0.1363859,0.0691173,-2.2409742
-1615570253,52.1324647,-2.3275911,0.1330741,0.0647975,-2.5763791,52.1324548,-2.3275892,0.1363845,0.0691022,-2.2407882
-1615570253,52.1324648,-2.3275911,0.1321048,0.0665052,-2.3899012,52.1324549,-2.3275892,0.1363930,0.0691134,-2.2408786
-1615570253,52.1324648,-2.3275910,0.1318376,0.0640657,-2.2225955,52.1324549,-2.3275892,0.1364021,0.0691330,-2.2410715
-1615570254,52.1324648,-2.3275910,0.1328607,0.0684571,-2.3984621,52.1324549,-2.3275892,0.1363736,0.0691359,-2.2412932
-1615570254,52.1324648,-2.3275910,0.1328652,0.0689451,-1.9563936,52.1324549,-2.3275892,0.1363774,0.0691446,-2.2413802
-1615570255,52.1324649,-2.3275910,0.1294135,0.0682131,-2.5705581,52.1324550,-2.3275892,0.1364168,0.0691458,-2.2411404
-1615570255,52.1324649,-2.3275911,0.1314020,0.0704092,-2.3679249,52.1324550,-2.3275892,0.1364066,0.0691386,-2.2411134
-1615570255,52.1324649,-2.3275910,0.1313710,0.0669931,-2.4954081,52.1324550,-2.3275892,0.1364372,0.0691420,-2.2409601
-1615570256,52.1324650,-2.3275909,0.1316170,0.0669931,-1.7332793,52.1324550,-2.3275892,0.1364537,0.0691366,-2.2407830
-1615570256,52.1324650,-2.3275910,0.1333597,0.0691891,-2.4215493,52.1324551,-2.3275892,0.1364724,0.0691737,-2.2411399
-1615570256,52.1324651,-2.3275910,0.1328835,0.0708973,-2.6004331,52.1324551,-2.3275892,0.1364886,0.0691693,-2.2409790
-1615570257,52.1324651,-2.3275910,0.1353247,0.0687011,-1.8641306,52.1324551,-2.3275892,0.1364831,0.0692046,-2.2414665
-1615570257,52.1324652,-2.3275909,0.1316368,0.0691891,-2.3866622,52.1324551,-2.3275892,0.1364631,0.0692028,-2.2415731
-1615570258,52.1324652,-2.3275909,0.1335663,0.0647975,-2.4202509,52.1324552,-2.3275893,0.1365116,0.0691562,-2.2406616
-1615570258,52.1324653,-2.3275909,0.1308767,0.0667492,-2.3703718,52.1324552,-2.3275893,0.1365295,0.0691096,-2.2399471
-1615570258,52.1324653,-2.3275909,0.1316041,0.0655293,-2.8568416,52.1324552,-2.3275893,0.1365439,0.0691132,-2.2399013
-1615570259,52.1324653,-2.3275908,0.1309075,0.0701652,-2.4167390,52.1324553,-2.3275893,0.1365715,0.0691257,-2.2398820
-1615570259,52.1324653,-2.3275909,0.1318397,0.0643096,-2.3646824,52.1324553,-2.3275893,0.1365539,0.0691237,-2.2399702
-1615570259,52.1324654,-2.3275910,0.1313539,0.0650414,-2.2687340,52.1324553,-2.3275893,0.1365848,0.0691334,-2.2398946
-1615570260,52.1324655,-2.3275910,0.1353362,0.0699211,-2.5221190,52.1324553,-2.3275893,0.1365670,0.0691314,-2.2399836
-1615570260,52.1324655,-2.3275910,0.1328562,0.0679691,-2.7100596,52.1324554,-2.3275893,0.1365562,0.0690758,-2.2393403
-1615570261,52.1324655,-2.3275910,0.1308832,0.0674811,-1.8078831,52.1324554,-2.3275893,0.1365940,0.0690652,-2.2389598
-1615570261,52.1324655,-2.3275911,0.1326079,0.0677251,-3.1128917,52.1324554,-2.3275893,0.1366003,0.0691040,-2.2394171
-1615570261,52.1324654,-2.3275912,0.1308767,0.0667492,-2.7947206,52.1324554,-2.3275893,0.1366348,0.0690937,-2.2390618
-1615570262,52.1324655,-2.3275912,0.1291278,0.0635778,-1.8176768,52.1324555,-2.3275893,0.1366319,0.0691050,-2.2392251
-1615570262,52.1324655,-2.3275912,0.1331113,0.0689451,-2.3221021,52.1324555,-2.3275893,0.1366150,0.0690795,-2.2390084
-1615570262,52.1324654,-2.3275912,0.1299143,0.0691891,-3.0630550,52.1324555,-2.3275893,0.1366357,0.0690989,-2.2391229
-1615570263,52.1324654,-2.3275913,0.1291718,0.0687011,-2.0641611,52.1324555,-2.3275893,0.1366309,0.0690756,-2.2388549
-1615570263,52.1324654,-2.3275914,0.1333056,0.0630900,-2.3660834,52.1324556,-2.3275893,0.1366326,0.0690858,-2.2389746
-1615570264,52.1324654,-2.3275914,0.1338188,0.0655293,-2.4290774,52.1324556,-2.3275893,0.1366561,0.0691075,-2.2391009
-1615570264,52.1324654,-2.3275915,0.1313645,0.0662612,-2.4000692,52.1324556,-2.3275893,0.1366361,0.0691241,-2.2394428
-1615570264,52.1324654,-2.3275915,0.1343154,0.0660173,-2.1441722,52.1324556,-2.3275893,0.1366388,0.0691054,-2.2391853
-1615570265,52.1324653,-2.3275915,0.1350539,0.0660173,-1.7251676,52.1324556,-2.3275893,0.1365937,0.0691174,-2.2396305
-1615570265,52.1324653,-2.3275916,0.1328518,0.0674811,-1.6225353,52.1324557,-2.3275893,0.1365899,0.0691208,-2.2396998
-1615570265,52.1324653,-2.3275917,0.1294245,0.0694331,-2.7243690,52.1324557,-2.3275894,0.1366075,0.0691063,-2.2393999
-1615570266,52.1324653,-2.3275917,0.1308454,0.0630900,-2.0125787,52.1324557,-2.3275894,0.1365976,0.0690669,-2.2389581
-1615570266,52.1324653,-2.3275917,0.1328431,0.0665052,-2.0536323,52.1324557,-2.3275894,0.1365776,0.0690402,-2.2387440
-1615570267,52.1324653,-2.3275917,0.1335579,0.0638218,-2.3147879,52.1324558,-2.3275894,0.1366345,0.0690538,-2.2385509
-1615570267,52.1324653,-2.3275918,0.1308746,0.0665052,-2.3070066,52.1324558,-2.3275894,0.1366269,0.0690603,-2.2386832
-1615570267,52.1324653,-2.3275918,0.1313581,0.0655293,-2.0659959,52.1324558,-2.3275894,0.1366346,0.0691138,-2.2393198
-1615570268,52.1324653,-2.3275919,0.1328629,0.0687011,-2.3965812,52.1324558,-2.3275894,0.1366408,0.0691177,-2.2393301
-1615570268,52.1324652,-2.3275919,0.1343198,0.0665052,-2.2367747,52.1324559,-2.3275894,0.1366409,0.0691159,-2.2393067
-1615570268,52.1324652,-2.3275918,0.1328260,0.0645536,-1.9227111,52.1324559,-2.3275894,0.1366789,0.0690966,-2.2388134
-1615570269,52.1324651,-2.3275915,0.1367619,0.0643096,-2.4453321,52.1324559,-2.3275894,0.1367246,0.0691028,-2.2385991
-1615570269,52.1324650,-2.3275911,0.1375272,0.0672371,-2.2947049,52.1324559,-2.3275894,0.1367452,0.0690822,-2.2382014
-1615570270,52.1324649,-2.3275907,0.1345748,0.0674811,-1.7375684,52.1324559,-2.3275894,0.1367446,0.0691015,-2.2384529
-1615570270,52.1324648,-2.3275903,0.1350517,0.0657733,-2.1722901,52.1324560,-2.3275894,0.1367433,0.0690730,-2.2380960
-1615570270,52.1324647,-2.3275899,0.1308640,0.0652854,-2.6115921,52.1324560,-2.3275894,0.1367751,0.0691069,-2.2383261
-1615570271,52.1324646,-2.3275896,0.1328238,0.0643096,-2.1745753,52.1324560,-2.3275894,0.1367585,0.0690658,-2.2379055
-1615570271,52.1324646,-2.3275892,0.1321268,0.0689451,-2.2592955,52.1324560,-2.3275894,0.1367726,0.0690802,-2.2379992
-1615570271,52.1324646,-2.3275889,0.1345704,0.0669931,-1.7537675,52.1324560,-2.3275894,0.1367391,0.0691245,-2.2387824
-1615570272,52.1324646,-2.3275886,0.1333758,0.0708973,-2.1024752,52.1324561,-2.3275894,0.1367478,0.0691561,-2.2391303
-1615570272,52.1324647,-2.3275883,0.1343421,0.0689451,-2.5262628,52.1324561,-2.3275894,0.1367643,0.0691603,-2.2390785
-1615570273,52.1324645,-2.3275880,0.1330595,0.0630900,-2.0946226,52.1324561,-2.3275894,0.1367964,0.0691637,-2.2389145
-1615570273,52.1324646,-2.3275877,0.1306821,0.0723616,-2.7686234,52.1324561,-2.3275894,0.1367773,0.0691967,-2.2394605
-1615570273,52.1324646,-2.3275874,0.1362760,0.0650414,-2.3519251,52.1324561,-2.3275894,0.1367922,0.0691883,-2.2392569
-1615570274,52.1324646,-2.3275870,0.1281624,0.0657733,-2.1650743,52.1324562,-2.3275894,0.1367798,0.0691665,-2.2390573
-1615570274,52.1324646,-2.3275867,0.1264493,0.0667492,-1.9266732,52.1324562,-2.3275894,0.1367654,0.0691726,-2.2392282
-1615570274,52.1324647,-2.3275864,0.1321005,0.0660173,-2.7401512,52.1324562,-2.3275894,0.1367756,0.0691980,-2.2394876
-1615570275,52.1324647,-2.3275861,0.1330784,0.0652854,-2.1707222,52.1324562,-2.3275894,0.1367672,0.0691649,-2.2391181
-1615570275,52.1324647,-2.3275859,0.1313710,0.0669931,-2.4151559,52.1324562,-2.3275894,0.1367729,0.0691837,-2.2393219
-1615570276,52.1324648,-2.3275856,0.1303804,0.0662612,-2.3235333,52.1324563,-2.3275894,0.1367844,0.0692043,-2.2395115
-1615570276,52.1324648,-2.3275854,0.1303375,0.0611388,-2.5269580,52.1324563,-2.3275894,0.1367644,0.0691745,-2.2392597
-1615570276,52.1324648,-2.3275851,0.1313753,0.0674811,-2.5896647,52.1324563,-2.3275893,0.1366674,0.0691431,-2.2394817
-1615570277,52.1324649,-2.3275850,0.1345594,0.0657733,-2.0028915,52.1324563,-2.3275893,0.1366804,0.0691656,-2.2396865
-1615570277,52.1324650,-2.3275848,0.1318566,0.0662612,-2.5515172,52.1324563,-2.3275893,0.1366361,0.0691136,-2.2393055
-1615570277,52.1324650,-2.3275845,0.1311491,0.0696771,-2.0609202,52.1324564,-2.3275893,0.1366500,0.0690924,-2.2389433
-1615570278,52.1324651,-2.3275843,0.1335814,0.0665052,-2.1789522,52.1324564,-2.3275893,0.1366669,0.0690857,-2.2387488
-1615570278,52.1324651,-2.3275843,0.1320899,0.0647975,-2.7209640,52.1324564,-2.3275893,0.1367075,0.0690845,-2.2384725
-1615570279,52.1324651,-2.3275841,0.1289237,0.0684571,-1.8639487,52.1324564,-2.3275893,0.1366971,0.0690657,-2.2382979
-1615570279,52.1324652,-2.3275840,0.1343264,0.0672371,-1.8611042,52.1324564,-2.3275893,0.1367084,0.0690421,-2.2379224
-1615570279,52.1324652,-2.3275839,0.1362870,0.0662612,-2.2376661,52.1324565,-2.3275893,0.1367197,0.0690994,-2.2385833
-1615570280,52.1324653,-2.3275837,0.1342674,0.0604072,-2.3174658,52.1324565,-2.3275892,0.1367210,0.0691119,-2.2387362
-1615570280,52.1324654,-2.3275835,0.1347969,0.0647975,-2.2370455,52.1324565,-2.3275892,0.1367350,0.0691379,-2.2389793
-1615570280,52.1324653,-2.3275835,0.1363166,0.0694331,-2.7088974,52.1324565,-2.3275892,0.1367733,0.0691401,-2.2387600
-1615570281,52.1324654,-2.3275833,0.1335836,0.0667492,-1.8420702,52.1324565,-2.3275892,0.1367755,0.0691416,-2.2387657
-1615570281,52.1324654,-2.3275833,0.1316391,0.0694331,-1.9362042,52.1324566,-2.3275892,0.1368003,0.0691073,-2.2381673
-1615570282,52.1324655,-2.3275832,0.1308919,0.0684571,-2.4376340,52.1324566,-2.3275892,0.1368323,0.0691119,-2.2380195
-1615570282,52.1324655,-2.3275830,0.1316257,0.0679691,-2.1244843,52.1324566,-2.3275892,0.1368510,0.0690970,-2.2377083
-1615570282,52.1324656,-2.3275829,0.1348461,0.0701652,-2.1470313,52.1324566,-2.3275892,0.1368353,0.0690850,-2.2376559
-1615570283,52.1324657,-2.3275827,0.1355462,0.0660173,-2.2131679,52.1324566,-2.3275891,0.1368051,0.0690931,-2.2379537
-1615570283,52.1324658,-2.3275825,0.1345704,0.0669931,-2.2235661,52.1324567,-2.3275891,0.1367583,0.0691034,-2.2383876
-1615570283,52.1324658,-2.3275824,0.1316302,0.0684571,-2.4705930,52.1324567,-2.3275891,0.1367157,0.0691106,-2.2387540
-1615570284,52.1324660,-2.3275822,0.1360520,0.0674811,-2.4176018,52.1324567,-2.3275891,0.1366967,0.0691751,-2.2397029
-1615570284,52.1324660,-2.3275821,0.1335770,0.0660173,-2.6881850,52.1324567,-2.3275891,0.1366974,0.0691488,-2.2393618
-1615570285,52.1324661,-2.3275819,0.1306076,0.0640657,-2.1685584,52.1324567,-2.3275891,0.1366444,0.0691069,-2.2391646
-1615570285,52.1324662,-2.3275818,0.1355484,0.0662612,-2.4502797,52.1324568,-2.3275890,0.1366431,0.0690756,-2.2387724
-1615570285,52.1324663,-2.3275817,0.1325862,0.0652854,-2.1169538,52.1324568,-2.3275890,0.1366471,0.0691052,-2.2391248
-1615570286,52.1324664,-2.3275815,0.1341028,0.0696771,-2.0842819,52.1324568,-2.3275890,0.1366489,0.0691168,-2.2392628
-1615570286,52.1324665,-2.3275815,0.1379779,0.0626022,-2.4989414,52.1324568,-2.3275890,0.1366537,0.0691568,-2.2397447
-1615570286,52.1324665,-2.3275813,0.1323574,0.0672371,-2.1934865,52.1324568,-2.3275890,0.1366627,0.0691167,-2.2391732
-1615570287,52.1324666,-2.3275811,0.1382480,0.0652854,-1.8080033,52.1324569,-2.3275890,0.1366390,0.0691167,-2.2393250
-1615570287,52.1324668,-2.3275810,0.1308810,0.0672371,-2.6483846,52.1324569,-2.3275889,0.1365944,0.0691076,-2.2394958
-1615570288,52.1324669,-2.3275809,0.1353156,0.0677251,-1.9924023,52.1324569,-2.3275889,0.1366023,0.0691579,-2.2400904
-1615570288,52.1324669,-2.3275808,0.1320962,0.0655293,-2.4653835,52.1324569,-2.3275889,0.1366411,0.0691464,-2.2396922
-1615570288,52.1324671,-2.3275806,0.1298596,0.0628461,-2.3388114,52.1324569,-2.3275889,0.1365637,0.0691557,-2.2403100
-1615570289,52.1324671,-2.3275805,0.1331091,0.0687011,-2.7562652,52.1324570,-2.3275889,0.1365591,0.0691314,-2.2400289
-1615570289,52.1324673,-2.3275804,0.1321070,0.0667492,-2.1284261,52.1324570,-2.3275889,0.1365684,0.0691615,-2.2403550
-1615570289,52.1324673,-2.3275802,0.1333035,0.0628461,-2.2907310,52.1324570,-2.3275888,0.1365697,0.0691686,-2.2404366
-1615570290,52.1324673,-2.3275801,0.1304290,0.0716294,-2.4574327,52.1324570,-2.3275888,0.1365849,0.0691812,-2.2405002
-1615570290,52.1324674,-2.3275799,0.1316192,0.0672371,-2.1302624,52.1324571,-2.3275888,0.1366202,0.0691936,-2.2404320
-1615570291,52.1324675,-2.3275798,0.1301582,0.0689451,-2.2681944,52.1324571,-2.3275888,0.1366080,0.0692074,-2.2406862
-1615570291,52.1324675,-2.3275796,0.1321201,0.0682131,-2.5681078,52.1324571,-2.3275888,0.1365946,0.0692476,-2.2412879
-1615570291,52.1324675,-2.3275794,0.1345704,0.0669931,-2.3620965,52.1324571,-2.3275887,0.1366079,0.0692535,-2.2412784
-1615570292,52.1324676,-2.3275793,0.1345572,0.0655293,-2.2195425,52.1324571,-2.3275887,0.1365928,0.0692648,-2.2415204
-1615570292,52.1324677,-2.3275791,0.1306055,0.0638218,-2.3370123,52.1324572,-2.3275887,0.1366129,0.0692501,-2.2412033
-1615570292,52.1324678,-2.3275789,0.1350302,0.0633339,-2.4292965,52.1324572,-2.3275887,0.1365668,0.0692704,-2.2417598
-1615570293,52.1324679,-2.3275788,0.1301538,0.0684571,-2.6368399,52.1324572,-2.3275887,0.1366139,0.0692650,-2.2413862
-1615570293,52.1324680,-2.3275787,0.1365444,0.0674811,-2.0285053,52.1324572,-2.3275886,0.1365526,0.0692402,-2.2414639
-1615570294,52.1324681,-2.3275786,0.1345637,0.0662612,-2.3198557,52.1324573,-2.3275886,0.1365803,0.0692961,-2.2420015
-1615570294,52.1324682,-2.3275785,0.1369704,0.0599194,-2.3276792,52.1324573,-2.3275886,0.1365559,0.0692880,-2.2420552
-1615570294,52.1324683,-2.3275784,0.1318481,0.0652854,-2.0619502,52.1324573,-2.3275886,0.1366334,0.0692639,-2.2412469
-1615570295,52.1324683,-2.3275783,0.1338498,0.0689451,-2.1367955,52.1324573,-2.3275886,0.1366642,0.0692489,-2.2408569
-1615570295,52.1324684,-2.3275782,0.1320733,0.0628461,-2.2343736,52.1324573,-2.3275885,0.1366440,0.0693019,-2.2416649
-1615570295,52.1324685,-2.3275782,0.1318439,0.0647975,-2.3678992,52.1324574,-2.3275885,0.1366405,0.0692922,-2.2415638
-1615570296,52.1324686,-2.3275782,0.1347969,0.0647975,-2.1207471,52.1324574,-2.3275885,0.1366709,0.0692276,-2.2405410
-1615570296,52.1324687,-2.3275781,0.1308767,0.0667492,-2.1015084,52.1324574,-2.3275885,0.1366219,0.0692264,-2.2408412
-1615570297,52.1324689,-2.3275780,0.1328431,0.0665052,-2.3720725,52.1324574,-2.3275885,0.1366180,0.0692477,-2.2411385
-1615570297,52.1324689,-2.3275779,0.1338253,0.0662612,-1.9711852,52.1324575,-2.3275884,0.1366643,0.0692276,-2.2405844
-1615570297,52.1324690,-2.3275779,0.1335496,0.0628461,-2.1766129,52.1324575,-2.3275884,0.1366277,0.0692687,-2.2413459
-1615570298,52.1324691,-2.3275779,0.1333375,0.0667492,-2.2735252,52.1324575,-2.3275884,0.1366540,0.0692738,-2.2412415
-1615570298,52.1324692,-2.3275779,0.1320962,0.0655293,-2.6351345,52.1324575,-2.3275884,0.1366695,0.0692431,-2.2407491
-1615570298,52.1324692,-2.3275779,0.1352870,0.0645536,-2.1129072,52.1324576,-2.3275884,0.1367159,0.0692370,-2.2403727
-1615570299,52.1324692,-2.3275778,0.1340500,0.0638218,-2.3888884,52.1324576,-2.3275883,0.1367146,0.0692468,-2.2405057
-1615570299,52.1324693,-2.3275779,0.1323640,0.0679691,-2.3834631,52.1324576,-2.3275883,0.1366844,0.0692591,-2.2408571
-1615570300,52.1324693,-2.3275779,0.1313952,0.0696771,-2.1644325,52.1324576,-2.3275883,0.1366876,0.0692875,-2.2411997
-1615570300,52.1324694,-2.3275779,0.1301116,0.0635778,-2.6462705,52.1324576,-2.3275883,0.1366601,0.0693179,-2.2417660
-1615570300,52.1324694,-2.3275779,0.1313775,0.0677251,-1.9777179,52.1324577,-2.3275882,0.1366766,0.0693500,-2.2420695
-1615570301,52.1324695,-2.3275778,0.1325884,0.0655293,-2.5498376,52.1324577,-2.3275882,0.1366407,0.0693242,-2.2419705
-1615570301,52.1324695,-2.3275779,0.1357858,0.0652854,-2.4378467,52.1324577,-2.3275882,0.1365991,0.0693538,-2.2426167
-1615570301,52.1324696,-2.3275779,0.1347947,0.0645536,-2.4806340,52.1324577,-2.3275882,0.1365713,0.0693556,-2.2428188
-1615570302,52.1324696,-2.3275779,0.1343606,0.0708973,-2.7848685,52.1324578,-2.3275882,0.1365319,0.0693525,-2.2430336
-1615570302,52.1324697,-2.3275778,0.1343399,0.0687011,-2.3828306,52.1324578,-2.3275881,0.1365058,0.0693168,-2.2427435
-1615570303,52.1324698,-2.3275779,0.1306180,0.0652854,-2.1109781,52.1324578,-2.3275881,0.1364931,0.0693760,-2.2435837
-1615570303,52.1324697,-2.3275778,0.1301716,0.0704092,-2.4373930,52.1324578,-2.3275881,0.1364881,0.0693797,-2.2436626
-1615570303,52.1324698,-2.3275778,0.1340376,0.0623583,-1.7337061,52.1324579,-2.3275881,0.1365120,0.0693837,-2.2435606
-1615570304,52.1324699,-2.3275778,0.1333552,0.0687011,-2.3134038,52.1324579,-2.3275881,0.1365114,0.0693388,-2.2429893
-1615570304,52.1324699,-2.3275778,0.1340915,0.0684571,-2.1578665,52.1324579,-2.3275880,0.1365032,0.0693255,-2.2428730
-1615570304,52.1324699,-2.3275778,0.1353133,0.0674811,-1.6195058,52.1324579,-2.3275880,0.1365081,0.0693258,-2.2428446
-1615570305,52.1324698,-2.3275778,0.1360475,0.0669931,-2.0681198,52.1324579,-2.3275880,0.1365414,0.0693068,-2.2423863
-1615570305,52.1324698,-2.3275779,0.1309030,0.0696771,-2.0102599,52.1324580,-2.3275880,0.1365007,0.0693148,-2.2427516
-1615570306,52.1324699,-2.3275779,0.1333463,0.0677251,-2.1158423,52.1324580,-2.3275880,0.1364836,0.0693233,-2.2429707
-1615570306,52.1324699,-2.3275779,0.1313581,0.0655293,-2.1661634,52.1324580,-2.3275879,0.1365093,0.0693215,-2.2427812
-1615570306,52.1324699,-2.3275779,0.1281835,0.0682131,-1.9195298,52.1324580,-2.3275879,0.1364883,0.0693158,-2.2428441
-1615570307,52.1324700,-2.3275779,0.1310793,0.0616266,-1.9714652,52.1324581,-2.3275879,0.1364697,0.0692831,-2.2425447
-1615570307,52.1324700,-2.3275778,0.1318785,0.0687011,-2.1114175,52.1324581,-2.3275879,0.1364594,0.0693018,-2.2428505
-1615570307,52.1324700,-2.3275778,0.1281666,0.0662612,-2.3521926,52.1324581,-2.3275879,0.1364186,0.0693245,-2.2434053
-1615570308,52.1324700,-2.3275777,0.1323317,0.0643096,-2.0727162,52.1324581,-2.3275879,0.1363718,0.0693327,-2.2438111
-1615570308,52.1324700,-2.3275777,0.1286502,0.0652854,-2.3185463,52.1324582,-2.3275878,0.1363461,0.0693697,-2.2444520
-1615570309,52.1324700,-2.3275777,0.1345637,0.0662612,-1.8801963,52.1324582,-2.3275878,0.1362720,0.0693814,-2.2450805
-1615570309,52.1324701,-2.3275776,0.1330678,0.0640657,-2.0101182,52.1324582,-2.3275878,0.1362706,0.0694107,-2.2454667
-1615570309,52.1324701,-2.3275776,0.1336151,0.0701652,-2.0309832,52.1324582,-2.3275878,0.1362673,0.0693853,-2.2451618
-1615570310,52.1324701,-2.3275775,0.1352913,0.0650414,-2.3534067,52.1324582,-2.3275878,0.1362482,0.0693866,-2.2453012
-1615570310,52.1324701,-2.3275774,0.1328453,0.0667492,-1.9914298,52.1324583,-2.3275877,0.1362813,0.0694128,-2.2454247
-1615570310,52.1324701,-2.3275774,0.1326035,0.0672371,-2.2946153,52.1324583,-2.3275877,0.1363263,0.0693963,-2.2449226
-1615570311,52.1324701,-2.3275773,0.1321113,0.0672371,-2.5512769,52.1324583,-2.3275877,0.1363300,0.0693959,-2.2448936
-1615570311,52.1324701,-2.3275773,0.1301116,0.0635778,-2.1825340,52.1324583,-2.3275877,0.1363269,0.0694002,-2.2449684
-1615570312,52.1324701,-2.3275771,0.1286461,0.0647975,-1.9545983,52.1324584,-2.3275877,0.1362923,0.0694171,-2.2454085
-1615570312,52.1324700,-2.3275772,0.1318875,0.0696771,-2.3498471,52.1324584,-2.3275876,0.1363258,0.0694270,-2.2453187
-1615570312,52.1324701,-2.3275771,0.1335880,0.0672371,-1.9718094,52.1324584,-2.3275876,0.1363271,0.0694208,-2.2452314
-1615570313,52.1324701,-2.3275770,0.1338430,0.0682131,-2.4819238,52.1324584,-2.3275876,0.1363251,0.0694204,-2.2452388
-1615570313,52.1324701,-2.3275769,0.1293757,0.0638218,-2.3633728,52.1324584,-2.3275876,0.1362805,0.0694311,-2.2456639
-1615570313,52.1324701,-2.3275768,0.1338167,0.0652854,-2.2454412,52.1324585,-2.3275876,0.1362955,0.0694472,-2.2457743
-1615570314,52.1324702,-2.3275767,0.1328518,0.0674811,-2.4608231,52.1324585,-2.3275875,0.1362967,0.0694257,-2.2454908
-1615570314,52.1324702,-2.3275767,0.1328094,0.0626022,-1.7610680,52.1324585,-2.3275875,0.1362796,0.0694327,-2.2456901
-1615570315,52.1324702,-2.3275767,0.1338521,0.0691891,-2.1267664,52.1324585,-2.3275875,0.1362501,0.0694107,-2.2455978
-1615570315,52.1324702,-2.3275766,0.1296466,0.0667492,-2.0934820,52.1324586,-2.3275875,0.1362480,0.0693950,-2.2454095
-1615570315,52.1324702,-2.3275765,0.1345838,0.0684571,-2.2806411,52.1324586,-2.3275875,0.1362802,0.0694044,-2.2453232
-1615570316,52.1324701,-2.3275765,0.1328281,0.0647975,-2.4502125,52.1324586,-2.3275874,0.1362728,0.0693462,-2.2446237
-1615570316,52.1324702,-2.3275764,0.1318523,0.0657733,-2.2827225,52.1324586,-2.3275874,0.1362599,0.0693920,-2.2452958
-1615570316,52.1324702,-2.3275764,0.1323509,0.0665052,-2.1410873,52.1324586,-2.3275874,0.1362517,0.0693695,-2.2450585
-1615570317,52.1324702,-2.3275763,0.1296176,0.0633339,-2.2482839,52.1324587,-2.3275874,0.1362696,0.0693185,-2.2442870
-1615570317,52.1324702,-2.3275762,0.1352785,0.0635778,-2.6403680,52.1324587,-2.3275874,0.1362254,0.0692600,-2.2438202
-1615570318,52.1324702,-2.3275761,0.1338145,0.0650414,-2.7616181,52.1324587,-2.3275873,0.1362086,0.0692486,-2.2437830
-1615570318,52.1324703,-2.3275761,0.1303678,0.0647975,-2.2853835,52.1324587,-2.3275873,0.1361914,0.0692149,-2.2434602
-1615570318,52.1324703,-2.3275761,0.1348323,0.0687011,-2.1682115,52.1324587,-2.3275873,0.1362139,0.0691945,-2.2430520
-1615570319,52.1324703,-2.3275761,0.1306637,0.0704092,-2.5321016,52.1324588,-2.3275873,0.1361667,0.0691951,-2.2433650
-1615570319,52.1324702,-2.3275760,0.1353270,0.0689451,-2.4160972,52.1324588,-2.3275873,0.1361327,0.0691909,-2.2435308
-1615570319,52.1324702,-2.3275760,0.1298800,0.0652854,-2.1305592,52.1324588,-2.3275872,0.1361948,0.0692180,-2.2434771
-1615570320,52.1324701,-2.3275759,0.1316436,0.0699211,-2.9133475,52.1324588,-2.3275872,0.1361995,0.0692319,-2.2436261
-1615570320,52.1324700,-2.3275759,0.1338319,0.0669931,-2.2587917,52.1324588,-2.3275872,0.1361750,0.0692442,-2.2439435
-1615570321,52.1324700,-2.3275758,0.1333485,0.0679691,-2.5657308,52.1324589,-2.3275872,0.1361809,0.0692202,-2.2435961
-1615570321,52.1324700,-2.3275758,0.1323509,0.0665052,-2.3628054,52.1324589,-2.3275872,0.1361703,0.0692402,-2.2439215
-1615570321,52.1324700,-2.3275757,0.1291784,0.0694331,-2.2075510,52.1324589,-2.3275871,0.1361880,0.0692162,-2.2434986
-1615570322,52.1324699,-2.3275756,0.1380152,0.0667492,-1.9004579,52.1324589,-2.3275871,0.1361450,0.0691884,-2.2434194
-1615570322,52.1324699,-2.3275755,0.1316504,0.0706532,-3.0492504,52.1324589,-2.3275871,0.1362027,0.0691969,-2.2431550
-1615570322,52.1324699,-2.3275755,0.1306525,0.0691891,-2.6109300,52.1324590,-2.3275871,0.1361917,0.0691767,-2.2429669
-1615570323,52.1324698,-2.3275754,0.1333181,0.0645536,-1.7983775,52.1324590,-2.3275870,0.1362075,0.0691695,-2.2427721
-1615570323,52.1324698,-2.3275753,0.1279312,0.0674811,-2.4931002,52.1324590,-2.3275870,0.1362022,0.0691756,-2.2428839
-1615570324,52.1324697,-2.3275753,0.1333485,0.0679691,-2.0310311,52.1324590,-2.3275870,0.1362018,0.0692114,-2.2433469
-1615570324,52.1324697,-2.3275752,0.1348121,0.0665052,-1.9647678,52.1324590,-2.3275870,0.1362571,0.0692067,-2.2429287
-1615570324,52.1324696,-2.3275752,0.1355289,0.0640657,-2.2509637,52.1324591,-2.3275870,0.1362534,0.0692308,-2.2432628
-1615570325,52.1324695,-2.3275752,0.1326057,0.0674811,-2.3010876,52.1324591,-2.3275869,0.1362914,0.0692742,-2.2435760
-1615570325,52.1324694,-2.3275751,0.1298948,0.0669931,-1.9695313,52.1324591,-2.3275869,0.1363563,0.0692970,-2.2434487
-1615570325,52.1324693,-2.3275751,0.1355778,0.0694331,-2.5672255,52.1324591,-2.3275869,0.1363646,0.0692696,-2.2430444
-1615570326,52.1324693,-2.3275751,0.1318460,0.0650414,-2.1717052,52.1324591,-2.3275869,0.1363765,0.0693039,-2.2434072
-1615570326,52.1324691,-2.3275750,0.1266952,0.0667492,-2.2957413,52.1324591,-2.3275869,0.1363187,0.0693411,-2.2442575
-1615570327,52.1324691,-2.3275750,0.1370624,0.0701652,-2.7207887,52.1324592,-2.3275868,0.1362913,0.0693443,-2.2444749
-1615570327,52.1324689,-2.3275750,0.1277522,0.0748025,-1.9319230,52.1324592,-2.3275868,0.1362603,0.0693625,-2.2449090
-1615570327,52.1324689,-2.3275750,0.1336197,0.0706532,-2.2554622,52.1324592,-2.3275868,0.1362677,0.0693398,-2.2445700
-1615570328,52.1324688,-2.3275750,0.1320941,0.0652854,-2.1967349,52.1324592,-2.3275868,0.1362443,0.0692828,-2.2439892
-1615570328,52.1324688,-2.3275750,0.1345906,0.0691891,-1.9048971,52.1324592,-2.3275868,0.1362588,0.0693162,-2.2443242
-1615570328,52.1324687,-2.3275749,0.1341051,0.0699211,-2.3659360,52.1324592,-2.3275867,0.1362619,0.0693965,-2.2453353
-1615570329,52.1324687,-2.3275749,0.1350627,0.0669931,-2.3948364,52.1324593,-2.3275867,0.1363072,0.0694297,-2.2454691
-1615570329,52.1324687,-2.3275750,0.1360565,0.0679691,-2.1675272,52.1324593,-2.3275867,0.1363188,0.0694060,-2.2450910
-1615570330,52.1324686,-2.3275749,0.1345277,0.0621144,-2.1922071,52.1324593,-2.3275867,0.1363124,0.0693971,-2.2450173
-1615570330,52.1324685,-2.3275750,0.1267142,0.0689451,-1.8646595,52.1324593,-2.3275867,0.1363203,0.0693632,-2.2445314
-1615570330,52.1324685,-2.3275750,0.1313907,0.0691891,-2.6071687,52.1324593,-2.3275866,0.1363350,0.0693786,-2.2446346
-1615570331,52.1324684,-2.3275751,0.1286734,0.0679691,-2.3617179,52.1324593,-2.3275866,0.1363812,0.0693922,-2.2445107
-1615570331,52.1324683,-2.3275751,0.1313666,0.0665052,-2.3616402,52.1324594,-2.3275866,0.1363574,0.0693344,-2.2439229
-1615570331,52.1324683,-2.3275752,0.1335946,0.0679691,-2.0577683,52.1324594,-2.3275866,0.1363467,0.0693608,-2.2443314
-1615570332,52.1324682,-2.3275753,0.1313797,0.0679691,-3.0006931,52.1324594,-2.3275866,0.1363657,0.0693758,-2.2444005
-1615570332,52.1324682,-2.3275753,0.1333441,0.0674811,-2.2776144,52.1324594,-2.3275865,0.1363938,0.0693438,-2.2438092
-1615570333,52.1324681,-2.3275755,0.1333507,0.0682131,-2.2123322,52.1324594,-2.3275865,0.1364091,0.0693042,-2.2432024
-1615570333,52.1324681,-2.3275755,0.1294179,0.0687011,-2.7577929,52.1324594,-2.3275865,0.1363438,0.0693134,-2.2437418
-1615570333,52.1324680,-2.3275756,0.1328453,0.0667492,-2.4837232,52.1324594,-2.3275865,0.1364019,0.0693398,-2.2437050
-1615570334,52.1324679,-2.3275756,0.1286691,0.0674811,-2.6596556,52.1324595,-2.3275865,0.1364006,0.0693174,-2.2434278
-1615570334,52.1324679,-2.3275757,0.1294289,0.0699211,-2.9168828,52.1324595,-2.3275864,0.1364261,0.0692789,-2.2427685
-1615570334,52.1324678,-2.3275757,0.1328135,0.0630900,-1.9865223,52.1324595,-2.3275864,0.1364601,0.0692929,-2.2427287
-1615570335,52.1324678,-2.3275757,0.1343220,0.0667492,-2.0829649,52.1324595,-2.3275864,0.1364781,0.0692948,-2.2426374
-1615570335,52.1324678,-2.3275757,0.1338060,0.0640657,-1.9504961,52.1324595,-2.3275864,0.1364528,0.0692842,-2.2426653
-1615570336,52.1324677,-2.3275757,0.1308875,0.0679691,-2.4257436,52.1324595,-2.3275864,0.1365007,0.0693304,-2.2429483
-1615570336,52.1324677,-2.3275757,0.1365332,0.0662612,-2.0938878,52.1324595,-2.3275864,0.1365285,0.0693538,-2.2430694
-1615570336,52.1324677,-2.3275757,0.1343309,0.0677251,-2.2207036,52.1324596,-2.3275863,0.1365099,0.0693582,-2.2432451
-1615570337,52.1324677,-2.3275757,0.1309030,0.0696771,-2.3508115,52.1324596,-2.3275863,0.1364516,0.0693229,-2.2431679
-1615570337,52.1324678,-2.3275757,0.1306264,0.0662612,-2.1599619,52.1324596,-2.3275863,0.1364453,0.0693384,-2.2434072
-1615570337,52.1324677,-2.3275756,0.1343220,0.0667492,-2.1596103,52.1324596,-2.3275863,0.1364187,0.0693142,-2.2432685
-1615570338,52.1324678,-2.3275757,0.1342983,0.0640657,-2.3407800,52.1324596,-2.3275863,0.1364781,0.0693053,-2.2427721
-1615570338,52.1324677,-2.3275756,0.1308619,0.0650414,-2.1651154,52.1324596,-2.3275863,0.1365082,0.0693201,-2.2427678
-1615570339,52.1324676,-2.3275756,0.1375340,0.0679691,-2.0283644,52.1324596,-2.3275862,0.1365220,0.0693321,-2.2428329
-1615570339,52.1324676,-2.3275756,0.1331068,0.0684571,-2.2979805,52.1324597,-2.3275862,0.1365308,0.0693465,-2.2429600
-1615570339,52.1324675,-2.3275755,0.1345486,0.0645536,-1.8210869,52.1324597,-2.3275862,0.1365351,0.0693348,-2.2427835
-1615570340,52.1324675,-2.3275755,0.1308897,0.0682131,-2.5382457,52.1324597,-2.3275862,0.1365733,0.0693348,-2.2425377
-1615570340,52.1324675,-2.3275755,0.1303911,0.0674811,-2.1228197,52.1324597,-2.3275862,0.1365496,0.0693132,-2.2424130
-1615570340,52.1324675,-2.3275755,0.1330554,0.0626022,-2.2888234,52.1324597,-2.3275861,0.1365759,0.0693175,-2.2422981
-1615570341,52.1324675,-2.3275755,0.1345507,0.0647975,-1.7124883,52.1324597,-2.3275861,0.1366063,0.0693325,-2.2422945
-1615570341,52.1324675,-2.3275754,0.1308682,0.0657733,-2.0179863,52.1324597,-2.3275861,0.1366194,0.0693195,-2.2420442
-1615570342,52.1324676,-2.3275754,0.1320920,0.0650414,-1.9183528,52.1324597,-2.3275861,0.1365676,0.0692587,-2.2416003
-1615570342,52.1324675,-2.3275753,0.1323707,0.0687011,-1.9061329,52.1324598,-2.3275861,0.1365429,0.0693234,-2.2425866
-1615570342,52.1324675,-2.3275753,0.1326123,0.0682131,-2.3140512,52.1324598,-2.3275861,0.1365935,0.0693269,-2.2423062
-1615570343,52.1324675,-2.3275752,0.1335836,0.0667492,-2.0958834,52.1324598,-2.3275860,0.1365787,0.0692844,-2.2418573
-1615570343,52.1324675,-2.3275752,0.1326123,0.0682131,-2.0322247,52.1324598,-2.3275860,0.1365577,0.0692499,-2.2415509
-1615570343,52.1324674,-2.3275752,0.1308640,0.0652854,-2.6011572,52.1324598,-2.3275860,0.1365447,0.0692834,-2.2420630
-1615570344,52.1324674,-2.3275752,0.1328835,0.0708973,-2.6404953,52.1324598,-2.3275860,0.1364760,0.0692465,-2.2420344
-1615570344,52.1324673,-2.3275753,0.1321048,0.0665052,-2.6147130,52.1324598,-2.3275860,0.1364747,0.0692680,-2.2423182
-1615570345,52.1324673,-2.3275754,0.1293697,0.0630900,-2.5230708,52.1324598,-2.3275860,0.1364528,0.0693109,-2.2430091
-1615570345,52.1324672,-2.3275755,0.1333245,0.0652854,-2.6156542,52.1324599,-2.3275859,0.1364797,0.0693347,-2.2431407
-1615570345,52.1324671,-2.3275755,0.1321313,0.0694331,-2.1037726,52.1324599,-2.3275859,0.1365186,0.0693444,-2.2430143
-1615570346,52.1324670,-2.3275756,0.1345726,0.0672371,-2.3611586,52.1324599,-2.3275859,0.1364761,0.0693894,-2.2438633
-1615570346,52.1324669,-2.3275755,0.1286669,0.0672371,-2.4810526,52.1324599,-2.3275859,0.1364617,0.0693914,-2.2439821
-1615570346,52.1324669,-2.3275757,0.1301408,0.0669931,-2.4766908,52.1324599,-2.3275859,0.1364510,0.0693593,-2.2436402
-1615570347,52.1324668,-2.3275757,0.1311491,0.0696771,-2.0371709,52.1324599,-2.3275859,0.1364278,0.0693608,-2.2438090
-1615570347,52.1324668,-2.3275757,0.1301472,0.0677251,-2.4894361,52.1324599,-2.3275858,0.1364008,0.0693318,-2.2436109
-1615570348,52.1324667,-2.3275757,0.1340671,0.0657733,-2.3303399,52.1324599,-2.3275858,0.1364338,0.0693417,-2.2435255
-1615570348,52.1324666,-2.3275759,0.1331159,0.0694331,-2.3800442,52.1324599,-2.3275858,0.1363695,0.0693373,-2.2438834
-1615570348,52.1324664,-2.3275759,0.1299012,0.0677251,-1.9390200,52.1324600,-2.3275858,0.1363998,0.0693110,-2.2433505
-1615570349,52.1324664,-2.3275760,0.1316279,0.0682131,-1.9577050,52.1324600,-2.3275858,0.1363302,0.0693091,-2.2437754
-1615570349,52.1324663,-2.3275761,0.1338253,0.0662612,-2.4901252,52.1324600,-2.3275858,0.1363032,0.0692700,-2.2434483
-1615570349,52.1324662,-2.3275761,0.1333309,0.0660173,-2.3597574,52.1324600,-2.3275857,0.1362423,0.0692706,-2.2438486
-1615570350,52.1324660,-2.3275763,0.1313602,0.0657733,-1.9859364,52.1324600,-2.3275857,0.1362350,0.0692530,-2.2436700
-1615570350,52.1324659,-2.3275763,0.1360127,0.0630900,-2.1371479,52.1324600,-2.3275857,0.1362834,0.0692654,-2.2435167
-1615570351,52.1324658,-2.3275764,0.1325841,0.0650414,-2.0412004,52.1324600,-2.3275857,0.1362512,0.0692186,-2.2431238
-1615570351,52.1324657,-2.3275764,0.1323574,0.0672371,-2.4322820,52.1324600,-2.3275857,0.1362690,0.0691805,-2.2425182
-1615570351,52.1324656,-2.3275765,0.1313539,0.0650414,-3.0974119,52.1324600,-2.3275857,0.1363706,0.0692741,-2.2430642
-1615570352,52.1324655,-2.3275765,0.1340458,0.0633339,-2.5477800,52.1324600,-2.3275857,0.1363269,0.0691978,-2.2423670
-1615570352,52.1324653,-2.3275766,0.1328453,0.0667492,-2.5209467,52.1324600,-2.3275856,0.1363954,0.0691842,-2.2417493
-1615570352,52.1324652,-2.3275767,0.1355332,0.0645536,-1.9639038,52.1324601,-2.3275856,0.1364047,0.0691715,-2.2415264
-1615570353,52.1324651,-2.3275768,0.1345861,0.0687011,-1.7754654,52.1324601,-2.3275856,0.1363542,0.0691615,-2.2417250
-1615570353,52.1324650,-2.3275768,0.1333530,0.0684571,-2.3198874,52.1324601,-2.3275856,0.1363169,0.0691152,-2.2413712
-1615570354,52.1324649,-2.3275769,0.1323797,0.0696771,-2.2179098,52.1324601,-2.3275856,0.1362615,0.0691059,-2.2416098
-1615570354,52.1324648,-2.3275770,0.1325799,0.0645536,-2.2476561,52.1324601,-2.3275856,0.1363032,0.0690925,-2.2411671
-1615570354,52.1324647,-2.3275771,0.1303998,0.0684571,-2.2709434,52.1324601,-2.3275856,0.1363502,0.0690947,-2.2408917
-1615570355,52.1324646,-2.3275772,0.1315937,0.0643096,-1.7357007,52.1324601,-2.3275855,0.1363610,0.0690377,-2.2400901
-1615570355,52.1324644,-2.3275773,0.1345465,0.0643096,-2.0635545,52.1324601,-2.3275855,0.1363824,0.0690225,-2.2397556
-1615570355,52.1324644,-2.3275774,0.1318523,0.0657733,-2.4779720,52.1324601,-2.3275855,0.1363818,0.0690332,-2.2398982
-1615570356,52.1324642,-2.3275774,0.1338232,0.0660173,-2.1868949,52.1324601,-2.3275855,0.1363280,0.0690246,-2.2401350
-1615570356,52.1324641,-2.3275775,0.1357793,0.0645536,-2.0096836,52.1324601,-2.3275855,0.1363402,0.0691184,-2.2412612
-1615570357,52.1324640,-2.3275775,0.1345704,0.0669931,-2.5183001,52.1324601,-2.3275855,0.1363375,0.0691081,-2.2411458
-1615570357,52.1324639,-2.3275776,0.1333224,0.0650414,-2.9351447,52.1324601,-2.3275855,0.1363578,0.0691187,-2.2411518
-1615570357,52.1324638,-2.3275778,0.1338659,0.0706532,-2.3423088,52.1324601,-2.3275855,0.1362872,0.0691418,-2.2419050
-1615570358,52.1324637,-2.3275778,0.1340915,0.0684571,-2.3538857,52.1324601,-2.3275854,0.1362860,0.0691750,-2.2423384
-1615570358,52.1324636,-2.3275778,0.1345594,0.0657733,-1.7668958,52.1324602,-2.3275854,0.1362827,0.0691972,-2.2426445
-1615570358,52.1324634,-2.3275779,0.1367839,0.0667492,-1.7109326,52.1324602,-2.3275854,0.1362483,0.0691448,-2.2421937
-1615570359,52.1324633,-2.3275780,0.1291278,0.0635778,-2.8262377,52.1324602,-2.3275854,0.1362381,0.0691569,-2.2424150
-1615570359,52.1324632,-2.3275781,0.1318875,0.0696771,-1.8935549,52.1324602,-2.3275854,0.1362275,0.0691708,-2.2426629
-1615570360,52.1324630,-2.3275783,0.1286440,0.0645536,-2.8976543,52.1324602,-2.3275854,0.1362430,0.0691738,-2.2426012
-1615570360,52.1324629,-2.3275784,0.1318740,0.0682131,-2.9970758,52.1324602,-2.3275854,0.1362882,0.0691792,-2.2423780
-1615570360,52.1324629,-2.3275784,0.1323707,0.0687011,-2.1466143,52.1324602,-2.3275854,0.1362956,0.0691860,-2.2424183
-1615570361,52.1324628,-2.3275786,0.1313841,0.0684571,-2.0935385,52.1324602,-2.3275854,0.1363402,0.0691850,-2.2421167
-1615570361,52.1324627,-2.3275786,0.1313518,0.0647975,-2.2516460,52.1324602,-2.3275854,0.1362986,0.0691798,-2.2423182
-1615570361,52.1324625,-2.3275787,0.1279462,0.0691891,-2.9711332,52.1324602,-2.3275853,0.1363037,0.0691363,-2.2417264
-1615570362,52.1324625,-2.3275787,0.1293964,0.0662612,-2.1516714,52.1324602,-2.3275853,0.1362474,0.0691831,-2.2426925
-1615570362,52.1324623,-2.3275788,0.1306328,0.0669931,-2.5491140,52.1324602,-2.3275853,0.1361628,0.0691301,-2.2425573
-1615570363,52.1324622,-2.3275789,0.1367728,0.0655293,-1.8556105,52.1324602,-2.3275853,0.1361684,0.0690550,-2.2415538
-1615570363,52.1324621,-2.3275790,0.1338363,0.0674811,-2.1308289,52.1324602,-2.3275853,0.1361199,0.0690792,-2.2421801
-1615570363,52.1324619,-2.3275790,0.1330678,0.0640657,-2.2009227,52.1324602,-2.3275853,0.1361222,0.0690888,-2.2422895
-1615570364,52.1324617,-2.3275791,0.1345681,0.0667492,-2.2490530,52.1324602,-2.3275853,0.1360563,0.0690850,-2.2426679
-1615570364,52.1324617,-2.3275791,0.1321027,0.0662612,-1.9010357,52.1324602,-2.3275853,0.1360862,0.0690588,-2.2421355
-1615570364,52.1324615,-2.3275791,0.1338019,0.0635778,-2.1937969,52.1324602,-2.3275853,0.1360704,0.0689943,-2.2414064
-1615570365,52.1324613,-2.3275791,0.1375159,0.0660173,-2.8507013,52.1324602,-2.3275853,0.1360688,0.0690009,-2.2415020
-1615570365,52.1324612,-2.3275792,0.1296403,0.0660173,-2.3990877,52.1324602,-2.3275852,0.1360927,0.0690107,-2.2414730
-1615570366,52.1324610,-2.3275792,0.1328720,0.0696771,-2.6605737,52.1324602,-2.3275852,0.1360874,0.0690332,-2.2417972
-1615570366,52.1324609,-2.3275793,0.1306569,0.0696771,-2.4243860,52.1324602,-2.3275852,0.1360773,0.0690141,-2.2416162
-1615570366,52.1324608,-2.3275794,0.1333597,0.0691891,-2.7115121,52.1324602,-2.3275852,0.1360593,0.0689991,-2.2415397
-1615570367,52.1324606,-2.3275795,0.1343331,0.0679691,-2.4501910,52.1324602,-2.3275852,0.1360924,0.0689501,-2.2406926
-1615570367,52.1324605,-2.3275796,0.1316481,0.0704092,-2.3514161,52.1324602,-2.3275852,0.1360375,0.0689477,-2.2410183
-1615570367,52.1324604,-2.3275796,0.1323574,0.0672371,-2.1276917,52.1324602,-2.3275852,0.1360308,0.0689867,-2.2415655
-1615570368,52.1324602,-2.3275797,0.1347926,0.0643096,-2.3924212,52.1324602,-2.3275852,0.1361032,0.0689872,-2.2411017
-1615570368,52.1324602,-2.3275797,0.1320962,0.0655293,-2.7317104,52.1324602,-2.3275852,0.1361189,0.0689713,-2.2407951
-1615570369,52.1324601,-2.3275798,0.1338210,0.0657733,-2.6152835,52.1324602,-2.3275852,0.1361108,0.0689120,-2.2400835
-1615570369,52.1324600,-2.3275798,0.1323596,0.0674811,-2.4022288,52.1324602,-2.3275852,0.1360965,0.0689002,-2.2400246
-1615570369,52.1324599,-2.3275798,0.1331136,0.0691891,-2.7502046,52.1324602,-2.3275852,0.1359904,0.0688981,-2.2406857
-1615570370,52.1324598,-2.3275799,0.1340607,0.0650414,-2.3028157,52.1324602,-2.3275851,0.1359842,0.0689251,-2.2410738
-1615570370,52.1324598,-2.3275800,0.1323402,0.0652854,-2.3481240,52.1324602,-2.3275851,0.1358688,0.0688668,-2.2410703
-1615570370,52.1324597,-2.3275800,0.1313476,0.0643096,-2.4136736,52.1324602,-2.3275851,0.1358820,0.0688012,-2.2401350
-1615570371,52.1324597,-2.3275801,0.1296530,0.0674811,-2.3383844,52.1324602,-2.3275851,0.1359229,0.0687947,-2.2397852
-1615570371,52.1324596,-2.3275801,0.1362588,0.0630900,-2.3244216,52.1324602,-2.3275851,0.1358949,0.0688004,-2.2400417
-1615570372,52.1324596,-2.3275801,0.1324194,0.0738261,-2.3345714,52.1324602,-2.3275851,0.1358372,0.0688170,-2.2406313
-1615570372,52.1324595,-2.3275802,0.1316041,0.0655293,-2.8569267,52.1324602,-2.3275851,0.1358810,0.0688199,-2.2403841
-1615570372,52.1324595,-2.3275802,0.1355462,0.0660173,-2.3006623,52.1324602,-2.3275851,0.1359701,0.0688274,-2.2399013
-1615570373,52.1324594,-2.3275803,0.1328409,0.0662612,-2.3470140,52.1324602,-2.3275851,0.1360183,0.0688749,-2.2402015
-1615570373,52.1324594,-2.3275803,0.1389585,0.0621144,-1.7324423,52.1324602,-2.3275851,0.1359976,0.0688265,-2.2397113
-1615570373,52.1324593,-2.3275804,0.1355528,0.0667492,-2.6866074,52.1324602,-2.3275851,0.1360698,0.0688333,-2.2393308
-1615570374,52.1324592,-2.3275804,0.1338521,0.0691891,-1.8146435,52.1324602,-2.3275851,0.1360844,0.0688234,-2.2391071
-1615570374,52.1324592,-2.3275805,0.1318830,0.0691891,-2.6579671,52.1324602,-2.3275851,0.1360879,0.0688080,-2.2388864
-1615570375,52.1324591,-2.3275806,0.1341005,0.0694331,-2.2009563,52.1324602,-2.3275851,0.1361006,0.0688281,-2.2390633
-1615570375,52.1324591,-2.3275805,0.1333331,0.0662612,-2.2528372,52.1324602,-2.3275851,0.1361261,0.0688672,-2.2394011
-1615570375,52.1324591,-2.3275806,0.1318523,0.0657733,-2.3936851,52.1324602,-2.3275850,0.1360892,0.0689295,-2.2404442
-1615570376,52.1324590,-2.3275807,0.1257158,0.0672371,-2.5528100,52.1324602,-2.3275850,0.1361494,0.0688952,-2.2396111
-1615570376,52.1324589,-2.3275807,0.1362982,0.0674811,-2.1093411,52.1324602,-2.3275850,0.1361869,0.0688720,-2.2390685
-1615570376,52.1324589,-2.3275808,0.1340937,0.0687011,-1.9954798,52.1324602,-2.3275850,0.1361816,0.0689153,-2.2396607
-1615570377,52.1324588,-2.3275808,0.1367469,0.0626022,-2.2340071,52.1324602,-2.3275850,0.1362021,0.0688582,-2.2387929
-1615570377,52.1324587,-2.3275809,0.1308986,0.0691891,-2.4572215,52.1324602,-2.3275850,0.1361839,0.0688386,-2.2386580
-1615570378,52.1324586,-2.3275809,0.1284338,0.0687011,-2.3083661,52.1324602,-2.3275850,0.1361610,0.0688064,-2.2383924
-1615570378,52.1324585,-2.3275810,0.1348277,0.0682131,-2.2690704,52.1324602,-2.3275850,0.1361657,0.0688288,-2.2386503
-1615570378,52.1324584,-2.3275810,0.1340892,0.0682131,-1.8667881,52.1324602,-2.3275850,0.1362316,0.0688137,-2.2380280
-1615570379,52.1324583,-2.3275810,0.1323317,0.0643096,-2.2217901,52.1324602,-2.3275850,0.1362884,0.0687624,-2.2369990
-1615570379,52.1324582,-2.3275811,0.1353022,0.0662612,-2.3071194,52.1324602,-2.3275850,0.1362296,0.0686999,-2.2365756
-1615570379,52.1324581,-2.3275811,0.1355418,0.0655293,-2.0588036,52.1324602,-2.3275850,0.1362122,0.0686762,-2.2363830
-1615570380,52.1324581,-2.3275811,0.1326013,0.0669931,-2.4417562,52.1324602,-2.3275850,0.1362458,0.0686717,-2.2361064
-1615570380,52.1324579,-2.3275812,0.1340960,0.0689451,-1.9598488,52.1324602,-2.3275850,0.1362192,0.0686876,-2.2364836
-1615570381,52.1324578,-2.3275812,0.1277046,0.0696771,2.9840274,52.1324602,-2.3275850,0.1362548,0.0686747,-2.2360852
-1615570381,52.1324577,-2.3275813,0.1279228,0.0665052,-2.2383056,52.1324602,-2.3275850,0.1362972,0.0686101,-2.2349772
-1615570381,52.1324576,-2.3275814,0.1313998,0.0701652,-2.3742962,52.1324602,-2.3275850,0.1363402,0.0685637,-2.2341006
-1615570382,52.1324575,-2.3275814,0.1331091,0.0687011,-1.6395470,52.1324602,-2.3275850,0.1363886,0.0686063,-2.2343357
-1615570382,52.1324575,-2.3275815,0.1311058,0.0647975,-2.6219020,52.1324602,-2.3275849,0.1363993,0.0686020,-2.2342100
-1615570382,52.1324575,-2.3275816,0.1352785,0.0635778,-2.5969284,52.1324602,-2.3275849,0.1364717,0.0686155,-2.2339153
-1615570383,52.1324574,-2.3275816,0.1308919,0.0684571,-2.3201339,52.1324601,-2.3275849,0.1364666,0.0686133,-2.2339203
-1615570383,52.1324574,-2.3275817,0.1271666,0.0643096,-2.3477762,52.1324601,-2.3275849,0.1365073,0.0686109,-2.2336254
-1615570384,52.1324573,-2.3275818,0.1355375,0.0650414,-1.7101616,52.1324601,-2.3275849,0.1364173,0.0686090,-2.2341833
-1615570384,52.1324573,-2.3275818,0.1345906,0.0691891,-2.4019914,52.1324601,-2.3275849,0.1364552,0.0686986,-2.2350905
-1615570384,52.1324573,-2.3275819,0.1341028,0.0696771,-2.7137170,52.1324601,-2.3275849,0.1364016,0.0686844,-2.2352555
-1615570385,52.1324573,-2.3275819,0.1335537,0.0633339,-2.0123019,52.1324601,-2.3275849,0.1363657,0.0686139,-2.2345810
-1615570385,52.1324572,-2.3275819,0.1336036,0.0689451,-2.3834946,52.1324601,-2.3275849,0.1363756,0.0686024,-2.2343686
-1615570385,52.1324572,-2.3275820,0.1323552,0.0669931,-2.6988750,52.1324601,-2.3275849,0.1363864,0.0685866,-2.2340956
-1615570386,52.1324571,-2.3275821,0.1316041,0.0655293,-2.0798178,52.1324601,-2.3275849,0.1364078,0.0685807,-2.2338803
-1615570386,52.1324572,-2.3275822,0.1360212,0.0640657,-2.2578771,52.1324601,-2.3275849,0.1364287,0.0686225,-2.2342834
-1615570387,52.1324571,-2.3275823,0.1347841,0.0633339,3.0699391,52.1324601,-2.3275849,0.1363792,0.0685982,-2.2342908
-1615570387,52.1324571,-2.3275823,0.1279419,0.0687011,-2.5724108,52.1324601,-2.3275849,0.1363459,0.0685718,-2.2341661
-1615570387,52.1324571,-2.3275824,0.1377803,0.0679691,-2.4047632,52.1324601,-2.3275849,0.1363417,0.0686224,-2.2348452
-1615570388,52.1324571,-2.3275824,0.1350717,0.0679691,-2.1935883,52.1324601,-2.3275849,0.1363247,0.0686373,-2.2351472
-1615570388,52.1324571,-2.3275825,0.1325884,0.0655293,-2.2631228,52.1324601,-2.3275849,0.1363259,0.0686414,-2.2351923
-1615570388,52.1324570,-2.3275825,0.1348210,0.0674811,-2.4544110,52.1324601,-2.3275849,0.1362926,0.0686492,-2.2355092
-1615570389,52.1324570,-2.3275825,0.1335858,0.0669931,-2.2960005,52.1324601,-2.3275849,0.1362547,0.0686419,-2.2356610
-1615570389,52.1324570,-2.3275826,0.1350517,0.0657733,-2.6951132,52.1324601,-2.3275849,0.1363069,0.0686286,-2.2351508
-1615570390,52.1324569,-2.3275826,0.1325799,0.0645536,-2.2222047,52.1324601,-2.3275849,0.1362815,0.0686343,-2.2353883
-1615570390,52.1324569,-2.3275827,0.1370392,0.0677251,-2.0714130,52.1324601,-2.3275849,0.1363142,0.0686499,-2.2353773
-1615570390,52.1324568,-2.3275826,0.1328176,0.0635778,-2.1877217,52.1324601,-2.3275849,0.1363165,0.0686035,-2.2347646
-1615570391,52.1324568,-2.3275827,0.1368161,0.0701652,-1.8772072,52.1324601,-2.3275849,0.1362340,0.0685601,-2.2347407
-1615570391,52.1324568,-2.3275827,0.1341262,0.0721175,-2.4828844,52.1324601,-2.3275849,0.1361230,0.0685618,-2.2354827
-1615570391,52.1324569,-2.3275828,0.1296466,0.0667492,-2.4347801,52.1324601,-2.3275849,0.1360991,0.0685054,-2.2349107
-1615570392,52.1324570,-2.3275830,0.1301177,0.0643096,-2.4069734,52.1324601,-2.3275849,0.1361159,0.0685119,-2.2348850
-1615570392,52.1324572,-2.3275831,0.1313731,0.0672371,-2.6072857,52.1324600,-2.3275848,0.1361025,0.0685583,-2.2355714
-1615570393,52.1324573,-2.3275833,0.1367929,0.0677251,-2.2974710,52.1324600,-2.3275848,0.1361079,0.0685683,-2.2356663
-1615570393,52.1324575,-2.3275834,0.1340564,0.0645536,-1.6492054,52.1324600,-2.3275848,0.1361696,0.0684945,-2.2343113
-1615570393,52.1324576,-2.3275835,0.1338124,0.0647975,-2.3400059,52.1324600,-2.3275848,0.1362210,0.0684761,-2.2337399
-1615570394,52.1324577,-2.3275837,0.1305994,0.0630900,-2.1021266,52.1324600,-2.3275848,0.1361914,0.0685113,-2.2343869
-1615570394,52.1324579,-2.3275839,0.1342961,0.0638218,-2.4129033,52.1324600,-2.3275848,0.1362068,0.0685010,-2.2341540
-1615570394,52.1324581,-2.3275840,0.1347905,0.0640657,-1.8583299,52.1324600,-2.3275848,0.1361804,0.0684412,-2.2335529
-1615570395,52.1324582,-2.3275841,0.1323729,0.0689451,-2.0904377,52.1324600,-2.3275848,0.1362092,0.0684184,-2.2330706
-1615570395,52.1324584,-2.3275843,0.1348055,0.0657733,-2.4051428,52.1324600,-2.3275848,0.1361727,0.0683907,-2.2329507
-1615570396,52.1324586,-2.3275845,0.1347862,0.0635778,-2.3810840,52.1324600,-2.3275848,0.1362082,0.0684570,-2.2335773
-1615570396,52.1324588,-2.3275846,0.1353000,0.0660173,-2.9613385,52.1324600,-2.3275848,0.1361755,0.0684351,-2.2335060
-1615570396,52.1324589,-2.3275848,0.1338341,0.0672371,3.1022437,52.1324600,-2.3275848,0.1361243,0.0684713,-2.2343066
-1615570397,52.1324591,-2.3275849,0.1355663,0.0682131,-2.4244213,52.1324600,-2.3275848,0.1361403,0.0684823,-2.2343452
-1615570397,52.1324592,-2.3275851,0.1296278,0.0645536,-2.4244072,52.1324600,-2.3275848,0.1361779,0.0685162,-2.2345381
-1615570397,52.1324593,-2.3275852,0.1326350,0.0706532,-2.0198374,52.1324600,-2.3275848,0.1361442,0.0684749,-2.2342238
-1615570398,52.1324595,-2.3275853,0.1330657,0.0638218,-2.0032010,52.1324600,-2.3275848,0.1361703,0.0685245,-2.2346950
-1615570398,52.1324596,-2.3275854,0.1301429,0.0672371,-2.4293997,52.1324600,-2.3275848,0.1362358,0.0685309,-2.2343524
-1615570399,52.1324597,-2.3275855,0.1311206,0.0665052,-2.2283180,52.1324600,-2.3275848,0.1361708,0.0684468,-2.2336888
-1615570399,52.1324599,-2.3275856,0.1286564,0.0660173,-2.3317220,52.1324600,-2.3275848,0.1360800,0.0684768,-2.2346668
-1615570399,52.1324600,-2.3275855,0.1326013,0.0669931,-2.2824244,52.1324600,-2.3275848,0.1361062,0.0685265,-2.2351382
-1615570400,52.1324601,-2.3275856,0.1321113,0.0672371,-2.2077353,52.1324600,-2.3275848,0.1360898,0.0685495,-2.2355428
-1615570400,52.1324601,-2.3275857,0.1345704,0.0669931,-1.7587185,52.1324600,-2.3275848,0.1361111,0.0685620,-2.2355661
-1615570400,52.1324602,-2.3275858,0.1294179,0.0687011,-2.5893979,52.1324600,-2.3275848,0.1361714,0.0685811,-2.2354207
-1615570401,52.1324603,-2.3275858,0.1323531,0.0667492,-2.7349763,52.1324600,-2.3275848,0.1361153,0.0685159,-2.2349436
-1615570401,52.1324604,-2.3275859,0.1321268,0.0689451,-2.0768211,52.1324600,-2.3275848,0.1360964,0.0684785,-2.2345824
-1615570402,52.1324605,-2.3275859,0.1308724,0.0662612,-2.3156841,52.1324600,-2.3275848,0.1361046,0.0684657,-2.2343633
-1615570402,52.1324606,-2.3275860,0.1303783,0.0660173,-2.2003865,52.1324600,-2.3275849,0.1361490,0.0685211,-2.2347915
-1615570402,52.1324606,-2.3275861,0.1323381,0.0650414,-2.3758271,52.1324600,-2.3275849,0.1361156,0.0685226,-2.2350276
-1615570403,52.1324607,-2.3275862,0.1335836,0.0667492,-2.3794680,52.1324600,-2.3275849,0.1361465,0.0684583,-2.2339962
-1615570403,52.1324608,-2.3275862,0.1325884,0.0655293,-2.2674794,52.1324600,-2.3275849,0.1361423,0.0684515,-2.2339358
-1615570403,52.1324608,-2.3275862,0.1276644,0.0650414,-1.9445413,52.1324600,-2.3275849,0.1361812,0.0684116,-2.2331662
-1615570404,52.1324609,-2.3275862,0.1298926,0.0667492,-2.4935174,52.1324600,-2.3275849,0.1361372,0.0684586,-2.2340608
-1615570404,52.1324608,-2.3275862,0.1281835,0.0682131,-2.3670752,52.1324600,-2.3275849,0.1361736,0.0684540,-2.2337639
-1615570405,52.1324608,-2.3275862,0.1345815,0.0682131,-2.4239447,52.1324600,-2.3275849,0.1361625,0.0684890,-2.2342880
-1615570405,52.1324607,-2.3275862,0.1347883,0.0638218,-2.7754126,52.1324600,-2.3275849,0.1361534,0.0685512,-2.2351503
-1615570405,52.1324608,-2.3275860,0.1350409,0.0645536,-1.9545654,52.1324600,-2.3275849,0.1361516,0.0686056,-2.2358656
-1615570406,52.1324607,-2.3275861,0.1311559,0.0704092,-2.1323237,52.1324600,-2.3275849,0.1360652,0.0686185,-2.2365940
-1615570406,52.1324607,-2.3275860,0.1308703,0.0660173,-2.6259010,52.1324600,-2.3275849,0.1361429,0.0686280,-2.2362115
-1615570406,52.1324607,-2.3275860,0.1318763,0.0684571,-2.2138846,52.1324600,-2.3275849,0.1361233,0.0685678,-2.2355611
-1615570407,52.1324607,-2.3275858,0.1333397,0.0669931,-2.7558677,52.1324600,-2.3275849,0.1360919,0.0685700,-2.2357931
-1615570407,52.1324608,-2.3275858,0.1338408,0.0679691,-1.7420198,52.1324600,-2.3275849,0.1361255,0.0686155,-2.2361634
-1615570408,52.1324608,-2.3275858,0.1316257,0.0679691,-2.2250025,52.1324600,-2.3275849,0.1361676,0.0686490,-2.2363219
-1615570408,52.1324609,-2.3275858,0.1335475,0.0626022,-2.2730923,52.1324600,-2.3275849,0.1361471,0.0686273,-2.2361746
-1615570408,52.1324610,-2.3275858,0.1331091,0.0687011,3.0883436,52.1324600,-2.3275849,0.1360957,0.0686432,-2.2367139
-1615570409,52.1324610,-2.3275857,0.1308703,0.0660173,-2.3744657,52.1324600,-2.3275849,0.1361463,0.0687013,-2.2371361
-1615570409,52.1324611,-2.3275858,0.1347905,0.0640657,-2.0279298,52.1324600,-2.3275849,0.1360824,0.0686496,-2.2368832
-1615570409,52.1324612,-2.3275857,0.1333441,0.0674811,-1.6602544,52.1324600,-2.3275849,0.1360288,0.0686747,-2.2375560
-1615570410,52.1324612,-2.3275857,0.1367884,0.0672371,-1.9310278,52.1324600,-2.3275849,0.1360414,0.0686921,-2.2376995
-1615570410,52.1324613,-2.3275857,0.1333397,0.0669931,-2.1088128,52.1324600,-2.3275849,0.1361338,0.0687032,-2.2372417
-1615570411,52.1324614,-2.3275857,0.1355824,0.0699211,-2.1838555,52.1324600,-2.3275849,0.1361432,0.0686974,-2.2371058
-1615570411,52.1324615,-2.3275857,0.1311228,0.0667492,-1.7669272,52.1324600,-2.3275849,0.1361374,0.0686722,-2.2368197
-1615570411,52.1324615,-2.3275857,0.1329022,0.0728498,-2.3134530,52.1324600,-2.3275849,0.1361518,0.0687051,-2.2371507
-1615570412,52.1324616,-2.3275857,0.1390403,0.0708973,-2.3243966,52.1324600,-2.3275849,0.1361624,0.0686573,-2.2364640
-1615570412,52.1324617,-2.3275857,0.1293860,0.0650414,-2.6060684,52.1324600,-2.3275849,0.1362042,0.0686335,-2.2358873
-1615570412,52.1324617,-2.3275857,0.1313731,0.0672371,-2.2064004,52.1324600,-2.3275849,0.1361656,0.0685665,-2.2352736
-1615570413,52.1324617,-2.3275857,0.1325414,0.0599194,-2.0700970,52.1324601,-2.3275849,0.1361659,0.0685632,-2.2352288
-1615570413,52.1324618,-2.3275857,0.1338341,0.0672371,-2.5361719,52.1324601,-2.3275849,0.1361975,0.0685715,-2.2351308
-1615570414,52.1324619,-2.3275857,0.1316302,0.0684571,-1.9613743,52.1324601,-2.3275849,0.1362400,0.0685579,-2.2346792
-1615570414,52.1324619,-2.3275858,0.1291675,0.0682131,-3.0803576,52.1324601,-2.3275849,0.1361609,0.0685164,-2.2346570
-1615570414,52.1324620,-2.3275858,0.1328073,0.0623583,-2.9101863,52.1324601,-2.3275849,0.1361862,0.0685279,-2.2346416
-1615570415,52.1324620,-2.3275859,0.1328366,0.0657733,-2.4619384,52.1324601,-2.3275849,0.1362239,0.0685229,-2.2343321
-1615570415,52.1324621,-2.3275860,0.1335924,0.0677251,-2.3716815,52.1324601,-2.3275849,0.1362803,0.0685108,-2.2338107
-1615570415,52.1324621,-2.3275860,0.1304109,0.0696771,-2.8323138,52.1324601,-2.3275849,0.1363307,0.0684869,-2.2331762
-1615570416,52.1324622,-2.3275861,0.1340585,0.0647975,-3.0093904,52.1324601,-2.3275849,0.1363587,0.0684741,-2.2328291
-1615570416,52.1324622,-2.3275861,0.1340585,0.0647975,-2.5489359,52.1324601,-2.3275849,0.1363117,0.0684521,-2.2328506
-1615570417,52.1324623,-2.3275861,0.1296639,0.0687011,-2.6305990,52.1324601,-2.3275849,0.1362418,0.0684157,-2.2328353
-1615570417,52.1324623,-2.3275862,0.1296445,0.0665052,-2.4434578,52.1324601,-2.3275849,0.1361860,0.0684317,-2.2334030
-1615570417,52.1324622,-2.3275862,0.1347990,0.0650414,3.1334164,52.1324601,-2.3275849,0.1361427,0.0684436,-2.2338381
-1615570418,52.1324623,-2.3275862,0.1345616,0.0660173,-2.0629029,52.1324601,-2.3275849,0.1361830,0.0684672,-2.2338820
-1615570418,52.1324624,-2.3275863,0.1331204,0.0699211,-2.0481644,52.1324601,-2.3275849,0.1361790,0.0684196,-2.2332926
-1615570418,52.1324625,-2.3275864,0.1343490,0.0696771,-2.3741479,52.1324601,-2.3275849,0.1361228,0.0683619,-2.2329123
-1615570419,52.1324625,-2.3275865,0.1313797,0.0679691,-1.7643505,52.1324601,-2.3275849,0.1361333,0.0684279,-2.2336977
-1615570419,52.1324625,-2.3275866,0.1333202,0.0647975,-2.2240708,52.1324601,-2.3275849,0.1361352,0.0684430,-2.2338796
-1615570420,52.1324625,-2.3275865,0.1343154,0.0660173,-2.6236510,52.1324601,-2.3275849,0.1362509,0.0683787,-2.2322979
-1615570420,52.1324625,-2.3275866,0.1296197,0.0635778,-2.3695338,52.1324601,-2.3275849,0.1362196,0.0683484,-2.2321103
-1615570420,52.1324626,-2.3275866,0.1328540,0.0677251,-2.2435501,52.1324601,-2.3275849,0.1363174,0.0683737,-2.2318022
-1615570421,52.1324626,-2.3275865,0.1328114,0.0628461,-1.8560872,52.1324601,-2.3275849,0.1364019,0.0684337,-2.2320273
-1615570421,52.1324626,-2.3275865,0.1291421,0.0652854,-2.3285379,52.1324601,-2.3275849,0.1364094,0.0684994,-2.2328253
-1615570421,52.1324626,-2.3275864,0.1313731,0.0672371,-2.3018451,52.1324601,-2.3275849,0.1364796,0.0684934,-2.2322936
-1615570422,52.1324627,-2.3275865,0.1353000,0.0660173,-1.9786221,52.1324601,-2.3275849,0.1365204,0.0685278,-2.2324717
-1615570422,52.1324627,-2.3275865,0.1321005,0.0660173,-2.1089597,52.1324601,-2.3275849,0.1364740,0.0684464,-2.2317252
-1615570423,52.1324628,-2.3275866,0.1348255,0.0679691,-2.0904222,52.1324601,-2.3275849,0.1364468,0.0685104,-2.2327251
-1615570423,52.1324628,-2.3275866,0.1323487,0.0662612,-2.4085598,52.1324601,-2.3275849,0.1364654,0.0684632,-2.2319975
-1615570423,52.1324628,-2.3275866,0.1315793,0.0626022,-2.2085567,52.1324601,-2.3275849,0.1364352,0.0684512,-2.2320375
-1615570424,52.1324628,-2.3275867,0.1304109,0.0696771,-2.3648775,52.1324601,-2.3275849,0.1364495,0.0684364,-2.2317553
-1615570424,52.1324628,-2.3275867,0.1331068,0.0684571,-1.8769444,52.1324601,-2.3275849,0.1364456,0.0683852,-2.2311215
-1615570424,52.1324628,-2.3275867,0.1355289,0.0640657,-2.5151043,52.1324601,-2.3275849,0.1363879,0.0683652,-2.2312374
-1615570425,52.1324629,-2.3275867,0.1325884,0.0655293,-1.8512415,52.1324601,-2.3275849,0.1364650,0.0684105,-2.2313209
-1615570425,52.1324629,-2.3275869,0.1352743,0.0630900,-1.7542108,52.1324601,-2.3275849,0.1364859,0.0683924,-2.2309542
-1615570426,52.1324628,-2.3275869,0.1315916,0.0640657,-1.6689184,52.1324601,-2.3275849,0.1363854,0.0683887,-2.2315567
-1615570426,52.1324629,-2.3275870,0.1355332,0.0645536,-1.8708088,52.1324602,-2.3275850,0.1363760,0.0683096,-2.2305977
-1615570426,52.1324628,-2.3275872,0.1326258,0.0696771,-1.8435656,52.1324602,-2.3275850,0.1364295,0.0682777,-2.2298393
-1615570427,52.1324628,-2.3275872,0.1296705,0.0694331,-2.7835121,52.1324602,-2.3275850,0.1364476,0.0681671,-2.2282958
-1615570427,52.1324628,-2.3275873,0.1355755,0.0691891,-2.5860572,52.1324602,-2.3275850,0.1364553,0.0681951,-2.2286077
-1615570427,52.1324628,-2.3275875,0.1328176,0.0635778,-2.2874157,52.1324602,-2.3275850,0.1364924,0.0682631,-2.2292438
-1615570428,52.1324627,-2.3275875,0.1325862,0.0652854,-2.1400571,52.1324602,-2.3275850,0.1365601,0.0682350,-2.2284431
-1615570428,52.1324627,-2.3275876,0.1318852,0.0694331,-1.9155363,52.1324602,-2.3275850,0.1365235,0.0681555,-2.2276566
-1615570429,52.1324626,-2.3275877,0.1303678,0.0647975,-2.1786258,52.1324602,-2.3275850,0.1365289,0.0681409,-2.2274337
-1615570429,52.1324626,-2.3275878,0.1360364,0.0657733,-2.0288725,52.1324602,-2.3275850,0.1364583,0.0681200,-2.2276216
-1615570429,52.1324626,-2.3275878,0.1331113,0.0689451,-3.0243468,52.1324602,-2.3275850,0.1364921,0.0681243,-2.2274575
-1615570430,52.1324625,-2.3275878,0.1323865,0.0704092,-2.2663689,52.1324602,-2.3275850,0.1364642,0.0680179,-2.2262664
-1615570430,52.1324625,-2.3275879,0.1357902,0.0657733,-1.9290656,52.1324602,-2.3275850,0.1364164,0.0680011,-2.2263596
-1615570430,52.1324625,-2.3275879,0.1318397,0.0643096,-2.1538577,52.1324602,-2.3275850,0.1363604,0.0679687,-2.2263052
-1615570431,52.1324624,-2.3275879,0.1338253,0.0662612,-2.1757026,52.1324602,-2.3275850,0.1364391,0.0680286,-2.2265680
-1615570431,52.1324624,-2.3275880,0.1338475,0.0687011,-2.2115982,52.1324602,-2.3275850,0.1363985,0.0680192,-2.2267096
-1615570432,52.1324624,-2.3275880,0.1281793,0.0677251,-2.7058954,52.1324602,-2.3275850,0.1364183,0.0680753,-2.2273057
-1615570432,52.1324623,-2.3275879,0.1336174,0.0704092,-1.9911058,52.1324602,-2.3275850,0.1364073,0.0680266,-2.2267485
-1615570432,52.1324623,-2.3275880,0.1355462,0.0660173,-2.3819175,52.1324602,-2.3275850,0.1363721,0.0679656,-2.2261896
-1615570433,52.1324622,-2.3275880,0.1325884,0.0655293,-2.7525797,52.1324602,-2.3275850,0.1363643,0.0679978,-2.2266564
-1615570433,52.1324622,-2.3275879,0.1352913,0.0650414,-2.7253206,52.1324602,-2.3275850,0.1363968,0.0679832,-2.2262554
-1615570433,52.1324621,-2.3275880,0.1338232,0.0660173,-2.5259721,52.1324602,-2.3275850,0.1363898,0.0679437,-2.2257910
-1615570434,52.1324621,-2.3275881,0.1335642,0.0645536,-2.4008141,52.1324602,-2.3275850,0.1363673,0.0678915,-2.2252624
-1615570434,52.1324620,-2.3275880,0.1328366,0.0657733,-2.6210966,52.1324602,-2.3275850,0.1363049,0.0678571,-2.2252240
-1615570435,52.1324620,-2.3275880,0.1311249,0.0669931,-2.6133523,52.1324602,-2.3275850,0.1363057,0.0679189,-2.2260187
-1615570435,52.1324620,-2.3275880,0.1338297,0.0667492,-1.5847788,52.1324602,-2.3275850,0.1362547,0.0679547,-2.2268131
-1615570435,52.1324619,-2.3275880,0.1313581,0.0655293,-2.4436495,52.1324602,-2.3275850,0.1363615,0.0679751,-2.2263825
-1615570436,52.1324619,-2.3275880,0.1296617,0.0684571,-2.1131244,52.1324602,-2.3275850,0.1363227,0.0680226,-2.2272496
-1615570436,52.1324618,-2.3275880,0.1347820,0.0630900,-2.0552115,52.1324602,-2.3275850,0.1363482,0.0680003,-2.2267950
-1615570436,52.1324618,-2.3275880,0.1286585,0.0662612,-1.8915085,52.1324602,-2.3275850,0.1363762,0.0680754,-2.2275832
-1615570437,52.1324617,-2.3275880,0.1328607,0.0684571,-2.3978341,52.1324602,-2.3275850,0.1363664,0.0680749,-2.2276409
-1615570437,52.1324617,-2.3275882,0.1328155,0.0633339,-2.1848347,52.1324602,-2.3275850,0.1364165,0.0680785,-2.2273617
-1615570438,52.1324617,-2.3275881,0.1328518,0.0674811,-2.2950606,52.1324602,-2.3275851,0.1364047,0.0680314,-2.2268298
-1615570438,52.1324615,-2.3275882,0.1326035,0.0672371,-2.0509214,52.1324602,-2.3275851,0.1363757,0.0679522,-2.2259963
-1615570438,52.1324615,-2.3275882,0.1309121,0.0706532,-2.2319708,52.1324602,-2.3275851,0.1362957,0.0678827,-2.2256169
-1615570439,52.1324614,-2.3275883,0.1306180,0.0652854,-2.2726040,52.1324602,-2.3275851,0.1362522,0.0678129,-2.2249961
-1615570439,52.1324613,-2.3275883,0.1301156,0.0640657,-2.2700813,52.1324602,-2.3275851,0.1363236,0.0678609,-2.2251525
-1615570439,52.1324612,-2.3275884,0.1286105,0.0604072,-2.3031225,52.1324602,-2.3275851,0.1363664,0.0679681,-2.2262607
-1615570440,52.1324612,-2.3275884,0.1340892,0.0682131,-2.2725759,52.1324602,-2.3275851,0.1363735,0.0680571,-2.2273648
-1615570440,52.1324611,-2.3275884,0.1323423,0.0655293,-2.0585735,52.1324602,-2.3275851,0.1363233,0.0680855,-2.2280593
-1615570441,52.1324610,-2.3275884,0.1340521,0.0640657,-1.7626523,52.1324602,-2.3275851,0.1362803,0.0681490,-2.2291594
-1615570441,52.1324610,-2.3275883,0.1323234,0.0633339,-2.3124039,52.1324602,-2.3275851,0.1361980,0.0680999,-2.2290592
-1615570441,52.1324609,-2.3275884,0.1301538,0.0684571,-2.8537283,52.1324602,-2.3275851,0.1361935,0.0681444,-2.2296648
-1615570442,52.1324608,-2.3275884,0.1316020,0.0652854,-2.1005280,52.1324602,-2.3275851,0.1361459,0.0681600,-2.2301769
-1615570442,52.1324607,-2.3275884,0.1323214,0.0630900,-2.3013554,52.1324602,-2.3275851,0.1361820,0.0681892,-2.2303202
-1615570442,52.1324607,-2.3275884,0.1389801,0.0645536,-2.0581541,52.1324602,-2.3275851,0.1361093,0.0680147,-2.2285323
-1615570443,52.1324605,-2.3275884,0.1335706,0.0652854,-2.4944370,52.1324602,-2.3275851,0.1361024,0.0679739,-2.2280498
-1615570443,52.1324605,-2.3275884,0.1335642,0.0645536,-2.6133595,52.1324602,-2.3275851,0.1360643,0.0680307,-2.2290354
-1615570444,52.1324605,-2.3275883,0.1325927,0.0660173,-2.0667739,52.1324602,-2.3275851,0.1360471,0.0680774,-2.2297540
-1615570444,52.1324604,-2.3275883,0.1365288,0.0657733,-2.2862098,52.1324602,-2.3275851,0.1360444,0.0681009,-2.2300758
-1615570444,52.1324603,-2.3275883,0.1338430,0.0682131,-2.1820855,52.1324602,-2.3275851,0.1360236,0.0681217,-2.2304811
-1615570445,52.1324602,-2.3275883,0.1283920,0.0638218,-2.2920008,52.1324602,-2.3275851,0.1359540,0.0681089,-2.2307701
-1615570445,52.1324601,-2.3275882,0.1328238,0.0643096,-2.0113826,52.1324602,-2.3275851,0.1357874,0.0680977,-2.2317133
-1615570445,52.1324600,-2.3275881,0.1336174,0.0704092,-2.2461987,52.1324602,-2.3275851,0.1357435,0.0681525,-2.2327156
-1615570446,52.1324599,-2.3275881,0.1303762,0.0657733,-2.0937438,52.1324602,-2.3275851,0.1357811,0.0682070,-2.2331781
-1615570446,52.1324598,-2.3275881,0.1335579,0.0638218,-2.1306126,52.1324602,-2.3275851,0.1358021,0.0681823,-2.2327192
-1615570447,52.1324597,-2.3275880,0.1348012,0.0652854,-2.0352621,52.1324602,-2.3275851,0.1357270,0.0681512,-2.2328062
-1615570447,52.1324596,-2.3275880,0.1330595,0.0630900,-2.0995438,52.1324602,-2.3275851,0.1356566,0.0680444,-2.2318754
-1615570447,52.1324595,-2.3275880,0.1321246,0.0687011,-2.5845401,52.1324602,-2.3275851,0.1356603,0.0680834,-2.2323604
-1615570448,52.1324594,-2.3275880,0.1311292,0.0674811,-2.3341999,52.1324602,-2.3275851,0.1355982,0.0680645,-2.2325208
-1615570448,52.1324593,-2.3275880,0.1328323,0.0652854,-1.8706625,52.1324602,-2.3275852,0.1356521,0.0681046,-2.2326910
-1615570448,52.1324592,-2.3275880,0.1321048,0.0665052,-2.4330015,52.1324602,-2.3275852,0.1356764,0.0681635,-2.2333002
-1615570449,52.1324591,-2.3275880,0.1362631,0.0635778,-1.8790787,52.1324602,-2.3275852,0.1357576,0.0681675,-2.2328188
-1615570449,52.1324590,-2.3275880,0.1320815,0.0638218,-2.3468075,52.1324602,-2.3275852,0.1358103,0.0681851,-2.2327039
-1615570450,52.1324589,-2.3275880,0.1325927,0.0660173,-2.0865550,52.1324602,-2.3275852,0.1357809,0.0682148,-2.2332819
-1615570450,52.1324588,-2.3275879,0.1335991,0.0684571,-2.2075806,52.1324602,-2.3275852,0.1357457,0.0682287,-2.2336936
-1615570450,52.1324587,-2.3275879,0.1293819,0.0645536,-2.5171340,52.1324602,-2.3275852,0.1358888,0.0682535,-2.2330801
-1615570451,52.1324586,-2.3275878,0.1286712,0.0677251,-1.8546016,52.1324602,-2.3275852,0.1358623,0.0682980,-2.2338328
-1615570451,52.1324584,-2.3275879,0.1308853,0.0677251,-2.3845801,52.1324602,-2.3275852,0.1356759,0.0682757,-2.2347617
-1615570451,52.1324583,-2.3275879,0.1311336,0.0679691,-2.5679588,52.1324602,-2.3275852,0.1355906,0.0681607,-2.2338216
-1615570452,52.1324582,-2.3275878,0.1323531,0.0667492,-2.2851322,52.1324602,-2.3275852,0.1355350,0.0681659,-2.2342539
-1615570452,52.1324582,-2.3275878,0.1316106,0.0662612,-2.2437170,52.1324602,-2.3275852,0.1355304,0.0681582,-2.2341840
-1615570453,52.1324580,-2.3275879,0.1323466,0.0660173,-2.2577016,52.1324602,-2.3275852,0.1356452,0.0681606,-2.2334621
-1615570453,52.1324579,-2.3275879,0.1308853,0.0677251,-2.2543666,52.1324602,-2.3275852,0.1356013,0.0681274,-2.2333157
-1615570453,52.1324578,-2.3275878,0.1338210,0.0657733,-2.5033102,52.1324602,-2.3275852,0.1355264,0.0680766,-2.2331448
-1615570454,52.1324576,-2.3275877,0.1340847,0.0677251,-2.0024767,52.1324602,-2.3275852,0.1355842,0.0680622,-2.2325766
-1615570454,52.1324576,-2.3275878,0.1313313,0.0623583,-2.1979070,52.1324602,-2.3275852,0.1355819,0.0680581,-2.2325382
-1615570454,52.1324575,-2.3275877,0.1338297,0.0667492,-2.3697984,52.1324602,-2.3275852,0.1355332,0.0680179,-2.2323327
-1615570455,52.1324573,-2.3275877,0.1306728,0.0713854,-2.4739087,52.1324602,-2.3275852,0.1354778,0.0680206,-2.2327321
-1615570455,52.1324573,-2.3275876,0.1306014,0.0633339,-2.5528586,52.1324602,-2.3275852,0.1354387,0.0679803,-2.2324624
-1615570456,52.1324571,-2.3275877,0.1298758,0.0647975,-2.1763880,52.1324602,-2.3275852,0.1354862,0.0680417,-2.2329533
-1615570456,52.1324569,-2.3275877,0.1320693,0.0623583,-1.7580448,52.1324602,-2.3275852,0.1355010,0.0681187,-2.2338631
-1615570456,52.1324568,-2.3275877,0.1335880,0.0672371,-1.9465080,52.1324602,-2.3275852,0.1354335,0.0681177,-2.2342937
-1615570457,52.1324567,-2.3275876,0.1325884,0.0655293,-2.8683221,52.1324602,-2.3275852,0.1353948,0.0681167,-2.2345364
-1615570457,52.1324565,-2.3275876,0.1326035,0.0672371,-2.2179096,52.1324602,-2.3275852,0.1354946,0.0682049,-2.2350328
-1615570457,52.1324564,-2.3275876,0.1291784,0.0694331,-2.9532218,52.1324602,-2.3275852,0.1354784,0.0682190,-2.2353244
-1615570458,52.1324563,-2.3275874,0.1355183,0.0628461,-1.4137582,52.1324602,-2.3275852,0.1354943,0.0682059,-2.2350478
-1615570458,52.1324562,-2.3275875,0.1311121,0.0655293,-1.9320821,52.1324602,-2.3275852,0.1355967,0.0682552,-2.2350199
-1615570459,52.1324560,-2.3275875,0.1294135,0.0682131,-1.9496809,52.1324602,-2.3275852,0.1356340,0.0682341,-2.2344995
-1615570459,52.1324559,-2.3275873,0.1308536,0.0640657,-1.9206078,52.1324602,-2.3275852,0.1354947,0.0681863,-2.2347903
-1615570459,52.1324558,-2.3275873,0.1301035,0.0626022,-1.4350337,52.1324602,-2.3275852,0.1354887,0.0682689,-2.2359092
-1615570460,52.1324557,-2.3275872,0.1311037,0.0645536,-2.6218474,52.1324601,-2.3275852,0.1355005,0.0682601,-2.2357168
-1615570460,52.1324555,-2.3275872,0.1304064,0.0691891,-2.2732043,52.1324601,-2.3275852,0.1355042,0.0682147,-2.2350993
-1615570460,52.1324554,-2.3275870,0.1323797,0.0696771,-2.2410378,52.1324601,-2.3275852,0.1355765,0.0683264,-2.2360835
-1615570461,52.1324553,-2.3275870,0.1330935,0.0669931,-2.1876240,52.1324601,-2.3275852,0.1355765,0.0682396,-2.2349505
-1615570461,52.1324552,-2.3275869,0.1303783,0.0660173,-1.9746729,52.1324601,-2.3275852,0.1355869,0.0682076,-2.2344637
-1615570462,52.1324551,-2.3275869,0.1330848,0.0660173,-2.4962287,52.1324601,-2.3275852,0.1356356,0.0681522,-2.2334218
-1615570462,52.1324549,-2.3275868,0.1335946,0.0679691,-2.7942710,52.1324601,-2.3275853,0.1355794,0.0680947,-2.2330394
-1615570462,52.1324548,-2.3275867,0.1308853,0.0677251,-2.0821924,52.1324601,-2.3275853,0.1355325,0.0680257,-2.2324457
-1615570463,52.1324547,-2.3275866,0.1328114,0.0628461,-2.1958156,52.1324601,-2.3275853,0.1356035,0.0680173,-2.2318697
-1615570463,52.1324545,-2.3275865,0.1330892,0.0665052,-2.3613896,52.1324601,-2.3275853,0.1356351,0.0680663,-2.2323027
-1615570463,52.1324544,-2.3275864,0.1301260,0.0652854,-2.3194246,52.1324601,-2.3275853,0.1357473,0.0681506,-2.2326665
-1615570464,52.1324543,-2.3275864,0.1303804,0.0662612,-2.2808895,52.1324601,-2.3275853,0.1358314,0.0681864,-2.2325811
-1615570464,52.1324542,-2.3275862,0.1335600,0.0640657,-2.2042003,52.1324601,-2.3275853,0.1358868,0.0682020,-2.2324226
-1615570465,52.1324541,-2.3275861,0.1283723,0.0613827,0.5645774,52.1324601,-2.3275853,0.1359617,0.0682205,-2.2321732
-1615570465,52.1324539,-2.3275860,0.1333224,0.0650414,-1.9769731,52.1324601,-2.3275853,0.1358830,0.0682575,-2.2331696
-1615570465,52.1324539,-2.3275859,0.1323729,0.0689451,-2.0523272,52.1324601,-2.3275853,0.1358720,0.0682883,-2.2336411
-1615570466,52.1324537,-2.3275858,0.1303783,0.0660173,-2.6875553,52.1324601,-2.3275853,0.1359428,0.0682821,-2.2330990
-1615570466,52.1324536,-2.3275856,0.1350387,0.0643096,-1.9148824,52.1324600,-2.3275853,0.1359212,0.0682866,-2.2332983
-1615570466,52.1324535,-2.3275855,0.1340915,0.0684571,-2.1928811,52.1324600,-2.3275853,0.1359786,0.0683377,-2.2335868
-1615570467,52.1324534,-2.3275854,0.1333441,0.0674811,-2.3967884,52.1324600,-2.3275853,0.1359350,0.0683356,-2.2338452
-1615570467,52.1324532,-2.3275853,0.1328431,0.0665052,-2.2726593,52.1324600,-2.3275853,0.1359713,0.0684068,-2.2345328
-1615570468,52.1324531,-2.3275853,0.1306307,0.0667492,-2.6969166,52.1324600,-2.3275853,0.1359124,0.0684413,-2.2353652
-1615570468,52.1324530,-2.3275851,0.1330827,0.0657733,-1.8779807,52.1324600,-2.3275853,0.1358787,0.0684392,-2.2355573
-1615570468,52.1324529,-2.3275850,0.1335946,0.0679691,-2.7123020,52.1324600,-2.3275853,0.1358935,0.0683724,-2.2345924
-1615570469,52.1324528,-2.3275849,0.1328238,0.0643096,-1.9081851,52.1324600,-2.3275853,0.1358710,0.0684089,-2.2352140
-1615570469,52.1324528,-2.3275848,0.1306503,0.0689451,-2.5293393,52.1324600,-2.3275853,0.1359051,0.0684327,-2.2353001
-1615570469,52.1324527,-2.3275848,0.1335836,0.0667492,-1.8641447,52.1324600,-2.3275853,0.1359090,0.0684563,-2.2355816
-1615570470,52.1324526,-2.3275846,0.1299210,0.0699211,-2.4336414,52.1324600,-2.3275853,0.1358380,0.0684402,-2.2358367
-1615570470,52.1324525,-2.3275845,0.1369994,0.0633339,-2.2035477,52.1324600,-2.3275853,0.1358705,0.0683547,-2.2345123
-1615570471,52.1324524,-2.3275845,0.1315978,0.0647975,-1.8910627,52.1324600,-2.3275853,0.1359725,0.0683928,-2.2343407
-1615570471,52.1324524,-2.3275844,0.1353362,0.0699211,-2.3032260,52.1324600,-2.3275853,0.1358962,0.0683694,-2.2345343
-1615570471,52.1324523,-2.3275844,0.1350605,0.0667492,-2.4691954,52.1324599,-2.3275853,0.1359204,0.0683490,-2.2341123
-1615570472,52.1324523,-2.3275842,0.1347926,0.0643096,-2.1677761,52.1324599,-2.3275853,0.1358736,0.0683432,-2.2343421
-1615570472,52.1324523,-2.3275841,0.1316459,0.0701652,-2.3753963,52.1324599,-2.3275853,0.1358922,0.0683774,-2.2346652
-1615570472,52.1324522,-2.3275840,0.1328281,0.0647975,-2.3573513,52.1324599,-2.3275853,0.1358247,0.0683299,-2.2344892
-1615570473,52.1324522,-2.3275839,0.1301323,0.0660173,-2.1959898,52.1324599,-2.3275853,0.1357638,0.0684000,-2.2357988
-1615570473,52.1324522,-2.3275838,0.1323255,0.0635778,-1.9118017,52.1324599,-2.3275852,0.1357419,0.0683747,-2.2356136
-1615570474,52.1324522,-2.3275837,0.1296382,0.0657733,-2.3127978,52.1324599,-2.3275852,0.1356964,0.0683632,-2.2357624
-1615570474,52.1324521,-2.3275837,0.1358240,0.0694331,-2.4566095,52.1324599,-2.3275852,0.1357522,0.0683550,-2.2352898
-1615570474,52.1324521,-2.3275836,0.1301386,0.0667492,-1.9018946,52.1324599,-2.3275852,0.1357455,0.0683817,-2.2356815
-1615570475,52.1324521,-2.3275836,0.1330914,0.0667492,-1.8989319,52.1324599,-2.3275852,0.1357286,0.0683340,-2.2351708
-1615570475,52.1324522,-2.3275836,0.1335706,0.0652854,-2.2028074,52.1324599,-2.3275852,0.1357589,0.0683629,-2.2353482
-1615570475,52.1324522,-2.3275836,0.1335749,0.0657733,-1.5749267,52.1324599,-2.3275852,0.1357073,0.0684656,-2.2370236
-1615570476,52.1324522,-2.3275836,0.1330595,0.0630900,-2.3210139,52.1324598,-2.3275852,0.1357737,0.0684722,-2.2366748
-1615570476,52.1324523,-2.3275836,0.1306350,0.0672371,-2.3110061,52.1324598,-2.3275852,0.1358516,0.0684732,-2.2361794
-1615570477,52.1324523,-2.3275836,0.1350036,0.0601633,-2.2785947,52.1324598,-2.3275852,0.1358818,0.0685471,-2.2369421
-1615570477,52.1324523,-2.3275837,0.1306180,0.0652854,-2.2263150,52.1324598,-2.3275852,0.1359278,0.0685235,-2.2363358
-1615570477,52.1324524,-2.3275836,0.1311121,0.0655293,-2.4569035,52.1324598,-2.3275852,0.1358988,0.0685858,-2.2373340
-1615570478,52.1324524,-2.3275836,0.1343198,0.0665052,-1.4418619,52.1324598,-2.3275852,0.1358963,0.0685929,-2.2374427
-1615570478,52.1324525,-2.3275836,0.1345748,0.0674811,-1.9413086,52.1324598,-2.3275852,0.1358887,0.0685925,-2.2374871
-1615570478,52.1324525,-2.3275837,0.1318785,0.0687011,-2.3154197,52.1324598,-2.3275852,0.1358338,0.0686472,-2.2385559
-1615570479,52.1324526,-2.3275838,0.1311271,0.0672371,-1.9978822,52.1324598,-2.3275852,0.1359509,0.0687197,-2.2387333
-1615570479,52.1324527,-2.3275837,0.1318481,0.0652854,-2.3897657,52.1324598,-2.3275852,0.1359532,0.0686768,-2.2381625
-1615570480,52.1324528,-2.3275836,0.1284360,0.0689451,-1.8203248,52.1324598,-2.3275852,0.1359738,0.0687180,-2.2385621
-1615570480,52.1324527,-2.3275837,0.1326013,0.0669931,-2.7142279,52.1324598,-2.3275852,0.1360260,0.0688018,-2.2393079
-1615570480,52.1324528,-2.3275837,0.1323552,0.0669931,-2.0138340,52.1324598,-2.3275852,0.1361509,0.0688554,-2.2391891
-1615570481,52.1324529,-2.3275838,0.1316041,0.0655293,-1.6642183,52.1324598,-2.3275852,0.1360499,0.0688212,-2.2394035
-1615570481,52.1324530,-2.3275838,0.1298800,0.0652854,-1.9155313,52.1324597,-2.3275852,0.1360470,0.0688585,-2.2399046
-1615570481,52.1324530,-2.3275839,0.1311292,0.0674811,-2.5122862,52.1324597,-2.3275852,0.1360887,0.0688541,-2.2395778
-1615570482,52.1324531,-2.3275840,0.1279186,0.0660173,-2.4779809,52.1324597,-2.3275852,0.1361437,0.0689116,-2.2399635
-1615570482,52.1324532,-2.3275840,0.1360364,0.0657733,-2.2758620,52.1324597,-2.3275852,0.1361917,0.0688511,-2.2388697
-1615570483,52.1324533,-2.3275841,0.1330805,0.0655293,-2.3205926,52.1324597,-2.3275852,0.1362775,0.0689271,-2.2392938
-1615570483,52.1324534,-2.3275841,0.1298905,0.0665052,-2.4541075,52.1324597,-2.3275852,0.1362917,0.0689206,-2.2391183
-1615570483,52.1324535,-2.3275841,0.1348077,0.0660173,-2.3268569,52.1324597,-2.3275852,0.1362777,0.0689150,-2.2391374
-1615570484,52.1324536,-2.3275842,0.1303868,0.0669931,-2.8615060,52.1324597,-2.3275852,0.1362823,0.0688749,-2.2385907
-1615570484,52.1324537,-2.3275843,0.1335621,0.0643096,-2.3961892,52.1324597,-2.3275852,0.1362332,0.0688990,-2.2392199
-1615570484,52.1324538,-2.3275844,0.1308661,0.0655293,-2.6388078,52.1324597,-2.3275852,0.1362447,0.0689041,-2.2392101
-1615570485,52.1324539,-2.3275845,0.1345793,0.0679691,-2.2098279,52.1324597,-2.3275852,0.1361398,0.0687763,-2.2382400
-1615570485,52.1324540,-2.3275845,0.1304199,0.0706532,-2.8722663,52.1324597,-2.3275852,0.1360711,0.0687947,-2.2389245
-1615570486,52.1324541,-2.3275846,0.1367490,0.0628461,-2.0337114,52.1324597,-2.3275852,0.1360775,0.0689124,-2.2404060
-1615570486,52.1324542,-2.3275847,0.1333419,0.0672371,-1.9969568,52.1324597,-2.3275852,0.1359718,0.0688028,-2.2396743
-1615570486,52.1324542,-2.3275848,0.1294113,0.0679691,-2.4432254,52.1324597,-2.3275852,0.1359816,0.0686813,-2.2380352
-1615570487,52.1324543,-2.3275849,0.1335684,0.0650414,-2.1027117,52.1324597,-2.3275852,0.1359432,0.0686749,-2.2382021
-1615570487,52.1324544,-2.3275850,0.1293657,0.0626022,-2.2060983,52.1324596,-2.3275852,0.1359077,0.0686415,-2.2380009
-1615570487,52.1324545,-2.3275850,0.1365422,0.0672371,-2.1634536,52.1324596,-2.3275852,0.1359738,0.0686413,-2.2375665
-1615570488,52.1324545,-2.3275852,0.1311446,0.0691891,-2.5771160,52.1324596,-2.3275852,0.1359759,0.0686128,-2.2371831
-1615570488,52.1324546,-2.3275853,0.1320815,0.0638218,-2.1251383,52.1324596,-2.3275852,0.1359863,0.0686393,-2.2374597
-1615570489,52.1324547,-2.3275853,0.1294006,0.0667492,-2.2644584,52.1324596,-2.3275852,0.1359524,0.0686280,-2.2375348
-1615570489,52.1324548,-2.3275853,0.1340825,0.0674811,-2.3752930,52.1324596,-2.3275852,0.1359036,0.0686805,-2.2385342
-1615570489,52.1324549,-2.3275854,0.1306264,0.0662612,-2.5515363,52.1324596,-2.3275852,0.1358797,0.0686876,-2.2387819
-1615570490,52.1324550,-2.3275855,0.1335792,0.0662612,-2.3993695,52.1324596,-2.3275852,0.1358506,0.0687616,-2.2399316
-1615570490,52.1324550,-2.3275856,0.1328197,0.0638218,-2.3116817,52.1324596,-2.3275852,0.1359632,0.0688088,-2.2398119
-1615570490,52.1324551,-2.3275856,0.1313775,0.0677251,-1.8863583,52.1324596,-2.3275852,0.1359353,0.0687868,-2.2397072
-1615570491,52.1324551,-2.3275856,0.1308789,0.0669931,-2.4281788,52.1324596,-2.3275852,0.1359518,0.0688027,-2.2398052
-1615570491,52.1324552,-2.3275856,0.1303740,0.0655293,-2.1238017,52.1324596,-2.3275852,0.1360048,0.0688760,-2.2404108
-1615570492,52.1324553,-2.3275856,0.1350517,0.0657733,-2.8263659,52.1324596,-2.3275852,0.1359444,0.0688536,-2.2405131
-1615570492,52.1324554,-2.3275857,0.1311292,0.0674811,-2.1614394,52.1324596,-2.3275852,0.1359461,0.0689026,-2.2411373
-1615570492,52.1324554,-2.3275856,0.1316214,0.0674811,-2.6110532,52.1324596,-2.3275852,0.1360058,0.0688874,-2.2405517
-1615570493,52.1324555,-2.3275855,0.1345550,0.0652854,-2.3907371,52.1324596,-2.3275852,0.1360029,0.0689854,-2.2418396
-1615570493,52.1324555,-2.3275856,0.1301386,0.0667492,-2.3075070,52.1324596,-2.3275852,0.1359533,0.0689473,-2.2416677
-1615570493,52.1324556,-2.3275856,0.1333160,0.0643096,-2.7931347,52.1324596,-2.3275852,0.1359530,0.0688986,-2.2410398
-1615570494,52.1324556,-2.3275857,0.1345929,0.0694331,-2.3030567,52.1324596,-2.3275852,0.1360008,0.0689048,-2.2408092
-1615570494,52.1324556,-2.3275856,0.1341144,0.0708973,-2.9934220,52.1324596,-2.3275852,0.1359670,0.0689813,-2.2420189
-1615570495,52.1324556,-2.3275857,0.1365422,0.0672371,-2.4178839,52.1324596,-2.3275852,0.1359326,0.0689537,-2.2418861
-1615570495,52.1324556,-2.3275857,0.1328562,0.0679691,-2.5960088,52.1324596,-2.3275852,0.1358850,0.0689665,-2.2423601
-1615570495,52.1324557,-2.3275857,0.1323574,0.0672371,-2.4731522,52.1324596,-2.3275852,0.1359360,0.0689294,-2.2415488
-1615570496,52.1324556,-2.3275858,0.1321335,0.0696771,-2.1068847,52.1324595,-2.3275852,0.1359454,0.0689306,-2.2415023
-1615570496,52.1324556,-2.3275859,0.1323423,0.0655293,-2.5721624,52.1324595,-2.3275852,0.1359335,0.0689760,-2.2421682
-1615570496,52.1324556,-2.3275859,0.1326123,0.0682131,-1.9290054,52.1324595,-2.3275852,0.1357939,0.0689648,-2.2429309
-1615570497,52.1324556,-2.3275858,0.1318335,0.0635778,-2.4400594,52.1324595,-2.3275852,0.1358106,0.0689206,-2.2422483
-1615570497,52.1324555,-2.3275859,0.1345422,0.0638218,-2.2653944,52.1324595,-2.3275852,0.1358304,0.0689247,-2.2421739
-1615570498,52.1324556,-2.3275858,0.1328387,0.0660173,-2.3746631,52.1324595,-2.3275852,0.1358504,0.0689893,-2.2428808
-1615570498,52.1324555,-2.3275859,0.1308577,0.0645536,-1.9913163,52.1324595,-2.3275852,0.1358728,0.0689974,-2.2428393
-1615570498,52.1324555,-2.3275860,0.1345486,0.0645536,-2.8841429,52.1324595,-2.3275852,0.1358720,0.0690874,-2.2440107
-1615570499,52.1324555,-2.3275860,0.1303678,0.0647975,-1.8857791,52.1324595,-2.3275852,0.1358626,0.0691369,-2.2447135
-1615570499,52.1324554,-2.3275861,0.1370530,0.0691891,-2.1623850,52.1324595,-2.3275852,0.1359067,0.0691003,-2.2439525
-1615570499,52.1324554,-2.3275862,0.1325841,0.0650414,-2.3459558,52.1324595,-2.3275852,0.1358939,0.0690725,-2.2436755
-1615570500,52.1324554,-2.3275862,0.1328540,0.0677251,-2.0915880,52.1324595,-2.3275852,0.1360438,0.0690221,-2.2420497
-1615570500,52.1324553,-2.3275862,0.1318875,0.0696771,-2.3757725,52.1324595,-2.3275852,0.1360945,0.0689107,-2.2402804
-1615570501,52.1324552,-2.3275862,0.1340982,0.0691891,-2.3134665,52.1324595,-2.3275852,0.1359978,0.0688326,-2.2398977
-1615570501,52.1324551,-2.3275862,0.1345036,0.0591878,-2.4820700,52.1324595,-2.3275852,0.1360792,0.0687461,-2.2382493
-1615570501,52.1324551,-2.3275861,0.1316279,0.0682131,-2.3294213,52.1324595,-2.3275852,0.1361078,0.0687274,-2.2378223
-1615570502,52.1324551,-2.3275861,0.1333353,0.0665052,-1.7690291,52.1324595,-2.3275852,0.1361722,0.0687289,-2.2374225
-1615570502,52.1324550,-2.3275860,0.1318397,0.0643096,-2.9942658,52.1324595,-2.3275852,0.1361929,0.0687754,-2.2378888
-1615570502,52.1324550,-2.3275859,0.1360657,0.0689451,-2.8694303,52.1324595,-2.3275852,0.1362031,0.0687256,-2.2371788
-1615570503,52.1324549,-2.3275858,0.1315895,0.0638218,-1.9060351,52.1324595,-2.3275852,0.1362652,0.0687843,-2.2375352
-1615570503,52.1324549,-2.3275857,0.1313731,0.0672371,-2.3334947,52.1324595,-2.3275852,0.1363326,0.0687253,-2.2363358
-1615570504,52.1324548,-2.3275857,0.1335537,0.0633339,-2.2950675,52.1324595,-2.3275852,0.1362644,0.0688205,-2.2380073
-1615570504,52.1324548,-2.3275856,0.1355353,0.0647975,-2.4632154,52.1324595,-2.3275852,0.1361895,0.0687712,-2.2378559
-1615570504,52.1324547,-2.3275855,0.1296552,0.0677251,-2.1465788,52.1324595,-2.3275852,0.1362403,0.0687524,-2.2372832
-1615570505,52.1324547,-2.3275854,0.1360452,0.0667492,-1.9862156,52.1324594,-2.3275852,0.1361999,0.0688235,-2.2384634
-1615570505,52.1324547,-2.3275853,0.1318481,0.0652854,-2.2739162,52.1324594,-2.3275852,0.1360474,0.0688516,-2.2398176
-1615570505,52.1324547,-2.3275852,0.1345115,0.0601633,-2.9261887,52.1324594,-2.3275852,0.1360393,0.0687863,-2.2390249
-1615570506,52.1324547,-2.3275851,0.1304086,0.0694331,-2.5686493,52.1324594,-2.3275852,0.1360150,0.0687258,-2.2383990
-1615570506,52.1324546,-2.3275849,0.1318830,0.0691891,-1.8556346,52.1324594,-2.3275852,0.1359182,0.0687217,-2.2389765
-1615570507,52.1324546,-2.3275848,0.1335858,0.0669931,-2.2655451,52.1324594,-2.3275852,0.1358442,0.0687147,-2.2393675
-1615570507,52.1324546,-2.3275848,0.1316302,0.0684571,-2.5535512,52.1324594,-2.3275852,0.1358481,0.0687403,-2.2396741
-1615570507,52.1324545,-2.3275846,0.1308963,0.0689451,-2.2627358,52.1324594,-2.3275852,0.1358381,0.0687779,-2.2402282
-1615570508,52.1324545,-2.3275845,0.1333309,0.0660173,-1.9964566,52.1324594,-2.3275852,0.1358529,0.0688523,-2.2410965
-1615570508,52.1324544,-2.3275844,0.1313539,0.0650414,-1.8780228,52.1324594,-2.3275852,0.1359046,0.0687228,-2.2390807
-1615570508,52.1324544,-2.3275844,0.1340607,0.0650414,-1.9414864,52.1324594,-2.3275852,0.1359616,0.0688551,-2.2404244
-1615570509,52.1324544,-2.3275843,0.1326013,0.0669931,-2.8181148,52.1324594,-2.3275852,0.1359194,0.0688378,-2.2404747
-1615570509,52.1324543,-2.3275842,0.1321246,0.0687011,-2.1483245,52.1324594,-2.3275852,0.1358114,0.0688305,-2.2410829
-1615570510,52.1324543,-2.3275841,0.1340693,0.0660173,-2.3738544,52.1324594,-2.3275852,0.1358505,0.0687390,-2.2396410
-1615570510,52.1324543,-2.3275841,0.1345572,0.0655293,-2.1769347,52.1324594,-2.3275852,0.1358423,0.0688004,-2.2404909
-1615570510,52.1324543,-2.3275840,0.1321268,0.0689451,-2.5122156,52.1324594,-2.3275852,0.1357993,0.0688188,-2.2410100
-1615570511,52.1324542,-2.3275839,0.1309008,0.0694331,-1.8093923,52.1324594,-2.3275852,0.1357499,0.0688157,-2.2412920
-1615570511,52.1324543,-2.3275839,0.1330979,0.0674811,-2.2149835,52.1324594,-2.3275852,0.1356260,0.0688102,-2.2420292
-1615570511,52.1324543,-2.3275838,0.1353133,0.0674811,-2.3259330,52.1324594,-2.3275852,0.1356654,0.0688136,-2.2418163
-1615570512,52.1324544,-2.3275837,0.1316214,0.0674811,-2.5677860,52.1324594,-2.3275852,0.1356234,0.0687635,-2.2414391
-1615570512,52.1324543,-2.3275836,0.1320836,0.0640657,-2.3388414,52.1324594,-2.3275852,0.1355932,0.0688707,-2.2430320
-1615570513,52.1324543,-2.3275836,0.1335858,0.0669931,-1.8816278,52.1324594,-2.3275852,0.1356372,0.0688721,-2.2427623
-1615570513,52.1324544,-2.3275835,0.1320941,0.0652854,-2.8806937,52.1324593,-2.3275852,0.1355226,0.0688726,-2.2435184
-1615570513,52.1324544,-2.3275835,0.1309075,0.0701652,-2.4525349,52.1324593,-2.3275852,0.1354723,0.0689051,-2.2442708
-1615570514,52.1324544,-2.3275834,0.1316413,0.0696771,-1.8201683,52.1324593,-2.3275852,0.1355115,0.0689116,-2.2440987
-1615570514,52.1324545,-2.3275834,0.1360520,0.0674811,-2.4447033,52.1324593,-2.3275852,0.1355069,0.0689742,-2.2449431
-1615570514,52.1324545,-2.3275833,0.1357793,0.0645536,-2.3593512,52.1324593,-2.3275852,0.1354945,0.0690376,-2.2458496
-1615570515,52.1324545,-2.3275833,0.1335770,0.0660173,-2.7879827,52.1324593,-2.3275852,0.1355129,0.0690675,-2.2461181
-1615570515,52.1324546,-2.3275833,0.1306222,0.0657733,-2.5823798,52.1324593,-2.3275852,0.1355235,0.0690192,-2.2454212
-1615570516,52.1324547,-2.3275832,0.1325473,0.0606510,-1.8377521,52.1324593,-2.3275852,0.1354804,0.0690508,-2.2461145
-1615570516,52.1324547,-2.3275832,0.1318566,0.0662612,-1.9898698,52.1324593,-2.3275852,0.1356611,0.0691517,-2.2462471
-1615570516,52.1324548,-2.3275831,0.1311446,0.0691891,-2.4630773,52.1324593,-2.3275852,0.1356152,0.0691627,-2.2466879
-1615570517,52.1324548,-2.3275831,0.1308598,0.0647975,-3.0069885,52.1324593,-2.3275852,0.1356613,0.0692838,-2.2479596
-1615570517,52.1324549,-2.3275830,0.1358080,0.0677251,-2.5720916,52.1324593,-2.3275852,0.1356450,0.0692038,-2.2470284
-1615570517,52.1324551,-2.3275829,0.1343331,0.0679691,-2.3669548,52.1324593,-2.3275852,0.1355895,0.0692384,-2.2478390
-1615570518,52.1324551,-2.3275828,0.1321113,0.0672371,-2.1111465,52.1324593,-2.3275852,0.1356821,0.0691837,-2.2465253
-1615570518,52.1324553,-2.3275827,0.1308598,0.0647975,-1.8710835,52.1324593,-2.3275852,0.1355807,0.0692016,-2.2474191
-1615570519,52.1324553,-2.3275826,0.1303740,0.0655293,-2.3082304,52.1324593,-2.3275852,0.1355298,0.0691845,-2.2475290
-1615570519,52.1324554,-2.3275825,0.1318875,0.0696771,-2.4765768,52.1324593,-2.3275852,0.1355634,0.0692156,-2.2477140
-1615570519,52.1324555,-2.3275823,0.1288982,0.0655293,-2.3679528,52.1324593,-2.3275852,0.1355093,0.0692275,-2.2482209
-1615570520,52.1324556,-2.3275822,0.1311121,0.0655293,-2.4830968,52.1324593,-2.3275852,0.1355177,0.0692679,-2.2486916
-1615570520,52.1324557,-2.3275821,0.1318566,0.0662612,-2.2783818,52.1324593,-2.3275852,0.1355854,0.0692856,-2.2484803
-1615570520,52.1324558,-2.3275820,0.1331113,0.0689451,-2.5817971,52.1324593,-2.3275852,0.1355740,0.0692801,-2.2484827
-1615570521,52.1324559,-2.3275819,0.1348300,0.0684571,-2.1769419,52.1324593,-2.3275852,0.1354994,0.0692157,-2.2481332
-1615570521,52.1324559,-2.3275819,0.1318213,0.0621144,-1.5355632,52.1324593,-2.3275852,0.1354964,0.0692394,-2.2484608
-1615570522,52.1324561,-2.3275817,0.1328366,0.0657733,-2.1105373,52.1324593,-2.3275852,0.1355199,0.0692173,-2.2480199
-1615570522,52.1324561,-2.3275816,0.1335579,0.0638218,-2.5146108,52.1324593,-2.3275852,0.1354017,0.0691568,-2.2480054
-1615570522,52.1324562,-2.3275815,0.1323797,0.0696771,-2.4155900,52.1324593,-2.3275851,0.1355084,0.0692230,-2.2481689
-1615570523,52.1324562,-2.3275814,0.1261831,0.0643096,-1.6209687,52.1324592,-2.3275851,0.1354641,0.0692245,-2.2484787
-1615570523,52.1324563,-2.3275814,0.1306307,0.0667492,-3.0322208,52.1324592,-2.3275851,0.1355606,0.0693180,-2.2490637
-1615570523,52.1324564,-2.3275812,0.1328562,0.0679691,-2.5320504,52.1324592,-2.3275851,0.1354537,0.0692741,-2.2491920
-1615570524,52.1324565,-2.3275812,0.1328562,0.0679691,-1.8313860,52.1324592,-2.3275851,0.1355071,0.0692574,-2.2486243
-1615570524,52.1324565,-2.3275812,0.1315834,0.0630900,-2.0521412,52.1324592,-2.3275851,0.1355156,0.0692173,-2.2480476
-1615570525,52.1324566,-2.3275811,0.1338275,0.0665052,-1.9704711,52.1324592,-2.3275851,0.1355867,0.0692732,-2.2483108
-1615570525,52.1324566,-2.3275811,0.1313581,0.0655293,-2.0837941,52.1324592,-2.3275851,0.1356307,0.0693279,-2.2487340
-1615570525,52.1324567,-2.3275809,0.1333419,0.0672371,-1.6713624,52.1324592,-2.3275851,0.1355468,0.0693145,-2.2491059
-1615570526,52.1324568,-2.3275808,0.1350808,0.0689451,-2.2889214,52.1324592,-2.3275851,0.1354755,0.0691997,-2.2480800
-1615570526,52.1324569,-2.3275808,0.1293778,0.0640657,-2.2389719,52.1324592,-2.3275851,0.1353603,0.0692345,-2.2492859
-1615570526,52.1324569,-2.3275806,0.1313456,0.0640657,-2.6516366,52.1324592,-2.3275851,0.1353210,0.0691667,-2.2486598
-1615570527,52.1324570,-2.3275806,0.1340915,0.0684571,-2.0876467,52.1324592,-2.3275851,0.1352997,0.0691853,-2.2490416
-1615570527,52.1324571,-2.3275805,0.1308598,0.0647975,-2.1792865,52.1324592,-2.3275851,0.1352508,0.0691077,-2.2483506
-1615570528,52.1324572,-2.3275804,0.1289087,0.0667492,-2.4634213,52.1324592,-2.3275851,0.1352467,0.0691044,-2.2483337
-1615570528,52.1324573,-2.3275803,0.1345770,0.0677251,-2.0968058,52.1324592,-2.3275851,0.1352813,0.0692006,-2.2493615
-1615570528,52.1324573,-2.3275802,0.1323173,0.0626022,-1.7926027,52.1324592,-2.3275851,0.1352963,0.0692637,-2.2500868
-1615570529,52.1324575,-2.3275802,0.1316106,0.0662612,-2.1408317,52.1324592,-2.3275851,0.1352922,0.0693249,-2.2509103
-1615570529,52.1324575,-2.3275801,0.1308682,0.0657733,-2.0456309,52.1324592,-2.3275851,0.1352528,0.0693041,-2.2508972
-1615570529,52.1324576,-2.3275799,0.1363027,0.0679691,-1.8647910,52.1324592,-2.3275851,0.1352976,0.0691961,-2.2491965
-1615570530,52.1324577,-2.3275799,0.1298863,0.0660173,-2.2407613,52.1324592,-2.3275851,0.1353218,0.0691567,-2.2485242
-1615570530,52.1324577,-2.3275798,0.1316020,0.0652854,-2.3566670,52.1324592,-2.3275851,0.1352057,0.0691270,-2.2488976
-1615570531,52.1324579,-2.3275796,0.1348055,0.0657733,-2.3831801,52.1324592,-2.3275851,0.1352583,0.0691506,-2.2488604
-1615570531,52.1324579,-2.3275796,0.1323297,0.0640657,-1.8347315,52.1324592,-2.3275851,0.1352326,0.0691544,-2.2490788
-1615570531,52.1324579,-2.3275795,0.1326258,0.0696771,-2.1522980,52.1324592,-2.3275851,0.1351640,0.0691557,-2.2495458
-1615570532,52.1324580,-2.3275794,0.1330513,0.0621144,-1.9871281,52.1324592,-2.3275850,0.1351355,0.0691382,-2.2495041
-1615570532,52.1324581,-2.3275793,0.1318897,0.0699211,-2.1829164,52.1324592,-2.3275850,0.1351900,0.0690394,-2.2478549
-1615570532,52.1324582,-2.3275793,0.1296382,0.0657733,-2.3824244,52.1324592,-2.3275850,0.1351651,0.0690401,-2.2480280
-1615570533,52.1324583,-2.3275792,0.1346045,0.0706532,-2.6400146,52.1324592,-2.3275850,0.1350928,0.0690063,-2.2480607
-1615570533,52.1324583,-2.3275792,0.1303555,0.0633339,-2.6070452,52.1324592,-2.3275850,0.1350779,0.0690647,-2.2489228
-1615570534,52.1324584,-2.3275791,0.1343176,0.0662612,-2.1344392,52.1324592,-2.3275850,0.1351186,0.0689407,-2.2470326
-1615570534,52.1324585,-2.3275791,0.1333331,0.0662612,-2.2503066,52.1324592,-2.3275850,0.1350909,0.0690024,-2.2480221
-1615570534,52.1324585,-2.3275791,0.1342898,0.0630900,-1.9983476,52.1324592,-2.3275850,0.1350303,0.0688865,-2.2469029
-1615570535,52.1324586,-2.3275790,0.1350561,0.0662612,-1.8463309,52.1324592,-2.3275850,0.1350371,0.0687869,-2.2455518
-1615570535,52.1324587,-2.3275790,0.1272148,0.0699211,-2.5622585,52.1324592,-2.3275850,0.1350957,0.0687714,-2.2449629
-1615570535,52.1324588,-2.3275789,0.1299368,0.0716294,-2.6180453,52.1324592,-2.3275850,0.1350857,0.0687254,-2.2444251
-1615570536,52.1324589,-2.3275789,0.1335814,0.0665052,-2.8766856,52.1324592,-2.3275850,0.1349949,0.0687172,-2.2449164
-1615570536,52.1324590,-2.3275789,0.1328094,0.0626022,-2.0780578,52.1324592,-2.3275850,0.1350880,0.0686570,-2.2435122
-1615570537,52.1324591,-2.3275789,0.1298758,0.0647975,-2.3825567,52.1324592,-2.3275850,0.1351135,0.0687662,-2.2447758
-1615570537,52.1324592,-2.3275788,0.1303762,0.0657733,-1.8264526,52.1324592,-2.3275850,0.1350062,0.0687083,-2.2447243
-1615570537,52.1324593,-2.3275788,0.1325927,0.0660173,-2.3711743,52.1324592,-2.3275850,0.1350304,0.0687549,-2.2451756
-1615570538,52.1324594,-2.3275787,0.1353133,0.0674811,-2.3247061,52.1324592,-2.3275850,0.1350376,0.0687032,-2.2444501
-1615570538,52.1324595,-2.3275787,0.1367929,0.0677251,-2.5285008,52.1324592,-2.3275850,0.1349766,0.0686349,-2.2439556
-1615570538,52.1324596,-2.3275787,0.1343068,0.0650414,-2.3092275,52.1324592,-2.3275849,0.1350722,0.0686510,-2.2435369
-1615570539,52.1324597,-2.3275786,0.1320941,0.0652854,-1.9936249,52.1324592,-2.3275849,0.1350779,0.0685366,-2.2419977
-1615570539,52.1324597,-2.3275786,0.1301494,0.0679691,-2.5723004,52.1324592,-2.3275849,0.1351006,0.0686073,-2.2427754
-1615570540,52.1324598,-2.3275785,0.1340715,0.0662612,-2.3334901,52.1324592,-2.3275849,0.1352689,0.0687108,-2.2430246
-1615570540,52.1324598,-2.3275784,0.1318418,0.0645536,-2.1007037,52.1324592,-2.3275849,0.1352298,0.0687183,-2.2433791
-1615570540,52.1324599,-2.3275783,0.1325778,0.0643096,-2.1906095,52.1324592,-2.3275849,0.1351736,0.0686616,-2.2430062
-1615570541,52.1324598,-2.3275782,0.1367728,0.0655293,-2.4727681,52.1324592,-2.3275849,0.1352230,0.0686186,-2.2421174
-1615570541,52.1324599,-2.3275781,0.1304131,0.0699211,-2.8351521,52.1324592,-2.3275849,0.1352587,0.0686342,-2.2420883
-1615570541,52.1324599,-2.3275781,0.1338210,0.0657733,-2.3219538,52.1324592,-2.3275849,0.1352626,0.0686475,-2.2422366
-1615570542,52.1324600,-2.3275780,0.1335969,0.0682131,-2.4799695,52.1324592,-2.3275849,0.1353283,0.0687595,-2.2432692
-1615570542,52.1324600,-2.3275780,0.1318481,0.0652854,-2.3690073,52.1324592,-2.3275849,0.1354063,0.0687665,-2.2428498
-1615570543,52.1324601,-2.3275779,0.1338363,0.0674811,-2.5566010,52.1324592,-2.3275849,0.1353591,0.0687718,-2.2432280
-1615570543,52.1324602,-2.3275779,0.1350324,0.0635778,-2.2724714,52.1324592,-2.3275849,0.1352736,0.0686990,-2.2428386
-1615570543,52.1324603,-2.3275779,0.1330892,0.0665052,-2.3613896,52.1324592,-2.3275849,0.1351653,0.0686722,-2.2431989
-1615570544,52.1324603,-2.3275777,0.1316106,0.0662612,-2.7850676,52.1324592,-2.3275849,0.1351265,0.0686939,-2.2437384
-1615570544,52.1324604,-2.3275777,0.1340892,0.0682131,-2.2863500,52.1324592,-2.3275849,0.1351444,0.0686307,-2.2427924
-1615570544,52.1324604,-2.3275776,0.1328629,0.0687011,-2.3215554,52.1324592,-2.3275849,0.1352077,0.0685635,-2.2414951
-1615570545,52.1324605,-2.3275777,0.1316020,0.0652854,-2.2110577,52.1324592,-2.3275848,0.1351735,0.0686184,-2.2424395
-1615570545,52.1324605,-2.3275776,0.1357520,0.0613827,-1.7422807,52.1324592,-2.3275848,0.1352490,0.0686388,-2.2422104
-1615570546,52.1324606,-2.3275776,0.1330699,0.0643096,-2.1204810,52.1324592,-2.3275848,0.1352007,0.0687356,-2.2437949
-1615570546,52.1324606,-2.3275775,0.1326236,0.0694331,-2.3359027,52.1324592,-2.3275848,0.1351937,0.0687950,-2.2446184
-1615570546,52.1324607,-2.3275774,0.1311674,0.0716294,-2.6513073,52.1324592,-2.3275848,0.1351657,0.0687531,-2.2442532
-1615570547,52.1324607,-2.3275773,0.1355528,0.0667492,-2.6130548,52.1324592,-2.3275848,0.1351637,0.0687222,-2.2438626
-1615570547,52.1324607,-2.3275773,0.1296340,0.0652854,-2.6426001,52.1324592,-2.3275848,0.1351560,0.0687850,-2.2447360
-1615570547,52.1324607,-2.3275773,0.1318696,0.0677251,-2.4113479,52.1324592,-2.3275848,0.1349799,0.0688156,-2.2462947
-1615570548,52.1324607,-2.3275772,0.1330784,0.0652854,-2.9715419,52.1324592,-2.3275848,0.1348890,0.0687443,-2.2459576
-1615570548,52.1324607,-2.3275772,0.1333245,0.0652854,-2.3167253,52.1324592,-2.3275848,0.1348899,0.0687883,-2.2465298
-1615570549,52.1324607,-2.3275772,0.1348368,0.0691891,-2.2030764,52.1324592,-2.3275848,0.1348211,0.0687270,-2.2461774
-1615570549,52.1324607,-2.3275773,0.1325948,0.0662612,-2.1118178,52.1324592,-2.3275848,0.1348631,0.0687197,-2.2458043
-1615570549,52.1324607,-2.3275772,0.1333507,0.0682131,-1.9949918,52.1324592,-2.3275848,0.1347687,0.0687850,-2.2472863
-1615570550,52.1324607,-2.3275772,0.1328431,0.0665052,-2.1137233,52.1324592,-2.3275848,0.1347931,0.0687830,-2.2470989
-1615570550,52.1324607,-2.3275772,0.1298616,0.0630900,-2.4419188,52.1324592,-2.3275848,0.1348066,0.0687919,-2.2471273
-1615570550,52.1324607,-2.3275772,0.1288961,0.0652854,-2.6046848,52.1324592,-2.3275848,0.1348619,0.0687637,-2.2463918
-1615570551,52.1324607,-2.3275772,0.1340803,0.0672371,-1.6825398,52.1324592,-2.3275847,0.1349434,0.0688177,-2.2465634
-1615570551,52.1324607,-2.3275771,0.1335496,0.0628461,-2.1039586,52.1324592,-2.3275847,0.1348971,0.0688516,-2.2473133
-1615570552,52.1324607,-2.3275770,0.1330892,0.0665052,-2.4457147,52.1324592,-2.3275847,0.1349644,0.0688087,-2.2463071
-1615570552,52.1324607,-2.3275771,0.1331046,0.0682131,-2.5426245,52.1324592,-2.3275847,0.1349024,0.0688559,-2.2473354
-1615570552,52.1324606,-2.3275771,0.1357771,0.0643096,-2.3483400,52.1324592,-2.3275847,0.1348525,0.0688354,-2.2473955
-1615570553,52.1324607,-2.3275770,0.1303911,0.0674811,-2.1892912,52.1324592,-2.3275847,0.1347610,0.0688312,-2.2479429
-1615570553,52.1324606,-2.3275770,0.1315813,0.0628461,-2.4180646,52.1324592,-2.3275847,0.1348760,0.0689378,-2.2485859
-1615570553,52.1324606,-2.3275770,0.1298926,0.0667492,-2.6622591,52.1324592,-2.3275847,0.1347724,0.0689156,-2.2489774
-1615570554,52.1324606,-2.3275769,0.1367861,0.0669931,-2.4062097,52.1324592,-2.3275847,0.1346878,0.0689168,-2.2495522
-1615570554,52.1324605,-2.3275769,0.1316192,0.0672371,-2.3098316,52.1324592,-2.3275847,0.1346483,0.0689564,-2.2503328
-1615570555,52.1324605,-2.3275769,0.1267317,0.0708973,-2.5952926,52.1324592,-2.3275847,0.1346236,0.0690039,-2.2511225
-1615570555,52.1324604,-2.3275770,0.1311079,0.0650414,-2.4491818,52.1324592,-2.3275847,0.1346923,0.0689754,-2.2502935
-1615570555,52.1324604,-2.3275769,0.1343399,0.0687011,-2.1377258,52.1324592,-2.3275847,0.1347154,0.0689799,-2.2502000
-1615570556,52.1324603,-2.3275769,0.1353044,0.0665052,-1.9881240,52.1324592,-2.3275847,0.1346690,0.0690642,-2.2516150
-1615570556,52.1324603,-2.3275768,0.1323774,0.0694331,-2.3280444,52.1324592,-2.3275847,0.1346134,0.0690131,-2.2513094
-1615570556,52.1324604,-2.3275770,0.1352891,0.0647975,-2.1810527,52.1324592,-2.3275846,0.1346184,0.0690587,-2.2518764
-1615570557,52.1324603,-2.3275769,0.1338408,0.0679691,-2.1296144,52.1324592,-2.3275846,0.1346746,0.0691699,-2.2529674
-1615570557,52.1324603,-2.3275769,0.1315937,0.0643096,-2.8343706,52.1324592,-2.3275846,0.1346920,0.0692156,-2.2534533
-1615570558,52.1324603,-2.3275769,0.1303846,0.0667492,-1.7309088,52.1324592,-2.3275846,0.1346737,0.0690958,-2.2520003
-1615570558,52.1324603,-2.3275769,0.1335727,0.0655293,-3.0852427,52.1324592,-2.3275846,0.1347560,0.0692042,-2.2528806
-1615570558,52.1324603,-2.3275770,0.1340458,0.0633339,-2.2808509,52.1324592,-2.3275846,0.1348381,0.0692259,-2.2526245
-1615570559,52.1324602,-2.3275769,0.1298477,0.0613827,-1.8963104,52.1324592,-2.3275846,0.1347147,0.0690856,-2.2515969
-1615570559,52.1324602,-2.3275769,0.1294028,0.0669931,-2.5561225,52.1324593,-2.3275846,0.1347177,0.0690516,-2.2511294
-1615570559,52.1324603,-2.3275769,0.1350473,0.0652854,-2.0858836,52.1324593,-2.3275846,0.1347289,0.0690885,-2.2515407
-1615570560,52.1324603,-2.3275768,0.1355595,0.0674811,-2.5182450,52.1324593,-2.3275846,0.1345877,0.0690912,-2.2525091
-1615570560,52.1324602,-2.3275768,0.1345704,0.0669931,-2.4443257,52.1324593,-2.3275846,0.1346058,0.0690652,-2.2520468
-1615570561,52.1324603,-2.3275767,0.1350605,0.0667492,-2.2473087,52.1324593,-2.3275846,0.1346033,0.0690366,-2.2516870
-1615570561,52.1324602,-2.3275768,0.1353456,0.0708973,-2.4442496,52.1324593,-2.3275846,0.1345410,0.0689397,-2.2508230
-1615570561,52.1324603,-2.3275767,0.1340500,0.0638218,-2.0602889,52.1324593,-2.3275846,0.1346002,0.0689187,-2.2501545
-1615570562,52.1324603,-2.3275767,0.1288961,0.0652854,-1.4339433,52.1324593,-2.3275846,0.1344916,0.0689784,-2.2516601
-1615570562,52.1324603,-2.3275767,0.1338081,0.0643096,-1.7501307,52.1324593,-2.3275845,0.1345406,0.0689832,-2.2513995
-1615570562,52.1324602,-2.3275766,0.1311249,0.0669931,-2.3039227,52.1324593,-2.3275845,0.1345790,0.0690138,-2.2515490
-1615570563,52.1324602,-2.3275766,0.1362914,0.0667492,-2.2195415,52.1324593,-2.3275845,0.1344929,0.0689786,-2.2516541
-1615570563,52.1324602,-2.3275766,0.1291762,0.0691891,-2.3085623,52.1324593,-2.3275845,0.1344866,0.0689127,-2.2508256
-1615570564,52.1324602,-2.3275766,0.1326146,0.0684571,-1.8363402,52.1324593,-2.3275845,0.1343397,0.0689176,-2.2518649
-1615570564,52.1324601,-2.3275766,0.1320878,0.0645536,-2.1674478,52.1324593,-2.3275845,0.1343410,0.0689627,-2.2524529
-1615570564,52.1324601,-2.3275766,0.1311079,0.0650414,-2.8103924,52.1324593,-2.3275845,0.1342296,0.0689090,-2.2524824
-1615570565,52.1324600,-2.3275766,0.1323466,0.0660173,-2.2870951,52.1324593,-2.3275845,0.1343055,0.0689109,-2.2520030
-1615570565,52.1324601,-2.3275765,0.1303415,0.0616266,-2.0176902,52.1324593,-2.3275845,0.1342971,0.0689786,-2.2529542
-1615570565,52.1324600,-2.3275765,0.1304131,0.0699211,-2.4871831,52.1324593,-2.3275845,0.1344374,0.0689959,-2.2522521
-1615570566,52.1324600,-2.3275764,0.1343309,0.0677251,-2.3514688,52.1324593,-2.3275845,0.1343625,0.0690369,-2.2532899
-1615570566,52.1324599,-2.3275763,0.1336243,0.0711413,-2.3556807,52.1324593,-2.3275845,0.1343895,0.0690460,-2.2532308
-1615570567,52.1324598,-2.3275763,0.1318763,0.0684571,-1.9873306,52.1324593,-2.3275845,0.1342599,0.0689026,-2.2521956
-1615570567,52.1324598,-2.3275762,0.1330957,0.0672371,-2.3711271,52.1324593,-2.3275845,0.1341938,0.0689607,-2.2534046
-1615570567,52.1324598,-2.3275761,0.1311314,0.0677251,-2.0171347,52.1324593,-2.3275845,0.1341662,0.0690192,-2.2543621
-1615570568,52.1324598,-2.3275759,0.1346332,0.0735820,-2.2963178,52.1324593,-2.3275844,0.1341216,0.0690765,-2.2554166
-1615570568,52.1324598,-2.3275758,0.1335770,0.0660173,-2.4525948,52.1324593,-2.3275844,0.1340236,0.0690702,-2.2559860
-1615570568,52.1324598,-2.3275757,0.1330699,0.0643096,-2.6847277,52.1324593,-2.3275844,0.1339802,0.0690874,-2.2565031
-1615570569,52.1324598,-2.3275756,0.1325991,0.0667492,-2.1387668,52.1324593,-2.3275844,0.1339765,0.0691713,-2.2576406
-1615570569,52.1324597,-2.3275755,0.1360939,0.0718735,-2.4216661,52.1324593,-2.3275844,0.1339603,0.0692003,-2.2581317
-1615570570,52.1324598,-2.3275754,0.1303494,0.0626022,-1.8463112,52.1324593,-2.3275844,0.1340388,0.0693198,-2.2591934
-1615570570,52.1324598,-2.3275753,0.1347883,0.0638218,-1.8021291,52.1324593,-2.3275844,0.1341159,0.0693911,-2.2596250
-1615570570,52.1324598,-2.3275752,0.1340500,0.0638218,-2.2013113,52.1324593,-2.3275844,0.1340829,0.0692940,-2.2585602
-1615570571,52.1324597,-2.3275751,0.1313998,0.0701652,-2.3660445,52.1324593,-2.3275844,0.1341015,0.0693040,-2.2585690
-1615570571,52.1324598,-2.3275750,0.1298697,0.0640657,-1.8730360,52.1324593,-2.3275844,0.1340489,0.0693737,-2.2598400
-1615570571,52.1324597,-2.3275749,0.1279207,0.0662612,-2.5562739,52.1324593,-2.3275844,0.1341024,0.0692948,-2.2584414
-1615570572,52.1324598,-2.3275747,0.1293737,0.0635778,-2.0080740,52.1324593,-2.3275844,0.1340379,0.0693244,-2.2592607
-1615570572,52.1324598,-2.3275746,0.1358058,0.0674811,-2.3261333,52.1324593,-2.3275844,0.1339656,0.0693330,-2.2598567
-1615570573,52.1324597,-2.3275745,0.1372900,0.0682131,-2.2502375,52.1324593,-2.3275844,0.1340116,0.0693918,-2.2603278
-1615570573,52.1324597,-2.3275745,0.1291359,0.0645536,-2.4625628,52.1324593,-2.3275843,0.1339118,0.0694402,-2.2616334
-1615570573,52.1324597,-2.3275745,0.1338521,0.0691891,-2.5505276,52.1324593,-2.3275843,0.1338326,0.0693879,-2.2614663
-1615570574,52.1324597,-2.3275744,0.1350452,0.0650414,-1.7490774,52.1324593,-2.3275843,0.1339442,0.0693589,-2.2603390
-1615570574,52.1324596,-2.3275743,0.1320857,0.0643096,-2.0532362,52.1324593,-2.3275843,0.1339072,0.0694003,-2.2611339
-1615570574,52.1324597,-2.3275743,0.1340715,0.0662612,-1.9018523,52.1324593,-2.3275843,0.1338306,0.0694077,-2.2617416
-1615570575,52.1324597,-2.3275743,0.1311206,0.0665052,-2.3325448,52.1324593,-2.3275843,0.1337871,0.0692623,-2.2601020
-1615570575,52.1324597,-2.3275741,0.1340937,0.0687011,-2.3210087,52.1324593,-2.3275843,0.1337563,0.0692613,-2.2602937
-1615570576,52.1324597,-2.3275740,0.1313731,0.0672371,-2.0668650,52.1324593,-2.3275843,0.1338605,0.0692819,-2.2598722
-1615570576,52.1324597,-2.3275739,0.1316192,0.0672371,-2.5036817,52.1324593,-2.3275843,0.1338287,0.0692842,-2.2601161
-1615570576,52.1324597,-2.3275738,0.1340479,0.0635778,-2.1186614,52.1324593,-2.3275843,0.1338039,0.0693294,-2.2608805
-1615570577,52.1324598,-2.3275737,0.1350430,0.0647975,-1.8386446,52.1324593,-2.3275843,0.1337710,0.0693537,-2.2614226
-1615570577,52.1324598,-2.3275737,0.1303494,0.0626022,-1.7097831,52.1324593,-2.3275843,0.1337313,0.0694055,-2.2623761
-1615570577,52.1324598,-2.3275735,0.1350649,0.0672371,-1.7393059,52.1324593,-2.3275842,0.1337055,0.0693837,-2.2622576
-1615570578,52.1324598,-2.3275735,0.1306200,0.0655293,-2.2877839,52.1324593,-2.3275842,0.1337889,0.0695615,-2.2640624
-1615570578,52.1324598,-2.3275734,0.1316504,0.0706532,-2.1035528,52.1324593,-2.3275842,0.1338833,0.0695342,-2.2630725
-1615570579,52.1324599,-2.3275733,0.1328474,0.0669931,-1.8384191,52.1324593,-2.3275842,0.1337978,0.0695728,-2.2641528
-1615570579,52.1324599,-2.3275732,0.1347905,0.0640657,-2.7515657,52.1324593,-2.3275842,0.1338004,0.0695777,-2.2642014
-1615570579,52.1324599,-2.3275730,0.1326236,0.0694331,-2.2250819,52.1324593,-2.3275842,0.1337818,0.0695615,-2.2641103
-1615570580,52.1324600,-2.3275730,0.1306328,0.0669931,-2.1554985,52.1324593,-2.3275842,0.1338217,0.0695589,-2.2638097
-1615570580,52.1324600,-2.3275729,0.1313797,0.0679691,-2.3388119,52.1324593,-2.3275842,0.1338473,0.0695072,-2.2629545
-1615570580,52.1324600,-2.3275729,0.1308897,0.0682131,-2.4785066,52.1324593,-2.3275842,0.1337595,0.0695376,-2.2639427
-1615570581,52.1324600,-2.3275727,0.1338039,0.0638218,-2.9401042,52.1324593,-2.3275842,0.1337849,0.0695045,-2.2633338
-1615570581,52.1324600,-2.3275726,0.1331091,0.0687011,-2.6719728,52.1324593,-2.3275842,0.1338088,0.0695308,-2.2635238
-1615570582,52.1324601,-2.3275725,0.1348323,0.0687011,-2.2035470,52.1324593,-2.3275841,0.1337459,0.0695127,-2.2637019
-1615570582,52.1324601,-2.3275725,0.1350583,0.0665052,-2.5195720,52.1324593,-2.3275841,0.1338235,0.0695025,-2.2630498
-1615570582,52.1324602,-2.3275724,0.1279104,0.0650414,-2.5454307,52.1324593,-2.3275841,0.1339115,0.0694316,-2.2615252
-1615570583,52.1324602,-2.3275723,0.1320878,0.0645536,-2.2358806,52.1324593,-2.3275841,0.1338033,0.0694340,-2.2622771
-1615570583,52.1324602,-2.3275721,0.1315999,0.0650414,-2.3755360,52.1324593,-2.3275841,0.1338143,0.0695129,-2.2632513
-1615570583,52.1324602,-2.3275719,0.1355732,0.0689451,-2.5460048,52.1324593,-2.3275841,0.1339280,0.0694645,-2.2618532
-1615570584,52.1324602,-2.3275717,0.1335946,0.0679691,-2.2892487,52.1324593,-2.3275841,0.1340473,0.0695571,-2.2622848
-1615570584,52.1324602,-2.3275716,0.1355484,0.0662612,-2.5558357,52.1324593,-2.3275841,0.1340156,0.0694652,-2.2612805
-1615570585,52.1324603,-2.3275715,0.1340803,0.0672371,-2.5936875,52.1324593,-2.3275841,0.1340815,0.0694853,-2.2611091
-1615570585,52.1324603,-2.3275714,0.1330616,0.0633339,-1.8565360,52.1324593,-2.3275841,0.1340698,0.0695468,-2.2619994
-1615570585,52.1324604,-2.3275713,0.1306592,0.0699211,-2.2130003,52.1324593,-2.3275840,0.1340845,0.0695744,-2.2622669
-1615570586,52.1324605,-2.3275711,0.1345815,0.0682131,-2.1936576,52.1324593,-2.3275840,0.1340571,0.0696087,-2.2629004
-1615570586,52.1324605,-2.3275710,0.1306222,0.0657733,-2.3903980,52.1324593,-2.3275840,0.1340203,0.0695907,-2.2629070
-1615570586,52.1324606,-2.3275708,0.1333620,0.0694331,-2.4501903,52.1324593,-2.3275840,0.1339085,0.0695506,-2.2631187
-1615570587,52.1324607,-2.3275708,0.1368068,0.0691891,-2.1241794,52.1324593,-2.3275840,0.1339209,0.0696421,-2.2642474
-1615570587,52.1324608,-2.3275708,0.1335727,0.0655293,-2.0663180,52.1324593,-2.3275840,0.1339066,0.0697142,-2.2652962
-1615570588,52.1324609,-2.3275706,0.1325905,0.0657733,-1.9953833,52.1324593,-2.3275840,0.1337333,0.0696824,-2.2660263
-1615570588,52.1324610,-2.3275705,0.1331002,0.0677251,-2.0763330,52.1324593,-2.3275840,0.1337407,0.0697039,-2.2662621
-1615570588,52.1324610,-2.3275704,0.1315978,0.0647975,-1.7527286,52.1324593,-2.3275840,0.1338265,0.0697183,-2.2658818
-1615570589,52.1324611,-2.3275705,0.1286221,0.0618705,-2.6437974,52.1324593,-2.3275840,0.1338394,0.0696272,-2.2645898
-1615570589,52.1324612,-2.3275705,0.1279228,0.0665052,-2.0824223,52.1324593,-2.3275839,0.1337873,0.0696160,-2.2647886
-1615570589,52.1324612,-2.3275705,0.1333309,0.0660173,-2.2016358,52.1324593,-2.3275839,0.1339495,0.0696682,-2.2644014
-1615570590,52.1324613,-2.3275705,0.1301323,0.0660173,-2.6047103,52.1324593,-2.3275839,0.1338949,0.0696296,-2.2642531
-1615570590,52.1324614,-2.3275705,0.1316148,0.0667492,-2.6133413,52.1324593,-2.3275839,0.1338561,0.0696186,-2.2643650
-1615570591,52.1324614,-2.3275704,0.1315773,0.0623583,-1.7503821,52.1324593,-2.3275839,0.1338337,0.0697233,-2.2659011
-1615570591,52.1324615,-2.3275703,0.1333331,0.0662612,-2.2116182,52.1324593,-2.3275839,0.1337555,0.0696700,-2.2657144
-1615570591,52.1324616,-2.3275704,0.1298596,0.0628461,-2.6153913,52.1324593,-2.3275839,0.1337920,0.0696659,-2.2654169
-1615570592,52.1324617,-2.3275704,0.1328453,0.0667492,-2.1271675,52.1324593,-2.3275839,0.1337424,0.0696975,-2.2661667
-1615570592,52.1324618,-2.3275704,0.1293964,0.0662612,-1.6812534,52.1324593,-2.3275839,0.1337926,0.0697663,-2.2667437
-1615570592,52.1324618,-2.3275704,0.1331002,0.0677251,-2.0576217,52.1324593,-2.3275838,0.1338074,0.0697404,-2.2663021
-1615570593,52.1324619,-2.3275703,0.1318397,0.0643096,-1.6137547,52.1324593,-2.3275838,0.1338679,0.0697317,-2.2657850
-1615570593,52.1324619,-2.3275704,0.1331002,0.0677251,-2.2839975,52.1324593,-2.3275838,0.1340911,0.0697095,-2.2640114
-1615570594,52.1324620,-2.3275704,0.1355506,0.0665052,-2.7904947,52.1324593,-2.3275838,0.1341068,0.0696604,-2.2632608
-1615570594,52.1324620,-2.3275705,0.1330979,0.0674811,-1.9824632,52.1324593,-2.3275838,0.1340656,0.0696565,-2.2634811
-1615570594,52.1324621,-2.3275704,0.1298926,0.0667492,-2.1777709,52.1324593,-2.3275838,0.1341368,0.0696779,-2.2632923
-1615570595,52.1324622,-2.3275704,0.1294311,0.0701652,-2.0837102,52.1324593,-2.3275838,0.1341468,0.0697432,-2.2640872
-1615570595,52.1324622,-2.3275704,0.1328260,0.0645536,-2.3189130,52.1324593,-2.3275838,0.1340856,0.0697643,-2.2647700
-1615570595,52.1324623,-2.3275703,0.1323402,0.0652854,-2.3304901,52.1324593,-2.3275838,0.1341990,0.0697632,-2.2640061
-1615570596,52.1324624,-2.3275702,0.1335770,0.0660173,-2.4189343,52.1324593,-2.3275838,0.1342633,0.0698680,-2.2649596
-1615570596,52.1324625,-2.3275702,0.1318418,0.0645536,-1.9454368,52.1324593,-2.3275837,0.1342017,0.0699628,-2.2666132
-1615570597,52.1324626,-2.3275701,0.1343376,0.0684571,-2.0589147,52.1324593,-2.3275837,0.1341112,0.0700064,-2.2677858
-1615570597,52.1324627,-2.3275700,0.1333202,0.0647975,3.1282485,52.1324593,-2.3275837,0.1342039,0.0701078,-2.2685065
-1615570597,52.1324628,-2.3275700,0.1318740,0.0682131,-2.2566855,52.1324593,-2.3275837,0.1342051,0.0701705,-2.2693229
-1615570598,52.1324628,-2.3275699,0.1306393,0.0677251,-2.4088340,52.1324593,-2.3275837,0.1342336,0.0700892,-2.2680659
-1615570598,52.1324629,-2.3275698,0.1321427,0.0706532,-1.9865242,52.1324594,-2.3275837,0.1341417,0.0700467,-2.2681143
-1615570598,52.1324630,-2.3275699,0.1311121,0.0655293,-2.6798515,52.1324594,-2.3275837,0.1341326,0.0700052,-2.2676291
-1615570599,52.1324631,-2.3275697,0.1288879,0.0643096,-1.8271896,52.1324594,-2.3275837,0.1341574,0.0699932,-2.2673066
-1615570599,52.1324631,-2.3275698,0.1323729,0.0689451,-2.4629917,52.1324594,-2.3275837,0.1341897,0.0700068,-2.2672722
-1615570600,52.1324631,-2.3275697,0.1347990,0.0650414,-1.9820452,52.1324594,-2.3275836,0.1342079,0.0700397,-2.2675855
-1615570600,52.1324633,-2.3275697,0.1316148,0.0667492,-1.9751660,52.1324594,-2.3275836,0.1341189,0.0699473,-2.2669568
-1615570600,52.1324633,-2.3275696,0.1331296,0.0708973,-2.5961866,52.1324594,-2.3275836,0.1341595,0.0700376,-2.2678764
-1615570601,52.1324634,-2.3275697,0.1330784,0.0652854,-2.0727663,52.1324594,-2.3275836,0.1341139,0.0700479,-2.2683132
-1615570601,52.1324636,-2.3275697,0.1360298,0.0650414,-2.5482049,52.1324594,-2.3275836,0.1340637,0.0700215,-2.2682979
-1615570601,52.1324637,-2.3275696,0.1340715,0.0662612,-2.5470729,52.1324594,-2.3275836,0.1339908,0.0700120,-2.2686543
-1615570602,52.1324637,-2.3275697,0.1335836,0.0667492,-1.7910739,52.1324594,-2.3275836,0.1340855,0.0700556,-2.2686028
-1615570602,52.1324638,-2.3275696,0.1347717,0.0618705,-2.0753384,52.1324594,-2.3275836,0.1341790,0.0700479,-2.2678835
-1615570603,52.1324638,-2.3275696,0.1345861,0.0687011,-2.6488955,52.1324594,-2.3275836,0.1340956,0.0698739,-2.2661452
-1615570603,52.1324639,-2.3275697,0.1333507,0.0682131,-2.5598829,52.1324594,-2.3275836,0.1340388,0.0698732,-2.2665117
-1615570603,52.1324640,-2.3275697,0.1318718,0.0679691,-2.8323843,52.1324594,-2.3275835,0.1341397,0.0698364,-2.2653584
-1615570604,52.1324641,-2.3275698,0.1385822,0.0743143,-1.4495599,52.1324594,-2.3275835,0.1340940,0.0699021,-2.2665262
-1615570604,52.1324641,-2.3275698,0.1284231,0.0674811,-2.2610435,52.1324594,-2.3275835,0.1341824,0.0698416,-2.2651455
-1615570604,52.1324641,-2.3275699,0.1380039,0.0655293,-2.6367083,52.1324594,-2.3275835,0.1342833,0.0698045,-2.2639909
-1615570605,52.1324642,-2.3275699,0.1318785,0.0687011,-2.3520255,52.1324594,-2.3275835,0.1343187,0.0697876,-2.2635341
-1615570605,52.1324642,-2.3275699,0.1325948,0.0662612,-2.2762818,52.1324594,-2.3275835,0.1342967,0.0698329,-2.2642753
-1615570606,52.1324643,-2.3275700,0.1343133,0.0657733,-2.6786003,52.1324594,-2.3275835,0.1342724,0.0699809,-2.2663801
-1615570606,52.1324643,-2.3275700,0.1310833,0.0621144,-2.7642074,52.1324594,-2.3275835,0.1343861,0.0698756,-2.2642474
-1615570606,52.1324644,-2.3275701,0.1308598,0.0647975,-2.1288314,52.1324594,-2.3275835,0.1343846,0.0698754,-2.2642558
-1615570607,52.1324644,-2.3275701,0.1340736,0.0665052,-1.3201053,52.1324594,-2.3275835,0.1344418,0.0700160,-2.2657218
-1615570607,52.1324644,-2.3275702,0.1360520,0.0674811,-2.0231819,52.1324594,-2.3275834,0.1345934,0.0700406,-2.2650478
-1615570607,52.1324645,-2.3275702,0.1323317,0.0643096,-2.6655786,52.1324594,-2.3275834,0.1344567,0.0699810,-2.2651656
-1615570608,52.1324646,-2.3275702,0.1264310,0.0645536,-2.7001107,52.1324594,-2.3275834,0.1344345,0.0699508,-2.2649164
-1615570608,52.1324647,-2.3275702,0.1333309,0.0660173,-2.4116313,52.1324594,-2.3275834,0.1345066,0.0699562,-2.2645128
-1615570609,52.1324647,-2.3275703,0.1340564,0.0645536,-2.1301365,52.1324594,-2.3275834,0.1345187,0.0700521,-2.2656891
-1615570609,52.1324648,-2.3275703,0.1281502,0.0643096,2.9635267,52.1324595,-2.3275834,0.1344469,0.0700313,-2.2658892
-1615570609,52.1324648,-2.3275704,0.1330892,0.0665052,-2.3964286,52.1324595,-2.3275834,0.1345259,0.0699907,-2.2648375
-1615570610,52.1324649,-2.3275704,0.1318192,0.0618705,-2.2743518,52.1324595,-2.3275834,0.1344380,0.0699012,-2.2642424
-1615570610,52.1324649,-2.3275703,0.1328540,0.0677251,-1.7819622,52.1324595,-2.3275834,0.1343620,0.0698593,-2.2641935
-1615570610,52.1324650,-2.3275704,0.1365422,0.0672371,-1.9658616,52.1324595,-2.3275834,0.1343525,0.0697770,-2.2631748
-1615570611,52.1324650,-2.3275704,0.1318173,0.0616266,-2.2874830,52.1324595,-2.3275833,0.1344093,0.0697700,-2.2627077
-1615570611,52.1324651,-2.3275705,0.1335663,0.0647975,-3.0377705,52.1324595,-2.3275833,0.1343834,0.0697348,-2.2624164
-1615570612,52.1324652,-2.3275704,0.1328176,0.0635778,-2.7343910,52.1324595,-2.3275833,0.1343748,0.0696284,-2.2610743
-1615570612,52.1324652,-2.3275705,0.1318718,0.0679691,-2.1254652,52.1324595,-2.3275833,0.1343821,0.0694948,-2.2592678
-1615570612,52.1324652,-2.3275706,0.1350539,0.0660173,-1.8970237,52.1324595,-2.3275833,0.1344157,0.0695052,-2.2591832
-1615570613,52.1324652,-2.3275705,0.1353022,0.0662612,-2.0437431,52.1324595,-2.3275833,0.1344472,0.0694467,-2.2582057
-1615570613,52.1324652,-2.3275706,0.1301239,0.0650414,-2.2951853,52.1324595,-2.3275833,0.1345093,0.0694373,-2.2576733
-1615570613,52.1324653,-2.3275707,0.1330957,0.0672371,-1.9734851,52.1324595,-2.3275833,0.1345274,0.0693550,-2.2564707
-1615570614,52.1324653,-2.3275707,0.1320857,0.0643096,-2.5195475,52.1324595,-2.3275833,0.1344390,0.0693219,-2.2566185
-1615570614,52.1324653,-2.3275707,0.1313863,0.0687011,-2.3779752,52.1324595,-2.3275833,0.1343951,0.0692616,-2.2561145
-1615570615,52.1324654,-2.3275708,0.1331002,0.0677251,-2.0746722,52.1324595,-2.3275832,0.1343625,0.0692529,-2.2562151
-1615570615,52.1324655,-2.3275709,0.1348121,0.0665052,-2.7282436,52.1324595,-2.3275832,0.1342898,0.0692928,-2.2572222
-1615570615,52.1324656,-2.3275709,0.1310734,0.0608949,-1.4097311,52.1324595,-2.3275832,0.1342473,0.0693454,-2.2581975
-1615570616,52.1324656,-2.3275709,0.1347676,0.0613827,-2.0601583,52.1324595,-2.3275832,0.1341721,0.0693160,-2.2583082
-1615570616,52.1324657,-2.3275709,0.1326168,0.0687011,-2.6406331,52.1324595,-2.3275832,0.1341717,0.0692723,-2.2577338
-1615570616,52.1324657,-2.3275710,0.1301365,0.0665052,-2.5374360,52.1324595,-2.3275832,0.1340850,0.0692517,-2.2580357
-1615570617,52.1324658,-2.3275712,0.1340915,0.0684571,-2.2118821,52.1324595,-2.3275832,0.1340515,0.0692668,-2.2584577
-1615570617,52.1324659,-2.3275712,0.1367884,0.0672371,-2.3172624,52.1324595,-2.3275832,0.1339949,0.0692992,-2.2592626
-1615570618,52.1324659,-2.3275713,0.1350830,0.0691891,-2.3717825,52.1324596,-2.3275832,0.1339019,0.0694217,-2.2615042
-1615570618,52.1324659,-2.3275714,0.1308598,0.0647975,-2.2787364,52.1324596,-2.3275832,0.1338586,0.0694378,-2.2620046
-1615570618,52.1324660,-2.3275714,0.1323444,0.0657733,-1.7622247,52.1324596,-2.3275832,0.1339022,0.0695476,-2.2631702
-1615570619,52.1324660,-2.3275715,0.1380129,0.0665052,-2.2059512,52.1324596,-2.3275831,0.1338067,0.0694233,-2.2621567
-1615570619,52.1324660,-2.3275716,0.1326146,0.0684571,-2.5288763,52.1324596,-2.3275831,0.1338840,0.0694545,-2.2620568
-1615570619,52.1324661,-2.3275717,0.1363142,0.0691891,-3.0612185,52.1324596,-2.3275831,0.1338690,0.0693136,-2.2602892
-1615570620,52.1324661,-2.3275718,0.1320857,0.0643096,-2.0917425,52.1324596,-2.3275831,0.1337597,0.0691450,-2.2587774
-1615570620,52.1324662,-2.3275718,0.1330473,0.0616266,-1.7158206,52.1324596,-2.3275831,0.1337942,0.0691760,-2.2589593
-1615570621,52.1324662,-2.3275719,0.1288982,0.0655293,-2.3673155,52.1324596,-2.3275831,0.1338441,0.0691630,-2.2584546
-1615570621,52.1324662,-2.3275721,0.1345838,0.0684571,-2.0572321,52.1324596,-2.3275831,0.1338652,0.0691699,-2.2584057
-1615570621,52.1324663,-2.3275722,0.1323552,0.0669931,-2.3407595,52.1324596,-2.3275831,0.1338371,0.0691018,-2.2576883
-1615570622,52.1324663,-2.3275723,0.1330892,0.0665052,-2.1201034,52.1324596,-2.3275831,0.1337109,0.0689806,-2.2569172
-1615570622,52.1324663,-2.3275724,0.1313863,0.0687011,-2.4791651,52.1324596,-2.3275831,0.1335160,0.0689685,-2.2580600
-1615570622,52.1324664,-2.3275726,0.1340915,0.0684571,-2.2928784,52.1324596,-2.3275831,0.1334934,0.0689587,-2.2580795
-1615570623,52.1324664,-2.3275728,0.1328474,0.0669931,-1.9662967,52.1324596,-2.3275831,0.1335229,0.0689924,-2.2583318
-1615570623,52.1324664,-2.3275728,0.1301386,0.0667492,-1.8595753,52.1324596,-2.3275831,0.1336126,0.0689751,-2.2575011
-1615570624,52.1324664,-2.3275730,0.1271850,0.0665052,-2.6870742,52.1324596,-2.3275830,0.1336583,0.0689812,-2.2572773
-1615570624,52.1324665,-2.3275731,0.1330805,0.0655293,-2.2479203,52.1324596,-2.3275830,0.1336722,0.0689173,-2.2563310
-1615570624,52.1324665,-2.3275733,0.1326236,0.0694331,-2.4533653,52.1324596,-2.3275830,0.1335857,0.0689736,-2.2576618
-1615570625,52.1324666,-2.3275733,0.1299300,0.0708973,-2.3175476,52.1324596,-2.3275830,0.1335556,0.0689534,-2.2575932
-1615570625,52.1324666,-2.3275734,0.1303911,0.0674811,-2.6542315,52.1324596,-2.3275830,0.1334768,0.0688946,-2.2573352
-1615570625,52.1324667,-2.3275734,0.1363119,0.0689451,-2.2703190,52.1324597,-2.3275830,0.1334604,0.0688987,-2.2575002
-1615570626,52.1324667,-2.3275735,0.1345659,0.0665052,-2.6839128,52.1324597,-2.3275830,0.1334918,0.0688844,-2.2570987
-1615570626,52.1324668,-2.3275736,0.1313688,0.0667492,-2.0195193,52.1324597,-2.3275830,0.1334562,0.0688261,-2.2565579
-1615570627,52.1324668,-2.3275738,0.1318920,0.0701652,-2.7671757,52.1324597,-2.3275830,0.1333967,0.0687039,-2.2553205
-1615570627,52.1324669,-2.3275739,0.1335880,0.0672371,-2.6901762,52.1324597,-2.3275830,0.1334753,0.0687361,-2.2552242
-1615570627,52.1324669,-2.3275741,0.1325862,0.0652854,-2.2607639,52.1324597,-2.3275830,0.1336072,0.0686217,-2.2528076
-1615570628,52.1324669,-2.3275743,0.1303720,0.0652854,-2.6819420,52.1324597,-2.3275830,0.1335531,0.0685783,-2.2525899
-1615570628,52.1324670,-2.3275745,0.1330892,0.0665052,-1.9637125,52.1324597,-2.3275830,0.1334887,0.0685807,-2.2530556
-1615570628,52.1324670,-2.3275747,0.1299056,0.0682131,-2.1357732,52.1324597,-2.3275830,0.1334089,0.0685867,-2.2536716
-1615570629,52.1324671,-2.3275749,0.1327973,0.0611388,-2.2517796,52.1324597,-2.3275829,0.1334420,0.0686707,-2.2545767
-1615570629,52.1324671,-2.3275750,0.1316041,0.0655293,-2.6737821,52.1324597,-2.3275829,0.1334737,0.0686974,-2.2547202
-1615570630,52.1324671,-2.3275752,0.1338498,0.0689451,-2.9090455,52.1324597,-2.3275829,0.1335394,0.0686401,-2.2535117
-1615570630,52.1324671,-2.3275754,0.1333224,0.0650414,-1.9458743,52.1324597,-2.3275829,0.1335503,0.0685463,-2.2521832
-1615570630,52.1324671,-2.3275756,0.1298821,0.0655293,-2.4661312,52.1324597,-2.3275829,0.1334108,0.0684941,-2.2524211
-1615570631,52.1324671,-2.3275757,0.1318830,0.0691891,-2.0277305,52.1324597,-2.3275829,0.1334514,0.0684827,-2.2519946
-1615570631,52.1324672,-2.3275759,0.1345444,0.0640657,-1.9678926,52.1324597,-2.3275829,0.1334124,0.0684152,-2.2513509
-1615570631,52.1324672,-2.3275761,0.1377734,0.0672371,-1.8580317,52.1324597,-2.3275829,0.1333607,0.0684459,-2.2521122
-1615570632,52.1324672,-2.3275764,0.1311228,0.0667492,-2.2317073,52.1324597,-2.3275829,0.1333119,0.0685061,-2.2532513
-1615570632,52.1324672,-2.3275765,0.1296530,0.0674811,-2.7891517,52.1324598,-2.3275829,0.1333257,0.0685481,-2.2537212
-1615570633,52.1324672,-2.3275766,0.1308640,0.0652854,-2.2938862,52.1324598,-2.3275829,0.1332711,0.0684839,-2.2532265
-1615570633,52.1324671,-2.3275768,0.1296136,0.0628461,-2.0767961,52.1324598,-2.3275829,0.1332555,0.0684844,-2.2533395
-1615570633,52.1324672,-2.3275769,0.1296403,0.0660173,-2.0126896,52.1324598,-2.3275829,0.1333028,0.0684873,-2.2530580
-1615570634,52.1324671,-2.3275771,0.1288982,0.0655293,-1.8037853,52.1324598,-2.3275829,0.1333352,0.0684487,-2.2523217
-1615570634,52.1324671,-2.3275772,0.1333160,0.0643096,-2.3063059,52.1324598,-2.3275829,0.1332735,0.0684152,-2.2522876
-1615570634,52.1324671,-2.3275774,0.1330763,0.0650414,-2.2572868,52.1324598,-2.3275829,0.1333710,0.0684125,-2.2515922
-1615570635,52.1324670,-2.3275776,0.1316192,0.0672371,-2.3030865,52.1324598,-2.3275829,0.1333888,0.0683942,-2.2512269
-1615570635,52.1324671,-2.3275777,0.1338385,0.0677251,-1.9793324,52.1324598,-2.3275829,0.1334074,0.0683516,-2.2505295
-1615570636,52.1324670,-2.3275778,0.1343068,0.0650414,-1.8231755,52.1324598,-2.3275829,0.1333494,0.0683646,-2.2510939
-1615570636,52.1324670,-2.3275780,0.1271829,0.0662612,-2.6136196,52.1324598,-2.3275829,0.1334510,0.0682805,-2.2492800
-1615570636,52.1324671,-2.3275781,0.1293985,0.0665052,-2.4955680,52.1324598,-2.3275829,0.1333847,0.0681348,-2.2477670
-1615570637,52.1324671,-2.3275783,0.1350430,0.0647975,-1.9198349,52.1324598,-2.3275829,0.1332024,0.0681111,-2.2486796
-1615570637,52.1324671,-2.3275784,0.1333441,0.0674811,-2.4538808,52.1324598,-2.3275829,0.1331591,0.0681037,-2.2488737
-1615570637,52.1324671,-2.3275786,0.1321335,0.0696771,-2.1327047,52.1324598,-2.3275828,0.1330811,0.0680983,-2.2493300
-1615570638,52.1324670,-2.3275787,0.1294135,0.0682131,-2.3579712,52.1324598,-2.3275828,0.1331072,0.0681321,-2.2496090
-1615570638,52.1324670,-2.3275788,0.1336036,0.0689451,-2.2115293,52.1324598,-2.3275828,0.1330482,0.0679968,-2.2481802
-1615570639,52.1324669,-2.3275790,0.1318460,0.0650414,2.7738366,52.1324598,-2.3275828,0.1329193,0.0679970,-2.2490582
-1615570639,52.1324669,-2.3275791,0.1325820,0.0647975,-1.7520183,52.1324598,-2.3275828,0.1328131,0.0680283,-2.2502065
-1615570639,52.1324669,-2.3275792,0.1306243,0.0660173,-2.1263247,52.1324598,-2.3275828,0.1327304,0.0680214,-2.2506762
-1615570640,52.1324668,-2.3275793,0.1367839,0.0667492,-1.8106701,52.1324599,-2.3275828,0.1327139,0.0680712,-2.2514653
-1615570640,52.1324668,-2.3275794,0.1326057,0.0674811,-2.8107977,52.1324599,-2.3275828,0.1328988,0.0680370,-2.2497425
-1615570640,52.1324668,-2.3275796,0.1286319,0.0630900,-2.1071932,52.1324599,-2.3275828,0.1328910,0.0680689,-2.2502277
-1615570641,52.1324668,-2.3275795,0.1311358,0.0682131,-1.8793947,52.1324599,-2.3275828,0.1329177,0.0681235,-2.2507856
-1615570641,52.1324668,-2.3275795,0.1293985,0.0665052,-2.4525433,52.1324599,-2.3275828,0.1330809,0.0681649,-2.2502384
-1615570642,52.1324668,-2.3275795,0.1321637,0.0728498,-2.2114418,52.1324599,-2.3275828,0.1331138,0.0681469,-2.2497721
-1615570642,52.1324668,-2.3275796,0.1316391,0.0694331,-2.3935974,52.1324599,-2.3275828,0.1331965,0.0681727,-2.2495606
-1615570642,52.1324668,-2.3275797,0.1311249,0.0669931,-2.1449718,52.1324599,-2.3275828,0.1332232,0.0682483,-2.2503984
-1615570643,52.1324668,-2.3275796,0.1328697,0.0694331,2.8834794,52.1324599,-2.3275828,0.1332802,0.0682997,-2.2507055
-1615570643,52.1324668,-2.3275796,0.1306637,0.0704092,-2.5670528,52.1324599,-2.3275828,0.1332223,0.0682879,-2.2509387
-1615570643,52.1324668,-2.3275797,0.1288920,0.0647975,-2.3123095,52.1324599,-2.3275828,0.1332328,0.0682590,-2.2504783
-1615570644,52.1324668,-2.3275798,0.1301582,0.0689451,-2.4573936,52.1324599,-2.3275828,0.1331991,0.0681836,-2.2496898
-1615570644,52.1324668,-2.3275799,0.1338408,0.0679691,-2.2905378,52.1324599,-2.3275828,0.1331930,0.0681623,-2.2494435
-1615570645,52.1324668,-2.3275800,0.1350561,0.0662612,-2.9579754,52.1324599,-2.3275828,0.1330883,0.0682243,-2.2509899
-1615570645,52.1324668,-2.3275801,0.1336014,0.0687011,-2.5758243,52.1324599,-2.3275828,0.1330577,0.0682456,-2.2514851
-1615570645,52.1324668,-2.3275802,0.1335516,0.0630900,-2.4065878,52.1324599,-2.3275828,0.1329074,0.0682895,-2.2530985
-1615570646,52.1324668,-2.3275803,0.1343154,0.0660173,-2.3233752,52.1324599,-2.3275828,0.1328466,0.0682892,-2.2535076
-1615570646,52.1324668,-2.3275805,0.1338232,0.0660173,-2.0352995,52.1324599,-2.3275828,0.1329555,0.0682686,-2.2524889
-1615570646,52.1324668,-2.3275806,0.1358080,0.0677251,-2.5024683,52.1324599,-2.3275828,0.1328607,0.0682208,-2.2524860
-1615570647,52.1324668,-2.3275808,0.1325841,0.0650414,-1.9727017,52.1324599,-2.3275828,0.1328791,0.0682691,-2.2530155
-1615570647,52.1324668,-2.3275808,0.1328562,0.0679691,-2.2366095,52.1324600,-2.3275828,0.1328396,0.0683294,-2.2540994
-1615570648,52.1324668,-2.3275810,0.1340982,0.0691891,-2.2253194,52.1324600,-2.3275828,0.1329630,0.0683797,-2.2539420
-1615570648,52.1324668,-2.3275812,0.1355573,0.0672371,-2.4093719,52.1324600,-2.3275828,0.1328467,0.0683797,-2.2547312
-1615570648,52.1324668,-2.3275813,0.1281401,0.0630900,-2.8726730,52.1324600,-2.3275828,0.1328860,0.0683799,-2.2544670
-1615570649,52.1324668,-2.3275814,0.1296403,0.0660173,-2.6027622,52.1324600,-2.3275828,0.1329012,0.0683980,-2.2546096
-1615570649,52.1324668,-2.3275816,0.1333643,0.0696771,-2.0763683,52.1324600,-2.3275828,0.1329397,0.0684022,-2.2544038
-1615570649,52.1324667,-2.3275815,0.1348461,0.0701652,-1.9237834,52.1324600,-2.3275828,0.1328824,0.0684071,-2.2548599
-1615570650,52.1324666,-2.3275817,0.1348077,0.0660173,-2.6337347,52.1324600,-2.3275828,0.1329592,0.0684646,-2.2551150
-1615570650,52.1324666,-2.3275818,0.1291218,0.0628461,-1.7691268,52.1324600,-2.3275828,0.1329065,0.0683828,-2.2543678
-1615570651,52.1324666,-2.3275819,0.1315834,0.0630900,-2.2323666,52.1324600,-2.3275828,0.1328917,0.0684216,-2.2549918
-1615570651,52.1324665,-2.3275820,0.1306035,0.0635778,-2.6970859,52.1324600,-2.3275828,0.1330707,0.0684967,-2.2547936
-1615570651,52.1324664,-2.3275820,0.1326304,0.0701652,-2.3787694,52.1324600,-2.3275828,0.1330630,0.0685039,-2.2549424
-1615570652,52.1324664,-2.3275822,0.1338566,0.0696771,-1.9717491,52.1324600,-2.3275828,0.1330709,0.0683764,-2.2531691
-1615570652,52.1324663,-2.3275822,0.1369868,0.0618705,-1.7429751,52.1324600,-2.3275828,0.1329656,0.0683462,-2.2534761
-1615570652,52.1324663,-2.3275823,0.1318718,0.0679691,-2.5279684,52.1324600,-2.3275828,0.1329812,0.0684067,-2.2541871
diff --git a/python_utils/test_data/raw_vs_ekf.png b/python_utils/test_data/raw_vs_ekf.png
deleted file mode 100644
index a8c9e680efece852dd913ebe425cc6d0e5d726bb..0000000000000000000000000000000000000000
GIT binary patch
literal 0
KcmV+b0RR6000031

literal 331991
zcmV+a{{R4qP)<h;3K|Lk000e1NJLTq00%t)00VXi1^@s6V=k0f00004b3#c}2nYxW
zd<bNS00009a7bBm000kR000kR0jNKxX#fBKIdnx>bW?9;ba!ELWdLnqbZ~5MbZlv2
zAa-SPb7^mGATlm8E;KA4XmoUNIxjD6VRUe8Z***FVlHoTXD{tUxUB#HAOJ~3K~#90
z?A>>GR8``}@pm%Gq>(~NB7r1?0HJpTq$5S7DImoJVcpdqNYhn7Kn>u6BDP%>7E#ef
zQP2fMP#_dB6j2aRK#&r8Ng$9w0!b!wet!%Z854>q>bT#}^UTA{x#ymH?wz>`^UgWP
zVvI2Y0000000000000l=^?P>!0000000000004doLQeny00000000009*xiw00000
z000000Dwm$^aKC^000000002s(Fi>O00000000000C+S)PXGV_000000000UjnESS
z0000000000fJY<r1ONa400000007|82t5G+0000000000cr-#!000000000000171
z&=UXv000000001hM<etE00000000000N~LGJplj!000000001ZG(t}R0000000000
z03MCd6951J00000004kTBlH9S0000000000;L!*@0RR9100000004M2LQeny00000
z000009*xiw00000000000Dwm$^aKC^000000002s(Fi>O00000000000C+S)PXGV_
z000000000UjnESS0000000000fJY<r1ONa400000007|82t5G+0000000000cr-#!
z000000000000171&=UXv000000001hM<etE00000000000N~LGJplj!000000001Z
zG(t}R000000000003MCd6951J00000004kTBlH9S0000000000;L!*@0RR9100000
z004M2LQeny00000000009*xiw00000000000Dwm$^aKC^000000002s(Fi>O00000
z000000C+S)PXGV_000000000UjnESS0000000000fJY<r1ONa400000007|82t5G+
z0000000000cr-#!000000000000171&=UXv000000001hM<etE00000000000N~LG
zJplj!000000001ZG(t}R000000000003MCd6951J00000004kTBlH9S0000000000
z;L!*@0RR9100000004M2LQeny00000000009*xiw00000000000Dwm$^aKC^00000
z0002s(Fi>O00000000000C+S)PXGV_000000000UjnESS0000000000fJY<r1ONa4
z00000007|82t5G+0000000000cr-#!000000000000171&=UXv000000001hM<etE
z00000000000N~LGJplj!000000001ZG(t}R000000000003MCd6951J00000004kT
zBlH9S0000000000;L!*@0RR9100000004M2LQeny00000000009*xiw0000000000
z0Dwm$^aKC^000000002s(Fi>O00000000000C+S)PXGV_000000000UjnESS00000
z00000fJY<r1ONa400000007|82t5G+0000000000cr-#!000000000000171&=UXv
z000000001hM<etE00000000000N~LGJplj!000000001ZG(t}R000000000003MCd
z6951J00000004kTBlH9S0000000000;L!*@0RR9100000004M2LQeny0000000000
z9*xiw00000000000Dwm$^aKC^002mmzWVAb*=#l)Jb3V?9iwmGzUtk(_f2d6kKm0r
z-jKy&(UBuZTxHFhH&?rM?S98z{XE5;0{{R30Q`{=dIA6d0Qkd7O-<F%p+i-rN)-hJ
z1SlXNK-H^P*N`DY^zFCby44*&e!MIeiy|T-l#`QFq^$}SDyU1BE^cM#&!1OPQj%)c
ztf|1jK$R|CT6OEz)rb)zbnMtMx4LWBu2rW_om8$|Ir;hdDLOh@UAuPGoH=u@c^<7>
zx0c0XaXtL~{Z+emZN2>R%W^mzH*jTcj&bA0sb9Z-iiwF)T3VXCy}gx~n0Uqd=gysz
zzrVkF^yqQj#~3|&wEp|w|7zQ|ZP!)5LWK%$*Y5Ji9e3Q}s#o~_pE`BQZU4iE4=XM%
zPNhnf(l_6HBS{)KaNrf&T)K4W4fp5b#f#T{9gZA1qVeO$7x^4}s;yhMYQTU2s!*YV
z{QUeB6cnU-_3G*I#~;^$0|(sdCMG7zVzH=x{rW}PvD@vkSS)(@;fLMI)6&v3Y}hcx
z$H&Xx-(TV3;cDEtu^xZ?@gn#8#~**JmMvQ<JUm>1fq|-6v7-9)>7(V#m;dVL4FCWD
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%0AZn?#nn3%yvlIh&J
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%0DE~`TrKh4OilQirq9}@@DF0u`%97Pi2?-Dx
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
GLSTZb0NG#w

