diff --git a/CMakeLists.txt b/CMakeLists.txt
index 8eb7e37..ec033d9 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -4,6 +4,12 @@ cmake_minimum_required(VERSION 2.8)
 #set(GCC_COMPILATION_FLAGS "-DLINUX")
 #set(CMAKE_CXX_FLAGS  "${GCC_COMPILATION_FLAGS}")
 
+set(CMAKE_SKIP_BUILD_RPATH TRUE)
+set(CMAKE_BUILD_WITH_INSTALL_RPATH FALSE)
+set(CMAKE_INSTALL_RPATH_USE_LINK_PATH FALSE)
+
+set(CMAKE_CXX_STANDARD 17)
+
 set(
     CMAKE_RUNTIME_OUTPUT_DIRECTORY
     ${CMAKE_HOME_DIRECTORY}/bin
@@ -14,7 +20,8 @@ set(
     ${CMAKE_HOME_DIRECTORY}/lib
     )
 
-set(CMAKE_MODULE_PATH "${CMAKE_HOME_DIRECTORY}/modules")
+#set(CMAKE_MODULE_PATH "${CMAKE_HOME_DIRECTORY}/modules")
+set(CMAKE_MODULE_PATH "${WORKDIR}/recipe-sysroot/usr/share/eigen3/cmake/")
 
 list(APPEND CMAKE_MODULE_PATH "${CMAKE_CURRENT_LIST_DIR}/cmake")
 find_package(Eigen3 REQUIRED)
@@ -22,7 +29,7 @@ include_directories(${EIGEN3_INCLUDE_DIR})
 message("${CMAKE_MODULE_PATH}")
 message("${EIGEN3_INCLUDE_DIR}")
 
-find_package(Boost 1.40 COMPONENTS system REQUIRED)
+#find_package(Boost 1.40 COMPONENTS system REQUIRED)
 
 link_directories(
     /usr/local/lib
@@ -34,10 +41,9 @@ link_directories(
 include_directories(
     /usr/include/
     ${CMAKE_HOME_DIRECTORY}/ekf_nav_ins/inc
-    ${CMAKE_HOME_DIRECTORY}/Ublox_Linux_Library/inc
-    ${CMAKE_HOME_DIRECTORY}/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/src
+    ${CMAKE_HOME_DIRECTORY}/EKF_Linux_Library/inc
+    ${CMAKE_HOME_DIRECTORY}/EKF_Linux_Library/EKF_GNSS_Library/src
     )
 
-add_subdirectory(Ublox_Linux_Library/linux_build)
+add_subdirectory(EKF_Linux_Library/linux_build)
 add_subdirectory(ekf_nav_ins)
-add_subdirectory(ekf_test)
diff --git a/EKF_Linux_Library/EKF_GNSS_Library/.gitattributes b/EKF_Linux_Library/EKF_GNSS_Library/.gitattributes
new file mode 100644
index 0000000..dfe0770
--- /dev/null
+++ b/EKF_Linux_Library/EKF_GNSS_Library/.gitattributes
@@ -0,0 +1,2 @@
+# Auto detect text files and perform LF normalization
+* text=auto
diff --git a/EKF_Linux_Library/EKF_GNSS_Library/.gitignore b/EKF_Linux_Library/EKF_GNSS_Library/.gitignore
new file mode 100644
index 0000000..58b4bef
--- /dev/null
+++ b/EKF_Linux_Library/EKF_GNSS_Library/.gitignore
@@ -0,0 +1,58 @@
+# Visual Studio Code files
+.vscode
+
+# Windows image file caches
+Thumbs.db
+ehthumbs.db
+
+# Folder config file
+Desktop.ini
+
+# Recycle Bin used on file shares
+$RECYCLE.BIN/
+
+# Windows Installer files
+*.cab
+*.msi
+*.msm
+*.msp
+
+# Windows shortcuts
+*.lnk
+
+# =========================
+# Operating System Files
+# =========================
+
+# OSX
+# =========================
+
+.DS_Store
+.AppleDouble
+.LSOverride
+
+# Thumbnails
+._*
+
+# Files that might appear in the root of a volume
+.DocumentRevisions-V100
+.fseventsd
+.Spotlight-V100
+.TemporaryItems
+.Trashes
+.VolumeIcon.icns
+
+# Directories potentially created on remote AFP share
+.AppleDB
+.AppleDesktop
+Network Trash Folder
+Temporary Items
+.apdisk
+
+# VIM backup files
+*~
+[._]*.un~
+*.swp
+
+# Zephyr build files
+examples/Zephyr/*/build/*
\ No newline at end of file
diff --git a/EKF_Linux_Library/EKF_GNSS_Library/src/EKF_GNSS_MPU157F_dk2_Library.cpp b/EKF_Linux_Library/EKF_GNSS_Library/src/EKF_GNSS_MPU157F_dk2_Library.cpp
new file mode 100644
index 0000000..079a3e0
--- /dev/null
+++ b/EKF_Linux_Library/EKF_GNSS_Library/src/EKF_GNSS_MPU157F_dk2_Library.cpp
@@ -0,0 +1,991 @@
+/*
+*) Refactor the code to remove reduentent part. 
+*) Compiled for Linux with C++14 standard
+Copyright (c) 2021 Balamurugan Kandan.
+MIT License; See LICENSE.md for complete details
+Author: 2021 Balamurugan Kandan
+*/
+
+/*
+Updated to be a class, use Eigen, and compile as an Arduino library.
+Added methods to get gyro and accel bias. Added initialization to
+estimated angles rather than assuming IMU is level.
+
+Copyright (c) 2016 - 2019 Regents of the University of Minnesota and Bolder Flight Systems Inc.
+MIT License; See LICENSE.md for complete details
+Author: Brian Taylor
+*/
+
+/*
+Addapted from earlier version
+Copyright 2011 Regents of the University of Minnesota. All rights reserved.
+Original Author: Adhika Lie
+*/
+
+#include "EKF_GNSS_MPU157F_dk2_Library.h"
+#include "EKF_GNSS_msg.h"
+#include <stdio.h>
+#include <string.h>
+#include <termios.h>
+#include <unistd.h>
+
+static GPRMC_msg_t GPRMC_msg;
+
+volatile int last_msg_index;
+volatile int fields_left;
+int valid_token=0;
+
+
+GPRMC_msg_t GPRMC_msg_g;
+GPGGA_msg_t GPGGA_msg_g;
+GPVTG_msg_t GPVTG_msg_g;
+GNGSA_msg_t GNGSA_msg_g;
+GPGLL_msg_t GPGLL_msg_g;
+PSTMCPU_msg_t PSTMCPU_msg_g;
+PSTMPV_msg_t PSTMPV_msg_g;
+
+
+
+fdlist_imus g_imufds;
+
+volatile ST_IMU_SensorData_t g_imudata;
+
+void clearerr_all(){
+//printf("E:%s\n",__func__);
+#if 0
+   rewind(g_imufds.gyro_x_fd);
+   rewind(g_imufds.gyro_y_fd);
+   rewind(g_imufds.gyro_z_fd);
+
+   rewind(g_imufds.gyro_xscale_fd);
+   rewind(g_imufds.gyro_yscale_fd);
+   rewind(g_imufds.gyro_zscale_fd);
+
+    /*sysfs FILE fd for accelerometer*/
+    rewind(g_imufds.accel_x_fd);
+    rewind(g_imufds.accel_y_fd);
+    rewind(g_imufds.accel_z_fd);
+
+    rewind(g_imufds.accel_xscale_fd);
+    rewind(g_imufds.accel_yscale_fd);
+    rewind(g_imufds.accel_zscale_fd);
+
+    /*sysfs FILE fd for magnetometer*/
+    rewind(g_imufds.magn_x_fd);
+    rewind(g_imufds.magn_y_fd);
+    rewind(g_imufds.magn_z_fd);
+
+    rewind(g_imufds.magn_xscale_fd);
+    rewind(g_imufds.magn_yscale_fd);
+    rewind(g_imufds.magn_zscale_fd);
+
+
+    /*SYSFS FILE FD for gyro*/
+   clearerr(g_imufds.gyro_x_fd);
+   clearerr(g_imufds.gyro_y_fd);
+   clearerr(g_imufds.gyro_z_fd);
+
+   clearerr(g_imufds.gyro_xscale_fd);
+   clearerr(g_imufds.gyro_yscale_fd);
+   clearerr(g_imufds.gyro_zscale_fd);
+
+    /*sysfs FILE fd for accelerometer*/
+    clearerr(g_imufds.accel_x_fd);
+    clearerr(g_imufds.accel_y_fd);
+    clearerr(g_imufds.accel_z_fd);
+
+    clearerr(g_imufds.accel_xscale_fd);
+    clearerr(g_imufds.accel_yscale_fd);
+    clearerr(g_imufds.accel_zscale_fd);
+
+    /*sysfs FILE fd for magnetometer*/
+    clearerr(g_imufds.magn_x_fd);
+    clearerr(g_imufds.magn_y_fd);
+    clearerr(g_imufds.magn_z_fd);
+
+    clearerr(g_imufds.magn_xscale_fd);
+    clearerr(g_imufds.magn_yscale_fd);
+    clearerr(g_imufds.magn_zscale_fd);
+#endif
+   fclose(g_imufds.gyro_x_fd);
+   fclose(g_imufds.gyro_y_fd);
+   fclose(g_imufds.gyro_z_fd);
+
+   fclose(g_imufds.gyro_xscale_fd);
+   fclose(g_imufds.gyro_yscale_fd);
+   fclose(g_imufds.gyro_zscale_fd);
+
+    /*sysfs FILE fd for accelerometer*/
+    fclose(g_imufds.accel_x_fd);
+    fclose(g_imufds.accel_y_fd);
+    fclose(g_imufds.accel_z_fd);
+
+    fclose(g_imufds.accel_xscale_fd);
+    fclose(g_imufds.accel_yscale_fd);
+    fclose(g_imufds.accel_zscale_fd);
+
+    /*sysfs FILE fd for magnetometer*/
+    fclose(g_imufds.magn_x_fd);
+    fclose(g_imufds.magn_y_fd);
+    fclose(g_imufds.magn_z_fd);
+
+    fclose(g_imufds.magn_xscale_fd);
+    fclose(g_imufds.magn_yscale_fd);
+    fclose(g_imufds.magn_zscale_fd);
+
+
+    initGyro(g_imufds.gyro_path);
+    initMagn(g_imufds.magn_path);
+    initAccel(g_imufds.accel_path);
+//    printf("X:%s\n",__func__);
+    return;
+}
+
+#pragma GCC push_options
+#pragma GCC optimize ("O0")
+void print_fd(){
+	printf("g_imufds.gyro_x_fd:0x%x,y:0x%x,z:0x%x\n",
+			g_imufds.gyro_x_fd,
+			g_imufds.gyro_y_fd,
+			g_imufds.gyro_z_fd);
+
+	printf("g_imufds.accel_x_fd:0x%x,y:0x%x,z:0x%x\n",
+			g_imufds.accel_x_fd,
+			g_imufds.accel_y_fd,
+			g_imufds.accel_z_fd);
+
+
+	printf("g_imufds.magn_x_fd:0x%x,y:0x%x,z:0x%x\n",
+			g_imufds.magn_x_fd,
+			g_imufds.magn_y_fd,
+			g_imufds.magn_z_fd);
+
+
+}
+
+void getIMUData(){
+
+   volatile  float data=0;
+    volatile float scale_data=0;
+
+    char data_read_accel[25];
+    char data_read_magn[25];
+    char data_read_gyro[25];
+    char data_read[25];
+   
+/*Accel Data*/
+    fgets(data_read_accel, 20, g_imufds.accel_x_fd );
+    data = atof(data_read_accel);
+    debug_imu("accelx:%f, ",data);
+    fgets(data_read_accel, 20, g_imufds.accel_xscale_fd );
+    scale_data = atof(data_read_accel);
+    g_imudata.accel_x_data = data * scale_data * (-1);
+
+    fgets(data_read_accel, 20, g_imufds.accel_y_fd );
+    data = atof(data_read_accel);
+    debug_imu("accely:%f, ",data);
+    fgets(data_read_accel, 20, g_imufds.accel_yscale_fd );
+    scale_data = atof(data_read_accel);
+    debug_imu("accely scale:%f ",scale_data);
+    g_imudata.accel_y_data = data * scale_data * (-1);
+
+    fgets(data_read_accel, 20, g_imufds.accel_z_fd );
+    data = atof(data_read_accel);
+    debug_imu("accelz:%f , ",data);
+    fgets(data_read_accel, 20, g_imufds.accel_zscale_fd );
+    scale_data = atof(data_read_accel);
+    g_imudata.accel_z_data = data * scale_data;
+    debug_imu("accelz scale:%f \n",scale_data);
+
+
+/*Gyro Data*/
+   // printf("gyrox\n");
+    fgets(data_read, 20, g_imufds.gyro_x_fd );
+    data = atof(data_read);
+    fgets(data_read, 20, g_imufds.gyro_xscale_fd );
+    scale_data = atof(data_read);
+    debug_imu("gyrox:%f,",data);
+    debug_imu("gyrox scale:%f\n ",scale_data);
+
+    g_imudata.gyro_x_data = data * scale_data;
+
+    fgets(data_read, 20, g_imufds.gyro_y_fd );
+    data = atof(data_read);
+    fgets(data_read, 20, g_imufds.gyro_yscale_fd );
+    scale_data = atof(data_read);
+    debug_imu("gyroy:%f,",data);
+    debug_imu("gyroy scale:%f\n ",scale_data);
+
+    g_imudata.gyro_y_data = data * scale_data;
+
+    fgets(data_read, 20, g_imufds.gyro_z_fd);
+    data = atof(data_read);
+    fgets(data_read, 20, g_imufds.gyro_zscale_fd);
+    scale_data = atof(data_read);
+    debug_imu("gyroz:%f,",data);
+    debug_imu("gyroz scale:%f\n ",scale_data);
+
+    g_imudata.gyro_z_data = data * scale_data;
+
+    debug_imu("gyroz\n");
+
+#if 1
+/* MAGN Data */
+//    printf("magx\n");
+    fgets(data_read, 20, g_imufds.magn_x_fd);
+    data = atof(data_read);
+    fgets(data_read, 20, g_imufds.magn_xscale_fd);
+    scale_data = atof(data_read);
+    debug_imu("magx:%f,",data);
+    debug_imu("magx scale:%f ",scale_data);
+    g_imudata.magn_x_data = data * scale_data;
+
+    fgets(data_read, 20, g_imufds.magn_y_fd );
+    data = atof(data_read);
+    fgets(data_read, 20, g_imufds.magn_yscale_fd );
+    scale_data = atof(data_read);
+    debug_imu("magy:%f,",data);
+    debug_imu("magy scale:%f ",scale_data);
+    g_imudata.magn_y_data = data * scale_data;
+
+    fgets(data_read, 20, g_imufds.magn_z_fd );
+    data = atof(data_read);
+    fgets(data_read, 20, g_imufds.magn_zscale_fd );
+    scale_data = atof(data_read);
+    debug_imu("magz:%f,",data);
+    debug_imu("magz scale:%f\n ",scale_data);
+
+    g_imudata.magn_z_data = data * scale_data;
+//	printf("magnz\n");
+    clearerr_all();
+
+//    sleep(1);
+
+    //print_fd();
+    debug_imu("X:%s\n",__func__);
+#endif
+
+    return;
+}
+
+#pragma GCC pop_options
+
+
+char *temp_array=NULL;
+void init_st_imulib(){
+
+    temp_array = (char *)malloc(sizeof(char) * 100);
+    return;
+
+}
+void initAccel(char *dev_name){
+
+    snprintf(temp_array,100,"%s%s",dev_name,"in_accel_x_raw");
+    g_imufds.accel_x_fd = fopen(temp_array,"r");
+    if(g_imufds.accel_x_fd == NULL)
+	printf("\nunable to open:%s\n",temp_array);
+   // else{
+//	printf("open:%s succesfull\n",temp_array);
+   // }
+
+    snprintf(temp_array,100,"%s%s",dev_name,"in_accel_y_raw");
+    g_imufds.accel_y_fd = fopen(temp_array,"r");
+    if(g_imufds.accel_y_fd == NULL)
+	printf("\nunable to open:%s\n",temp_array);
+ //   else
+//	printf("open:%s succesfull\n",temp_array);
+
+    snprintf(temp_array,100,"%s%s",dev_name,"in_accel_z_raw");
+    g_imufds.accel_z_fd = fopen(temp_array,"r");
+    if(g_imufds.accel_z_fd == NULL)
+	printf("\nunable to open:%s\n",temp_array);
+    //else
+//	printf("open:%s succesfull\n",temp_array);
+
+
+    snprintf(temp_array,100,"%s%s",dev_name,"in_accel_x_scale");
+    g_imufds.accel_xscale_fd = fopen(temp_array,"r");
+    if(g_imufds.accel_xscale_fd == NULL)
+	printf("\nunable to open:%s\n",temp_array);
+ //   else
+//	printf("open:%s succesfull\n",temp_array);
+
+    snprintf(temp_array,100,"%s%s",dev_name,"in_accel_y_scale");
+    g_imufds.accel_yscale_fd = fopen(temp_array,"r");
+    if(g_imufds.accel_yscale_fd == NULL)
+	printf("\nunable to open:%s\n",temp_array);
+   // else
+//	printf("open:%s succesfull\n",temp_array);
+
+    snprintf(temp_array,100,"%s%s",dev_name,"in_accel_z_scale");
+    g_imufds.accel_zscale_fd = fopen(temp_array,"r");
+    if(g_imufds.accel_zscale_fd == NULL)
+	printf("\nunable to open:%s\n",temp_array);
+  //  else
+//	printf("open:%s succesfull\n",temp_array);
+
+    return;
+}
+
+void initGyro(char *dev_name){
+    //printf("%s: %s\n",__func__,dev_name);
+    snprintf(temp_array,100,"%s%s",dev_name,"in_anglvel_x_raw");
+    g_imufds.gyro_x_fd = fopen(temp_array,"r");
+    if(g_imufds.gyro_x_fd == NULL)
+	printf("\nunable to open:%s\n",temp_array);
+//    else
+//	printf("open:%s succesfull\n",temp_array);
+
+    snprintf(temp_array,100,"%s%s",dev_name,"in_anglvel_y_raw");
+    g_imufds.gyro_y_fd = fopen(temp_array,"r");
+    if(g_imufds.gyro_y_fd == NULL)
+	printf("\nunable to open:%s\n",temp_array);
+  //  else
+//	printf("open:%s succesfull\n",temp_array);
+
+    snprintf(temp_array,100,"%s%s",dev_name,"in_anglvel_z_raw");
+    g_imufds.gyro_z_fd = fopen(temp_array,"r");
+    if(g_imufds.gyro_z_fd == NULL)
+	printf("\nunable to open:%s\n",temp_array);
+  //  else
+//	printf("open:%s succesfull\n",temp_array);
+
+
+    snprintf(temp_array,100,"%s%s",dev_name,"in_anglvel_x_scale");
+    g_imufds.gyro_xscale_fd = fopen(temp_array,"r");
+    if(g_imufds.gyro_xscale_fd == NULL)
+	printf("\nunable to open:%s\n",temp_array);
+  //  else
+//	printf("open:%s succesfull\n",temp_array);
+
+    snprintf(temp_array,100,"%s%s",dev_name,"in_anglvel_y_scale");
+    g_imufds.gyro_yscale_fd = fopen(temp_array,"r");
+    if(g_imufds.gyro_yscale_fd == NULL)
+	printf("\nunable to open:%s\n",temp_array);
+  //  else
+//	printf("open:%s succesfull\n",temp_array);
+
+    snprintf(temp_array,100,"%s%s",dev_name,"in_anglvel_z_scale");
+    g_imufds.gyro_zscale_fd = fopen(temp_array,"r");
+    if(g_imufds.gyro_zscale_fd == NULL)
+	printf("\nunable to open:%s\n",temp_array);
+  //  else
+//	printf("open:%s succesfull\n",temp_array);
+
+
+    return;
+}
+
+void initMagn(char *dev_name){
+
+    snprintf(temp_array,100,"%s%s",dev_name,"in_magn_x_raw");
+    g_imufds.magn_x_fd = fopen(temp_array,"r");
+    if(g_imufds.magn_x_fd == NULL)
+	printf("\nunable to open:%s\n",temp_array);
+  //  else
+//	printf("open:%s succesfull\n",temp_array);
+
+    snprintf(temp_array,100,"%s%s",dev_name,"in_magn_y_raw");
+    g_imufds.magn_y_fd = fopen(temp_array,"r");
+    if(g_imufds.magn_y_fd == NULL)
+	printf("\nunable to open:%s\n",temp_array);
+  //  else
+//	printf("open:%s succesfull\n",temp_array);
+
+    snprintf(temp_array,100,"%s%s",dev_name,"in_magn_z_raw");
+    g_imufds.magn_z_fd = fopen(temp_array,"r");
+    if(g_imufds.gyro_z_fd == NULL)
+	printf("\nunable to open:%s\n",temp_array);
+  //  else
+//	printf("open:%s succesfull\n",temp_array);
+
+
+    snprintf(temp_array,100,"%s%s",dev_name,"in_magn_x_scale");
+    g_imufds.magn_xscale_fd = fopen(temp_array,"r");
+    if(g_imufds.magn_xscale_fd == NULL)
+	printf("\nunable to open:%s\n",temp_array);
+  //  else
+//	printf("open:%s succesfull\n",temp_array);
+
+    snprintf(temp_array,100,"%s%s",dev_name,"in_magn_y_scale");
+    g_imufds.magn_yscale_fd = fopen(temp_array,"r");
+    if(g_imufds.magn_yscale_fd == NULL)
+	printf("\nunable to open:%s\n",temp_array);
+  //  else
+//	printf("open:%s succesfull\n",temp_array);
+
+    snprintf(temp_array,100,"%s%s",dev_name,"in_magn_z_scale");
+    g_imufds.magn_zscale_fd = fopen(temp_array,"r");
+    if(g_imufds.magn_zscale_fd == NULL)
+	printf("\nunable to open:%s\n",temp_array);
+  //  else
+//	printf("open:%s succesfull\n",temp_array);
+
+    return;
+}
+
+imu_s_data getGyroData(){
+
+}
+
+
+void save_gprmc_token_3_1(char *token,int field_num){
+   // printf("%s:token:%s,field_num:%d\n",__func__,token,field_num);
+    GPRMC_msg_t *ptr = &GPRMC_msg_g; 
+    switch(field_num){
+    case 0:
+	ptr->timestamp = atof(token);
+	debug_gps("timestamp:%f\n",ptr->timestamp);
+	break;
+    case 1:
+        //strcpy(&ptr->status, token);
+	ptr->status = *token;
+	debug_gps("status:%c\n",ptr->status);
+	break;
+    case 2:
+	ptr->latitude = atof(token);
+	debug_gps("latitude:%f\n",ptr->latitude);
+	break;
+    case 3:
+        //strcpy(&ptr->lat_direction, token);
+	ptr->lat_direction = *token;
+	debug_gps("lat_direction:%c\n",ptr->lat_direction);
+	break;
+    case 4:
+	ptr->longitude  = atof(token);
+	debug_gps("longitude:%f\n",ptr->longitude);
+	break;
+    case 5:
+        //strcpy(&ptr->lat_direction, token);
+	ptr->long_direction = *token;
+	debug_gps("long_direction:%c\n",ptr->long_direction);
+	break;
+    case 6:
+	ptr->speed = atof(token);
+	debug_gps("speed:%f\n",ptr->speed);
+	break;
+    case 7:
+	ptr->trackgood  = atof(token);	
+	debug_gps("trackgood:%f\n",ptr->trackgood);
+	break;
+    case 8:
+	ptr->date  = atof(token);
+	debug_gps("date:%f\n",ptr->date);
+	break;
+    case 9:
+	ptr->magvar = atof(token);
+	debug_gps("magvar:%f\n",ptr->magvar);
+	break;
+    case 10:
+	ptr->magvardirection = (*token);
+	debug_gps("magvardirection:%c\n",ptr->magvardirection);
+	break;
+    case 11:
+        strcpy(ptr->checksum, token);
+	debug_gps("checksum:%s\n",ptr->checksum);
+	break;
+
+
+    default:
+        printf("\nGPRMC: fieldnumber{%d}:is not implemented:value:%s\n",field_num,token);
+	break;
+    }
+
+    return;
+} 
+
+
+
+
+//alt 8th case for gpgga
+void save_gpgga_token_3_1(char *token,int field_num){
+    GPGGA_msg_t *ptr = &GPGGA_msg_g;
+    debug_gps("GPGGA:token %s,  field_num:%d\n",token,field_num);
+    switch(field_num){
+	case 8:
+		ptr->alt =atof(token);
+		debug_gps("%s:set alt:%f,token:%s\n",__func__,ptr->alt,token);
+	default:
+		debug_gps("%s: %s token , %d field not used for now",__func__,token,field_num);
+    }
+//    debug_gps("%s:token:%s,field_num:%d\n",__func__,token,field_num);
+    return;
+}
+
+
+void save_gpvtg_token_3_1(char *token,int field_num){
+
+    debug_gps("%s:token:%s,field_num:%d\n",__func__,token,field_num);
+    return;
+}
+
+
+void save_gngsa_token_3_1(char *token,int field_num){
+
+    debug_gps("%s:token:%s,field_num:%d\n",__func__,token,field_num);
+    return;
+}
+
+
+void save_gpgll_token_3_1(char *token,int field_num){
+    debug_gps("%s:token:%s,field_num:%d\n",__func__,token,field_num);
+    return;
+}
+
+void save_pstmcpu_token_3_1(char *token,int field_num){
+
+    debug_gps("%s:token:%s,field_num:%d\n",__func__,token,field_num);
+    return;
+}
+
+
+//#define DEBUG_PSTMPV
+void save_pstmpv_token_3_1(char *token,int field_num){
+    //printf("%s:token:%s,field_num:%d\n",__func__,token,field_num);
+    PSTMPV_msg_t *ptr = &PSTMPV_msg_g; 
+    switch(field_num){
+    case 0:
+	ptr->timestamp = atof(token);
+	debug_gps("timestamp:%f\n",ptr->timestamp);
+        #ifdef DEBUG_PSTMPV
+	printf("timestamp:%f\n",ptr->timestamp);
+	#endif
+	break;
+    case 1:
+	ptr->latitude = atof(token);
+	debug_gps("latitude:%f\n",ptr->latitude);
+        #ifdef DEBUG_PSTMPV
+	printf("latitude:%f\n",ptr->latitude);
+	#endif
+	break;
+    case 2:
+        //strcpy(&ptr->lat_direction, token);
+	ptr->lat_direction = *token;
+	debug_gps("lat_direction:%c\n",ptr->lat_direction);
+	break;
+    case 3:
+	ptr->longitude  = atof(token);
+	debug_gps("longitude:%f\n",ptr->longitude);
+	break;
+    case 4:
+        //strcpy(&ptr->lat_direction, token);
+	ptr->long_direction = *token;
+	debug_gps("long_direction:%c\n",ptr->long_direction);
+	break;
+    case 5:
+	ptr->alt = atof(token);
+	debug_gps("alt:%f\n",ptr->alt);
+	break;
+    case 6:
+	ptr->alt_val  = *(token);	
+	debug_gps("alt_val:%c\n",ptr->alt_val);
+	break;
+    case 7:
+	ptr->vel_N  = atof(token);
+	debug_gps("vel_N:%f\n",ptr->vel_N);
+        #ifdef DEBUG_PSTMPV
+	printf("vel_N:%f\n",ptr->vel_N);
+	#endif
+	break;
+    case 8:
+	ptr->vel_E = atof(token);
+	debug_gps("vel_E:%f\n",ptr->vel_E);
+        #ifdef DEBUG_PSTMPV
+	printf("vel_E:%f\n",ptr->vel_E);
+	#endif
+	break;
+    case 9:
+	ptr->P_cov_N = atof(token);
+	debug_gps("P_cov_N:%f\n",ptr->P_cov_N);
+        #ifdef DEBUG_PSTMPV
+	printf("P_cov_N:%f\n",ptr->P_cov_N);
+	#endif
+	break;
+
+    case 10:
+	ptr->P_cov_NE = atof(token);
+	debug_gps("P_cov_NE:%f\n",ptr->P_cov_NE);
+	break;
+
+    case 11:
+	ptr->P_cov_NV = atof(token);
+	debug_gps("P_cov_NV:%f\n",ptr->P_cov_NV);
+	break;
+    case 12:
+	ptr->P_cov_E = atof(token);
+	debug_gps("P_cov_E:%f\n",ptr->P_cov_E);
+	break;
+    case 13:
+	ptr->P_cov_EV = atof(token);
+	debug_gps("P_cov_EV:%f\n",ptr->P_cov_EV);
+	break;
+    case 14:
+	ptr->P_cov_V = atof(token);
+	debug_gps("P_cov_V:%f\n",ptr->P_cov_V);
+	break;
+    case 15:
+	ptr->P_cov_N = atof(token);
+	debug_gps("P_cov_N:%f\n",ptr->P_cov_N);
+	break;
+    case 16:
+	ptr->V_cov_N = atof(token);
+	debug_gps("V_cov_N:%f\n",ptr->V_cov_N);
+	break;
+    case 17:
+	ptr->V_cov_NE = atof(token);
+	debug_gps("V_cov_NE:%f\n",ptr->V_cov_NE);
+	break;
+    case 18:
+	ptr->V_cov_NV = atof(token);
+	debug_gps("V_cov_NV:%f\n",ptr->V_cov_NV);
+	break;
+    case 19:
+	ptr->V_cov_E = atof(token);
+	debug_gps("V_cov_E:%f\n",ptr->V_cov_E);
+	break;
+    case 20:
+	ptr->V_cov_EV = atof(token);
+	debug_gps("V_cov_EV:%f\n",ptr->V_cov_EV);
+	break;
+    case 21:
+	ptr->V_cov_V = atof(token);
+	debug_gps("V_cov_V:%f\n",ptr->V_cov_V);
+	break;
+
+    default:
+        printf("\nPSTMPV: fieldnumber{%d}:is not implemented:value:%s\n",field_num,token);
+	break;
+    }
+
+    return;
+} 
+
+
+msg_details_nmea_t nmea_msg_details[]={
+{"$GPRMC", 12, &save_gprmc_token_3_1},
+{"$GPGGA",14, &save_gpgga_token_3_1},
+{"$GPVTG",9, &save_gpvtg_token_3_1},
+{"$GNGSA",17, &save_gngsa_token_3_1},
+{"$GPGLL",7, &save_gpgll_token_3_1},
+{"$PSTMCPU",3, &save_pstmcpu_token_3_1},
+{"$PSTMPV",22, &save_pstmpv_token_3_1},
+};
+
+/*below macros should follow nmea_msg_details order*/
+#define GPRMC 0
+#define GPGGA 1
+#define GPVTG 2
+#define GNGSA 3
+#define GPGLL 4
+#define PSTMCPU 5
+#define PSTMPV 6
+
+
+static int nmea_msg_valid[sizeof(nmea_msg_details)/sizeof(nmea_msg_details[0])];
+
+
+float getLatitude(){
+   if(nmea_msg_valid[GPRMC])
+	  return GPRMC_msg_g.latitude;
+   if(nmea_msg_valid[PSTMPV])
+	  return PSTMPV_msg_g.latitude;
+    return float(0.0);
+}
+
+float getLongitude(){
+   if(nmea_msg_valid[GPRMC])
+	  return GPRMC_msg_g.longitude;
+   if(nmea_msg_valid[PSTMPV])
+	  return PSTMPV_msg_g.longitude;
+    return float(0.0);
+
+}
+
+
+float getAltitude(){
+   //if(nmea_msg_valid[PSTMPV])
+	  //return PSTMPV_msg_g.alt;
+   if(nmea_msg_valid[GPGGA])
+	  return GPGGA_msg_g.alt;
+    debug_gps("Return zero Altitude:nmea_msg_valid[GPGGA]:%d\n",nmea_msg_valid[GPGGA]);
+    return float(0.0);
+
+}
+
+float getNedNorthVel(){
+   if(nmea_msg_valid[PSTMPV])
+          return PSTMPV_msg_g.vel_N;
+    return float(0.0);
+}
+
+float getNedEastVel(){
+   if(nmea_msg_valid[PSTMPV])
+        return PSTMPV_msg_g.vel_E;
+    return float(0.0);
+}
+
+float getNedDownVel(){
+   if(nmea_msg_valid[PSTMPV])
+        return PSTMPV_msg_g.vel_V;
+    return float(0.0);
+}
+
+
+
+int get_nmea_index(char *token){
+    int i,ret=-1;
+    int array_size=(sizeof(nmea_msg_details)/sizeof(nmea_msg_details[0]));
+    //printf("E:%s,array_size:%d\n",__func__,array_size);
+    for(i=0;i<array_size;i++){
+       // printf("i:%d\n",i);
+	//if (!strcmp(token, nmea_msg_details[i].name) ){
+	if (strstr(token, nmea_msg_details[i].name)!=NULL ){
+    //	    printf("index found:X:{%s}:%d\n",token,i);
+	    ret=i;
+	    break;
+	} 
+    }
+    if(i==array_size){
+	debug_gps("index not found, Message :{%s} is not supported by app",token);
+	ret=-1;
+  }
+   return ret;
+}
+
+
+char *
+strtok_single (char * str, char const * delims)
+{
+  static char  * src = NULL;
+  char  *  p,  * ret = 0;
+
+  if (str != NULL)
+    src = str;
+
+  if (src == NULL || *src == '\0')
+    return NULL;
+
+  ret = src;
+  if ((p = strpbrk (src, delims)) != NULL) {
+    *p  = 0;
+    //ret = src;
+    src = ++p;
+
+  } else
+         src+=strlen(src); 
+
+  return ret;
+}
+
+void process_gps_string(char *buffer){
+    int i = 0;
+    int current_msg_idx = -1;
+
+          // sleep(1);
+   // printf("%s():%s\n",__func__,buffer);
+   // fflush(stdout);
+          // sleep(1);
+
+    char *token = strtok_single(buffer,",");
+    while (token!=NULL){
+	debug_gps("token is:%s\n",token);
+	if((strstr(token,"$G")!=NULL) || (strstr(token,"$P")!=NULL)){
+			debug_gps("%s is new message\n",token);
+			/*add check if message is supported or not here*/
+			valid_token=1;
+			last_msg_index = get_nmea_index(token);
+			if(last_msg_index >=0){
+	//		printf("index:%d\n",last_msg_index);
+				fields_left = nmea_msg_details[last_msg_index].field_count;
+				current_msg_idx = last_msg_index;
+			} else {
+				valid_token=0;
+				current_msg_idx = -1;
+				debug_gps("token:%s not supported\n",token);
+			}
+	}else{
+		if(!valid_token){
+	//		printf("token not valid: discardind{%s}\n",token);
+		//	sleep(1);
+        		token=strtok_single(NULL,",");
+	//		printf("new token is:%s\n",token);
+			continue;
+		}
+		if(*token == NULL){
+			debug_gps("Empty Field\n");
+		}else{
+			nmea_msg_details[last_msg_index].save_token(token,
+	 			nmea_msg_details[last_msg_index].field_count - fields_left);
+			if(last_msg_index==1){//GPGGA
+				debug_gps("GPGGA Token:%s\n",token);
+			}
+		}
+		fields_left--;
+	//	printf("fields left for :%s is :%d\n",nmea_msg_details[last_msg_index].name,fields_left);
+		if(fields_left == 0){
+			debug_gps("all fields received:\n");
+			if(current_msg_idx >= 0){
+				debug_gps("marking %s/%d nmea_msg valid\n", 
+					nmea_msg_details[current_msg_idx].name,current_msg_idx);
+				nmea_msg_valid[current_msg_idx] = 1;
+				if(current_msg_idx ==  1){
+					debug_gps("Marking%s valid\n",nmea_msg_details[current_msg_idx].name);
+				}
+			}
+	//		sleep(1);
+			valid_token = 0;
+		}
+	}
+        token=strtok_single(NULL,",");
+   }
+	/*if complete message was not received, mark it invalid and proceed*/
+		if(current_msg_idx >= 0 && fields_left != 0){
+				nmea_msg_valid[current_msg_idx] = 0;
+			}
+
+           debug_gps("%s: done!!\n",__func__);
+           //sleep(1);
+    return;
+}
+
+
+
+void readGPS_thread(ST_GNSS1_IMU *ST_GNSS1_cls){
+	printf("%s started\n",__func__);
+	Stream SerialPort_local;
+	//uint8_t buffer ;
+	int i=0;
+		
+	SerialPort_local = ST_GNSS1_cls->serialPort;
+	if(ST_GNSS1_cls == NULL){
+		printf("Error NULL imu class\n");
+	}
+	printf("gpsThread\n");
+	std::string port = "/dev/ttySTM1";
+        int device = open(port.c_str(), O_RDWR | O_NOCTTY | O_SYNC);
+
+
+    std::string response;
+    char buffer[1024*16];
+    int parity=0;
+    struct termios tty;
+    ssize_t read_l;
+    size_t len = 0;
+    if (tcgetattr(device ,&tty)!=0){
+	printf("Error in tcgetatt\n");
+    }
+#if 1
+        cfsetospeed (&tty, B9600);
+        cfsetispeed (&tty, B9600);
+
+        tty.c_cflag = (tty.c_cflag & ~CSIZE) | CS8;     // 8-bit chars
+        // disable IGNBRK for mismatched speed tests; otherwise receive break
+        // as \000 chars
+        tty.c_iflag &= ~IGNBRK;         // disable break processing
+        tty.c_lflag = 0;                // no signaling chars, no echo,
+                                        // no canonical processing
+        tty.c_oflag = 0;                // no remapping, no delays
+        tty.c_cc[VMIN]  = 0;            // read doesn't block
+        tty.c_cc[VTIME] = 5;            // 0.5 seconds read timeout
+
+        tty.c_iflag &= ~(IXON | IXOFF | IXANY); // shut off xon/xoff ctrl
+
+        tty.c_cflag |= (CLOCAL | CREAD);// ignore modem controls,
+                                        // enable reading
+        tty.c_cflag &= ~(PARENB | PARODD);      // shut off parity
+        tty.c_cflag |= parity;
+        tty.c_cflag &= ~CSTOPB;
+        tty.c_cflag &= ~CRTSCTS;
+       if (tcsetattr (device, TCSANOW, &tty) != 0)
+        {
+                printf("error from tcsetattr\n");
+                return;
+        } else {
+		printf("serial config done\n");
+	}
+
+#endif
+
+
+
+
+
+    do
+    {
+        int n = read(device,(void *) buffer, sizeof buffer);
+
+        if (n > 0) {
+#if 0
+	   //buffer[n+2]='\0';
+	   char *pch = strstr(buffer,"\n");
+           while(pch != NULL){
+		strncpy(pch, ",",1);
+		pch = strstr(buffer, "\n");
+	   }
+
+#endif
+     	   debug_gps("\n[BE4S]:buffer 4m serial: %s\n",buffer);
+	  // fflush(stdout);
+           //sleep(1);
+	  for(int i = 0;buffer[i]!='\0';i++){
+		if(buffer[i]=='\n'){
+			buffer[i]=',';
+		}
+ 	   }
+     	  // printf("\nbuffer from serial is: %s\n",buffer);
+	  // fflush(stdout);
+	   process_gps_string(buffer);
+           //std::cout << buffer;
+        }else{
+		printf("no serial Data\n");
+		usleep(10000); //10,ms
+	}
+
+	getIMUData();
+	//usleep(100000);
+#ifdef DEBUG_IMU_DATA
+	printf("gyro data:x%f,y:%f,Z:%f\n",g_imudata.gyro_x_data ,
+		g_imudata.gyro_y_data, g_imudata.gyro_z_data);
+
+	printf("accel data:x%f,y:%f,Z:%f\n",g_imudata.accel_x_data ,
+		g_imudata.accel_y_data, g_imudata.accel_z_data);
+
+	printf("magn data:x%f,y:%f,Z:%f\n",g_imudata.magn_x_data ,
+		g_imudata.magn_y_data, g_imudata.magn_z_data);
+//	sleep(2);
+#endif
+
+    } while (1); // 'X' means end of transmission
+
+
+    close(device);
+#if 0
+	while(1){
+		while(SerialPort_local.available()){
+			buffer = SerialPort_local.read();
+			printf("gnssData:%c,%d",buffer,buffer);
+		}
+		if(i%10 == 1){
+			i=1;
+			i++;
+			printf("Debug:gpsThread 10 read tries done\n");
+		}
+		sleep(1);
+	}
+#endif
+	return;
+
+}
+
+std::thread ST_GNSS1_IMU::initGPS(Stream serialDev, int gpsDataFormat){
+	serialPort = serialDev;
+	return std::thread(&readGPS_thread,this);
+}
+
+
+ST_GNSS1_IMU::ST_GNSS1_IMU(void){
+
+
+}
+
+
diff --git a/EKF_Linux_Library/EKF_GNSS_Library/src/EKF_GNSS_MPU157F_dk2_Library.h b/EKF_Linux_Library/EKF_GNSS_Library/src/EKF_GNSS_MPU157F_dk2_Library.h
new file mode 100644
index 0000000..2b740ef
--- /dev/null
+++ b/EKF_Linux_Library/EKF_GNSS_Library/src/EKF_GNSS_MPU157F_dk2_Library.h
@@ -0,0 +1,238 @@
+/*
+*) Refactor the code to remove reduentent part. 
+*) Compiled for Linux with C++14 standard
+Copyright (c) 2021 Balamurugan Kandan.
+MIT License; See LICENSE.md for complete details
+Author: 2021 Balamurugan Kandan
+*/
+
+/*
+Updated to be a class, use Eigen, and compile as an Arduino library.
+Added methods to get gyro and accel bias. Added initialization to
+estimated angles rather than assuming IMU is level.
+
+Copyright (c) 2016 - 2019 Regents of the University of Minnesota and Bolder Flight Systems Inc.
+MIT License; See LICENSE.md for complete details
+Author: Brian Taylor
+*/
+
+/*
+Addapted from earlier version
+Copyright 2011 Regents of the University of Minnesota. All rights reserved.
+Original Author: Adhika Lie
+*/
+
+
+
+#ifndef EKF_GNSS_MPU157F_DK2_LIBRARY_H
+
+#define EKF_GNSS_MPU157F_DK2_LIBRARY_H
+
+#include <Wire.h>
+#include <stdint.h>
+#include <atomic>
+#include <cstdio> 
+#include <thread>
+#include <mutex>
+#include <Stream.h>
+
+
+float getLatitude();
+
+float getLongitude();
+
+float getAltitude();
+float getNedNorthVel();
+float getNedEastVel();
+float getNedDownVel();
+
+
+
+std::atomic<int> gpslock(0);
+std::mutex gpsBuffReadmtx[2];
+#define IIO_SYS_DIR "/sys/bus/iio/devices/iio:device"
+
+void init_st_imulib();
+
+typedef struct
+{
+    /* iio dev number in sysfs */
+    uint32_t gyro_id;
+    uint32_t magnet_id;
+    uint32_t accel_id;
+
+    /* gyro scale factor */
+    float gyro_x_scale;
+    float gyro_y_scale;
+    float gyro_z_scale;
+
+
+    /* accelerometer scale factor */
+    float accel_x_scale;
+    float accel_y_scale;
+    float accel_z_scale;
+
+    /* magnetometer scale factor */
+    float magn_x_scale;
+    float magn_y_scale;
+    float magn_z_scale;
+
+    /*SYSFS FILE FD for gyro*/
+    FILE *gyro_x_fd;
+    FILE *gyro_y_fd;
+    FILE *gyro_z_fd;
+
+    /*sysfs FILE fd for accelerometer*/
+    FILE *accel_x_fd;
+    FILE *accel_y_fd;
+    FILE *accel_z_fd;
+
+
+    /*sysfs FILE fd for magnetometer*/
+    FILE *magn_x_fd;
+    FILE *magn_y_fd;
+    FILE *magn_z_fd;
+
+} ST_IMU_SensorInfo_t;
+
+
+typedef struct file_fd_imus_t{
+
+    /*SYSFS FILE FD for gyro*/
+    char gyro_path[100];
+    FILE *gyro_x_fd;
+    FILE *gyro_y_fd;
+    FILE *gyro_z_fd;
+
+    FILE *gyro_xscale_fd;
+    FILE *gyro_yscale_fd;
+    FILE *gyro_zscale_fd;
+    char accel_path[100];
+    /*sysfs FILE fd for accelerometer*/
+    FILE *accel_x_fd;
+    FILE *accel_y_fd;
+    FILE *accel_z_fd;
+
+    FILE *accel_xscale_fd;
+    FILE *accel_yscale_fd;
+    FILE *accel_zscale_fd;
+
+    /*sysfs FILE fd for magnetometer*/
+    char magn_path[100];
+    FILE *magn_x_fd;
+    FILE *magn_y_fd;
+    FILE *magn_z_fd;
+
+    FILE *magn_xscale_fd;
+    FILE *magn_yscale_fd;
+    FILE *magn_zscale_fd;
+
+}fdlist_imus;
+
+
+typedef struct imu_s_data_{
+	float x;
+	float y;
+	float z;
+}imu_s_data;
+
+typedef struct
+{
+
+    float gyro_x_data;
+    float gyro_y_data;
+    float gyro_z_data;
+
+    float accel_x_data;
+    float accel_y_data;
+    float accel_z_data;
+
+    float magn_x_data;
+    float magn_y_data;
+    float magn_z_data;
+
+} ST_IMU_SensorData_t;
+
+typedef struct
+{
+    int solutionType; /* 2: DGNSS/FIX , 1: DGNSS/Float 0:No RTK FIxed*/
+    float latitude;
+    float longitude;
+    float altitude;
+    float altitude_msl;
+    float SIV; /* satellite in view */
+    float PDOP; /* Position Dilution of Precision*/
+    float fixType;
+    float groundSpeed;
+    float VelN; /* NORTH Velocity */
+    float VelE; /* EAST Velocity */
+    float VelD; /* NDOWN Velocity */
+    float VAcc; /* Vertical Acceleration */
+    float HAcc; /* Horizontal Acceleration */
+    float SpeedAccEst; /* ?? */
+    float HeadAccEst; /* ?? */
+    float HeadVehValid; /* ?? */
+    float HeadVeh;
+    float MagDec;
+    float MagAcc;
+
+
+} ST_GPS_Data_t;
+
+
+enum gpsDataType{
+	NONE=0,
+	NMEA,
+	RTCM,
+	RTCM3,
+	GPS_D_MAX
+} currentDataMode = NONE;
+
+
+void initGyro(char *dev_name);
+void initAccel(char *dev_name);
+void initMagn(char *dev_name);
+void  getIMUData();
+
+
+class ST_GNSS1_IMU
+{
+public:
+	ST_GNSS1_IMU(void);
+	void initGPSThread();
+	imu_s_data getGyroData();	
+	imu_s_data getAccelData();	
+	imu_s_data getMagnData();	
+
+	/*gpsDataFormat is either NMEA, RTCM, RTCM3*/
+	std::thread initGPS(Stream serialdevGPS ,int gpsDataFormat); 
+	float getGPSData();
+	/*get IMU Data*/
+	ST_IMU_SensorData_t getIMUData();
+	Stream serial_inst;
+	uint8_t *serialBuffer = NULL;
+	Stream serialPort;
+
+private:
+	/*thread processes GPS data in a thread and stores in gpsData pingpong bufer
+	 Atomic operation is needed to ensure while updating active buffer getGPSData callback doesnt picks old/invalid data*/	
+	
+	/*save sensor information like FILE fd for various sensors data nodes and scaling parameters*/
+	ST_IMU_SensorInfo_t sensorinfo;
+	/*below is needed if running IU sensor data thread and storing data in pingpong buffer
+	Just like GPS*/
+	/*ST_IMU_SensorData_t sensordata[2];
+
+	std::atomic<int> imudatalock(0);
+	*/
+
+
+	ST_GPS_Data_t GPSpingpong_dat[2];
+	uint16_t baudrate;
+	char SerialName[40];
+	uint8_t gpsValidnum;
+
+};
+
+
+#endif
diff --git a/EKF_Linux_Library/EKF_GNSS_Library/src/EKF_GNSS_msg.h b/EKF_Linux_Library/EKF_GNSS_Library/src/EKF_GNSS_msg.h
new file mode 100644
index 0000000..a4fc18a
--- /dev/null
+++ b/EKF_Linux_Library/EKF_GNSS_Library/src/EKF_GNSS_msg.h
@@ -0,0 +1,199 @@
+/*
+*) Refactor the code to remove reduentent part. 
+*) Compiled for Linux with C++14 standard
+Copyright (c) 2021 Balamurugan Kandan.
+MIT License; See LICENSE.md for complete details
+Author: 2021 Balamurugan Kandan
+*/
+
+/*
+Updated to be a class, use Eigen, and compile as an Arduino library.
+Added methods to get gyro and accel bias. Added initialization to
+estimated angles rather than assuming IMU is level.
+
+Copyright (c) 2016 - 2019 Regents of the University of Minnesota and Bolder Flight Systems Inc.
+MIT License; See LICENSE.md for complete details
+Author: Brian Taylor
+*/
+
+/*
+Addapted from earlier version
+Copyright 2011 Regents of the University of Minnesota. All rights reserved.
+Original Author: Adhika Lie
+*/
+
+#ifndef EKF_GNSS_MSG_H
+#define EKF_GNSS_MSG_H
+
+#define NMEA_0183
+#define NMEA_REV_3_1
+
+#ifdef NMEA_0183
+
+#ifdef NMEA_REV_3_1
+
+#include <stdlib.h>
+
+/*
+extern GPRMC_msg_g;
+extern GPGGA_msg_g;
+extern GPVTG_msg_g;
+extern GNGSA_msg_g;
+extern GPGLL_msg_g;
+extern PSTMCPU_msg_g;
+*/
+
+typedef struct msg_array_NMEA{
+ char *name;
+ int field_count;
+ void (*save_token)(char *token,int field_num);
+// void *getData();
+}msg_details_nmea_t;
+
+
+typedef struct GPRMC_msg_rev3_1 {
+    float timestamp;
+    char status;
+    float latitude;
+    char lat_direction;
+    float longitude;
+    char long_direction;
+    float speed;
+    float trackgood;
+    float date;
+    float magvar;
+    char magvardirection;
+   // char mode;
+    //char navStatus;
+    char checksum[8];
+} GPRMC_msg_t;
+
+
+typedef struct PSTMPV_msg_rev3_1 {
+    float timestamp;
+    float latitude;
+    char lat_direction;
+    float longitude;
+    char long_direction;
+    float alt;
+    char alt_val; //M=meters
+    float vel_N;//north velocity, m/s
+    float vel_E;//east velocity, m/s
+    float vel_V; //velocity vertical, m/s
+    float P_cov_N;
+    float P_cov_NE;
+    float P_cov_NV;
+    float P_cov_E;
+    float P_cov_EV;
+    float P_cov_V;
+    float V_cov_N;
+    float V_cov_NE;
+    float V_cov_NV;
+    float V_cov_E;
+    float V_cov_EV;
+    float V_cov_V;
+}PSTMPV_msg_t;
+
+typedef struct GPGGA_msg_rev3_1 {
+    float timestamp;
+    float latitude;
+    char  lat_direction;
+    float longitude;
+    char  long_direction;
+    unsigned char gpsQual;
+    unsigned char sats;
+    float HDOP;
+    float alt;
+    float GeoSep;
+    float GeoVal;
+    float DGPSAge;
+    float DGPSRef;
+    char checksum[8];
+} GPGGA_msg_t;
+
+typedef struct GPVTG_msg_rev3_1 {
+    float tmgt;
+    char terrest;
+    float tmgm;
+    char magn;
+    float SoGN;
+    char n;
+    float SoGK;
+    char km;
+   // char mode_d;
+    char checksum[8];
+
+}GPVTG_msg_t;
+
+
+typedef struct GNGSA_msg_rev3_1 {
+    char mode_1; /*M=Manual, A= AUtomatic*/
+    char mode_2; /*Fix Type, 1= N/A, 2=2D , 3=3D*/
+    unsigned long prn;
+    float PDOP;
+    float HDOP; 
+    float VDOP; 
+    unsigned int sys_ID;
+    char checksum[8];
+}GNGSA_msg_t;
+
+
+typedef struct GPGLL_msg_rev3_1 {
+    float latitude;
+    char lat_direction;
+    float longitude;
+    char lon_direction;
+    float timestamp;
+    char status;
+    char pos_mode;
+    char checksum[8];
+}GPGLL_msg_t;
+
+typedef struct PSTMCPU_msg_rev3_1 {
+    float CPU_usage;
+    float CPU_speed;
+    char checksum[8];
+}PSTMCPU_msg_t;
+
+
+void process_gps_string(char *buffer);
+
+float getLatitude();
+float getLongitude();
+float getAltitude();
+float getNedNorthVel();
+float getNedEastVel();
+float getNedDownVel();
+
+
+//#define DEBUG_GPS_ON 
+//#define DEBUG_IMU_DATA
+
+#ifdef DEBUG_GPS_ON
+
+#define debug_gps(fmt, ...) \
+	do { printf("%s():" fmt,__func__,__VA_ARGS__);}while(0)
+
+#else
+#define debug_gps(fmt,...) do {} while(false)
+#endif
+
+
+//#define DEBUG_IMU_ON
+#ifdef DEBUG_IMU_ON
+
+#define debug_imu(fmt, args...) \
+	do { printf("%s():" fmt,__func__, ##args);}while(0)
+
+#else
+#define debug_imu(fmt,...) do {} while(false)
+#endif
+
+
+
+
+#endif //NMEA_REV_3_1
+
+#endif //NMEA_0183
+
+#endif //Header
diff --git a/Ublox_Linux_Library/LICENSE b/EKF_Linux_Library/LICENSE
similarity index 100%
rename from Ublox_Linux_Library/LICENSE
rename to EKF_Linux_Library/LICENSE
diff --git a/Ublox_Linux_Library/inc/Common.h b/EKF_Linux_Library/inc/Common.h
similarity index 70%
rename from Ublox_Linux_Library/inc/Common.h
rename to EKF_Linux_Library/inc/Common.h
index 0b46147..f7b6b99 100644
--- a/Ublox_Linux_Library/inc/Common.h
+++ b/EKF_Linux_Library/inc/Common.h
@@ -1,6 +1,6 @@
 #ifndef COMMON_H__
 #define COMMON_H__
-
+#include <stdint.h>
 typedef uint8_t byte;
 typedef bool boolean;
 
@@ -11,6 +11,6 @@ typedef bool boolean;
 
 #define SHORT_BUFF 256
 
-#define I2C_DEV "/dev/ublox_i2c"
+#define I2C_DEV "/dev/noname"
 
-#endif // COMMON_H__
\ No newline at end of file
+#endif // COMMON_H__
diff --git a/Ublox_Linux_Library/inc/Print.h b/EKF_Linux_Library/inc/Print.h
similarity index 100%
rename from Ublox_Linux_Library/inc/Print.h
rename to EKF_Linux_Library/inc/Print.h
diff --git a/Ublox_Linux_Library/inc/Stream.h b/EKF_Linux_Library/inc/Stream.h
similarity index 100%
rename from Ublox_Linux_Library/inc/Stream.h
rename to EKF_Linux_Library/inc/Stream.h
diff --git a/Ublox_Linux_Library/inc/Utils.h b/EKF_Linux_Library/inc/Utils.h
similarity index 100%
rename from Ublox_Linux_Library/inc/Utils.h
rename to EKF_Linux_Library/inc/Utils.h
diff --git a/Ublox_Linux_Library/inc/WProgram.h b/EKF_Linux_Library/inc/WProgram.h
similarity index 100%
rename from Ublox_Linux_Library/inc/WProgram.h
rename to EKF_Linux_Library/inc/WProgram.h
diff --git a/Ublox_Linux_Library/inc/Wire.h b/EKF_Linux_Library/inc/Wire.h
similarity index 98%
rename from Ublox_Linux_Library/inc/Wire.h
rename to EKF_Linux_Library/inc/Wire.h
index 957e936..53b13f4 100755
--- a/Ublox_Linux_Library/inc/Wire.h
+++ b/EKF_Linux_Library/inc/Wire.h
@@ -6,7 +6,9 @@
 #include <linux/i2c.h>
 #include <sys/ioctl.h>
 #include <cstdio>
-
+#include <unistd.h>
+#include <errno.h>
+#include <cstring>
 #include "Common.h"
 
 class TwoWire
@@ -172,4 +174,4 @@ private:
 
 extern TwoWire Wire;
 
-#endif //Wire_h
\ No newline at end of file
+#endif //Wire_h
diff --git a/EKF_Linux_Library/linux_build/CMakeLists.txt b/EKF_Linux_Library/linux_build/CMakeLists.txt
new file mode 100644
index 0000000..51401f6
--- /dev/null
+++ b/EKF_Linux_Library/linux_build/CMakeLists.txt
@@ -0,0 +1,54 @@
+project (ekf_linux)
+cmake_minimum_required(VERSION 2.8)
+
+set(CMAKE_SKIP_BUILD_RPATH TRUE)
+set(CMAKE_BUILD_WITH_INSTALL_RPATH FALSE)
+set(CMAKE_INSTALL_RPATH_USE_LINK_PATH FALSE)
+
+set(
+    CMAKE_RUNTIME_OUTPUT_DIRECTORY
+    ${CMAKE_HOME_DIRECTORY}/bin
+    )
+
+set(
+    CMAKE_LIBRARY_OUTPUT_DIRECTORY
+    ${CMAKE_HOME_DIRECTORY}/lib
+    )
+
+add_definitions(
+    -std=c++11 -Wno-deprecated -fconcepts -Wall -DLINUX_PLATFORM -pthread
+    )
+
+link_directories(
+    /usr/local/lib
+    /usr/lib
+    ${CMAKE_HOME_DIRECTORY}/lib
+    )
+
+include_directories(
+    ${CMAKE_HOME_DIRECTORY}/../inc
+    ${CMAKE_HOME_DIRECTORY}/../EKF_GNSS_Library/src
+    )
+
+set(
+    ekf_parser_src
+    ../EKF_GNSS_Library/src/EKF_GNSS_MPU157F_dk2_Library.cpp
+    ../src/Print.cpp
+    ../src/Utils.cpp
+    )
+
+add_library(
+    ekf_linux SHARED ${ekf_parser_src}
+    )
+
+
+set(
+    ekf_gnss1_test_src
+    ../linux_examples/ekf_gnss1_test.cpp
+    )
+
+add_executable(
+    ekf_gnss1_test ${ekf_gnss1_test_src}
+    )
+
+target_link_libraries(ekf_gnss1_test ekf_linux util)
diff --git a/EKF_Linux_Library/linux_examples/ekf_gnss1_test.cpp b/EKF_Linux_Library/linux_examples/ekf_gnss1_test.cpp
new file mode 100644
index 0000000..cd5f2c4
--- /dev/null
+++ b/EKF_Linux_Library/linux_examples/ekf_gnss1_test.cpp
@@ -0,0 +1,803 @@
+/*
+Copyright (c) 2020 Balamurugan Kandan
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in all
+copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+SOFTWARE.
+*/
+
+
+/*
+*) Refactor the code to remove reduentent part. 
+*) Compiled for Linux with C++14 standard
+Copyright (c) 2021 Balamurugan Kandan.
+MIT License; See LICENSE.md for complete details
+Author: 2021 Balamurugan Kandan
+*/
+
+/*
+Updated to be a class, use Eigen, and compile as an Arduino library.
+Added methods to get gyro and accel bias. Added initialization to
+estimated angles rather than assuming IMU is level.
+
+Copyright (c) 2016 - 2019 Regents of the University of Minnesota and Bolder Flight Systems Inc.
+MIT License; See LICENSE.md for complete details
+Author: Brian Taylor
+*/
+
+/*
+Addapted from earlier version
+Copyright 2011 Regents of the University of Minnesota. All rights reserved.
+Original Author: Adhika Lie
+*/
+
+
+
+#include <algorithm>
+#include "ekfNavINS.h"
+#include "../../ekf_nav_ins/inc/ekfNavINS.h"
+#include <iostream>
+#include <iomanip>
+#include <tuple>
+#include <fstream>
+#include <string>
+#include <signal.h>
+#include <time.h>
+
+#include "EKF_GNSS_MPU157F_dk2_Library.h"
+#define SERIAL_ST_DEV "/dev/ttySTM1"
+ST_GNSS1_IMU myGPS;
+
+
+using namespace std;
+static int running = 0;
+
+extern fdlist_imus g_imufds;
+extern ST_IMU_SensorData_t g_imudata;
+
+
+static void __signal_handler(__attribute__((unused))int dummy){
+	running = 0;
+	return;
+}
+
+char* getCmdOption(char ** begin, char ** end, const std::string & option)
+{
+    char ** itr = std::find(begin, end, option);
+    if (itr != end && ++itr != end)
+    {
+        return *itr;
+    }
+    return 0;
+}
+
+#define NEW_TEST
+#ifdef NEW_TEST
+
+// file pointer
+fstream fout;
+fstream fout_log;
+inline void open_file(std::string file_name) {
+    fout.open(file_name, ios::out | ios::app);
+    fout << std::fixed <<"time" << "," << "latitude" << "," << "longitude" << "," 
+    								   << "roll" << "," << "pitch" << "," << "yaw" << "," 
+    								   << "filtered_latitude" << "," << "filtered_longitude" << ","
+    								   << "filtered_roll" << "," << "filtered_pitch" << "," << "filtered_yaw" << std::endl;
+}
+
+
+inline void open_file_log(std::string file_name) {
+    fout_log.open(file_name, ios::out | ios::app);
+    fout_log << std::fixed <<"time" << "," << "latitude" << "," << "longitude" << ","  << "altid" << ","
+    								   << "ax" << "," << "ay" << "," << "az" << "," 
+    								   << "hx" << "," << "hy" << ","
+    								   << "hz" << "," << "nVel" << ","  << "eVel" << ","  << "dVel" << std::endl;
+}
+
+
+
+inline void update_file(long int time, double latitude, double longitude,
+						float roll, float pitch, float yaw, 
+						double filtered_latitude, double filtered_longitude,
+						float filtered_roll, float filtered_pitch, float filtered_yaw) {
+	fout << time << "," << std::setprecision(7) << latitude << "," << std::setprecision(7) << longitude 
+				 << "," << roll << "," << pitch << "," << yaw
+				 << "," << std::setprecision(7) << filtered_latitude << "," << std::setprecision(7) << filtered_longitude 
+				 << "," << filtered_roll << "," << filtered_pitch << "," << filtered_yaw << std::endl;
+}
+
+inline void update_file_log(long int time, double latitude, double longitude,double altid, double ax,double ay,double az, double hx, double hy,double hz,double nVel, double eVel, double dVel){
+	fout_log << time << "," << std::setprecision(7) << latitude << "," << std::setprecision(7) << longitude << "," << std::setprecision(7) << altid
+				 << "," << ax << "," << ay << "," << az
+				 << "," << std::setprecision(7) << hx << "," << std::setprecision(7) << hy 
+				 << "," << hz << "," << nVel << "," << eVel << "," << dVel<< std::endl;
+}
+
+
+
+
+inline void close_file() {
+	printf("%s\n",__func__);
+	fout.close();
+}
+
+ inline void close_file_log() {
+	fout_log.close();
+}     
+
+
+#endif
+
+bool cmdOptionExists(char** begin, char** end, const std::string& option)
+{
+    return std::find(begin, end, option) != end;
+}
+
+void helpmenu(){
+    printf("\n-----HELP MENU-----\n");
+    printf("-h 'GPS Serial device'\n");
+    printf("-m magnetometer device number in %s\n",IIO_SYS_DIR);
+    printf("-g gyro device number in %s\n",IIO_SYS_DIR);
+    printf("-a accelerometer device number in %s\n",IIO_SYS_DIR);
+    printf("Sample cmdline: app_name -h /dev/ttySTM1 -g 0 -a 2 -m 3,\n where 0,2,3 are iio dev numbers in %s\n",IIO_SYS_DIR);
+    printf("\n---Menu Ends here---");
+}
+
+char *gyro_dev;
+char filename_csv[50];
+char *magn_dev;
+char *accel_dev;
+int filename_custom=0;
+
+int main(int argc, char** argv)
+{
+    std::thread gpsThread;
+    char *ttyName;
+    char delim_s='/';
+    int accel_passed = 0;
+    int gyro_passed = 0;
+    int magn_passed = 0;
+    ttyName=(char *) malloc(sizeof(char)*30);
+    init_st_imulib();
+for (int i = 1; i < argc; i++) {
+
+    if (strcmp(argv[i],"-h")==0) {
+        strcpy(ttyName,argv[i+1]);
+        printf("ttyName: %s",ttyName);
+    } else if (strcmp(argv[i],"-a")==0) {
+
+	accel_dev = (char *)malloc(strlen(IIO_SYS_DIR)+strlen(argv[i+1])+1);	
+	strcpy(accel_dev,IIO_SYS_DIR);
+	strcat(accel_dev,argv[i+1]);
+	strcat(accel_dev,&delim_s);
+	strcpy(g_imufds.accel_path,accel_dev);
+	printf("accel device node:%s\n",accel_dev);
+
+        int accel = atoi(argv[i + 1]);
+        printf("\naccel ID: %d",accel);
+        initAccel(accel_dev);
+	accel_passed = 1; 
+	
+    } else if (strcmp(argv[i],"-f")==0) {
+	printf("filename is:%s\n",argv[i+1]);
+	strcpy(filename_csv,argv[i+1]);
+	filename_custom = 1;
+    } else if (strcmp(argv[i],"-g")==0) {
+
+	gyro_dev = (char *)malloc(strlen(IIO_SYS_DIR)+strlen(argv[i+1])+1);	
+	strcpy(gyro_dev,IIO_SYS_DIR);
+	strcat(gyro_dev,argv[i+1]);
+	strcat(gyro_dev,&delim_s);
+	strcpy(g_imufds.gyro_path,gyro_dev);
+	printf("gyro device node:%s\n",gyro_dev);
+
+       int gyro = atoi(argv[i + 1]);
+        printf("\ngyro ID:%d",gyro);
+	initGyro(gyro_dev);
+	gyro_passed = 1; 
+
+    } else if (strcmp(argv[i],"-m")==0) {
+
+	magn_dev = (char *)malloc(strlen(IIO_SYS_DIR)+strlen(argv[i+1])+1);	
+	strcpy(magn_dev,IIO_SYS_DIR);
+	strcat(magn_dev,argv[i+1]);
+	strcat(magn_dev,&delim_s);
+	strcpy(g_imufds.magn_path,magn_dev);
+	printf("magn device node:%s\n",magn_dev);
+
+       int magnet = atof(argv[i + 1]);
+        printf("\ntmagnet id:%d",magnet);
+	initMagn(magn_dev);
+	magn_passed = 1; 
+    }
+
+}
+	if(magn_passed && gyro_passed && accel_passed){
+		printf("imu options passed correctly\n");
+	}else {
+		helpmenu();
+		return -1;	
+	}
+
+	
+
+
+    ekfNavINS ekf;
+    float ax, ay, az, hx, hy, hz, pitch, roll, yaw;
+    float latid,longid,altid;
+
+    signal(SIGINT, __signal_handler);
+    running = 1;
+
+
+
+
+    Stream seriComm(ttyName);
+    seriComm.begin(9600);
+    if (!seriComm.isConnected()) {
+        printf ("Please connect GNSS1 module and try again...\n");
+        return 0;
+    }
+
+    #ifdef NEW_TEST 
+	if(!filename_custom)
+		open_file(std::string("./gnss.csv"));
+	else
+		open_file(std::string(filename_csv));
+	//open_file(std::string("./gnss.csv"));
+	open_file_log(std::string("./data_log.csv"));
+    #endif
+    printf ("\n--------------------------------------------------------\n");
+	gpsThread = myGPS.initGPS(seriComm, NMEA);
+        //gpsThread.join();
+	int i = 0;
+	float init_longid=0;
+	float init_latid=0;
+	int is_latlon_init = 0;
+	int latlong_def_value = 0;
+	int init_latitlong=0;
+#define TEST_OUTDOOR_ONLY
+#ifdef TEST_OUTDOOR_ONLY
+	printf("Test OUTDOOR macro case\n");
+	/*skip first value to avoid logging default value */
+	while(!init_latitlong){
+		usleep(100000);
+		longid = getLongitude();
+                latid = getLatitude();
+                altid = getAltitude();
+                if((longid == 0) || (latid == 0)){
+			continue;
+	        }
+		if(!latlong_def_value){
+			printf("non zero value found:%f, %f\n",longid,latid);
+			init_longid = longid;
+			init_latid = latid;
+			latlong_def_value=1;
+			continue;
+		}
+		if((longid != init_longid) ||(latid != init_latid) ){
+			printf("new latlong found:%f, %f\n",longid,latid);
+			init_latitlong = 1;
+		}
+	
+	}
+#endif
+	printf("Start logging Data,as new latlong value recieved!!!\n");
+	while(running){
+	    ax = g_imudata.accel_x_data;
+	    ay = g_imudata.accel_y_data;
+	    az = g_imudata.accel_z_data;
+
+	    hx = g_imudata.magn_x_data; 
+	    hy = g_imudata.magn_y_data; 
+	    hz = g_imudata.magn_z_data; 
+#if 0
+            std::tie(pitch,roll,yaw) = ekf.getPitchRollYaw(ax, ay, az, hx, hy, hz);
+
+            ekf.ekf_update(time(NULL) /*,gps.getTimeOfWeek()*/, getNedNorthVel()*1e-3, getNedEastVel()*1e-3, getNedDownVel()*1e-3,
+                        getLatitude()*1e-7*DEG_TO_RAD, getLongitude()*1e-7*DEG_TO_RAD, (getAltitude()*1e-3),
+                        g_imudata.gyro_x_data*DEG_TO_RAD, -1*g_imudata.gyro_y_data*DEG_TO_RAD, g_imudata.gyro_z_data*DEG_TO_RAD,                   
+                        ax, ay, az, hx, hy, hz);
+#else
+
+            std::tie(pitch,roll,yaw) = ekf.getPitchRollYaw(ax, ay, az, hx, hy, hz);
+		longid = getLongitude();
+                latid = getLatitude();
+                altid = getAltitude();
+
+                float north_vel = getNedNorthVel()*1e-3;
+		float east_vel = getNedEastVel()*1e-3;
+		float down_vel = getNedDownVel()*1e-3;
+//		printf("lat:%f,long:%f, height:%f\n",latid,longid,altid);
+               // printf("velocity:N:%f,E:%f, D:%f", north_vel,east_vel,down_vel);
+		//Update location only if long and latid are not zero!!!
+//#ifndef TEST_OUTDOOR_ONLY
+            if((longid != 0) &&(latid != 0) && (altid !=0 )){ /*altid is zero, TODO check */
+//#endif
+            	ekf.ekf_update(time(NULL) /*,gps.getTimeOfWeek()*/, getNedNorthVel()*1e-3, getNedEastVel()*1e-3, getNedDownVel()*1e-3,
+                        latid*1e-2*DEG_TO_RAD, longid*1e-2*DEG_TO_RAD, altid*1e-3,
+                        g_imudata.gyro_x_data*DEG_TO_RAD, -1*g_imudata.gyro_y_data*DEG_TO_RAD, g_imudata.gyro_z_data*DEG_TO_RAD,                   
+                        ax, ay, az, hx, hy, hz);
+//#ifndef TEST_OUTDOOR_ONLY
+	      }
+//#endif
+	
+#endif
+
+
+#ifdef NEW_TEST
+
+#if 0
+	    update_file(time(NULL), 
+						getLatitude()*1e-7, getLongitude()*1e-7,
+						roll, pitch, yaw,
+						ekf.getLatitude_rad()*RAD_TO_DEG, ekf.getLongitude_rad()*RAD_TO_DEG,
+						ekf.getRoll_rad(), ekf.getPitch_rad(), ekf.getHeading_rad());
+#else
+            if((longid != 0) &&(latid != 0)){
+	                         update_file(time(NULL), 
+                        			latid*1e-2, longid*1e-2, 
+						roll, pitch, yaw,
+						ekf.getLatitude_rad()*RAD_TO_DEG, ekf.getLongitude_rad()*RAD_TO_DEG,
+						ekf.getRoll_rad(), ekf.getPitch_rad(), ekf.getHeading_rad());
+
+
+	                         update_file_log(time(NULL), 
+                        			latid*1e-2, longid*1e-2,altid ,ax,ay,az,hx,hy,hz,
+						north_vel, east_vel, down_vel); 
+
+	     }
+
+#endif
+
+#endif
+	usleep(100000);
+	}
+
+        //sleep(10);
+#if 0
+    while(true) {
+        if (myGPS.getPVT()) {
+          printf ("%02d/%02d/%02d %02d:%02d:%02d %d:%d\n", myGPS.getDay(), myGPS.getMonth(), myGPS.getYear(), 
+                                                           myGPS.getHour(), myGPS.getMinute(), myGPS.getSecond(), 
+                                                           myGPS.getMillisecond(), myGPS.getNanosecond());
+          printf("Latitude                : %2.8f (deg)\n", myGPS.getLatitude() * 1e-7);
+          printf("Longitude               : %2.8f (deg)\n", myGPS.getLongitude() * 1e-7);
+          printf("Altitude                : %d (mm)\n", myGPS.getAltitude());
+          printf("Altitude MSL            : %d (mm)\n", myGPS.getAltitudeMSL());
+          printf("SIV                     : %d\n", myGPS.getSIV());
+          printf("PDOP                    : %f\n", myGPS.getPDOP() * 1e-2); 
+          printf("Fix type                : %d\n", myGPS.getFixType());
+          printf("Ground Speed            : %d\n", myGPS.getGroundSpeed());
+          printf("VelN                    : %08d (mm/s)\n", myGPS.getNedNorthVel());
+          printf("VelE                    : %08d (mm/s)\n", myGPS.getNedEastVel());
+          printf("VelD                    : %08d (mm/s)\n", myGPS.getNedDownVel());
+          printf("VAcc                    : %08d (mm)\n", myGPS.getVerticalAccEst());
+          printf("HAcc                    : %08d (mm)\n", myGPS.getHorizontalAccEst());
+          printf("SpeedAccEst             : %08d (mm/s)\n", myGPS.getSpeedAccEst());
+          printf("HeadAccEst              : %08d (degrees * 10^-5)\n", myGPS.getHeadingAccEst());
+          printf("HeadVehValid            : %s\n", myGPS.getHeadVehValid() ? "true" : "false");
+          printf("HeadVeh                 : %08d (degrees * 10^-5)\n", myGPS.getHeadVeh());
+          printf("MagDec                  : %08d (degrees * 10^-2)\n", myGPS.getMagDec());
+          printf("MagAcc                  : %08d (degrees * 10^-2)\n", myGPS.getMagAcc());
+          int solnType = myGPS.getCarrierSolutionType();
+          if (solnType == 0) printf ("### No RTK Fix yet ###\n");
+          else if (solnType == 1) printf ("&&& DGNSS/Float &&&\n");
+          else if (solnType == 2) printf ("*** DGNSS/Fix ***\n");
+          printf ("\n--------------------------------------------------------\n");
+          usleep(50);
+        }
+
+        usleep(25);
+    }
+#endif
+
+        gpsThread.join();
+	close_file();
+	close_file_log();
+    return 0;
+}
+
+
+
+
+
+
+
+void ekfNavINS::ekf_init(uint64_t time, double vn,double ve,double vd,double lat,double lon,double alt,float p,float q,float r,float ax,float ay,float az,float hx,float hy, float hz) {
+  // grab initial gyro values for biases
+  gbx = p;
+  gby = q;
+  gbz = r;
+  std::tie(theta,phi,psi) = getPitchRollYaw(ax, ay, az, hx, hy, hz);
+  // euler to quaternion
+  quat = toQuaternion(phi, theta, psi);
+  // Assemble the matrices
+  // ... gravity
+  grav(2,0) = G;
+  // ... H
+  H.block(0,0,5,5) = Eigen::Matrix<float,5,5>::Identity();
+  // ... Rw
+  Rw.block(0,0,3,3) = powf(SIG_W_A,2.0f) * Eigen::Matrix<float,3,3>::Identity();
+  Rw.block(3,3,3,3) = powf(SIG_W_G,2.0f) * Eigen::Matrix<float,3,3>::Identity();
+  Rw.block(6,6,3,3) = 2.0f * powf(SIG_A_D,2.0f) / TAU_A*Eigen::Matrix<float,3,3>::Identity();
+  Rw.block(9,9,3,3) = 2.0f * powf(SIG_G_D,2.0f) / TAU_G*Eigen::Matrix<float,3,3>::Identity();
+  // ... P
+  P.block(0,0,3,3) = powf(P_P_INIT,2.0f) * Eigen::Matrix<float,3,3>::Identity();
+  P.block(3,3,3,3) = powf(P_V_INIT,2.0f) * Eigen::Matrix<float,3,3>::Identity();
+  P.block(6,6,2,2) = powf(P_A_INIT,2.0f) * Eigen::Matrix<float,2,2>::Identity();
+  P(8,8) = powf(P_HDG_INIT,2.0f);
+  P.block(9,9,3,3) = powf(P_AB_INIT,2.0f) * Eigen::Matrix<float,3,3>::Identity();
+  P.block(12,12,3,3) = powf(P_GB_INIT,2.0f) * Eigen::Matrix<float,3,3>::Identity();
+  // ... R
+  R.block(0,0,2,2) = powf(SIG_GPS_P_NE,2.0f) * Eigen::Matrix<float,2,2>::Identity();
+  R(2,2) = powf(SIG_GPS_P_D,2.0f);
+  R.block(3,3,2,2) = powf(SIG_GPS_V_NE,2.0f) * Eigen::Matrix<float,2,2>::Identity();
+  R(5,5) = powf(SIG_GPS_V_D,2.0f);
+  // .. then initialize states with GPS Data
+  lat_ins = lat;
+  lon_ins = lon;
+  alt_ins = alt;
+  vn_ins = vn;
+  ve_ins = ve;
+  vd_ins = vd;
+  // specific force
+  f_b(0,0) = ax;
+  f_b(1,0) = ay;
+  f_b(2,0) = az;
+  /* initialize the time */
+  _tprev = time;
+}
+
+void ekfNavINS::ekf_update( uint64_t time/*, unsigned long TOW*/, double vn,double ve,double vd,double lat,double lon,double alt,
+                          float p,float q,float r,float ax,float ay,float az,float hx,float hy, float hz ) {
+  if (!initialized_) {
+    ekf_init(time, vn, ve, vd, lat, lon, alt, p, q, r, ax, ay, az, hx, hy, hz);
+    // initialized flag
+    initialized_ = true;
+  } else {
+    // get the change in time
+    float _dt = ((float)(time - _tprev)) / 1e6;
+    // Update Gyro and Accelerometer biases
+    updateBias(ax, ay, az, p, q, r);
+    // Update INS values
+    updateINS();
+    // Attitude Update
+    dq(0) = 1.0f;
+    dq(1) = 0.5f*om_ib(0,0)*_dt;
+    dq(2) = 0.5f*om_ib(1,0)*_dt;
+    dq(3) = 0.5f*om_ib(2,0)*_dt;
+    quat = qmult(quat,dq);
+    quat.normalize();
+    // Avoid quaternion flips sign
+    if (quat(0) < 0) {
+      quat = -1.0f*quat;
+    }
+    // AHRS Transformations
+    C_N2B = quat2dcm(quat);
+    C_B2N = C_N2B.transpose();
+    // obtain euler angles from quaternion
+    std::tie(phi, theta, psi) = toEulerAngles(quat);
+    // Velocity Update
+    dx = C_B2N*f_b + grav;
+    vn_ins += _dt*dx(0,0);
+    ve_ins += _dt*dx(1,0);
+    vd_ins += _dt*dx(2,0);
+    // Position Update
+    dxd = llarate(V_ins,lla_ins);
+    lat_ins += _dt*dxd(0,0);
+    lon_ins += _dt*dxd(1,0);
+    alt_ins += _dt*dxd(2,0);
+    // Jacobian update
+    updateJacobianMatrix();
+    // Update process noise and covariance time
+    updateProcessNoiseCovarianceTime(_dt);
+    // Gps measurement update
+    //if ((TOW - previousTOW) > 0) {
+    if ((time - _tprev) > 0) {
+      //previousTOW = TOW;
+      lla_gps(0,0) = lat;
+      lla_gps(1,0) = lon;
+      lla_gps(2,0) = alt;
+      V_gps(0,0) = vn;
+      V_gps(1,0) = ve;
+      V_gps(2,0) = vd;
+      // Update INS values
+      updateINS();
+      // Create measurement Y
+      updateCalculatedVsPredicted();
+      // Kalman gain
+      K = P*H.transpose()*(H*P*H.transpose() + R).inverse();
+      // Covariance update
+      P = (Eigen::Matrix<float,15,15>::Identity()-K*H)*P*(Eigen::Matrix<float,15,15>::Identity()-K*H).transpose() + K*R*K.transpose();
+      // State update
+      x = K*y;
+      // Update the results
+      update15statesAfterKF();
+      _tprev = time;
+    }
+    // Get the new Specific forces and Rotation Rate
+    updateBias(ax, ay, az, p, q, r);
+  }
+}
+
+void ekfNavINS::ekf_update(uint64_t time) {
+  std::shared_lock lock(shMutex);
+  ekf_update(time, /*0,*/ gpsVel.vN, gpsVel.vE, gpsVel.vD,
+                      gpsCoor.lat, gpsCoor.lon, gpsCoor.alt,
+                      imuDat.gyroX, imuDat.gyroY, imuDat.gyroZ,
+                      imuDat.accX, imuDat.accY, imuDat.accZ,
+                      imuDat.hX, imuDat.hY, imuDat.hZ);
+}
+
+void ekfNavINS::imuUpdateEKF(uint64_t time, imuData imu) {
+  {
+    std::unique_lock lock(shMutex);
+    imuDat = imu;
+  }
+  ekf_update(time);
+}
+
+void ekfNavINS::gpsCoordinateUpdateEKF(gpsCoordinate coor) {
+  std::unique_lock lock(shMutex);
+  gpsCoor = coor;
+}
+
+void ekfNavINS::gpsVelocityUpdateEKF(gpsVelocity vel) {
+  std::unique_lock lock(shMutex);
+  gpsVel = vel;
+}
+
+void ekfNavINS::updateINS() {
+  // Update lat, lng, alt, velocity INS values to matrix
+  lla_ins(0,0) = lat_ins;
+  lla_ins(1,0) = lon_ins;
+  lla_ins(2,0) = alt_ins;
+  V_ins(0,0) = vn_ins;
+  V_ins(1,0) = ve_ins;
+  V_ins(2,0) = vd_ins;
+}
+
+std::tuple<float,float,float> ekfNavINS::getPitchRollYaw(float ax, float ay, float az, float hx, float hy, float hz) {
+  // initial attitude and heading
+  theta = asinf(ax/G);
+  phi = -asinf(ay/(G*cosf(theta)));
+  // magnetic heading correction due to roll and pitch angle
+  Bxc = hx*cosf(theta) + (hy*sinf(phi) + hz*cosf(phi))*sinf(theta);
+  Byc = hy*cosf(phi) - hz*sinf(phi);
+  // finding initial heading
+  psi = -atan2f(Byc,Bxc);
+  return (std::make_tuple(theta,phi,psi));
+}
+
+void ekfNavINS::updateCalculatedVsPredicted() {
+      // Position, converted to NED
+      pos_ecef_ins = lla2ecef(lla_ins);
+      pos_ecef_gps = lla2ecef(lla_gps);
+      pos_ned_gps = ecef2ned(pos_ecef_gps - pos_ecef_ins, lla_ins);
+      // Update the difference between calculated and predicted
+      y(0,0) = (float)(pos_ned_gps(0,0));
+      y(1,0) = (float)(pos_ned_gps(1,0));
+      y(2,0) = (float)(pos_ned_gps(2,0));
+      y(3,0) = (float)(V_gps(0,0) - V_ins(0,0));
+      y(4,0) = (float)(V_gps(1,0) - V_ins(1,0));
+      y(5,0) = (float)(V_gps(2,0) - V_ins(2,0));
+}
+
+void ekfNavINS::update15statesAfterKF() {
+      estmimated_ins = llarate ((x.block(0,0,3,1)).cast<double>(), lat_ins, alt_ins);
+      lat_ins += estmimated_ins(0,0);
+      lon_ins += estmimated_ins(1,0);
+      alt_ins += estmimated_ins(2,0);
+      vn_ins = vn_ins + x(3,0);
+      ve_ins = ve_ins + x(4,0);
+      vd_ins = vd_ins + x(5,0);
+      // Attitude correction
+      dq(0,0) = 1.0f;
+      dq(1,0) = x(6,0);
+      dq(2,0) = x(7,0);
+      dq(3,0) = x(8,0);
+      quat = qmult(quat,dq);
+      quat.normalize();
+      // obtain euler angles from quaternion
+      std::tie(phi, theta, psi) = toEulerAngles(quat);
+      abx = abx + x(9,0);
+      aby = aby + x(10,0);
+      abz = abz + x(11,0);
+      gbx = gbx + x(12,0);
+      gby = gby + x(13,0);
+      gbz = gbz + x(14,0);
+}
+
+void ekfNavINS::updateBias(float ax,float ay,float az,float p,float q, float r) {
+  f_b(0,0) = ax - abx;
+  f_b(1,0) = ay - aby;
+  f_b(2,0) = az - abz;
+  om_ib(0,0) = p - gbx;
+  om_ib(1,0) = q - gby;
+  om_ib(2,0) = r - gbz;
+}
+
+void ekfNavINS::updateProcessNoiseCovarianceTime(float _dt) {
+  PHI = Eigen::Matrix<float,15,15>::Identity()+Fs*_dt;
+  // Process Noise
+  Gs.setZero();
+  Gs.block(3,0,3,3) = -C_B2N;
+  Gs.block(6,3,3,3) = -0.5f*Eigen::Matrix<float,3,3>::Identity();
+  Gs.block(9,6,6,6) = Eigen::Matrix<float,6,6>::Identity();
+  // Discrete Process Noise
+  Q = PHI*_dt*Gs*Rw*Gs.transpose();
+  Q = 0.5f*(Q+Q.transpose());
+  // Covariance Time Update
+  P = PHI*P*PHI.transpose()+Q;
+  P = 0.5f*(P+P.transpose());
+}
+
+void ekfNavINS::updateJacobianMatrix() {
+    // Jacobian
+  Fs.setZero();
+  // ... pos2gs
+  Fs.block(0,3,3,3) = Eigen::Matrix<float,3,3>::Identity();
+  // ... gs2pos
+  Fs(5,2) = -2.0f*G/EARTH_RADIUS;
+  // ... gs2att
+  Fs.block(3,6,3,3) = -2.0f*C_B2N*sk(f_b);
+  // ... gs2acc
+  Fs.block(3,9,3,3) = -C_B2N;
+  // ... att2att
+  Fs.block(6,6,3,3) = -sk(om_ib);
+  // ... att2gyr
+  Fs.block(6,12,3,3) = -0.5f*Eigen::Matrix<float,3,3>::Identity();
+  // ... Accel Markov Bias
+  Fs.block(9,9,3,3) = -1.0f/TAU_A*Eigen::Matrix<float,3,3>::Identity();
+  Fs.block(12,12,3,3) = -1.0f/TAU_G*Eigen::Matrix<float,3,3>::Identity();
+}
+
+// This function gives a skew symmetric matrix from a given vector w
+Eigen::Matrix<float,3,3> ekfNavINS::sk(Eigen::Matrix<float,3,1> w) {
+  Eigen::Matrix<float,3,3> C;
+  C(0,0) = 0.0f;    C(0,1) = -w(2,0); C(0,2) = w(1,0);
+  C(1,0) = w(2,0);  C(1,1) = 0.0f;    C(1,2) = -w(0,0);
+  C(2,0) = -w(1,0); C(2,1) = w(0,0);  C(2,2) = 0.0f;
+  return C;
+}
+
+constexpr std::pair<double, double> ekfNavINS::earthradius(double lat) {
+  double denom = fabs(1.0 - (ECC2 * pow(sin(lat),2.0)));
+  double Rew = EARTH_RADIUS / sqrt(denom);
+  double Rns = EARTH_RADIUS * (1.0-ECC2) / (denom*sqrt(denom));
+  return (std::make_pair(Rew, Rns));
+}
+
+// This function calculates the rate of change of latitude, longitude, and altitude.
+Eigen::Matrix<double,3,1> ekfNavINS::llarate(Eigen::Matrix<double,3,1> V,Eigen::Matrix<double,3,1> lla) {
+  double Rew, Rns, denom;
+  Eigen::Matrix<double,3,1> lla_dot;
+  std::tie(Rew, Rns) = earthradius(lla(0,0));
+  lla_dot(0,0) = V(0,0)/(Rns + lla(2,0));
+  lla_dot(1,0) = V(1,0)/((Rew + lla(2,0))*cos(lla(0,0)));
+  lla_dot(2,0) = -V(2,0);
+  return lla_dot;
+}
+
+// This function calculates the rate of change of latitude, longitude, and altitude.
+Eigen::Matrix<double,3,1> ekfNavINS::llarate(Eigen::Matrix<double,3,1> V, double lat, double alt) {
+  Eigen::Matrix<double,3,1> lla;
+  lla(0,0) = lat;
+  lla(1,0) = 0.0; // Not used
+  lla(2,0) = alt;
+  return llarate(V, lla);
+}
+
+// This function calculates the ECEF Coordinate given the Latitude, Longitude and Altitude.
+Eigen::Matrix<double,3,1> ekfNavINS::lla2ecef(Eigen::Matrix<double,3,1> lla) {
+  double Rew, denom;
+  Eigen::Matrix<double,3,1> ecef;
+  std::tie(Rew, std::ignore) = earthradius(lla(0,0));
+  ecef(0,0) = (Rew + lla(2,0)) * cos(lla(0,0)) * cos(lla(1,0));
+  ecef(1,0) = (Rew + lla(2,0)) * cos(lla(0,0)) * sin(lla(1,0));
+  ecef(2,0) = (Rew * (1.0 - ECC2) + lla(2,0)) * sin(lla(0,0));
+  return ecef;
+}
+
+// This function converts a vector in ecef to ned coordinate centered at pos_ref.
+Eigen::Matrix<double,3,1> ekfNavINS::ecef2ned(Eigen::Matrix<double,3,1> ecef,Eigen::Matrix<double,3,1> pos_ref) {
+  Eigen::Matrix<double,3,1> ned;
+  ned(1,0)=-sin(pos_ref(1,0))*ecef(0,0) + cos(pos_ref(1,0))*ecef(1,0);
+  ned(0,0)=-sin(pos_ref(0,0))*cos(pos_ref(1,0))*ecef(0,0)-sin(pos_ref(0,0))*sin(pos_ref(1,0))*ecef(1,0)+cos(pos_ref(0,0))*ecef(2,0);
+  ned(2,0)=-cos(pos_ref(0,0))*cos(pos_ref(1,0))*ecef(0,0)-cos(pos_ref(0,0))*sin(pos_ref(1,0))*ecef(1,0)-sin(pos_ref(0,0))*ecef(2,0);
+  return ned;
+}
+
+// quaternion to dcm
+Eigen::Matrix<float,3,3> ekfNavINS::quat2dcm(Eigen::Matrix<float,4,1> q) {
+  Eigen::Matrix<float,3,3> C_N2B;
+  C_N2B(0,0) = 2.0f*powf(q(0,0),2.0f)-1.0f + 2.0f*powf(q(1,0),2.0f);
+  C_N2B(1,1) = 2.0f*powf(q(0,0),2.0f)-1.0f + 2.0f*powf(q(2,0),2.0f);
+  C_N2B(2,2) = 2.0f*powf(q(0,0),2.0f)-1.0f + 2.0f*powf(q(3,0),2.0f);
+
+  C_N2B(0,1) = 2.0f*q(1,0)*q(2,0) + 2.0f*q(0,0)*q(3,0);
+  C_N2B(0,2) = 2.0f*q(1,0)*q(3,0) - 2.0f*q(0,0)*q(2,0);
+
+  C_N2B(1,0) = 2.0f*q(1,0)*q(2,0) - 2.0f*q(0,0)*q(3,0);
+  C_N2B(1,2) = 2.0f*q(2,0)*q(3,0) + 2.0f*q(0,0)*q(1,0);
+
+  C_N2B(2,0) = 2.0f*q(1,0)*q(3,0) + 2.0f*q(0,0)*q(2,0);
+  C_N2B(2,1) = 2.0f*q(2,0)*q(3,0) - 2.0f*q(0,0)*q(1,0);
+  return C_N2B;
+}
+
+// quaternion multiplication
+Eigen::Matrix<float,4,1> ekfNavINS::qmult(Eigen::Matrix<float,4,1> p, Eigen::Matrix<float,4,1> q) {
+  Eigen::Matrix<float,4,1> r;
+  r(0,0) = p(0,0)*q(0,0) - (p(1,0)*q(1,0) + p(2,0)*q(2,0) + p(3,0)*q(3,0));
+  r(1,0) = p(0,0)*q(1,0) + q(0,0)*p(1,0) + p(2,0)*q(3,0) - p(3,0)*q(2,0);
+  r(2,0) = p(0,0)*q(2,0) + q(0,0)*p(2,0) + p(3,0)*q(1,0) - p(1,0)*q(3,0);
+  r(3,0) = p(0,0)*q(3,0) + q(0,0)*p(3,0) + p(1,0)*q(2,0) - p(2,0)*q(1,0);
+  return r;
+}
+
+// bound angle between -180 and 180
+float ekfNavINS::constrainAngle180(float dta) {
+  if(dta >  M_PI) dta -= (M_PI*2.0f);
+  if(dta < -M_PI) dta += (M_PI*2.0f);
+  return dta;
+}
+
+// bound angle between 0 and 360
+float ekfNavINS::constrainAngle360(float dta){
+  dta = fmod(dta,2.0f*M_PI);
+  if (dta < 0)
+    dta += 2.0f*M_PI;
+  return dta;
+}
+
+Eigen::Matrix<float,4,1> ekfNavINS::toQuaternion(float yaw, float pitch, float roll) {
+    float cy = cosf(yaw * 0.5f);
+    float sy = sinf(yaw * 0.5f);
+    float cp = cosf(pitch * 0.5f);
+    float sp = sinf(pitch * 0.5f);
+    float cr = cosf(roll * 0.5f);
+    float sr = sinf(roll * 0.5f);
+    Eigen::Matrix<float,4,1> q;
+    q(0) = cr * cp * cy + sr * sp * sy; // w
+    q(1) = cr * cp * sy - sr * sp * cy; // x
+    q(2) = cr * sp * cy + sr * cp * sy; // y
+    q(3) = sr * cp * cy - cr * sp * sy; // z
+    return q;
+}
+
+std::tuple<float, float, float> ekfNavINS::toEulerAngles(Eigen::Matrix<float,4,1> quat) {
+    float roll, pitch, yaw;
+    // roll (x-axis rotation)
+    float sinr_cosp = 2.0f * (quat(0,0)*quat(1,0)+quat(2,0)*quat(3,0));
+    float cosr_cosp = 1.0f - 2.0f * (quat(1,0)*quat(1,0)+quat(2,0)*quat(2,0));
+    roll = atan2f(sinr_cosp, cosr_cosp);
+    // pitch (y-axis rotation)
+    double sinp = 2.0f * (quat(0,0)*quat(2,0) - quat(1,0)*quat(3,0));
+    //angles.pitch = asinf(-2.0f*(quat(1,0)*quat(3,0)-quat(0,0)*quat(2,0)));
+    if (std::abs(sinp) >= 1)
+        pitch = std::copysign(M_PI / 2.0f, sinp); // use 90 degrees if out of range
+    else
+        pitch = asinf(sinp);
+    // yaw (z-axis rotation)
+    float siny_cosp = 2.0f * (quat(1,0)*quat(2,0)+quat(0,0)*quat(3,0));
+    float cosy_cosp = 1.0f - 2.0f * (quat(2,0)*quat(2,0)+quat(3,0)*quat(3,0));
+    yaw = atan2f(siny_cosp, cosy_cosp);
+    return std::make_tuple(roll, pitch, yaw);
+}
+
diff --git a/Ublox_Linux_Library/src/Print.cpp b/EKF_Linux_Library/src/Print.cpp
similarity index 99%
rename from Ublox_Linux_Library/src/Print.cpp
rename to EKF_Linux_Library/src/Print.cpp
index bc33ee1..288d9bd 100644
--- a/Ublox_Linux_Library/src/Print.cpp
+++ b/EKF_Linux_Library/src/Print.cpp
@@ -24,9 +24,6 @@
 #include <stdio.h>
 #include <string.h>
 #include <math.h>
-/*
-#include "Arduino.h"
-*/
 #include "Print.h"
 
 // Public Methods //////////////////////////////////////////////////////////////
diff --git a/Ublox_Linux_Library/src/Utils.cpp b/EKF_Linux_Library/src/Utils.cpp
similarity index 100%
rename from Ublox_Linux_Library/src/Utils.cpp
rename to EKF_Linux_Library/src/Utils.cpp
diff --git a/Ublox_Linux_Library/README.md b/Ublox_Linux_Library/README.md
deleted file mode 100644
index 9e741f2..0000000
--- a/Ublox_Linux_Library/README.md
+++ /dev/null
@@ -1,33 +0,0 @@
-# Ublox_Linux_Library
-The aim of this repository to port the SparkFun_u-blox_GNSS_Arduino_Library to linux platform.
-
-## How to pull the code
-* git clone https://github.com/balamuruganky/Ublox_Linux_Library
-* cd Ublox_Linux_Library
-* git submodule update --init
-
-## How to compile Linux Library (Assumed that CMake setup done already)
-* cd linux_build
-* mkdir build
-* cd build
-* cmake ..
-* make
-
-## How to compile Android Library (Assumed that NDK setup done already)
-* cd android_build
-* ndk-build -j2 NDK_PROJECT_PATH=. APP_BUILD_SCRIPT=./Android.mk NDK_APPLICATION_MK=./Application.mk
-
-## How to execute test
-* cd ../bin (Assuming the current directorty is build directory, created above)
-* ./ublox_f9p_test /dev/ttyACM0
-* ./ublox_f9p_i2c_test /dev/ublox_i2c 0x42 (or without command line arguments)
-
-## License
-This repository consists files from different other repositories such as Arduino and SparkFun_u-blox_GNSS_Arduino_Library. Please consider the licenses according to the files where it is from.
-
-## Linux Examples
-Feel free to port the examples from Sparkfun_Ublox_Arduino_Library to linux.
-
-## Future Work
-Port some important examples from Arduino to Linux
-
diff --git a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/CONTRIBUTING.md b/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/CONTRIBUTING.md
deleted file mode 100644
index f874edd..0000000
--- a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/CONTRIBUTING.md
+++ /dev/null
@@ -1,20 +0,0 @@
-# How to Contribute
-
-Thank you so *much* for offering to help out. We truly appreciate it.
-
-If you'd like to contribute, start by searching through the [issues](https://github.com/sparkfun/SparkFun_u-blox_GNSS_Arduino_Library/issues) and [pull requests](https://github.com/sparkfun/SparkFun_u-blox_GNSS_Arduino_Library/pulls) to see whether someone else has raised a similar idea or question.
-Please check the [closed issues](https://github.com/sparkfun/SparkFun_u-blox_GNSS_Arduino_Library/issues?q=is%3Aissue+is%3Aclosed)
-and [closed pull requests](https://github.com/sparkfun/SparkFun_u-blox_GNSS_Arduino_Library/pulls?q=is%3Apr+is%3Aclosed) too - you may find that your issue or feature has already been discussed.
-
-If you decide to add a feature to this library, please create a PR and follow these best practices:
-
-* Change as little as possible. Do not submit a PR that changes 100 lines of whitespace. Break up into multiple PRs if necessary.
-* If you've added a new feature document it with a simple example sketch. This serves both as a test of your PR and as a quick way for users to quickly learn how to use your new feature.
-* If you add new functions also add them to _keywords.txt_ so that they are properly highlighted in Arduino. [Read more](https://www.arduino.cc/en/Hacking/libraryTutorial).
-* **Important:** Please submit your PR using the [release_candidate branch](https://github.com/sparkfun/SparkFun_u-blox_GNSS_Arduino_Library/tree/release_candidate). That way, we can merge and test your PR quickly without changing the _master_ branch
-
-![Contributing.JPG](./img/Contributing.JPG)
-
-## Style guide
-
-Please read and follow the [Arduino API style guide](https://www.arduino.cc/en/Reference/APIStyleGuide). Also read and consider the [Arduino style guide](https://www.arduino.cc/en/Reference/StyleGuide).
diff --git a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/ISSUE_TEMPLATE.md b/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/ISSUE_TEMPLATE.md
deleted file mode 100644
index 84ae55b..0000000
--- a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/ISSUE_TEMPLATE.md
+++ /dev/null
@@ -1,18 +0,0 @@
-### Subject of the issue
-Describe your issue here. If you reference a datasheet please specify which one and in which section (ie, the protocol manual, section 5.1.2). Additionally, screenshots are easy to paste into github.
-
-### Your workbench
-* What development board or microcontroller are you using?
-* What version of hardware or breakout board are you using? 
-* How is the breakout board wired to your microcontroller?
-* How is everything being powered?
-* Are there any additional details that may help us help you?
-
-### Steps to reproduce
-Tell us how to reproduce this issue. Please post stripped down example code demonstrating your issue.
-
-### Expected behavior
-Tell us what should happen
-
-### Actual behavior
-Tell us what happens instead
diff --git a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/LICENSE.md b/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/LICENSE.md
deleted file mode 100644
index e64bd4e..0000000
--- a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/LICENSE.md
+++ /dev/null
@@ -1,55 +0,0 @@
-SparkFun License Information
-============================
-
-SparkFun uses two different licenses for our files — one for hardware and one for code.
-
-Hardware
----------
-
-**SparkFun hardware is released under [Creative Commons Share-alike 4.0 International](http://creativecommons.org/licenses/by-sa/4.0/).**
-
-Note: This is a human-readable summary of (and not a substitute for) the [license](http://creativecommons.org/licenses/by-sa/4.0/legalcode).
-
-You are free to:
-
-Share — copy and redistribute the material in any medium or format
-Adapt — remix, transform, and build upon the material
-for any purpose, even commercially.
-The licensor cannot revoke these freedoms as long as you follow the license terms.
-Under the following terms:
-
-Attribution — You must give appropriate credit, provide a link to the license, and indicate if changes were made. You may do so in any reasonable manner, but not in any way that suggests the licensor endorses you or your use.
-ShareAlike — If you remix, transform, or build upon the material, you must distribute your contributions under the same license as the original.
-No additional restrictions — You may not apply legal terms or technological measures that legally restrict others from doing anything the license permits.
-Notices:
-
-You do not have to comply with the license for elements of the material in the public domain or where your use is permitted by an applicable exception or limitation.
-No warranties are given. The license may not give you all of the permissions necessary for your intended use. For example, other rights such as publicity, privacy, or moral rights may limit how you use the material.
-
-
-Code
---------
-
-**SparkFun code, firmware, and software is released under the MIT License(http://opensource.org/licenses/MIT).**
-
-The MIT License (MIT)
-
-Copyright (c) 2016 SparkFun Electronics
-
-Permission is hereby granted, free of charge, to any person obtaining a copy
-of this software and associated documentation files (the "Software"), to deal
-in the Software without restriction, including without limitation the rights
-to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-copies of the Software, and to permit persons to whom the Software is
-furnished to do so, subject to the following conditions:
-
-The above copyright notice and this permission notice shall be included in all
-copies or substantial portions of the Software.
-
-THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
-SOFTWARE.
diff --git a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/README.md b/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/README.md
deleted file mode 100644
index 1eb267f..0000000
--- a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/README.md
+++ /dev/null
@@ -1,107 +0,0 @@
-# SparkFun u-blox Arduino GNSS Library
-
-<table class="table table-hover table-striped table-bordered">
-  <tr align="center">
-   <td><a href="https://www.sparkfun.com/products/15136"><img src="https://cdn.sparkfun.com//assets/parts/1/3/5/1/4/15136-SparkFun_GPS-RTK2_Board_-_ZED-F9P__Qwiic_-03.jpg"></a></td>
-   <td><a href="https://www.sparkfun.com/products/15005"><img src="https://cdn.sparkfun.com//assets/parts/1/3/3/2/0/15005-SparkFun_GPS-RTK__Qwiic__-_NEO-M8P-2-00.jpg"></a></td>
-   <td><a href="https://www.sparkfun.com/products/15193"><img src="https://cdn.sparkfun.com//assets/parts/1/3/6/1/4/15193-SparkFun_GPS_Breakout_-_U.FL__ZOE-M8__Qwiic_-01.jpg"></a></td>
-   <td><a href="https://www.sparkfun.com/products/15210"><img src="https://cdn.sparkfun.com//assets/parts/1/3/6/4/8/15210-SparkFun_GPS_Breakout_-_Chip_Antenna__SAM-M8Q__Qwiic_-01.jpg"></a></td>
-    <td><a href="https://www.sparkfun.com/products/15733"><img src="https://cdn.sparkfun.com//assets/parts/1/4/3/2/2/15733-SparkFun_GPS_Breakout_-_NEO-M9N__Chip_Antenna__Qwiic_-01.jpg"></a></td>
-  </tr>
-  <tr align="center">
-    <td><a href="https://www.sparkfun.com/products/15136">SparkFun GPS-RTK2 - ZED-F9P (GPS-15136)</a></td>
-    <td><a href="https://www.sparkfun.com/products/15005">SparkFun GPS-RTK - NEO-M8P-2 (GPS-15005)</a></td>
-    <td><a href="https://www.sparkfun.com/products/15193">SparkFun ZOE-M8Q Breakout (GPS-15193)</a></td>
-    <td><a href="https://www.sparkfun.com/products/15210">SparkFun SAM-M8Q Breakout (GPS-15210)</a></td>
-    <td><a href="https://www.sparkfun.com/products/15733">SparkFun NEO-M9N Breakout (GPS-15733)</a></td>
-  </tr>
-</table>
-
-u-blox makes some incredible GNSS receivers covering everything from low-cost, highly configurable modules such as the SAM-M8Q all the way up to the surveyor grade ZED-F9P with precision of the diameter of a dime. This library focuses on configuration and control of u-blox devices over I<sup>2</sup>C (called DDC by u-blox) and Serial. The UBX protocol is supported over both I<sup>2</sup>C and serial, and is a much easier and lighterweight interface to a GNSS module. Stop polling messages and parsing NMEA data! Simply ask for the datums you need and receive an automatic callback when they arrive.
-
-This library can be installed via the Arduino Library manager. Search for **SparkFun u-blox GNSS**.
-
-## v2.0
-
-This library is the new and improved version of the very popular SparkFun u-blox GNSS Arduino Library. v2.0 contains some big changes and improvements:
-
-* Seamless support for "automatic" message delivery:
-  * In v1.8, you could ask for the NAV PVT (Navigation Position Velocity Time) message to be delivered _automatically_, without polling. v2.0 adds automatic support for [**23 messages**](./Theory.md#auto-messages), covering the full range of: standard and High Precision position, velocity and time information; relative positioning; event capture with nanosecond time resolution; raw GNSS signal data including carrier phase; Sensor Fusion; and High Navigation Rate data.
-* Dynamic memory allocation with clearly-defined data storage structs for each message:
-  * There are no static 'global' variables to eat up your RAM. v2.0 automatically allocates memory for the automatic messages when they are enabled. You may find your total RAM use is lower with v2.0 than with v1.8.
-  * Each "auto" message has a clearly-defined [data storage struct](./src/u-blox_structs.h) which follows the u-blox protocol specification precisely.
-* Callbacks:
-  * No more polling! Simply request the "auto" messages you need and receive an automatic callback when each message arrives.
-  * Please see the [callback examples](./examples/Callbacks) for more details.
-* Built-in support for data logging:
-  * Want to log RXM SFRBX and RAWX data for Post-Processed Kinematics or Precise Point Positioning? You can absolutely do that! v2.0 provides built-in support for data logging, allowing you to log **any** of the "auto" messages simply and easily.
-  * Incoming "auto" data can be stored in a configurable ring buffer. You can then extract the data from the buffer and write it to (e.g.) SD card using your favorite SD library.
-  * Data is logged in u-blox UBX format which is compact and efficient. You can replay the data using [u-center](https://www.u-blox.com/en/product/u-center).
-  * Please see the [data logging examples](./examples/Data_Logging) for more details.
-
-## Migrating to v2.0
-
-Migrating to v2.0 is easy. There are two small changes all users will need to make:
-
-* The name of the library class has changed from ```SFE_UBLOX_GPS``` to ```SFE_UBLOX_GNSS``` to reflect that the library supports all of the Global Navigation Satellite Systems:
-  * As a minimum, you need to change: ```SFE_UBLOX_GPS myGPS;```
-  * to: ```SFE_UBLOX_GNSS myGPS;```
-  * But we would encourage you to use ```SFE_UBLOX_GNSS myGNSS;```. You will see that all of the library examples now use ```myGNSS``` instead of ```myGPS```.
-* The name of the library header and C++ files have changed too:
-  * Change: ```#include <SparkFun_Ublox_Arduino_Library.h>```
-  * to: ```#include <SparkFun_u-blox_GNSS_Arduino_Library.h>```
-
-If you are using the Dead Reckoning Sensor Fusion or High Dynamic Rate messages, you will need to make more small changes to your code. Please see the [dead reckoning examples](./examples/Dead_Reckoning) for more details. There is more detail available in [Theory.md](./Theory.md#migrating-your-code-to-v20) if you need it.
-
-## Max (400kHz) I<sup>2</sup>C Support
-
-To achieve 400kHz I<sup>2</sup>C speed please be sure to remove all pull-ups on the I<sup>2</sup>C bus. Most, if not all, u-blox modules include internal pull ups on the I<sup>2</sup>C lines (sometimes called DDC in their manuals). Cut all I<sup>2</sup>C pull up jumpers and/or remove them from peripheral boards. Otherwise, various data glitches can occur. See issues [38](https://github.com/sparkfun/SparkFun_Ublox_Arduino_Library/issues/38) and [40](https://github.com/sparkfun/SparkFun_Ublox_Arduino_Library/issues/40) for more information. If possible, run the I<sup>2</sup>C bus at 100kHz.
-
-## Contributing
-
-If you would like to contribute to this library: please do, we truly appreciate it, but please follow [these guidelines](./CONTRIBUTING.md). Thanks!
-
-## Repository Contents
-
-* [**/examples**](./examples) - Example sketches for the library (.ino). Run these from the Arduino IDE.
-* [**/src**](./src) - Source files for the library (.cpp, .h).
-* [**keywords.txt**](./keywords.txt) - Keywords from this library that will be highlighted in the Arduino IDE.
-* [**library.properties**](./library.properties) - General library properties for the Arduino package manager.
-* [**CONTRIBUTING.md**](./CONTRIBUTING.md) - Guidelines on how to contribute to this library.
-* [**Theory.md**](./Theory.md) - provides detail on how data is processed by the library.
-* [**/Utils**](./Utils) - contains a Python utility which can check the contents of UBX log files.
-
-## Documentation
-
-* [**Installing an Arduino Library Guide**](https://learn.sparkfun.com/tutorials/installing-an-arduino-library) - Basic information on how to install an Arduino library.
-
-## Theory
-
-If you would like to learn more about how this library works, including the big changes we made in version 2.0, please see [**Theory.md**](./Theory.md) for full details.
-
-## Products That Use This Library
-
-* [GPS-16481](https://www.sparkfun.com/products/16481) - SparkFun GPS-RTK-SMA Breakout - ZED-F9P (Qwiic)
-* [GPS-15136](https://www.sparkfun.com/products/15136) - SparkFun GPS-RTK2 Board - ZED-F9P (Qwiic)
-* [GPS-16344](https://www.sparkfun.com/products/16344) - SparkFun GPS-RTK Dead Reckoning Breakout - ZED-F9R (Qwiic)
-* [GPS-15005](https://www.sparkfun.com/products/15005) - SparkFun GPS-RTK Board - NEO-M8P-2 (Qwiic)
-* [GPS-15210](https://www.sparkfun.com/products/15210) - SparkFun GPS Breakout - Chip Antenna, SAM-M8Q (Qwiic)
-* [GPS-15193](https://www.sparkfun.com/products/15193) - SparkFun GPS Breakout - Chip Antenna, ZOE-M8Q (Qwiic)
-* [GPS-17285](https://www.sparkfun.com/products/17285) - SparkFun GPS Breakout - NEO-M9N, SMA (Qwiic)
-* [GPS-15733](https://www.sparkfun.com/products/15733) - SparkFun GPS Breakout - NEO-M9N, Chip Antenna (Qwiic)
-* [GPS-15712](https://www.sparkfun.com/products/15712) - SparkFun GPS Breakout - NEO-M9N, U.FL (Qwiic)
-* [GPS-16329](https://www.sparkfun.com/products/16329) - SparkFun GPS Dead Reckoning Breakout - NEO-M8U (Qwiic)
-* [SPX-14980](https://www.sparkfun.com/products/14980) - SparkX GPS-RTK Black
-* [SPX-15106](https://www.sparkfun.com/products/15106) - SparkX SAM-M8Q
-
-## License Information
-
-This product is _**open source**_!
-
-Various bits of the code have different licenses applied. Anything SparkFun wrote is beerware; if you see me (or any other SparkFun employee) at the local, and you've found our code helpful, please buy us a round!
-
-Please use, reuse, and modify these files as you see fit. Please maintain attribution to SparkFun Electronics and release anything derivative under the same license.
-
-Distributed as-is; no warranty is given.
-
-- Your friends at SparkFun.
diff --git a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/Theory.md b/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/Theory.md
deleted file mode 100644
index eb8bdd3..0000000
--- a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/Theory.md
+++ /dev/null
@@ -1,127 +0,0 @@
-## How I<sup>2</sup>C (aka DDC) communication works with a u-blox module
-
-When the user calls one of the methods the library will poll the u-blox module for new data.
-
-* Wait for a minimum of 25 ms between polls (configured dynamically when update rate is set)
-* Write 0xFD to module
-* Read two bytes (0xFD and 0xFE) for bytes available
-* If 0x7F or 0xFF then no bytes are available
-* Otherwise, read number of bytes and process into NMEA, UBX, or RTCM frame.
-* If checksum is valid, flag frame as complete.
-
-This library was originally written to use the I<sup>2</sup>C interface but Serial has been implemented as well.
-
-## How data is processed by this library
-
-In Version 1 of this library, we tried to minimize memory usage by being very careful about how much RAM we allocated to UBX packet storage and processing. We used only three buffers or containers to store the incoming data: **packetBuf** (packetBuffer); **packetCfg** (packetConfiguration); and **packetAck** (packetAcknowledge). Incoming packets were stored in **packetBuf** initially and then diverted into **packetAck** or **packetCfg** as necessary. Once data was received and validated, it would be copied out of **packetCfg** and into 'global' variables with names like ```gpsSecond``` or ```latitude```. We also introduced the concept of _Polling vs. Auto-Reporting_ where messages like PVT (Position, Velocity, Time) could be generated and parsed "automatically". This meant that functions like ```getLatitude``` could be non-blocking, returning the most recent data and requesting fresh data when necessary. But it also meant that _polled_ messages could be _overwritten_ (in **packetCfg**) by any _auto-reported_ messages. The library dealt with this successfully, but it was a headache.
-
-Version 1 had two main drawbacks. As time went on:
-- the RAM use increased as we had to add new 'global' storage for each new data type
-- the number of messages which needed "auto" processing through **packetCfg** became complex, requiring significant code changes each time a new "auto" message was added. (We started with NAV-PVT. Then came NAV-HPPOSLLH and NAV-DOP. Things got complicated when HNR-ATT, HNR-INS and HNR-PVT were added to the mix.)
-
-Version 2 of the library does things differently. Whilst of course trying to keep the library backward-compatible as much as possible, we have taken a fresh approach:
-- We have added **packetAuto** which is used to temporarily buffer expected auto-reported messages and prevents data from being overwritten in **packetCfg**.
-  - The payload for **packetAuto** is allocated dynamically in RAM and deleted after use.
-  - If insufficient RAM is available, the code falls back to using **packetCfg** to buffer the data instead.
-- The library no longer uses 'global' (permanently-allocated) storage for the GNSS data. Instead:
-  - Each message type has a **typedef struct** defined which matches the format of the UBX message. (_typedef structs_ are just definitions, they don't occupy memory.) You can find the definitions in [_**u-blox_structs.h**_](./src/u-blox_structs.h).
-  - The struct allows each data field (latitude, longitude, etc.) to be read simply and easily using dot notation. Flags etc. are supported by bit definitions in the struct. The field names are as defined in the u-blox interface description.
-  - Storage for that message is only _allocated_ in RAM if/when required. The allocation is done using _new_ via a pointer to the struct.
-- _Any_ message can be "auto" if required, but can be polled too.
-- An optional _callback_ can be associated with the arrival of each message type. A simple scheduler ```checkCallbacks``` triggers the callbacks once I<sup>2</sup>C/Serial data reception is complete.
-  - This means that your code no longer needs to wait for the arrival of a message, you are able to request (e.g.) PVT or HNR data and your callback is called once the data arrives.
-  - The callbacks are not re-entrant.
-  - The callback receives a _copy_ of the data, so data reception and processing can continue while the callback is executing. Data integrity is preserved. You can call ```checkUblox()``` from inside a callback if needed.
-- Incoming data can be copied to a separate buffer to allow automatic writing to a file on SD card, which will be useful for (e.g.) RAWX logging.
-  - Data is stored in a RingBuffer, the size of which can be set by calling ```setFileBufferSize``` _before_ ```.begin```.
-  - The default buffer size is zero - to save memory.
-  - To simplify SD card writing, data can be copied from the RingBuffer to a user-defined linear buffer first using ```extractFileBufferData```.
-  - Data reception and processing can continue during the SD write.
-  - User-defined code does the actual writing of data from the linear buffer to the SD card. The u-blox GNSS library itself does not perform the writing and so is not tied to any particular SD library.
-  - The logged files can be played back and analyzed with (e.g.) u-center or RTKLIB.
-
-In terms of RAM, you may find that your total RAM use is lower using v2 compared to v1, but it does of course depend on how many message types are being processed. The downside to this is that it is difficult to know in advance how much RAM is required, since it is only allocated if/when required. If the processor runs out of RAM (i.e. the _new_ fails) then a debug error message is generated.
-
-## "Auto" messages
-
-In v2.0, the full list of messages which can be processed and logged automatically is:
-- UBX-NAV-POSECEF (0x01 0x01): Position solution in ECEF
-- UBX-NAV-STATUS (0x01 0x03): Receiver navigation status
-- UBX-NAV-DOP (0x01 0x04): Dilution of precision
-- UBX-NAV-ATT (0x01 0x05): Attitude solution (**only with ADR or UDR products**)
-- UBX-NAV-PVT (0x01 0x07): Navigation position velocity time solution
-- UBX-NAV-ODO (0x01 0x09): Odometer solution
-- UBX-NAV-VELECEF (0x01 0x11): Velocity solution in ECEF
-- UBX-NAV-VELNED (0x01 0x12): Velocity solution in NED frame
-- UBX-NAV-HPPOSECEF (0x01 0x13): High precision position solution in ECEF
-- UBX-NAV-HPPOSLLH (0x01 0x14): High precision geodetic position solution
-- UBX-NAV-CLOCK (0x01 0x22): Clock solution
-- UBX-NAV-SVIN (0x01 0x3B): Survey-in data (**only with High Precision GNSS products**)
-- UBX-NAV-RELPOSNED (0x01 0x3C): Relative positioning information in NED frame (**only with High Precision GNSS products**)
-- UBX-RXM-SFRBX (0x02 0x13): Broadcast navigation data subframe
-- UBX-RXM-RAWX (0x02 0x15): Multi-GNSS raw measurement data (**only with ADR or High Precision GNSS or Time Sync products**)
-- UBX-TIM-TM2 (0x0D 0x03): Time mark data
-- UBX-ESF-ALG (0x10 0x14): IMU alignment information (**only with ADR or UDR products**)
-- UBX-ESF-INS (0x10 0x15): Vehicle dynamics information (**only with ADR or UDR products**)
-- UBX-ESF-MEAS (0x10 0x02): External sensor fusion measurements (**only with ADR or UDR products**)
-- UBX-ESF-RAW (0x10 0x03): Raw sensor measurements (**only with ADR or UDR products**)
-- UBX-ESF-STATUS (0x10 0x10): External sensor fusion status (**only with ADR or UDR products**)
-- UBX-HNR-PVT (0x28 0x00): High rate output of PVT solution (**only with ADR or UDR products**)
-- UBX-HNR-ATT (0x28 0x01): Attitude solution (**only with ADR or UDR products**)
-- UBX-HNR-INS (0x28 0x02): Vehicle dynamics information (**only with ADR or UDR products**)
-
-Notes:
-- UBX-NAV-POSLLH is not supported as UBX-NAV-PVT contains the same information
-- UBX-NAV-TIMEUTC is not supported as UBX-NAV-PVT contains the same information
-
-## Migrating your code to v2.0
-
-Migrating to v2.0 is easy. There are two small changes all users will need to make:
-
-* The name of the library class has changed from ```SFE_UBLOX_GPS``` to ```SFE_UBLOX_GNSS``` to reflect that the library supports all of the Global Navigation Satellite Systems:
-  * As a minimum, you need to change: ```SFE_UBLOX_GPS myGPS;```
-  * to: ```SFE_UBLOX_GNSS myGPS;```
-  * But we would encourage you to use ```SFE_UBLOX_GNSS myGNSS;```. You will see that all of the library examples now use ```myGNSS``` instead of ```myGPS```.
-* The name of the library header and C++ files have changed too:
-  * Change: ```#include <SparkFun_Ublox_Arduino_Library.h>```
-  * to: ```#include <SparkFun_u-blox_GNSS_Arduino_Library.h>```
-
-The biggest change in v2.0 is that data is now stored in a _struct_ which matches the u-blox interface description for that message. For example:
-- In v1, the NAV PVT (Position Velocity Time) latitude and longitude were stored in 'global' _int32_t_ variables called ```latitude``` and ```longitude```
-  - In v2.0, the data is now stored in <strong>UBX_NAV_PVT_t *packetUBXNAVPVT</strong>
-  - ```myGPS.latitude``` becomes ```myGNSS.packetUBXNAVPVT->data.lat```
-  - ```myGPS.longitude``` becomes ```myGNSS.packetUBXNAVPVT->data.lon```
-  - The helper functions ```myGNSS.getLatitude()``` and ```myGNSS.getLongitude()``` are still available and work in the same way.
-- In v1, the ESF Sensor Fusion data for the Dead Reckoning modules was stored in 'global' variables ```imuMeas```, ```ubloxSen``` and ```vehAtt```
-  - In v2.0, the data is now stored in:
-  - <strong>UBX_ESF_ALG_t *packetUBXESFALG</strong> contains the IMU alignment information (roll, pitch and yaw)
-  - <strong>UBX_ESF_INS_t *packetUBXESFINS</strong> contains the vehicle dynamics information (acceleration and angular rate)
-  - <strong>UBX_ESF_MEAS_t *packetUBXESFMEAS</strong> contains the sensor fusion measurements
-  - <strong>UBX_ESF_RAW_t *packetUBXESFRAW</strong> contains the raw sensor measurements
-  - <strong>UBX_ESF_STATUS_t *packetUBXESFSTATUS</strong> contains the sensor fusion status
-  - e.g. ```myGPS.imuMeas.fusionMode``` becomes ```myGNSS.packetUBXESFSTATUS->data.fusionMode```
-  - The helper functions ```getSensorFusionMeasurement```, ```getRawSensorMeasurement``` and ```getSensorFusionStatus``` can be used to extract the sensor data for an individual sensor
-  - "auto" data can be marked as stale by calling (e.g.) ```myGNSS.flushESFALG()```
-  - Please see the [**Dead_Reckoning/Example4_vehicleDynamics**](./examples/Dead_Reckoning/Example4_vehicleDynamics/Example4_vehicleDynamics.ino) example for more details
-- In v1, the HNR (High Navigation Rate) data for the Dead Reckoning modules was stored in 'global' variables ```hnrAtt```, ```hnrVehDyn``` and ```hnrPVT```
-  - In v2.0, e.g.:
-  - ```myGPS.hnrAtt.roll``` becomes ```myGNSS.packetUBXHNRATT->data.roll```
-  - ```myGPS.hnrVehDyn.xAccel``` becomes ```myGNSS.packetUBXHNRINS->data.xAccel```
-  - ```myGPS.hnrPVT.lat``` becomes ```myGNSS.packetUBXHNRPVT->data.lat```
-  - "auto" data can be marked as stale by calling (e.g.) ```myGNSS.flushHNRATT()```
-  - Please see the [**Dead_Reckoning/Example6_getAutoHNRData**](./examples/Dead_Reckoning/Example6_getAutoHNRData/Example6_getAutoHNRData.ino) example for more details
-
-Other changes include:
-- In v1, NAV_RELPOSNED relPosN, relPosE and relPosD were returned as (float)m. In v2.0 they are returned via <strong>packetUBXNAVRELPOSNED->data.relPosN</strong> (etc.) as (int32_t)cm.
-  - New helper functions (```getRelPosN```, ```getRelPosE``` and ```getRelPosD```) provide backward-compatibility
-  - Please see the [**ZED-F9P/Example5_RelativePositioningInformation**](./examples/ZED-F9P/Example5_RelativePositioningInformation/Example5_RelativePositioningInformation.ino) example for more details
-- In v1, NAV_RELPOSNED accN, accE and accD were returned as (float)m. In v2.0 they are returned via <strong>packetUBXNAVRELPOSNED->data.accN</strong> (etc.) as (uint32_t)mm*0.1.
-  - New helper functions (```getRelPosAccN```, ```getRelPosAccE``` and ```getRelPosAccD```) provide backward-compatibility
-  - Please see the [**ZED-F9P/Example5_RelativePositioningInformation**](./examples/ZED-F9P/Example5_RelativePositioningInformation/Example5_RelativePositioningInformation.ino) example for more details
-- getSurveyStatus now returns data via <strong>UBX_NAV_SVIN_t *packetUBXNAVSVIN</strong>
-  - ```myGPS.svin.active``` becomes ```myGNSS.packetUBXNAVSVIN->data.active```
-  - ```myGPS.svin.valid``` becomes ```myGNSS.packetUBXNAVSVIN->data.valid```
-  - ```myGPS.svin.observationTime``` becomes ```myGNSS.packetUBXNAVSVIN->data.dur``` and is now uint32_t (not uint16_t)
-  - ```myGPS.svin.MeanAccuracy``` becomes ```myGNSS.packetUBXNAVSVIN->data.meanAcc``` and is now uint32_t * 0.1mm (not float * m)
-  - New helper functions (```getSurveyInActive```, ```getSurveyInValid```, ```getSurveyInObservationTime``` and ```getSurveyInMeanAccuracy```) provide backward-compatibility
-  - Please see the [**ZED-F9P/Example3_StartRTCMBase**](./examples/ZED-F9P/Example3_StartRTCMBase/Example3_StartRTCMBase.ino) example for more details
diff --git a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/Utils/UBX_Integrity_Checker.py b/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/Utils/UBX_Integrity_Checker.py
deleted file mode 100644
index 2fac318..0000000
--- a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/Utils/UBX_Integrity_Checker.py
+++ /dev/null
@@ -1,399 +0,0 @@
-# Checks the integrity of u-blox binary files
-
-# Written by: Paul Clark
-# Last update: August 26th 2020
-
-# Reads a UBX file and checks the integrity of both UBX and NMEA data
-# Will rewind and re-sync if an error is found
-
-# SparkFun code, firmware, and software is released under the MIT License (http://opensource.org/licenses/MIT)
-#
-# The MIT License (MIT)
-#
-# Copyright (c) 2020 SparkFun Electronics
-#
-# Permission is hereby granted, free of charge, to any person obtaining a copy
-# of this software and associated documentation files (the "Software"), to deal
-# in the Software without restriction, including without limitation the rights
-# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-# copies of the Software, and to permit persons to whom the Software is
-# furnished to do so, subject to the following conditions:
-#
-# The above copyright notice and this permission notice shall be included in all
-# copies or substantial portions of the Software.
-#
-# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
-# SOFTWARE.
-
-import sys
-import os
-
-# Add byte to checksums sum1 and sum2
-def csum(byte, sum1, sum2):
-    sum1 = sum1 + byte
-    sum2 = sum2 + sum1
-    sum1 = sum1 & 0xFF
-    sum2 = sum2 & 0xFF
-    return sum1,sum2
-
-print('UBX Integrity Checker')
-print()
-
-filename = ''
-
-if filename == '':
-    # Check if the bin filename was passed in argv
-    if len(sys.argv) > 1: filename = sys.argv[1]
-
-# Find first .ubx file in the current directory
-firstfile = ''
-for root, dirs, files in os.walk("."):
-    if len(files) > 0:
-        if root == ".": # Comment this line to check sub-directories too
-            for afile in files:
-                if afile[-4:] == '.ubx':
-                    if firstfile == '': firstfile = os.path.join(root, afile)
-
-# Ask user for .bin filename offering firstfile as the default
-if filename == '': filename = input('Enter the UBX filename (default: ' + firstfile + '): ') # Get the filename
-if filename == '': filename = firstfile
-
-# Ask user if the data contains NMEA messages
-response = input('Could this file contain any NMEA messages? (Y/n): ') # Get the response
-if (response == '') or (response == 'Y') or (response == 'y'):
-    containsNMEA = True
-else:
-    containsNMEA = False
-
-print()
-print('Processing',filename)
-print()
-filesize = os.path.getsize(filename) # Record the file size
-
-# Try to open file for reading
-try:
-    fi = open(filename,"rb")
-except:
-    raise Exception('Invalid file!')
-
-processed = -1 # The nunber of bytes processed
-messages = {} # The collected message types
-longest = 0 # The length of the longest UBX message
-keepGoing = True
-
-# Sync 'state machine'
-looking_for_B5_dollar   = 0 # Looking for either a UBX 0xB5 or an NMEA '$'
-looking_for_62          = 1 # Looking for a UBX 0x62 header byte
-looking_for_class       = 2 # Looking for UBX class byte
-looking_for_ID          = 3 # Looking for UBX ID byte
-looking_for_length_LSB  = 4 # Looking for UBX length bytes
-looking_for_length_MSB  = 5
-processing_payload      = 6 # Processing the payload. Keep going until length bytes have been processed
-looking_for_checksum_A  = 7 # Looking for UBX checksum bytes
-looking_for_checksum_B  = 8
-sync_lost               = 9 # Go into this state if sync is lost (bad checksum etc.)
-looking_for_asterix     = 10 # Looking for NMEA '*'
-looking_for_csum1       = 11 # Looking for NMEA checksum bytes
-looking_for_csum2       = 12
-looking_for_term1       = 13 # Looking for NMEA terminating bytes (CR and LF)
-looking_for_term2       = 14
-
-ubx_nmea_state = sync_lost # Initialize the state machine
-
-# Storage for UBX messages
-ubx_length = 0
-ubx_class = 0
-ubx_ID = 0
-ubx_checksum_A = 0
-ubx_checksum_B = 0
-ubx_expected_checksum_A = 0
-ubx_expected_checksum_B = 0
-
-# Storage for NMEA messages
-nmea_length = 0
-nmea_char_1 = 0 # e.g. G
-nmea_char_2 = 0 # e.g. P
-nmea_char_3 = 0 # e.g. G
-nmea_char_4 = 0 # e.g. G
-nmea_char_5 = 0 # e.g. A
-nmea_csum = 0
-nmea_csum1 = 0
-nmea_csum2 = 0
-nmea_expected_csum1 = 0
-nmea_expected_csum2 = 0
-
-max_nmea_len = 100 # Maximum length for an NMEA message: use this to detect if we have lost sync while receiving an NMEA message
-sync_lost_at = -1 # Record where we lost sync
-rewind_to = -1 # Keep a note of where we should rewind to if sync is lost
-rewind_attempts = 0 # Keep a note of how many rewinds have been attempted
-max_rewinds = 100 # Abort after this many rewinds
-rewind_in_progress = False # Flag to indicate if a rewind is in progress
-resyncs = 0 # Record the number of successful resyncs
-resync_in_progress = False # Flag to indicate if a resync is in progress
-message_start_byte = 0 # Record where the latest message started (for resync reporting)
-
-try:
-    while keepGoing:
-
-        # Read one byte from the file
-        fileBytes = fi.read(1)
-        if (len(fileBytes) == 0):
-            print('ERROR: Read zero bytes. End of file?! Or zero file size?!')
-            raise Exception('End of file?! Or zero file size?!')
-        c = fileBytes[0]
-
-        processed = processed + 1 # Keep a record of how many bytes have been read and processed
-
-        # Process data bytes according to ubx_nmea_state
-        # For UBX messages:
-        # Sync Char 1: 0xB5
-        # Sync Char 2: 0x62
-        # Class byte
-        # ID byte
-        # Length: two bytes, little endian
-        # Payload: length bytes
-        # Checksum: two bytes
-        # For NMEA messages:
-        # Starts with a '$'
-        # The next five characters indicate the message type (stored in nmea_char_1 to nmea_char_5)
-        # Message fields are comma-separated
-        # Followed by an '*'
-        # Then a two character checksum (the logical exclusive-OR of all characters between the $ and the * as ASCII hex)
-        # Ends with CR LF
-        # Only allow a new file to be opened when a complete packet has been processed and ubx_nmea_state has returned to "looking_for_B5_dollar"
-        # Or when a data error is detected (sync_lost)
-
-        # RXM_RAWX is class 0x02 ID 0x15
-        # RXM_SFRBF is class 0x02 ID 0x13
-        # TIM_TM2 is class 0x0d ID 0x03
-        # NAV_POSLLH is class 0x01 ID 0x02
-        # NAV_PVT is class 0x01 ID 0x07
-        # NAV-STATUS is class 0x01 ID 0x03
-
-        if (ubx_nmea_state == looking_for_B5_dollar) or (ubx_nmea_state == sync_lost):
-            if (c == 0xB5): # Have we found Sync Char 1 (0xB5) if we were expecting one?
-                if (ubx_nmea_state == sync_lost):
-                    print("UBX Sync Char 1 (0xB5) found at byte "+str(processed)+". Checking for Sync Char 2")
-                ubx_nmea_state = looking_for_62 # Now look for Sync Char 2 (0x62)
-                message_start_byte = processed # Record the message start byte for resync reporting
-            elif (c == 0x24) and (containsNMEA == True): # Have we found an NMEA '$' if we were expecting one?
-                if (ubx_nmea_state == sync_lost):
-                    print("NMEA $ found at byte "+str(processed)+". Attempting to process the message")
-                ubx_nmea_state = looking_for_asterix # Now keep going until we receive an asterix
-                nmea_length = 0 # Reset nmea_length then use it to check for excessive message length
-                nmea_csum = 0 # Reset the nmea_csum. Update it as each character arrives
-                nmea_char_1 = 0x30 # Reset the first five NMEA chars to something invalid
-                nmea_char_2 = 0x30
-                nmea_char_3 = 0x30
-                nmea_char_4 = 0x30
-                nmea_char_5 = 0x30
-                message_start_byte = processed # Record the message start byte for resync reporting
-            else:
-                #print("Was expecting Sync Char 0xB5 or an NMEA $ but did not receive one!")
-                if (c == 0x24):
-                    print("Warning: * found at byte "+str(processed)+"! Are you sure this file does not contain NMEA messages?")
-                sync_lost_at = processed
-                ubx_nmea_state = sync_lost
-        elif (ubx_nmea_state == looking_for_62):
-            if (c == 0x62): # Have we found Sync Char 2 (0x62) when we were expecting one?
-                ubx_expected_checksum_A = 0 # Reset the expected checksum
-                ubx_expected_checksum_B = 0
-                ubx_nmea_state = looking_for_class # Now look for Class byte
-            else:
-                print("Panic!! Was expecting Sync Char 2 (0x62) but did not receive one!")
-                print("Sync lost at byte "+str(processed)+". Attemting to re-sync")
-                sync_lost_at = processed
-                resync_in_progress = True
-                ubx_nmea_state = sync_lost
-        elif (ubx_nmea_state == looking_for_class):
-            ubx_class = c
-            ubx_expected_checksum_A = ubx_expected_checksum_A + c # Update the expected checksum
-            ubx_expected_checksum_B = ubx_expected_checksum_B + ubx_expected_checksum_A
-            ubx_nmea_state = looking_for_ID # Now look for ID byte
-        elif (ubx_nmea_state == looking_for_ID):
-            ubx_ID = c
-            ubx_expected_checksum_A = ubx_expected_checksum_A + c # Update the expected checksum
-            ubx_expected_checksum_B = ubx_expected_checksum_B + ubx_expected_checksum_A
-            message_type = '0x%02X 0x%02X'%(ubx_class,ubx_ID) # Record the message type
-            ubx_nmea_state = looking_for_length_LSB # Now look for length LSB
-        elif (ubx_nmea_state == looking_for_length_LSB):
-            ubx_length = c # Store the length LSB
-            ubx_expected_checksum_A = ubx_expected_checksum_A + c # Update the expected checksum
-            ubx_expected_checksum_B = ubx_expected_checksum_B + ubx_expected_checksum_A
-            ubx_nmea_state = looking_for_length_MSB # Now look for length MSB
-        elif (ubx_nmea_state == looking_for_length_MSB):
-            ubx_length = ubx_length + (c * 256) # Add the length MSB
-            ubx_expected_checksum_A = ubx_expected_checksum_A + c # Update the expected checksum
-            ubx_expected_checksum_B = ubx_expected_checksum_B + ubx_expected_checksum_A
-            if (ubx_length > longest): # Update the longest UBX message length    
-                longest = ubx_length
-            rewind_to = processed # If we lose sync due to dropped bytes then rewind to here
-            ubx_nmea_state = processing_payload # Now look for payload bytes (length: ubx_length)
-        elif (ubx_nmea_state == processing_payload):
-            ubx_length = ubx_length - 1 # Decrement length by one
-            ubx_expected_checksum_A = ubx_expected_checksum_A + c # Update the expected checksum
-            ubx_expected_checksum_B = ubx_expected_checksum_B + ubx_expected_checksum_A
-            if (ubx_length == 0):
-                ubx_expected_checksum_A = ubx_expected_checksum_A & 0xff # Limit checksums to 8-bits
-                ubx_expected_checksum_B = ubx_expected_checksum_B & 0xff
-                ubx_nmea_state = looking_for_checksum_A # If we have received length payload bytes, look for checksum bytes
-        elif (ubx_nmea_state == looking_for_checksum_A):
-            ubx_checksum_A = c
-            ubx_nmea_state = looking_for_checksum_B
-        elif (ubx_nmea_state == looking_for_checksum_B):
-            ubx_checksum_B = c
-            ubx_nmea_state = looking_for_B5_dollar # All bytes received so go back to looking for a new Sync Char 1 unless there is a checksum error
-            if ((ubx_expected_checksum_A != ubx_checksum_A) or (ubx_expected_checksum_B != ubx_checksum_B)):
-                print("Panic!! UBX checksum error!")
-                print("Sync lost at byte "+str(processed)+". Attemting to re-sync.")
-                sync_lost_at = processed
-                resync_in_progress = True
-                ubx_nmea_state = sync_lost
-            else:
-                # Valid UBX message was received. Check if we have seen this message type before
-                if message_type in messages:
-                    messages[message_type] += 1 # if we have, increment its count
-                else:
-                    messages[message_type] = 1 # if we have not, set its count to 1
-                rewind_in_progress = False # Clear rewind_in_progress
-                rewind_to = -1
-                if (resync_in_progress == True): # Check if we are resyncing
-                    resync_in_progress = False # Clear the flag now that a valid message has been received
-                    resyncs += 1 # Increment the number of successful resyncs
-                    print("Sync successfully re-established at byte "+str(processed)+". The UBX message started at byte "+str(message_start_byte))
-                    print()
-        # NMEA messages
-        elif (ubx_nmea_state == looking_for_asterix):
-            nmea_length = nmea_length + 1 # Increase the message length count
-            if (nmea_length > max_nmea_len): # If the length is greater than max_nmea_len, something bad must have happened (sync_lost)
-                print("Panic!! Excessive NMEA message length!")
-                print("Sync lost at byte "+str(processed)+". Attemting to re-sync")
-                sync_lost_at = processed
-                resync_in_progress = True
-                ubx_nmea_state = sync_lost
-                continue
-            # If this is one of the first five characters, store it
-            if (nmea_length <= 5):
-                if (nmea_length == 1):
-                    nmea_char_1 = c
-                    rewind_to = processed # If we lose sync due to dropped bytes then rewind to here
-                elif (nmea_length == 2):
-                    nmea_char_2 = c
-                elif (nmea_length == 3):
-                    nmea_char_3 = c
-                elif (nmea_length == 4):
-                    nmea_char_4 = c
-                else: # ubx_length == 5
-                    nmea_char_5 = c
-                    message_type = chr(nmea_char_1) + chr(nmea_char_2) + chr(nmea_char_3) + chr(nmea_char_4) + chr(nmea_char_5) # Record the message type
-            # Now check if this is an '*'
-            if (c == 0x2A):
-                # Asterix received
-                # Don't exOR it into the checksum
-                # Instead calculate what the expected checksum should be (nmea_csum in ASCII hex)
-                nmea_expected_csum1 = ((nmea_csum & 0xf0) >> 4) + 0x30 # Convert MS nibble to ASCII hex
-                if (nmea_expected_csum1 >= 0x3A): # : follows 9 so add 7 to convert to A-F
-                    nmea_expected_csum1 += 7
-                nmea_expected_csum2 = (nmea_csum & 0x0f) + 0x30 # Convert LS nibble to ASCII hex
-                if (nmea_expected_csum2 >= 0x3A): # : follows 9 so add 7 to convert to A-F
-                    nmea_expected_csum2 += 7
-                # Next, look for the first csum character
-                ubx_nmea_state = looking_for_csum1
-                continue # Don't include the * in the checksum
-            # Now update the checksum
-            # The checksum is the exclusive-OR of all characters between the $ and the *
-            nmea_csum = nmea_csum ^ c
-        elif (ubx_nmea_state == looking_for_csum1):
-            # Store the first NMEA checksum character
-            nmea_csum1 = c
-            ubx_nmea_state = looking_for_csum2
-        elif (ubx_nmea_state == looking_for_csum2):
-            # Store the second NMEA checksum character
-            nmea_csum2 = c
-            # Now check if the checksum is correct
-            if ((nmea_csum1 != nmea_expected_csum1) or (nmea_csum2 != nmea_expected_csum2)):
-                # The checksum does not match so sync_lost
-                print("Panic!! NMEA checksum error!")
-                print("Sync lost at byte "+str(processed)+". Attemting to re-sync")
-                sync_lost_at = processed
-                resync_in_progress = True
-                ubx_nmea_state = sync_lost
-            else:
-                # Checksum was valid so wait for the terminators
-                ubx_nmea_state = looking_for_term1
-        elif (ubx_nmea_state == looking_for_term1):
-            # Check if this is CR
-            if (c != 0x0D):
-                print("Panic!! NMEA CR not found!")
-                print("Sync lost at byte "+str(processed)+". Attemting to re-sync")
-                sync_lost_at = processed
-                resync_in_progress = True
-                ubx_nmea_state = sync_lost
-            else:
-                ubx_nmea_state = looking_for_term2
-        elif (ubx_nmea_state == looking_for_term2):
-            # Check if this is LF
-            if (c != 0x0A):
-                print("Panic!! NMEA LF not found!")
-                print("Sync lost at byte "+str(processed)+". Attemting to re-sync")
-                sync_lost_at = processed
-                resync_in_progress = True
-                ubx_nmea_state = sync_lost
-            else:
-                # Valid NMEA message was received. Check if we have seen this message type before
-                if message_type in messages:
-                    messages[message_type] += 1 # if we have, increment its count
-                else:
-                    messages[message_type] = 1 # if we have not, set its count to 1
-                # LF was received so go back to looking for B5 or a $
-                ubx_nmea_state = looking_for_B5_dollar
-                rewind_in_progress = False # Clear rewind_in_progress
-                rewind_to = -1
-                if (resync_in_progress == True): # Check if we are resyncing
-                    resync_in_progress = False # Clear the flag now that a valid message has been received
-                    resyncs += 1 # Increment the number of successful resyncs
-                    print("Sync successfully re-established at byte "+str(processed)+". The NMEA message started at byte "+str(message_start_byte))
-                    print()
-
-        # Check if the end of the file has been reached
-        if (processed >= filesize - 1): keepGoing = False
-
-        # Check if we should attempt to rewind
-        # Don't rewind if we have not yet seen a valid message
-        # Don't rewind if a rewind is already in progress
-        if (ubx_nmea_state == sync_lost) and (len(messages) > 0) and (rewind_in_progress == False) and (rewind_to >= 0):
-            rewind_attempts += 1 # Increment the number of rewind attempts
-            if (rewind_attempts > max_rewinds): # Only rewind up to max_rewind times
-                print("Panic! Maximum rewind attempts reached! Aborting...")
-                keepGoing = False
-            else:
-                print("Sync has been lost. Currently processing byte "+str(processed)+". Rewinding to byte "+str(rewind_to))
-                fi.seek(rewind_to) # Rewind the file
-                processed = rewind_to - 1 # Rewind processed too! (-1 is needed as processed is incremented at the start of the loop)
-                rewind_in_progress = True # Flag that a rewind is in progress
-            
-
-finally:
-    fi.close() # Close the file
-
-    # Print the file statistics
-    print()
-    processed += 1
-    print('Processed',processed,'bytes')
-    print('File size was',filesize)
-    if (processed != filesize):
-        print('FILE SIZE MISMATCH!!')
-    print('Longest UBX message was %i data bytes'%longest)
-    if len(messages) > 0:
-        print('Message types and totals were:')
-        for key in messages.keys():
-            print('Message type:',key,'  Total:',messages[key])
-    if (resyncs > 0):
-        print('Number of successful resyncs:',resyncs)
-    print()
-    print('Bye!')
diff --git a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Callbacks/CallbackExample1_NAV_PVT/CallbackExample1_NAV_PVT.ino b/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Callbacks/CallbackExample1_NAV_PVT/CallbackExample1_NAV_PVT.ino
deleted file mode 100644
index 4b1afba..0000000
--- a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Callbacks/CallbackExample1_NAV_PVT/CallbackExample1_NAV_PVT.ino
+++ /dev/null
@@ -1,104 +0,0 @@
-/*
-  Configuring the GNSS to automatically send position reports over I2C and display them using a callback
-  By: Paul Clark
-  SparkFun Electronics
-  Date: December 30th, 2020
-  License: MIT. See license file for more information but you can
-  basically do whatever you want with this code.
-
-  This example shows how to configure the u-blox GNSS to send navigation reports automatically
-  and access the data via a callback. No more polling!
-
-  Feel like supporting open source hardware?
-  Buy a board from SparkFun!
-  ZED-F9P RTK2: https://www.sparkfun.com/products/15136
-  NEO-M8P RTK: https://www.sparkfun.com/products/15005
-  SAM-M8Q: https://www.sparkfun.com/products/15106
-
-  Hardware Connections:
-  Plug a Qwiic cable into the GPS and a BlackBoard
-  If you don't have a platform with a Qwiic connection use the SparkFun Qwiic Breadboard Jumper (https://www.sparkfun.com/products/14425)
-  Open the serial monitor at 115200 baud to see the output
-*/
-
-#include <Wire.h> //Needed for I2C to GPS
-
-#include <SparkFun_u-blox_GNSS_Arduino_Library.h> //http://librarymanager/All#SparkFun_u-blox_GNSS
-SFE_UBLOX_GNSS myGNSS;
-
-// Callback: printPVTdata will be called when new NAV PVT data arrives
-// See u-blox_structs.h for the full definition of UBX_NAV_PVT_data_t
-//         _____  You can use any name you like for the callback. Use the same name when you call setAutoPVTcallback
-//        /                  _____  This _must_ be UBX_NAV_PVT_data_t
-//        |                 /               _____ You can use any name you like for the struct
-//        |                 |              /
-//        |                 |              |
-void printPVTdata(UBX_NAV_PVT_data_t ubxDataStruct)
-{
-    Serial.println();
-
-    Serial.print(F("Time: ")); // Print the time
-    uint8_t hms = ubxDataStruct.hour; // Print the hours
-    if (hms < 10) Serial.print(F("0")); // Print a leading zero if required
-    Serial.print(hms);
-    Serial.print(F(":"));
-    hms = ubxDataStruct.min; // Print the minutes
-    if (hms < 10) Serial.print(F("0")); // Print a leading zero if required
-    Serial.print(hms);
-    Serial.print(F(":"));
-    hms = ubxDataStruct.sec; // Print the seconds
-    if (hms < 10) Serial.print(F("0")); // Print a leading zero if required
-    Serial.print(hms);
-    Serial.print(F("."));
-    unsigned long millisecs = ubxDataStruct.iTOW % 1000; // Print the milliseconds
-    if (millisecs < 100) Serial.print(F("0")); // Print the trailing zeros correctly
-    if (millisecs < 10) Serial.print(F("0"));
-    Serial.print(millisecs);
-
-    long latitude = ubxDataStruct.lat; // Print the latitude
-    Serial.print(F(" Lat: "));
-    Serial.print(latitude);
-
-    long longitude = ubxDataStruct.lon; // Print the longitude
-    Serial.print(F(" Long: "));
-    Serial.print(longitude);
-    Serial.print(F(" (degrees * 10^-7)"));
-
-    long altitude = ubxDataStruct.hMSL; // Print the height above mean sea level
-    Serial.print(F(" Height above MSL: "));
-    Serial.print(altitude);
-    Serial.println(F(" (mm)"));
-}
-
-void setup()
-{
-  Serial.begin(115200);
-  while (!Serial); //Wait for user to open terminal
-  Serial.println("SparkFun u-blox Example");
-
-  Wire.begin();
-
-  //myGNSS.enableDebugging(); // Uncomment this line to enable helpful debug messages on Serial
-
-  if (myGNSS.begin() == false) //Connect to the u-blox module using Wire port
-  {
-    Serial.println(F("u-blox GNSS not detected at default I2C address. Please check wiring. Freezing."));
-    while (1);
-  }
-
-  myGNSS.setI2COutput(COM_TYPE_UBX); //Set the I2C port to output UBX only (turn off NMEA noise)
-  myGNSS.saveConfigSelective(VAL_CFG_SUBSEC_IOPORT); //Save (only) the communications port settings to flash and BBR
-
-  myGNSS.setNavigationFrequency(2); //Produce two solutions per second
-
-  myGNSS.setAutoPVTcallback(&printPVTdata); // Enable automatic NAV PVT messages with callback to printPVTdata
-}
-
-void loop()
-{
-  myGNSS.checkUblox(); // Check for the arrival of new data and process it.
-  myGNSS.checkCallbacks(); // Check if any callbacks are waiting to be processed.
-
-  Serial.print(".");
-  delay(50);
-}
diff --git a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Callbacks/CallbackExample2_NAV_ODO/CallbackExample2_NAV_ODO.ino b/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Callbacks/CallbackExample2_NAV_ODO/CallbackExample2_NAV_ODO.ino
deleted file mode 100644
index 3e1008c..0000000
--- a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Callbacks/CallbackExample2_NAV_ODO/CallbackExample2_NAV_ODO.ino
+++ /dev/null
@@ -1,89 +0,0 @@
-/*
-  Configuring the GNSS to automatically send odometer reports over I2C and display the data using a callback
-  By: Paul Clark
-  SparkFun Electronics
-  Date: December 30th, 2020
-  License: MIT. See license file for more information but you can
-  basically do whatever you want with this code.
-
-  This example shows how to configure the u-blox GNSS to send odometer reports automatically
-  and display the data via a callback. No more polling!
-
-  Feel like supporting open source hardware?
-  Buy a board from SparkFun!
-  ZED-F9P RTK2: https://www.sparkfun.com/products/15136
-  NEO-M8P RTK: https://www.sparkfun.com/products/15005
-  SAM-M8Q: https://www.sparkfun.com/products/15106
-
-  Hardware Connections:
-  Plug a Qwiic cable into the GPS and a BlackBoard
-  If you don't have a platform with a Qwiic connection use the SparkFun Qwiic Breadboard Jumper (https://www.sparkfun.com/products/14425)
-  Open the serial monitor at 115200 baud to see the output
-*/
-
-#include <Wire.h> //Needed for I2C to GPS
-
-#include <SparkFun_u-blox_GNSS_Arduino_Library.h> //http://librarymanager/All#SparkFun_u-blox_GNSS
-SFE_UBLOX_GNSS myGNSS;
-
-// Callback: printODOdata will be called when new NAV ODO data arrives
-// See u-blox_structs.h for the full definition of UBX_NAV_ODO_data_t
-//         _____  You can use any name you like for the callback. Use the same name when you call setAutoNAVODOcallback
-//        /                  _____  This _must_ be UBX_NAV_ODO_data_t
-//        |                 /                   _____ You can use any name you like for the struct
-//        |                 |                  /
-//        |                 |                  |
-void printODOdata(UBX_NAV_ODO_data_t ubxDataStruct)
-{
-    Serial.println();
-
-    Serial.print(F("TOW: ")); // Print the Time Of Week
-    unsigned long iTOW = ubxDataStruct.iTOW; // iTOW is in milliseconds
-    Serial.print(iTOW);
-    Serial.print(F(" (ms)"));
-
-    Serial.print(F(" Distance: "));
-    unsigned long distance = ubxDataStruct.distance; // Print the distance
-    Serial.print(distance);
-    Serial.print(F(" (m)"));
-
-    Serial.print(F(" Total Distance: "));
-    unsigned long totalDistance = ubxDataStruct.totalDistance; // Print the total distance
-    Serial.print(totalDistance);
-    Serial.println(F(" (m)"));
-}
-
-void setup()
-{
-  Serial.begin(115200);
-  while (!Serial); //Wait for user to open terminal
-  Serial.println("SparkFun u-blox Example");
-
-  Wire.begin();
-
-  //myGNSS.enableDebugging(); // Uncomment this line to enable helpful debug messages on Serial
-
-  if (myGNSS.begin() == false) //Connect to the u-blox module using Wire port
-  {
-    Serial.println(F("u-blox GNSS not detected at default I2C address. Please check wiring. Freezing."));
-    while (1);
-  }
-
-  myGNSS.setI2COutput(COM_TYPE_UBX); //Set the I2C port to output UBX only (turn off NMEA noise)
-  myGNSS.saveConfigSelective(VAL_CFG_SUBSEC_IOPORT); //Save (only) the communications port settings to flash and BBR
-
-  myGNSS.setNavigationFrequency(1); //Produce one solution per second
-
-  //myGNSS.resetOdometer(); //Uncomment this line to reset the odometer
-
-  myGNSS.setAutoNAVODOcallback(&printODOdata); // Enable automatic NAV ODO messages with callback to printODOdata
-}
-
-void loop()
-{
-  myGNSS.checkUblox(); // Check for the arrival of new data and process it.
-  myGNSS.checkCallbacks(); // Check if any callbacks are waiting to be processed.
-
-  Serial.print(".");
-  delay(50);
-}
diff --git a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Callbacks/CallbackExample3_TIM_TM2/CallbackExample3_TIM_TM2.ino b/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Callbacks/CallbackExample3_TIM_TM2/CallbackExample3_TIM_TM2.ino
deleted file mode 100644
index 3737bec..0000000
--- a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Callbacks/CallbackExample3_TIM_TM2/CallbackExample3_TIM_TM2.ino
+++ /dev/null
@@ -1,115 +0,0 @@
-/*
-  Configuring the GNSS to automatically send TIM TM2 reports over I2C and display the data using a callback
-  By: Paul Clark
-  SparkFun Electronics
-  Date: December 30th, 2020
-  License: MIT. See license file for more information but you can
-  basically do whatever you want with this code.
-
-  This example shows how to configure the u-blox GNSS to send TIM TM2 reports automatically
-  and display the data via a callback. No more polling!
-
-  Connecting the PPS (Pulse Per Second) breakout pin to the INT (Interrupt) pin with a jumper wire
-  will cause a TIM TM2 message to be produced once per second. You can then study the timing of the
-  pulse edges with nanosecond resolution!
-
-  Note: TIM TM2 can only capture the timing of one rising edge and one falling edge per
-  navigation solution. So with setNavigationFrequency set to 1Hz, we can only see the timing
-  of one rising and one falling edge per second. If the frequency of the signal on the INT pin
-  is higher than 1Hz, we will only be able to see the timing of the most recent edges.
-  However, the module can count the number of rising edges too, at rates faster than the navigation rate.
-
-  TIM TM2 messages are only produced when a rising or falling edge is detected on the INT pin.
-  If you disconnect your PPS to INT jumper wire, the messages will stop.
-
-  Feel like supporting open source hardware?
-  Buy a board from SparkFun!
-  ZED-F9P RTK2: https://www.sparkfun.com/products/15136
-  NEO-M8P RTK: https://www.sparkfun.com/products/15005
-  NEO-M9N: https://www.sparkfun.com/products/17285
-
-  Hardware Connections:
-  Plug a Qwiic cable into the GPS and a BlackBoard
-  If you don't have a platform with a Qwiic connection use the SparkFun Qwiic Breadboard Jumper (https://www.sparkfun.com/products/14425)
-  Open the serial monitor at 115200 baud to see the output
-*/
-
-#include <Wire.h> //Needed for I2C to GPS
-
-#include <SparkFun_u-blox_GNSS_Arduino_Library.h> //http://librarymanager/All#SparkFun_u-blox_GNSS
-SFE_UBLOX_GNSS myGNSS;
-
-int dotsPrinted = 0; // Print dots in rows of 50 while waiting for a TIM TM2 message
-
-// Callback: printTIMTM2data will be called when new TIM TM2 data arrives
-// See u-blox_structs.h for the full definition of UBX_TIM_TM2_data_t
-//         _____  You can use any name you like for the callback. Use the same name when you call setAutoTIMTM2callback
-//        /                  _____  This _must_ be UBX_TIM_TM2_data_t
-//        |                 /                   _____ You can use any name you like for the struct
-//        |                 |                  /
-//        |                 |                  |
-void printTIMTM2data(UBX_TIM_TM2_data_t ubxDataStruct)
-{
-    Serial.println();
-
-    Serial.print(F("newFallingEdge: ")); // 1 if a new falling edge was detected
-    Serial.print(ubxDataStruct.flags.bits.newFallingEdge);
-
-    Serial.print(F(" newRisingEdge: ")); // 1 if a new rising edge was detected
-    Serial.print(ubxDataStruct.flags.bits.newRisingEdge);
-
-    Serial.print(F(" Rising Edge Counter: ")); // Rising edge counter
-    Serial.print(ubxDataStruct.count);
-
-    Serial.print(F(" towMsR: ")); // Time Of Week of rising edge (ms)
-    Serial.print(ubxDataStruct.towMsR);
-
-    Serial.print(F(" towSubMsR: ")); // Millisecond fraction of Time Of Week of rising edge in nanoseconds
-    Serial.print(ubxDataStruct.towSubMsR);
-
-    Serial.print(F(" towMsF: ")); // Time Of Week of falling edge (ms)
-    Serial.print(ubxDataStruct.towMsF);
-
-    Serial.print(F(" towSubMsF: ")); // Millisecond fraction of Time Of Week of falling edge in nanoseconds
-    Serial.println(ubxDataStruct.towSubMsF);
-
-    dotsPrinted = 0; // Reset dotsPrinted
-}
-
-void setup()
-{
-  Serial.begin(115200);
-  while (!Serial); //Wait for user to open terminal
-  Serial.println("SparkFun u-blox Example");
-
-  Wire.begin();
-
-  //myGNSS.enableDebugging(); // Uncomment this line to enable helpful debug messages on Serial
-
-  if (myGNSS.begin() == false) //Connect to the u-blox module using Wire port
-  {
-    Serial.println(F("u-blox GNSS not detected at default I2C address. Please check wiring. Freezing."));
-    while (1);
-  }
-
-  myGNSS.setI2COutput(COM_TYPE_UBX); //Set the I2C port to output UBX only (turn off NMEA noise)
-  myGNSS.saveConfigSelective(VAL_CFG_SUBSEC_IOPORT); //Save (only) the communications port settings to flash and BBR
-
-  myGNSS.setNavigationFrequency(1); //Produce one solution per second
-
-  myGNSS.setAutoTIMTM2callback(&printTIMTM2data); // Enable automatic TIM TM2 messages with callback to printTIMTM2data
-}
-
-void loop()
-{
-  myGNSS.checkUblox(); // Check for the arrival of new data and process it.
-  myGNSS.checkCallbacks(); // Check if any callbacks are waiting to be processed.
-
-  Serial.print(".");
-  delay(50);
-  if (++dotsPrinted > 50)
-  {
-    Serial.println();
-    dotsPrinted = 0;
-  }
-}
diff --git a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Callbacks/CallbackExample4_HNR/CallbackExample4_HNR.ino b/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Callbacks/CallbackExample4_HNR/CallbackExample4_HNR.ino
deleted file mode 100644
index 7c86fa8..0000000
--- a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Callbacks/CallbackExample4_HNR/CallbackExample4_HNR.ino
+++ /dev/null
@@ -1,117 +0,0 @@
-/*
-  By: Paul Clark
-  SparkFun Electronics
-  Date: December, 2020
-  License: MIT. See license file for more information but you can
-  basically do whatever you want with this code.
-
-  This example configures the High Navigation Rate on the NEO-M8U and then
-  reads and displays the attitude solution, vehicle dynamics information
-  and high rate position, velocity and time.
-
-  This example uses callbacks to process the HNR data automatically. No more polling!
-
-  Please make sure your NEO-M8U is running UDR firmware >= 1.31. Please update using u-center if necessary:
-  https://www.u-blox.com/en/product/neo-m8u-module#tab-documentation-resources
-
-  Feel like supporting open source hardware?
-  Buy a board from SparkFun!
-  NEO-M8U: https://www.sparkfun.com/products/16329
-
-  Hardware Connections:
-  Plug a Qwiic cable into the GPS and a Redboard Qwiic
-  If you don't have a platform with a Qwiic connection use the
-	SparkFun Qwiic Breadboard Jumper (https://www.sparkfun.com/products/14425)
-  Open the serial monitor at 115200 baud to see the output
-
-*/
-
-#include <Wire.h> //Needed for I2C to GPS
-
-#include <SparkFun_u-blox_GNSS_Arduino_Library.h> //http://librarymanager/All#SparkFun_u-blox_GNSS
-SFE_UBLOX_GNSS myGNSS;
-
-// Callback: printHNRATTdata will be called when new HNR ATT data arrives
-// See u-blox_structs.h for the full definition of UBX_HNR_ATT_data_t
-//         _____  You can use any name you like for the callback. Use the same name when you call setAutoHNRATTcallback
-//        /                  _____  This _must_ be UBX_HNR_ATT_data_t
-//        |                 /                   _____ You can use any name you like for the struct
-//        |                 |                  /
-//        |                 |                  |
-void printHNRATTdata(UBX_HNR_ATT_data_t ubxDataStruct)
-{
-  Serial.println();
-  Serial.print(F("Roll: ")); // Print selected data
-  Serial.print((float)ubxDataStruct.roll / 100000.0, 2); // Convert roll to degrees
-  Serial.print(F(" Pitch: "));
-  Serial.print((float)ubxDataStruct.pitch / 100000.0, 2); // Convert pitch to degrees
-  Serial.print(F(" Heading: "));
-  Serial.println((float)ubxDataStruct.heading / 100000.0, 2); // Convert heading to degrees
-}
-
-// Callback: printHNRINSdata will be called when new HNR INS data arrives
-// See u-blox_structs.h for the full definition of UBX_HNR_INS_data_t
-void printHNRINSdata(UBX_HNR_INS_data_t ubxDataStruct)
-{
-  Serial.print(F("xAccel: ")); // Print selected data
-  Serial.print(ubxDataStruct.xAccel);
-  Serial.print(F(" yAccel: "));
-  Serial.print(ubxDataStruct.yAccel);
-  Serial.print(F(" zAccel: "));
-  Serial.println(ubxDataStruct.zAccel);
-}
-
-// Callback: printHNRPVTdata will be called when new HNR PVT data arrives
-// See u-blox_structs.h for the full definition of UBX_HNR_PVT_data_t
-void printHNRPVTdata(UBX_HNR_PVT_data_t ubxDataStruct)
-{
-  Serial.print(F("ns: ")); // Print selected data
-  Serial.print(ubxDataStruct.nano);
-  Serial.print(F(" Lat: "));
-  Serial.print(ubxDataStruct.lat);
-  Serial.print(F(" Lon: "));
-  Serial.println(ubxDataStruct.lon);
-}
-
-void setup()
-{
-  Serial.begin(115200);
-  while (!Serial); //Wait for user to open terminal
-  Serial.println(F("SparkFun u-blox Example"));
-
-  Wire.begin();
-
-  //myGNSS.enableDebugging(); // Uncomment this line to enable debug messages on Serial
-
-  if (myGNSS.begin() == false) //Connect to the u-blox module using Wire port
-  {
-    Serial.println(F("u-blox GNSS not detected at default I2C address. Please check wiring. Freezing."));
-    while (1);
-  }
-
-  myGNSS.setI2COutput(COM_TYPE_UBX); //Set the I2C port to output UBX only (turn off NMEA noise)
-  myGNSS.saveConfigSelective(VAL_CFG_SUBSEC_IOPORT); //Save (only) the communications port settings to flash and BBR
-
-  if (myGNSS.setHNRNavigationRate(10) == true) //Set the High Navigation Rate to 10Hz
-    Serial.println(F("setHNRNavigationRate was successful"));
-  else
-    Serial.println(F("setHNRNavigationRate was NOT successful"));
-
-  if (myGNSS.setAutoHNRATTcallback(&printHNRATTdata) == true) // Enable automatic HNR ATT messages with callback to printHNRATTdata
-    Serial.println(F("setAutoHNRATTcallback successful"));
-
-  if (myGNSS.setAutoHNRINScallback(&printHNRINSdata) == true) // Enable automatic HNR INS messages with callback to printHNRINSdata
-    Serial.println(F("setAutoHNRINScallback successful"));
-
-  if (myGNSS.setAutoHNRPVTcallback(&printHNRPVTdata) == true) // Enable automatic HNR PVT messages with callback to printHNRPVTdata
-    Serial.println(F("setAutoHNRPVTcallback successful"));
-}
-
-void loop()
-{
-  myGNSS.checkUblox(); // Check for the arrival of new data and process it.
-  myGNSS.checkCallbacks(); // Check if any callbacks are waiting to be processed.
-
-  Serial.print(".");
-  delay(25);
-}
diff --git a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Callbacks/CallbackExample5_ESF/CallbackExample5_ESF.ino b/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Callbacks/CallbackExample5_ESF/CallbackExample5_ESF.ino
deleted file mode 100644
index bd5a7d6..0000000
--- a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Callbacks/CallbackExample5_ESF/CallbackExample5_ESF.ino
+++ /dev/null
@@ -1,179 +0,0 @@
-/*
-  By: Paul Clark
-  SparkFun Electronics
-  Date: December, 2020
-  License: MIT. See license file for more information but you can
-  basically do whatever you want with this code.
-
-  This example configures the External Sensor Fusion messages on the NEO-M8U and
-  uses callbacks to process and display the ESF data automatically. No more polling!
-
-  Please make sure your NEO-M8U is running UDR firmware >= 1.31. Please update using u-center if necessary:
-  https://www.u-blox.com/en/product/neo-m8u-module#tab-documentation-resources
-
-  Feel like supporting open source hardware?
-  Buy a board from SparkFun!
-  NEO-M8U: https://www.sparkfun.com/products/16329
-
-  Hardware Connections:
-  Plug a Qwiic cable into the GPS and a Redboard Qwiic
-  If you don't have a platform with a Qwiic connection use the
-	SparkFun Qwiic Breadboard Jumper (https://www.sparkfun.com/products/14425)
-  Open the serial monitor at 115200 baud to see the output
-
-*/
-
-#include <Wire.h> //Needed for I2C to GPS
-
-#include <SparkFun_u-blox_GNSS_Arduino_Library.h> //http://librarymanager/All#SparkFun_u-blox_GNSS
-SFE_UBLOX_GNSS myGNSS;
-
-// Callback: printESFALGdata will be called when new ESF ALG data arrives
-// See u-blox_structs.h for the full definition of UBX_ESF_ALG_data_t
-//         _____  You can use any name you like for the callback. Use the same name when you call setAutoESFALGcallback
-//        /                  _____  This _must_ be UBX_ESF_ALG_data_t
-//        |                 /                   _____ You can use any name you like for the struct
-//        |                 |                  /
-//        |                 |                  |
-void printESFALGdata(UBX_ESF_ALG_data_t ubxDataStruct)
-{
-  Serial.println();
-
-  Serial.print(F("TOW: ")); // Print the Time Of Week
-  unsigned long iTOW = ubxDataStruct.iTOW; // iTOW is in milliseconds
-  Serial.print(iTOW);
-  Serial.print(F(" (ms)"));
-
-  Serial.print(F(" Roll: ")); // Print selected data
-  Serial.print((float)ubxDataStruct.roll / 100.0, 2); // Convert roll to degrees
-
-  Serial.print(F(" Pitch: "));
-  Serial.print((float)ubxDataStruct.pitch / 100.0, 2); // Convert pitch to degrees
-
-  Serial.print(F(" Yaw: "));
-  Serial.print((float)ubxDataStruct.yaw / 100.0, 2); // Convert yaw to degrees
-
-  Serial.println(F(" (Degrees)"));
-}
-
-// Callback: printESFINSdata will be called when new ESF INS data arrives
-// See u-blox_structs.h for the full definition of UBX_ESF_INS_data_t
-void printESFINSdata(UBX_ESF_INS_data_t ubxDataStruct)
-{
-  Serial.print(F("xAccel: ")); // Print selected data
-  Serial.print(ubxDataStruct.xAccel);
-
-  Serial.print(F(" yAccel: "));
-  Serial.print(ubxDataStruct.yAccel);
-
-  Serial.print(F(" zAccel: "));
-  Serial.print(ubxDataStruct.zAccel);
-
-  Serial.println(F(" (m/s^2)"));
-}
-
-// Callback: printESFMEASdata will be called when new ESF MEAS data arrives
-// See u-blox_structs.h for the full definition of UBX_ESF_MEAS_data_t
-// and UBX_ESF_MEAS_sensorData_t
-void printESFMEASdata(UBX_ESF_MEAS_data_t ubxDataStruct)
-{
-  Serial.println();
-
-  Serial.print(F("id: ")); // Print selected data
-  Serial.print(ubxDataStruct.id);
-
-  Serial.print(F(" numMeas: "));
-  Serial.println(ubxDataStruct.flags.bits.numMeas);
-
-  for (uint8_t num = 0; num < ubxDataStruct.flags.bits.numMeas; num++) // For each sensor
-  {
-    Serial.print(F("Sensor "));
-    Serial.print(num);
-
-    UBX_ESF_MEAS_sensorData_t sensorData;
-    myGNSS.getSensorFusionMeasurement(&sensorData, ubxDataStruct, num); // Extract the data for one sensor
-
-    Serial.print(F(": Type: "));
-    Serial.print(sensorData.data.bits.dataType);
-    Serial.print(F(" Data: "));
-    Serial.println(sensorData.data.bits.dataField);
-  }
-}
-
-// Callback: printESFSTATUSdata will be called when new ESF STATUS data arrives
-// See u-blox_structs.h for the full definition of UBX_ESF_STATUS_data_t
-// and UBX_ESF_STATUS_sensorStatus_t
-void printESFSTATUSdata(UBX_ESF_STATUS_data_t ubxDataStruct)
-{
-  Serial.print(F("fusionMode: ")); // Print selected data
-  Serial.print(ubxDataStruct.fusionMode);
-
-  Serial.print(F(" numSens: "));
-  Serial.println(ubxDataStruct.numSens);
-
-  for (uint8_t num = 0; num < ubxDataStruct.numSens; num++) // For each sensor
-  {
-    Serial.print(F("Sensor "));
-    Serial.print(num);
-
-    UBX_ESF_STATUS_sensorStatus_t sensorStatus;
-    myGNSS.getSensorFusionStatus(&sensorStatus, ubxDataStruct, num); // Extract the data for one sensor
-
-    Serial.print(F(": Type: "));
-    Serial.print(sensorStatus.sensStatus1.bits.type);
-    Serial.print(F(" Used: "));
-    Serial.print(sensorStatus.sensStatus1.bits.used);
-    Serial.print(F(" Ready: "));
-    Serial.print(sensorStatus.sensStatus1.bits.ready);
-    Serial.print(F(" Calib Status: "));
-    Serial.print(sensorStatus.sensStatus2.bits.calibStatus);
-    Serial.print(F(" Noisy: "));
-    Serial.println(sensorStatus.faults.bits.noisyMeas);
-  }
-}
-
-void setup()
-{
-  Serial.begin(115200);
-  while (!Serial); //Wait for user to open terminal
-  Serial.println(F("SparkFun u-blox Example"));
-
-  Wire.begin();
-
-  //myGNSS.enableDebugging(); // Uncomment this line to enable debug messages on Serial
-
-  if (myGNSS.begin() == false) //Connect to the u-blox module using Wire port
-  {
-    Serial.println(F("u-blox GNSS not detected at default I2C address. Please check wiring. Freezing."));
-    while (1);
-  }
-
-  myGNSS.setI2COutput(COM_TYPE_UBX); //Set the I2C port to output UBX only (turn off NMEA noise)
-  myGNSS.saveConfigSelective(VAL_CFG_SUBSEC_IOPORT); //Save (only) the communications port settings to flash and BBR
-
-  myGNSS.setNavigationFrequency(1); //Produce one solution per second
-  myGNSS.setHNRNavigationRate(1); //Set the High Navigation Rate to 1Hz
-
-  myGNSS.setI2CpollingWait(50); //Allow checkUblox to poll I2C data every 50ms to keep up with the ESF MEAS messages
-
-  if (myGNSS.setAutoESFALGcallback(&printESFALGdata) == true) // Enable automatic ESF ALG messages with callback to printESFALGdata
-    Serial.println(F("setAutoESFALGcallback successful"));
-
-  if (myGNSS.setAutoESFINScallback(&printESFINSdata) == true) // Enable automatic ESF INS messages with callback to printESFINSdata
-    Serial.println(F("setAutoESFINScallback successful"));
-
-  if (myGNSS.setAutoESFMEAScallback(&printESFMEASdata) == true) // Enable automatic ESF MEAS messages with callback to printESFMEASdata
-    Serial.println(F("setAutoESFMEAScallback successful"));
-
-  if (myGNSS.setAutoESFSTATUScallback(&printESFSTATUSdata) == true) // Enable automatic ESF STATUS messages with callback to printESFSTATUSdata
-    Serial.println(F("setAutoESFSTATUScallback successful"));
-}
-
-void loop()
-{
-  myGNSS.checkUblox(); // Check for the arrival of new data and process it.
-  myGNSS.checkCallbacks(); // Check if any callbacks are waiting to be processed.
-
-  Serial.print(".");
-  delay(25);
-}
diff --git a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Callbacks/CallbackExample6_RAWX/CallbackExample6_RAWX.ino b/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Callbacks/CallbackExample6_RAWX/CallbackExample6_RAWX.ino
deleted file mode 100644
index 2461ccc..0000000
--- a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Callbacks/CallbackExample6_RAWX/CallbackExample6_RAWX.ino
+++ /dev/null
@@ -1,107 +0,0 @@
-/*
-  Configuring the GNSS to automatically send RXM RZWX reports over I2C and display them using a callback
-  By: Paul Clark
-  SparkFun Electronics
-  Date: March 11th, 2021
-  License: MIT. See license file for more information but you can
-  basically do whatever you want with this code.
-
-  This example shows how to configure the u-blox GNSS to send RXM RAWX reports automatically
-  and access the data via a callback. No more polling!
-
-  Feel like supporting open source hardware?
-  Buy a board from SparkFun!
-  ZED-F9P RTK2: https://www.sparkfun.com/products/15136
-
-  Hardware Connections:
-  Plug a Qwiic cable into the GPS and a BlackBoard
-  If you don't have a platform with a Qwiic connection use the SparkFun Qwiic Breadboard Jumper (https://www.sparkfun.com/products/14425)
-  Open the serial monitor at 115200 baud to see the output
-*/
-
-#include <Wire.h> //Needed for I2C to GPS
-
-#include <SparkFun_u-blox_GNSS_Arduino_Library.h> //http://librarymanager/All#SparkFun_u-blox_GNSS
-SFE_UBLOX_GNSS myGNSS;
-
-// Callback: newRAWX will be called when new RXM RAWX data arrives
-// See u-blox_structs.h for the full definition of UBX_RXMRAWX_data_t
-//         _____  You can use any name you like for the callback. Use the same name when you call setAutoRXMRAWXcallback
-//        /             _____  This _must_ be UBX_RXM_RAWX_data_t
-//        |            /                _____ You can use any name you like for the struct
-//        |            |               /
-//        |            |               |
-void newRAWX(UBX_RXM_RAWX_data_t ubxDataStruct)
-{
-  Serial.println();
-
-  Serial.print(F("New RAWX data received. It contains "));
-  Serial.print(ubxDataStruct.header.numMeas); // Print numMeas (Number of measurements / blocks)
-  Serial.println(F(" data blocks:"));
-
-  for (uint8_t block = 0; block < ubxDataStruct.header.numMeas; block++) // For each block
-  {
-    Serial.print(F("GNSS ID: "));
-    if (ubxDataStruct.blocks[block].gnssId < 100) Serial.print(F(" ")); // Align the gnssId
-    if (ubxDataStruct.blocks[block].gnssId < 10) Serial.print(F(" ")); // Align the gnssId
-    Serial.print(ubxDataStruct.blocks[block].gnssId);
-    Serial.print(F("  SV ID: "));
-    if (ubxDataStruct.blocks[block].svId < 100) Serial.print(F(" ")); // Align the svId
-    if (ubxDataStruct.blocks[block].svId < 10) Serial.print(F(" ")); // Align the svId
-    Serial.print(ubxDataStruct.blocks[block].svId);
-
-    if (sizeof(double) == 8) // Check if our processor supports 64-bit double
-    {
-      // Convert prMes from uint8_t[8] to 64-bit double
-      // prMes is little-endian
-      double pseudorange;
-      memcpy(&pseudorange, &ubxDataStruct.blocks[block].prMes, 8);
-      Serial.print(F("  PR: "));
-      Serial.print(pseudorange, 3);
-
-      // Convert cpMes from uint8_t[8] to 64-bit double
-      // cpMes is little-endian
-      double carrierPhase;
-      memcpy(&carrierPhase, &ubxDataStruct.blocks[block].cpMes, 8);
-      Serial.print(F(" m  CP: "));
-      Serial.print(carrierPhase, 3);
-      Serial.print(F(" cycles"));
-    }
-    Serial.println();
-  }
-}
-
-void setup()
-{
-  Serial.begin(115200);
-  while (!Serial); //Wait for user to open terminal
-  Serial.println("SparkFun u-blox Example");
-
-  Wire.begin();
-
-  //myGNSS.enableDebugging(); // Uncomment this line to enable helpful debug messages on Serial
-
-  myGNSS.disableUBX7Fcheck(); // RAWX data can legitimately contain 0x7F, so we need to disable the "7F" check in checkUbloxI2C
-
-  if (myGNSS.begin() == false) //Connect to the u-blox module using Wire port
-  {
-    Serial.println(F("u-blox GNSS not detected at default I2C address. Please check wiring. Freezing."));
-    while (1);
-  }
-
-  myGNSS.setI2COutput(COM_TYPE_UBX); //Set the I2C port to output UBX only (turn off NMEA noise)
-  myGNSS.saveConfigSelective(VAL_CFG_SUBSEC_IOPORT); //Save (only) the communications port settings to flash and BBR
-
-  myGNSS.setNavigationFrequency(1); //Produce one solution per second (RAWX produces a _lot_ of data!)
-
-  myGNSS.setAutoRXMRAWXcallback(&newRAWX); // Enable automatic RXM RAWX messages with callback to newRAWX
-}
-
-void loop()
-{
-  myGNSS.checkUblox(); // Check for the arrival of new data and process it.
-  myGNSS.checkCallbacks(); // Check if any callbacks are waiting to be processed.
-
-  Serial.print(".");
-  delay(50);
-}
diff --git a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Data_Logging/DataLoggingExample1_NAV_PVT/DataLoggingExample1_NAV_PVT.ino b/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Data_Logging/DataLoggingExample1_NAV_PVT/DataLoggingExample1_NAV_PVT.ino
deleted file mode 100644
index 0f09f64..0000000
--- a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Data_Logging/DataLoggingExample1_NAV_PVT/DataLoggingExample1_NAV_PVT.ino
+++ /dev/null
@@ -1,230 +0,0 @@
-/*
-  Configuring the GNSS to automatically send NAV PVT reports over I2C and log them to file on SD card
-  By: Paul Clark
-  SparkFun Electronics
-  Date: December 30th, 2020
-  License: MIT. See license file for more information but you can
-  basically do whatever you want with this code.
-
-  This example shows how to configure the u-blox GNSS to send NAV PVT reports automatically
-  and log the data to SD card in UBX format.
-
-  This code is intended to be run on the MicroMod Data Logging Carrier Board using the Artemis Processor
-  but can be adapted by changing the chip select pin and SPI definitions:
-  https://www.sparkfun.com/products/16829
-  https://www.sparkfun.com/products/16401
-
-  Hardware Connections:
-  Please see: https://learn.sparkfun.com/tutorials/micromod-data-logging-carrier-board-hookup-guide
-  Insert the Artemis Processor into the MicroMod Data Logging Carrier Board and secure with the screw.
-  Connect your GNSS breakout to the Carrier Board using a Qwiic cable.
-  Connect an antenna to your GNSS board if required.
-  Insert a formatted micro-SD card into the socket on the Carrier Board.
-  Connect the Carrier Board to your computer using a USB-C cable.
-  Ensure you have the SparkFun Apollo3 boards installed: http://boardsmanager/All#SparkFun_Apollo3
-  This code has been tested using version 1.2.1 of the Apollo3 boards on Arduino IDE 1.8.13.
-  Select "SparkFun Artemis MicroMod" as the board type.
-  Press upload to upload the code onto the Artemis.
-  Open the Serial Monitor at 115200 baud to see the output.
-
-  To minimise I2C bus errors, it is a good idea to open the I2C pull-up split pad links on
-  both the MicroMod Data Logging Carrier Board and the u-blox module breakout.
-
-  Data is logged in u-blox UBX format. Please see the u-blox protocol specification for more details.
-  You can replay and analyze the data using u-center:
-  https://www.u-blox.com/en/product/u-center
-
-  Feel like supporting open source hardware?
-  Buy a board from SparkFun!
-  ZED-F9P RTK2: https://www.sparkfun.com/products/15136
-  NEO-M8P RTK: https://www.sparkfun.com/products/15005
-  SAM-M8Q: https://www.sparkfun.com/products/15106
-
-*/
-
-#include <SPI.h>
-#include <SD.h>
-#include <Wire.h> //Needed for I2C to GNSS
-
-#include <SparkFun_u-blox_GNSS_Arduino_Library.h> //Click here to get the library: http://librarymanager/All#SparkFun_u-blox_GNSS
-SFE_UBLOX_GNSS myGNSS;
-
-File myFile; //File that all GNSS data is written to
-
-#define sdChipSelect CS //Primary SPI Chip Select is CS for the MicroMod Artemis Processor. Adjust for your processor if necessary.
-
-#define packetLength 100 // NAV PVT is 92 + 8 bytes in length (including the sync chars, class, id, length and checksum bytes)
-
-// Callback: printPVTdata will be called when new NAV PVT data arrives
-// See u-blox_structs.h for the full definition of UBX_NAV_PVT_data_t
-//         _____  You can use any name you like for the callback. Use the same name when you call setAutoPVTcallback
-//        /                  _____  This _must_ be UBX_NAV_PVT_data_t
-//        |                 /               _____ You can use any name you like for the struct
-//        |                 |              /
-//        |                 |              |
-void printPVTdata(UBX_NAV_PVT_data_t ubxDataStruct)
-{
-    Serial.println();
-
-    Serial.print(F("Time: ")); // Print the time
-    uint8_t hms = ubxDataStruct.hour; // Print the hours
-    if (hms < 10) Serial.print(F("0")); // Print a leading zero if required
-    Serial.print(hms);
-    Serial.print(F(":"));
-    hms = ubxDataStruct.min; // Print the minutes
-    if (hms < 10) Serial.print(F("0")); // Print a leading zero if required
-    Serial.print(hms);
-    Serial.print(F(":"));
-    hms = ubxDataStruct.sec; // Print the seconds
-    if (hms < 10) Serial.print(F("0")); // Print a leading zero if required
-    Serial.print(hms);
-    Serial.print(F("."));
-    unsigned long millisecs = ubxDataStruct.iTOW % 1000; // Print the milliseconds
-    if (millisecs < 100) Serial.print(F("0")); // Print the trailing zeros correctly
-    if (millisecs < 10) Serial.print(F("0"));
-    Serial.print(millisecs);
-
-    long latitude = ubxDataStruct.lat; // Print the latitude
-    Serial.print(F(" Lat: "));
-    Serial.print(latitude);
-
-    long longitude = ubxDataStruct.lon; // Print the longitude
-    Serial.print(F(" Long: "));
-    Serial.print(longitude);
-    Serial.print(F(" (degrees * 10^-7)"));
-
-    long altitude = ubxDataStruct.hMSL; // Print the height above mean sea level
-    Serial.print(F(" Height above MSL: "));
-    Serial.print(altitude);
-    Serial.println(F(" (mm)"));
-}
-
-void setup()
-{
-  Serial.begin(115200);
-  while (!Serial); //Wait for user to open terminal
-  Serial.println("SparkFun u-blox Example");
-
-  Wire.begin(); // Start I2C communication with the GNSS
-
-#if defined(AM_PART_APOLLO3)
-  Wire.setPullups(0); // On the Artemis, we can disable the internal I2C pull-ups too to help reduce bus errors
-#endif
-
-  while (Serial.available()) // Make sure the Serial buffer is empty
-  {
-    Serial.read();
-  }
-
-  Serial.println(F("Press any key to start logging."));
-
-  while (!Serial.available()) // Wait for the user to press a key
-  {
-    ; // Do nothing
-  }
-
-  delay(100); // Wait, just in case multiple characters were sent
-
-  while (Serial.available()) // Empty the Serial buffer
-  {
-    Serial.read();
-  }
-
-  Serial.println("Initializing SD card...");
-
-  // See if the card is present and can be initialized:
-  if (!SD.begin(sdChipSelect))
-  {
-    Serial.println("Card failed, or not present. Freezing...");
-    // don't do anything more:
-    while (1);
-  }
-  Serial.println("SD card initialized.");
-
-  // Create or open a file called "NAV_PVT.ubx" on the SD card.
-  // If the file already exists, the new data is appended to the end of the file.
-  myFile = SD.open("NAV_PVT.ubx", FILE_WRITE);
-  if(!myFile)
-  {
-    Serial.println(F("Failed to create UBX data file! Freezing..."));
-    while (1);
-  }
-
-  //myGNSS.enableDebugging(); // Uncomment this line to enable helpful GNSS debug messages on Serial
-
-  // NAV PVT messages are 100 bytes long.
-  // In this example, the data will arrive no faster than one message per second.
-  // So, setting the file buffer size to 301 bytes should be more than adequate.
-  // I.e. room for three messages plus an empty tail byte.
-  myGNSS.setFileBufferSize(301); // setFileBufferSize must be called _before_ .begin
-
-  if (myGNSS.begin() == false) //Connect to the u-blox module using Wire port
-  {
-    Serial.println(F("u-blox GNSS not detected at default I2C address. Please check wiring. Freezing..."));
-    while (1);
-  }
-
-  // Uncomment the next line if you want to reset your module back to the default settings with 1Hz navigation rate
-  // (This will also disable any "auto" messages that were enabled and saved by other examples and reduce the load on the I2C bus)
-  //myGNSS.factoryDefault(); delay(5000);
-
-  myGNSS.setI2COutput(COM_TYPE_UBX); //Set the I2C port to output UBX only (turn off NMEA noise)
-  myGNSS.saveConfigSelective(VAL_CFG_SUBSEC_IOPORT); //Save (only) the communications port settings to flash and BBR
-
-  myGNSS.setNavigationFrequency(1); //Produce one navigation solution per second
-
-  myGNSS.setAutoPVTcallback(&printPVTdata); // Enable automatic NAV PVT messages with callback to printPVTdata
-
-  myGNSS.logNAVPVT(); // Enable NAV PVT data logging
-
-  Serial.println(F("Press any key to stop logging."));
-}
-
-void loop()
-{
-  myGNSS.checkUblox(); // Check for the arrival of new data and process it.
-  myGNSS.checkCallbacks(); // Check if any callbacks are waiting to be processed.
-
-  if (myGNSS.fileBufferAvailable() >= packetLength) // Check to see if a new packetLength-byte NAV PVT message has been stored
-  {
-    uint8_t myBuffer[packetLength]; // Create our own buffer to hold the data while we write it to SD card
-
-    myGNSS.extractFileBufferData((uint8_t *)&myBuffer, packetLength); // Extract exactly packetLength bytes from the UBX file buffer and put them into myBuffer
-
-    myFile.write(myBuffer, packetLength); // Write exactly packetLength bytes from myBuffer to the ubxDataFile on the SD card
-
-    //printBuffer(myBuffer); // Uncomment this line to print the data as Hexadecimal bytes
-  }
-
-  if (Serial.available()) // Check if the user wants to stop logging
-  {
-    myFile.close(); // Close the data file
-    Serial.println(F("Logging stopped. Freezing..."));
-    while(1); // Do nothing more
-  }
-
-  Serial.print(".");
-  delay(50);
-}
-
-// Print the buffer contents as Hexadecimal bytes
-// You should see:
-// SYNC CHAR 1: 0xB5
-// SYNC CHAR 2: 0x62
-// CLASS: 0x01 for NAV
-// ID: 0x07 for PVT
-// LENGTH: 2-bytes Little Endian (0x5C00 = 92 bytes for NAV PVT)
-// PAYLOAD: LENGTH bytes
-// CHECKSUM_A
-// CHECKSUM_B
-// Please see the u-blox protocol specification for more details
-void printBuffer(uint8_t *ptr)
-{
-  for (int i = 0; i < packetLength; i++)
-  {
-    if (ptr[i] < 16) Serial.print("0"); // Print a leading zero if required
-    Serial.print(ptr[i], HEX); // Print the byte as Hexadecimal
-    Serial.print(" ");
-  }
-  Serial.println();
-}
diff --git a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Data_Logging/DataLoggingExample2_TIM_TM2/DataLoggingExample2_TIM_TM2.ino b/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Data_Logging/DataLoggingExample2_TIM_TM2/DataLoggingExample2_TIM_TM2.ino
deleted file mode 100644
index 05417ae..0000000
--- a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Data_Logging/DataLoggingExample2_TIM_TM2/DataLoggingExample2_TIM_TM2.ino
+++ /dev/null
@@ -1,241 +0,0 @@
-/*
-  Configuring the GNSS to automatically send TIM TM2 reports over I2C and log them to file on SD card
-  By: Paul Clark
-  SparkFun Electronics
-  Date: December 30th, 2020
-  License: MIT. See license file for more information but you can
-  basically do whatever you want with this code.
-
-  This example shows how to configure the u-blox GNSS to send TIM TM2 reports automatically
-  and log the data to SD card in UBX format.
-
-  This code is intended to be run on the MicroMod Data Logging Carrier Board using the Artemis Processor
-  but can be adapted by changing the chip select pin and SPI definitions:
-  https://www.sparkfun.com/products/16829
-  https://www.sparkfun.com/products/16401
-
-  Hardware Connections:
-  Please see: https://learn.sparkfun.com/tutorials/micromod-data-logging-carrier-board-hookup-guide
-  Insert the Artemis Processor into the MicroMod Data Logging Carrier Board and secure with the screw.
-  Connect your GNSS breakout to the Carrier Board using a Qwiic cable.
-  Connect an antenna to your GNSS board if required.
-  Insert a formatted micro-SD card into the socket on the Carrier Board.
-  Connect the Carrier Board to your computer using a USB-C cable.
-  Ensure you have the SparkFun Apollo3 boards installed: http://boardsmanager/All#SparkFun_Apollo3
-  This code has been tested using version 1.2.1 of the Apollo3 boards on Arduino IDE 1.8.13.
-  Select "SparkFun Artemis MicroMod" as the board type.
-  Press upload to upload the code onto the Artemis.
-  Open the Serial Monitor at 115200 baud to see the output.
-
-  To minimise I2C bus errors, it is a good idea to open the I2C pull-up split pad links on
-  both the MicroMod Data Logging Carrier Board and the u-blox module breakout.
-
-  Connecting the PPS (Pulse Per Second) breakout pin to the INT (Interrupt) pin with a jumper wire
-  will cause a TIM TM2 message to be produced once per second. You can then study the timing of the
-  pulse edges with nanosecond resolution!
-
-  Note: TIM TM2 can only capture the timing of one rising edge and one falling edge per
-  navigation solution. So with setNavigationFrequency set to 1Hz, we can only see the timing
-  of one rising and one falling edge per second. If the frequency of the signal on the INT pin
-  is higher than 1Hz, we will only be able to see the timing of the most recent edges.
-  However, the module can count the number of rising edges too, at rates faster than the navigation rate.
-
-  TIM TM2 messages are only produced when a rising or falling edge is detected on the INT pin.
-  If you disconnect your PPS to INT jumper wire, the messages will stop.
-
-  Data is logged in u-blox UBX format. Please see the u-blox protocol specification for more details.
-  You can replay and analyze the data using u-center:
-  https://www.u-blox.com/en/product/u-center
-
-  Feel like supporting open source hardware?
-  Buy a board from SparkFun!
-  ZED-F9P RTK2: https://www.sparkfun.com/products/15136
-  NEO-M8P RTK: https://www.sparkfun.com/products/15005
-  NEO-M9N: https://www.sparkfun.com/products/17285
-
-*/
-
-#include <SPI.h>
-#include <SD.h>
-#include <Wire.h> //Needed for I2C to GNSS
-
-#include <SparkFun_u-blox_GNSS_Arduino_Library.h> //Click here to get the library: http://librarymanager/All#SparkFun_u-blox_GNSS
-SFE_UBLOX_GNSS myGNSS;
-
-File myFile; //File that all GNSS data is written to
-
-#define sdChipSelect CS //Primary SPI Chip Select is CS for the MicroMod Artemis Processor. Adjust for your processor if necessary.
-
-#define packetLength 36 // TIM TM2 is 28 + 8 bytes in length (including the sync chars, class, id, length and checksum bytes)
-
-int dotsPrinted = 0; // Print dots in rows of 50 while waiting for a TIM TM2 message
-
-// Callback: printTIMTM2data will be called when new TIM TM2 data arrives
-// See u-blox_structs.h for the full definition of UBX_TIM_TM2_data_t
-//         _____  You can use any name you like for the callback. Use the same name when you call setAutoTIMTM2callback
-//        /                  _____  This _must_ be UBX_TIM_TM2_data_t
-//        |                 /                   _____ You can use any name you like for the struct
-//        |                 |                  /
-//        |                 |                  |
-void printTIMTM2data(UBX_TIM_TM2_data_t ubxDataStruct)
-{
-  Serial.println();
-
-  Serial.print(F("newFallingEdge: ")); // 1 if a new falling edge was detected
-  Serial.print(ubxDataStruct.flags.bits.newFallingEdge);
-
-  Serial.print(F(" newRisingEdge: ")); // 1 if a new rising edge was detected
-  Serial.print(ubxDataStruct.flags.bits.newRisingEdge);
-
-  Serial.print(F(" Rising Edge Counter: ")); // Rising edge counter
-  Serial.print(ubxDataStruct.count);
-
-  Serial.print(F(" towMsR: ")); // Time Of Week of rising edge (ms)
-  Serial.print(ubxDataStruct.towMsR);
-
-  Serial.print(F(" towSubMsR: ")); // Millisecond fraction of Time Of Week of rising edge in nanoseconds
-  Serial.print(ubxDataStruct.towSubMsR);
-
-  Serial.print(F(" towMsF: ")); // Time Of Week of falling edge (ms)
-  Serial.print(ubxDataStruct.towMsF);
-
-  Serial.print(F(" towSubMsF: ")); // Millisecond fraction of Time Of Week of falling edge in nanoseconds
-  Serial.println(ubxDataStruct.towSubMsF);
-
-  dotsPrinted = 0; // Reset dotsPrinted
-}
-
-void setup()
-{
-  Serial.begin(115200);
-  while (!Serial); //Wait for user to open terminal
-  Serial.println("SparkFun u-blox Example");
-
-  Wire.begin(); // Start I2C communication with the GNSS
-
-#if defined(AM_PART_APOLLO3)
-  Wire.setPullups(0); // On the Artemis, we can disable the internal I2C pull-ups too to help reduce bus errors
-#endif
-
-  while (Serial.available()) // Make sure the Serial buffer is empty
-  {
-    Serial.read();
-  }
-
-  Serial.println(F("Press any key to start logging."));
-
-  while (!Serial.available()) // Wait for the user to press a key
-  {
-    ; // Do nothing
-  }
-
-  delay(100); // Wait, just in case multiple characters were sent
-
-  while (Serial.available()) // Empty the Serial buffer
-  {
-    Serial.read();
-  }
-
-  Serial.println("Initializing SD card...");
-
-  // See if the card is present and can be initialized:
-  if (!SD.begin(sdChipSelect))
-  {
-    Serial.println("Card failed, or not present. Freezing...");
-    // don't do anything more:
-    while (1);
-  }
-  Serial.println("SD card initialized.");
-
-  // Create or open a file called "TIM_TM2.ubx" on the SD card.
-  // If the file already exists, the new data is appended to the end of the file.
-  myFile = SD.open("TIM_TM2.ubx", FILE_WRITE);
-  if(!myFile)
-  {
-    Serial.println(F("Failed to create UBX data file! Freezing..."));
-    while (1);
-  }
-
-  //myGNSS.enableDebugging(); // Uncomment this line to enable helpful GNSS debug messages on Serial
-
-  // TIM TM2 messages are 36 bytes long.
-  // In this example, the data will arrive no faster than one message per second.
-  // So, setting the file buffer size to 109 bytes should be more than adequate.
-  // I.e. room for three messages plus an empty tail byte.
-  myGNSS.setFileBufferSize(109); // setFileBufferSize must be called _before_ .begin
-
-  if (myGNSS.begin() == false) //Connect to the u-blox module using Wire port
-  {
-    Serial.println(F("u-blox GNSS not detected at default I2C address. Please check wiring. Freezing..."));
-    while (1);
-  }
-
-  // Uncomment the next line if you want to reset your module back to the default settings with 1Hz navigation rate
-  // (This will also disable any "auto" messages that were enabled and saved by other examples and reduce the load on the I2C bus)
-  //myGNSS.factoryDefault(); delay(5000);
-
-  myGNSS.setI2COutput(COM_TYPE_UBX); //Set the I2C port to output UBX only (turn off NMEA noise)
-  myGNSS.saveConfigSelective(VAL_CFG_SUBSEC_IOPORT); //Save (only) the communications port settings to flash and BBR
-
-  myGNSS.setNavigationFrequency(1); //Produce one navigation solution per second
-
-  myGNSS.setAutoTIMTM2callback(&printTIMTM2data); // Enable automatic TIM TM2 messages with callback to printTIMTM2data
-
-  myGNSS.logTIMTM2(); // Enable TIM TM2 data logging
-
-  Serial.println(F("Press any key to stop logging."));
-}
-
-void loop()
-{
-  myGNSS.checkUblox(); // Check for the arrival of new data and process it.
-  myGNSS.checkCallbacks(); // Check if any callbacks are waiting to be processed.
-
-  if (myGNSS.fileBufferAvailable() >= packetLength) // Check to see if a new packetLength-byte TIM TM2 message has been stored
-  {
-    uint8_t myBuffer[packetLength]; // Create our own buffer to hold the data while we write it to SD card
-
-    myGNSS.extractFileBufferData((uint8_t *)&myBuffer, packetLength); // Extract exactly packetLength bytes from the UBX file buffer and put them into myBuffer
-
-    myFile.write(myBuffer, packetLength); // Write exactly packetLength bytes from myBuffer to the ubxDataFile on the SD card
-
-    //printBuffer(myBuffer); // Uncomment this line to print the data
-  }
-
-  if (Serial.available()) // Check if the user wants to stop logging
-  {
-    myFile.close(); // Close the data file
-    Serial.println(F("Logging stopped. Freezing..."));
-    while(1); // Do nothing more
-  }
-
-  Serial.print("."); // Print dots in rows of 50
-  delay(50);
-  if (++dotsPrinted > 50)
-  {
-    Serial.println();
-    dotsPrinted = 0;
-  }
-}
-
-// Print the buffer contents as Hexadecimal
-// You should see:
-// SYNC CHAR 1: 0xB5
-// SYNC CHAR 2: 0x62
-// CLASS: 0x0D for TIM
-// ID: 0x03 for TM2
-// LENGTH: 2-bytes Little Endian (0x1C00 = 28 bytes for TIM TM2)
-// PAYLOAD: LENGTH bytes
-// CHECKSUM_A
-// CHECKSUM_B
-// Please see the u-blox protocol specification for more details
-void printBuffer(uint8_t *ptr)
-{
-  for (int i = 0; i < packetLength; i++)
-  {
-    if (ptr[i] < 16) Serial.print("0"); // Print a leading zero if required
-    Serial.print(ptr[i], HEX); // Print the byte as Hexadecimal
-    Serial.print(" ");
-  }
-  Serial.println();
-}
diff --git a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Data_Logging/DataLoggingExample3_RXM_SFRBX_and_RAWX/DataLoggingExample3_RXM_SFRBX_and_RAWX.ino b/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Data_Logging/DataLoggingExample3_RXM_SFRBX_and_RAWX/DataLoggingExample3_RXM_SFRBX_and_RAWX.ino
deleted file mode 100644
index 952f840..0000000
--- a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Data_Logging/DataLoggingExample3_RXM_SFRBX_and_RAWX/DataLoggingExample3_RXM_SFRBX_and_RAWX.ino
+++ /dev/null
@@ -1,273 +0,0 @@
-/*
-  Configuring the GNSS to automatically send RXM SFRBX and RAWX reports over I2C and log them to file on SD card
-  By: Paul Clark
-  SparkFun Electronics
-  Date: December 30th, 2020
-  License: MIT. See license file for more information but you can
-  basically do whatever you want with this code.
-
-  This example shows how to configure the u-blox GNSS to send RXM SFRBX and RAWX reports automatically
-  and log the data to SD card in UBX format.
-
-  ** Please note: this example will only work on u-blox ADR or High Precision GNSS or Time Sync products **
-
-  ** Please note: this example will only work on processors like the Artemis which have plenty of RAM available **
-
-  Data is logged in u-blox UBX format. Please see the u-blox protocol specification for more details.
-  You can replay and analyze the data using u-center:
-  https://www.u-blox.com/en/product/u-center
-  Or you can use (e.g.) RTKLIB to analyze the data and extract your precise location or produce
-  Post-Processed Kinematic data:
-  https://rtklibexplorer.wordpress.com/
-  http://rtkexplorer.com/downloads/rtklib-code/
-
-  This code is intended to be run on the MicroMod Data Logging Carrier Board using the Artemis Processor
-  but can be adapted by changing the chip select pin and SPI definitions:
-  https://www.sparkfun.com/products/16829
-  https://www.sparkfun.com/products/16401
-
-  Hardware Connections:
-  Please see: https://learn.sparkfun.com/tutorials/micromod-data-logging-carrier-board-hookup-guide
-  Insert the Artemis Processor into the MicroMod Data Logging Carrier Board and secure with the screw.
-  Connect your GNSS breakout to the Carrier Board using a Qwiic cable.
-  Connect an antenna to your GNSS board if required.
-  Insert a formatted micro-SD card into the socket on the Carrier Board.
-  Connect the Carrier Board to your computer using a USB-C cable.
-  Ensure you have the SparkFun Apollo3 boards installed: http://boardsmanager/All#SparkFun_Apollo3
-  This code has been tested using version 1.2.1 of the Apollo3 boards on Arduino IDE 1.8.13.
-  Select "SparkFun Artemis MicroMod" as the board type.
-  Press upload to upload the code onto the Artemis.
-  Open the Serial Monitor at 115200 baud to see the output.
-
-  To minimise I2C bus errors, it is a good idea to open the I2C pull-up split pad links on
-  both the MicroMod Data Logging Carrier Board and the u-blox module breakout.
-
-  Feel like supporting open source hardware?
-  Buy a board from SparkFun!
-  ZED-F9P RTK2: https://www.sparkfun.com/products/15136
-  NEO-M8P RTK: https://www.sparkfun.com/products/15005
-*/
-
-#include <SPI.h>
-#include <SD.h>
-#include <Wire.h> //Needed for I2C to GNSS
-
-#include <SparkFun_u-blox_GNSS_Arduino_Library.h> //Click here to get the library: http://librarymanager/All#SparkFun_u-blox_GNSS
-SFE_UBLOX_GNSS myGNSS;
-
-File myFile; //File that all GNSS data is written to
-
-#define sdChipSelect CS //Primary SPI Chip Select is CS for the MicroMod Artemis Processor. Adjust for your processor if necessary.
-
-#define sdWriteSize 512 // Write data to the SD card in blocks of 512 bytes
-#define fileBufferSize 16384 // Allocate 16KBytes of RAM for UBX message storage
-
-unsigned long lastPrint; // Record when the last Serial print took place
-
-// Note: we'll keep a count of how many SFRBX and RAWX messages arrive - but the count will not be completely accurate.
-// If two or more SFRBX messages arrive together as a group and are processed by one call to checkUblox, the count will
-// only increase by one.
-
-int numSFRBX = 0; // Keep count of how many SFRBX message groups have been received (see note above)
-int numRAWX = 0; // Keep count of how many RAWX message groups have been received (see note above)
-
-// Callback: newSFRBX will be called when new RXM SFRBX data arrives
-// See u-blox_structs.h for the full definition of UBX_RXMSFRBX_data_t
-//         _____  You can use any name you like for the callback. Use the same name when you call setAutoRXMSFRBXcallback
-//        /                  _____  This _must_ be UBX_RXM_SFRBX_data_t
-//        |                 /                   _____ You can use any name you like for the struct
-//        |                 |                  /
-//        |                 |                  |
-void newSFRBX(UBX_RXM_SFRBX_data_t ubxDataStruct)
-{
-  numSFRBX++; // Increment the count
-}
-
-// Callback: newRAWX will be called when new RXM RAWX data arrives
-// See u-blox_structs.h for the full definition of UBX_RXMRAWX_data_t
-//         _____  You can use any name you like for the callback. Use the same name when you call setAutoRXMRAWXcallback
-//        /             _____  This _must_ be UBX_RXM_RAWX_data_t
-//        |            /                _____ You can use any name you like for the struct
-//        |            |               /
-//        |            |               |
-void newRAWX(UBX_RXM_RAWX_data_t ubxDataStruct)
-{
-  numRAWX++; // Increment the count
-}
-
-void setup()
-{
-  Serial.begin(115200);
-  while (!Serial); //Wait for user to open terminal
-  Serial.println("SparkFun u-blox Example");
-
-  pinMode(LED_BUILTIN, OUTPUT); // Flash LED_BUILTIN each time we write to the SD card
-  digitalWrite(LED_BUILTIN, LOW);
-
-  Wire.begin(); // Start I2C communication
-
-#if defined(AM_PART_APOLLO3)
-  Wire.setPullups(0); // On the Artemis, we can disable the internal I2C pull-ups too to help reduce bus errors
-#endif
-
-  while (Serial.available()) // Make sure the Serial buffer is empty
-  {
-    Serial.read();
-  }
-
-  Serial.println(F("Press any key to start logging."));
-
-  while (!Serial.available()) // Wait for the user to press a key
-  {
-    ; // Do nothing
-  }
-
-  delay(100); // Wait, just in case multiple characters were sent
-
-  while (Serial.available()) // Empty the Serial buffer
-  {
-    Serial.read();
-  }
-
-  Serial.println("Initializing SD card...");
-
-  // See if the card is present and can be initialized:
-  if (!SD.begin(sdChipSelect))
-  {
-    Serial.println("Card failed, or not present. Freezing...");
-    // don't do anything more:
-    while (1);
-  }
-  Serial.println("SD card initialized.");
-
-  // Create or open a file called "RXM_RAWX.ubx" on the SD card.
-  // If the file already exists, the new data is appended to the end of the file.
-  myFile = SD.open("RXM_RAWX.ubx", FILE_WRITE);
-  if(!myFile)
-  {
-    Serial.println(F("Failed to create UBX data file! Freezing..."));
-    while (1);
-  }
-
-  //myGNSS.enableDebugging(); // Uncomment this line to enable lots of helpful GNSS debug messages on Serial
-  //myGNSS.enableDebugging(Serial, true); // Or, uncomment this line to enable only the important GNSS debug messages on Serial
-
-  myGNSS.disableUBX7Fcheck(); // RAWX data can legitimately contain 0x7F, so we need to disable the "7F" check in checkUbloxI2C
-
-  // RAWX messages can be over 2KBytes in size, so we need to make sure we allocate enough RAM to hold all the data.
-  // SD cards can occasionally 'hiccup' and a write takes much longer than usual. The buffer needs to be big enough
-  // to hold the backlog of data if/when this happens.
-  // getMaxFileBufferAvail will tell us the maximum number of bytes which the file buffer has contained.
-  myGNSS.setFileBufferSize(fileBufferSize); // setFileBufferSize must be called _before_ .begin
-
-  if (myGNSS.begin() == false) //Connect to the u-blox module using Wire port
-  {
-    Serial.println(F("u-blox GNSS not detected at default I2C address. Please check wiring. Freezing..."));
-    while (1);
-  }
-
-  // Uncomment the next line if you want to reset your module back to the default settings with 1Hz navigation rate
-  // (This will also disable any "auto" messages that were enabled and saved by other examples and reduce the load on the I2C bus)
-  //myGNSS.factoryDefault(); delay(5000);
-
-  myGNSS.setI2COutput(COM_TYPE_UBX); //Set the I2C port to output UBX only (turn off NMEA noise)
-  myGNSS.saveConfigSelective(VAL_CFG_SUBSEC_IOPORT); //Save (only) the communications port settings to flash and BBR
-
-  myGNSS.setNavigationFrequency(1); //Produce one navigation solution per second (that's plenty for Precise Point Positioning)
-
-  myGNSS.setAutoRXMSFRBXcallback(&newSFRBX); // Enable automatic RXM SFRBX messages with callback to newSFRBX
-
-  myGNSS.logRXMSFRBX(); // Enable RXM SFRBX data logging
-
-  myGNSS.setAutoRXMRAWXcallback(&newRAWX); // Enable automatic RXM RAWX messages with callback to newRAWX
-
-  myGNSS.logRXMRAWX(); // Enable RXM RAWX data logging
-
-  Serial.println(F("Press any key to stop logging."));
-
-  lastPrint = millis(); // Initialize lastPrint
-}
-
-void loop()
-{
-  // =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
-
-  myGNSS.checkUblox(); // Check for the arrival of new data and process it.
-  myGNSS.checkCallbacks(); // Check if any callbacks are waiting to be processed.
-
-  // =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
-
-  while (myGNSS.fileBufferAvailable() >= sdWriteSize) // Check to see if we have at least sdWriteSize waiting in the buffer
-  {
-    digitalWrite(LED_BUILTIN, HIGH); // Flash LED_BUILTIN each time we write to the SD card
-
-    uint8_t myBuffer[sdWriteSize]; // Create our own buffer to hold the data while we write it to SD card
-
-    myGNSS.extractFileBufferData((uint8_t *)&myBuffer, sdWriteSize); // Extract exactly sdWriteSize bytes from the UBX file buffer and put them into myBuffer
-
-    myFile.write(myBuffer, sdWriteSize); // Write exactly sdWriteSize bytes from myBuffer to the ubxDataFile on the SD card
-
-    // In case the SD writing is slow or there is a lot of data to write, keep checking for the arrival of new data
-    myGNSS.checkUblox(); // Check for the arrival of new data and process it.
-    myGNSS.checkCallbacks(); // Check if any callbacks are waiting to be processed.
-
-    digitalWrite(LED_BUILTIN, LOW); // Turn LED_BUILTIN off again
-  }
-
-  // =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
-
-  if (millis() > (lastPrint + 1000)) // Print the message count once per second
-  {
-    Serial.print(F("Number of message groups received: SFRBX: ")); // Print how many message groups have been received (see note above)
-    Serial.print(numSFRBX);
-    Serial.print(F(" RAWX: "));
-    Serial.println(numRAWX);
-
-    uint16_t maxBufferBytes = myGNSS.getMaxFileBufferAvail(); // Get how full the file buffer has been (not how full it is now)
-
-    //Serial.print(F("The maximum number of bytes which the file buffer has contained is: ")); // It is a fun thing to watch how full the buffer gets
-    //Serial.println(maxBufferBytes);
-
-    if (maxBufferBytes > ((fileBufferSize / 5) * 4)) // Warn the user if fileBufferSize was more than 80% full
-    {
-      Serial.println(F("Warning: the file buffer has been over 80% full. Some data may have been lost."));
-    }
-
-    lastPrint = millis(); // Update lastPrint
-  }
-
-  // =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
-
-  if (Serial.available()) // Check if the user wants to stop logging
-  {
-    uint16_t remainingBytes = myGNSS.fileBufferAvailable(); // Check if there are any bytes remaining in the file buffer
-
-    while (remainingBytes > 0) // While there is still data in the file buffer
-    {
-      digitalWrite(LED_BUILTIN, HIGH); // Flash LED_BUILTIN while we write to the SD card
-
-      uint8_t myBuffer[sdWriteSize]; // Create our own buffer to hold the data while we write it to SD card
-
-      uint16_t bytesToWrite = remainingBytes; // Write the remaining bytes to SD card sdWriteSize bytes at a time
-      if (bytesToWrite > sdWriteSize)
-      {
-        bytesToWrite = sdWriteSize;
-      }
-
-      myGNSS.extractFileBufferData((uint8_t *)&myBuffer, bytesToWrite); // Extract bytesToWrite bytes from the UBX file buffer and put them into myBuffer
-
-      myFile.write(myBuffer, bytesToWrite); // Write bytesToWrite bytes from myBuffer to the ubxDataFile on the SD card
-
-      remainingBytes -= bytesToWrite; // Decrement remainingBytes
-    }
-
-    digitalWrite(LED_BUILTIN, LOW); // Turn LED_BUILTIN off
-
-    myFile.close(); // Close the data file
-
-    Serial.println(F("Logging stopped. Freezing..."));
-    while(1); // Do nothing more
-  }
-
-  // =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
-}
diff --git a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Data_Logging/DataLoggingExample4_RXM_without_Callbacks/DataLoggingExample4_RXM_without_Callbacks.ino b/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Data_Logging/DataLoggingExample4_RXM_without_Callbacks/DataLoggingExample4_RXM_without_Callbacks.ino
deleted file mode 100644
index 9e4737c..0000000
--- a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Data_Logging/DataLoggingExample4_RXM_without_Callbacks/DataLoggingExample4_RXM_without_Callbacks.ino
+++ /dev/null
@@ -1,247 +0,0 @@
-/*
-  Configuring the GNSS to automatically send RXM SFRBX and RAWX reports over I2C and log them to file on SD card
-  ** without using callbacks **
-  By: Paul Clark
-  SparkFun Electronics
-  Date: December 30th, 2020
-  License: MIT. See license file for more information but you can
-  basically do whatever you want with this code.
-
-  This example shows how to configure the u-blox GNSS to send RXM SFRBX and RAWX reports automatically
-  and log the data to SD card in UBX format ** without using callbacks **
-
-  ** Please note: this example will only work on u-blox ADR or High Precision GNSS or Time Sync products **
-
-  ** Please note: this example will only work on processors like the Artemis which have plenty of RAM available **
-
-  Data is logged in u-blox UBX format. Please see the u-blox protocol specification for more details.
-  You can replay and analyze the data using u-center:
-  https://www.u-blox.com/en/product/u-center
-  Or you can use (e.g.) RTKLIB to analyze the data and extract your precise location or produce
-  Post-Processed Kinematic data:
-  https://rtklibexplorer.wordpress.com/
-  http://rtkexplorer.com/downloads/rtklib-code/
-
-  This code is intended to be run on the MicroMod Data Logging Carrier Board using the Artemis Processor
-  but can be adapted by changing the chip select pin and SPI definitions:
-  https://www.sparkfun.com/products/16829
-  https://www.sparkfun.com/products/16401
-
-  Hardware Connections:
-  Please see: https://learn.sparkfun.com/tutorials/micromod-data-logging-carrier-board-hookup-guide
-  Insert the Artemis Processor into the MicroMod Data Logging Carrier Board and secure with the screw.
-  Connect your GNSS breakout to the Carrier Board using a Qwiic cable.
-  Connect an antenna to your GNSS board if required.
-  Insert a formatted micro-SD card into the socket on the Carrier Board.
-  Connect the Carrier Board to your computer using a USB-C cable.
-  Ensure you have the SparkFun Apollo3 boards installed: http://boardsmanager/All#SparkFun_Apollo3
-  This code has been tested using version 1.2.1 of the Apollo3 boards on Arduino IDE 1.8.13.
-  Select "SparkFun Artemis MicroMod" as the board type.
-  Press upload to upload the code onto the Artemis.
-  Open the Serial Monitor at 115200 baud to see the output.
-
-  To minimise I2C bus errors, it is a good idea to open the I2C pull-up split pad links on
-  both the MicroMod Data Logging Carrier Board and the u-blox module breakout.
-
-  Feel like supporting open source hardware?
-  Buy a board from SparkFun!
-  ZED-F9P RTK2: https://www.sparkfun.com/products/15136
-  NEO-M8P RTK: https://www.sparkfun.com/products/15005
-*/
-
-#include <SPI.h>
-#include <SD.h>
-#include <Wire.h> //Needed for I2C to GNSS
-
-#include <SparkFun_u-blox_GNSS_Arduino_Library.h> //Click here to get the library: http://librarymanager/All#SparkFun_u-blox_GNSS
-SFE_UBLOX_GNSS myGNSS;
-
-File myFile; //File that all GNSS data is written to
-
-#define sdChipSelect CS //Primary SPI Chip Select is CS for the MicroMod Artemis Processor. Adjust for your processor if necessary.
-
-#define sdWriteSize 512 // Write data to the SD card in blocks of 512 bytes
-#define fileBufferSize 16384 // Allocate 16KBytes of RAM for UBX message storage
-
-unsigned long lastPrint; // Record when the last Serial print took place
-unsigned long bytesWritten = 0; // Record how many bytes have been written to SD card
-
-void setup()
-{
-  Serial.begin(115200);
-  while (!Serial); //Wait for user to open terminal
-  Serial.println("SparkFun u-blox Example");
-
-  pinMode(LED_BUILTIN, OUTPUT); // Flash LED_BUILTIN each time we write to the SD card
-  digitalWrite(LED_BUILTIN, LOW);
-
-  Wire.begin(); // Start I2C communication
-
-#if defined(AM_PART_APOLLO3)
-  Wire.setPullups(0); // On the Artemis, we can disable the internal I2C pull-ups too to help reduce bus errors
-#endif
-
-  while (Serial.available()) // Make sure the Serial buffer is empty
-  {
-    Serial.read();
-  }
-
-  Serial.println(F("Press any key to start logging."));
-
-  while (!Serial.available()) // Wait for the user to press a key
-  {
-    ; // Do nothing
-  }
-
-  delay(100); // Wait, just in case multiple characters were sent
-  
-  while (Serial.available()) // Empty the Serial buffer
-  {
-    Serial.read();
-  }
-
-  Serial.println("Initializing SD card...");
-
-  // See if the card is present and can be initialized:
-  if (!SD.begin(sdChipSelect))
-  {
-    Serial.println("Card failed, or not present. Freezing...");
-    // don't do anything more:
-    while (1);
-  }
-  Serial.println("SD card initialized.");
-
-  // Create or open a file called "RXM_RAWX.ubx" on the SD card.
-  // If the file already exists, the new data is appended to the end of the file.
-  myFile = SD.open("RXM_RAWX.ubx", FILE_WRITE);
-  if(!myFile)
-  {
-    Serial.println(F("Failed to create UBX data file! Freezing..."));
-    while (1);
-  }
-
-  //myGNSS.enableDebugging(); // Uncomment this line to enable lots of helpful GNSS debug messages on Serial
-  //myGNSS.enableDebugging(Serial, true); // Or, uncomment this line to enable only the important GNSS debug messages on Serial
-
-  myGNSS.disableUBX7Fcheck(); // RAWX data can legitimately contain 0x7F, so we need to disable the "7F" check in checkUbloxI2C
-
-  // RAWX messages can be over 2KBytes in size, so we need to make sure we allocate enough RAM to hold all the data.
-  // SD cards can occasionally 'hiccup' and a write takes much longer than usual. The buffer needs to be big enough
-  // to hold the backlog of data if/when this happens.
-  // getMaxFileBufferAvail will tell us the maximum number of bytes which the file buffer has contained.
-  myGNSS.setFileBufferSize(fileBufferSize); // setFileBufferSize must be called _before_ .begin
-
-  if (myGNSS.begin() == false) //Connect to the u-blox module using Wire port
-  {
-    Serial.println(F("u-blox GNSS not detected at default I2C address. Please check wiring. Freezing..."));
-    while (1);
-  }
-
-  // Uncomment the next line if you want to reset your module back to the default settings with 1Hz navigation rate
-  // (This will also disable any "auto" messages that were enabled and saved by other examples and reduce the load on the I2C bus)
-  //myGNSS.factoryDefault(); delay(5000);
-
-  myGNSS.setI2COutput(COM_TYPE_UBX); //Set the I2C port to output UBX only (turn off NMEA noise)
-  myGNSS.saveConfigSelective(VAL_CFG_SUBSEC_IOPORT); //Save (only) the communications port settings to flash and BBR
-  
-  myGNSS.setNavigationFrequency(1); //Produce one navigation solution per second (that's plenty for Precise Point Positioning)
-
-  myGNSS.setAutoRXMSFRBX(true, false); // Enable automatic RXM SFRBX messages: without callback; without implicit update
-  
-  myGNSS.logRXMSFRBX(); // Enable RXM SFRBX data logging
-
-  myGNSS.setAutoRXMRAWX(true, false); // Enable automatic RXM RAWX messages: without callback; without implicit update
-  
-  myGNSS.logRXMRAWX(); // Enable RXM RAWX data logging
-
-  Serial.println(F("Press any key to stop logging."));
-
-  lastPrint = millis(); // Initialize lastPrint
-}
-
-void loop()
-{
-  // =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
-
-  myGNSS.checkUblox(); // Check for the arrival of new data and process it.
-
-  // =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
-
-  while (myGNSS.fileBufferAvailable() >= sdWriteSize) // Check to see if we have at least sdWriteSize waiting in the buffer
-  {
-    digitalWrite(LED_BUILTIN, HIGH); // Flash LED_BUILTIN each time we write to the SD card
-  
-    uint8_t myBuffer[sdWriteSize]; // Create our own buffer to hold the data while we write it to SD card
-
-    myGNSS.extractFileBufferData((uint8_t *)&myBuffer, sdWriteSize); // Extract exactly sdWriteSize bytes from the UBX file buffer and put them into myBuffer
-
-    myFile.write(myBuffer, sdWriteSize); // Write exactly sdWriteSize bytes from myBuffer to the ubxDataFile on the SD card
-
-    bytesWritten += sdWriteSize; // Update bytesWritten
-
-    // In case the SD writing is slow or there is a lot of data to write, keep checking for the arrival of new data
-    myGNSS.checkUblox(); // Check for the arrival of new data and process it.
-
-    digitalWrite(LED_BUILTIN, LOW); // Turn LED_BUILTIN off again
-  }
-
-  // =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
-
-  if (millis() > (lastPrint + 1000)) // Print bytesWritten once per second
-  {
-    Serial.print(F("The number of bytes written to SD card is ")); // Print how many bytes have been written to SD card
-    Serial.println(bytesWritten);
-
-    uint16_t maxBufferBytes = myGNSS.getMaxFileBufferAvail(); // Get how full the file buffer has been (not how full it is now)
-    
-    //Serial.print(F("The maximum number of bytes which the file buffer has contained is: ")); // It is a fun thing to watch how full the buffer gets
-    //Serial.println(maxBufferBytes);
-
-    if (maxBufferBytes > ((fileBufferSize / 5) * 4)) // Warn the user if fileBufferSize was more than 80% full
-    {
-      Serial.println(F("Warning: the file buffer has been over 80% full. Some data may have been lost."));
-    }
-    
-    lastPrint = millis(); // Update lastPrint
-  }
-
-  // =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
-
-  if (Serial.available()) // Check if the user wants to stop logging
-  {
-    uint16_t remainingBytes = myGNSS.fileBufferAvailable(); // Check if there are any bytes remaining in the file buffer
-    
-    while (remainingBytes > 0) // While there is still data in the file buffer
-    {
-      digitalWrite(LED_BUILTIN, HIGH); // Flash LED_BUILTIN while we write to the SD card
-      
-      uint8_t myBuffer[sdWriteSize]; // Create our own buffer to hold the data while we write it to SD card
-
-      uint16_t bytesToWrite = remainingBytes; // Write the remaining bytes to SD card sdWriteSize bytes at a time
-      if (bytesToWrite > sdWriteSize)
-      {
-        bytesToWrite = sdWriteSize;
-      }
-  
-      myGNSS.extractFileBufferData((uint8_t *)&myBuffer, bytesToWrite); // Extract bytesToWrite bytes from the UBX file buffer and put them into myBuffer
-
-      myFile.write(myBuffer, bytesToWrite); // Write bytesToWrite bytes from myBuffer to the ubxDataFile on the SD card
-
-      bytesWritten += bytesToWrite; // Update bytesWritten
-
-      remainingBytes -= bytesToWrite; // Decrement remainingBytes
-    }
-
-    digitalWrite(LED_BUILTIN, LOW); // Turn LED_BUILTIN off
-
-    Serial.print(F("The total number of bytes written to SD card is ")); // Print how many bytes have been written to SD card
-    Serial.println(bytesWritten);
-
-    myFile.close(); // Close the data file
-    
-    Serial.println(F("Logging stopped. Freezing..."));
-    while(1); // Do nothing more
-  }
-
-  // =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
-}
diff --git a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Data_Logging/DataLoggingExample5_Fast_RXM/DataLoggingExample5_Fast_RXM.ino b/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Data_Logging/DataLoggingExample5_Fast_RXM/DataLoggingExample5_Fast_RXM.ino
deleted file mode 100644
index 9a5881c..0000000
--- a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Data_Logging/DataLoggingExample5_Fast_RXM/DataLoggingExample5_Fast_RXM.ino
+++ /dev/null
@@ -1,272 +0,0 @@
-/*
-  Configuring the GNSS to automatically send RXM SFRBX and RAWX reports over I2C and log them to file on SD card
-  without using callbacks and ** as fast as your module can go! **
-  By: Paul Clark
-  SparkFun Electronics
-  Date: December 30th, 2020
-  License: MIT. See license file for more information but you can
-  basically do whatever you want with this code.
-
-  This example shows how to configure the u-blox GNSS to send RXM SFRBX and RAWX reports automatically
-  and log the data to SD card in UBX format without using callbacks and ** as fast as your module can go! **
-
-  ** Please note: this example will only work on u-blox ADR or High Precision GNSS or Time Sync products **
-
-  ** Please note: this example will only work on processors like the Artemis which have plenty of RAM available **
-
-  Data is logged in u-blox UBX format. Please see the u-blox protocol specification for more details.
-  You can replay and analyze the data using u-center:
-  https://www.u-blox.com/en/product/u-center
-  Or you can use (e.g.) RTKLIB to analyze the data and extract your precise location or produce
-  Post-Processed Kinematic data:
-  https://rtklibexplorer.wordpress.com/
-  http://rtkexplorer.com/downloads/rtklib-code/
-
-  This code is intended to be run on the MicroMod Data Logging Carrier Board using the Artemis Processor
-  but can be adapted by changing the chip select pin and SPI definitions:
-  https://www.sparkfun.com/products/16829
-  https://www.sparkfun.com/products/16401
-
-  Hardware Connections:
-  Please see: https://learn.sparkfun.com/tutorials/micromod-data-logging-carrier-board-hookup-guide
-  Insert the Artemis Processor into the MicroMod Data Logging Carrier Board and secure with the screw.
-  Connect your GNSS breakout to the Carrier Board using a Qwiic cable.
-  Connect an antenna to your GNSS board if required.
-  Insert a formatted micro-SD card into the socket on the Carrier Board.
-  Connect the Carrier Board to your computer using a USB-C cable.
-  Ensure you have the SparkFun Apollo3 boards installed: http://boardsmanager/All#SparkFun_Apollo3
-  This code has been tested using version 1.2.1 of the Apollo3 boards on Arduino IDE 1.8.13.
-  Select "SparkFun Artemis MicroMod" as the board type.
-  Press upload to upload the code onto the Artemis.
-  Open the Serial Monitor at 115200 baud to see the output.
-
-  To minimise I2C bus errors, it is a good idea to open the I2C pull-up split pad links on
-  both the MicroMod Data Logging Carrier Board and the u-blox module breakout.
-
-  Feel like supporting open source hardware?
-  Buy a board from SparkFun!
-  ZED-F9P RTK2: https://www.sparkfun.com/products/15136
-  NEO-M8P RTK: https://www.sparkfun.com/products/15005
-*/
-
-#include <SPI.h>
-#include <SD.h>
-#include <Wire.h> //Needed for I2C to GNSS
-
-#include <SparkFun_u-blox_GNSS_Arduino_Library.h> //Click here to get the library: http://librarymanager/All#SparkFun_u-blox_GNSS
-SFE_UBLOX_GNSS myGNSS;
-
-File myFile; //File that all GNSS data is written to
-
-#define sdChipSelect CS //Primary SPI Chip Select is CS for the MicroMod Artemis Processor. Adjust for your processor if necessary.
-
-#define sdWriteSize 512 // Write data to the SD card in blocks of 512 bytes
-#define fileBufferSize 32768 // Allocate 32KBytes of RAM for UBX message storage
-
-unsigned long lastPrint; // Record when the last Serial print took place
-unsigned long bytesWritten = 0; // Record how many bytes have been written to SD card
-
-void setup()
-{
-  Serial.begin(115200);
-  while (!Serial); //Wait for user to open terminal
-  Serial.println("SparkFun u-blox Example");
-
-  pinMode(LED_BUILTIN, OUTPUT); // Flash LED_BUILTIN each time we write to the SD card
-  digitalWrite(LED_BUILTIN, LOW);
-
-  Wire.begin(); // Start I2C communication
-
-#if defined(AM_PART_APOLLO3)
-  Wire.setPullups(0); // On the Artemis, we can disable the internal I2C pull-ups too to help reduce bus errors
-#endif
-
-  while (Serial.available()) // Make sure the Serial buffer is empty
-  {
-    Serial.read();
-  }
-
-  Serial.println(F("Press any key to start logging."));
-
-  while (!Serial.available()) // Wait for the user to press a key
-  {
-    ; // Do nothing
-  }
-
-  delay(100); // Wait, just in case multiple characters were sent
-  
-  while (Serial.available()) // Empty the Serial buffer
-  {
-    Serial.read();
-  }
-
-  Serial.println("Initializing SD card...");
-
-  // See if the card is present and can be initialized:
-  if (!SD.begin(sdChipSelect))
-  {
-    Serial.println("Card failed, or not present. Freezing...");
-    // don't do anything more:
-    while (1);
-  }
-  Serial.println("SD card initialized.");
-
-  // Create or open a file called "Fast_RXM.ubx" on the SD card.
-  // If the file already exists, the new data is appended to the end of the file.
-  myFile = SD.open("Fast_RXM.ubx", FILE_WRITE);
-  if(!myFile)
-  {
-    Serial.println(F("Failed to create UBX data file! Freezing..."));
-    while (1);
-  }
-
-  //myGNSS.enableDebugging(); // Uncomment this line to enable lots of helpful GNSS debug messages on Serial
-  //myGNSS.enableDebugging(Serial, true); // Or, uncomment this line to enable only the important GNSS debug messages on Serial
-
-  myGNSS.disableUBX7Fcheck(); // RAWX data can legitimately contain 0x7F, so we need to disable the "7F" check in checkUbloxI2C
-
-  // RAWX messages can be over 2KBytes in size, so we need to make sure we allocate enough RAM to hold all the data.
-  // SD cards can occasionally 'hiccup' and a write takes much longer than usual. The buffer needs to be big enough
-  // to hold the backlog of data if/when this happens.
-  // getMaxFileBufferAvail will tell us the maximum number of bytes which the file buffer has contained.
-  myGNSS.setFileBufferSize(fileBufferSize); // setFileBufferSize must be called _before_ .begin
-
-  if (myGNSS.begin() == false) //Connect to the u-blox module using Wire port
-  {
-    Serial.println(F("u-blox GNSS not detected at default I2C address. Please check wiring. Freezing..."));
-    while (1);
-  }
-
-  // Uncomment the next line if you want to reset your module back to the default settings with 1Hz navigation rate
-  // (This will also disable any "auto" messages that were enabled and saved by other examples and reduce the load on the I2C bus)
-  //myGNSS.factoryDefault(); delay(5000);
-
-  myGNSS.setI2COutput(COM_TYPE_UBX); //Set the I2C port to output UBX only (turn off NMEA noise)
-  myGNSS.saveConfigSelective(VAL_CFG_SUBSEC_IOPORT); //Save (only) the communications port settings to flash and BBR
-
-  // Modules like the ZED-F9P can produce RAW navigation data at rates of up to 25Hz but not while using all of the GNSS constellations.
-  // Please consult the data sheet for the Performance figures for your module.
-  // In this example we make sure GPS is enabled and then disable Galileo, GLONASS, BeiDou, SBAS and QZSS to achieve 25Hz.
-  myGNSS.enableGNSS(true, SFE_UBLOX_GNSS_ID_GPS); // Make sure GPS is enabled (we must leave at least one major GNSS enabled!)
-  myGNSS.enableGNSS(false, SFE_UBLOX_GNSS_ID_SBAS); // Disable SBAS
-  myGNSS.enableGNSS(false, SFE_UBLOX_GNSS_ID_GALILEO); // Disable Galileo
-  myGNSS.enableGNSS(false, SFE_UBLOX_GNSS_ID_BEIDOU); // Disable BeiDou
-  myGNSS.enableGNSS(false, SFE_UBLOX_GNSS_ID_IMES); // Disable IMES
-  myGNSS.enableGNSS(false, SFE_UBLOX_GNSS_ID_QZSS); // Disable QZSS
-  myGNSS.enableGNSS(false, SFE_UBLOX_GNSS_ID_GLONASS); // Disable GLONASS
-
-  delay(2000); // Give the module some extra time to get ready
-
-  //Produce 7 navigation solutions per second. That's a lot of RAWX data - especially when using both GPS bands L1 and L2.
-  //The SD library and card need to be able to cope with the data rate too. You may need a faster SD library to go above 7Hz.
-  myGNSS.setNavigationFrequency(7);
-
-  myGNSS.setAutoRXMSFRBX(true, false); // Enable automatic RXM SFRBX messages: without callback; without implicit update
-  
-  myGNSS.logRXMSFRBX(); // Enable RXM SFRBX data logging
-
-  myGNSS.setAutoRXMRAWX(true, false); // Enable automatic RXM RAWX messages: without callback; without implicit update
-  
-  myGNSS.logRXMRAWX(); // Enable RXM RAWX data logging
-
-  Serial.println(F("Press any key to stop logging."));
-
-  lastPrint = millis(); // Initialize lastPrint
-}
-
-void loop()
-{
-  // =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
-
-  myGNSS.checkUblox(); // Check for the arrival of new data and process it.
-
-  // =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
-
-  while (myGNSS.fileBufferAvailable() >= sdWriteSize) // Check to see if we have at least sdWriteSize waiting in the buffer
-  {
-    digitalWrite(LED_BUILTIN, HIGH); // Flash LED_BUILTIN each time we write to the SD card
-  
-    uint8_t myBuffer[sdWriteSize]; // Create our own buffer to hold the data while we write it to SD card
-
-    myGNSS.extractFileBufferData((uint8_t *)&myBuffer, sdWriteSize); // Extract exactly sdWriteSize bytes from the UBX file buffer and put them into myBuffer
-
-    myFile.write(myBuffer, sdWriteSize); // Write exactly sdWriteSize bytes from myBuffer to the ubxDataFile on the SD card
-
-    bytesWritten += sdWriteSize; // Update bytesWritten
-
-    // In case the SD writing is slow or there is a lot of data to write, keep checking for the arrival of new data
-    myGNSS.checkUblox(); // Check for the arrival of new data and process it.
-
-    digitalWrite(LED_BUILTIN, LOW); // Turn LED_BUILTIN off again
-  }
-
-  // =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
-
-  if (millis() > (lastPrint + 1000)) // Print bytesWritten once per second
-  {
-    Serial.print(F("The number of bytes written to SD card is: ")); // Print how many bytes have been written to SD card
-    Serial.println(bytesWritten);
-
-    uint16_t maxBufferBytes = myGNSS.getMaxFileBufferAvail(); // Get how full the file buffer has been (not how full it is now)
-    
-    //Serial.print(F("The maximum number of bytes which the file buffer has contained is: ")); // It is a fun thing to watch how full the buffer gets
-    //Serial.println(maxBufferBytes);
-
-    if (maxBufferBytes > ((fileBufferSize / 5) * 4)) // Warn the user if fileBufferSize was more than 80% full
-    {
-      Serial.println(F("Warning: the file buffer has been over 80% full. Some data may have been lost."));
-    }
-    
-    lastPrint = millis(); // Update lastPrint
-  }
-
-  // =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
-
-  if (Serial.available()) // Check if the user wants to stop logging
-  {
-    myGNSS.setAutoRXMSFRBX(false, false); // Disable the automatic RXM SFRBX messages
-    myGNSS.setAutoRXMRAWX(false, false); // Disable the automatic RXM RAWX messages
-
-    delay(1000); // Allow time for any remaining messages to arrive
-    myGNSS.checkUblox(); // Process any remaining data
-
-    uint16_t remainingBytes = myGNSS.fileBufferAvailable(); // Check if there are any bytes remaining in the file buffer
-    
-    while (remainingBytes > 0) // While there is still data in the file buffer
-    {
-      digitalWrite(LED_BUILTIN, HIGH); // Flash LED_BUILTIN while we write to the SD card
-      
-      uint8_t myBuffer[sdWriteSize]; // Create our own buffer to hold the data while we write it to SD card
-
-      uint16_t bytesToWrite = remainingBytes; // Write the remaining bytes to SD card sdWriteSize bytes at a time
-      if (bytesToWrite > sdWriteSize)
-      {
-        bytesToWrite = sdWriteSize;
-      }
-  
-      myGNSS.extractFileBufferData((uint8_t *)&myBuffer, bytesToWrite); // Extract bytesToWrite bytes from the UBX file buffer and put them into myBuffer
-
-      myFile.write(myBuffer, bytesToWrite); // Write bytesToWrite bytes from myBuffer to the ubxDataFile on the SD card
-
-      bytesWritten += bytesToWrite; // Update bytesWritten
-
-      remainingBytes -= bytesToWrite; // Decrement remainingBytes
-    }
-
-    digitalWrite(LED_BUILTIN, LOW); // Turn LED_BUILTIN off
-
-    Serial.print(F("The total number of bytes written to SD card is: ")); // Print how many bytes have been written to SD card
-    Serial.println(bytesWritten);
-
-    uint16_t maxBufferBytes = myGNSS.getMaxFileBufferAvail(); // Show how full the file buffer has been (not how full it is now)
-    Serial.print(F("The maximum number of bytes which the file buffer has contained is: "));
-    Serial.println(maxBufferBytes);
-
-    myFile.close(); // Close the data file
-    
-    Serial.println(F("Logging stopped. Freezing..."));
-    while(1); // Do nothing more
-  }
-
-  // =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
-}
diff --git a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Dead_Reckoning/Example1_calibrateSensor/Example1_calibrateSensor.ino b/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Dead_Reckoning/Example1_calibrateSensor/Example1_calibrateSensor.ino
deleted file mode 100644
index ed85e6a..0000000
--- a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Dead_Reckoning/Example1_calibrateSensor/Example1_calibrateSensor.ino
+++ /dev/null
@@ -1,75 +0,0 @@
-/*
-  By: Elias Santistevan
-  SparkFun Electronics
-  Date: May, 2020
-  License: MIT. See license file for more information but you can
-  basically do whatever you want with this code.
-
-  Feel like supporting open source hardware?
-  Buy a board from SparkFun!
-  NEO-M8U: https://www.sparkfun.com/products/16329
-  ZED-F9R: https://www.sparkfun.com/products/16344  
-
-  Hardware Connections:
-  Plug a Qwiic cable into the GNSS and a Redboard Qwiic
-  If you don't have a platform with a Qwiic connection use the 
-  SparkFun Qwiic Breadboard Jumper (https://www.sparkfun.com/products/14425)
-  Open the serial monitor at 115200 baud to see the output
-
-  To take advantage of the internal IMU of either the Dead Reckoning GNSS
-  boards (ZED-F9R, NEO-M8U), you must first calibrate it. This includes securing the GNSS module
-  to your vehicle so that it is stable within 2 degrees and that the frame of
-  reference of the board is consistent with the picture outlined in the
-  Receiver-Description-Prot-Spec Datasheet under Automotive/Untethered Dead
-  Reckoning. You may also check either the ZED-F9R or NEO-M8U Hookup Guide for
-  more information. After the board is secure, you'll need to put the module
-  through certain conditions for proper calibration: acceleration, turning,
-  stopping for a few minutes, getting to a speed over 30km/h all under a clear sky 
-  with good GNSS signal. This example simply looks at the
-  "fusionMode" status which indicates whether the SparkFun Dead Reckoning is
-  initializing - 0, calibrated - 1, or if an error has occurred - 2,3.  
-*/
-
-#include <Wire.h> //Needed for I2C to GNSS
-
-#include <SparkFun_u-blox_GNSS_Arduino_Library.h> //http://librarymanager/All#SparkFun_u-blox_GNSS
-SFE_UBLOX_GNSS myGNSS;
-
-void setup()
-{
-  Serial.begin(115200);
-  while (!Serial); //Wait for user to open terminal
-  Serial.println(F("SparkFun u-blox Example"));
-
-  Wire.begin();
-
-  if (myGNSS.begin() == false) //Connect to the u-blox module using Wire port
-  {
-    Serial.println(F("u-blox GNSS not detected at default I2C address. Please check wiring. Freezing."));
-    while (1);
-  }
-
-  myGNSS.setI2COutput(COM_TYPE_UBX); //Set the I2C port to output UBX only (turn off NMEA noise)
-
-  //myGNSS.resetIMUalignment(); // Uncomment this line to reset the IMU alignment
-}
-
-void loop()
-{
-  // ESF data is produced at the navigation rate, so by default we'll get fresh data once per second
-  if (myGNSS.getEsfInfo()) // Poll new ESF STATUS data
-  {
-    Serial.print(F("Fusion Mode: "));  
-    Serial.print(myGNSS.packetUBXESFSTATUS->data.fusionMode);  
-    if (myGNSS.packetUBXESFSTATUS->data.fusionMode == 0)
-      Serial.println(F("  Sensor is initializing..."));  
-    else if (myGNSS.packetUBXESFSTATUS->data.fusionMode == 1)
-      Serial.println(F("  Sensor is calibrated!"));  
-    else if (myGNSS.packetUBXESFSTATUS->data.fusionMode == 2)
-      Serial.println(F("  Sensor fusion is suspended!"));  
-    else if (myGNSS.packetUBXESFSTATUS->data.fusionMode == 3)
-      Serial.println(F("  Sensor fusion is disabled!"));  
-  }
-
-  delay(250);
-}
diff --git a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Dead_Reckoning/Example2_getIMUData/Example2_getIMUData.ino b/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Dead_Reckoning/Example2_getIMUData/Example2_getIMUData.ino
deleted file mode 100644
index e9889d9..0000000
--- a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Dead_Reckoning/Example2_getIMUData/Example2_getIMUData.ino
+++ /dev/null
@@ -1,91 +0,0 @@
-/*
-  By: Elias Santistevan
-  SparkFun Electronics
-  Date: May, 2020
-  License: MIT. See license file for more information but you can
-  basically do whatever you want with this code.
-
-  Feel like supporting open source hardware?
-  Buy a board from SparkFun!
-  NEO-M8U: https://www.sparkfun.com/products/16329
-  ZED-F9R: https://www.sparkfun.com/products/16344  
-
-  Hardware Connections:
-  Plug a Qwiic cable into the GNSS and a Redboard Qwiic
-  If you don't have a platform with a Qwiic connection use the 
-	SparkFun Qwiic Breadboard Jumper (https://www.sparkfun.com/products/14425)
-  Open the serial monitor at 115200 baud to see the output
-
-	After calibrating the module, also known as "Fusion Mode", you can get
-	data directly from the IMU. This data is integrated directly into the GNSS
-	output, but is provided by the module as well. 
-
-*/
-
-#include <Wire.h> //Needed for I2C to GNSS
-
-#include <SparkFun_u-blox_GNSS_Arduino_Library.h> //http://librarymanager/All#SparkFun_u-blox_GNSS
-SFE_UBLOX_GNSS myGNSS;
-
-void setup()
-{
-  Serial.begin(115200);
-  while (!Serial); //Wait for user to open terminal
-  Serial.println(F("SparkFun u-blox Example"));
-
-  Wire.begin();
-
-  if (myGNSS.begin() == false) //Connect to the u-blox module using Wire port
-  {
-    Serial.println(F("u-blox GNSS not detected at default I2C address. Please check wiring. Freezing."));
-    while (1);
-  }
-
-  myGNSS.setI2COutput(COM_TYPE_UBX); //Set the I2C port to output UBX only (turn off NMEA noise)
-
-  if (myGNSS.getEsfInfo()){
-
-    Serial.print(F("Fusion Mode: "));
-    Serial.println(myGNSS.packetUBXESFSTATUS->data.fusionMode);  
-
-    if (myGNSS.packetUBXESFSTATUS->data.fusionMode == 1){
-      Serial.println(F("Fusion Mode is Initialized!"));  
-		}
-		else {
-      Serial.println(F("Fusion Mode is either disabled or not initialized!"));  
-			Serial.println(F("Please see the previous example for more information."));
-		}
-  }
-}
-
-void loop()
-{
-  // ESF data is produced at the navigation rate, so by default we'll get fresh data once per second
-  if (myGNSS.getEsfIns()) // Poll new ESF INS data
-  {
-    Serial.print(F("X Ang Rate: "));
-    Serial.print(myGNSS.packetUBXESFINS->data.xAngRate);  
-    Serial.print(F(" Y Ang Rate: "));
-    Serial.print(myGNSS.packetUBXESFINS->data.yAngRate);  
-    Serial.print(F(" Z Ang Rate: "));
-    Serial.print(myGNSS.packetUBXESFINS->data.zAngRate);  
-    Serial.print(F(" X Accel: "));
-    Serial.print(myGNSS.packetUBXESFINS->data.xAccel);  
-    Serial.print(F(" Y Accel: "));
-    Serial.print(myGNSS.packetUBXESFINS->data.yAccel);  
-    Serial.print(F(" Z Accel: "));
-    Serial.print(myGNSS.packetUBXESFINS->data.zAccel);
-      
-		// These values also have "validity checks" that can be provided by the
-		// ublox library by reading bitfield0
-    Serial.print(F(" Validity: "));
-    Serial.print(myGNSS.packetUBXESFINS->data.bitfield0.bits.xAngRateValid);
-    Serial.print(myGNSS.packetUBXESFINS->data.bitfield0.bits.yAngRateValid);
-    Serial.print(myGNSS.packetUBXESFINS->data.bitfield0.bits.zAngRateValid);
-    Serial.print(myGNSS.packetUBXESFINS->data.bitfield0.bits.xAccelValid);
-    Serial.print(myGNSS.packetUBXESFINS->data.bitfield0.bits.yAccelValid);
-    Serial.println(myGNSS.packetUBXESFINS->data.bitfield0.bits.zAccelValid);
-  }
-
-  delay(250);
-}
diff --git a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Dead_Reckoning/Example3_getSensorStatus/Example3_getSensorStatus.ino b/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Dead_Reckoning/Example3_getSensorStatus/Example3_getSensorStatus.ino
deleted file mode 100644
index db48d20..0000000
--- a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Dead_Reckoning/Example3_getSensorStatus/Example3_getSensorStatus.ino
+++ /dev/null
@@ -1,125 +0,0 @@
-/*
-  By: Elias Santistevan
-  SparkFun Electronics
-  Date: May, 2020
-  License: MIT. See license file for more information but you can
-  basically do whatever you want with this code.
-
-  Feel like supporting open source hardware?
-  Buy a board from SparkFun!
-  NEO-M8U: https://www.sparkfun.com/products/16329
-  ZED-F9R: https://www.sparkfun.com/products/16344  
-
-  Hardware Connections:
-  Plug a Qwiic cable into the GNSS and a Redboard Qwiic
-  If you don't have a platform with a Qwiic connection use the 
-	SparkFun Qwiic Breadboard Jumper (https://www.sparkfun.com/products/14425)
-  Open the serial monitor at 115200 baud to see the output
-
-	After calibrating the module, also known as "Fusion Mode", you can get
-	data directly from the IMU. This example code walks you through trouble
-  shooting or identifying the different states of any individual  
-  "external" (which include internal) sensors you've hooked up (vehicle speed
-  sensor) or the internal IMU used by the modules. You can see if the sensor is
-  being used, if it's calibrated, ready, what data type it returns, the state
-  of the measurement etc.
-
-*/
-
-#include <Wire.h> //Needed for I2C to GNSS
-
-#include <SparkFun_u-blox_GNSS_Arduino_Library.h> //http://librarymanager/All#SparkFun_u-blox_GNSS
-SFE_UBLOX_GNSS myGNSS;
-
-void setup()
-{
-  Serial.begin(115200);
-  while (!Serial); //Wait for user to open terminal
-  Serial.println(F("SparkFun u-blox Example"));
-
-  Wire.begin();
-
-  if (myGNSS.begin() == false) //Connect to the u-blox module using Wire port
-  {
-    Serial.println(F("u-blox GNSS not detected at default I2C address. Please check wiring. Freezing."));
-    while (1);
-  }
-
-  myGNSS.setI2COutput(COM_TYPE_UBX); //Set the I2C port to output UBX only (turn off NMEA noise)
-
-	// GetEsfInfo also gets the number of sensors used by the ublox module, this
-	// includes (in the case of the ZED-F9R) wheel tick input from the vehicle
-	// speed sensor attached to the module. 
-  if (myGNSS.getEsfInfo()){
-
-    Serial.print(F("Fusion Mode: "));  
-    Serial.println(myGNSS.packetUBXESFSTATUS->data.fusionMode);  
-
-    if (myGNSS.packetUBXESFSTATUS->data.fusionMode == 1){
-      Serial.println(F("Fusion Mode is Initialized!"));  
-		}
-		else {
-      Serial.println(F("Fusion Mode is either disabled or not initialized!"));  
-			Serial.println(F("Please see the previous example for more information."));
-		}
-  }
-}
-
-void loop()
-{
-  // ESF data is produced at the navigation rate, so by default we'll get fresh data once per second
-  if (myGNSS.getEsfInfo()) // Poll new ESF STATUS data
-  {
-    UBX_ESF_STATUS_sensorStatus_t sensorStatus; // Create storage for the individual sensor status
-
-    //See ublox receiver description or our hookup guide for information on the return values
-
-    Serial.println(F("                              "));
-    Serial.println(F("              C               "));
-    Serial.println(F("              a               "));
-    Serial.println(F("              l               "));
-    Serial.println(F("              i               "));
-    Serial.println(F("              b           M   "));
-    Serial.println(F("              r           i  N"));
-    Serial.println(F("              a        B  s  o"));
-    Serial.println(F("    S         t  T  B  a  s  i"));
-    Serial.println(F("S   e   B     i  i  a  d  e  s"));
-    Serial.println(F("e   n   e     o  m  d     d  y"));
-    Serial.println(F("n   s   i  I  n  e     T      "));
-    Serial.println(F("s   o   n  s        M  i  M  M"));
-    Serial.println(F("o   r   g     S  S  e  m  e  e"));
-    Serial.println(F("r          R  t  t  a  e  a  a"));
-    Serial.println(F("    T   U  e  a  a  s     s  s"));
-    Serial.println(F("N   y   s  a  t  t  u  T  u  u"));
-    Serial.println(F("o   p   e  d  u  u  r  a  r  r"));
-    Serial.println(F(".   e   d  y  s  s  e  g  e  e"));
-    Serial.println(F("                              "));
-
-  	for(uint8_t i = 0; i < myGNSS.packetUBXESFSTATUS->data.numSens; i++)
-  	{
-      myGNSS.getSensorFusionStatus(&sensorStatus, i); // Extract the individual sensor data for this sensor
-      
-      Serial.print(i); Serial.print(F("   ")); // Print the sensor number
-
-      // Print the sensor type
-  		Serial.print(sensorStatus.sensStatus1.bits.type);
-      if (sensorStatus.sensStatus1.bits.type < 10) Serial.print(F(" "));
-  		Serial.print(F("  "));
-
-      Serial.print(sensorStatus.sensStatus1.bits.used); Serial.print(F("  ")); // Print the used flag
-      Serial.print(sensorStatus.sensStatus1.bits.ready); Serial.print(F("  ")); // Print the ready flag
-
-      Serial.print(sensorStatus.sensStatus2.bits.calibStatus); Serial.print(F("  ")); // Print the calibration status
-      Serial.print(sensorStatus.sensStatus2.bits.timeStatus); Serial.print(F("  ")); // Print the time status
-
-      Serial.print(sensorStatus.faults.bits.badMeas); Serial.print(F("  ")); // Print the bad measurement flag
-      Serial.print(sensorStatus.faults.bits.badTTag); Serial.print(F("  ")); // Print the time tag flag
-      Serial.print(sensorStatus.faults.bits.missingMeas); Serial.print(F("  ")); // Print the missing measurement flag
-      Serial.print(sensorStatus.faults.bits.noisyMeas); // Print the noisy measure flag
-
-      Serial.println(); 
-  	}
-  }
-
-  delay(250);
-}
diff --git a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Dead_Reckoning/Example4_vehicleDynamics/Example4_vehicleDynamics.ino b/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Dead_Reckoning/Example4_vehicleDynamics/Example4_vehicleDynamics.ino
deleted file mode 100644
index 451fec6..0000000
--- a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Dead_Reckoning/Example4_vehicleDynamics/Example4_vehicleDynamics.ino
+++ /dev/null
@@ -1,83 +0,0 @@
-/*
-  By: Elias Santistevan
-  SparkFun Electronics
-  Date: May, 2020
-  License: MIT. See license file for more information but you can
-  basically do whatever you want with this code.
-
-  Feel like supporting open source hardware?
-  Buy a board from SparkFun!
-  NEO-M8U: https://www.sparkfun.com/products/16329
-  ZED-F9R: https://www.sparkfun.com/products/16344  
-
-  Hardware Connections:
-  Plug a Qwiic cable into the GNSS and a Redboard Qwiic
-  If you don't have a platform with a Qwiic connection use the 
-	SparkFun Qwiic Breadboard Jumper (https://www.sparkfun.com/products/14425)
-  Open the serial monitor at 115200 baud to see the output
-
-	After calibrating the module and securing it to your vehicle such that it's
-  stable within 2 degrees, and the board is oriented correctly with regards to
-  the vehicle's frame, you can now read the vehicle's "attitude". The attitude
-  includes the vehicle's heading, pitch, and roll. You can also check the
-  accuracy of those readings. 
-
-*/
-
-#include <Wire.h> //Needed for I2C to GNSS
-
-#include <SparkFun_u-blox_GNSS_Arduino_Library.h> //http://librarymanager/All#SparkFun_u-blox_GNSS
-SFE_UBLOX_GNSS myGNSS;
-
-void setup()
-{
-  Serial.begin(115200);
-  while (!Serial); //Wait for user to open terminal
-  Serial.println(F("SparkFun u-blox Example"));
-
-  Wire.begin();
-
-  if (myGNSS.begin() == false) //Connect to the u-blox module using Wire port
-  {
-    Serial.println(F("u-blox GNSS not detected at default I2C address. Please check wiring. Freezing."));
-    while (1);
-  }
-
-  myGNSS.setI2COutput(COM_TYPE_UBX); //Set the I2C port to output UBX only (turn off NMEA noise)
-
-  if (myGNSS.getEsfInfo()){
-
-    Serial.print(F("Fusion Mode: "));  
-    Serial.println(myGNSS.packetUBXESFSTATUS->data.fusionMode);  
-
-    if (myGNSS.packetUBXESFSTATUS->data.fusionMode == 1){
-      Serial.println(F("Fusion Mode is Initialized!"));  
-		}
-		else {
-      Serial.println(F("Fusion Mode is either disabled or not initialized!"));  
-			Serial.println(F("Please see the previous example for more information."));
-		}
-  }
-}
-
-void loop()
-{
-  // ESF data is produced at the navigation rate, so by default we'll get fresh data once per second
-	if (myGNSS.getEsfAlignment()) // Poll new ESF ALG data
-  {
-  	Serial.print(F("Status: ")); 
-  	Serial.print(myGNSS.packetUBXESFALG->data.flags.bits.status);
-    Serial.print(F(" Roll: ")); 
-    Serial.print(myGNSS.getESFroll(), 2); // Use the helper function to get the roll in degrees
-  	Serial.print(F(" Pitch: ")); 
-  	Serial.print(myGNSS.getESFpitch(), 2); // Use the helper function to get the pitch in degrees
-  	Serial.print(F(" Heading: ")); 
-  	Serial.print(myGNSS.getESFyaw(), 2); // Use the helper function to get the yaw in degrees
-  	Serial.print(F(" Errors: ")); 
-  	Serial.print(myGNSS.packetUBXESFALG->data.error.bits.tiltAlgError);
-  	Serial.print(myGNSS.packetUBXESFALG->data.error.bits.yawAlgError);
-  	Serial.println(myGNSS.packetUBXESFALG->data.error.bits.angleError);
-  }
-
-  delay(250);
-}
diff --git a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Dead_Reckoning/Example5_getHNRData/Example5_getHNRData.ino b/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Dead_Reckoning/Example5_getHNRData/Example5_getHNRData.ino
deleted file mode 100644
index a1e4930..0000000
--- a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Dead_Reckoning/Example5_getHNRData/Example5_getHNRData.ino
+++ /dev/null
@@ -1,94 +0,0 @@
-/*
-  By: Paul Clark
-  SparkFun Electronics
-  Date: December, 2020
-  License: MIT. See license file for more information but you can
-  basically do whatever you want with this code.
-
-  This example configures the High Navigation Rate on the NEO-M8U and then
-  polls and displays the attitude solution, vehicle dynamics information
-  and high rate position, velocity and time.
-  
-  This example polls the high rate data.
-  (The next example uses "autoHNR" to receive the HNR data automatically.)
-  
-  Please make sure your NEO-M8U is running UDR firmware >= 1.31. Please update using u-center if necessary:
-  https://www.u-blox.com/en/product/neo-m8u-module#tab-documentation-resources
-
-  Feel like supporting open source hardware?
-  Buy a board from SparkFun!
-  NEO-M8U: https://www.sparkfun.com/products/16329
-
-  Hardware Connections:
-  Plug a Qwiic cable into the GPS and a Redboard Qwiic
-  If you don't have a platform with a Qwiic connection use the 
-	SparkFun Qwiic Breadboard Jumper (https://www.sparkfun.com/products/14425)
-  Open the serial monitor at 115200 baud to see the output
-
-*/
-
-#include <Wire.h> //Needed for I2C to GPS
-
-#include <SparkFun_u-blox_GNSS_Arduino_Library.h> //http://librarymanager/All#SparkFun_u-blox_GNSS
-SFE_UBLOX_GNSS myGNSS;
-
-void setup()
-{
-  Serial.begin(115200);
-  while (!Serial); //Wait for user to open terminal
-  Serial.println(F("SparkFun u-blox Example"));
-
-  Wire.begin();
-
-  //myGNSS.enableDebugging(); // Uncomment this line to enable debug messages on Serial
-
-  if (myGNSS.begin() == false) //Connect to the u-blox module using Wire port
-  {
-    Serial.println(F("Warning! u-blox GPS did not begin correctly."));
-    Serial.println(F("(This may be because the I2C port is busy with HNR messages.)"));
-  }
-
-  myGNSS.setI2COutput(COM_TYPE_UBX); //Set the I2C port to output UBX only (turn off NMEA noise)
-  myGNSS.saveConfigSelective(VAL_CFG_SUBSEC_IOPORT); //Save (only) the communications port settings to flash and BBR
-
-  if (myGNSS.setHNRNavigationRate(10) == true) //Set the High Navigation Rate to 10Hz
-    Serial.println(F("setHNRNavigationRate was successful"));
-  else
-    Serial.println(F("setHNRNavigationRate was NOT successful"));
-
-  myGNSS.setAutoHNRATT(false); //Make sure auto HNR attitude messages are disabled
-  myGNSS.setAutoHNRINS(false); //Make sure auto HNR vehicle dynamics messages are disabled
-  myGNSS.setAutoHNRPVT(false); //Make sure auto HNR PVT messages are disabled
-}
-
-void loop()
-{
-  // Poll and print selected HNR data
-  if (myGNSS.getHNRAtt(125) == true) // Request HNR Att data using a 125ms timeout
-  {
-    Serial.print(F("Roll: "));
-    Serial.print(myGNSS.getHNRroll(), 2); // Use the helper function to get the roll in degrees
-    Serial.print(F(" Pitch: "));
-    Serial.print(myGNSS.getHNRpitch(), 2); // Use the helper function to get the pitch in degrees
-    Serial.print(F(" Heading: "));
-    Serial.println(myGNSS.getHNRheading(), 2); // Use the helper function to get the heading in degrees
-  }
-  if (myGNSS.getHNRDyn(125) == true) // Request HNR Dyn data using a 125ms timeout
-  {
-    Serial.print(F("xAccel: "));
-    Serial.print(myGNSS.packetUBXHNRINS->data.xAccel);
-    Serial.print(F(" yAccel: "));
-    Serial.print(myGNSS.packetUBXHNRINS->data.yAccel);
-    Serial.print(F(" zAccel: "));
-    Serial.println(myGNSS.packetUBXHNRINS->data.zAccel);
-  }
-  if (myGNSS.getHNRPVT(125) == true) // Request HNR PVT data using a 125ms timeout
-  {
-    Serial.print(F("ns: "));
-    Serial.print(myGNSS.packetUBXHNRPVT->data.nano);
-    Serial.print(F(" Lat: "));
-    Serial.print(myGNSS.packetUBXHNRPVT->data.lat);
-    Serial.print(F(" Lon: "));
-    Serial.println(myGNSS.packetUBXHNRPVT->data.lon);
-  }
-}
diff --git a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Dead_Reckoning/Example6_getAutoHNRData/Example6_getAutoHNRData.ino b/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Dead_Reckoning/Example6_getAutoHNRData/Example6_getAutoHNRData.ino
deleted file mode 100644
index d48787e..0000000
--- a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Dead_Reckoning/Example6_getAutoHNRData/Example6_getAutoHNRData.ino
+++ /dev/null
@@ -1,107 +0,0 @@
-/*
-  By: Paul Clark
-  SparkFun Electronics
-  Date: December, 2020
-  License: MIT. See license file for more information but you can
-  basically do whatever you want with this code.
-
-  This example configures the High Navigation Rate on the NEO-M8U and then
-  reads and displays the attitude solution, vehicle dynamics information
-  and high rate position, velocity and time.
-  
-  This example uses "autoHNR" to receive the HNR data automatically.
-
-  Please make sure your NEO-M8U is running UDR firmware >= 1.31. Please update using u-center if necessary:
-  https://www.u-blox.com/en/product/neo-m8u-module#tab-documentation-resources
-
-  Feel like supporting open source hardware?
-  Buy a board from SparkFun!
-  NEO-M8U: https://www.sparkfun.com/products/16329
-
-  Hardware Connections:
-  Plug a Qwiic cable into the GPS and a Redboard Qwiic
-  If you don't have a platform with a Qwiic connection use the 
-	SparkFun Qwiic Breadboard Jumper (https://www.sparkfun.com/products/14425)
-  Open the serial monitor at 115200 baud to see the output
-
-*/
-
-#include <Wire.h> //Needed for I2C to GPS
-
-#include <SparkFun_u-blox_GNSS_Arduino_Library.h> //http://librarymanager/All#SparkFun_u-blox_GNSS
-SFE_UBLOX_GNSS myGNSS;
-
-boolean usingAutoHNRAtt = false;
-boolean usingAutoHNRDyn = false;
-boolean usingAutoHNRPVT = false;
-
-void setup()
-{
-  Serial.begin(115200);
-  while (!Serial); //Wait for user to open terminal
-  Serial.println(F("SparkFun u-blox Example"));
-
-  Wire.begin();
-
-  //myGNSS.enableDebugging(); // Uncomment this line to enable debug messages on Serial
-
-  if (myGNSS.begin() == false) //Connect to the u-blox module using Wire port
-  {
-    Serial.println(F("Warning! u-blox GPS did not begin correctly."));
-    Serial.println(F("(This may be because the I2C port is busy with HNR messages.)"));
-  }
-
-  myGNSS.setI2COutput(COM_TYPE_UBX); //Set the I2C port to output UBX only (turn off NMEA noise)
-  myGNSS.saveConfigSelective(VAL_CFG_SUBSEC_IOPORT); //Save (only) the communications port settings to flash and BBR
-
-  if (myGNSS.setHNRNavigationRate(10) == true) //Set the High Navigation Rate to 10Hz
-    Serial.println(F("setHNRNavigationRate was successful"));
-  else
-    Serial.println(F("setHNRNavigationRate was NOT successful"));
-    
-  usingAutoHNRAtt = myGNSS.setAutoHNRATT(true); //Attempt to enable auto HNR attitude messages
-  if (usingAutoHNRAtt)
-    Serial.println(F("AutoHNRATT successful"));
-  
-  usingAutoHNRDyn = myGNSS.setAutoHNRINS(true); //Attempt to enable auto HNR vehicle dynamics messages  
-  if (usingAutoHNRDyn)
-    Serial.println(F("AutoHNRINS successful"));
-  
-  usingAutoHNRPVT = myGNSS.setAutoHNRPVT(true); //Attempt to enable auto HNR PVT messages
-  if (usingAutoHNRPVT)
-    Serial.println(F("AutoHNRPVT successful"));
-}
-
-void loop()
-{
-  if (usingAutoHNRAtt && (myGNSS.getHNRAtt() == true)) // If setAutoHNRAtt was successful and new data is available
-  {
-    Serial.print(F("Roll: ")); // Print selected data
-    Serial.print(myGNSS.getHNRroll(), 2); // Use the helper function to get the roll in degrees
-    Serial.print(F(" Pitch: "));
-    Serial.print(myGNSS.getHNRpitch(), 2); // Use the helper function to get the pitch in degrees
-    Serial.print(F(" Heading: "));
-    Serial.println(myGNSS.getHNRheading(), 2); // Use the helper function to get the heading in degrees
-    myGNSS.flushHNRATT(); // Mark data as stale
-  }
-  if (usingAutoHNRDyn && (myGNSS.getHNRDyn() == true)) // If setAutoHNRDyn was successful and new data is available
-  {
-    Serial.print(F("xAccel: ")); // Print selected data
-    Serial.print(myGNSS.packetUBXHNRINS->data.xAccel);
-    Serial.print(F(" yAccel: "));
-    Serial.print(myGNSS.packetUBXHNRINS->data.yAccel);
-    Serial.print(F(" zAccel: "));
-    Serial.println(myGNSS.packetUBXHNRINS->data.zAccel);
-    myGNSS.flushHNRINS(); // Mark data as stale
-  }
-  if (usingAutoHNRPVT && (myGNSS.getHNRPVT() == true)) // If setAutoHNRPVT was successful and new data is available
-  {
-    Serial.print(F("ns: ")); // Print selected data
-    Serial.print(myGNSS.packetUBXHNRPVT->data.nano);
-    Serial.print(F(" Lat: "));
-    Serial.print(myGNSS.packetUBXHNRPVT->data.lat);
-    Serial.print(F(" Lon: "));
-    Serial.println(myGNSS.packetUBXHNRPVT->data.lon);
-    myGNSS.flushHNRPVT(); // Mark data as stale
-  }
-}
diff --git a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Example10_AltitudeMSL/Example10_AltitudeMSL.ino b/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Example10_AltitudeMSL/Example10_AltitudeMSL.ino
deleted file mode 100644
index a6f82ee..0000000
--- a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Example10_AltitudeMSL/Example10_AltitudeMSL.ino
+++ /dev/null
@@ -1,82 +0,0 @@
-/*
-  Reading two altitudes - Mean Sea Level and Ellipsode
-  By: Nathan Seidle
-  SparkFun Electronics
-  Date: January 3rd, 2019
-  License: MIT. See license file for more information but you can
-  basically do whatever you want with this code.
-
-  This example shows how to query a u-blox module for its lat/long/altitude. 
-
-  getAltitude() reports mm above ellipsode model of the globe. There are some
-  instances where altitude above Mean Sea Level is better. This example shows how 
-  to use getAltitudeMSL(). The difference varies but is ~20m.
-  Ellipsoid model: https://www.esri.com/news/arcuser/0703/geoid1of3.html
-  Difference between Ellipsoid Model and Mean Sea Level: https://eos-gnss.com/elevation-for-beginners/
-  
-  Leave NMEA parsing behind. Now you can simply ask the module for the datums you want!
-
-  Feel like supporting open source hardware?
-  Buy a board from SparkFun!
-  ZED-F9P RTK2: https://www.sparkfun.com/products/15136
-  NEO-M8P RTK: https://www.sparkfun.com/products/15005
-  SAM-M8Q: https://www.sparkfun.com/products/15106
-
-  Hardware Connections:
-  Plug a Qwiic cable into the GNSS and a BlackBoard
-  If you don't have a platform with a Qwiic connection use the SparkFun Qwiic Breadboard Jumper (https://www.sparkfun.com/products/14425)
-  Open the serial monitor at 115200 baud to see the output
-*/
-
-#include <Wire.h> //Needed for I2C to GNSS
-
-#include <SparkFun_u-blox_GNSS_Arduino_Library.h> //http://librarymanager/All#SparkFun_u-blox_GNSS
-SFE_UBLOX_GNSS myGNSS;
-
-long lastTime = 0; //Tracks the passing of 2000ms (2 seconds)
-
-void setup()
-{
-  Serial.begin(115200);
-  while (!Serial); //Wait for user to open terminal
-  Serial.println("SparkFun u-blox Example");
-
-  Wire.begin();
-
-  if (myGNSS.begin() == false) //Connect to the u-blox module using Wire port
-  {
-    Serial.println(F("u-blox GNSS not detected at default I2C address. Please check wiring. Freezing."));
-    while (1);
-  }
-}
-
-void loop()
-{
-  //Query module only every second. Doing it more often will just cause I2C traffic.
-  //The module only responds when a new position is available
-  if (millis() - lastTime > 1000)
-  {
-    lastTime = millis(); //Update the timer
-    
-    long latitude = myGNSS.getLatitude();
-    Serial.print(F("Lat: "));
-    Serial.print(latitude);
-
-    long longitude = myGNSS.getLongitude();
-    Serial.print(F(" Long: "));
-    Serial.print(longitude);
-    Serial.print(F(" (degrees * 10^-7)"));
-
-    long altitude = myGNSS.getAltitude();
-    Serial.print(F(" Alt: "));
-    Serial.print(altitude);
-    Serial.print(F(" (mm)"));
-
-    long altitudeMSL = myGNSS.getAltitudeMSL();
-    Serial.print(F(" AltMSL: "));
-    Serial.print(altitudeMSL);
-    Serial.print(F(" (mm)"));
-
-    Serial.println();
-  }
-}
diff --git a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Example11_ResetModule/Example1_FactoryDefaultviaI2C/Example1_FactoryDefaultviaI2C.ino b/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Example11_ResetModule/Example1_FactoryDefaultviaI2C/Example1_FactoryDefaultviaI2C.ino
deleted file mode 100644
index 856bcd3..0000000
--- a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Example11_ResetModule/Example1_FactoryDefaultviaI2C/Example1_FactoryDefaultviaI2C.ino
+++ /dev/null
@@ -1,60 +0,0 @@
-/*
-  Send command to reset module over I2C
-  By: Nathan Seidle
-  Date: January 29rd, 2019
-  License: MIT. See license file for more information but you can
-  basically do whatever you want with this code.
-
-  This example shows how to reset the U-Blox module to factory defaults over I2C.
-
-  Feel like supporting open source hardware?
-  Buy a board from SparkFun!
-  ZED-F9P RTK2: https://www.sparkfun.com/products/15136
-  NEO-M8P RTK: https://www.sparkfun.com/products/15005
-  SAM-M8Q: https://www.sparkfun.com/products/15106
-
-  Hardware Connections:
-  Plug a Qwiic cable into the GNSS and a BlackBoard
-  If you don't have a platform with a Qwiic connection use the SparkFun Qwiic Breadboard Jumper (https://www.sparkfun.com/products/14425)
-  Open the serial monitor at 115200 baud to see the output
-*/
-
-#include <SparkFun_u-blox_GNSS_Arduino_Library.h> //http://librarymanager/All#SparkFun_u-blox_GNSS
-SFE_UBLOX_GNSS myGNSS;
-
-void setup()
-{
-  Serial.begin(115200);
-  while (!Serial); //Wait for user to open terminal
-  Serial.println("SparkFun u-blox Example");
-
-  Wire.begin();
-
-  if (myGNSS.begin() == false) //Connect to the u-blox module using Wire port
-  {
-    Serial.println(F("u-blox GNSS not detected at default I2C address. Please check wiring. Freezing."));
-    while (1);
-  }
-
-  while (Serial.available()) Serial.read(); //Trash any incoming chars
-  Serial.println("Press a key to reset module to factory defaults");
-  while (Serial.available() == false) ; //Wait for user to send character
-
-  myGNSS.factoryReset(); //Reset everything: baud rate, I2C address, update rate, everything.
-
-  delay(5000); // Wait while the module restarts
-
-  while (myGNSS.begin() == false) //Attempt to re-connect
-  {
-    delay(1000);
-    Serial.println(F("Attempting to re-connect to u-blox GNSS..."));
-  }
-
-  Serial.println("Unit has now been factory reset. Freezing...");
-  while(1); // Do nothing more
-}
-
-void loop()
-{
-
-}
diff --git a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Example11_ResetModule/Example2_FactoryDefaultsviaSerial/Example2_FactoryDefaultsviaSerial.ino b/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Example11_ResetModule/Example2_FactoryDefaultsviaSerial/Example2_FactoryDefaultsviaSerial.ino
deleted file mode 100644
index 4493f7a..0000000
--- a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Example11_ResetModule/Example2_FactoryDefaultsviaSerial/Example2_FactoryDefaultsviaSerial.ino
+++ /dev/null
@@ -1,110 +0,0 @@
-/*
-  Test baud rate changes on serial, factory reset, and hard reset.
-  By: Thorsten von Eicken
-  Date: January 29rd, 2019
-  License: MIT. See license file for more information but you can
-  basically do whatever you want with this code.
-
-  This example shows how to reset the U-Blox module to factory defaults over serial.
-
-  Feel like supporting open source hardware?
-  Buy a board from SparkFun!
-  ZED-F9P RTK2: https://www.sparkfun.com/products/15136
-  NEO-M8P RTK: https://www.sparkfun.com/products/15005
-  SAM-M8Q: https://www.sparkfun.com/products/15106
-
-  Hardware Connections:
-  Connect the U-Blox serial port to Serial1
-  If you're using a Uno or don't have a 2nd serial port (Serial1), use SoftwareSerial instead (see below)
-  Open the serial monitor at 115200 baud to see the output
-*/
-
-#include <SparkFun_u-blox_GNSS_Arduino_Library.h> //http://librarymanager/All#SparkFun_u-blox_GNSS
-SFE_UBLOX_GNSS myGNSS;
-
-#include <SoftwareSerial.h>
-
-//#define mySerial Serial1 // Uncomment this line to connect via Serial1
-// - or -
-SoftwareSerial mySerial(10, 11); // Uncomment this line to connect via SoftwareSerial(RX, TX). Connect pin 10 to GNSS TX pin.
-
-#define defaultRate 9600 // Uncomment this line if you are using an M8 - which defaults to 9600 Baud on UART1
-// - or -
-//#define defaultRate 38400 // Uncomment this line if you are using an F9 - which defaults to 38400 Baud on UART1
-
-int state = 0; // steps through auto-baud, reset, etc states
-
-void setup()
-{
-  Serial.begin(115200);
-  while (!Serial); //Wait for user to open terminal
-  Serial.println("SparkFun u-blox Example");
-
-  //myGNSS.enableDebugging(); // Uncomment this line to enable helpful debug messages on Serial
-}
-
-void loop()
-{
-    Serial.print("===== STATE ");
-    Serial.println(state);
-    switch (state) {
-    case 0: // auto-baud connection, then switch to 38400 and save config
-        do {
-            Serial.println("GNSS: trying 38400 baud");
-            mySerial.begin(38400);
-            if (myGNSS.begin(mySerial)) break;
-
-            delay(100);
-            Serial.println("GNSS: trying 9600 baud");
-            mySerial.begin(9600);
-            if (myGNSS.begin(mySerial)) {
-                Serial.println("GNSS: connected at 9600 baud, switching to 38400");
-                myGNSS.setSerialRate(38400);
-                delay(100);
-            } else {
-                delay(2000); //Wait a bit before trying again to limit the Serial output flood
-            }
-        } while(1);
-        myGNSS.setUART1Output(COM_TYPE_UBX); //Set the UART port to output UBX only
-        myGNSS.saveConfiguration(); //Save the current settings to flash and BBR
-        Serial.println("GNSS serial connected, saved config");
-        state++;
-        break;
-    case 1: // hardReset, expect to see GNSS back at 38400 baud
-        Serial.println("Issuing hardReset (cold start)");
-        myGNSS.hardReset();
-        delay(2000);
-        mySerial.begin(38400);
-        if (myGNSS.begin(mySerial)) {
-            Serial.println("Success.");
-            state++;
-        } else {
-            Serial.println("*** GNSS did not respond at 38400 baud, starting over.");
-            state = 0;
-        }
-        break;
-    case 2: // factoryReset, expect to see GNSS back at defaultRate baud
-        Serial.println("Issuing factoryReset");
-        myGNSS.factoryReset();
-        delay(5000); // takes more than one second... a loop to resync would be best
-        mySerial.begin(defaultRate);
-        if (myGNSS.begin(mySerial)) {
-            Serial.println("Success.");
-            state++;
-        } else {
-            Serial.println("*** GNSS did not come back at defaultRate baud, starting over.");
-            state = 0;
-        }
-        break;
-    case 3: // print version info
-        // Note: this may fail on boards like the UNO (ATmega328P) with modules like the ZED-F9P
-        // because getProtocolVersion returns a lot of data - more than the UNO's serial buffer can hold
-        Serial.print("GNSS protocol version: ");
-        Serial.print(myGNSS.getProtocolVersionHigh());
-        Serial.print('.');
-        Serial.println(myGNSS.getProtocolVersionLow());
-        Serial.println("All finished! Freezing...");
-        while(1);
-    }
-    delay(1000);
-}
diff --git a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Example12_UseUart/Example12_UseUart.ino b/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Example12_UseUart/Example12_UseUart.ino
deleted file mode 100644
index 5d28e08..0000000
--- a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Example12_UseUart/Example12_UseUart.ino
+++ /dev/null
@@ -1,98 +0,0 @@
-/*
-  Reading lat and long via UBX binary commands using UART @38400 baud - free from I2C
-  By: Nathan Seidle, Adapted from Example3_GetPosition by Thorsten von Eicken
-  SparkFun Electronics
-  Date: January 28rd, 2019
-  License: MIT. See license file for more information but you can
-  basically do whatever you want with this code.
-
-  This example shows how to configure the library and U-Blox for serial port use as well as
-  switching the module from the default 9600 baud to 38400.
-
-  Note: Long/lat are large numbers because they are * 10^7. To convert lat/long
-  to something google maps understands simply divide the numbers by 10,000,000. We 
-  do this so that we don't have to use floating point numbers.
-
-  Leave NMEA parsing behind. Now you can simply ask the module for the datums you want!
-
-  Feel like supporting open source hardware?
-  Buy a board from SparkFun!
-  ZED-F9P RTK2: https://www.sparkfun.com/products/15136
-  NEO-M8P RTK: https://www.sparkfun.com/products/15005
-  SAM-M8Q: https://www.sparkfun.com/products/15106
-
-  Hardware Connections:
-  Connect the U-Blox serial TX pin to Uno pin 10
-  Connect the U-Blox serial RX pin to Uno pin 11
-  Open the serial monitor at 115200 baud to see the output
-*/
-
-#include <SparkFun_u-blox_GNSS_Arduino_Library.h> //http://librarymanager/All#SparkFun_u-blox_GNSS
-SFE_UBLOX_GNSS myGNSS;
-
-#include <SoftwareSerial.h>
-SoftwareSerial mySerial(10, 11); // RX, TX. Pin 10 on Uno goes to TX pin on GNSS module.
-
-long lastTime = 0; //Simple local timer. Limits amount of I2C traffic to u-blox module.
-
-void setup()
-{
-  Serial.begin(115200);
-  while (!Serial); //Wait for user to open terminal
-  Serial.println("SparkFun u-blox Example");
-
-  //Assume that the U-Blox GNSS is running at 9600 baud (the default) or at 38400 baud.
-  //Loop until we're in sync and then ensure it's at 38400 baud.
-  do {
-    Serial.println("GNSS: trying 38400 baud");
-    mySerial.begin(38400);
-    if (myGNSS.begin(mySerial) == true) break;
-
-    delay(100);
-    Serial.println("GNSS: trying 9600 baud");
-    mySerial.begin(9600);
-    if (myGNSS.begin(mySerial) == true) {
-        Serial.println("GNSS: connected at 9600 baud, switching to 38400");
-        myGNSS.setSerialRate(38400);
-        delay(100);
-    } else {
-        //myGNSS.factoryReset();
-        delay(2000); //Wait a bit before trying again to limit the Serial output
-    }
-  } while(1);
-  Serial.println("GNSS serial connected");
-
-  myGNSS.setUART1Output(COM_TYPE_UBX); //Set the UART port to output UBX only
-  myGNSS.setI2COutput(COM_TYPE_UBX); //Set the I2C port to output UBX only (turn off NMEA noise)
-  myGNSS.saveConfiguration(); //Save the current settings to flash and BBR
-}
-
-void loop()
-{
-  //Query module only every second. Doing it more often will just cause I2C traffic.
-  //The module only responds when a new position is available
-  if (millis() - lastTime > 1000)
-  {
-    lastTime = millis(); //Update the timer
-    
-    long latitude = myGNSS.getLatitude();
-    Serial.print(F("Lat: "));
-    Serial.print(latitude);
-
-    long longitude = myGNSS.getLongitude();
-    Serial.print(F(" Long: "));
-    Serial.print(longitude);
-    Serial.print(F(" (degrees * 10^-7)"));
-
-    long altitude = myGNSS.getAltitude();
-    Serial.print(F(" Alt: "));
-    Serial.print(altitude);
-    Serial.print(F(" (mm)"));
-
-    byte SIV = myGNSS.getSIV();
-    Serial.print(F(" SIV: "));
-    Serial.print(SIV);
-
-    Serial.println();
-  }
-}
diff --git a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Example13_PVT/Example1_AutoPVT/Example1_AutoPVT.ino b/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Example13_PVT/Example1_AutoPVT/Example1_AutoPVT.ino
deleted file mode 100644
index f82d4bc..0000000
--- a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Example13_PVT/Example1_AutoPVT/Example1_AutoPVT.ino
+++ /dev/null
@@ -1,141 +0,0 @@
-/*
-  Configuring the GNSS to automatically send position reports over I2C
-  By: Nathan Seidle and Thorsten von Eicken
-  SparkFun Electronics
-  Date: January 3rd, 2019
-  License: MIT. See license file for more information but you can
-  basically do whatever you want with this code.
-
-  This example shows how to configure the U-Blox GNSS the send navigation reports automatically
-  and retrieving the latest one via getPVT. This eliminates the blocking in getPVT while the GNSS
-  produces a fresh navigation solution at the expense of returning a slighly old solution.
-
-  This can be used over serial or over I2C, this example shows the I2C use. With serial the GNSS
-  simply outputs the UBX_NAV_PVT packet. With I2C it queues it into its internal I2C buffer (4KB in
-  size?) where it can be retrieved in the next I2C poll.
-
-  Feel like supporting open source hardware?
-  Buy a board from SparkFun!
-  ZED-F9P RTK2: https://www.sparkfun.com/products/15136
-  NEO-M8P RTK: https://www.sparkfun.com/products/15005
-  SAM-M8Q: https://www.sparkfun.com/products/15106
-
-  Hardware Connections:
-  Plug a Qwiic cable into the GNSS and a BlackBoard
-  If you don't have a platform with a Qwiic connection use the SparkFun Qwiic Breadboard Jumper (https://www.sparkfun.com/products/14425)
-  Open the serial monitor at 115200 baud to see the output
-*/
-
-#include <Wire.h> //Needed for I2C to GNSS
-
-#include <SparkFun_u-blox_GNSS_Arduino_Library.h> //http://librarymanager/All#SparkFun_u-blox_GNSS
-SFE_UBLOX_GNSS myGNSS;
-
-void setup()
-{
-  Serial.begin(115200);
-  while (!Serial); //Wait for user to open terminal
-  Serial.println("SparkFun u-blox Example");
-
-  Wire.begin();
-
-  if (myGNSS.begin() == false) //Connect to the u-blox module using Wire port
-  {
-    Serial.println(F("u-blox GNSS not detected at default I2C address. Please check wiring. Freezing."));
-    while (1);
-  }
-
-  myGNSS.setI2COutput(COM_TYPE_UBX); //Set the I2C port to output UBX only (turn off NMEA noise)
-  myGNSS.setNavigationFrequency(2); //Produce two solutions per second
-  myGNSS.setAutoPVT(true); //Tell the GNSS to "send" each solution
-  //myGNSS.saveConfiguration(); //Optional: Save the current settings to flash and BBR
-}
-
-void loop()
-{
-  // Calling getPVT returns true if there actually is a fresh navigation solution available.
-  // Start the reading only when valid LLH is available
-  if (myGNSS.getPVT() && (myGNSS.getInvalidLlh() == false))
-  {
-    Serial.println();
-    long latitude = myGNSS.getLatitude();
-    Serial.print(F("Lat: "));
-    Serial.print(latitude);
-
-    long longitude = myGNSS.getLongitude();
-    Serial.print(F(" Long: "));
-    Serial.print(longitude);
-    Serial.print(F(" (degrees * 10^-7)"));
-
-    long altitude = myGNSS.getAltitude();
-    Serial.print(F(" Alt: "));
-    Serial.print(altitude);
-    Serial.print(F(" (mm)"));
-
-    byte SIV = myGNSS.getSIV();
-    Serial.print(F(" SIV: "));
-    Serial.print(SIV);
-
-    int PDOP = myGNSS.getPDOP();
-    Serial.print(F(" PDOP: "));
-    Serial.print(PDOP);
-    Serial.print(F(" (10^-2)"));
-
-    int nedNorthVel = myGNSS.getNedNorthVel();
-    Serial.print(F(" VelN: "));
-    Serial.print(nedNorthVel);
-    Serial.print(F(" (mm/s)"));
-
-    int nedEastVel = myGNSS.getNedEastVel();
-    Serial.print(F(" VelE: "));
-    Serial.print(nedEastVel);
-    Serial.print(F(" (mm/s)"));
-
-    int nedDownVel = myGNSS.getNedDownVel();
-    Serial.print(F(" VelD: "));
-    Serial.print(nedDownVel);
-    Serial.print(F(" (mm/s)"));
-
-    int verticalAccEst = myGNSS.getVerticalAccEst();
-    Serial.print(F(" VAccEst: "));
-    Serial.print(verticalAccEst);
-    Serial.print(F(" (mm)"));
-
-    int horizontalAccEst = myGNSS.getHorizontalAccEst();
-    Serial.print(F(" HAccEst: "));
-    Serial.print(horizontalAccEst);
-    Serial.print(F(" (mm)"));
-
-    int speedAccEst = myGNSS.getSpeedAccEst();
-    Serial.print(F(" SpeedAccEst: "));
-    Serial.print(speedAccEst);
-    Serial.print(F(" (mm/s)"));
-
-    int headAccEst = myGNSS.getHeadingAccEst();
-    Serial.print(F(" HeadAccEst: "));
-    Serial.print(headAccEst);
-    Serial.print(F(" (degrees * 10^-5)"));
-
-    if (myGNSS.getHeadVehValid() == true) {
-      int headVeh = myGNSS.getHeadVeh();
-      Serial.print(F(" HeadVeh: "));
-      Serial.print(headVeh);
-      Serial.print(F(" (degrees * 10^-5)"));
-
-      int magDec = myGNSS.getMagDec();
-      Serial.print(F(" MagDec: "));
-      Serial.print(magDec);
-      Serial.print(F(" (degrees * 10^-2)"));
-
-      int magAcc = myGNSS.getMagAcc();
-      Serial.print(F(" MagAcc: "));
-      Serial.print(magAcc);
-      Serial.print(F(" (degrees * 10^-2)"));
-    }
-
-    Serial.println();
-  } else {
-    Serial.print(".");
-    delay(50);
-  }
-}
diff --git a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Example13_PVT/Example2_AutoPVT_ExplicitUpdate/Example2_AutoPVT_ExplicitUpdate.ino b/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Example13_PVT/Example2_AutoPVT_ExplicitUpdate/Example2_AutoPVT_ExplicitUpdate.ino
deleted file mode 100644
index 429b2ad..0000000
--- a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Example13_PVT/Example2_AutoPVT_ExplicitUpdate/Example2_AutoPVT_ExplicitUpdate.ino
+++ /dev/null
@@ -1,103 +0,0 @@
-/*
-  Configuring the GNSS to automatically send position reports over I2C, with explicit data parsing calls
-  By: Nathan Seidle Thorsten von Eicken and Felix Jirka
-  SparkFun Electronics
-  Date: July 1st, 2019
-  License: MIT. See license file for more information but you can
-  basically do whatever you want with this code.
-
-  This example shows how to configure the U-Blox GNSS the send navigation reports automatically
-  and retrieving the latest one via checkUblox when available.
-  This eliminates the implicit update in getPVT when accessing data fields twice.
-  Also this reduces the memory overhead of a separate buffer while introducing a slight error by inconsistencies because of the unsynchronized updates (on a multi core system).
-
-  This can be used over serial or over I2C, this example shows the I2C use. With serial the GNSS
-  simply outputs the UBX_NAV_PVT packet. With I2C it queues it into its internal I2C buffer (4KB in
-  size?) where it can be retrieved in the next I2C poll.
-
-  Feel like supporting open source hardware?
-  Buy a board from SparkFun!
-  ZED-F9P RTK2: https://www.sparkfun.com/products/15136
-  NEO-M8P RTK: https://www.sparkfun.com/products/15005
-  SAM-M8Q: https://www.sparkfun.com/products/15106
-
-  Hardware Connections:
-  Plug a Qwiic cable into the GNSS and a BlackBoard
-  If you don't have a platform with a Qwiic connection use the SparkFun Qwiic Breadboard Jumper (https://www.sparkfun.com/products/14425)
-  Open the serial monitor at 115200 baud to see the output
-*/
-
-#include <Wire.h> //Needed for I2C to GNSS
-
-#include <SparkFun_u-blox_GNSS_Arduino_Library.h> //http://librarymanager/All#SparkFun_u-blox_GNSS
-SFE_UBLOX_GNSS myGNSS;
-
-void setup()
-{
-  Serial.begin(115200);
-  while (!Serial)
-    ; //Wait for user to open terminal
-  Serial.println("SparkFun u-blox Example");
-
-  Wire.begin();
-
-  if (myGNSS.begin() == false) //Connect to the u-blox module using Wire port
-  {
-    Serial.println(F("u-blox GNSS not detected at default I2C address. Please check wiring. Freezing."));
-    while (1)
-      ;
-  }
-
-  myGNSS.setI2COutput(COM_TYPE_UBX); //Set the I2C port to output UBX only (turn off NMEA noise)
-  myGNSS.setNavigationFrequency(2);  //Produce two solutions per second
-  myGNSS.setAutoPVT(true, false);    //Tell the GNSS to "send" each solution and the lib not to update stale data implicitly
-  //myGNSS.saveConfiguration();        //Optional: Save the current settings to flash and BBR
-}
-
-/*
-     Calling getPVT would return false now (compare to previous example where it would return true), so we just use the data provided
-     If you are using a threaded OS eg. FreeRTOS on an ESP32, the explicit mode of autoPVT allows you to use the data provided on both cores and inside multiple threads
-     The data update in background creates an inconsistent state, but that should not cause issues for most applications as they usually won't change the GNSS location significantly within a 2Hz - 5Hz update rate.
-     Also you could oversample (10Hz - 20Hz) the data to smooth out such issues...
-*/
-void loop()
-{
-  static uint16_t counter = 0;
-
-  if (counter % 10 == 0)
-  {
-    // update your AHRS filter here for a ~100Hz update rate
-    // GNSS data will be quasi static but data from your IMU will be changing
-  }
-  // debug output each half second
-  if (counter % 500 == 0)
-  {
-    Serial.println();
-    long latitude = myGNSS.getLatitude();
-    Serial.print(F("Lat: "));
-    Serial.print(latitude);
-
-    long longitude = myGNSS.getLongitude();
-    Serial.print(F(" Long: "));
-    Serial.print(longitude);
-    Serial.print(F(" (degrees * 10^-7)"));
-
-    long altitude = myGNSS.getAltitude();
-    Serial.print(F(" Alt: "));
-    Serial.print(altitude);
-    Serial.print(F(" (mm)"));
-
-    byte SIV = myGNSS.getSIV();
-    Serial.print(F(" SIV: "));
-    Serial.print(SIV);
-
-    Serial.println();
-  }
-  // call checkUblox all 50ms to capture the GNSS data
-  if (counter % 50 == 0)
-  {
-    myGNSS.checkUblox();
-  }
-  delay(1);
-  counter++;
-}
diff --git a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Example13_PVT/Example3_AutoPVTviaUart/Example3_AutoPVTviaUart.ino b/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Example13_PVT/Example3_AutoPVTviaUart/Example3_AutoPVTviaUart.ino
deleted file mode 100644
index 8aa3937..0000000
--- a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Example13_PVT/Example3_AutoPVTviaUart/Example3_AutoPVTviaUart.ino
+++ /dev/null
@@ -1,107 +0,0 @@
-/*
-  Configuring the GNSS to automatically send position reports over Serial
-  By: Nathan Seidle, Adapted from Example11 by Felix Jirka
-  SparkFun Electronics
-  Date: July 2nd, 2019
-  License: MIT. See license file for more information but you can
-  basically do whatever you want with this code.
-
-  This example shows how to configure the U-Blox GNSS the send navigation reports automatically
-  and retrieving the latest one via getPVT. This eliminates the blocking in getPVT while the GNSS
-  produces a fresh navigation solution at the expense of returning a slighly old solution.
-
-  This can be used over serial or over I2C, this example shows the Serial use. With serial the GNSS
-  simply outputs the UBX_NAV_PVT packet. With I2C it queues it into its internal I2C buffer (4KB in
-  size?) where it can be retrieved in the next I2C poll.
-
-  Leave NMEA parsing behind. Now you can simply ask the module for the datums you want!
-
-  Feel like supporting open source hardware?
-  Buy a board from SparkFun!
-  ZED-F9P RTK2: https://www.sparkfun.com/products/15136
-  NEO-M8P RTK: https://www.sparkfun.com/products/15005
-  SAM-M8Q: https://www.sparkfun.com/products/15106
-
-  Hardware Connections:
-  Plug a Qwiic cable into the GNSS and a BlackBoard
-  If you don't have a platform with a Qwiic connection use the SparkFun Qwiic Breadboard Jumper (https://www.sparkfun.com/products/14425)
-  Open the serial monitor at 115200 baud to see the output
-*/
-
-#include <SparkFun_u-blox_GNSS_Arduino_Library.h> //http://librarymanager/All#SparkFun_u-blox_GNSS
-SFE_UBLOX_GNSS myGNSS;
-
-#include <SoftwareSerial.h>
-
-//#define mySerial Serial2 // Uncomment this line to connect via Serial2
-// - or -
-SoftwareSerial mySerial(10, 11); // Uncomment this line to connect via SoftwareSerial(RX, TX). Connect pin 10 to GNSS TX pin.
-
-//#define baudRate 9600 // Uncomment this line to select 9600 Baud for the M8
-// - or -
-#define baudRate 38400 // Uncomment this line to select 38400 Baud for the F9
-
-void setup()
-{
-  Serial.begin(115200);
-  while (!Serial); //Wait for user to open terminal
-  Serial.println("SparkFun u-blox Example");
-
-  mySerial.begin(baudRate); // Start the Serial port
-
-  if (myGNSS.begin(mySerial) == false) //Connect to the u-blox module using Serial
-  {
-    Serial.println(F("u-blox GNSS not detected. Please check wiring. Freezing."));
-    while (1);
-  }
-
-  myGNSS.setUART1Output(COM_TYPE_UBX); //Set the UART1 port to output UBX only (turn off NMEA noise)
-  myGNSS.setNavigationFrequency(2); //Produce two solutions per second
-  myGNSS.setAutoPVT(true); //Tell the GNSS to "send" each solution
-  //myGNSS.saveConfiguration(); //Optional: Save the current settings to flash and BBR
-}
-
-void loop()
-{
-  // getPVT will return true if there actually is a fresh navigation solution available.
-  // Important note: the PVT message is 100 bytes long. We need to call getPVT often enough
-  // to prevent serial buffer overflows on boards like the original RedBoard / UNO.
-  // At 38400 Baud, the 100 PVT bytes will arrive in 26ms.
-  // On the RedBoard, we need to call getPVT every 5ms to keep up.
-  if (myGNSS.getPVT())
-  {
-    Serial.println();
-
-    long latitude = myGNSS.getLatitude();
-    Serial.print(F("Lat: "));
-    Serial.print(latitude);
-
-    long longitude = myGNSS.getLongitude();
-    Serial.print(F(" Long: "));
-    Serial.print(longitude);
-    Serial.print(F(" (degrees * 10^-7)"));
-
-    long altitude = myGNSS.getAltitude();
-    Serial.print(F(" Alt: "));
-    Serial.print(altitude);
-    Serial.print(F(" (mm)"));
-
-    byte SIV = myGNSS.getSIV();
-    Serial.print(F(" SIV: "));
-    Serial.print(SIV);
-
-    Serial.println();
-  }
-  else
-  {
-    delay(5); // Delay for 5ms only
-
-    static int counter = 0; // Print a dot every 50ms
-    counter++;
-    if (counter > 10)
-    {
-      Serial.print(".");
-      counter = 0;
-    }
-  }
-}
diff --git a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Example13_PVT/Example4_AssumeAutoPVTviaUart/Example4_AssumeAutoPVTviaUart.ino b/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Example13_PVT/Example4_AssumeAutoPVTviaUart/Example4_AssumeAutoPVTviaUart.ino
deleted file mode 100644
index 756a8b0..0000000
--- a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Example13_PVT/Example4_AssumeAutoPVTviaUart/Example4_AssumeAutoPVTviaUart.ino
+++ /dev/null
@@ -1,110 +0,0 @@
-/*
-  Reading lat and long via UBX binary commands using an RX-only UART
-  By: Nathan Seidle, Adapted from Example11 by Felix Jirka
-  SparkFun Electronics
-  Date: July 2nd, 2019
-  License: MIT. See license file for more information but you can
-  basically do whatever you want with this code.
-
-  This example shows how to configure the library for serial port use with a single wire connection using the assumeAutoPVT method.
-  Saving your pins for other stuff :-)
-
-  This example only works correctly if the module has already been configured is sending PVT messages via its UART1 TX pin.
-  Run the previous example to enable the auto PVT messages if you need to.
-
-  Leave NMEA parsing behind. Now you can simply ask the module for the datums you want!
-
-  Feel like supporting open source hardware?
-  Buy a board from SparkFun!
-  ZED-F9P RTK2: https://www.sparkfun.com/products/15136
-  NEO-M8P RTK: https://www.sparkfun.com/products/15005
-  SAM-M8Q: https://www.sparkfun.com/products/15106
-
-  Preconditions:
-  U-Blox module is configured to send cyclical PVT message
-  
-  Hardware Connections:
-  Connect the U-Blox serial TX pin to Rx of Serial2 (default: GPIO16) on your ESP32
-  Or, switch to SoftwareSerial
-  Open the serial monitor at 115200 baud to see the output
-*/
-
-#include <SparkFun_u-blox_GNSS_Arduino_Library.h> //http://librarymanager/All#SparkFun_u-blox_GNSS
-SFE_UBLOX_GNSS myGNSS;
-
-#include <SoftwareSerial.h>
-
-//#define mySerial Serial2 // Uncomment this line to connect via Serial2
-// - or -
-SoftwareSerial mySerial(10, 11); // Uncomment this line to connect via SoftwareSerial(RX, TX). Connect pin 10 to GNSS TX pin.
-
-//#define baudRate 9600 // Uncomment this line to select 9600 Baud for the M8
-// - or -
-#define baudRate 38400 // Uncomment this line to select 38400 Baud for the F9
-
-void setup()
-{
-  Serial.begin(115200);
-  while (!Serial); //Wait for user to open terminal
-  Serial.println("SparkFun u-blox Example");
-
-  //Use any Serial port with at least a RX Pin connected or a receive only version of SoftwareSerial here
-  //Assume that the U-Blox GNSS is running at baudRate baud
-  mySerial.begin(baudRate);
-  // No need to check return value as internal call to isConnected() will not succeed
-  myGNSS.begin(mySerial);
-
-  // Tell the library we are expecting the module to send PVT messages by itself to our Rx pin.
-  // You can set second parameter to "false" if you want to control the parsing and eviction of the data (need to call checkUblox cyclically)
-  myGNSS.assumeAutoPVT(true, true);
-
-}
-
-void loop()
-{
-  // If implicit updates are enabled, calling getPVT will trigger parsing of the incoming messages
-  // and return true once a PVT message has been parsed.
-  // In case you want to use explicit updates, wrap this in a timer and call checkUblox()
-  // as often as needed, not to overflow your UART buffers.
-  //
-  // Important note: the PVT message is 100 bytes long. We need to call getPVT often enough
-  // to prevent serial buffer overflows on boards like the original RedBoard / UNO.
-  // At 38400 Baud, the 100 PVT bytes will arrive in 26ms.
-  // On the RedBoard, we need to call getPVT every 5ms to keep up.
-  if (myGNSS.getPVT())
-  {
-    Serial.println();
-
-    long latitude = myGNSS.getLatitude();
-    Serial.print(F("Lat: "));
-    Serial.print(latitude);
-
-    long longitude = myGNSS.getLongitude();
-    Serial.print(F(" Long: "));
-    Serial.print(longitude);
-    Serial.print(F(" (degrees * 10^-7)"));
-
-    long altitude = myGNSS.getAltitude();
-    Serial.print(F(" Alt: "));
-    Serial.print(altitude);
-    Serial.print(F(" (mm)"));
-
-    byte SIV = myGNSS.getSIV();
-    Serial.print(F(" SIV: "));
-    Serial.print(SIV);
-
-    Serial.println();
-  }
-  else
-  {
-    delay(5); // Delay for 5ms only
-
-    static int counter = 0; // Print a dot every 50ms
-    counter++;
-    if (counter > 10)
-    {
-      Serial.print(".");
-      counter = 0;
-    }
-  }
-}
diff --git a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Example14_DebugOutput/Example14_DebugOutput.ino b/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Example14_DebugOutput/Example14_DebugOutput.ino
deleted file mode 100644
index 544655e..0000000
--- a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Example14_DebugOutput/Example14_DebugOutput.ino
+++ /dev/null
@@ -1,107 +0,0 @@
-/*
-  Debug Output
-  By: Nathan Seidle, Adapted from Example3_GetPosition by Thorsten von Eicken
-  SparkFun Electronics
-  Date: January 28rd, 2019
-  License: MIT. See license file for more information but you can
-  basically do whatever you want with this code.
-
-  This example shows how to configure the debug output from the library.
-  Debug shows various packet and status outputs. These prints can be directed
-  towards Serial (as in Serial.print) or any other port (Serial1, SerialUSB, etc).
-
-  You can also limit the debug messages to the "critical" ones by adding an extra argument.
-
-  The debug messages can be disabled again by calling disableDebugging()
-
-  Feel like supporting open source hardware?
-  Buy a board from SparkFun!
-  ZED-F9P RTK2: https://www.sparkfun.com/products/15136
-  NEO-M8P RTK: https://www.sparkfun.com/products/15005
-  SAM-M8Q: https://www.sparkfun.com/products/15106
-
-  Hardware Connections:
-  Plug a Qwiic cable into the GNSS and a BlackBoard
-  If you don't have a platform with a Qwiic connection use the SparkFun Qwiic Breadboard Jumper (https://www.sparkfun.com/products/14425)
-  Open the serial monitor at 115200 baud to see the output
-*/
-
-#include <SparkFun_u-blox_GNSS_Arduino_Library.h> //http://librarymanager/All#SparkFun_u-blox_GNSS
-SFE_UBLOX_GNSS myGNSS;
-
-unsigned long lastTime = 0; //Simple local timer. Limits amount if I2C traffic to u-blox module.
-int counter = 0; // Disable the debug messages when counter reaches 20
-
-void setup()
-{
-  Serial.begin(115200);
-  while (!Serial); //Wait for user to open terminal
-  Serial.println("SparkFun u-blox Example");
-
-  Wire.begin();
-
-  if (myGNSS.begin() == false) //Connect to the u-blox module using Wire port
-  {
-    Serial.println(F("u-blox GNSS not detected at default I2C address. Please check wiring. Freezing."));
-    while (1);
-  }
-
-  myGNSS.setI2COutput(COM_TYPE_UBX); //Set the I2C port to output UBX only (turn off NMEA noise)
-  //myGNSS.saveConfiguration(); //Optional: Save the current settings to flash and BBR
-
-  myGNSS.enableDebugging(); //Enable all the debug messages over Serial (default)
-  
-  //myGNSS.enableDebugging(SerialUSB); //Enable debug messages over Serial USB
-
-  //myGNSS.enableDebugging(Serial, true); //Enable only the critical debug messages over Serial
-  
-}
-
-void loop()
-{
-  //Query module only every second. Doing it more often will just cause I2C traffic.
-  //The module only responds when a new position is available
-  if (millis() - lastTime > 1000)
-  {
-    lastTime = millis(); //Update the timer
-    
-    long latitude = myGNSS.getLatitude();
-    Serial.print(F("Lat: "));
-    Serial.print(latitude);
-
-    long longitude = myGNSS.getLongitude();
-    Serial.print(F(" Long: "));
-    Serial.print(longitude);
-    Serial.print(F(" (degrees * 10^-7)"));
-
-    long altitude = myGNSS.getAltitude();
-    Serial.print(F(" Alt: "));
-    Serial.print(altitude);
-    Serial.print(F(" (mm)"));
-
-    byte SIV = myGNSS.getSIV();
-    Serial.print(F(" SIV: "));
-    Serial.print(SIV);
-
-    Serial.print(F("   "));
-    Serial.print(myGNSS.getYear());
-    Serial.print(F("-"));
-    Serial.print(myGNSS.getMonth());
-    Serial.print(F("-"));
-    Serial.print(myGNSS.getDay());
-    Serial.print(F(" "));
-    Serial.print(myGNSS.getHour());
-    Serial.print(F(":"));
-    Serial.print(myGNSS.getMinute());
-    Serial.print(F(":"));
-    Serial.println(myGNSS.getSecond());
-    
-    Serial.println();
-
-    counter++; // Increment counter
-    if (counter == 20)
-    {
-      myGNSS.disableDebugging(); // Disable the debug messages when counter reaches 20
-    }
-  }
-}
diff --git a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Example15_GetDateTime/Example15_GetDateTime.ino b/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Example15_GetDateTime/Example15_GetDateTime.ino
deleted file mode 100644
index bdbaf63..0000000
--- a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Example15_GetDateTime/Example15_GetDateTime.ino
+++ /dev/null
@@ -1,107 +0,0 @@
-/*
-  Getting time and date using u-blox commands
-  By: davidallenmann
-  SparkFun Electronics
-  Date: April 16th, 2019
-  License: MIT. See license file for more information but you can
-  basically do whatever you want with this code.
-
-  This example shows how to query a u-blox module for the current time and date. We also
-  turn off the NMEA output on the I2C port. This decreases the amount of I2C traffic
-  dramatically.
-
-  Leave NMEA parsing behind. Now you can simply ask the module for the datums you want!
-
-  Feel like supporting open source hardware?
-  Buy a board from SparkFun!
-  ZED-F9P RTK2: https://www.sparkfun.com/products/15136
-  NEO-M8P RTK: https://www.sparkfun.com/products/15005
-  SAM-M8Q: https://www.sparkfun.com/products/15106
-
-  Hardware Connections:
-  Plug a Qwiic cable into the GNSS and a BlackBoard
-  If you don't have a platform with a Qwiic connection use the SparkFun Qwiic Breadboard Jumper (https://www.sparkfun.com/products/14425)
-  Open the serial monitor at 115200 baud to see the output
-*/
-
-#include <Wire.h> //Needed for I2C to GNSS
-
-#include <SparkFun_u-blox_GNSS_Arduino_Library.h> //http://librarymanager/All#SparkFun_u-blox_GNSS
-SFE_UBLOX_GNSS myGNSS;
-
-long lastTime = 0; //Simple local timer. Limits amount if I2C traffic to u-blox module.
-
-void setup()
-{
-  Serial.begin(115200);
-  while (!Serial)
-    ; //Wait for user to open terminal
-  Serial.println("SparkFun u-blox Example");
-
-  Wire.begin();
-
-  if (myGNSS.begin() == false) //Connect to the u-blox module using Wire port
-  {
-    Serial.println(F("u-blox GNSS not detected at default I2C address. Please check wiring. Freezing."));
-    while (1)
-      ;
-  }
-
-  myGNSS.setI2COutput(COM_TYPE_UBX); //Set the I2C port to output UBX only (turn off NMEA noise)
-  //myGNSS.saveConfiguration();        //Optional: Save the current settings to flash and BBR
-}
-
-void loop()
-{
-  //Query module only every second. Doing it more often will just cause I2C traffic.
-  //The module only responds when a new position is available
-  if (millis() - lastTime > 1000)
-  {
-    lastTime = millis(); //Update the timer
-
-    long latitude = myGNSS.getLatitude();
-    Serial.print(F("Lat: "));
-    Serial.print(latitude);
-
-    long longitude = myGNSS.getLongitude();
-    Serial.print(F(" Long: "));
-    Serial.print(longitude);
-    Serial.print(F(" (degrees * 10^-7)"));
-
-    long altitude = myGNSS.getAltitude();
-    Serial.print(F(" Alt: "));
-    Serial.print(altitude);
-    Serial.print(F(" (mm)"));
-
-    byte SIV = myGNSS.getSIV();
-    Serial.print(F(" SIV: "));
-    Serial.print(SIV);
-
-    Serial.println();
-    Serial.print(myGNSS.getYear());
-    Serial.print("-");
-    Serial.print(myGNSS.getMonth());
-    Serial.print("-");
-    Serial.print(myGNSS.getDay());
-    Serial.print(" ");
-    Serial.print(myGNSS.getHour());
-    Serial.print(":");
-    Serial.print(myGNSS.getMinute());
-    Serial.print(":");
-    Serial.print(myGNSS.getSecond());
-
-    Serial.print("  Time is ");
-    if (myGNSS.getTimeValid() == false)
-    {
-      Serial.print("not ");
-    }
-    Serial.print("valid  Date is ");
-    if (myGNSS.getDateValid() == false)
-    {
-      Serial.print("not ");
-    }
-    Serial.print("valid");
-
-    Serial.println();
-  }
-}
diff --git a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Example16_Nanosecond_MaxOutput/Example16_Nanosecond_MaxOutput.ino b/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Example16_Nanosecond_MaxOutput/Example16_Nanosecond_MaxOutput.ino
deleted file mode 100644
index 6fa1d68..0000000
--- a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Example16_Nanosecond_MaxOutput/Example16_Nanosecond_MaxOutput.ino
+++ /dev/null
@@ -1,109 +0,0 @@
-/*
-  Getting time and date using u-blox commands
-  By: davidallenmann
-  SparkFun Electronics
-  Date: April 16th, 2019
-  License: MIT. See license file for more information but you can
-  basically do whatever you want with this code.
-
-  This example shows how to query a u-blox module for the current time and date. We also
-  turn off the NMEA output on the I2C port. This decreases the amount of I2C traffic
-  dramatically.
-
-  Note: you will need to set your Serial Monitor to 500000 Baud to see the output
-
-  Leave NMEA parsing behind. Now you can simply ask the module for the datums you want!
-
-  Feel like supporting open source hardware?
-  Buy a board from SparkFun!
-  ZED-F9P RTK2: https://www.sparkfun.com/products/15136
-  NEO-M8P RTK: https://www.sparkfun.com/products/15005
-  SAM-M8Q: https://www.sparkfun.com/products/15106
-
-  Hardware Connections:
-  Plug a Qwiic cable into the GNSS and a BlackBoard
-  If you don't have a platform with a Qwiic connection use the SparkFun Qwiic Breadboard Jumper (https://www.sparkfun.com/products/14425)
-  Open the serial monitor at 115200 baud to see the output
-*/
-
-#include <Wire.h> //Needed for I2C to GNSS
-
-#include <SparkFun_u-blox_GNSS_Arduino_Library.h> //http://librarymanager/All#SparkFun_u-blox_GNSS
-SFE_UBLOX_GNSS myGNSS;
-
-long lastTime = 0; //Simple local timer. Limits amount if I2C traffic to u-blox module.
-
-void setup()
-{
-  Serial.begin(500000); //Increase serial speed to maximize
-  while (!Serial)
-    ; //Wait for user to open terminal
-  Serial.println("SparkFun u-blox Example");
-
-  Wire.begin();
-  Wire.setClock(400000); // Increase I2C clock speed to 400kHz
-
-  //myGNSS.enableDebugging(); //Uncomment this line to enable debug messages over Serial
-
-  if (myGNSS.begin() == false) //Connect to the u-blox module using Wire port
-  {
-    Serial.println(F("u-blox GNSS not detected at default I2C address. Please check wiring. Freezing."));
-    while (1)
-      ;
-  }
-
-  myGNSS.setI2COutput(COM_TYPE_UBX); //Set the I2C port to output UBX only (turn off NMEA noise)
-  //myGNSS.saveConfiguration(); //Optional: Save the current settings to flash and BBR
-
-  myGNSS.setNavigationFrequency(5); //Set output to 5 times a second
-  
-  byte rate = myGNSS.getNavigationFrequency(); //Get the update rate of this module
-  Serial.print("Current update rate: ");
-  Serial.println(rate);
-}
-
-void loop()
-{
-  // Calling getPVT returns true if there actually is a fresh navigation solution available.
-  if (myGNSS.getPVT())
-  {
-    lastTime = millis(); //Update the timer
-
-    long latitude = myGNSS.getLatitude();
-    Serial.print(F("Lat: "));
-    Serial.print(latitude);
-
-    long longitude = myGNSS.getLongitude();
-    Serial.print(F(" Long: "));
-    Serial.print(longitude);
-    Serial.print(F(" (degrees * 10^-7)"));
-
-    long altitude = myGNSS.getAltitude();
-    Serial.print(F(" Alt: "));
-    Serial.print(altitude);
-    Serial.print(F(" (mm)"));
-
-    byte SIV = myGNSS.getSIV();
-    Serial.print(F(" SIV: "));
-    Serial.print(SIV);
-
-    Serial.print(" ");
-    Serial.print(myGNSS.getYear());
-    Serial.print("-");
-    Serial.print(myGNSS.getMonth());
-    Serial.print("-");
-    Serial.print(myGNSS.getDay());
-    Serial.print(" ");
-    Serial.print(myGNSS.getHour());
-    Serial.print(":");
-    Serial.print(myGNSS.getMinute());
-    Serial.print(":");
-    Serial.print(myGNSS.getSecond());
-    Serial.print(" nanoseconds: ");
-    Serial.print(myGNSS.getNanosecond()); // Nanoseconds can be negative
-
-    myGNSS.flushPVT();
-
-    Serial.println();
-  }
-}
diff --git a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Example16_PartialSecond_MaxOutput/Example16_PartialSecond_MaxOutput.ino b/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Example16_PartialSecond_MaxOutput/Example16_PartialSecond_MaxOutput.ino
deleted file mode 100644
index aee070b..0000000
--- a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Example16_PartialSecond_MaxOutput/Example16_PartialSecond_MaxOutput.ino
+++ /dev/null
@@ -1,118 +0,0 @@
-/*
-  Getting time and date using u-blox commands
-  By: Nathan Seidle
-  SparkFun Electronics
-  Date: April 16th, 2019
-  License: MIT. See license file for more information but you can
-  basically do whatever you want with this code.
-
-  This example shows how to use the Millisecond and Nanosecond output as well as increase the
-  I2C speed (100 to 400kHz), and serial output (115200 to 500kbps).
-
-  Note: you will need to set your Serial Monitor to 500000 Baud to see the output
-
-  Leave NMEA parsing behind. Now you can simply ask the module for the datums you want!
-
-  Feel like supporting open source hardware?
-  Buy a board from SparkFun!
-  ZED-F9P RTK2: https://www.sparkfun.com/products/15136
-  NEO-M8P RTK: https://www.sparkfun.com/products/15005
-  SAM-M8Q: https://www.sparkfun.com/products/15106
-
-  Hardware Connections:
-  Plug a Qwiic cable into the GNSS and a BlackBoard
-  If you don't have a platform with a Qwiic connection use the SparkFun Qwiic Breadboard Jumper (https://www.sparkfun.com/products/14425)
-  Open the serial monitor at 115200 baud to see the output
-*/
-
-#include <Wire.h> //Needed for I2C to GNSS
-
-#include <SparkFun_u-blox_GNSS_Arduino_Library.h> //http://librarymanager/All#SparkFun_u-blox_GNSS
-SFE_UBLOX_GNSS myGNSS;
-
-long lastTime = 0; //Simple local timer. Limits amount if I2C traffic to u-blox module.
-
-void setup()
-{
-  Serial.begin(500000); //Increase serial speed to maximize
-  while (!Serial)
-    ; //Wait for user to open terminal
-  Serial.println("SparkFun u-blox Example");
-
-  Wire.begin();
-  Wire.setClock(400000); // Increase I2C clock speed to 400kHz
-
-  //myGNSS.enableDebugging(); //Uncomment this line to enable debug messages over Serial
-
-  if (myGNSS.begin() == false) //Connect to the u-blox module using Wire port
-  {
-    Serial.println(F("u-blox GNSS not detected at default I2C address. Please check wiring. Freezing."));
-    while (1)
-      ;
-  }
-
-  myGNSS.setI2COutput(COM_TYPE_UBX); //Set the I2C port to output UBX only (turn off NMEA noise)
-
-  // Note: not all u-blox modules can output solutions at 10Hz - or not while tracking all satellite constellations
-  // If the rate drops back to 1Hz, you're asking too much of your module
-  myGNSS.setNavigationFrequency(10);           //Set output to 10 times a second
-  
-  byte rate = myGNSS.getNavigationFrequency(); //Get the update rate of this module
-  Serial.print("Current update rate:");
-  Serial.println(rate);
-
-  //myGNSS.saveConfiguration(); //Optional: Save the current settings to flash and BBR
-}
-
-void loop()
-{
-  // Calling getPVT returns true if there actually is a fresh navigation solution available.
-  if (myGNSS.getPVT())
-  {
-    lastTime = millis(); //Update the timer
-
-    long latitude = myGNSS.getLatitude();
-    Serial.print(F("Lat: "));
-    Serial.print(latitude);
-
-    long longitude = myGNSS.getLongitude();
-    Serial.print(F(" Long: "));
-    Serial.print(longitude);
-    Serial.print(F(" (degrees * 10^-7)"));
-
-    long altitude = myGNSS.getAltitude();
-    Serial.print(F(" Alt: "));
-    Serial.print(altitude);
-    Serial.print(F(" (mm)"));
-
-    byte SIV = myGNSS.getSIV();
-    Serial.print(F(" SIV: "));
-    Serial.print(SIV);
-
-    Serial.print(" ");
-    Serial.print(myGNSS.getYear());
-    Serial.print("-");
-    Serial.print(myGNSS.getMonth());
-    Serial.print("-");
-    Serial.print(myGNSS.getDay());
-    Serial.print(" ");
-    Serial.print(myGNSS.getHour());
-    Serial.print(":");
-    Serial.print(myGNSS.getMinute());
-    Serial.print(":");
-    Serial.print(myGNSS.getSecond());
-    Serial.print(".");
-    //Pretty print leading zeros
-    int mseconds = myGNSS.getMillisecond();
-    if (mseconds < 100)
-      Serial.print("0");
-    if (mseconds < 10)
-      Serial.print("0");
-    Serial.print(mseconds);
-
-    Serial.print(" nanoseconds: ");
-    Serial.print(myGNSS.getNanosecond());
-
-    Serial.println();
-  }
-}
diff --git a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Example17_Geofence/Example17_Geofence.ino b/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Example17_Geofence/Example17_Geofence.ino
deleted file mode 100644
index 684fd05..0000000
--- a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Example17_Geofence/Example17_Geofence.ino
+++ /dev/null
@@ -1,169 +0,0 @@
-/*
-  u-blox M8 geofence example
-
-  Written by Paul Clark (PaulZC)
-  10th December 2019
-
-  License: MIT. See license file for more information but you can
-  basically do whatever you want with this code.
-
-  This example demonstrates how to use the addGeofence and getGeofenceState functions
-
-  Feel like supporting open source hardware?
-  Buy a board from SparkFun!
-  ZED-F9P RTK2: https://www.sparkfun.com/products/15136
-  NEO-M8P RTK: https://www.sparkfun.com/products/15005
-  SAM-M8Q: https://www.sparkfun.com/products/15210
-  ZOE-M8Q: https://www.sparkfun.com/products/15193
-
-  This example powers up the GNSS and reads the fix.
-  Once a valid 3D fix has been found, the code reads the latitude and longitude.
-  The code then sets four geofences around that position with a radii of 5m, 10m, 15m and 20m with 95% confidence.
-  The code then monitors the geofence status.
-  The LED will be illuminated if you are inside the _combined_ geofence (i.e. within the 20m radius).
-
-  This code has been tested on the ZOE-M8Q.
-*/
-
-#define LED LED_BUILTIN // Change this if your LED is on a different pin
-
-#include <Wire.h> // Needed for I2C
-
-#include <SparkFun_u-blox_GNSS_Arduino_Library.h> //http://librarymanager/All#SparkFun_u-blox_GNSS
-SFE_UBLOX_GNSS myGNSS;
-
-void setup()
-{
-  pinMode(LED, OUTPUT);
-
-  // Set up the I2C pins
-  Wire.begin();
-
-  // Start the console serial port
-  Serial.begin(115200);
-  while (!Serial); // Wait for the user to open the serial monitor
-  delay(100);
-  Serial.println();
-  Serial.println();
-  Serial.println(F("u-blox M8 geofence example"));
-  Serial.println();
-  Serial.println();
-
-  delay(1000); // Let the GNSS power up
-
-  if (myGNSS.begin() == false) //Connect to the u-blox module using Wire port
-  {
-    Serial.println(F("u-blox GNSS not detected at default I2C address. Please check wiring. Freezing."));
-    while (1);
-  }
-
-  //myGNSS.enableDebugging(); // Enable debug messages
-  myGNSS.setI2COutput(COM_TYPE_UBX); // Limit I2C output to UBX (disable the NMEA noise)
-
-  Serial.println(F("Waiting for a 3D fix..."));
-
-  byte fixType = 0;
-
-  while (fixType < 3)
-  {
-    fixType = myGNSS.getFixType(); // Get the fix type
-    Serial.print(F("Fix: ")); // Print it
-    Serial.print(fixType);
-    if(fixType == 0) Serial.print(F(" = No fix"));
-    else if(fixType == 1) Serial.print(F(" = Dead reckoning"));
-    else if(fixType == 2) Serial.print(F(" = 2D"));
-    else if(fixType == 3) Serial.print(F(" = 3D"));
-    else if(fixType == 4) Serial.print(F(" = GNSS + Dead reckoning"));
-    else if(fixType == 5) Serial.print(F(" = Time only"));
-    Serial.println();
-    delay(1000);
-  }
-
-  Serial.println(F("3D fix found!"));
-
-  long latitude = myGNSS.getLatitude(); // Get the latitude in degrees * 10^-7
-  Serial.print(F("Lat: "));
-  Serial.print(latitude);
-
-  long longitude = myGNSS.getLongitude(); // Get the longitude in degrees * 10^-7
-  Serial.print(F("   Long: "));
-  Serial.println(longitude);
-
-  uint32_t radius = 500; // Set the radius to 5m (radius is in m * 10^-2 i.e. cm)
-
-  byte confidence = 2; // Set the confidence level: 0=none, 1=68%, 2=95%, 3=99.7%, 4=99.99%
-
-  // Call clearGeofences() to clear all existing geofences.
-  Serial.print(F("Clearing any existing geofences. clearGeofences returned: "));
-  Serial.println(myGNSS.clearGeofences());
-
-  // It is possible to define up to four geofences.
-  // Call addGeofence up to four times to define them.
-  Serial.println(F("Setting the geofences:"));
-
-  Serial.print(F("addGeofence for geofence 1 returned: "));
-  Serial.println(myGNSS.addGeofence(latitude, longitude, radius, confidence));
-
-  radius = 1000; // 10m
-  Serial.print(F("addGeofence for geofence 2 returned: "));
-  Serial.println(myGNSS.addGeofence(latitude, longitude, radius, confidence));
-
-  radius = 1500; // 15m
-  Serial.print(F("addGeofence for geofence 3 returned: "));
-  Serial.println(myGNSS.addGeofence(latitude, longitude, radius, confidence));
-
-  radius = 2000; // 20m
-  Serial.print(F("addGeofence for geofence 4 returned: "));
-  Serial.println(myGNSS.addGeofence(latitude, longitude, radius, confidence));
-}
-
-void loop()
-{
-  geofenceState currentGeofenceState; // Create storage for the geofence state
-
-  boolean result = myGNSS.getGeofenceState(currentGeofenceState);
-
-  Serial.print(F("getGeofenceState returned: ")); // Print the combined state
-  Serial.print(result); // Get the geofence state
-
-  if (!result) // If getGeofenceState did not return true
-  {
-    Serial.println(F(".")); // Tidy up
-    return; // and go round the loop again
-  }
-
-  Serial.print(F(". status is: ")); // Print the status
-  Serial.print(currentGeofenceState.status);
-
-  Serial.print(F(". numFences is: ")); // Print the numFences
-  Serial.print(currentGeofenceState.numFences);
-
-  Serial.print(F(". combState is: ")); // Print the combined state
-  Serial.print(currentGeofenceState.combState);
-
-  if (currentGeofenceState.combState == 0)
-  {
-    Serial.print(F(" = Unknown"));
-    digitalWrite(LED, LOW);
-  }
-  if (currentGeofenceState.combState == 1)
-  {
-    Serial.print(F(" = Inside"));
-    digitalWrite(LED, HIGH);
-  }
-  else if (currentGeofenceState.combState == 2)
-  {
-    Serial.print(F(" = Outside"));
-    digitalWrite(LED, LOW);
-  }
-
-  Serial.print(F(". The individual states are: ")); // Print the state of each geofence
-  for(int i = 0; i < currentGeofenceState.numFences; i++)
-  {
-    if (i > 0) Serial.print(F(","));
-    Serial.print(currentGeofenceState.states[i]);
-  }
-  Serial.println();
-
-  delay(1000);
-}
diff --git a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Example18_PowerSaveMode/Example18_PowerSaveMode.ino b/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Example18_PowerSaveMode/Example18_PowerSaveMode.ino
deleted file mode 100644
index fc24259..0000000
--- a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Example18_PowerSaveMode/Example18_PowerSaveMode.ino
+++ /dev/null
@@ -1,163 +0,0 @@
-/*
-  Power Save Mode
-  By: Paul Clark (PaulZC)
-  Date: April 22nd, 2020
-
-  Based extensively on Example3_GetPosition
-  By: Nathan Seidle
-  SparkFun Electronics
-  Date: January 3rd, 2019
-  License: MIT. See license file for more information but you can
-  basically do whatever you want with this code.
-
-  This example shows how to put the u-blox module into power save mode and then
-  query its lat/long/altitude. We also turn off the NMEA output on the I2C port.
-  This decreases the amount of I2C traffic dramatically.
-
-  ** When it is able to ** the module will reduce its current draw.
-  For the ZOE-M8Q with a passive antenna, you should see the current drop
-  from (approx.) 25-28mA to (approx.) 9mA when power save mode kicks in.
-
-  Note: this will fail on the ZED (protocol version >= 27) as UBX-CFG-RXM is not supported
-
-  Note: Long/lat are large numbers because they are * 10^7. To convert lat/long
-  to something google maps understands simply divide the numbers by 10,000,000. We
-  do this so that we don't have to use floating point numbers.
-
-  Leave NMEA parsing behind. Now you can simply ask the module for the datums you want!
-
-  Feel like supporting open source hardware?
-  Buy a board from SparkFun!
-  ZED-F9P RTK2: https://www.sparkfun.com/products/15136
-  NEO-M8P RTK: https://www.sparkfun.com/products/15005
-  SAM-M8Q: https://www.sparkfun.com/products/15106
-
-  Hardware Connections:
-  Plug a Qwiic cable into the GNSS and a BlackBoard
-  If you don't have a platform with a Qwiic connection use the SparkFun Qwiic Breadboard Jumper (https://www.sparkfun.com/products/14425)
-  Open the serial monitor at 115200 baud to see the output
-*/
-
-#include <Wire.h> //Needed for I2C to GNSS
-
-#include <SparkFun_u-blox_GNSS_Arduino_Library.h> //http://librarymanager/All#SparkFun_u-blox_GNSS
-SFE_UBLOX_GNSS myGNSS;
-
-long lastTime = 0; //Simple local timer. Limits amount if I2C traffic to u-blox module.
-
-void setup()
-{
-  Serial.begin(115200);
-  while (!Serial)
-    ; //Wait for user to open terminal
-  Serial.println("SparkFun u-blox Example");
-
-  Wire.begin();
-
-  if (myGNSS.begin() == false) //Connect to the u-blox module using Wire port
-  {
-    Serial.println(F("u-blox GNSS not detected at default I2C address. Please check wiring. Freezing."));
-    while (1)
-      ;
-  }
-
-  //myGNSS.enableDebugging(); // Uncomment this line to enable debug messages
-
-  myGNSS.setI2COutput(COM_TYPE_UBX); //Set the I2C port to output UBX only (turn off NMEA noise)
-  //myGNSS.saveConfiguration(); //Optional: Uncomment this line to save the current settings to flash and BBR
-
-  Serial.println("Power save example.");
-  Serial.println("1) Enable power saving");
-  Serial.println("2) Disable power saving");
-}
-
-void loop()
-{
-  if (Serial.available())
-  {
-    byte incoming = Serial.read();
-
-    if (incoming == '1')
-    {
-      // Put the GNSS into power save mode
-      // (If you want to disable power save mode, call myGNSS.powerSaveMode(false) instead)
-      // This will fail on the ZED (protocol version >= 27) as UBX-CFG-RXM is not supported
-      if (myGNSS.powerSaveMode()) // Defaults to true
-        Serial.println(F("Power Save Mode enabled."));
-      else
-        Serial.println(F("***!!! Power Save Mode FAILED !!!***"));
-    }
-    else if (incoming == '2')
-    {
-      //Go to normal power mode (not power saving mode)
-      if (myGNSS.powerSaveMode(false))
-        Serial.println(F("Power Save Mode disabled."));
-      else
-        Serial.println(F("***!!! Power Save Disable FAILED !!!***"));
-    }
-
-    // Read and print the new low power mode
-    uint8_t lowPowerMode = myGNSS.getPowerSaveMode();
-    if (lowPowerMode == 255)
-    {
-      Serial.println(F("***!!! getPowerSaveMode FAILED !!!***"));
-    }
-    else
-    {
-      Serial.print(F("The low power mode is: "));
-      Serial.print(lowPowerMode);
-      if (lowPowerMode == 0)
-      {
-        Serial.println(F(" (Continuous)"));
-      }
-      else if (lowPowerMode == 1)
-      {
-        Serial.println(F(" (Power Save)"));
-      }
-      else if (lowPowerMode == 4)
-      {
-        Serial.println(F(" (Continuous)"));
-      }
-      else
-      {
-        Serial.println(F(" (Unknown!)"));
-      }
-    }
-  }
-
-  //Query module every 10 seconds so it is easier to monitor the current draw
-  if (millis() - lastTime > 10000)
-  {
-    lastTime = millis(); //Update the timer
-
-    byte fixType = myGNSS.getFixType(); // Get the fix type
-    Serial.print(F("Fix: "));
-    Serial.print(fixType);
-    if (fixType == 0)
-      Serial.print(F("(No fix)"));
-    else if (fixType == 1)
-      Serial.print(F("(Dead reckoning)"));
-    else if (fixType == 2)
-      Serial.print(F("(2D)"));
-    else if (fixType == 3)
-      Serial.print(F("(3D)"));
-    else if (fixType == 4)
-      Serial.print(F("(GNSS + Dead reckoning)"));
-
-    long latitude = myGNSS.getLatitude();
-    Serial.print(F(" Lat: "));
-    Serial.print(latitude);
-
-    long longitude = myGNSS.getLongitude();
-    Serial.print(F(" Long: "));
-    Serial.print(longitude);
-    Serial.print(F(" (degrees * 10^-7)"));
-
-    long altitude = myGNSS.getAltitude();
-    Serial.print(F(" Alt: "));
-    Serial.print(altitude);
-    Serial.print(F(" (mm)"));
-
-    Serial.println();
-  }
-}
diff --git a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Example19_DynamicModel/Example19_DynamicModel.ino b/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Example19_DynamicModel/Example19_DynamicModel.ino
deleted file mode 100644
index 9915647..0000000
--- a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Example19_DynamicModel/Example19_DynamicModel.ino
+++ /dev/null
@@ -1,117 +0,0 @@
-/*
-  Set Dynamic Model
-  By: Paul Clark (PaulZC)
-  Date: April 22nd, 2020
-
-  Based extensively on Example3_GetPosition
-  By: Nathan Seidle
-  SparkFun Electronics
-  Date: January 3rd, 2019
-  License: MIT. See license file for more information but you can
-  basically do whatever you want with this code.
-
-  This example shows how to change the u-blox module's dynamic platform model and then
-  query its lat/long/altitude. We also turn off the NMEA output on the I2C port.
-  This decreases the amount of I2C traffic dramatically.
-
-  Possible values for the dynamic model are: PORTABLE, STATIONARY, PEDESTRIAN, AUTOMOTIVE,
-  SEA, AIRBORNE1g, AIRBORNE2g, AIRBORNE4g, WRIST, BIKE
-
-  Note: Long/lat are large numbers because they are * 10^7. To convert lat/long
-  to something google maps understands simply divide the numbers by 10,000,000. We
-  do this so that we don't have to use floating point numbers.
-
-  Leave NMEA parsing behind. Now you can simply ask the module for the datums you want!
-
-  Feel like supporting open source hardware?
-  Buy a board from SparkFun!
-  ZED-F9P RTK2: https://www.sparkfun.com/products/15136
-  NEO-M8P RTK: https://www.sparkfun.com/products/15005
-  SAM-M8Q: https://www.sparkfun.com/products/15106
-
-  Hardware Connections:
-  Plug a Qwiic cable into the GNSS and a BlackBoard
-  If you don't have a platform with a Qwiic connection use the SparkFun Qwiic Breadboard Jumper (https://www.sparkfun.com/products/14425)
-  Open the serial monitor at 115200 baud to see the output
-*/
-
-#include <Wire.h> //Needed for I2C to GNSS
-
-#include <SparkFun_u-blox_GNSS_Arduino_Library.h> //http://librarymanager/All#SparkFun_u-blox_GNSS
-SFE_UBLOX_GNSS myGNSS;
-
-long lastTime = 0; //Simple local timer. Limits amount if I2C traffic to u-blox module.
-
-void setup()
-{
-  Serial.begin(115200);
-  while (!Serial)
-    ; //Wait for user to open terminal
-  Serial.println(F("SparkFun u-blox Example"));
-
-  Wire.begin();
-
-  //myGNSS.enableDebugging(); // Uncomment this line to enable debug messages
-
-  if (myGNSS.begin() == false) //Connect to the u-blox module using Wire port
-  {
-    Serial.println(F("u-blox GNSS not detected at default I2C address. Please check wiring. Freezing."));
-    while (1)
-      ;
-  }
-
-  myGNSS.setI2COutput(COM_TYPE_UBX); //Set the I2C port to output UBX only (turn off NMEA noise)
-
-  // If we are going to change the dynamic platform model, let's do it here.
-  // Possible values are:
-  // PORTABLE, STATIONARY, PEDESTRIAN, AUTOMOTIVE, SEA, AIRBORNE1g, AIRBORNE2g, AIRBORNE4g, WRIST, BIKE
-
-  if (myGNSS.setDynamicModel(DYN_MODEL_PORTABLE) == false) // Set the dynamic model to PORTABLE
-  {
-    Serial.println(F("***!!! Warning: setDynamicModel failed !!!***"));
-  }
-  else
-  {
-    Serial.println(F("Dynamic platform model changed successfully!"));
-  }
-
-  // Let's read the new dynamic model to see if it worked
-  uint8_t newDynamicModel = myGNSS.getDynamicModel();
-  if (newDynamicModel == DYN_MODEL_UNKNOWN)
-  {
-    Serial.println(F("***!!! Warning: getDynamicModel failed !!!***"));
-  }
-  else
-  {
-    Serial.print(F("The new dynamic model is: "));
-    Serial.println(newDynamicModel);
-  }
-
-  //myGNSS.saveConfigSelective(VAL_CFG_SUBSEC_NAVCONF); //Uncomment this line to save only the NAV settings to flash and BBR
-}
-
-void loop()
-{
-  //Query module only every second. Doing it more often will just cause I2C traffic.
-  //The module only responds when a new position is available
-  if (millis() - lastTime > 1000)
-  {
-    lastTime = millis(); //Update the timer
-
-    long latitude = myGNSS.getLatitude();
-    Serial.print(F("Lat: "));
-    Serial.print(latitude);
-
-    long longitude = myGNSS.getLongitude();
-    Serial.print(F(" Long: "));
-    Serial.print(longitude);
-    Serial.print(F(" (degrees * 10^-7)"));
-
-    long altitude = myGNSS.getAltitude();
-    Serial.print(F(" Alt: "));
-    Serial.print(altitude);
-    Serial.print(F(" (mm)"));
-
-    Serial.println();
-  }
-}
diff --git a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Example1_BasicNMEARead/Example1_BasicNMEARead.ino b/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Example1_BasicNMEARead/Example1_BasicNMEARead.ino
deleted file mode 100644
index f2c2368..0000000
--- a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Example1_BasicNMEARead/Example1_BasicNMEARead.ino
+++ /dev/null
@@ -1,51 +0,0 @@
-/*
-  Read NMEA sentences over I2C using u-blox module SAM-M8Q, NEO-M8P, ZED-F9P, etc
-  By: Nathan Seidle
-  SparkFun Electronics
-  Date: August 22nd, 2018
-  License: MIT. See license file for more information but you can
-  basically do whatever you want with this code.
-
-  This example reads the NMEA setences from the u-blox module over I2c and outputs
-  them to the serial port
-  
-  Feel like supporting open source hardware?
-  Buy a board from SparkFun!
-  ZED-F9P RTK2: https://www.sparkfun.com/products/15136
-  NEO-M8P RTK: https://www.sparkfun.com/products/15005
-  SAM-M8Q: https://www.sparkfun.com/products/15106
-
-  Hardware Connections:
-  Plug a Qwiic cable into the GNSS and a BlackBoard
-  If you don't have a platform with a Qwiic connection use the SparkFun Qwiic Breadboard Jumper (https://www.sparkfun.com/products/14425)
-  Open the serial monitor at 115200 baud to see the output
-*/
-
-#include <Wire.h> //Needed for I2C to GNSS
-
-#include <SparkFun_u-blox_GNSS_Arduino_Library.h> //Click here to get the library: http://librarymanager/All#SparkFun_Ublox_GPS
-SFE_UBLOX_GNSS myGNSS;
-
-void setup()
-{
-  Serial.begin(115200);
-  Serial.println("SparkFun u-blox Example");
-
-  Wire.begin();
-
-  if (myGNSS.begin() == false)
-  {
-    Serial.println(F("u-blox GNSS not detected at default I2C address. Please check wiring. Freezing."));
-    while (1);
-  }
-
-  //This will pipe all NMEA sentences to the serial port so we can see them
-  myGNSS.setNMEAOutputPort(Serial);
-}
-
-void loop()
-{
-  myGNSS.checkUblox(); //See if new data is available. Process bytes as they come in.
-
-  delay(250); //Don't pound too hard on the I2C bus
-}
diff --git a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Example20_SendCustomCommand/Example20_SendCustomCommand.ino b/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Example20_SendCustomCommand/Example20_SendCustomCommand.ino
deleted file mode 100644
index 45c259b..0000000
--- a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Example20_SendCustomCommand/Example20_SendCustomCommand.ino
+++ /dev/null
@@ -1,166 +0,0 @@
-/*
-  Send Custom Command
-  By: Paul Clark (PaulZC)
-  Date: April 20th, 2020
-
-  License: MIT. See license file for more information but you can
-  basically do whatever you want with this code.
-
-  This example shows how you can create and send a custom UBX packet
-  using the SparkFun u-blox library.
-
-  Previously it was possible to create and send a custom packet
-  through the library but it would always appear to timeout as
-  some of the internal functions referred to the internal private
-  struct packetCfg.
-  The most recent version of the library allows sendCommand to
-  use a custom packet as if it were packetCfg and so:
-  - sendCommand will return a sfe_ublox_status_e enum as if
-    it had been called from within the library
-  - the custom packet will be updated with data returned by the module
-    (previously this was not possible from outside the library)
-
-  Feel like supporting open source hardware?
-  Buy a board from SparkFun!
-  ZED-F9P RTK2: https://www.sparkfun.com/products/15136
-  NEO-M8P RTK: https://www.sparkfun.com/products/15005
-  SAM-M8Q: https://www.sparkfun.com/products/15106
-
-  Hardware Connections:
-  Plug a Qwiic cable into the GNSS and a BlackBoard
-  If you don't have a platform with a Qwiic connection use the SparkFun Qwiic Breadboard Jumper (https://www.sparkfun.com/products/14425)
-  Open the serial monitor at 115200 baud to see the output
-*/
-
-#define NAV_RATE 5 // The new navigation rate in Hz (measurements per second)
-
-#include <Wire.h> //Needed for I2C to GNSS
-
-#include <SparkFun_u-blox_GNSS_Arduino_Library.h> //http://librarymanager/All#SparkFun_u-blox_GNSS
-SFE_UBLOX_GNSS myGNSS;
-
-void setup()
-{
-  Serial.begin(115200); // You may need to increase this for high navigation rates!
-  while (!Serial)
-    ; //Wait for user to open terminal
-  Serial.println("SparkFun u-blox Example");
-
-  Wire.begin();
-
-  //myGNSS.enableDebugging(); // Uncomment this line to enable debug messages
-
-  if (myGNSS.begin() == false) //Connect to the u-blox module using Wire port
-  {
-    Serial.println(F("u-blox GNSS not detected at default I2C address. Please check wiring. Freezing."));
-    while (1)
-      ;
-  }
-
-  myGNSS.setI2COutput(COM_TYPE_UBX); //Set the I2C port to output UBX only (turn off NMEA noise)
-
-  // Let's configure the module's navigation rate as if we were using setNavigationFrequency
-
-  // Let's create our custom packet
-  uint8_t customPayload[MAX_PAYLOAD_SIZE]; // This array holds the payload data bytes
-  // The next line creates and initialises the packet information which wraps around the payload
-  ubxPacket customCfg = {0, 0, 0, 0, 0, customPayload, 0, 0, SFE_UBLOX_PACKET_VALIDITY_NOT_DEFINED, SFE_UBLOX_PACKET_VALIDITY_NOT_DEFINED};
-
-  // The structure of ubxPacket is:
-  // uint8_t cls           : The message Class
-  // uint8_t id            : The message ID
-  // uint16_t len          : Length of the payload. Does not include cls, id, or checksum bytes
-  // uint16_t counter      : Keeps track of number of overall bytes received. Some responses are larger than 255 bytes.
-  // uint16_t startingSpot : The counter value needed to go past before we begin recording into payload array
-  // uint8_t *payload      : The payload
-  // uint8_t checksumA     : Given to us by the module. Checked against the rolling calculated A/B checksums.
-  // uint8_t checksumB
-  // sfe_ublox_packet_validity_e valid            : Goes from NOT_DEFINED to VALID or NOT_VALID when checksum is checked
-  // sfe_ublox_packet_validity_e classAndIDmatch  : Goes from NOT_DEFINED to VALID or NOT_VALID when the Class and ID match the requestedClass and requestedID
-
-  // sendCommand will return:
-  // SFE_UBLOX_STATUS_DATA_RECEIVED if the data we requested was read / polled successfully
-  // SFE_UBLOX_STATUS_DATA_SENT     if the data we sent was writted successfully (ACK'd)
-  // Other values indicate errors. Please see the sfe_ublox_status_e enum for further details.
-
-  // Referring to the u-blox M8 Receiver Description and Protocol Specification we see that
-  // the navigation rate is configured using the UBX-CFG-RATE message. So let's load our
-  // custom packet with the correct information so we can read (poll / get) the current settings.
-
-  customCfg.cls = UBX_CLASS_CFG; // This is the message Class
-  customCfg.id = UBX_CFG_RATE; // This is the message ID
-  customCfg.len = 0; // Setting the len (length) to zero let's us poll the current settings
-  customCfg.startingSpot = 0; // Always set the startingSpot to zero (unless you really know what you are doing)
-
-  // We also need to tell sendCommand how long it should wait for a reply
-  uint16_t maxWait = 250; // Wait for up to 250ms (Serial may need a lot longer e.g. 1100)
-
-  // Now let's read the current navigation rate. The results will be loaded into customCfg.
-  if (myGNSS.sendCommand(&customCfg, maxWait) != SFE_UBLOX_STATUS_DATA_RECEIVED) // We are expecting data and an ACK
-  {
-    Serial.println(F("sendCommand (poll / get) failed! Freezing..."));
-    while (1)
-      ;
-  }
-
-  // Referring to the message definition for UBX-CFG-RATE we see that the measurement rate
-  // is stored in payload bytes 0 and 1 as a uint16_t in LSB-first (little endian) format
-
-  uint16_t rate = (customPayload[1] << 8) | customPayload[0]; // Extract the current rate (ms)
-  float f_rate = 1000.0 / ((float)rate); // Convert the navigation rate to Hz (measurements per second)
-
-  // Print the current measurement rate
-  Serial.print(F("The current measurement rate is: "));
-  Serial.println(f_rate, 1);
-
-  // Let's change it
-  rate = 1000 / NAV_RATE; // Load the new value into rate
-  customPayload[0] = rate & 0xFF; // Store it in the payload
-  customPayload[1] = rate >> 8;
-
-  // Print the new measurement rate
-  Serial.print(F("The new measurement rate will be: "));
-  Serial.println(NAV_RATE);
-
-  // We don't need to update customCfg.len as it will have been set to 6
-  // when sendCommand read the data
-
-  // Now we write the custom packet back again to change the setting
-  if (myGNSS.sendCommand(&customCfg, maxWait) != SFE_UBLOX_STATUS_DATA_SENT) // This time we are only expecting an ACK
-  {
-    Serial.println(F("sendCommand (set) failed! Freezing."));
-    while (1)
-      ;
-  }
-  else
-  {
-    Serial.println(F("Navigation rate updated. Here we go..."));
-  }
-
-  myGNSS.setAutoPVT(true); // Enable AutoPVT. The module will generate measurements automatically without being polled.
-
-  //myGNSS.saveConfigSelective(VAL_CFG_SUBSEC_NAVCONF); //Uncomment this line to save only the NAV settings to flash and BBR
-}
-
-void loop()
-{
-  //Query the module as fast as possible
-    int32_t latitude = myGNSS.getLatitude();
-    Serial.print(F("Lat: "));
-    Serial.print(latitude);
-
-    int32_t longitude = myGNSS.getLongitude();
-    Serial.print(F(" Lon: "));
-    Serial.print(longitude);
-    Serial.print(F(" (degrees * 10^-7)"));
-
-    int32_t altitude = myGNSS.getAltitude();
-    Serial.print(F(" Alt: "));
-    Serial.print(altitude);
-    Serial.print(F(" (mm)"));
-    
-    uint16_t milliseconds = myGNSS.getMillisecond();
-    Serial.print(F(" Milliseconds: "));
-    Serial.print(altitude);
-    Serial.println();
-}
diff --git a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Example21_ModuleInfo/Example21_ModuleInfo.ino b/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Example21_ModuleInfo/Example21_ModuleInfo.ino
deleted file mode 100644
index 9349eca..0000000
--- a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Example21_ModuleInfo/Example21_ModuleInfo.ino
+++ /dev/null
@@ -1,183 +0,0 @@
-/*
-  Module Info - extracts and prints the full module information from UBX_MON_VER
-  using a custom command.
-  By: @mayopan
-  Date: May 9th, 2020
-
-  Based on:
-  Send Custom Command
-  By: Paul Clark (PaulZC)
-  Date: April 20th, 2020
-
-  License: MIT. See license file for more information but you can
-  basically do whatever you want with this code.
-
-  Previously it was possible to create and send a custom packet
-  through the library but it would always appear to timeout as
-  some of the internal functions referred to the internal private
-  struct packetCfg.
-  The most recent version of the library allows sendCommand to
-  use a custom packet as if it were packetCfg and so:
-  - sendCommand will return a sfe_ublox_status_e enum as if
-    it had been called from within the library
-  - the custom packet will be updated with data returned by the module
-    (previously this was not possible from outside the library)
-
-  Feel like supporting open source hardware?
-  Buy a board from SparkFun!
-  ZED-F9P RTK2: https://www.sparkfun.com/products/15136
-  NEO-M8P RTK: https://www.sparkfun.com/products/15005
-  SAM-M8Q: https://www.sparkfun.com/products/15106
-
-  Hardware Connections:
-  Plug a Qwiic cable into the GNSS and a BlackBoard
-  If you don't have a platform with a Qwiic connection use the SparkFun Qwiic Breadboard Jumper (https://www.sparkfun.com/products/14425)
-  Open the serial monitor at 115200 baud to see the output
-*/
-
-#include <Wire.h> //Needed for I2C to GNSS
-
-#define MAX_PAYLOAD_SIZE 384 // Override MAX_PAYLOAD_SIZE for getModuleInfo which can return up to 348 bytes
-
-#include <SparkFun_u-blox_GNSS_Arduino_Library.h> //http://librarymanager/All#SparkFun_u-blox_GNSS
-
-// Extend the class for getModuleInfo
-class SFE_UBLOX_GPS_ADD : public SFE_UBLOX_GNSS
-{
-public:
-    boolean getModuleInfo(uint16_t maxWait = 1100); //Queries module, texts
-
-    struct minfoStructure // Structure to hold the module info (uses 341 bytes of RAM)
-    {
-        char swVersion[30];
-        char hwVersion[10];
-        uint8_t extensionNo = 0;
-        char extension[10][30];
-    } minfo;
-};
-
-SFE_UBLOX_GPS_ADD myGNSS;
-
-void setup()
-{
-    Serial.begin(115200); // You may need to increase this for high navigation rates!
-    while (!Serial)
-        ; //Wait for user to open terminal
-    Serial.println(F("SparkFun u-blox Example"));
-
-    Wire.begin();
-
-    //myGNSS.enableDebugging(); // Uncomment this line to enable debug messages
-
-    if (myGNSS.begin() == false) //Connect to the u-blox module using Wire port
-    {
-        Serial.println(F("u-blox GNSS not detected at default I2C address. Please check wiring. Freezing."));
-        while (1)
-            ;
-    }
-
-    myGNSS.setI2COutput(COM_TYPE_UBX); //Set the I2C port to output UBX only (turn off NMEA noise)
-
-    Serial.print(F("Polling module info"));
-    if (myGNSS.getModuleInfo(1100) == false) // Try to get the module info
-    {
-        Serial.print(F("getModuleInfo failed! Freezing..."));
-        while (1)
-            ;
-    }
-
-    Serial.println();
-    Serial.println();
-    Serial.println(F("Module Info : "));
-    Serial.print(F("Soft version: "));
-    Serial.println(myGNSS.minfo.swVersion);
-    Serial.print(F("Hard version: "));
-    Serial.println(myGNSS.minfo.hwVersion);
-    Serial.print(F("Extensions:"));
-    Serial.println(myGNSS.minfo.extensionNo);
-    for (int i = 0; i < myGNSS.minfo.extensionNo; i++)
-    {
-        Serial.print("  ");
-        Serial.println(myGNSS.minfo.extension[i]);
-    }
-    Serial.println();
-    Serial.println(F("Done!"));
-}
-
-void loop()
-{
-}
-
-boolean SFE_UBLOX_GPS_ADD::getModuleInfo(uint16_t maxWait)
-{
-    myGNSS.minfo.hwVersion[0] = 0;
-    myGNSS.minfo.swVersion[0] = 0;
-    for (int i = 0; i < 10; i++)
-        myGNSS.minfo.extension[i][0] = 0;
-    myGNSS.minfo.extensionNo = 0;
-
-    // Let's create our custom packet
-    uint8_t customPayload[MAX_PAYLOAD_SIZE]; // This array holds the payload data bytes
-
-    // The next line creates and initialises the packet information which wraps around the payload
-    ubxPacket customCfg = {0, 0, 0, 0, 0, customPayload, 0, 0, SFE_UBLOX_PACKET_VALIDITY_NOT_DEFINED, SFE_UBLOX_PACKET_VALIDITY_NOT_DEFINED};
-
-    // The structure of ubxPacket is:
-    // uint8_t cls           : The message Class
-    // uint8_t id            : The message ID
-    // uint16_t len          : Length of the payload. Does not include cls, id, or checksum bytes
-    // uint16_t counter      : Keeps track of number of overall bytes received. Some responses are larger than 255 bytes.
-    // uint16_t startingSpot : The counter value needed to go past before we begin recording into payload array
-    // uint8_t *payload      : The payload
-    // uint8_t checksumA     : Given to us by the module. Checked against the rolling calculated A/B checksums.
-    // uint8_t checksumB
-    // sfe_ublox_packet_validity_e valid            : Goes from NOT_DEFINED to VALID or NOT_VALID when checksum is checked
-    // sfe_ublox_packet_validity_e classAndIDmatch  : Goes from NOT_DEFINED to VALID or NOT_VALID when the Class and ID match the requestedClass and requestedID
-
-    // sendCommand will return:
-    // SFE_UBLOX_STATUS_DATA_RECEIVED if the data we requested was read / polled successfully
-    // SFE_UBLOX_STATUS_DATA_SENT     if the data we sent was writted successfully (ACK'd)
-    // Other values indicate errors. Please see the sfe_ublox_status_e enum for further details.
-
-    // Referring to the u-blox M8 Receiver Description and Protocol Specification we see that
-    // the module information can be read using the UBX-MON-VER message. So let's load our
-    // custom packet with the correct information so we can read (poll / get) the module information.
-
-    customCfg.cls = UBX_CLASS_MON; // This is the message Class
-    customCfg.id = UBX_MON_VER;    // This is the message ID
-    customCfg.len = 0;             // Setting the len (length) to zero let's us poll the current settings
-    customCfg.startingSpot = 0;    // Always set the startingSpot to zero (unless you really know what you are doing)
-
-    // Now let's send the command. The module info is returned in customPayload
-
-    if (sendCommand(&customCfg, maxWait) != SFE_UBLOX_STATUS_DATA_RECEIVED)
-        return (false); //If command send fails then bail
-
-    // Now let's extract the module info from customPayload
-
-    uint16_t position = 0;
-    for (int i = 0; i < 30; i++)
-    {
-        minfo.swVersion[i] = customPayload[position];
-        position++;
-    }
-    for (int i = 0; i < 10; i++)
-    {
-        minfo.hwVersion[i] = customPayload[position];
-        position++;
-    }
-
-    while (customCfg.len >= position + 30)
-    {
-        for (int i = 0; i < 30; i++)
-        {
-            minfo.extension[minfo.extensionNo][i] = customPayload[position];
-            position++;
-        }
-        minfo.extensionNo++;
-        if (minfo.extensionNo > 9)
-            break;
-    }
-
-    return (true); //Success!
-}
diff --git a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Example22_PowerOff/Example22_PowerOff.ino b/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Example22_PowerOff/Example22_PowerOff.ino
deleted file mode 100644
index dd0f128..0000000
--- a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Example22_PowerOff/Example22_PowerOff.ino
+++ /dev/null
@@ -1,88 +0,0 @@
-/*
-  Powering off a ublox GNSS module
-  By: bjorn
-  unsurv.org
-  Date: July 20th, 2020
-  License: MIT. See license file for more information but you can
-  basically do whatever you want with this code.
-
-  This example shows you how to turn off the ublox module to lower the power consumption.
-  There are two functions: one just specifies a duration in milliseconds the other also specifies a pin on the GNSS device to wake it up with.
-  By driving a voltage from LOW to HIGH or HIGH to LOW on the chosen module pin you wake the device back up.
-  Note: Doing so on the INT0 pin when using the regular powerOff(durationInMs) function will wake the device anyway. (tested on SAM-M8Q)
-  Note: While powered off, you should not query the device for data or it might wake up. This can be used to wake the device but is not recommended.
-        Works best when also putting your microcontroller to sleep.
-
-  Feel like supporting open source hardware?
-  Buy a board from SparkFun!
-  ZED-F9P RTK2: https://www.sparkfun.com/products/15136
-  NEO-M8P RTK: https://www.sparkfun.com/products/15005
-  SAM-M8Q: https://www.sparkfun.com/products/15106
-
-  Hardware Connections:
-  Plug a Qwiic cable into the GNSS and a BlackBoard.
-  To force the device to wake up you need to connect to a pin (for example INT0) seperately on the module.
-  If you don't have a platform with a Qwiic connection use the SparkFun Qwiic Breadboard Jumper (https://www.sparkfun.com/products/14425)
-  Open the serial monitor at 115200 baud to see the output
-*/
-
-#include <SparkFun_u-blox_GNSS_Arduino_Library.h> //http://librarymanager/All#SparkFun_u-blox_GNSS
-SFE_UBLOX_GNSS myGNSS;
-
-// define a digital pin capable of driving HIGH and LOW
-#define WAKEUP_PIN 5
-
-// Possible GNSS interrupt pins for powerOffWithInterrupt are:
-// VAL_RXM_PMREQ_WAKEUPSOURCE_UARTRX  = uartrx
-// VAL_RXM_PMREQ_WAKEUPSOURCE_EXTINT0 = extint0 (default)
-// VAL_RXM_PMREQ_WAKEUPSOURCE_EXTINT1 = extint1
-// VAL_RXM_PMREQ_WAKEUPSOURCE_SPICS   = spics
-// These values can be or'd (|) together to enable interrupts on multiple pins
-
-void wakeUp() {
-
-  Serial.print("-- waking up module via pin " + String(WAKEUP_PIN));
-  Serial.println(" on your microcontroller --");
-
-  digitalWrite(WAKEUP_PIN, LOW);
-  delay(1000);
-  digitalWrite(WAKEUP_PIN, HIGH);
-  delay(1000);
-  digitalWrite(WAKEUP_PIN, LOW);
-}
-
-
-void setup() {
-
-  pinMode(WAKEUP_PIN, OUTPUT);
-  digitalWrite(WAKEUP_PIN, LOW);
-
-  Serial.begin(115200);
-  while (!Serial); //Wait for user to open terminal
-  Serial.println("SparkFun u-blox Example");
-
-  Wire.begin();
-
-  //myGNSS.enableDebugging(); // Enable debug messages
-
-  if (myGNSS.begin() == false) //Connect to the u-blox module using Wire port
-  {
-    Serial.println(F("u-blox GNSS not detected at default I2C address. Please check wiring. Freezing."));
-    while (1);
-  }
-
-  // Powering off for 20s, you should see the power consumption drop.
-  Serial.println("-- Powering off module for 20s --");
-
-  myGNSS.powerOff(20000);
-  //myGNSS.powerOffWithInterrupt(20000, VAL_RXM_PMREQ_WAKEUPSOURCE_EXTINT0);
-
-  delay(10000);
-
-  // After 10 seconds wake the device via the specified pin on your microcontroller and module.
-  wakeUp();
-}
-
-void loop() {
-  //Do nothing
-}
diff --git a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Example23_TimePulseParameters/Example23_TimePulse_BulletTime/Example23_TimePulse_BulletTime.ino b/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Example23_TimePulseParameters/Example23_TimePulse_BulletTime/Example23_TimePulse_BulletTime.ino
deleted file mode 100644
index c7b25fa..0000000
--- a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Example23_TimePulseParameters/Example23_TimePulse_BulletTime/Example23_TimePulse_BulletTime.ino
+++ /dev/null
@@ -1,120 +0,0 @@
-/*
-  Time Pulse Parameters - Bullet Time (https://en.wikipedia.org/wiki/Bullet_time)
-  By: Paul Clark (PaulZC)
-  Date: January 13th, 2021
-
-  License: MIT. See license file for more information but you can
-  basically do whatever you want with this code.
-
-  This example shows how to change the time pulse parameters and configure the TIMEPULSE (PPS)
-  pin to produce a pulse once per second but with an adjustable delay. You could use this to
-  trigger multiple cameras and replicate the "bullet time" effect.
-
-  The SparkFun GPS-RTK-SMA Breakout - ZED-F9P (Qwiic) (https://www.sparkfun.com/products/16481)
-  has solder pads which will let you connect an SMA connector to the TIMEPULSE signal. Need an
-  accurate timelapse camera shutter signal? This is the product for you!
-
-  Feel like supporting open source hardware?
-  Buy a board from SparkFun!
-  ZED-F9P RTK2: https://www.sparkfun.com/products/15136
-  NEO-M8P RTK: https://www.sparkfun.com/products/15005
-  SAM-M8Q: https://www.sparkfun.com/products/15106
-
-  Hardware Connections:
-  Plug a Qwiic cable into the GNSS and a BlackBoard
-  If you don't have a platform with a Qwiic connection use the SparkFun Qwiic Breadboard Jumper (https://www.sparkfun.com/products/14425)
-  Open the serial monitor at 115200 baud to see the output
-*/
-
-#include <Wire.h> //Needed for I2C to GNSS
-
-#include "SparkFun_u-blox_GNSS_Arduino_Library.h" //http://librarymanager/All#SparkFun_u-blox_GNSS
-SFE_UBLOX_GNSS myGNSS;
-
-void setup()
-{
-  Serial.begin(115200);
-  while (!Serial)
-    ; //Wait for user to open terminal
-  Serial.println(F("SparkFun u-blox Example"));
-
-  Wire.begin();
-
-  //myGNSS.enableDebugging(); // Uncomment this line to enable debug messages
-
-  if (myGNSS.begin() == false) //Connect to the u-blox module using Wire port
-  {
-    Serial.println(F("u-blox GNSS not detected at default I2C address. Please check wiring. Freezing."));
-    while (1)
-      ;
-  }
-
-  myGNSS.setI2COutput(COM_TYPE_UBX); //Set the I2C port to output UBX only (turn off NMEA noise)
-
-  // Create storage for the time pulse parameters
-  UBX_CFG_TP5_data_t timePulseParameters;
-
-  // Get the time pulse parameters
-  if (myGNSS.getTimePulseParameters(&timePulseParameters) == false)
-  {
-    Serial.println(F("getTimePulseParameters failed! Freezing..."));
-    while (1) ; // Do nothing more
-  }
-
-  // Print the CFG TP5 version
-  Serial.print(F("UBX_CFG_TP5 version: "));
-  Serial.println(timePulseParameters.version);
-
-  timePulseParameters.tpIdx = 0; // Select the TIMEPULSE pin
-  //timePulseParameters.tpIdx = 1; // Or we could select the TIMEPULSE2 pin instead, if the module has one
-
-  // We can configure the time pulse pin to produce a defined frequency or period
-  // Here is how to set the period:
-
-  // Let's say that we want our pulse-per-second to be as accurate as possible. So, let's tell the module
-  // to generate no signal while it is _locking_ to GNSS time. We want the signal to start only when the module is
-  // _locked_ to GNSS time.
-  timePulseParameters.freqPeriod = 0; // Set the frequency/period to zero
-  timePulseParameters.pulseLenRatio = 0; // Set the pulse ratio to zero
-
-  // When the module is _locked_ to GNSS time, make it generate a 0.1 second pulse once per second
-  timePulseParameters.freqPeriodLock = 1000000; // Set the period to 1,000,000 us
-  timePulseParameters.pulseLenRatioLock = 100000; // Set the pulse length to 0.1s (100,000 us)
-  timePulseParameters.flags.bits.polarity = 1; // Set the polarity to "1" (high for 0.1s, low for 0.9s, rising edge at top of second)
-
-  // We can use userConfigDelay to delay the pulse for each camera. The delay needs to be negative for this example.
-  // We can delay the pulse by +/- 2^31 nanoseconds (+/- 2.147 seconds)
-  //timePulseParameters.userConfigDelay = 0; // Camera 1: delay the pulse by 0ns
-  //timePulseParameters.userConfigDelay = -100000000; // Camera 2: delay the pulse by 0.1s (100,000,000 ns)
-  //timePulseParameters.userConfigDelay = -200000000; // Camera 3: delay the pulse by 0.2s (200,000,000 ns)
-  timePulseParameters.userConfigDelay = -300000000; // Camera 4: delay the pulse by 0.3s (300,000,000 ns)
-  //timePulseParameters.userConfigDelay = -400000000; // Camera 5: delay the pulse by 0.4s (400,000,000 ns)
-  //timePulseParameters.userConfigDelay = -500000000; // Camera 6: delay the pulse by 0.5s (500,000,000 ns)
-  //timePulseParameters.userConfigDelay = -600000000; // Camera 7: delay the pulse by 0.6s (600,000,000 ns)
-  //timePulseParameters.userConfigDelay = -700000000; // Camera 8: delay the pulse by 0.7s (700,000,000 ns)
-  //timePulseParameters.userConfigDelay = -800000000; // Camera 9: delay the pulse by 0.8s (800,000,000 ns)
-  //timePulseParameters.userConfigDelay = -900000000; // Camera 10: delay the pulse by 0.9s (900,000,000 ns)
-
-  timePulseParameters.flags.bits.active = 1; // Make sure the active flag is set to enable the time pulse. (Set to 0 to disable.)
-  timePulseParameters.flags.bits.lockedOtherSet = 1; // Tell the module to use freqPeriod while locking and freqPeriodLock when locked to GNSS time
-  timePulseParameters.flags.bits.isFreq = 0; // Tell the module that we want to set the period (not the frequency)
-  timePulseParameters.flags.bits.isLength = 1; // Tell the module that pulseLenRatio is a length (in us) - not a duty cycle
-
-  // Now set the time pulse parameters
-  if (myGNSS.setTimePulseParameters(&timePulseParameters) == false)
-  {
-    Serial.println(F("setTimePulseParameters failed!"));
-  }
-  else
-  {
-    Serial.println(F("Success!"));
-  }
-
-  // Finally, save the time pulse parameters in battery-backed memory so the pulse will automatically restart at power on
-  myGNSS.saveConfigSelective(VAL_CFG_SUBSEC_NAVCONF); // Save the configuration
-}
-
-void loop()
-{
-  // Nothing to do here
-}
diff --git a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Example23_TimePulseParameters/Example23_TimePulse_Frequency/Example23_TimePulse_Frequency.ino b/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Example23_TimePulseParameters/Example23_TimePulse_Frequency/Example23_TimePulse_Frequency.ino
deleted file mode 100644
index e8c775c..0000000
--- a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Example23_TimePulseParameters/Example23_TimePulse_Frequency/Example23_TimePulse_Frequency.ino
+++ /dev/null
@@ -1,101 +0,0 @@
-/*
-  Time Pulse Parameters - Frequency
-  By: Paul Clark (PaulZC)
-  Date: January 13th, 2021
-
-  License: MIT. See license file for more information but you can
-  basically do whatever you want with this code.
-
-  This example shows how to change the time pulse parameters and configure the TIMEPULSE (PPS)
-  pin to produce a 1kHz squarewave
-
-  The SparkFun GPS-RTK-SMA Breakout - ZED-F9P (Qwiic) (https://www.sparkfun.com/products/16481)
-  has solder pads which will let you connect an SMA connector to the TIMEPULSE signal. Need an
-  accurate frequency or clock source for your latest project? This is the product for you!
-
-  Feel like supporting open source hardware?
-  Buy a board from SparkFun!
-  ZED-F9P RTK2: https://www.sparkfun.com/products/15136
-  NEO-M8P RTK: https://www.sparkfun.com/products/15005
-  SAM-M8Q: https://www.sparkfun.com/products/15106
-
-  Hardware Connections:
-  Plug a Qwiic cable into the GNSS and a BlackBoard
-  If you don't have a platform with a Qwiic connection use the SparkFun Qwiic Breadboard Jumper (https://www.sparkfun.com/products/14425)
-  Open the serial monitor at 115200 baud to see the output
-*/
-
-#include <Wire.h> //Needed for I2C to GNSS
-
-#include "SparkFun_u-blox_GNSS_Arduino_Library.h" //http://librarymanager/All#SparkFun_u-blox_GNSS
-SFE_UBLOX_GNSS myGNSS;
-
-void setup()
-{
-  Serial.begin(115200);
-  while (!Serial)
-    ; //Wait for user to open terminal
-  Serial.println(F("SparkFun u-blox Example"));
-
-  Wire.begin();
-
-  //myGNSS.enableDebugging(); // Uncomment this line to enable debug messages
-
-  if (myGNSS.begin() == false) //Connect to the u-blox module using Wire port
-  {
-    Serial.println(F("u-blox GNSS not detected at default I2C address. Please check wiring. Freezing."));
-    while (1)
-      ;
-  }
-
-  myGNSS.setI2COutput(COM_TYPE_UBX); //Set the I2C port to output UBX only (turn off NMEA noise)
-
-  // Create storage for the time pulse parameters
-  UBX_CFG_TP5_data_t timePulseParameters;
-
-  // Get the time pulse parameters
-  if (myGNSS.getTimePulseParameters(&timePulseParameters) == false)
-  {
-    Serial.println(F("getTimePulseParameters failed! Freezing..."));
-    while (1) ; // Do nothing more
-  }
-
-  // Print the CFG TP5 version
-  Serial.print(F("UBX_CFG_TP5 version: "));
-  Serial.println(timePulseParameters.version);
-
-  timePulseParameters.tpIdx = 0; // Select the TIMEPULSE pin
-  //timePulseParameters.tpIdx = 1; // Or we could select the TIMEPULSE2 pin instead, if the module has one
-
-  // We can configure the time pulse pin to produce a defined frequency or period
-  // Here is how to set the frequency:
-
-  // While the module is _locking_ to GNSS time, make it generate 2kHz
-  timePulseParameters.freqPeriod = 2000; // Set the frequency/period to 2000Hz
-  timePulseParameters.pulseLenRatio = 0x55555555; // Set the pulse ratio to 1/3 * 2^32 to produce 33:67 mark:space
-
-  // When the module is _locked_ to GNSS time, make it generate 1kHz
-  timePulseParameters.freqPeriodLock = 1000; // Set the frequency/period to 1000Hz
-  timePulseParameters.pulseLenRatioLock = 0x80000000; // Set the pulse ratio to 1/2 * 2^32 to produce 50:50 mark:space
-
-  timePulseParameters.flags.bits.active = 1; // Make sure the active flag is set to enable the time pulse. (Set to 0 to disable.)
-  timePulseParameters.flags.bits.lockedOtherSet = 1; // Tell the module to use freqPeriod while locking and freqPeriodLock when locked to GNSS time
-  timePulseParameters.flags.bits.isFreq = 1; // Tell the module that we want to set the frequency (not the period)
-  timePulseParameters.flags.bits.isLength = 0; // Tell the module that pulseLenRatio is a ratio / duty cycle (* 2^-32) - not a length (in us)
-  timePulseParameters.flags.bits.polarity = 1; // Tell the module that we want the rising edge at the top of second. (Set to 0 for falling edge.)
-
-  // Now set the time pulse parameters
-  if (myGNSS.setTimePulseParameters(&timePulseParameters) == false)
-  {
-    Serial.println(F("setTimePulseParameters failed!"));
-  }
-  else
-  {
-    Serial.println(F("Success!"));
-  }
-}
-
-void loop()
-{
-  // Nothing to do here
-}
diff --git a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Example23_TimePulseParameters/Example23_TimePulse_Period/Example23_TimePulse_Period.ino b/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Example23_TimePulseParameters/Example23_TimePulse_Period/Example23_TimePulse_Period.ino
deleted file mode 100644
index 4a49ba2..0000000
--- a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Example23_TimePulseParameters/Example23_TimePulse_Period/Example23_TimePulse_Period.ino
+++ /dev/null
@@ -1,108 +0,0 @@
-/*
-  Time Pulse Parameters - Period
-  By: Paul Clark (PaulZC)
-  Date: January 13th, 2021
-
-  License: MIT. See license file for more information but you can
-  basically do whatever you want with this code.
-
-  This example shows how to change the time pulse parameters and configure the TIMEPULSE (PPS)
-  pin to produce a 1 second pulse every 30 seconds. What's really cool is that if you run this
-  example on two GNSS boards, the pulses are precisely synchronised!
-
-  The SparkFun GPS-RTK-SMA Breakout - ZED-F9P (Qwiic) (https://www.sparkfun.com/products/16481)
-  has solder pads which will let you connect an SMA connector to the TIMEPULSE signal. Need an
-  accurate timelapse camera shutter signal? This is the product for you!
-
-  Feel like supporting open source hardware?
-  Buy a board from SparkFun!
-  ZED-F9P RTK2: https://www.sparkfun.com/products/15136
-  NEO-M8P RTK: https://www.sparkfun.com/products/15005
-  SAM-M8Q: https://www.sparkfun.com/products/15106
-
-  Hardware Connections:
-  Plug a Qwiic cable into the GNSS and a BlackBoard
-  If you don't have a platform with a Qwiic connection use the SparkFun Qwiic Breadboard Jumper (https://www.sparkfun.com/products/14425)
-  Open the serial monitor at 115200 baud to see the output
-*/
-
-#include <Wire.h> //Needed for I2C to GNSS
-
-#include "SparkFun_u-blox_GNSS_Arduino_Library.h" //http://librarymanager/All#SparkFun_u-blox_GNSS
-SFE_UBLOX_GNSS myGNSS;
-
-void setup()
-{
-  Serial.begin(115200);
-  while (!Serial)
-    ; //Wait for user to open terminal
-  Serial.println(F("SparkFun u-blox Example"));
-
-  Wire.begin();
-
-  //myGNSS.enableDebugging(); // Uncomment this line to enable debug messages
-
-  if (myGNSS.begin() == false) //Connect to the u-blox module using Wire port
-  {
-    Serial.println(F("u-blox GNSS not detected at default I2C address. Please check wiring. Freezing."));
-    while (1)
-      ;
-  }
-
-  myGNSS.setI2COutput(COM_TYPE_UBX); //Set the I2C port to output UBX only (turn off NMEA noise)
-
-  // Create storage for the time pulse parameters
-  UBX_CFG_TP5_data_t timePulseParameters;
-
-  // Get the time pulse parameters
-  if (myGNSS.getTimePulseParameters(&timePulseParameters) == false)
-  {
-    Serial.println(F("getTimePulseParameters failed! Freezing..."));
-    while (1) ; // Do nothing more
-  }
-
-  // Print the CFG TP5 version
-  Serial.print(F("UBX_CFG_TP5 version: "));
-  Serial.println(timePulseParameters.version);
-
-  timePulseParameters.tpIdx = 0; // Select the TIMEPULSE pin
-  //timePulseParameters.tpIdx = 1; // Or we could select the TIMEPULSE2 pin instead, if the module has one
-
-  // We can configure the time pulse pin to produce a defined frequency or period
-  // Here is how to set the period:
-
-  // Let's say that we want our 1 pulse every 30 seconds to be as accurate as possible. So, let's tell the module
-  // to generate no signal while it is _locking_ to GNSS time. We want the signal to start only when the module is
-  // _locked_ to GNSS time.
-  timePulseParameters.freqPeriod = 0; // Set the frequency/period to zero
-  timePulseParameters.pulseLenRatio = 0; // Set the pulse ratio to zero
-
-  // When the module is _locked_ to GNSS time, make it generate a 1 second pulse every 30 seconds
-  // (Although the period can be a maximum of 2^32 microseconds (over one hour), the upper limit appears to be around 33 seconds)
-  timePulseParameters.freqPeriodLock = 30000000; // Set the period to 30,000,000 us
-  timePulseParameters.pulseLenRatioLock = 1000000; // Set the pulse length to 1,000,000 us
-
-  timePulseParameters.flags.bits.active = 1; // Make sure the active flag is set to enable the time pulse. (Set to 0 to disable.)
-  timePulseParameters.flags.bits.lockedOtherSet = 1; // Tell the module to use freqPeriod while locking and freqPeriodLock when locked to GNSS time
-  timePulseParameters.flags.bits.isFreq = 0; // Tell the module that we want to set the period (not the frequency)
-  timePulseParameters.flags.bits.isLength = 1; // Tell the module that pulseLenRatio is a length (in us) - not a duty cycle
-  timePulseParameters.flags.bits.polarity = 1; // Tell the module that we want the rising edge at the top of second. (Set to 0 for falling edge.)
-
-  // Now set the time pulse parameters
-  if (myGNSS.setTimePulseParameters(&timePulseParameters) == false)
-  {
-    Serial.println(F("setTimePulseParameters failed!"));
-  }
-  else
-  {
-    Serial.println(F("Success!"));
-  }
-
-  // Finally, save the time pulse parameters in battery-backed memory so the pulse will automatically restart at power on
-  myGNSS.saveConfigSelective(VAL_CFG_SUBSEC_NAVCONF); // Save the configuration
-}
-
-void loop()
-{
-  // Nothing to do here
-}
diff --git a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Example24_GetUnixEpochAndMicros/Example24_GetUnixEpochAndMicros.ino b/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Example24_GetUnixEpochAndMicros/Example24_GetUnixEpochAndMicros.ino
deleted file mode 100644
index 2ebdc2a..0000000
--- a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Example24_GetUnixEpochAndMicros/Example24_GetUnixEpochAndMicros.ino
+++ /dev/null
@@ -1,111 +0,0 @@
-/*
-  Getting Unix Epoch Time and micros using u-blox commands
-  By: UT2UH
-  Date: March 31th, 2021
-  License: MIT. See license file for more information but you can
-  basically do whatever you want with this code.
-
-  This example shows how to query a u-blox module for the current time and date as Unix Epoch uint32_t type to avoid time.h dependency.
-  We also turn off the NMEA output on the I2C port. This decreases the amount of I2C traffic dramatically.
-
-  Note: this example works best on modules like the ZED_F9P. Modules like the ZOE_M8Q do not support confirmedTime.
-
-  Leave NMEA parsing behind. Now you can simply ask the module for the datums you want!
-
-  Feel like supporting open source hardware?
-  Buy a board from SparkFun!
-  ZED-F9P RTK2: https://www.sparkfun.com/products/15136
-  NEO-M8P RTK: https://www.sparkfun.com/products/15005
-  SAM-M8Q: https://www.sparkfun.com/products/15106
-
-  Hardware Connections:
-  Plug a Qwiic cable into the GNSS and a BlackBoard
-  If you don't have a platform with a Qwiic connection use the SparkFun Qwiic Breadboard Jumper (https://www.sparkfun.com/products/14425)
-  Open the serial monitor at 115200 baud to see the output
-*/
-
-#include <Wire.h> //Needed for I2C to GNSS
-
-#include <SparkFun_u-blox_GNSS_Arduino_Library.h> //http://librarymanager/All#SparkFun_u-blox_GNSS
-SFE_UBLOX_GNSS myGNSS;
-
-
-long lastTime = 0; //Simple local timer. Limits amount if I2C traffic to u-blox module.
-  
-void setup()
-{
-  Serial.begin(115200);
-  while (!Serial)
-    ; //Wait for user to open terminal
-  Serial.println("SparkFun u-blox Example");
-
-  Wire.begin();
-  
-  if (myGNSS.begin() == false) //Connect to the u-blox module using Wire port
-  {
-    Serial.println(F("u-blox GNSS not detected at default I2C address. Please check wiring. Freezing."));
-    while (1)
-      ;
-  }
-
-  // Uncomment the next line if you need to completely reset your module
-  //myGNSS.factoryDefault(); delay(5000); // Reset everything and wait while the module restarts
-
-  myGNSS.setI2COutput(COM_TYPE_UBX); //Set the I2C port to output UBX only (turn off NMEA noise)
-  //myGNSS.saveConfiguration();        //Optional: Save the current settings to flash and BBR
-
-  Serial.println("Compare Unix Epoch given with reference one from https://www.epochconverter.com/");
-
-}
-
-void loop()
-{
-  //Query module only every second. Doing it more often will just cause I2C traffic.
-  //The module only responds when a new position is available
-  if (millis() - lastTime > 1000)
-  {
-    lastTime = millis(); //Update the timer
-
-    // getUnixEpoch marks the PVT data as stale so you will get Unix time and PVT time on alternate seconds
-
-    uint32_t us;  //microseconds returned by getUnixEpoch()
-    uint32_t epoch = myGNSS.getUnixEpoch();
-    Serial.print("Unix Epoch rounded: ");
-    Serial.print(epoch, DEC);    
-    epoch = myGNSS.getUnixEpoch(us);
-    Serial.print("  Exact Unix Epoch: ");
-    Serial.print(epoch, DEC);
-    Serial.print("  micros: ");
-    Serial.println(us, DEC);
-
-    Serial.print(myGNSS.getYear());
-    Serial.print("-");
-    Serial.print(myGNSS.getMonth());
-    Serial.print("-");
-    Serial.print(myGNSS.getDay());
-    Serial.print(" ");
-    Serial.print(myGNSS.getHour());
-    Serial.print(":");
-    Serial.print(myGNSS.getMinute());
-    Serial.print(":");
-    Serial.print(myGNSS.getSecond());
-    
-    Serial.print("  Time is ");
-    if (myGNSS.getTimeValid() == false)
-    {
-      Serial.print("not ");
-    }
-    Serial.print("valid ");
-    if (myGNSS.getConfirmedTime() == false)
-    {
-      Serial.print("but not ");
-    } else {
-      Serial.print("and ");
-    }
-    Serial.print("confirmed");
-
-    byte SIV = myGNSS.getSIV();
-    Serial.print(F("  SIV: "));
-    Serial.println(SIV);
-  }
-}
\ No newline at end of file
diff --git a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Example25_MeasurementAndNavigationRate/Example25_MeasurementAndNavigationRate.ino b/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Example25_MeasurementAndNavigationRate/Example25_MeasurementAndNavigationRate.ino
deleted file mode 100644
index c16f6ed..0000000
--- a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Example25_MeasurementAndNavigationRate/Example25_MeasurementAndNavigationRate.ino
+++ /dev/null
@@ -1,123 +0,0 @@
-/*
-  Demonstrate get/setMeasurementRate and get/setNavigationRate
-  By: Paul Clark
-  SparkFun Electronics
-  Date: March 30th, 2021
-  License: MIT. See license file for more information but you can
-  basically do whatever you want with this code.
-
-  This example shows how to slow down the measurement and navigation rates.
-  This should run on any GNSS module but has only been tested on the ZED_F9P and ZOE_M8Q.
-
-  Feel like supporting open source hardware?
-  Buy a board from SparkFun!
-  ZED-F9P RTK2: https://www.sparkfun.com/products/15136
-  NEO-M8P RTK: https://www.sparkfun.com/products/15005
-  SAM-M8Q: https://www.sparkfun.com/products/15106
-
-  Hardware Connections:
-  Plug a Qwiic cable into the GNSS and a BlackBoard
-  If you don't have a platform with a Qwiic connection use the SparkFun Qwiic Breadboard Jumper (https://www.sparkfun.com/products/14425)
-  Open the serial monitor at 115200 baud to see the output
-*/
-
-#include <Wire.h> //Needed for I2C to GNSS
-
-#include <SparkFun_u-blox_GNSS_Arduino_Library.h> //http://librarymanager/All#SparkFun_u-blox_GNSS
-SFE_UBLOX_GNSS myGNSS;
-
-unsigned long lastTime = 0; //Simple local timer. Used to calc the message interval.
-
-void setup()
-{
-  Serial.begin(115200);
-  while (!Serial); //Wait for user to open terminal
-  Serial.println("SparkFun u-blox Example");
-
-  Wire.begin();
-
-  //myGNSS.enableDebugging(); // Uncomment this line to enable helpful debug messages on Serial
-
-  if (myGNSS.begin() == false) //Connect to the u-blox module using Wire port
-  {
-    Serial.println(F("u-blox GNSS not detected at default I2C address. Please check wiring. Freezing."));
-    while (1);
-  }
-
-  // Uncomment the next line if you need to completely reset your module
-  //myGNSS.factoryDefault(); delay(5000); // Reset everything and wait while the module restarts
-
-  myGNSS.setI2COutput(COM_TYPE_UBX); //Set the I2C port to output UBX only (turn off NMEA noise)
-
-  // Begin by printing the current measurement rate and navigation rate
-
-  uint16_t rate = myGNSS.getMeasurementRate(); //Get the measurement rate of this module
-  Serial.print("Current measurement interval (ms): ");
-  Serial.println(rate);
-
-  rate = myGNSS.getNavigationRate(); //Get the navigation rate of this module
-  Serial.print("Current navigation ratio (cycles): ");
-  Serial.println(rate);
-
-  // The measurement rate is the elapsed time between GNSS measurements, which defines the rate
-  // e.g. 100 ms => 10 Hz, 1000 ms => 1 Hz, 10000 ms => 0.1 Hz.
-  // Let's set the measurement rate (interval) to 5 seconds = 5000 milliseconds
-  if (myGNSS.setMeasurementRate(5000) == false)
-  {
-    Serial.println(F("Could not set the measurement rate. Freezing."));
-    while (1);
-  }
-
-  // setMeasurementRate will set i2cPollingWait to a quarter of the interval
-  // Let's override that so we can poll the module more frequently and avoid timeouts
-  myGNSS.setI2CpollingWait(25); // Set i2cPollingWait to 25ms
-
-  // The navigation rate is the ratio between the number of measurements and the number of navigation solutions
-  // e.g. 5 means five measurements for every navigation solution. Maximum value is 127
-  // Let's set the navigation rate (ratio) to 12 to produce a solution every minute
-  if (myGNSS.setNavigationRate(12) == false)
-  {
-    Serial.println(F("Could not set the navigation rate. Freezing."));
-    while (1);
-  }
-
-  // Another trick we can use is to mark the CFG RATE data as stale so we can be sure we read fresh data
-  myGNSS.packetUBXCFGRATE->moduleQueried.moduleQueried.all = 0; // Mark all of the CFG RATE data as stale
-
-  // Read and print the updated measurement rate and navigation rate
-
-  rate = myGNSS.getMeasurementRate(); //Get the measurement rate of this module
-  Serial.print("New measurement interval (ms): ");
-  Serial.println(rate);
-
-  rate = myGNSS.getNavigationRate(); //Get the navigation rate of this module
-  Serial.print("New navigation ratio (cycles): ");
-  Serial.println(rate);
-
-  lastTime = millis();
-}
-
-void loop()
-{
-  // i2cPollingWait will prevent us from thrashing the I2C bus
-
-  if (myGNSS.getPVT()) //Check for new Position, Velocity, Time data. getPVT returns true if new data is available.
-  {    
-      long latitude = myGNSS.getLatitude();
-      Serial.print(F("Lat: "));
-      Serial.print(latitude);
-
-      long longitude = myGNSS.getLongitude();
-      Serial.print(F(" Long: "));
-      Serial.print(longitude);
-
-      //Calculate the interval since the last message
-      Serial.print(F(" Interval: "));
-      Serial.print(((float)(millis() - lastTime)) / 1000.0, 2);
-      Serial.print(F("s"));
-
-      Serial.println();
-
-      lastTime = millis(); //Update lastTime
-  }
-}
diff --git a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Example26_End/Example26_End.ino b/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Example26_End/Example26_End.ino
deleted file mode 100644
index 077ed90..0000000
--- a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Example26_End/Example26_End.ino
+++ /dev/null
@@ -1,91 +0,0 @@
-/*
-  Demonstrating how to use "end"
-  By: Paul Clark
-  SparkFun Electronics
-  Date: April 1st, 2021
-  License: MIT. See license file for more information but you can
-  basically do whatever you want with this code.
-
-  This example shows how to use the end function.
-  End will stop all automatic message processing and free (nearly) all used RAM.
-  The file buffer is deleted (if it exists).
-  
-  Feel like supporting open source hardware?
-  Buy a board from SparkFun!
-  ZED-F9P RTK2: https://www.sparkfun.com/products/15136
-  NEO-M8P RTK: https://www.sparkfun.com/products/15005
-  SAM-M8Q: https://www.sparkfun.com/products/15106
-
-  Hardware Connections:
-  Plug a Qwiic cable into the GNSS and a BlackBoard
-  If you don't have a platform with a Qwiic connection use the SparkFun Qwiic Breadboard Jumper (https://www.sparkfun.com/products/14425)
-  Open the serial monitor at 115200 baud to see the output
-*/
-
-#include <Wire.h> //Needed for I2C to GNSS
-
-#include <SparkFun_u-blox_GNSS_Arduino_Library.h> //http://librarymanager/All#SparkFun_u-blox_GNSS
-SFE_UBLOX_GNSS myGNSS;
-
-void setup()
-{
-  Serial.begin(115200);
-  while (!Serial); //Wait for user to open terminal
-  Serial.println("SparkFun u-blox Example");
-
-  Wire.begin();
-
-  //myGNSS.enableDebugging(); // Uncomment this line to enable helpful debug messages on Serial
-  
-  if (myGNSS.begin() == false) //Connect to the u-blox module using Wire port
-  {
-    Serial.println(F("u-blox GNSS not detected at default I2C address. Please check wiring. Freezing."));
-    while (1);
-  }
-
-  myGNSS.setI2COutput(COM_TYPE_UBX); //Set the I2C port to output UBX only (turn off NMEA noise)
-  //myGNSS.saveConfiguration(); //Optional: Save the current settings to flash and BBR
-
-  myGNSS.end(); // Call end now just because we can - it won't do much as we haven't used any automatic messages
-}
-
-void loop()
-{
-  // Allocate 128 bytes for file storage - this checks that issue #20 has been resolved
-  // Allocating only 128 bytes will let this code run on the ATmega328P
-  // If your processor has plenty of RAM, you can increase this to something useful like 16KB
-  myGNSS.setFileBufferSize(128);
-  
-  if (myGNSS.begin() == false) //Connect to the u-blox module using Wire port
-  {
-    Serial.println(F("u-blox GNSS not detected. Freezing."));
-    while (1);
-  }
-
-  Serial.print(F("The file buffer size is: "));
-  Serial.println(myGNSS.getFileBufferSize());    
-
-  // Request Position, Velocity, Time
-  // RAM will be allocated for PVT message processing
-  // getPVT will return true is fresh PVT data was received and processed
-  if (myGNSS.getPVT())
-  {
-    long latitude = myGNSS.getLatitude();
-    Serial.print(F("Lat: "));
-    Serial.print(latitude);
-
-    long longitude = myGNSS.getLongitude();
-    Serial.print(F(" Long: "));
-    Serial.print(longitude);
-    Serial.print(F(" (degrees * 10^-7)"));
-
-    long altitude = myGNSS.getAltitude();
-    Serial.print(F(" Alt: "));
-    Serial.print(altitude);
-    Serial.println(F(" (mm)"));
-  }
-
-  // Calling end will free the RAM allocated for file storage and PVT processing
-  // Calling end is optional. You can comment the next line if you want to.
-  myGNSS.end();
-}
diff --git a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Example27_MultipleRates/Example27_MultipleRates.ino b/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Example27_MultipleRates/Example27_MultipleRates.ino
deleted file mode 100644
index 057b493..0000000
--- a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Example27_MultipleRates/Example27_MultipleRates.ino
+++ /dev/null
@@ -1,106 +0,0 @@
-/*
-  Configuring the GNSS to produce multiple messages at different rates
-  By: Paul Clark
-  SparkFun Electronics
-  Date: April 1st, 2021
-  License: MIT. See license file for more information but you can
-  basically do whatever you want with this code.
-
-  This example shows how to configure the U-Blox GNSS to output multiple messages at different rates:
-  PVT is output every second;
-  POSECEF is output every five seconds;
-  VELNED is output every ten seconds.
-
-  Feel like supporting open source hardware?
-  Buy a board from SparkFun!
-  ZED-F9P RTK2: https://www.sparkfun.com/products/15136
-  NEO-M8P RTK: https://www.sparkfun.com/products/15005
-  SAM-M8Q: https://www.sparkfun.com/products/15106
-
-  Hardware Connections:
-  Plug a Qwiic cable into the GNSS and a BlackBoard
-  If you don't have a platform with a Qwiic connection use the SparkFun Qwiic Breadboard Jumper (https://www.sparkfun.com/products/14425)
-  Open the serial monitor at 115200 baud to see the output
-*/
-
-#include <Wire.h> //Needed for I2C to GNSS
-
-#include <SparkFun_u-blox_GNSS_Arduino_Library.h> //http://librarymanager/All#SparkFun_u-blox_GNSS
-SFE_UBLOX_GNSS myGNSS;
-
-void setup()
-{
-  Serial.begin(115200);
-  while (!Serial); //Wait for user to open terminal
-  Serial.println("SparkFun u-blox Example");
-
-  Wire.begin();
-
-  if (myGNSS.begin() == false) //Connect to the u-blox module using Wire port
-  {
-    Serial.println(F("u-blox GNSS not detected at default I2C address. Please check wiring. Freezing."));
-    while (1);
-  }
-
-  myGNSS.setI2COutput(COM_TYPE_UBX); //Set the I2C port to output UBX only (turn off NMEA noise)
-  myGNSS.setMeasurementRate(1000); //Produce a measurement every 1000ms
-  myGNSS.setNavigationRate(1); //Produce a navigation solution every measurement
-  
-  myGNSS.setAutoPVTrate(1); //Tell the GNSS to send the PVT solution every measurement
-  myGNSS.setAutoNAVPOSECEFrate(5); //Tell the GNSS to send each POSECEF solution every 5th measurement
-  myGNSS.setAutoNAVVELNEDrate(10); //Tell the GNSS to send each VELNED solution every 10th measurement
-  //myGNSS.saveConfiguration(); //Optional: Save the current settings to flash and BBR
-}
-
-void loop()
-{
-  // Calling getPVT returns true if there actually is a fresh navigation solution available.
-  if (myGNSS.getPVT())
-  {
-    long latitude = myGNSS.getLatitude();
-    Serial.print(F("Lat: "));
-    Serial.print(latitude);
-
-    long longitude = myGNSS.getLongitude();
-    Serial.print(F(" Long: "));
-    Serial.print(longitude);
-    Serial.print(F(" (degrees * 10^-7)"));
-
-    long altitude = myGNSS.getAltitude();
-    Serial.print(F(" Alt: "));
-    Serial.print(altitude);
-    Serial.println(F(" (mm)"));
-  }
-
-  // Calling getNAVPOSECEF returns true if there actually is a fresh position solution available.
-  if (myGNSS.getNAVPOSECEF())
-  {
-    Serial.print(F("ecefX: "));
-    Serial.print((float)myGNSS.packetUBXNAVPOSECEF->data.ecefX / 100.0, 2); // convert ecefX to m
-
-    Serial.print(F(" ecefY: "));
-    Serial.print((float)myGNSS.packetUBXNAVPOSECEF->data.ecefY / 100.0, 2); // convert ecefY to m
-
-    Serial.print(F(" ecefZ: "));
-    Serial.print((float)myGNSS.packetUBXNAVPOSECEF->data.ecefZ / 100.0, 2); // convert ecefY to m
-    Serial.println(F(" (m)"));
-
-    myGNSS.flushNAVPOSECEF(); //Mark all the data as read/stale so we get fresh data next time
-  }
-
-  // Calling getNAVVELNED returns true if there actually is fresh velocity data available.
-  if (myGNSS.getNAVVELNED())
-  {
-    Serial.print(F("velN: "));
-    Serial.print((float)myGNSS.packetUBXNAVVELNED->data.velN / 100.0, 2); // convert velN to m/s
-
-    Serial.print(F(" velE: "));
-    Serial.print((float)myGNSS.packetUBXNAVVELNED->data.velE / 100.0, 2); // convert velE to m/s
-
-    Serial.print(F(" velD: "));
-    Serial.print((float)myGNSS.packetUBXNAVVELNED->data.velD / 100.0, 2); // convert velD to m/s
-    Serial.println(F(" (m/s)"));
-
-    myGNSS.flushNAVVELNED(); //Mark all the data as read/stale so we get fresh data next time
-  }
-}
diff --git a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Example2_NMEAParsing/Example2_NMEAParsing.ino b/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Example2_NMEAParsing/Example2_NMEAParsing.ino
deleted file mode 100644
index 35c2001..0000000
--- a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Example2_NMEAParsing/Example2_NMEAParsing.ino
+++ /dev/null
@@ -1,83 +0,0 @@
-/*
-  Read NMEA sentences over I2C using u-blox module SAM-M8Q, NEO-M8P, etc
-  By: Nathan Seidle
-  SparkFun Electronics
-  Date: August 22nd, 2018
-  License: MIT. See license file for more information but you can
-  basically do whatever you want with this code.
-
-  This example reads the NMEA characters over I2C and pipes them to MicroNMEA
-  This example will output your current long/lat and satellites in view
- 
-  Feel like supporting open source hardware?
-  Buy a board from SparkFun!
-  ZED-F9P RTK2: https://www.sparkfun.com/products/15136
-  NEO-M8P RTK: https://www.sparkfun.com/products/15005
-  SAM-M8Q: https://www.sparkfun.com/products/15106
-
-  For more MicroNMEA info see https://github.com/stevemarple/MicroNMEA
-
-  Hardware Connections:
-  Plug a Qwiic cable into the GNSS and a BlackBoard
-  If you don't have a platform with a Qwiic connection use the SparkFun Qwiic Breadboard Jumper (https://www.sparkfun.com/products/14425)
-  Open the serial monitor at 115200 baud to see the output
-  Go outside! Wait ~25 seconds and you should see your lat/long
-*/
-
-#include <Wire.h> //Needed for I2C to GNSS
-
-#include <SparkFun_u-blox_GNSS_Arduino_Library.h> //http://librarymanager/All#SparkFun_u-blox_GNSS
-SFE_UBLOX_GNSS myGNSS;
-
-#include <MicroNMEA.h> //http://librarymanager/All#MicroNMEA
-char nmeaBuffer[100];
-MicroNMEA nmea(nmeaBuffer, sizeof(nmeaBuffer));
-
-void setup()
-{
-  Serial.begin(115200);
-  Serial.println("SparkFun u-blox Example");
-
-  Wire.begin();
-
-  if (myGNSS.begin() == false)
-  {
-    Serial.println(F("u-blox GNSS not detected at default I2C address. Please check wiring. Freezing."));
-    while (1);
-  }
-}
-
-void loop()
-{
-  myGNSS.checkUblox(); //See if new data is available. Process bytes as they come in.
-
-  if(nmea.isValid() == true)
-  {
-    long latitude_mdeg = nmea.getLatitude();
-    long longitude_mdeg = nmea.getLongitude();
-
-    Serial.print("Latitude (deg): ");
-    Serial.println(latitude_mdeg / 1000000., 6);
-    Serial.print("Longitude (deg): ");
-    Serial.println(longitude_mdeg / 1000000., 6);
-  }
-  else
-  {
-    Serial.print("No Fix - ");
-    Serial.print("Num. satellites: ");
-    Serial.println(nmea.getNumSatellites());
-  }
-
-  delay(250); //Don't pound too hard on the I2C bus
-}
-
-//This function gets called from the SparkFun u-blox Arduino Library
-//As each NMEA character comes in you can specify what to do with it
-//Useful for passing to other libraries like tinyGPS, MicroNMEA, or even
-//a buffer, radio, etc.
-void SFE_UBLOX_GNSS::processNMEA(char incoming)
-{
-  //Take the incoming char from the u-blox I2C port and pass it on to the MicroNMEA lib
-  //for sentence cracking
-  nmea.process(incoming);
-}
diff --git a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Example3_GetPosition/Example3_GetPosition.ino b/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Example3_GetPosition/Example3_GetPosition.ino
deleted file mode 100644
index be605f3..0000000
--- a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Example3_GetPosition/Example3_GetPosition.ino
+++ /dev/null
@@ -1,84 +0,0 @@
-/*
-  Reading lat and long via UBX binary commands - no more NMEA parsing!
-  By: Nathan Seidle
-  SparkFun Electronics
-  Date: January 3rd, 2019
-  License: MIT. See license file for more information but you can
-  basically do whatever you want with this code.
-
-  This example shows how to query a u-blox module for its lat/long/altitude. We also
-  turn off the NMEA output on the I2C port. This decreases the amount of I2C traffic 
-  dramatically.
-
-  Note: Long/lat are large numbers because they are * 10^7. To convert lat/long
-  to something google maps understands simply divide the numbers by 10,000,000. We 
-  do this so that we don't have to use floating point numbers.
-
-  Leave NMEA parsing behind. Now you can simply ask the module for the datums you want!
-
-  Feel like supporting open source hardware?
-  Buy a board from SparkFun!
-  ZED-F9P RTK2: https://www.sparkfun.com/products/15136
-  NEO-M8P RTK: https://www.sparkfun.com/products/15005
-  SAM-M8Q: https://www.sparkfun.com/products/15106
-
-  Hardware Connections:
-  Plug a Qwiic cable into the GNSS and a BlackBoard
-  If you don't have a platform with a Qwiic connection use the SparkFun Qwiic Breadboard Jumper (https://www.sparkfun.com/products/14425)
-  Open the serial monitor at 115200 baud to see the output
-*/
-
-#include <Wire.h> //Needed for I2C to GNSS
-
-#include <SparkFun_u-blox_GNSS_Arduino_Library.h> //http://librarymanager/All#SparkFun_u-blox_GNSS
-SFE_UBLOX_GNSS myGNSS;
-
-long lastTime = 0; //Simple local timer. Limits amount if I2C traffic to u-blox module.
-
-void setup()
-{
-  Serial.begin(115200);
-  while (!Serial); //Wait for user to open terminal
-  Serial.println("SparkFun u-blox Example");
-
-  Wire.begin();
-
-  if (myGNSS.begin() == false) //Connect to the u-blox module using Wire port
-  {
-    Serial.println(F("u-blox GNSS not detected at default I2C address. Please check wiring. Freezing."));
-    while (1);
-  }
-
-  myGNSS.setI2COutput(COM_TYPE_UBX); //Set the I2C port to output UBX only (turn off NMEA noise)
-  myGNSS.saveConfigSelective(VAL_CFG_SUBSEC_IOPORT); //Save (only) the communications port settings to flash and BBR
-}
-
-void loop()
-{
-  //Query module only every second. Doing it more often will just cause I2C traffic.
-  //The module only responds when a new position is available
-  if (millis() - lastTime > 1000)
-  {
-    lastTime = millis(); //Update the timer
-    
-    long latitude = myGNSS.getLatitude();
-    Serial.print(F("Lat: "));
-    Serial.print(latitude);
-
-    long longitude = myGNSS.getLongitude();
-    Serial.print(F(" Long: "));
-    Serial.print(longitude);
-    Serial.print(F(" (degrees * 10^-7)"));
-
-    long altitude = myGNSS.getAltitude();
-    Serial.print(F(" Alt: "));
-    Serial.print(altitude);
-    Serial.print(F(" (mm)"));
-
-    byte SIV = myGNSS.getSIV();
-    Serial.print(F(" SIV: "));
-    Serial.print(SIV);
-
-    Serial.println();
-  }
-}
diff --git a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Example4_FixType/Example4_FixType.ino b/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Example4_FixType/Example4_FixType.ino
deleted file mode 100644
index 5ddfc01..0000000
--- a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Example4_FixType/Example4_FixType.ino
+++ /dev/null
@@ -1,96 +0,0 @@
-/*
-  Get fix type and RTK fix type if available
-  By: Nathan Seidle
-  SparkFun Electronics
-  Date: January 3rd, 2019
-  License: MIT. See license file for more information but you can
-  basically do whatever you want with this code.
-
-  This example shows how to query a u-blox module for fix type and RTK fix type.
-  The fix type is as follows:
-    0 = no fix
-    1 = dead reckoning (requires external sensors)
-    2 = 2D (not quite enough satellites in view)
-    3 = 3D (the standard fix)
-    4 = GNSS + dead reckoning (requires external sensors)
-    5 = Time fix only
-
-  Additionally, if we are doing RTK, we can figure out if we have a floating 
-  RTK solution or if we have been able to resolve a fixec solution (better precision).
-
-  Leave NMEA parsing behind. Now you can simply ask the module for the datums you want!
-
-  Feel like supporting open source hardware?
-  Buy a board from SparkFun!
-  ZED-F9P RTK2: https://www.sparkfun.com/products/15136
-  NEO-M8P RTK: https://www.sparkfun.com/products/15005
-  SAM-M8Q: https://www.sparkfun.com/products/15106
-
-  Hardware Connections:
-  Plug a Qwiic cable into the GNSS and a BlackBoard
-  If you don't have a platform with a Qwiic connection use the SparkFun Qwiic Breadboard Jumper (https://www.sparkfun.com/products/14425)
-  Open the serial monitor at 115200 baud to see the output
-*/
-
-#include <Wire.h> //Needed for I2C to GNSS
-
-#include <SparkFun_u-blox_GNSS_Arduino_Library.h> //http://librarymanager/All#SparkFun_u-blox_GNSS
-SFE_UBLOX_GNSS myGNSS;
-
-long lastTime = 0; //Simple local timer. Limits amount if I2C traffic to u-blox module.
-
-void setup()
-{
-  Serial.begin(115200);
-  while (!Serial); //Wait for user to open terminal
-  Serial.println("SparkFun u-blox Example");
-
-  Wire.begin();
-  //Wire.setClock(400000); //Optional. Increase I2C clock speed to 400kHz.
-
-  if (myGNSS.begin() == false) //Connect to the u-blox module using Wire port
-  {
-    Serial.println(F("u-blox GNSS not detected at default I2C address. Please check wiring. Freezing."));
-    while (1);
-  }
-}
-
-void loop()
-{
-  //Query module only every second. Doing it more often will just cause I2C traffic.
-  if (millis() - lastTime > 1000)
-  {
-    lastTime = millis(); //Update the timer
-
-    long latitude = myGNSS.getLatitude();
-    Serial.print(F("Lat: "));
-    Serial.print(latitude);
-
-    long longitude = myGNSS.getLongitude();
-    Serial.print(F(" Long: "));
-    Serial.print(longitude);
-
-    long altitude = myGNSS.getAltitude();
-    Serial.print(F(" Alt: "));
-    Serial.print(altitude);
-
-    byte fixType = myGNSS.getFixType();
-    Serial.print(F(" Fix: "));
-    if(fixType == 0) Serial.print(F("No fix"));
-    else if(fixType == 1) Serial.print(F("Dead reckoning"));
-    else if(fixType == 2) Serial.print(F("2D"));
-    else if(fixType == 3) Serial.print(F("3D"));
-    else if(fixType == 4) Serial.print(F("GNSS + Dead reckoning"));
-    else if(fixType == 5) Serial.print(F("Time only"));
-
-    byte RTK = myGNSS.getCarrierSolutionType();
-    Serial.print(" RTK: ");
-    Serial.print(RTK);
-    if (RTK == 0) Serial.print(F(" (No solution)"));
-    else if (RTK == 1) Serial.print(F(" (High precision floating fix)"));
-    else if (RTK == 2) Serial.print(F(" (High precision fix)"));
-
-    Serial.println();
-  }
-
-}
diff --git a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Example5_SpeedHeadingPrecision/Example5_SpeedHeadingPrecision.ino b/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Example5_SpeedHeadingPrecision/Example5_SpeedHeadingPrecision.ino
deleted file mode 100644
index 427f726..0000000
--- a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Example5_SpeedHeadingPrecision/Example5_SpeedHeadingPrecision.ino
+++ /dev/null
@@ -1,83 +0,0 @@
-/*
-  Get Speed/Heading and dilution of precision via UBX binary commands - no more NMEA parsing!
-  By: Nathan Seidle
-  SparkFun Electronics
-  Date: January 3rd, 2019
-  License: MIT. See license file for more information but you can
-  basically do whatever you want with this code.
-
-  This example shows how to query a u-blox module for its lat/long/altitude.
-
-  Note: Long/lat are large numbers because they are * 10^7. To convert lat/long
-  to something google maps understands simply divide the numbers by 1,000,000. We
-  do this so that we don't have to use floating point numbers.
-
-  Leave NMEA parsing behind. Now you can simply ask the module for the datums you want!
-
-  Feel like supporting open source hardware?
-  Buy a board from SparkFun!
-  ZED-F9P RTK2: https://www.sparkfun.com/products/15136
-  NEO-M8P RTK: https://www.sparkfun.com/products/15005
-  SAM-M8Q: https://www.sparkfun.com/products/15106
-
-  Hardware Connections:
-  Plug a Qwiic cable into the GNSS and a BlackBoard
-  If you don't have a platform with a Qwiic connection use the SparkFun Qwiic Breadboard Jumper (https://www.sparkfun.com/products/14425)
-  Open the serial monitor at 115200 baud to see the output
-*/
-
-#include <Wire.h> //Needed for I2C to GNSS
-
-#include <SparkFun_u-blox_GNSS_Arduino_Library.h> //http://librarymanager/All#SparkFun_u-blox_GNSS
-SFE_UBLOX_GNSS myGNSS;
-
-long lastTime = 0; //Simple local timer. Limits amount if I2C traffic to u-blox module.
-
-void setup()
-{
-  Serial.begin(115200);
-  while (!Serial); //Wait for user to open terminal
-  Serial.println("SparkFun u-blox Example");
-
-  Wire.begin();
-
-  if (myGNSS.begin() == false) //Connect to the u-blox module using Wire port
-  {
-    Serial.println(F("u-blox GNSS not detected at default I2C address. Please check wiring. Freezing."));
-    while (1);
-  }
-}
-
-void loop()
-{
-  //Query module only every second. Doing it more often will just cause I2C traffic.
-  //The module only responds when a new position is available
-  if (millis() - lastTime > 1000)
-  {
-    lastTime = millis(); //Update the timer
-    
-    long latitude = myGNSS.getLatitude();
-    Serial.print(F("Lat: "));
-    Serial.print(latitude);
-
-    long longitude = myGNSS.getLongitude();
-    Serial.print(F(" Long: "));
-    Serial.print(longitude);
-
-    long speed = myGNSS.getGroundSpeed();
-    Serial.print(F(" Speed: "));
-    Serial.print(speed);
-    Serial.print(F(" (mm/s)"));
-
-    long heading = myGNSS.getHeading();
-    Serial.print(F(" Heading: "));
-    Serial.print(heading);
-    Serial.print(F(" (degrees * 10^-5)"));
-
-    int pDOP = myGNSS.getPDOP();
-    Serial.print(F(" pDOP: "));
-    Serial.print(pDOP / 100.0, 2); // Convert pDOP scaling from 0.01 to 1
-
-    Serial.println();
-  }
-}
diff --git a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Example6_EnableNMEASentences/Example6_EnableNMEASentences.ino b/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Example6_EnableNMEASentences/Example6_EnableNMEASentences.ino
deleted file mode 100644
index ca1b462..0000000
--- a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Example6_EnableNMEASentences/Example6_EnableNMEASentences.ino
+++ /dev/null
@@ -1,79 +0,0 @@
-/*
-  Turn on/off various NMEA sentences.
-  By: Nathan Seidle
-  SparkFun Electronics
-  Date: January 3rd, 2019
-  License: MIT. See license file for more information but you can
-  basically do whatever you want with this code.
-
-  This example shows how to turn on/off the NMEA sentences being output
-  over UART1. We use the I2C interface on the u-blox module for configuration
-  but you won't see any output from this sketch. You'll need to hook up
-  a Serial Basic or other USB to Serial device to UART1 on your u-blox module
-  to see the output.
-
-  This example turns off all sentences except for the GPGGA and GPVTG sentences.
-
-  Feel like supporting open source hardware?
-  Buy a board from SparkFun!
-  ZED-F9P RTK2: https://www.sparkfun.com/products/15136
-  NEO-M8P RTK: https://www.sparkfun.com/products/15005
-  SAM-M8Q: https://www.sparkfun.com/products/15106
-
-  Hardware Connections:
-  Plug a Qwiic cable into the GNSS and a RedBoard
-  If you don't have a platform with a Qwiic connection use the SparkFun Qwiic Breadboard Jumper (https://www.sparkfun.com/products/14425)
-  Open the serial monitor at 115200 baud to see the output
-  Hookup a Serial Basic (https://www.sparkfun.com/products/15096) to UART1 on the u-blox module. Open a terminal at 57600bps
-  and see GPGGA and GPVTG sentences.
-*/
-#include <Wire.h> //Needed for I2C to GNSS
-
-#include <SparkFun_u-blox_GNSS_Arduino_Library.h> //Click here to get the library: http://librarymanager/All#SparkFun_u-blox_GNSS
-SFE_UBLOX_GNSS myGNSS;
-
-unsigned long lastGNSSsend = 0;
-
-void setup()
-{
-  Serial.begin(115200); // Serial debug output over USB visible from Arduino IDE
-  Serial.println("Example showing how to enable/disable certain NMEA sentences");
-
-  Wire.begin();
-
-  if (myGNSS.begin() == false)
-  {
-    Serial.println(F("u-blox GNSS not detected at default I2C address. Please check wiring. Freezing."));
-    while (1)
-      ;
-  }
-
-  //Disable or enable various NMEA sentences over the UART1 interface
-  myGNSS.disableNMEAMessage(UBX_NMEA_GLL, COM_PORT_UART1); //Several of these are on by default on ublox board so let's disable them
-  myGNSS.disableNMEAMessage(UBX_NMEA_GSA, COM_PORT_UART1);
-  myGNSS.disableNMEAMessage(UBX_NMEA_GSV, COM_PORT_UART1);
-  myGNSS.disableNMEAMessage(UBX_NMEA_RMC, COM_PORT_UART1);
-  myGNSS.enableNMEAMessage(UBX_NMEA_GGA, COM_PORT_UART1); //Only leaving GGA & VTG enabled at current navigation rate
-  myGNSS.enableNMEAMessage(UBX_NMEA_VTG, COM_PORT_UART1);
-
-  //Here's the advanced configure method
-  //Some of the other examples in this library enable the PVT message so let's disable it
-  myGNSS.configureMessage(UBX_CLASS_NAV, UBX_NAV_PVT, COM_PORT_UART1, 0); //Message Class, ID, and port we want to configure, sendRate of 0 (disable).
-
-  myGNSS.setUART1Output(COM_TYPE_NMEA); //Turn off UBX and RTCM sentences on the UART1 interface
-
-  myGNSS.setSerialRate(57600); //Set UART1 to 57600bps.
-
-  //myGNSS.saveConfiguration(); //Optional: Save these settings to NVM
-
-  Serial.println(F("Messages configured. NMEA now being output over the UART1 port on the u-blox module at 57600bps."));
-}
-
-void loop()
-{
-  if (millis() - lastGNSSsend > 200)
-  {
-    myGNSS.checkUblox(); //See if new data is available, but we don't want to get NMEA here. Go check UART1.
-    lastGNSSsend = millis();
-  }
-}
diff --git a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Example7_OutputRate/Example7_OutputRate.ino b/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Example7_OutputRate/Example7_OutputRate.ino
deleted file mode 100644
index 18efc58..0000000
--- a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Example7_OutputRate/Example7_OutputRate.ino
+++ /dev/null
@@ -1,94 +0,0 @@
-/*
-  Set update rate to 10Hz
-  By: Nathan Seidle
-  SparkFun Electronics
-  Date: January 3rd, 2019
-  License: MIT. See license file for more information but you can
-  basically do whatever you want with this code.
-
-  This example shows how to increase the output of the module from 1Hz to 4Hz.
-  The max output rate various from model to model. RTFM! But you cannot do harm
-  to the module.
-
-  We also disable NMEA output on the I2C bus and use only UBX. This dramatically 
-  decreases the amount of data that needs to be transmitted.
-
-  Leave NMEA parsing behind. Now you can simply ask the module for the datums you want!
-
-  Feel like supporting open source hardware?
-  Buy a board from SparkFun!
-  ZED-F9P RTK2: https://www.sparkfun.com/products/15136
-  NEO-M8P RTK: https://www.sparkfun.com/products/15005
-  SAM-M8Q: https://www.sparkfun.com/products/15106
-
-  Hardware Connections:
-  Plug a Qwiic cable into the GNSS and a BlackBoard
-  If you don't have a platform with a Qwiic connection use the SparkFun Qwiic Breadboard Jumper (https://www.sparkfun.com/products/14425)
-  Open the serial monitor at 115200 baud to see the output
-*/
-
-#include <Wire.h> //Needed for I2C to GNSS
-
-#include <SparkFun_u-blox_GNSS_Arduino_Library.h> //http://librarymanager/All#SparkFun_u-blox_GNSS
-SFE_UBLOX_GNSS myGNSS;
-
-unsigned long lastTime = 0; //Simple local timer. Limits amount if I2C traffic to u-blox module.
-unsigned long startTime = 0; //Used to calc the actual update rate.
-unsigned long updateCount = 0; //Used to calc the actual update rate.
-
-void setup()
-{
-  Serial.begin(115200);
-  while (!Serial); //Wait for user to open terminal
-  Serial.println("SparkFun u-blox Example");
-
-  Wire.begin();
-
-  // Increase I2C clock speed to 400kHz to cope with the high navigation rate
-  // (We normally recommend running the bus at 100kHz)
-  Wire.setClock(400000);
-  
-  if (myGNSS.begin() == false) //Connect to the u-blox module using Wire port
-  {
-    Serial.println(F("u-blox GNSS not detected at default I2C address. Please check wiring. Freezing."));
-    while (1);
-  }
-
-  myGNSS.setI2COutput(COM_TYPE_UBX); //Set the I2C port to output UBX only (turn off NMEA noise)
-  myGNSS.setNavigationFrequency(5); //Set output to 5 times a second
-
-  uint8_t rate = myGNSS.getNavigationFrequency(); //Get the update rate of this module
-  Serial.print("Current update rate: ");
-  Serial.println(rate);
-
-  startTime = millis();
-}
-
-void loop()
-{
-  //Query module every 25 ms. Doing it more often will just cause I2C traffic.
-  //The module only responds when a new position is available. This is defined
-  //by the update freq.
-  if (millis() - lastTime > 25)
-  {
-    lastTime = millis(); //Update the timer
-    
-    long latitude = myGNSS.getLatitude();
-    Serial.print(F("Lat: "));
-    Serial.print(latitude);
-
-    long longitude = myGNSS.getLongitude();
-    Serial.print(F(" Long: "));
-    Serial.print(longitude);
-
-    updateCount++;
-
-    //Calculate the actual update rate based on the sketch start time and the 
-    //number of updates we've received.
-    Serial.print(F(" Rate: "));
-    Serial.print( updateCount / ((millis() - startTime) / 1000.0), 2);
-    Serial.print(F("Hz"));
-
-    Serial.println();
-  }
-}
diff --git a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Example8_GetProtocolVersion/Example8_GetProtocolVersion.ino b/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Example8_GetProtocolVersion/Example8_GetProtocolVersion.ino
deleted file mode 100644
index f7ed3e0..0000000
--- a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Example8_GetProtocolVersion/Example8_GetProtocolVersion.ino
+++ /dev/null
@@ -1,61 +0,0 @@
-/*
-  Reading the protocol version of a u-blox module
-  By: Nathan Seidle
-  SparkFun Electronics
-  Date: January 3rd, 2019
-  License: MIT. See license file for more information but you can
-  basically do whatever you want with this code.
-
-  This example shows how to query a u-blox module for its protocol version.
-
-  Various modules have various protocol version. We've seen v18 up to v27. Depending
-  on the protocol version there are different commands available. This is a handy
-  way to predict which commands will or won't work.
-
-  Leave NMEA parsing behind. Now you can simply ask the module for the datums you want!
-
-  Feel like supporting open source hardware?
-  Buy a board from SparkFun!
-  ZED-F9P RTK2: https://www.sparkfun.com/products/15136
-  NEO-M8P RTK: https://www.sparkfun.com/products/15005
-  SAM-M8Q: https://www.sparkfun.com/products/15106
-
-  Hardware Connections:
-  Plug a Qwiic cable into the GNSS and a BlackBoard
-  If you don't have a platform with a Qwiic connection use the SparkFun Qwiic Breadboard Jumper (https://www.sparkfun.com/products/14425)
-  Open the serial monitor at 115200 baud to see the output
-*/
-
-#include <Wire.h> //Needed for I2C to GNSS
-
-#include <SparkFun_u-blox_GNSS_Arduino_Library.h> //http://librarymanager/All#SparkFun_u-blox_GNSS
-SFE_UBLOX_GNSS myGNSS;
-
-long lastTime = 0; //Simple local timer. Limits amount if I2C traffic to u-blox module.
-
-void setup()
-{
-  Serial.begin(115200);
-  while (!Serial); //Wait for user to open terminal
-  Serial.println("SparkFun u-blox Example");
-
-  Wire.begin();
-
-  if (myGNSS.begin() == false) //Connect to the u-blox module using Wire port
-  {
-    Serial.println(F("u-blox GNSS not detected at default I2C address. Please check wiring. Freezing."));
-    while (1);
-  }
-
-  Serial.print(F("Version: "));
-  byte versionHigh = myGNSS.getProtocolVersionHigh();
-  Serial.print(versionHigh);
-  Serial.print(".");
-  byte versionLow = myGNSS.getProtocolVersionLow();
-  Serial.print(versionLow);
-}
-
-void loop()
-{
-  //Do nothing
-}
diff --git a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Example8_GetProtocolVersion_Serial/Example8_GetProtocolVersion_Serial.ino b/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Example8_GetProtocolVersion_Serial/Example8_GetProtocolVersion_Serial.ino
deleted file mode 100644
index 0f9ad28..0000000
--- a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Example8_GetProtocolVersion_Serial/Example8_GetProtocolVersion_Serial.ino
+++ /dev/null
@@ -1,81 +0,0 @@
-/*
-  Reading the protocol version of a u-blox module
-  By: Nathan Seidle
-  SparkFun Electronics
-  Date: January 3rd, 2019
-  License: MIT. See license file for more information but you can
-  basically do whatever you want with this code.
-
-  This example shows how to query a u-blox module for its protocol version.
-
-  Note: this may fail on boards like the UNO (ATmega328P) with modules like the ZED-F9P
-        because getProtocolVersion returns a lot of data - more than the UNO's serial buffer can hold
-
-  Various modules have various protocol version. We've seen v18 up to v27. Depending
-  on the protocol version there are different commands available. This is a handy
-  way to predict which commands will or won't work.
-
-  Leave NMEA parsing behind. Now you can simply ask the module for the datums you want!
-
-  Feel like supporting open source hardware?
-  Buy a board from SparkFun!
-  ZED-F9P RTK2: https://www.sparkfun.com/products/15136
-  NEO-M8P RTK: https://www.sparkfun.com/products/15005
-  SAM-M8Q: https://www.sparkfun.com/products/15106
-
-  Hardware Connections:
-  Plug a Qwiic cable into the GNSS and a BlackBoard
-  If you don't have a platform with a Qwiic connection use the SparkFun Qwiic Breadboard Jumper (https://www.sparkfun.com/products/14425)
-  Open the serial monitor at 115200 baud to see the output
-*/
-
-#include <SoftwareSerial.h>
-
-#define mySerial Serial1 // Uncomment this line to connect via Serial1
-// - or -
-//SoftwareSerial mySerial(10, 11); // Uncomment this line to connect via SoftwareSerial(RX, TX). Connect pin 10 to GNSS TX pin.
-
-#include <SparkFun_u-blox_GNSS_Arduino_Library.h> //http://librarymanager/All#SparkFun_u-blox_GNSS
-SFE_UBLOX_GNSS myGNSS;
-
-long lastTime = 0; //Simple local timer. Limits amount if I2C traffic to u-blox module.
-
-void setup()
-{
-  Serial.begin(115200);
-  while (!Serial); //Wait for user to open terminal
-  Serial.println("SparkFun u-blox Example");
-
-  Serial.println("Trying 38400 baud");
-  mySerial.begin(38400);
-  if (myGNSS.begin(mySerial))
-  {
-    Serial.println("GNSS connected at 38400 baud");
-  }
-  else
-  {
-    Serial.println("Trying 9600 baud");
-    mySerial.begin(9600);
-    if (myGNSS.begin(mySerial))
-    {
-      Serial.println("GNSS connected at 9600 baud");
-    }
-    else
-    {
-      Serial.println("Could not connect to GNSS. Freezing...");
-      while(1); // Do nothing more
-    }
-  }
-
-  Serial.print(F("Version: "));
-  byte versionHigh = myGNSS.getProtocolVersionHigh();
-  Serial.print(versionHigh);
-  Serial.print(".");
-  byte versionLow = myGNSS.getProtocolVersionLow();
-  Serial.print(versionLow);
-}
-
-void loop()
-{
-  //Do nothing
-}
diff --git a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Example9_ChangeI2CAddress/Example9_ChangeI2CAddress.ino b/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Example9_ChangeI2CAddress/Example9_ChangeI2CAddress.ino
deleted file mode 100644
index 9a5b061..0000000
--- a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/Example9_ChangeI2CAddress/Example9_ChangeI2CAddress.ino
+++ /dev/null
@@ -1,116 +0,0 @@
-/*
-  Change the I2C address of a u-blox module using I2C
-  By: Nathan Seidle
-  SparkFun Electronics
-  Date: January 3rd, 2019
-  License: MIT. See license file for more information but you can
-  basically do whatever you want with this code.
-
-  This example shows how to change the I2C address of a u-blox module
-
-  Feel like supporting open source hardware?
-  Buy a board from SparkFun!
-  ZED-F9P RTK2: https://www.sparkfun.com/products/15136
-  NEO-M8P RTK: https://www.sparkfun.com/products/15005
-  SAM-M8Q: https://www.sparkfun.com/products/15106
-
-  Hardware Connections:
-  Plug a Qwiic cable into the GNSS and a BlackBoard
-  If you don't have a platform with a Qwiic connection use the SparkFun Qwiic Breadboard Jumper (https://www.sparkfun.com/products/14425)
-  Open the serial monitor at 115200 baud to see the output
-*/
-
-#include <Wire.h> //Needed for I2C to GNSS
-
-#include <SparkFun_u-blox_GNSS_Arduino_Library.h> //http://librarymanager/All#SparkFun_u-blox_GNSS
-SFE_UBLOX_GNSS myGNSS;
-
-long lastTime = 0; //Tracks the passing of 2000ms (2 seconds)
-
-void setup()
-{
-  Serial.begin(115200);
-  while (!Serial); //Wait for user to open terminal
-  Serial.println("SparkFun u-blox Example");
-
-  Wire.begin();
-
-  byte oldAddress = 0x42; //The default address for u-blox modules is 0x42
-  byte newAddress = 0x3F; //Address you want to change to. Valid is 0x08 to 0x77.
-
-  while (Serial.available()) Serial.read(); //Trash any incoming chars
-  Serial.print("Press a key to change address to 0x");
-  Serial.println(newAddress, HEX);
-  while (Serial.available() == false) ; //Wait for user to send character
-
-  //myGNSS.enableDebugging(); // Uncomment this line to enable helpful debug messages on Serial
-  
-  if (myGNSS.begin(Wire, oldAddress) == true) //Connect to the u-blox module using Wire port and the old address
-  {
-    Serial.print("GNSS found at address 0x");
-    Serial.println(oldAddress, HEX);
-
-    myGNSS.setI2CAddress(newAddress); //Change I2C address of this device
-    //Device's I2C address is stored to memory and loaded on each power-on
-
-    delay(2000); // Allow time for the change to take
-
-    if (myGNSS.begin(Wire, newAddress) == true)
-    {
-      myGNSS.saveConfiguration(); //Save the current settings to flash and BBR
-      
-      Serial.print("Address successfully changed to 0x");
-      Serial.println(newAddress, HEX);
-      Serial.print("Now load another example sketch using .begin(Wire, 0x");
-      Serial.print(newAddress, HEX);
-      Serial.println(") to use this GPS module");
-      Serial.println("Freezing...");
-      while (1);
-    }
-  }
-
-  //Something went wrong, begin looking for the I2C device
-  Serial.println("Address change probably failed. Beginning an I2C scan.");
-
-  Wire.begin();
-}
-
-void loop() {
-
-  byte address;
-  int nDevices;
-
-  Serial.println("Scanning...");
-
-  nDevices = 0;
-  for (address = 1; address < 127; address++ )
-  {
-    Wire.beginTransmission(address);
-    byte error = Wire.endTransmission();
-
-    if (error == 0)
-    {
-      Serial.print("I2C device found at address 0x");
-      if (address < 16)
-        Serial.print("0");
-      Serial.print(address, HEX);
-      Serial.println("  !");
-
-      nDevices++;
-    }
-//    else if (error == 4)
-//    {
-//      Serial.print("Unknown error at address 0x");
-//      if (address < 16)
-//        Serial.print("0");
-//      Serial.println(address, HEX);
-//    }
-  }
-
-  if (nDevices == 0)
-    Serial.println("No I2C devices found\n");
-  else
-    Serial.println("done\n");
-
-  delay(5000);           // wait 5 seconds for next scan
-}
diff --git a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/NEO-M8P-2/Example1_EnableRTCM/Example1_EnableRTCM.ino b/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/NEO-M8P-2/Example1_EnableRTCM/Example1_EnableRTCM.ino
deleted file mode 100644
index 6addf88..0000000
--- a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/NEO-M8P-2/Example1_EnableRTCM/Example1_EnableRTCM.ino
+++ /dev/null
@@ -1,77 +0,0 @@
-/*
-  Send UBX binary commands to enable RTCM sentences on u-blox NEO-M8P module
-  By: Nathan Seidle
-  SparkFun Electronics
-  Date: September 7th, 2018
-  License: MIT. See license file for more information but you can
-  basically do whatever you want with this code.
-
-  This example sends the command to enable the four RTCM messages needed for RTK. This 
-  is the first part of a larger tutorial and example to setup an RTK base station.
-  These commands are only accepted by the NEO-M8P module.
- 
-  Feel like supporting open source hardware?
-  Buy a board from SparkFun!
-  ZED-F9P RTK2: https://www.sparkfun.com/products/15136
-  NEO-M8P RTK: https://www.sparkfun.com/products/15005
-  SAM-M8Q: https://www.sparkfun.com/products/15106
-
-  Hardware Connections:
-  Plug a Qwiic cable into the GNSS and a BlackBoard
-  If you don't have a platform with a Qwiic connection use the SparkFun Qwiic Breadboard Jumper (https://www.sparkfun.com/products/14425)
-  Open the serial monitor at 115200 baud to see the output
-*/
-
-#include <Wire.h> //Needed for I2C to GNSS
-
-#include <SparkFun_u-blox_GNSS_Arduino_Library.h> //http://librarymanager/All#SparkFun_u-blox_GNSS
-SFE_UBLOX_GNSS myGNSS;
-
-void setup()
-{
-  Serial.begin(115200);
-  while(!Serial); //Wait for user to open terminal
-  Serial.println(F("u-blox RTCM Enable Example"));
-
-  Wire.begin();
-  Wire.setClock(400000); //Increase I2C clock speed to 400kHz
-
-  if (myGNSS.begin() == false) //Connect to the u-blox module using Wire port
-  {
-    Serial.println(F("u-blox GNSS not detected at default I2C address. Please check wiring. Freezing."));
-    while (1);
-  }
-
-  while(Serial.available()) Serial.read(); //Clear any latent chars in serial buffer
-  Serial.println(F("Press any key to send commands to enable RTCM 3.x"));
-  while(Serial.available() == 0) ; //Wait for user to press a key
-
-  myGNSS.setI2COutput(COM_TYPE_UBX); //Set the I2C port to output UBX only (turn off NMEA noise)
-  myGNSS.saveConfiguration(); //Save the current settings to flash and BBR
-
-  boolean response = true;
-  response &= myGNSS.enableRTCMmessage(UBX_RTCM_1005, COM_PORT_I2C, 1); //Enable message 1005 to output through I2C port, message every second
-  response &= myGNSS.enableRTCMmessage(UBX_RTCM_1077, COM_PORT_I2C, 1);
-  response &= myGNSS.enableRTCMmessage(UBX_RTCM_1087, COM_PORT_I2C, 1);
-  response &= myGNSS.enableRTCMmessage(UBX_RTCM_1230, COM_PORT_I2C, 10); //Enable message every 10 seconds
-
-  if (response == true)
-  {
-    Serial.println(F("RTCM messages enabled"));
-  }
-  else
-  {
-    Serial.println(F("RTCM failed to enable. Are you sure you have an NEO-M8P?"));
-    while(1); //Freeze
-  }
-
-  //RTCM is now enabled but we haven't done a 'survey-in'
-  //See example 4 for the full Base RTK setup
-}
-
-void loop()
-{
-  myGNSS.checkUblox(); //See if new data is available. Process bytes as they come in.
-
-  delay(250); //Don't pound too hard on the I2C bus
-}
diff --git a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/NEO-M8P-2/Example2_StartRTCMBase/Example2_StartRTCMBase.ino b/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/NEO-M8P-2/Example2_StartRTCMBase/Example2_StartRTCMBase.ino
deleted file mode 100644
index 8cf2375..0000000
--- a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/NEO-M8P-2/Example2_StartRTCMBase/Example2_StartRTCMBase.ino
+++ /dev/null
@@ -1,164 +0,0 @@
-/*
-  Note: compiles OK with v2.0 but is currently untested
-  
-  Send UBX binary commands to enable RTCM sentences on u-blox NEO-M8P-2 module
-  By: Nathan Seidle
-  SparkFun Electronics
-  Date: September 7th, 2018
-  License: MIT. See license file for more information but you can
-  basically do whatever you want with this code.
-
-  This example does all steps to configure and enable a NEO-M8P-2 as a base station:
-    Begin Survey-In
-    Once we've achieved 2m accuracy and 300s have passed, survey is complete
-    Enable four RTCM messages
-    Begin outputting RTCM bytes
-
-  Feel like supporting open source hardware?
-  Buy a board from SparkFun!
-  ZED-F9P RTK2: https://www.sparkfun.com/products/15136
-  NEO-M8P RTK: https://www.sparkfun.com/products/15005
-  SAM-M8Q: https://www.sparkfun.com/products/15106
-
-  Hardware Connections:
-  Plug a Qwiic cable into the GNSS and a BlackBoard
-  If you don't have a platform with a Qwiic connection use the SparkFun Qwiic Breadboard Jumper (https://www.sparkfun.com/products/14425)
-  Open the serial monitor at 115200 baud to see the output
-*/
-
-#include <Wire.h> //Needed for I2C to GNSS
-
-#include <SparkFun_u-blox_GNSS_Arduino_Library.h> //http://librarymanager/All#SparkFun_u-blox_GNSS
-SFE_UBLOX_GNSS myGNSS;
-
-void setup()
-{
-  Serial.begin(115200);
-  while (!Serial); //Wait for user to open terminal
-  Serial.println(F("u-blox NEO-M8P-2 base station example"));
-
-  Wire.begin();
-  Wire.setClock(400000); //Increase I2C clock speed to 400kHz
-
-  if (myGNSS.begin() == false) //Connect to the u-blox module using Wire port
-  {
-    Serial.println(F("u-blox GNSS not detected at default I2C address. Please check wiring. Freezing."));
-    while (1);
-  }
-
-  myGNSS.setI2COutput(COM_TYPE_UBX); //Set the I2C port to output UBX only (turn off NMEA noise)
-  myGNSS.saveConfiguration(); //Save the current settings to flash and BBR
-
-  while (Serial.available()) Serial.read(); //Clear any latent chars in serial buffer
-  Serial.println(F("Press any key to send commands to begin Survey-In"));
-  while (Serial.available() == 0) ; //Wait for user to press a key
-
-  boolean response;
-
-  //Check if Survey is in Progress before initiating one
-  // From v2.0, the data from getSurveyStatus (UBX-NAV-SVIN) is returned in UBX_NAV_SVIN_t packetUBXNAVSVIN
-  // Please see u-blox_structs.h for the full definition of UBX_NAV_SVIN_t
-  // You can either read the data from packetUBXNAVSVIN directly
-  // or can use the helper functions: getSurveyInActive; getSurveyInValid; getSurveyInObservationTime; and getSurveyInMeanAccuracy
-  response = myGNSS.getSurveyStatus(2000); //Query module for SVIN status with 2000ms timeout (request can take a long time)
-  
-  if (response == false) // Check if fresh data was received
-  {
-    Serial.println(F("Failed to get Survey In status. Freezing..."));
-    while (1); //Freeze
-  }
-
-  if (myGNSS.getSurveyInActive() == true) // Use the helper function
-  {
-    Serial.print(F("Survey already in progress."));
-  }
-  else
-  {
-    //Start survey
-    response = myGNSS.enableSurveyMode(300, 2.000); //Enable Survey in, 300 seconds, 2.0m
-    if (response == false)
-    {
-      Serial.println(F("Survey start failed. Freezing..."));
-      while (1);
-    }
-    Serial.println(F("Survey started. This will run until 300s has passed and less than 2m accuracy is achieved."));
-  }
-
-  while(Serial.available()) Serial.read(); //Clear buffer
-  
-  //Begin waiting for survey to complete
-  while (myGNSS.getSurveyInValid() == false) // Call the helper function
-  {
-    if(Serial.available())
-    {
-      byte incoming = Serial.read();
-      if(incoming == 'x')
-      {
-        //Stop survey mode
-        response = myGNSS.disableSurveyMode(); //Disable survey
-        Serial.println(F("Survey stopped"));
-        break;
-      }
-    }
-    
-    // From v2.0, the data from getSurveyStatus (UBX-NAV-SVIN) is returned in UBX_NAV_SVIN_t packetUBXNAVSVIN
-    // Please see u-blox_structs.h for the full definition of UBX_NAV_SVIN_t
-    // You can either read the data from packetUBXNAVSVIN directly
-    // or can use the helper functions: getSurveyInActive; getSurveyInValid; getSurveyInObservationTime; and getSurveyInMeanAccuracy
-    response = myGNSS.getSurveyStatus(2000); //Query module for SVIN status with 2000ms timeout (req can take a long time)
-    if (response == true) // Check if fresh data was received
-    {
-      Serial.print(F("Press x to end survey - "));
-      Serial.print(F("Time elapsed: "));
-      Serial.print((String)myGNSS.getSurveyInObservationTime());
-
-      Serial.print(F(" Accuracy: "));
-      Serial.print((String)myGNSS.getSurveyInMeanAccuracy());
-      Serial.println();
-    }
-    else
-    {
-      Serial.println(F("SVIN request failed"));
-    }
-
-    delay(1000);
-  }
-  Serial.println(F("Survey valid!"));
-
-  response = true;
-  response &= myGNSS.enableRTCMmessage(UBX_RTCM_1005, COM_PORT_I2C, 1); //Enable message 1005 to output through I2C port, message every second
-  response &= myGNSS.enableRTCMmessage(UBX_RTCM_1077, COM_PORT_I2C, 1);
-  response &= myGNSS.enableRTCMmessage(UBX_RTCM_1087, COM_PORT_I2C, 1);
-  response &= myGNSS.enableRTCMmessage(UBX_RTCM_1230, COM_PORT_I2C, 10); //Enable message every 10 seconds
-
-  if (response == true)
-  {
-    Serial.println(F("RTCM messages enabled"));
-  }
-  else
-  {
-    Serial.println(F("RTCM failed to enable. Are you sure you have an NEO-M8P?"));
-    while (1); //Freeze
-  }
-
-  Serial.println(F("Base survey complete! RTCM now broadcasting."));
-}
-
-void loop()
-{
-  myGNSS.checkUblox(); //See if new data is available. Process bytes as they come in.
-
-  delay(250); //Don't pound too hard on the I2C bus
-}
-
-//This function gets called from the SparkFun u-blox Arduino Library.
-//As each RTCM byte comes in you can specify what to do with it
-//Useful for passing the RTCM correction data to a radio, Ntrip broadcaster, etc.
-void SFE_UBLOX_GNSS::processRTCM(uint8_t incoming)
-{
-  //Let's just pretty-print the HEX values for now
-  if (myGNSS.rtcmFrameCounter % 16 == 0) Serial.println();
-  Serial.print(F(" "));
-  if (incoming < 0x10) Serial.print(F("0"));
-  Serial.print(incoming, HEX);
-}
diff --git a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/NEO-M8P-2/Example3_BaseWithLCD/Example3_BaseWithLCD.ino b/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/NEO-M8P-2/Example3_BaseWithLCD/Example3_BaseWithLCD.ino
deleted file mode 100644
index d39f2b9..0000000
--- a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/NEO-M8P-2/Example3_BaseWithLCD/Example3_BaseWithLCD.ino
+++ /dev/null
@@ -1,195 +0,0 @@
-/*
-  Note: compiles OK with v2.0 but is currently untested
-  
-  Send UBX binary commands to enable RTCM sentences on u-blox NEO-M8P-2 module
-  By: Nathan Seidle
-  SparkFun Electronics
-  Date: September 7th, 2018
-  License: MIT. See license file for more information but you can
-  basically do whatever you want with this code.
-
-  This example does all steps to configure and enable a NEO-M8P-2 as a base station:
-    Begin Survey-In
-    Once we've achieved 2m accuracy and 300s have passed, survey is complete
-    Enable four RTCM messages
-    Begin outputting RTCM bytes
-
-  Feel like supporting open source hardware?
-  Buy a board from SparkFun!
-  ZED-F9P RTK2: https://www.sparkfun.com/products/15136
-  NEO-M8P RTK: https://www.sparkfun.com/products/15005
-  SAM-M8Q: https://www.sparkfun.com/products/15106
-
-  Hardware Connections:
-  Plug a Qwiic cable into the GNSS and a BlackBoard
-  Plug a SerLCD onto the Qwiic bus
-  If you don't have a platform with a Qwiic connection use the SparkFun Qwiic Breadboard Jumper (https://www.sparkfun.com/products/14425)
-  Watch the output on the LCD or open the serial monitor at 115200 baud to see the output
-*/
-
-#define STAT_LED 13
-
-#include <Wire.h> //Needed for I2C to GNSS
-
-#include <SparkFun_u-blox_GNSS_Arduino_Library.h> //Click here to get the library: http://librarymanager/All#SparkFun_u-blox_GNSS
-SFE_UBLOX_GNSS myGNSS;
-
-#include <SerLCD.h> //Click here to get the library: http://librarymanager/All#SparkFun_SerLCD
-SerLCD lcd; // Initialize the library with default I2C address 0x72
-
-void setup()
-{
-  Serial.begin(115200);
-  while (!Serial); //Wait for user to open terminal
-  Serial.println(F("u-blox GNSS I2C Test"));
-
-  Wire.begin();
-
-  pinMode(STAT_LED, OUTPUT);
-  digitalWrite(STAT_LED, LOW);
-
-  lcd.begin(Wire); //Set up the LCD for Serial communication at 9600bps
-  lcd.setBacklight(0x4B0082); //indigo, a kind of dark purplish blue
-  lcd.clear();
-  lcd.print(F("LCD Ready"));
-
-  myGNSS.begin(Wire);
-  if (myGNSS.isConnected() == false)
-  {
-    Serial.println(F("u-blox GNSS not detected at default I2C address. Please check wiring. Freezing."));
-    lcd.setCursor(0, 1);
-    lcd.print(F("No GNSS detected"));
-    while (1);
-  }
-
-  Wire.setClock(400000); //Increase I2C clock speed to 400kHz
-
-  lcd.setCursor(0, 1);
-  lcd.print("GNSS Detected");
-
-  //Check if Survey is in Progress before initiating one
-  // From v2.0, the data from getSurveyStatus (UBX-NAV-SVIN) is returned in UBX_NAV_SVIN_t packetUBXNAVSVIN
-  // Please see u-blox_structs.h for the full definition of UBX_NAV_SVIN_t
-  // You can either read the data from packetUBXNAVSVIN directly
-  // or can use the helper functions: getSurveyInActive; getSurveyInValid; getSurveyInObservationTime; and getSurveyInMeanAccuracy
-  boolean response;
-  response = myGNSS.getSurveyStatus(2000); //Query module for SVIN status with 2000ms timeout (request can take a long time)
-  if (response == false)
-  {
-    Serial.println(F("Failed to get Survey In status"));
-    while (1); //Freeze
-  }
-
-  if (myGNSS.getSurveyInActive() == true) // Use the helper function
-  {
-    Serial.print(F("Survey already in progress."));
-    lcd.setCursor(0, 2);
-    lcd.print(F("Survey already going"));
-  }
-  else
-  {
-    //Start survey
-    response = myGNSS.enableSurveyMode(300, 2.000); //Enable Survey in, 300 seconds, 2.0m
-    if (response == false)
-    {
-      Serial.println(F("Survey start failed"));
-      lcd.setCursor(0, 3);
-      lcd.print(F("Survey start failed"));
-      while (1);
-    }
-    Serial.println(F("Survey started. This will run until 300s has passed and less than 2m accuracy is achieved."));
-  }
-
-  while (Serial.available()) Serial.read(); //Clear buffer
-
-  lcd.clear();
-  lcd.print(F("Survey in progress"));
-
-  //Begin waiting for survey to complete
-  while (myGNSS.getSurveyInValid() == false) // Call the helper function
-  {
-    if (Serial.available())
-    {
-      byte incoming = Serial.read();
-      if (incoming == 'x')
-      {
-        //Stop survey mode
-        response = myGNSS.disableSurveyMode(); //Disable survey
-        Serial.println(F("Survey stopped"));
-        break;
-      }
-    }
-
-    // From v2.0, the data from getSurveyStatus (UBX-NAV-SVIN) is returned in UBX_NAV_SVIN_t packetUBXNAVSVIN
-    // Please see u-blox_structs.h for the full definition of UBX_NAV_SVIN_t
-    // You can either read the data from packetUBXNAVSVIN directly
-    // or can use the helper functions: getSurveyInActive; getSurveyInValid; getSurveyInObservationTime; and getSurveyInMeanAccuracy
-    response = myGNSS.getSurveyStatus(2000); //Query module for SVIN status with 2000ms timeout (req can take a long time)
-    if (response == true)
-    {
-      Serial.print(F("Press x to end survey - "));
-      Serial.print(F("Time elapsed: "));
-      Serial.print((String)myGNSS.getSurveyInObservationTime());
-
-      lcd.setCursor(0, 1);
-      lcd.print(F("Elapsed: "));
-      lcd.print((String)myGNSS.getSurveyInObservationTime());
-
-      Serial.print(F(" Accuracy: "));
-      Serial.print((String)myGNSS.getSurveyInMeanAccuracy());
-      Serial.println();
-
-      lcd.setCursor(0, 2);
-      lcd.print(F("Accuracy: "));
-      lcd.print((String)myGNSS.getSurveyInMeanAccuracy());
-    }
-    else
-    {
-      Serial.println(F("SVIN request failed"));
-    }
-
-    delay(1000);
-  }
-  Serial.println(F("Survey valid!"));
-
-  response = true;
-  response &= myGNSS.enableRTCMmessage(UBX_RTCM_1005, COM_PORT_I2C, 1); //Enable message 1005 to output through I2C port, message every second
-  response &= myGNSS.enableRTCMmessage(UBX_RTCM_1077, COM_PORT_I2C, 1);
-  response &= myGNSS.enableRTCMmessage(UBX_RTCM_1087, COM_PORT_I2C, 1);
-  response &= myGNSS.enableRTCMmessage(UBX_RTCM_1230, COM_PORT_I2C, 10); //Enable message every 10 seconds
-
-  if (response == true)
-  {
-    Serial.println(F("RTCM messages enabled"));
-  }
-  else
-  {
-    Serial.println(F("RTCM failed to enable. Are you sure you have an NEO-M8P?"));
-    while (1); //Freeze
-  }
-
-  Serial.println(F("Base survey complete! RTCM now broadcasting."));
-  lcd.clear();
-  lcd.print(F("Transmitting RTCM"));
-}
-
-void loop()
-{
-  myGNSS.checkUblox(); //See if new data is available. Process bytes as they come in.
-
-  //Do anything you want. Call checkUblox() every second. NEO-M8P-2 has TX buffer of 4k bytes.
-  
-  delay(250); //Don't pound too hard on the I2C bus
-}
-
-//This function gets called from the SparkFun u-blox Arduino Library.
-//As each RTCM byte comes in you can specify what to do with it
-//Useful for passing the RTCM correction data to a radio, Ntrip broadcaster, etc.
-void SFE_UBLOX_GNSS::processRTCM(uint8_t incoming)
-{
-  //Let's just pretty-print the HEX values for now
-  if (myGNSS.rtcmFrameCounter % 16 == 0) Serial.println();
-  Serial.print(" ");
-  if (incoming < 0x10) Serial.print("0");
-  Serial.print(incoming, HEX);
-}
diff --git a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/ZED-F9P/Example10_GetHighPrecisionPositionAndAccuracy/Example10_GetHighPrecisionPositionAndAccuracy.ino b/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/ZED-F9P/Example10_GetHighPrecisionPositionAndAccuracy/Example10_GetHighPrecisionPositionAndAccuracy.ino
deleted file mode 100644
index 0496d5c..0000000
--- a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/ZED-F9P/Example10_GetHighPrecisionPositionAndAccuracy/Example10_GetHighPrecisionPositionAndAccuracy.ino
+++ /dev/null
@@ -1,172 +0,0 @@
-/*
-  Get the high precision geodetic solution for latitude and longitude
-  By: Nathan Seidle
-  Modified by: Steven Rowland and Paul Clark
-  SparkFun Electronics
-  Date: April 17th, 2020
-  License: MIT. See license file for more information but you can
-  basically do whatever you want with this code.
-
-  This example shows how to inspect the accuracy of the high-precision
-  positional solution. Please see below for information about the units.
-
-  Feel like supporting open source hardware?
-  Buy a board from SparkFun!
-  ZED-F9P RTK2: https://www.sparkfun.com/products/15136
-  NEO-M8P RTK: https://www.sparkfun.com/products/15005
-
-  Hardware Connections:
-  Plug a Qwiic cable into the GNSS and a BlackBoard
-  If you don't have a platform with a Qwiic connection use the SparkFun Qwiic Breadboard Jumper (https://www.sparkfun.com/products/14425)
-  Open the serial monitor at 115200 baud to see the output
-*/
-
-#include <Wire.h> //Needed for I2C to GNSS
-
-#include <SparkFun_u-blox_GNSS_Arduino_Library.h> //http://librarymanager/All#SparkFun_u-blox_GNSS
-SFE_UBLOX_GNSS myGNSS;
-
-long lastTime = 0; //Simple local timer. Limits amount if I2C traffic to u-blox module.
-
-void setup()
-{
-  Serial.begin(115200);
-  while (!Serial); //Wait for user to open terminal
-
-  Wire.begin();
-
-  //myGNSS.enableDebugging(Serial);
-
-  if (myGNSS.begin(Wire) == false) //Connect to the u-blox module using Wire port
-  {
-    Serial.println(F("u-blox GNSS not detected at default I2C address. Please check wiring. Freezing."));
-    while (1);
-  }
-
-  myGNSS.setI2COutput(COM_TYPE_UBX); //Set the I2C port to output UBX only (turn off NMEA noise)
-  myGNSS.setNavigationFrequency(20); //Set output to 20 times a second
-
-  byte rate = myGNSS.getNavigationFrequency(); //Get the update rate of this module
-  Serial.print("Current update rate: ");
-  Serial.println(rate);
-
-  //myGNSS.saveConfiguration(); //Save the current settings to flash and BBR
-}
-
-void loop()
-{
-  //Query module only every second. Doing it more often will just cause I2C traffic.
-  //The module only responds when a new position is available
-  if (millis() - lastTime > 1000)
-  {
-    lastTime = millis(); //Update the timer
-
-    // getHighResLatitude: returns the latitude from HPPOSLLH as an int32_t in degrees * 10^-7
-    // getHighResLatitudeHp: returns the high resolution component of latitude from HPPOSLLH as an int8_t in degrees * 10^-9
-    // getHighResLongitude: returns the longitude from HPPOSLLH as an int32_t in degrees * 10^-7
-    // getHighResLongitudeHp: returns the high resolution component of longitude from HPPOSLLH as an int8_t in degrees * 10^-9
-    // getElipsoid: returns the height above ellipsoid as an int32_t in mm
-    // getElipsoidHp: returns the high resolution component of the height above ellipsoid as an int8_t in mm * 10^-1
-    // getMeanSeaLevel: returns the height above mean sea level as an int32_t in mm
-    // getMeanSeaLevelHp: returns the high resolution component of the height above mean sea level as an int8_t in mm * 10^-1
-    // getHorizontalAccuracy: returns the horizontal accuracy estimate from HPPOSLLH as an uint32_t in mm * 10^-1
-
-    // If you want to use the high precision latitude and longitude with the full 9 decimal places
-    // you will need to use a 64-bit double - which is not supported on all platforms
-
-    // To allow this example to run on standard platforms, we cheat by converting lat and lon to integer and fractional degrees
-
-    // The high resolution altitudes can be converted into standard 32-bit float
-
-    // First, let's collect the position data
-    int32_t latitude = myGNSS.getHighResLatitude();
-    int8_t latitudeHp = myGNSS.getHighResLatitudeHp();
-    int32_t longitude = myGNSS.getHighResLongitude();
-    int8_t longitudeHp = myGNSS.getHighResLongitudeHp();
-    int32_t ellipsoid = myGNSS.getElipsoid();
-    int8_t ellipsoidHp = myGNSS.getElipsoidHp();
-    int32_t msl = myGNSS.getMeanSeaLevel();
-    int8_t mslHp = myGNSS.getMeanSeaLevelHp();
-    uint32_t accuracy = myGNSS.getHorizontalAccuracy();
-
-    // Defines storage for the lat and lon units integer and fractional parts
-    int32_t lat_int; // Integer part of the latitude in degrees
-    int32_t lat_frac; // Fractional part of the latitude
-    int32_t lon_int; // Integer part of the longitude in degrees
-    int32_t lon_frac; // Fractional part of the longitude
-
-    // Calculate the latitude and longitude integer and fractional parts
-    lat_int = latitude / 10000000; // Convert latitude from degrees * 10^-7 to Degrees
-    lat_frac = latitude - (lat_int * 10000000); // Calculate the fractional part of the latitude
-    lat_frac = (lat_frac * 100) + latitudeHp; // Now add the high resolution component
-    if (lat_frac < 0) // If the fractional part is negative, remove the minus sign
-    {
-      lat_frac = 0 - lat_frac;
-    }
-    lon_int = longitude / 10000000; // Convert latitude from degrees * 10^-7 to Degrees
-    lon_frac = longitude - (lon_int * 10000000); // Calculate the fractional part of the longitude
-    lon_frac = (lon_frac * 100) + longitudeHp; // Now add the high resolution component
-    if (lon_frac < 0) // If the fractional part is negative, remove the minus sign
-    {
-      lon_frac = 0 - lon_frac;
-    }
-
-    // Print the lat and lon
-    Serial.print("Lat (deg): ");
-    Serial.print(lat_int); // Print the integer part of the latitude
-    Serial.print(".");
-    printFractional(lat_frac, 9); // Print the fractional part of the latitude with leading zeros
-    Serial.print(", Lon (deg): ");
-    Serial.print(lon_int); // Print the integer part of the latitude
-    Serial.print(".");
-    printFractional(lon_frac, 9); // Print the fractional part of the latitude with leading zeros
-    Serial.println();
-
-    // Now define float storage for the heights and accuracy
-    float f_ellipsoid;
-    float f_msl;
-    float f_accuracy;
-
-    // Calculate the height above ellipsoid in mm * 10^-1
-    f_ellipsoid = (ellipsoid * 10) + ellipsoidHp;
-    // Now convert to m
-    f_ellipsoid = f_ellipsoid / 10000.0; // Convert from mm * 10^-1 to m
-
-    // Calculate the height above mean sea level in mm * 10^-1
-    f_msl = (msl * 10) + mslHp;
-    // Now convert to m
-    f_msl = f_msl / 10000.0; // Convert from mm * 10^-1 to m
-
-    // Convert the horizontal accuracy (mm * 10^-1) to a float
-    f_accuracy = accuracy;
-    // Now convert to m
-    f_accuracy = f_accuracy / 10000.0; // Convert from mm * 10^-1 to m
-
-    // Finally, do the printing
-    Serial.print("Ellipsoid (m): ");
-    Serial.print(f_ellipsoid, 4); // Print the ellipsoid with 4 decimal places
-
-    Serial.print(", Mean Sea Level(m): ");
-    Serial.print(f_msl, 4); // Print the mean sea level with 4 decimal places
-
-    Serial.print(", Accuracy (m): ");
-    Serial.println(f_accuracy, 4); // Print the accuracy with 4 decimal places
-  }
-}
-
-// Pretty-print the fractional part with leading zeros - without using printf
-// (Only works with positive numbers)
-void printFractional(int32_t fractional, uint8_t places)
-{
-  if (places > 1)
-  {
-    for (uint8_t place = places - 1; place > 0; place--)
-    {
-      if (fractional < pow(10, place))
-      {
-        Serial.print("0");
-      }
-    }
-  }
-  Serial.print(fractional);
-}
diff --git a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/ZED-F9P/Example11_GetHighPrecisionPositionUsingDouble/Example11_GetHighPrecisionPositionUsingDouble.ino b/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/ZED-F9P/Example11_GetHighPrecisionPositionUsingDouble/Example11_GetHighPrecisionPositionUsingDouble.ino
deleted file mode 100644
index bb8eef8..0000000
--- a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/ZED-F9P/Example11_GetHighPrecisionPositionUsingDouble/Example11_GetHighPrecisionPositionUsingDouble.ino
+++ /dev/null
@@ -1,146 +0,0 @@
-/*
-  Get the high precision geodetic solution for latitude and longitude using double
-  By: Nathan Seidle
-  Modified by: Paul Clark (PaulZC)
-  SparkFun Electronics
-  Date: April 17th, 2020
-  License: MIT. See license file for more information but you can
-  basically do whatever you want with this code.
-
-  This example shows how to inspect the accuracy of the high-precision
-  positional solution. Please see below for information about the units.
-
-  ** This example will only work correctly on platforms which support 64-bit double **
-
-  Feel like supporting open source hardware?
-  Buy a board from SparkFun!
-  ZED-F9P RTK2: https://www.sparkfun.com/products/15136
-  NEO-M8P RTK: https://www.sparkfun.com/products/15005
-
-  Hardware Connections:
-  Plug a Qwiic cable into the GNSS and (e.g.) a Redboard Artemis https://www.sparkfun.com/products/15444
-  or an Artemis Thing Plus https://www.sparkfun.com/products/15574
-  If you don't have a platform with a Qwiic connection use the SparkFun Qwiic Breadboard Jumper (https://www.sparkfun.com/products/14425)
-  Open the serial monitor at 115200 baud to see the output
-*/
-
-#include <Wire.h> // Needed for I2C to GNSS
-
-#define myWire Wire // This will work on the Redboard Artemis and the Artemis Thing Plus using Qwiic
-//#define myWire Wire1 // Uncomment this line if you are using the extra SCL1/SDA1 pins (D17 and D16) on the Thing Plus
-
-#include <SparkFun_u-blox_GNSS_Arduino_Library.h> //http://librarymanager/All#SparkFun_u-blox_GNSS
-SFE_UBLOX_GNSS myGNSS;
-
-long lastTime = 0; //Simple local timer. Limits amount if I2C traffic to u-blox module.
-
-void setup()
-{
-  Serial.begin(115200);
-  while (!Serial); //Wait for user to open terminal
-
-  myWire.begin();
-
-  //myGNSS.enableDebugging(Serial); // Uncomment this line to enable debug messages
-
-  if (myGNSS.begin(myWire) == false) //Connect to the u-blox module using Wire port
-  {
-    Serial.println(F("u-blox GNSS not detected at default I2C address. Please check wiring. Freezing."));
-    while (1)
-      ;
-  }
-
-  // Check that this platform supports 64-bit (8 byte) double
-  if (sizeof(double) < 8)
-  {
-    Serial.println(F("Warning! Your platform does not support 64-bit double."));
-    Serial.println(F("The latitude and longitude will be inaccurate."));
-  }
-
-  myGNSS.setI2COutput(COM_TYPE_UBX); //Set the I2C port to output UBX only (turn off NMEA noise)
-
-  //myGNSS.setNavigationFrequency(20); //Set output to 20 times a second
-
-  byte rate = myGNSS.getNavigationFrequency(); //Get the update rate of this module
-  Serial.print("Current update rate: ");
-  Serial.println(rate);
-
-  //myGNSS.saveConfiguration(); //Save the current settings to flash and BBR
-}
-
-void loop()
-{
-  //Query module only every second.
-  //The module only responds when a new position is available.
-  if (millis() - lastTime > 1000)
-  {
-    lastTime = millis(); //Update the timer
-
-    // getHighResLatitude: returns the latitude from HPPOSLLH as an int32_t in degrees * 10^-7
-    // getHighResLatitudeHp: returns the high resolution component of latitude from HPPOSLLH as an int8_t in degrees * 10^-9
-    // getHighResLongitude: returns the longitude from HPPOSLLH as an int32_t in degrees * 10^-7
-    // getHighResLongitudeHp: returns the high resolution component of longitude from HPPOSLLH as an int8_t in degrees * 10^-9
-    // getElipsoid: returns the height above ellipsoid as an int32_t in mm
-    // getElipsoidHp: returns the high resolution component of the height above ellipsoid as an int8_t in mm * 10^-1
-    // getMeanSeaLevel: returns the height above mean sea level as an int32_t in mm
-    // getMeanSeaLevelHp: returns the high resolution component of the height above mean sea level as an int8_t in mm * 10^-1
-    // getHorizontalAccuracy: returns the horizontal accuracy estimate from HPPOSLLH as an uint32_t in mm * 10^-1
-
-    // First, let's collect the position data
-    int32_t latitude = myGNSS.getHighResLatitude();
-    int8_t latitudeHp = myGNSS.getHighResLatitudeHp();
-    int32_t longitude = myGNSS.getHighResLongitude();
-    int8_t longitudeHp = myGNSS.getHighResLongitudeHp();
-    int32_t ellipsoid = myGNSS.getElipsoid();
-    int8_t ellipsoidHp = myGNSS.getElipsoidHp();
-    int32_t msl = myGNSS.getMeanSeaLevel();
-    int8_t mslHp = myGNSS.getMeanSeaLevelHp();
-    uint32_t accuracy = myGNSS.getHorizontalAccuracy();
-
-    // Defines storage for the lat and lon as double
-    double d_lat; // latitude
-    double d_lon; // longitude
-
-    // Assemble the high precision latitude and longitude
-    d_lat = ((double)latitude) / 10000000.0; // Convert latitude from degrees * 10^-7 to degrees
-    d_lat += ((double)latitudeHp) / 1000000000.0; // Now add the high resolution component (degrees * 10^-9 )
-    d_lon = ((double)longitude) / 10000000.0; // Convert longitude from degrees * 10^-7 to degrees
-    d_lon += ((double)longitudeHp) / 1000000000.0; // Now add the high resolution component (degrees * 10^-9 )
-
-   // Print the lat and lon
-    Serial.print("Lat (deg): ");
-    Serial.print(d_lat, 9);
-    Serial.print(", Lon (deg): ");
-    Serial.print(d_lon, 9);
-
-    // Now define float storage for the heights and accuracy
-    float f_ellipsoid;
-    float f_msl;
-    float f_accuracy;
-
-    // Calculate the height above ellipsoid in mm * 10^-1
-    f_ellipsoid = (ellipsoid * 10) + ellipsoidHp;
-    // Now convert to m
-    f_ellipsoid = f_ellipsoid / 10000.0; // Convert from mm * 10^-1 to m
-
-    // Calculate the height above mean sea level in mm * 10^-1
-    f_msl = (msl * 10) + mslHp;
-    // Now convert to m
-    f_msl = f_msl / 10000.0; // Convert from mm * 10^-1 to m
-
-    // Convert the horizontal accuracy (mm * 10^-1) to a float
-    f_accuracy = accuracy;
-    // Now convert to m
-    f_accuracy = f_accuracy / 10000.0; // Convert from mm * 10^-1 to m
-
-    // Finally, do the printing
-    Serial.print(", Ellipsoid (m): ");
-    Serial.print(f_ellipsoid, 4); // Print the ellipsoid with 4 decimal places
-
-    Serial.print(", Mean Sea Level (m): ");
-    Serial.print(f_msl, 4); // Print the mean sea level with 4 decimal places
-
-    Serial.print(", Accuracy (m): ");
-    Serial.println(f_accuracy, 4); // Print the accuracy with 4 decimal places
-  }
-}
diff --git a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/ZED-F9P/Example12_setStaticPosition/Example12_setStaticPosition.ino b/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/ZED-F9P/Example12_setStaticPosition/Example12_setStaticPosition.ino
deleted file mode 100644
index d30ef49..0000000
--- a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/ZED-F9P/Example12_setStaticPosition/Example12_setStaticPosition.ino
+++ /dev/null
@@ -1,77 +0,0 @@
-/*
-  Set the static position of the receiver.
-  By: SparkFun Electronics / Nathan Seidle
-  Date: September 26th, 2020
-  License: MIT. See license file for more information but you can
-  basically do whatever you want with this code.
-
-  This example shows how to set the static position of a receiver
-  using an Earth-Centered, Earth-Fixed (ECEF) location. This is the
-  output from a long (24 hour+) survey-in. Setting the static position
-  immediately causes the receiver to begin outputting RTCM data (if
-  enabled), perfect for setting up your own RTCM NTRIP caster or CORS.
-
-  Feel like supporting open source hardware?
-  Buy a board from SparkFun!
-  ZED-F9P RTK2: https://www.sparkfun.com/products/15136
-  NEO-M8P RTK: https://www.sparkfun.com/products/15005
-
-  Hardware Connections:
-  Plug a Qwiic cable into the GNSS and a BlackBoard
-  If you don't have a platform with a Qwiic connection use the SparkFun Qwiic Breadboard Jumper (https://www.sparkfun.com/products/14425)
-  Open the serial monitor at 115200 baud to see the output
-*/
-
-#include <Wire.h> //Needed for I2C to GNSS
-
-#include <SparkFun_u-blox_GNSS_Arduino_Library.h> //http://librarymanager/All#SparkFun_u-blox_GNSS
-SFE_UBLOX_GNSS myGNSS;
-
-void setup()
-{
-  Serial.begin(115200); // You may need to increase this for high navigation rates!
-  while (!Serial)
-    ; //Wait for user to open terminal
-  Serial.println(F("SparkFun u-blox Example"));
-
-  Wire.begin();
-
-  //myGNSS.enableDebugging(); // Uncomment this line to enable debug messages
-
-  if (myGNSS.begin() == false) //Connect to the u-blox module using Wire port
-  {
-    Serial.println(F("u-blox GNSS not detected at default I2C address. Please check wiring. Freezing."));
-    while (1)
-      ;
-  }
-
-  myGNSS.setI2COutput(COM_TYPE_UBX); //Set the I2C port to output UBX only (turn off NMEA noise)
-
-  boolean success = true;
-
-  //-1280208.308,-4716803.847,4086665.811 is SparkFun HQ so...
-
-  //Units are cm so 1234 = 12.34m
-  //success &= myGNSS.setStaticPosition(-128020831, -471680385, 408666581);
-
-  //Units are cm with a high precision extension so -1234.5678 should be called: (-123456, -78)
-  success &= myGNSS.setStaticPosition(-128020830, -80, -471680384, -70, 408666581, 10); //With high precision 0.1mm parts
-
-  //We can also set via lat/long
-  //40.09029751,-105.18507900,1560.238
-  //success &= myGNSS.setStaticPosition(400902975, -1051850790, 156024, true); //True at end enables lat/long input
-  //success &= myGNSS.setStaticPosition(400902975, 10, -1051850790, 0, 156023, 80, true);
-
-  if (!success) Serial.println(F("At least one call to setStaticPosition failed!"));
-
-  //Now let's use getVals to read back the data
-  //long ecefX = myGNSS.getVal32(0x40030003);
-  //Serial.print("ecefX: ");
-  //Serial.println(ecefX);
-
-  Serial.println(F("Done!"));
-}
-
-void loop()
-{
-}
diff --git a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/ZED-F9P/Example13_autoHPPOSLLH/Example13_autoHPPOSLLH.ino b/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/ZED-F9P/Example13_autoHPPOSLLH/Example13_autoHPPOSLLH.ino
deleted file mode 100644
index ca7d7a2..0000000
--- a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/ZED-F9P/Example13_autoHPPOSLLH/Example13_autoHPPOSLLH.ino
+++ /dev/null
@@ -1,119 +0,0 @@
-/*
-  Configuring the GNSS to automatically send HPPOSLLH position reports over I2C
-  By: Paul Clark
-  Date: October 27th 2020
-
-  Based on an earlier example:
-  By: Nathan Seidle and Thorsten von Eicken
-  SparkFun Electronics
-  Date: January 3rd, 2019
-  License: MIT. See license file for more information but you can
-  basically do whatever you want with this code.
-
-  This example shows how to configure the U-Blox GNSS the send navigation reports automatically
-  and retrieving the latest one via getHPPOSLLH. This eliminates the blocking in getHPPOSLLH while the GNSS
-  produces a fresh navigation solution at the expense of returning a slighly old solution.
-
-  This can be used over serial or over I2C, this example shows the I2C use. With serial the GNSS
-  simply outputs the UBX_NAV_HPPOSLLH packet. With I2C it queues it into its internal I2C buffer (4KB in
-  size?) where it can be retrieved in the next I2C poll.
-
-  Feel like supporting open source hardware?
-  Buy a board from SparkFun!
-  ZED-F9P RTK2: https://www.sparkfun.com/products/15136
-  NEO-M8P RTK: https://www.sparkfun.com/products/15005
-
-  Hardware Connections:
-  Plug a Qwiic cable into the GNSS and a BlackBoard
-  If you don't have a platform with a Qwiic connection use the SparkFun Qwiic Breadboard Jumper (https://www.sparkfun.com/products/14425)
-  Open the serial monitor at 115200 baud to see the output
-*/
-
-#include <Wire.h> //Needed for I2C to GNSS
-
-#include <SparkFun_u-blox_GNSS_Arduino_Library.h> //http://librarymanager/All#SparkFun_u-blox_GNSS
-SFE_UBLOX_GNSS myGNSS;
-
-void setup()
-{
-  Serial.begin(115200);
-  while (!Serial); //Wait for user to open terminal
-  Serial.println("SparkFun u-blox Example");
-
-  Wire.begin();
-
-  //myGNSS.enableDebugging(); // Uncomment this line to enable lots of helpful debug messages
-  //myGNSS.enableDebugging(Serial, true); // Uncomment this line to enable the minimum of helpful debug messages
-
-  if (myGNSS.begin() == false) //Connect to the u-blox module using Wire port
-  {
-    Serial.println(F("u-blox GNSS not detected at default I2C address. Please check wiring. Freezing."));
-    while (1);
-  }
-
-  // Uncomment the next line if you want to reset your module back to the default settings with 1Hz navigation rate
-  //myGNSS.factoryDefault(); delay(5000);
-
-  myGNSS.setI2COutput(COM_TYPE_UBX); //Set the I2C port to output UBX only (turn off NMEA noise)
-  myGNSS.saveConfigSelective(VAL_CFG_SUBSEC_IOPORT); //Save the communications port settings to flash and BBR
-
-  myGNSS.setNavigationFrequency(1); //Produce one solution per second
-
-
-  // The acid test: all four of these combinations should work seamlessly :-)
-
-  //myGNSS.setAutoPVT(false); // Library will poll each reading
-  //myGNSS.setAutoHPPOSLLH(false); // Library will poll each reading
-
-  //myGNSS.setAutoPVT(true); // Tell the GPS to "send" each solution automatically
-  //myGNSS.setAutoHPPOSLLH(false); // Library will poll each reading
-
-  //myGNSS.setAutoPVT(false); // Library will poll each reading
-  //myGNSS.setAutoHPPOSLLH(true); // Tell the GPS to "send" each hi res solution automatically
-
-  myGNSS.setAutoPVT(true); // Tell the GPS to "send" each solution automatically
-  myGNSS.setAutoHPPOSLLH(true); // Tell the GPS to "send" each hi res solution automatically
-}
-
-void loop()
-{
-  // Calling getHPPOSLLH returns true if there actually is a fresh navigation solution available.
-  // Calling getPVT returns true if there actually is a fresh navigation solution available.
-  if ((myGNSS.getHPPOSLLH()) || (myGNSS.getPVT()))
-  {
-    Serial.println();
-
-    long highResLatitude = myGNSS.getHighResLatitude();
-    Serial.print(F("Hi Res Lat: "));
-    Serial.print(highResLatitude);
-
-    int highResLatitudeHp = myGNSS.getHighResLatitudeHp();
-    Serial.print(F(" "));
-    Serial.print(highResLatitudeHp);
-
-    long highResLongitude = myGNSS.getHighResLongitude();
-    Serial.print(F(" Hi Res Long: "));
-    Serial.print(highResLongitude);
-
-    int highResLongitudeHp = myGNSS.getHighResLongitudeHp();
-    Serial.print(F(" "));
-    Serial.print(highResLongitudeHp);
-
-    unsigned long horizAccuracy = myGNSS.getHorizontalAccuracy();
-    Serial.print(F(" Horiz accuracy: "));
-    Serial.print(horizAccuracy);
-
-    long latitude = myGNSS.getLatitude();
-    Serial.print(F(" Lat: "));
-    Serial.print(latitude);
-
-    long longitude = myGNSS.getLongitude();
-    Serial.print(F(" Long: "));
-    Serial.println(longitude);
-  }
-  else
-  {
-    Serial.print(".");
-    delay(50);
-  }
-}
diff --git a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/ZED-F9P/Example13_autoHPPOSLLH_with_Callback/Example13_autoHPPOSLLH_with_Callback.ino b/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/ZED-F9P/Example13_autoHPPOSLLH_with_Callback/Example13_autoHPPOSLLH_with_Callback.ino
deleted file mode 100644
index 94a6e75..0000000
--- a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/ZED-F9P/Example13_autoHPPOSLLH_with_Callback/Example13_autoHPPOSLLH_with_Callback.ino
+++ /dev/null
@@ -1,150 +0,0 @@
-/*
-  Configuring the GNSS to automatically send HPPOSLLH position reports over I2C
-  and uses callbacks to process and display the data automatically
-  By: Paul Clark
-  Date: October 27th 2020
-
-  Based on an earlier example:
-  By: Nathan Seidle and Thorsten von Eicken
-  SparkFun Electronics
-  Date: January 3rd, 2019
-  License: MIT. See license file for more information but you can
-  basically do whatever you want with this code.
-
-  This example shows how to configure the U-Blox GNSS the send navigation reports automatically
-  and and uses callbacks to process and display the data automatically. No more polling!
-
-  This can be used over serial or over I2C, this example shows the I2C use. With serial the GNSS
-  simply outputs the UBX_NAV_HPPOSLLH packet. With I2C it queues it into its internal I2C buffer (4KB in
-  size?) where it can be retrieved in the next I2C poll.
-
-  Feel like supporting open source hardware?
-  Buy a board from SparkFun!
-  ZED-F9P RTK2: https://www.sparkfun.com/products/15136
-  NEO-M8P RTK: https://www.sparkfun.com/products/15005
-
-  Hardware Connections:
-  Plug a Qwiic cable into the GNSS and a BlackBoard
-  If you don't have a platform with a Qwiic connection use the SparkFun Qwiic Breadboard Jumper (https://www.sparkfun.com/products/14425)
-  Open the serial monitor at 115200 baud to see the output
-*/
-
-#include <Wire.h> //Needed for I2C to GNSS
-
-#include <SparkFun_u-blox_GNSS_Arduino_Library.h> //http://librarymanager/All#SparkFun_u-blox_GNSS
-SFE_UBLOX_GNSS myGNSS;
-
-// Callback: printHPdata will be called when new NAV HPPOSLLH data arrives
-// See u-blox_structs.h for the full definition of UBX_NAV_HPPOSLLH_data_t
-//         _____  You can use any name you like for the callback. Use the same name when you call setAutoHPPOSLLHcallback
-//        /                  _____  This _must_ be UBX_NAV_HPPOSLLH_data_t
-//        |                 /                   _____ You can use any name you like for the struct
-//        |                 |                  /
-//        |                 |                  |
-void printHPdata(UBX_NAV_HPPOSLLH_data_t ubxDataStruct)
-{
-  Serial.println();
-
-  long highResLatitude = ubxDataStruct.lat;
-  Serial.print(F("Hi Res Lat: "));
-  Serial.print(highResLatitude);
-
-  int highResLatitudeHp = ubxDataStruct.latHp;
-  Serial.print(F(" "));
-  Serial.print(highResLatitudeHp);
-
-  long highResLongitude = ubxDataStruct.lon;
-  Serial.print(F(" Hi Res Long: "));
-  Serial.print(highResLongitude);
-
-  int highResLongitudeHp = ubxDataStruct.lonHp;
-  Serial.print(F(" "));
-  Serial.print(highResLongitudeHp);
-
-  float horizAccuracy = ((float)ubxDataStruct.hAcc) / 10000.0; // Convert hAcc from mm*0.1 to m
-  Serial.print(F(" Horiz accuracy: "));
-  Serial.println(horizAccuracy);
-}
-
-// Callback: printPVTdata will be called when new NAV PVT data arrives
-// See u-blox_structs.h for the full definition of UBX_NAV_PVT_data_t
-//         _____  You can use any name you like for the callback. Use the same name when you call setAutoPVTcallback
-//        /                  _____  This _must_ be UBX_NAV_PVT_data_t
-//        |                 /                _____ You can use any name you like for the struct
-//        |                 |               /
-//        |                 |               |
-void printPVTdata(UBX_NAV_PVT_data_t ubxDataStruct)
-{
-    Serial.println();
-
-    Serial.print(F("Time: ")); // Print the time
-    uint8_t hms = ubxDataStruct.hour; // Print the hours
-    if (hms < 10) Serial.print(F("0")); // Print a leading zero if required
-    Serial.print(hms);
-    Serial.print(F(":"));
-    hms = ubxDataStruct.min; // Print the minutes
-    if (hms < 10) Serial.print(F("0")); // Print a leading zero if required
-    Serial.print(hms);
-    Serial.print(F(":"));
-    hms = ubxDataStruct.sec; // Print the seconds
-    if (hms < 10) Serial.print(F("0")); // Print a leading zero if required
-    Serial.print(hms);
-    Serial.print(F("."));
-    unsigned long millisecs = ubxDataStruct.iTOW % 1000; // Print the milliseconds
-    if (millisecs < 100) Serial.print(F("0")); // Print the trailing zeros correctly
-    if (millisecs < 10) Serial.print(F("0"));
-    Serial.print(millisecs);
-
-    long latitude = ubxDataStruct.lat; // Print the latitude
-    Serial.print(F(" Lat: "));
-    Serial.print(latitude);
-
-    long longitude = ubxDataStruct.lon; // Print the longitude
-    Serial.print(F(" Long: "));
-    Serial.print(longitude);
-    Serial.print(F(" (degrees * 10^-7)"));
-
-    long altitude = ubxDataStruct.hMSL; // Print the height above mean sea level
-    Serial.print(F(" Height above MSL: "));
-    Serial.print(altitude);
-    Serial.println(F(" (mm)"));
-}
-
-void setup()
-{
-  Serial.begin(115200);
-  while (!Serial); //Wait for user to open terminal
-  Serial.println("SparkFun u-blox Example");
-
-  Wire.begin();
-
-  //myGNSS.enableDebugging(); // Uncomment this line to enable lots of helpful debug messages
-  //myGNSS.enableDebugging(Serial, true); // Uncomment this line to enable the minimum of helpful debug messages
-
-  if (myGNSS.begin() == false) //Connect to the u-blox module using Wire port
-  {
-    Serial.println(F("u-blox GNSS not detected at default I2C address. Please check wiring. Freezing."));
-    while (1);
-  }
-
-  // Uncomment the next line if you want to reset your module back to the default settings with 1Hz navigation rate
-  //myGNSS.factoryDefault(); delay(5000);
-
-  myGNSS.setI2COutput(COM_TYPE_UBX); //Set the I2C port to output UBX only (turn off NMEA noise)
-  myGNSS.saveConfigSelective(VAL_CFG_SUBSEC_IOPORT); //Save the communications port settings to flash and BBR
-
-  myGNSS.setNavigationFrequency(2); //Produce two solutions per second
-
-  myGNSS.setAutoPVTcallback(&printPVTdata); // Enable automatic NAV PVT messages with callback to printPVTdata
-
-  myGNSS.setAutoHPPOSLLHcallback(&printHPdata); // Enable automatic NAV HPPOSLLH messages with callback to printHPdata
-}
-
-void loop()
-{
-  myGNSS.checkUblox(); // Check for the arrival of new data and process it. You could set up a timer interrupt to do this for you.
-  myGNSS.checkCallbacks(); // Check if any callbacks are waiting to be processed.
-
-  Serial.print(".");
-  delay(50);
-}
diff --git a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/ZED-F9P/Example14_NTRIPServer/Example14_NTRIPServer.ino b/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/ZED-F9P/Example14_NTRIPServer/Example14_NTRIPServer.ino
deleted file mode 100644
index ca01530..0000000
--- a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/ZED-F9P/Example14_NTRIPServer/Example14_NTRIPServer.ino
+++ /dev/null
@@ -1,276 +0,0 @@
-/*
-  Note: compiles OK with v2.0 but is currently untested
-  
-  Use ESP32 WiFi to push RTCM data to RTK2Go (caster) as a Server
-  By: SparkFun Electronics / Nathan Seidle
-  Date: December 14th, 2020
-  License: MIT. See license file for more information but you can
-  basically do whatever you want with this code.
-
-  This example shows how to gather RTCM data over I2C and push it to a casting service over WiFi.
-  It's confusing, but the Arduino is acting as a 'server' to a 'caster'. In this case we will
-  use RTK2Go.com as our caster because it is free. A rover (car, surveyor stick, etc) can
-  then connect to RTK2Go as a 'client' and get the RTCM data it needs.
-
-  You will need to register your mountpoint here: http://www.rtk2go.com/new-reservation/
-  (They'll probably block the credentials we include in this example)
-
-  To see if your mountpoint is active go here: http://rtk2go.com:2101/
-
-  This is a proof of concept. Serving RTCM to a caster over WiFi is useful when you need to
-  set up a high-precision base station.
-
-  Feel like supporting open source hardware?
-  Buy a board from SparkFun!
-  ZED-F9P RTK2: https://www.sparkfun.com/products/16481
-  RTK Surveyor: https://www.sparkfun.com/products/17369
-
-  Hardware Connections:
-  Plug a Qwiic cable into the GNSS and a ESP32 Thing Plus
-  If you don't have a platform with a Qwiic connection use the SparkFun Qwiic Breadboard Jumper (https://www.sparkfun.com/products/14425)
-  Open the serial monitor at 115200 baud to see the output
-*/
-
-#include <WiFi.h>
-#include "secrets.h"
-WiFiClient client;
-
-#include <Wire.h> //Needed for I2C to GNSS
-#include <SparkFun_u-blox_GNSS_Arduino_Library.h> //http://librarymanager/All#SparkFun_u-blox_GNSS
-SFE_UBLOX_GNSS myGNSS;
-
-//Basic Connection settings to RTK2Go NTRIP Caster - See secrets for mount specific credentials
-//=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
-const uint16_t casterPort = 2101;
-const char * casterHost = "rtk2go.com";
-const char * ntrip_server_name = "SparkFun_RTK_Surveyor";
-
-long lastSentRTCM_ms = 0; //Time of last data pushed to socket
-int maxTimeBeforeHangup_ms = 10000; //If we fail to get a complete RTCM frame after 10s, then disconnect from caster
-
-uint32_t serverBytesSent = 0; //Just a running total
-//=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
-
-long lastReport_ms = 0; //Time of last report of bytes sent
-
-void setup()
-{
-  Serial.begin(115200); // You may need to increase this for high navigation rates!
-  while (!Serial)
-    ; //Wait for user to open terminal
-  Serial.println(F("SparkFun u-blox Example"));
-
-  Wire.begin();
-
-  //myGNSS.enableDebugging(); // Uncomment this line to enable debug messages
-
-  if (myGNSS.begin() == false) //Connect to the u-blox module using Wire port
-  {
-    Serial.println(F("u-blox GNSS not detected at default I2C address. Please check wiring. Freezing."));
-    while (1)
-      ;
-  }
-
-  Serial.print("Connecting to local WiFi");
-  WiFi.begin(ssid, password);
-  while (WiFi.status() != WL_CONNECTED) {
-    delay(500);
-    Serial.print(".");
-  }
-
-  Serial.print("\nWiFi connected with IP: ");
-  Serial.println(WiFi.localIP());
-
-  myGNSS.setI2COutput(COM_TYPE_UBX | COM_TYPE_NMEA | COM_TYPE_RTCM3); //UBX+RTCM3 is not a valid option so we enable all three.
-
-  myGNSS.setNavigationFrequency(1); //Set output in Hz. RTCM rarely benefits from >1Hz.
-
-  //Disable all NMEA sentences
-  bool response = true;
-  response &= myGNSS.disableNMEAMessage(UBX_NMEA_GGA, COM_PORT_I2C);
-  response &= myGNSS.disableNMEAMessage(UBX_NMEA_GSA, COM_PORT_I2C);
-  response &= myGNSS.disableNMEAMessage(UBX_NMEA_GSV, COM_PORT_I2C);
-  response &= myGNSS.disableNMEAMessage(UBX_NMEA_RMC, COM_PORT_I2C);
-  response &= myGNSS.disableNMEAMessage(UBX_NMEA_GST, COM_PORT_I2C);
-  response &= myGNSS.disableNMEAMessage(UBX_NMEA_GLL, COM_PORT_I2C);
-  response &= myGNSS.disableNMEAMessage(UBX_NMEA_VTG, COM_PORT_I2C);
-
-  if (response == false)
-  {
-    Serial.println(F("Failed to disable NMEA. Freezing..."));
-    while (1);
-  }
-  else
-    Serial.println(F("NMEA disabled"));
-
-  //Enable necessary RTCM sentences
-  response &= myGNSS.enableRTCMmessage(UBX_RTCM_1005, COM_PORT_I2C, 1); //Enable message 1005 to output through UART2, message every second
-  response &= myGNSS.enableRTCMmessage(UBX_RTCM_1074, COM_PORT_I2C, 1);
-  response &= myGNSS.enableRTCMmessage(UBX_RTCM_1084, COM_PORT_I2C, 1);
-  response &= myGNSS.enableRTCMmessage(UBX_RTCM_1094, COM_PORT_I2C, 1);
-  response &= myGNSS.enableRTCMmessage(UBX_RTCM_1124, COM_PORT_I2C, 1);
-  response &= myGNSS.enableRTCMmessage(UBX_RTCM_1230, COM_PORT_I2C, 10); //Enable message every 10 seconds
-
-  if (response == false)
-  {
-    Serial.println(F("Failed to enable RTCM. Freezing..."));
-    while (1);
-  }
-  else
-    Serial.println(F("RTCM sentences enabled"));
-
-  //-1280208.308,-4716803.847,4086665.811 is SparkFun HQ so...
-  //Units are cm with a high precision extension so -1234.5678 should be called: (-123456, -78)
-  //For more infomation see Example12_setStaticPosition
-  //Note: If you leave these coordinates in place and setup your antenna *not* at SparkFun, your receiver
-  //will be very confused and fail to generate correction data because, well, you aren't at SparkFun...
-  //See this tutorial on getting PPP coordinates: https://learn.sparkfun.com/tutorials/how-to-build-a-diy-gnss-reference-station/all
-  response &= myGNSS.setStaticPosition(-128020830, -80, -471680384, -70, 408666581, 10); //With high precision 0.1mm parts
-  if (response == false)
-  {
-    Serial.println(F("Failed to enter static position. Freezing..."));
-    while (1);
-  }
-  else
-    Serial.println(F("Static position set"));
-
-  //You could instead do a survey-in but it takes much longer to start generating RTCM data. See Example4_BaseWithLCD
-  //myGNSS.enableSurveyMode(60, 5.000); //Enable Survey in, 60 seconds, 5.0m
-
-  if (myGNSS.saveConfiguration() == false) //Save the current settings to flash and BBR
-    Serial.println(F("Module failed to save."));
-
-  Serial.println(F("Module configuration complete"));
-}
-
-void loop()
-{
-  if (Serial.available()) beginServing();
-
-  Serial.println(F("Press any key to start serving."));
-
-  delay(1000);
-}
-
-void beginServing()
-{
-  Serial.println("Xmit to RTK2Go. Press any key to stop");
-  delay(10); //Wait for any serial to arrive
-  while (Serial.available()) Serial.read(); //Flush
-
-  while (Serial.available() == 0)
-  {
-    //Connect if we are not already
-    if (client.connected() == false)
-    {
-      Serial.printf("Opening socket to %s\n", casterHost);
-
-      if (client.connect(casterHost, casterPort) == true) //Attempt connection
-      {
-        Serial.printf("Connected to %s:%d\n", casterHost, casterPort);
-
-        const int SERVER_BUFFER_SIZE  = 512;
-        char serverBuffer[SERVER_BUFFER_SIZE];
-
-        snprintf(serverBuffer, SERVER_BUFFER_SIZE, "SOURCE %s /%s\r\nSource-Agent: NTRIP %s/%s\r\n\r\n",
-                 mntpnt_pw, mntpnt, ntrip_server_name, "App Version 1.0");
-
-        Serial.printf("Sending credentials:\n%s\n", serverBuffer);
-        client.write(serverBuffer, strlen(serverBuffer));
-
-        //Wait for response
-        unsigned long timeout = millis();
-        while (client.available() == 0)
-        {
-          if (millis() - timeout > 5000)
-          {
-            Serial.println(">>> Client Timeout !");
-            client.stop();
-            return;
-          }
-          delay(10);
-        }
-
-        //Check reply
-        bool connectionSuccess = false;
-        char response[512];
-        int responseSpot = 0;
-        while (client.available())
-        {
-          response[responseSpot++] = client.read();
-          if (strstr(response, "200") > 0) //Look for 'ICY 200 OK'
-            connectionSuccess = true;
-          if (responseSpot == 512 - 1) break;
-        }
-        response[responseSpot] = '\0';
-
-        if (connectionSuccess == false)
-        {
-          Serial.printf("Failed to connect to RTK2Go: %s", response);
-        }
-      } //End attempt to connect
-      else
-      {
-        Serial.println("Connection to host failed");
-      }
-    } //End connected == false
-
-    if (client.connected() == true)
-    {
-      delay(10);
-      while (Serial.available()) Serial.read(); //Flush any endlines or carriage returns
-
-      lastReport_ms = millis();
-      lastSentRTCM_ms = millis();
-
-      //This is the main sending loop. We scan for new ublox data but processRTCM() is where the data actually gets sent out.
-      while (1)
-      {
-        if (Serial.available()) break;
-
-        myGNSS.checkUblox(); //See if new data is available. Process bytes as they come in.
-
-        //Close socket if we don't have new data for 10s
-        //RTK2Go will ban your IP address if you abuse it. See http://www.rtk2go.com/how-to-get-your-ip-banned/
-        //So let's not leave the socket open/hanging without data
-        if (millis() - lastSentRTCM_ms > maxTimeBeforeHangup_ms)
-        {
-          Serial.println("RTCM timeout. Disconnecting...");
-          client.stop();
-          return;
-        }
-
-        delay(10);
-
-        //Report some statistics every 250
-        if (millis() - lastReport_ms > 250)
-        {
-          lastReport_ms += 250;
-          Serial.printf("Total sent: %d\n", serverBytesSent);
-        }
-      }
-    }
-
-    delay(10);
-  }
-
-  Serial.println("User pressed a key");
-  Serial.println("Disconnecting...");
-  client.stop();
-
-  delay(10);
-  while (Serial.available()) Serial.read(); //Flush any endlines or carriage returns
-}
-
-//This function gets called from the SparkFun u-blox Arduino Library.
-//As each RTCM byte comes in you can specify what to do with it
-//Useful for passing the RTCM correction data to a radio, Ntrip broadcaster, etc.
-void SFE_UBLOX_GNSS::processRTCM(uint8_t incoming)
-{
-  if (client.connected() == true)
-  {
-    client.write(incoming); //Send this byte to socket
-    serverBytesSent++;
-    lastSentRTCM_ms = millis();
-  }
-}
diff --git a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/ZED-F9P/Example14_NTRIPServer/secrets.h b/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/ZED-F9P/Example14_NTRIPServer/secrets.h
deleted file mode 100644
index 5dcd50e..0000000
--- a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/ZED-F9P/Example14_NTRIPServer/secrets.h
+++ /dev/null
@@ -1,7 +0,0 @@
-//Your WiFi credentials
-const char* ssid = "TRex";
-const char* password =  "hasBigTeeth";
-
-//Your RTK2GO mount point credentials
-const char* mntpnt_pw = "WR5wRo4H";
-const char* mntpnt = "bldr_dwntwn2";
diff --git a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/ZED-F9P/Example1_GetPositionAccuracy/Example1_GetPositionAccuracy.ino b/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/ZED-F9P/Example1_GetPositionAccuracy/Example1_GetPositionAccuracy.ino
deleted file mode 100644
index 05270cb..0000000
--- a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/ZED-F9P/Example1_GetPositionAccuracy/Example1_GetPositionAccuracy.ino
+++ /dev/null
@@ -1,76 +0,0 @@
-/*
-  Get the high position accuracy of the RTK enhanced position from HPPOSECEF
-  By: Nathan Seidle
-  SparkFun Electronics
-  Date: January 3rd, 2019
-  License: MIT. See license file for more information but you can
-  basically do whatever you want with this code.
-
-  This example shows how to inspect the accuracy of the high-precision
-  positional solution.
-
-  Feel like supporting open source hardware?
-  Buy a board from SparkFun!
-  ZED-F9P RTK2: https://www.sparkfun.com/products/15136
-  NEO-M8P RTK: https://www.sparkfun.com/products/15005
-  SAM-M8Q: https://www.sparkfun.com/products/15106
-
-  Hardware Connections:
-  Plug a Qwiic cable into the GNSS and a BlackBoard
-  If you don't have a platform with a Qwiic connection use the SparkFun Qwiic Breadboard Jumper (https://www.sparkfun.com/products/14425)
-  Open the serial monitor at 115200 baud to see the output
-*/
-
-#include <Wire.h> //Needed for I2C to GNSS
-
-#include <SparkFun_u-blox_GNSS_Arduino_Library.h> //http://librarymanager/All#SparkFun_u-blox_GNSS
-SFE_UBLOX_GNSS myGNSS;
-
-long lastTime = 0; //Simple local timer. Limits amount if I2C traffic to u-blox module.
-
-void setup()
-{
-  Serial.begin(115200);
-  while (!Serial); //Wait for user to open terminal
-  Serial.println("SparkFun u-blox Example");
-
-  Wire.begin();
-
-  if (myGNSS.begin() == false) //Connect to the u-blox module using Wire port
-  {
-    Serial.println(F("u-blox GNSS not detected at default I2C address. Please check wiring. Freezing."));
-    while (1);
-  }
-
-  myGNSS.setI2COutput(COM_TYPE_UBX); //Set the I2C port to output UBX only (turn off NMEA noise)
-  //myGNSS.saveConfiguration(); //Optional: Save the current settings to flash and BBR
-}
-
-void loop()
-{
-  //Query module only every second. Doing it more often will just cause I2C traffic.
-  //The module only responds when a new position is available
-  if (millis() - lastTime > 1000)
-  {
-    lastTime = millis(); //Update the timer
-
-    long latitude = myGNSS.getLatitude();
-    Serial.print(F("Lat: "));
-    Serial.print(latitude);
-
-    long longitude = myGNSS.getLongitude();
-    Serial.print(F(" Long: "));
-    Serial.print(longitude);
-    Serial.print(F(" (degrees * 10^-7)"));
-
-    long altitude = myGNSS.getAltitude();
-    Serial.print(F(" Alt: "));
-    Serial.print(altitude);
-    Serial.print(F(" (mm)"));
-
-    long accuracy = myGNSS.getPositionAccuracy();
-    Serial.print(F(" 3D Positional Accuracy: "));
-    Serial.print(accuracy);
-    Serial.println(F(" (mm)"));
-  }
-}
diff --git a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/ZED-F9P/Example2_ValConfigurationMethod/Example2_ValConfigurationMethod.ino b/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/ZED-F9P/Example2_ValConfigurationMethod/Example2_ValConfigurationMethod.ino
deleted file mode 100644
index a2dac0b..0000000
--- a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/ZED-F9P/Example2_ValConfigurationMethod/Example2_ValConfigurationMethod.ino
+++ /dev/null
@@ -1,63 +0,0 @@
-/*
-  Configuring u-blox Module using new VALGET / VALSET / VALDEL methods
-
-  Please see u-blox_config_keys.h for the definitions of _all_ of the configuration keys
-  
-  By: Nathan Seidle
-  SparkFun Electronics
-  Date: January 3rd, 2019
-  License: MIT. See license file for more information but you can
-  basically do whatever you want with this code.
-
-  u-blox deprecated many -CFG messages and replaced them with new
-  VALGET, VALSET, VALDEL methods. This shows the basics of how to use
-  these methods.
-
-  Leave NMEA parsing behind. Now you can simply ask the module for the datums you want!
-
-  Feel like supporting open source hardware?
-  Buy a board from SparkFun!
-  ZED-F9P RTK2: https://www.sparkfun.com/products/15136
-  NEO-M8P RTK: https://www.sparkfun.com/products/15005
-  SAM-M8Q: https://www.sparkfun.com/products/15106
-
-  Hardware Connections:
-  Plug a Qwiic cable into the GNSS and a BlackBoard
-  If you don't have a platform with a Qwiic connection use the SparkFun Qwiic Breadboard Jumper (https://www.sparkfun.com/products/14425)
-  Open the serial monitor at 115200 baud to see the output
-*/
-
-#include <Wire.h> //Needed for I2C to GNSS
-
-#include <SparkFun_u-blox_GNSS_Arduino_Library.h> //http://librarymanager/All#SparkFun_u-blox_GNSS
-SFE_UBLOX_GNSS myGNSS;
-
-long lastTime = 0; //Simple local timer. Limits amount if I2C traffic to u-blox module.
-
-void setup()
-{
-  Serial.begin(115200);
-  while (!Serial); //Wait for user to open terminal
-  Serial.println("SparkFun u-blox Example");
-
-  Wire.begin();
-
-  if (myGNSS.begin() == false) //Connect to the u-blox module using Wire port
-  {
-    Serial.println(F("u-blox GNSS not detected at default I2C address. Please check wiring. Freezing."));
-    while (1);
-  }
-
-  byte response;
-  response = myGNSS.getVal8(UBLOX_CFG_I2C_ADDRESS, VAL_LAYER_RAM); // Get the I2C address (see u-blox_config_keys.h for details)
-  Serial.print(F("I2C Address: 0x"));
-  Serial.println(response >> 1, HEX); //We have to shift by 1 to get the common '7-bit' I2C address format
-
-  response = myGNSS.getVal8(UBLOX_CFG_I2COUTPROT_NMEA, VAL_LAYER_RAM); // Get the flag indicating is NMEA should be output on I2C
-  Serial.print(F("Output NMEA over I2C port: 0x"));
-  Serial.print(response, HEX);
-}
-
-void loop()
-{
-}
diff --git a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/ZED-F9P/Example3_StartRTCMBase/Example3_StartRTCMBase.ino b/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/ZED-F9P/Example3_StartRTCMBase/Example3_StartRTCMBase.ino
deleted file mode 100644
index d3d13be..0000000
--- a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/ZED-F9P/Example3_StartRTCMBase/Example3_StartRTCMBase.ino
+++ /dev/null
@@ -1,194 +0,0 @@
-/*
-  Send UBX binary commands to enable RTCM sentences on u-blox ZED-F9P module
-  By: Nathan Seidle
-  SparkFun Electronics
-  Date: January 9th, 2019
-  License: MIT. See license file for more information but you can
-  basically do whatever you want with this code.
-
-  This example does all steps to configure and enable a ZED-F9P as a base station:
-    Begin Survey-In
-    Once we've achieved 2m accuracy and 300s have passed, survey is complete
-    Enable six RTCM messages
-    Begin outputting RTCM bytes
-
-  Feel like supporting open source hardware?
-  Buy a board from SparkFun!
-  ZED-F9P RTK2: https://www.sparkfun.com/products/15136
-  NEO-M8P RTK: https://www.sparkfun.com/products/15005
-  SAM-M8Q: https://www.sparkfun.com/products/15106
-
-  Hardware Connections:
-  Plug a Qwiic cable into the GNSS and a BlackBoard
-  If you don't have a platform with a Qwiic connection use the SparkFun Qwiic Breadboard Jumper (https://www.sparkfun.com/products/14425)
-  Open the serial monitor at 115200 baud to see the output
-*/
-
-#include <Wire.h> //Needed for I2C to GNSS
-
-#include <SparkFun_u-blox_GNSS_Arduino_Library.h> //http://librarymanager/All#SparkFun_u-blox_GNSS
-SFE_UBLOX_GNSS myGNSS;
-
-//#define USE_SERIAL1 // Uncomment this line to push the RTCM data to Serial1
-
-void setup()
-{
-  Serial.begin(115200);
-  while (!Serial); //Wait for user to open terminal
-  Serial.println(F("u-blox Base Station example"));
-
-#ifdef USE_SERIAL1
-  // If our board supports it, we can output the RTCM data on Serial1
-  Serial1.begin(115200);
-#endif
-
-  Wire.begin();
-  Wire.setClock(400000); //Increase I2C clock speed to 400kHz
-
-  if (myGNSS.begin() == false) //Connect to the u-blox module using Wire port
-  {
-    Serial.println(F("u-blox GNSS not detected at default I2C address. Please check wiring. Freezing."));
-    while (1);
-  }
-
-  // Uncomment the next line if you want to reset your module back to the default settings with 1Hz navigation rate
-  //myGNSS.factoryDefault(); delay(5000);
-
-  myGNSS.setI2COutput(COM_TYPE_UBX); //Set the I2C port to output UBX only (turn off NMEA noise)
-  myGNSS.saveConfigSelective(VAL_CFG_SUBSEC_IOPORT); //Save the communications port settings to flash and BBR
-
-  while (Serial.available()) Serial.read(); //Clear any latent chars in serial buffer
-  Serial.println(F("Press any key to send commands to begin Survey-In"));
-  while (Serial.available() == 0) ; //Wait for user to press a key
-
-  boolean response = true;
-  response &= myGNSS.enableRTCMmessage(UBX_RTCM_1005, COM_PORT_I2C, 1); //Enable message 1005 to output through I2C port, message every second
-  response &= myGNSS.enableRTCMmessage(UBX_RTCM_1074, COM_PORT_I2C, 1);
-  response &= myGNSS.enableRTCMmessage(UBX_RTCM_1084, COM_PORT_I2C, 1);
-  response &= myGNSS.enableRTCMmessage(UBX_RTCM_1094, COM_PORT_I2C, 1);
-  response &= myGNSS.enableRTCMmessage(UBX_RTCM_1124, COM_PORT_I2C, 1);
-  response &= myGNSS.enableRTCMmessage(UBX_RTCM_1230, COM_PORT_I2C, 10); //Enable message every 10 seconds
-
-  //Use COM_PORT_UART1 for the above six messages to direct RTCM messages out UART1
-  //COM_PORT_UART2, COM_PORT_USB, COM_PORT_SPI are also available
-  //For example: response &= myGNSS.enableRTCMmessage(UBX_RTCM_1005, COM_PORT_UART1, 10);
-
-  if (response == true)
-  {
-    Serial.println(F("RTCM messages enabled"));
-  }
-  else
-  {
-    Serial.println(F("RTCM failed to enable. Are you sure you have an ZED-F9P?"));
-    while (1); //Freeze
-  }
-
-  //Check if Survey is in Progress before initiating one
-  // From v2.0, the data from getSurveyStatus (UBX-NAV-SVIN) is returned in UBX_NAV_SVIN_t packetUBXNAVSVIN
-  // Please see u-blox_structs.h for the full definition of UBX_NAV_SVIN_t
-  // You can either read the data from packetUBXNAVSVIN directly
-  // or can use the helper functions: getSurveyInActive; getSurveyInValid; getSurveyInObservationTime; and getSurveyInMeanAccuracy
-  response = myGNSS.getSurveyStatus(2000); //Query module for SVIN status with 2000ms timeout (request can take a long time)
-  
-  if (response == false) // Check if fresh data was received
-  {
-    Serial.println(F("Failed to get Survey In status"));
-    while (1); //Freeze
-  }
-
-  if (myGNSS.getSurveyInActive() == true) // Use the helper function
-  //if (myGNSS.packetUBXNAVSVIN->data.active > 0) // Or we could read active directly
-  {
-    Serial.print(F("Survey already in progress."));
-  }
-  else
-  {
-    //Start survey
-    //The ZED-F9P is slightly different than the NEO-M8P. See the Integration manual 3.5.8 for more info.
-    //response = myGNSS.enableSurveyMode(300, 2.000); //Enable Survey in on NEO-M8P, 300 seconds, 2.0m
-    response = myGNSS.enableSurveyMode(60, 5.000); //Enable Survey in, 60 seconds, 5.0m
-    if (response == false)
-    {
-      Serial.println(F("Survey start failed. Freezing..."));
-      while (1);
-    }
-    Serial.println(F("Survey started. This will run until 60s has passed and less than 5m accuracy is achieved."));
-  }
-
-  while(Serial.available()) Serial.read(); //Clear buffer
-  
-  //Begin waiting for survey to complete
-  while (myGNSS.getSurveyInValid() == false) // Call the helper function
-  //while (myGNSS.packetUBXNAVSVIN->data.valid == 0) // Or we could read valid directly
-  {
-    if(Serial.available())
-    {
-      byte incoming = Serial.read();
-      if(incoming == 'x')
-      {
-        //Stop survey mode
-        response = myGNSS.disableSurveyMode(); //Disable survey
-        Serial.println(F("Survey stopped"));
-        break;
-      }
-    }
-
-    // From v2.0, the data from getSurveyStatus (UBX-NAV-SVIN) is returned in UBX_NAV_SVIN_t packetUBXNAVSVIN
-    // Please see u-blox_structs.h for the full definition of UBX_NAV_SVIN_t
-    // You can either read the data from packetUBXNAVSVIN directly
-    // or can use the helper functions: getSurveyInActive; getSurveyInValid; getSurveyInObservationTime; and getSurveyInMeanAccuracy
-    response = myGNSS.getSurveyStatus(2000); //Query module for SVIN status with 2000ms timeout (req can take a long time)
-    
-    if (response == true) // Check if fresh data was received
-    {
-      Serial.print(F("Press x to end survey - "));
-      Serial.print(F("Time elapsed: "));
-      Serial.print((String)myGNSS.getSurveyInObservationTime()); // Call the helper function
-      Serial.print(F(" ("));
-      Serial.print((String)myGNSS.packetUBXNAVSVIN->data.dur); // Read the survey-in duration directly from packetUBXNAVSVIN
-
-      Serial.print(F(") Accuracy: "));
-      Serial.print((String)myGNSS.getSurveyInMeanAccuracy()); // Call the helper function
-      Serial.print(F(" ("));
-      // Read the mean accuracy directly from packetUBXNAVSVIN and manually convert from mm*0.1 to m
-      float meanAcc = ((float)myGNSS.packetUBXNAVSVIN->data.meanAcc) / 10000.0;
-      Serial.print((String)meanAcc); 
-      Serial.println(F(")"));
-    }
-    else
-    {
-      Serial.println(F("SVIN request failed"));
-    }
-
-    delay(1000);
-  }
-  Serial.println(F("Survey valid!"));
-
-  Serial.println(F("Base survey complete! RTCM now broadcasting."));
-
-  myGNSS.setI2COutput(COM_TYPE_UBX | COM_TYPE_RTCM3); //Set the I2C port to output UBX and RTCM sentences (not really an option, turns on NMEA as well)
-}
-
-void loop()
-{
-  myGNSS.checkUblox(); //See if new data is available. Process bytes as they come in.
-
-  delay(250); //Don't pound too hard on the I2C bus
-}
-
-//This function gets called from the SparkFun u-blox Arduino Library.
-//As each RTCM byte comes in you can specify what to do with it
-//Useful for passing the RTCM correction data to a radio, Ntrip broadcaster, etc.
-void SFE_UBLOX_GNSS::processRTCM(uint8_t incoming)
-{
-#ifdef USE_SERIAL1
-  //Push the RTCM data to Serial1
-  Serial1.write(incoming);
-#endif
-
-  //Pretty-print the HEX values to Serial
-  if (myGNSS.rtcmFrameCounter % 16 == 0) Serial.println();
-  Serial.print(F(" "));
-  if (incoming < 0x10) Serial.print(F("0"));
-  Serial.print(incoming, HEX);
-}
diff --git a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/ZED-F9P/Example4_BaseWithLCD/Example4_BaseWithLCD.ino b/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/ZED-F9P/Example4_BaseWithLCD/Example4_BaseWithLCD.ino
deleted file mode 100644
index dfa025a..0000000
--- a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/ZED-F9P/Example4_BaseWithLCD/Example4_BaseWithLCD.ino
+++ /dev/null
@@ -1,210 +0,0 @@
-/*
-  Note: compiles OK with v2.0 but is untested. The previous example works fine though.
-  
-  Send UBX binary commands to enable RTCM sentences on u-blox ZED-F9P module
-  By: Nathan Seidle
-  SparkFun Electronics
-  Date: January 9th, 2019
-  License: MIT. See license file for more information but you can
-  basically do whatever you want with this code.
-
-  This example does all steps to configure and enable a ZED-F9P as a base station:
-    Begin Survey-In
-    Once we've achieved 2m accuracy and 300s have passed, survey is complete
-    Enable six RTCM messages
-    Begin outputting RTCM bytes
-
-  Feel like supporting open source hardware?
-  Buy a board from SparkFun!
-  ZED-F9P RTK2: https://www.sparkfun.com/products/15136
-  NEO-M8P RTK: https://www.sparkfun.com/products/15005
-  SAM-M8Q: https://www.sparkfun.com/products/15106
-
-  Hardware Connections:
-  Plug a Qwiic cable into the GNSS and a BlackBoard
-  Plug a SerLCD onto the Qwiic bus
-  If you don't have a platform with a Qwiic connection use the SparkFun Qwiic Breadboard Jumper (https://www.sparkfun.com/products/14425)
-  Watch the output on the LCD or open the serial monitor at 115200 baud to see the output
-*/
-
-#define STAT_LED 13
-
-#include <Wire.h> //Needed for I2C to GNSS
-
-#include <SparkFun_u-blox_GNSS_Arduino_Library.h> //Click here to get the library: http://librarymanager/All#SparkFun_u-blox_GNSS
-SFE_UBLOX_GNSS myGNSS;
-
-#include <SerLCD.h> //Click here to get the library: http://librarymanager/All#SparkFun_SerLCD
-SerLCD lcd;         // Initialize the library with default I2C address 0x72
-
-void setup()
-{
-  Serial.begin(115200);
-  while (!Serial)
-    ; //Wait for user to open terminal
-  Serial.println(F("u-blox GNSS I2C Test"));
-
-  Wire.begin();
-
-  pinMode(STAT_LED, OUTPUT);
-  digitalWrite(STAT_LED, LOW);
-
-  lcd.begin(Wire);            //Set up the LCD for Serial communication at 9600bps
-  lcd.setBacklight(0x4B0082); //indigo, a kind of dark purplish blue
-  lcd.clear();
-  lcd.print(F("LCD Ready"));
-
-  myGNSS.begin(Wire);
-  if (myGNSS.isConnected() == false)
-  {
-    Serial.println(F("u-blox GNSS not detected at default I2C address. Please check wiring. Freezing."));
-    lcd.setCursor(0, 1);
-    lcd.print(F("No GNSS detected"));
-    while (1)
-      ;
-  }
-
-  Wire.setClock(400000); //Increase I2C clock speed to 400kHz
-
-  lcd.setCursor(0, 1);
-  lcd.print("GNSS Detected");
-
-  //myGNSS.setI2COutput(COM_TYPE_RTCM3); //Set the I2C port to output RTCM3 sentences (turn off NMEA noise)
-  myGNSS.setI2COutput(COM_TYPE_UBX); //Set the I2C port to output UBX sentences (turn off NMEA noise)
-  myGNSS.saveConfigSelective(VAL_CFG_SUBSEC_IOPORT); //Save the communications port settings to flash and BBR
-
-  boolean response = true;
-  response &= myGNSS.enableRTCMmessage(UBX_RTCM_1005, COM_PORT_I2C, 1); //Enable message 1005 to output through I2C port, message every second
-  response &= myGNSS.enableRTCMmessage(UBX_RTCM_1074, COM_PORT_I2C, 1);
-  response &= myGNSS.enableRTCMmessage(UBX_RTCM_1084, COM_PORT_I2C, 1);
-  response &= myGNSS.enableRTCMmessage(UBX_RTCM_1094, COM_PORT_I2C, 1);
-  response &= myGNSS.enableRTCMmessage(UBX_RTCM_1124, COM_PORT_I2C, 1);
-  response &= myGNSS.enableRTCMmessage(UBX_RTCM_1230, COM_PORT_I2C, 10); //Enable message every 10 seconds
-  if (response == true)
-  {
-    Serial.println(F("RTCM messages enabled"));
-  }
-  else
-  {
-    Serial.println(F("RTCM failed to enable. Are you sure you have an ZED-F9P? Freezing."));
-    while (1)
-      ; //Freeze
-  }
-
-  //Check if Survey is in Progress before initiating one
-  // From v2.0, the data from getSurveyStatus (UBX-NAV-SVIN) is returned in UBX_NAV_SVIN_t packetUBXNAVSVIN
-  // Please see u-blox_structs.h for the full definition of UBX_NAV_SVIN_t
-  // You can either read the data from packetUBXNAVSVIN directly
-  // or can use the helper functions: getSurveyInActive; getSurveyInValid; getSurveyInObservationTime; and getSurveyInMeanAccuracy
-  response = myGNSS.getSurveyStatus(2000); //Query module for SVIN status with 2000ms timeout (request can take a long time)
-  if (response == false)
-  {
-    Serial.println(F("Failed to get Survey In status. Freezing."));
-    while (1)
-      ; //Freeze
-  }
-
-  if (myGNSS.getSurveyInActive() == true) // Use the helper function
-  {
-    Serial.print(F("Survey already in progress."));
-    lcd.setCursor(0, 2);
-    lcd.print(F("Survey already going"));
-  }
-  else
-  {
-    //Start survey
-    response = myGNSS.enableSurveyMode(60, 5.000); //Enable Survey in, 60 seconds, 5.0m
-    if (response == false)
-    {
-      Serial.println(F("Survey start failed"));
-      lcd.setCursor(0, 3);
-      lcd.print(F("Survey start failed. Freezing."));
-      while (1)
-        ;
-    }
-    Serial.println(F("Survey started. This will run until 60s has passed and less than 5m accuracy is achieved."));
-  }
-
-  while (Serial.available())
-    Serial.read(); //Clear buffer
-
-  lcd.clear();
-  lcd.print(F("Survey in progress"));
-
-  //Begin waiting for survey to complete
-  while (myGNSS.getSurveyInValid() == false) // Call the helper function
-  {
-    if (Serial.available())
-    {
-      byte incoming = Serial.read();
-      if (incoming == 'x')
-      {
-        //Stop survey mode
-        response = myGNSS.disableSurveyMode(); //Disable survey
-        Serial.println(F("Survey stopped"));
-        break;
-      }
-    }
-
-    // From v2.0, the data from getSurveyStatus (UBX-NAV-SVIN) is returned in UBX_NAV_SVIN_t packetUBXNAVSVIN
-    // Please see u-blox_structs.h for the full definition of UBX_NAV_SVIN_t
-    // You can either read the data from packetUBXNAVSVIN directly
-    // or can use the helper functions: getSurveyInActive; getSurveyInValid; getSurveyInObservationTime; and getSurveyInMeanAccuracy
-    response = myGNSS.getSurveyStatus(2000); //Query module for SVIN status with 2000ms timeout (req can take a long time)
-    if (response == true)
-    {
-      Serial.print(F("Press x to end survey - "));
-      Serial.print(F("Time elapsed: "));
-      Serial.print((String)myGNSS.getSurveyInObservationTime()); // Call the helper function
-
-      lcd.setCursor(0, 1);
-      lcd.print(F("Elapsed: "));
-      lcd.print((String)myGNSS.getSurveyInObservationTime()); // Call the helper function
-
-      Serial.print(F(" Accuracy: "));
-      Serial.print((String)myGNSS.getSurveyInMeanAccuracy()); // Call the helper function
-      Serial.println();
-
-      lcd.setCursor(0, 2);
-      lcd.print(F("Accuracy: "));
-      lcd.print((String)myGNSS.getSurveyInMeanAccuracy()); // Call the helper function
-    }
-    else
-    {
-      Serial.println(F("SVIN request failed"));
-    }
-
-    delay(1000);
-  }
-  Serial.println(F("Survey valid!"));
-
-  Serial.println(F("Base survey complete! RTCM now broadcasting."));
-  lcd.clear();
-  lcd.print(F("Transmitting RTCM"));
-
-  myGNSS.setI2COutput(COM_TYPE_UBX | COM_TYPE_RTCM3); //Set the I2C port to output UBX and RTCM sentences (not really an option, turns on NMEA as well)
-  
-}
-
-void loop()
-{
-  myGNSS.checkUblox(); //See if new data is available. Process bytes as they come in.
-
-  //Do anything you want. Call checkUblox() every second. ZED-F9P has TX buffer of 4k bytes.
-
-  delay(250); //Don't pound too hard on the I2C bus
-}
-
-//This function gets called from the SparkFun u-blox Arduino Library.
-//As each RTCM byte comes in you can specify what to do with it
-//Useful for passing the RTCM correction data to a radio, Ntrip broadcaster, etc.
-void SFE_UBLOX_GNSS::processRTCM(uint8_t incoming)
-{
-  //Let's just pretty-print the HEX values for now
-  if (myGNSS.rtcmFrameCounter % 16 == 0)
-    Serial.println();
-  Serial.print(" ");
-  if (incoming < 0x10)
-    Serial.print("0");
-  Serial.print(incoming, HEX);
-}
diff --git a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/ZED-F9P/Example5_RelativePositioningInformation/Example5_RelativePositioningInformation.ino b/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/ZED-F9P/Example5_RelativePositioningInformation/Example5_RelativePositioningInformation.ino
deleted file mode 100644
index 3990f89..0000000
--- a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/ZED-F9P/Example5_RelativePositioningInformation/Example5_RelativePositioningInformation.ino
+++ /dev/null
@@ -1,165 +0,0 @@
-/*
-  Send UBX binary commands to enable RTCM sentences on u-blox ZED-F9P module
-  By: Nathan Seidle
-  SparkFun Electronics
-  Date: January 9th, 2019
-  License: MIT. See license file for more information but you can
-  basically do whatever you want with this code.
-
-  This example shows how to query the module for RELPOS information in the NED frame.
-  It assumes you already have RTCM correction data being fed to the receiver.
-
-  Feel like supporting open source hardware?
-  Buy a board from SparkFun!
-  ZED-F9P RTK2: https://www.sparkfun.com/products/15136
-  NEO-M8P RTK: https://www.sparkfun.com/products/15005
-  SAM-M8Q: https://www.sparkfun.com/products/15106
-
-  Hardware Connections:
-  Plug a Qwiic cable into the GNSS and a RedBoard Qwiic or BlackBoard
-  If you don't have a platform with a Qwiic connection use the SparkFun Qwiic Breadboard Jumper (https://www.sparkfun.com/products/14425)
-  Open the serial monitor at 115200 baud to see the output
-*/
-
-#include <Wire.h> //Needed for I2C to GNSS
-
-#include <SparkFun_u-blox_GNSS_Arduino_Library.h> //http://librarymanager/All#SparkFun_u-blox_GNSS
-SFE_UBLOX_GNSS myGNSS;
-
-//#define USE_SERIAL1 // Uncomment this line to push the RTCM data from Serial1 to the module via I2C
-
-size_t numBytes = 0; // Record the number os bytes received from Serial1
-
-void setup()
-{
-  Serial.begin(115200);
-  while (!Serial); //Wait for user to open terminal
-  Serial.println("u-blox Base station example");
-
-#ifdef USE_SERIAL1
-  // If our board supports it, we can receive the RTCM data on Serial1
-  Serial1.begin(115200);
-#endif
-
-  Wire.begin();
-  Wire.setClock(400000); //Increase I2C clock speed to 400kHz
-
-  if (myGNSS.begin() == false) //Connect to the u-blox module using Wire port
-  {
-    Serial.println(F("u-blox GNSS not detected at default I2C address. Please check wiring. Freezing."));
-    while (1);
-  }
-
-  // Uncomment the next line if you want to reset your module back to the default settings with 1Hz navigation rate
-  //myGNSS.factoryDefault(); delay(5000);
-
-#ifdef USE_SERIAL1
-  Serial.print(F("Enabling UBX and RTCM input on I2C. Result: "));
-  Serial.print(myGNSS.setPortInput(COM_PORT_I2C, COM_TYPE_UBX | COM_TYPE_RTCM3)); //Enable UBX and RTCM input on I2C
-  myGNSS.saveConfigSelective(VAL_CFG_SUBSEC_IOPORT); //Save the communications port settings to flash and BBR
-#endif
-}
-
-void loop()
-{
-  // From v2.0, the data from getRELPOSNED (UBX-NAV-RELPOSNED) is returned in UBX_NAV_RELPOSNED_t packetUBXNAVRELPOSNED
-  // Please see u-blox_structs.h for the full definition of UBX_NAV_RELPOSNED_t
-  // You can either read the data from packetUBXNAVRELPOSNED directly
-  // or can use the helper functions: getRelPosN/E/D; getRelPosAccN/E/D
-  if (myGNSS.getRELPOSNED() == true)
-  {
-    Serial.print("relPosN: ");
-    Serial.println(myGNSS.getRelPosN(), 4); // Use the helper functions to get the rel. pos. as m
-    Serial.print("relPosE: ");
-    Serial.println(myGNSS.getRelPosE(), 4);
-    Serial.print("relPosD: ");
-    Serial.println(myGNSS.getRelPosD(), 4);
-
-    Serial.print("relPosLength: ");
-    Serial.println(myGNSS.packetUBXNAVRELPOSNED->data.relPosLength);
-    Serial.print("relPosHeading: ");
-    Serial.println(myGNSS.packetUBXNAVRELPOSNED->data.relPosHeading);
-
-    Serial.print("relPosHPN: ");
-    Serial.println(myGNSS.packetUBXNAVRELPOSNED->data.relPosHPN);
-    Serial.print("relPosHPE: ");
-    Serial.println(myGNSS.packetUBXNAVRELPOSNED->data.relPosHPE);
-    Serial.print("relPosHPD: ");
-    Serial.println(myGNSS.packetUBXNAVRELPOSNED->data.relPosHPD);
-    Serial.print("relPosHPLength: ");
-    Serial.println(myGNSS.packetUBXNAVRELPOSNED->data.relPosHPLength);
-
-    Serial.print("accN: ");
-    Serial.println(myGNSS.getRelPosAccN(), 4); // Use the helper functions to get the rel. pos. accuracy as m
-    Serial.print("accE: ");
-    Serial.println(myGNSS.getRelPosAccE(), 4);
-    Serial.print("accD: ");
-    Serial.println(myGNSS.getRelPosAccD(), 4);
-
-    Serial.print("gnssFixOk: ");
-    if (myGNSS.packetUBXNAVRELPOSNED->data.flags.bits.gnssFixOK == true)
-      Serial.println("x");
-    else
-      Serial.println("");
-
-    Serial.print("diffSolution: ");
-    if (myGNSS.packetUBXNAVRELPOSNED->data.flags.bits.diffSoln == true)
-      Serial.println("x");
-    else
-      Serial.println("");
-
-    Serial.print("relPosValid: ");
-    if (myGNSS.packetUBXNAVRELPOSNED->data.flags.bits.relPosValid == true)
-      Serial.println("x");
-    else
-      Serial.println("");
-
-    Serial.print("carrier Solution Type: ");
-    if (myGNSS.packetUBXNAVRELPOSNED->data.flags.bits.carrSoln == 0)
-      Serial.println("None");
-    else if (myGNSS.packetUBXNAVRELPOSNED->data.flags.bits.carrSoln == 1)
-      Serial.println("Float");
-    else if (myGNSS.packetUBXNAVRELPOSNED->data.flags.bits.carrSoln == 2)
-      Serial.println("Fixed");
-
-    Serial.print("isMoving: ");
-    if (myGNSS.packetUBXNAVRELPOSNED->data.flags.bits.isMoving == true)
-      Serial.println("x");
-    else
-      Serial.println("");
-
-    Serial.print("refPosMiss: ");
-    if (myGNSS.packetUBXNAVRELPOSNED->data.flags.bits.refPosMiss == true)
-      Serial.println("x");
-    else
-      Serial.println("");
-
-    Serial.print("refObsMiss: ");
-    if (myGNSS.packetUBXNAVRELPOSNED->data.flags.bits.refObsMiss == true)
-      Serial.println("x");
-    else
-      Serial.println("");
-  }
-  else
-    Serial.println("RELPOS request failed");
-
-  for (int i = 0; i < 500; i++)
-  {
-#ifdef USE_SERIAL1
-    uint8_t store[256];
-    while ((Serial1.available()) && (numBytes < 256)) // Check if data has been received
-    {
-      store[numBytes++] = Serial1.read(); // Read a byte from Serial1 and store it
-    }
-    if (numBytes > 0) // Check if data was received
-    {
-      //Serial.print("Pushing ");
-      //Serial.print(numBytes);
-      //Serial.println(" bytes via I2C");
-      myGNSS.pushRawData(((uint8_t *)&store), numBytes); // Push the RTCM data via I2C
-      numBytes = 0; // Reset numBytes
-    }
-#endif
-    delay(10);
-  }
-}
diff --git a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/ZED-F9P/Example6_GetVal/Example6_GetVal.ino b/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/ZED-F9P/Example6_GetVal/Example6_GetVal.ino
deleted file mode 100644
index 8a419dc..0000000
--- a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/ZED-F9P/Example6_GetVal/Example6_GetVal.ino
+++ /dev/null
@@ -1,60 +0,0 @@
-/*
-  Get a device's I2C address using advanced getVal method
-  By: Nathan Seidle
-  SparkFun Electronics
-  Date: January 9th, 2019
-  License: MIT. See license file for more information but you can
-  basically do whatever you want with this code.
-
-  u-blox changed how to configure their modules in 2019. As of version 23 of the UBX protocol the
-  UBX-CFG commands are deprecated; they still work, they just recommend using VALSET, VALGET, and VALDEL
-  commands instead. This example shows how to use this new command structure.
-
-  Feel like supporting open source hardware?
-  Buy a board from SparkFun!
-  ZED-F9P RTK2: https://www.sparkfun.com/products/15136
-  NEO-M8P RTK: https://www.sparkfun.com/products/15005
-  SAM-M8Q: https://www.sparkfun.com/products/15106
-
-  Hardware Connections:
-  Plug a Qwiic cable into the GNSS and a RedBoard Qwiic or BlackBoard
-  If you don't have a platform with a Qwiic connection use the SparkFun Qwiic Breadboard Jumper (https://www.sparkfun.com/products/14425)
-  Open the serial monitor at 115200 baud to see the output
-*/
-
-#include <Wire.h> //Needed for I2C to GNSS
-
-#include <SparkFun_u-blox_GNSS_Arduino_Library.h> //http://librarymanager/All#SparkFun_u-blox_GNSS
-SFE_UBLOX_GNSS myGNSS;
-
-long lastTime = 0; //Simple local timer. Limits amount if I2C traffic to u-blox module.
-
-void setup()
-{
-  Serial.begin(115200);
-  while (!Serial)
-    ; //Wait for user to open terminal
-  Serial.println("u-blox getVal example");
-
-  Wire.begin();
-  Wire.setClock(400000); //Increase I2C clock speed to 400kHz
-
-  if (myGNSS.begin() == false) //Connect to the u-blox module using Wire port
-  {
-    Serial.println(F("u-blox GNSS not detected at default I2C address. Please check wiring. Freezing."));
-    while (1)
-      ;
-  }
-
-  //myGNSS.enableDebugging(); //Enable debug messages over Serial (default)
-  //myGNSS.enableDebugging(SerialUSB); //Enable debug messages over Serial USB
-
-  uint8_t currentI2Caddress = myGNSS.getVal8(UBLOX_CFG_I2C_ADDRESS);
-  Serial.print("Current I2C address (should be 0x42): 0x");
-  Serial.println(currentI2Caddress >> 1, HEX); //u-blox module returns a shifted 8-bit address. Make it 7-bit unshifted.
-}
-
-void loop()
-{
-  // Nothing to do here
-}
diff --git a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/ZED-F9P/Example7_SetVal/Example7_SetVal.ino b/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/ZED-F9P/Example7_SetVal/Example7_SetVal.ino
deleted file mode 100644
index 859d568..0000000
--- a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/ZED-F9P/Example7_SetVal/Example7_SetVal.ino
+++ /dev/null
@@ -1,76 +0,0 @@
-/*
-  Send UBX binary commands to enable RTCM sentences on u-blox ZED-F9P module
-  By: Nathan Seidle
-  SparkFun Electronics
-  Date: January 9th, 2019
-  License: MIT. See license file for more information but you can
-  basically do whatever you want with this code.
-
-  u-blox changed how to configure their modules in 2019. As of version 23 of the UBX protocol the
-  UBX-CFG commands are deprecated; they still work, they just recommend using VALSET, VALGET, and VALDEL
-  commands instead. This example shows how to use this new command structure.
-
-  Feel like supporting open source hardware?
-  Buy a board from SparkFun!
-  ZED-F9P RTK2: https://www.sparkfun.com/products/15136
-  NEO-M8P RTK: https://www.sparkfun.com/products/15005
-  SAM-M8Q: https://www.sparkfun.com/products/15106
-
-  Hardware Connections:
-  Plug a Qwiic cable into the GNSS and a RedBoard Qwiic or BlackBoard
-  If you don't have a platform with a Qwiic connection use the SparkFun Qwiic Breadboard Jumper (https://www.sparkfun.com/products/14425)
-  Open the serial monitor at 115200 baud to see the output
-*/
-
-#include <Wire.h> //Needed for I2C to GNSS
-
-#include <SparkFun_u-blox_GNSS_Arduino_Library.h> //http://librarymanager/All#SparkFun_u-blox_GNSS
-SFE_UBLOX_GNSS myGNSS;
-
-long lastTime = 0; //Simple local timer. Limits amount if I2C traffic to u-blox module.
-
-void setup()
-{
-  Serial.begin(115200);
-  while (!Serial)
-    ; //Wait for user to open terminal
-  Serial.println("u-blox getVal example");
-
-  Wire.begin();
-  Wire.setClock(400000); //Increase I2C clock speed to 400kHz
-
-  if (myGNSS.begin() == false) //Connect to the u-blox module using Wire port
-  {
-    Serial.println(F("u-blox GNSS not detected at default I2C address. Please check wiring. Freezing."));
-    while (1)
-      ;
-  }
-
-  //myGNSS.enableDebugging(); //Enable debug messages over Serial (default)
-  //myGNSS.enableDebugging(SerialUSB); //Enable debug messages over Serial USB
-
-  bool setValueSuccess;
-
-  //These key values are hard coded and defined in u-blox_config_keys.h.
-  //You can obtain them from the ZED-F9P interface description doc
-  //or from u-center's Messages->CFG->VALSET window. Keys must be 32-bit.
-  //setValueSuccess = myGNSS.setVal(UBLOX_CFG_NMEA_HIGHPREC, 0); //Enable high precision NMEA
-  //setValueSuccess = myGNSS.setVal(UBLOX_CFG_RATE_MEAS, 1000); //Set measurement rate to 100ms (10Hz update rate)
-  setValueSuccess = myGNSS.setVal(UBLOX_CFG_RATE_MEAS, 1000); //Set measurement rate to 1000ms (1Hz update rate)
-
-  //Below is the original way we enabled the RTCM message on the I2C port. After that, we show how to do the same
-  //but with setVal().
-  //Original: myGNSS.enableRTCMmessage(UBX_RTCM_1005, COM_PORT_I2C, 1); //Enable message 1005 to output through I2C port, message every second
-  //setValueSuccess = myGNSS.setVal(UBLOX_CFG_MSGOUT_RTCM_3X_TYPE1005_I2C, 1); //Set output rate of msg 1005 over the I2C port to once per second
-
-  if (setValueSuccess == true)
-  {
-    Serial.println("Value was successfully set");
-  }
-  else
-    Serial.println("Value set failed");
-}
-
-void loop()
-{
-}
diff --git a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/ZED-F9P/Example8_GetSetPortSettings/Example8_GetSetPortSettings.ino b/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/ZED-F9P/Example8_GetSetPortSettings/Example8_GetSetPortSettings.ino
deleted file mode 100644
index 5207746..0000000
--- a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/ZED-F9P/Example8_GetSetPortSettings/Example8_GetSetPortSettings.ino
+++ /dev/null
@@ -1,98 +0,0 @@
-/*
-  Configuring port settings using the newer getVal/setVal methods
-  By: Nathan Seidle
-  SparkFun Electronics
-  Date: October 23rd, 2020
-  License: MIT. See license file for more information but you can
-  basically do whatever you want with this code.
-
-  This example shows how to query a u-blox module for its UART1 settings and
-  then change them if the settings aren't what we want.
-
-  Note: getVal/setVal/delVal are only support in u-blox protocol versions 27 and higher.
-
-  Feel like supporting open source hardware?
-  Buy a board from SparkFun!
-  ZED-F9P RTK2: https://www.sparkfun.com/products/15136
-
-  Hardware Connections:
-  Plug a Qwiic cable into the GNSS and a RedBoard
-  If you don't have a platform with a Qwiic connection use the SparkFun Qwiic Breadboard Jumper (https://www.sparkfun.com/products/14425)
-  Open the serial monitor at 115200 baud to see the output
-*/
-
-#include <Wire.h> //Needed for I2C to GNSS
-
-#include <SparkFun_u-blox_GNSS_Arduino_Library.h> //http://librarymanager/All#SparkFun_u-blox_GNSS
-SFE_UBLOX_GNSS myGNSS;
-
-void setup()
-{
-  Serial.begin(115200);
-  while (!Serial)
-    ; //Wait for user to open terminal
-  Serial.println("SparkFun u-blox Example");
-
-  Wire.begin();
-
-  if (myGNSS.begin() == false) //Connect to the u-blox module using Wire port
-  {
-    Serial.println(F("u-blox GNSS not detected at default I2C address. Please check wiring. Freezing."));
-    while (1)
-      ;
-  }
-
-  bool response = true;
-
-  //Read the settings from RAM (what the module is running right now, not BBR, Flash, or default)
-  uint8_t currentUART1Setting_ubx = myGNSS.getVal8(UBLOX_CFG_UART1INPROT_UBX);
-  uint8_t currentUART1Setting_nmea = myGNSS.getVal8(UBLOX_CFG_UART1INPROT_NMEA);
-  uint8_t currentUART1Setting_rtcm3 = myGNSS.getVal8(UBLOX_CFG_UART1INPROT_RTCM3X);
-
-  Serial.print("currentUART1Setting_ubx: ");
-  Serial.println(currentUART1Setting_ubx);
-  Serial.print("currentUART1Setting_nmea: ");
-  Serial.println(currentUART1Setting_nmea);
-  Serial.print("currentUART1Setting_rtcm3: ");
-  Serial.println(currentUART1Setting_rtcm3);
-
-  //Check if NMEA and RTCM are enabled for UART1
-  if (currentUART1Setting_ubx == 0 || currentUART1Setting_nmea == 0)
-  {
-    Serial.println("Updating UART1 configuration");
-
-    //setVal sets the values for RAM, BBR, and Flash automatically so no .saveConfiguration() is needed
-    response &= myGNSS.setVal8(UBLOX_CFG_UART1INPROT_UBX, 1);    //Enable UBX on UART1 Input
-    response &= myGNSS.setVal8(UBLOX_CFG_UART1INPROT_NMEA, 1);   //Enable NMEA on UART1 Input
-    response &= myGNSS.setVal8(UBLOX_CFG_UART1INPROT_RTCM3X, 0); //Disable RTCM on UART1 Input
-
-    if (response == false)
-      Serial.println("SetVal failed");
-    else
-      Serial.println("SetVal succeeded");
-  }
-  else
-    Serial.println("No port change needed");
-
-  //Change speed of UART2
-  uint32_t currentUART2Baud = myGNSS.getVal32(UBLOX_CFG_UART2_BAUDRATE);
-  Serial.print("currentUART2Baud: ");
-  Serial.println(currentUART2Baud);
-
-  if (currentUART2Baud != 57600)
-  {
-    response &= myGNSS.setVal32(UBLOX_CFG_UART2_BAUDRATE, 57600);
-    if (response == false)
-      Serial.println("SetVal failed");
-    else
-      Serial.println("SetVal succeeded");
-  }
-  else
-    Serial.println("No baud change needed");
-
-  Serial.println("Done");
-}
-
-void loop()
-{
-}
diff --git a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/ZED-F9P/Example9_multiSetVal/Example9_multiSetVal.ino b/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/ZED-F9P/Example9_multiSetVal/Example9_multiSetVal.ino
deleted file mode 100644
index 7e7655d..0000000
--- a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/examples/ZED-F9P/Example9_multiSetVal/Example9_multiSetVal.ino
+++ /dev/null
@@ -1,90 +0,0 @@
-/*
-  Send UBX binary commands to enable RTCM sentences on u-blox ZED-F9P module
-  Based on Example7 By: Nathan Seidle
-  SparkFun Electronics
-  Updated by Paul Clark to demonstrate setVal8/16/32, newCfgValset8/16/32, addCfgValset8/16/32 and sendCfgValset8/16/32
-  Date: July 1st, 2019
-  License: MIT. See license file for more information but you can
-  basically do whatever you want with this code.
-
-  u-blox changed how to configure their modules in 2019. As of version 23 of the UBX protocol the
-  UBX-CFG commands are deprecated; they still work, they just recommend using VALSET, VALGET, and VALDEL
-  commands instead. This example shows how to use this new command structure.
-
-  Feel like supporting open source hardware?
-  Buy a board from SparkFun!
-  ZED-F9P RTK2: https://www.sparkfun.com/products/15136
-  NEO-M8P RTK: https://www.sparkfun.com/products/15005
-  SAM-M8Q: https://www.sparkfun.com/products/15106
-
-  Hardware Connections:
-  Plug a Qwiic cable into the GNSS and a RedBoard Qwiic or BlackBoard
-  If you don't have a platform with a Qwiic connection use the SparkFun Qwiic Breadboard Jumper (https://www.sparkfun.com/products/14425)
-  Open the serial monitor at 115200 baud to see the output
-*/
-
-#include <Wire.h> //Needed for I2C to GNSS
-
-#include <SparkFun_u-blox_GNSS_Arduino_Library.h> //http://librarymanager/All#SparkFun_u-blox_GNSS
-SFE_UBLOX_GNSS myGNSS;
-
-void setup()
-{
-  Serial.begin(115200);
-  while (!Serial)
-    ; //Wait for user to open terminal
-  Serial.println("u-blox multi setVal example");
-
-  Wire.begin();
-  Wire.setClock(400000); //Increase I2C clock speed to 400kHz
-
-  if (myGNSS.begin() == false) //Connect to the u-blox module using Wire port
-  {
-    Serial.println(F("u-blox GNSS not detected at default I2C address. Please check wiring. Freezing."));
-    while (1)
-      ;
-  }
-
-  //myGNSS.enableDebugging(); //Enable debug messages over Serial (default)
-  //myGNSS.enableDebugging(SerialUSB); //Enable debug messages over Serial USB
-
-  bool setValueSuccess = true;
-
-  //These key values are hard coded. You can obtain them from the ZED-F9P interface description doc
-  //or from u-center's Messages->CFG->VALSET window. Keys must be 32-bit.
-  //Choose setVal8, setVal16 or setVal32 depending on the required value data width (1, 2 or 4 bytes)
-  //L, U1, I1, E1 and X1 values are 8-bit
-  //U2, I2, E2 and X2 values are 16-bit
-  //U4, I4, R4, E4, X4 values are 32-bit
-
-  setValueSuccess &= myGNSS.setVal8(UBLOX_CFG_NMEA_HIGHPREC, 0); //Enable high precision NMEA (value is 8-bit (L / U1))
-  //setValueSuccess &= myGNSS.setVal16(UBLOX_CFG_RATE_MEAS, 200); //Set measurement rate to 100ms (10Hz update rate) (value is 16-bit (U2))
-  //setValueSuccess &= myGNSS.setVal16(UBLOX_CFG_RATE_MEAS, 200, 1); //Set rate setting in RAM instead of BBR
-  setValueSuccess &= myGNSS.setVal16(UBLOX_CFG_RATE_MEAS, 1000); //Set measurement rate to 1000ms (1Hz update rate) (value is 16-bit (U2))
-
-  //Below is the original way we enabled a single RTCM message on the I2C port. After that, we show how to do the same
-  //but with multiple messages all in one go using newCfgValset, addCfgValset and sendCfgValset.
-  //Original: myGNSS.enableRTCMmessage(UBX_RTCM_1005, COM_PORT_I2C, 1); //Enable message 1005 to output through I2C port, message every second
-
-  //Begin with newCfgValset8/16/32
-  setValueSuccess &= myGNSS.newCfgValset8(UBLOX_CFG_MSGOUT_RTCM_3X_TYPE1005_I2C, 1); //Set output rate of msg 1005 over the I2C port to once per measurement (value is 8-bit (U1))
-  //setValueSuccess &= myGNSS.newCfgValset8(UBLOX_CFG_MSGOUT_RTCM_3X_TYPE1005_I2C, 1, VAL_LAYER_RAM); //Set this and the following settings in RAM only instead of Flash/RAM/BBR
-  //Add extra keyIDs and values using addCfgValset8/16/32
-  setValueSuccess &= myGNSS.addCfgValset8(UBLOX_CFG_MSGOUT_RTCM_3X_TYPE1077_I2C, 1); //Set output rate of msg 1077 over the I2C port to once per measurement (value is 8-bit (U1))
-  setValueSuccess &= myGNSS.addCfgValset8(UBLOX_CFG_MSGOUT_RTCM_3X_TYPE1087_I2C, 1); //Set output rate of msg 1087 over the I2C port to once per measurement (value is 8-bit (U1))
-  setValueSuccess &= myGNSS.addCfgValset8(UBLOX_CFG_MSGOUT_RTCM_3X_TYPE1127_I2C, 1); //Set output rate of msg 1127 over the I2C port to once per measurement (value is 8-bit (U1))
-  setValueSuccess &= myGNSS.addCfgValset8(UBLOX_CFG_MSGOUT_RTCM_3X_TYPE1097_I2C, 1); //Set output rate of msg 1097 over the I2C port to once per measurement (value is 8-bit (U1))
-  // Add the final value and send the packet using sendCfgValset8/16/32
-  setValueSuccess &= myGNSS.sendCfgValset8(UBLOX_CFG_MSGOUT_RTCM_3X_TYPE1230_I2C, 10); //Set output rate of msg 1230 over the I2C port to once every 10 measurements (value is 8-bit (U1))
-
-  if (setValueSuccess == true)
-  {
-    Serial.println("Values were successfully set");
-  }
-  else
-    Serial.println("Value set failed");
-}
-
-void loop()
-{
-}
diff --git a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/img/Contributing.JPG b/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/img/Contributing.JPG
deleted file mode 100644
index 39ebf68b048682d490c560ab5cd4fc67656ae778..0000000000000000000000000000000000000000
GIT binary patch
literal 0
HcmV?d00001

literal 62131
zcmeFZ2{hFI|1UnG5R$TmsO*HuQr1*L6QZmWlVlxZl6{*gLPSCcA%wC`*0BteJ$v@d
zU@Y0U8Os=Eap!Y?_x$et-gEx<|G)op{^$JfIp3Fgoim5m`}KZ3U$5u#cs&=#e~xDX
zXYb!Lz6W4pVgfv6`~Z$|fIEN_OicfL{##={$^1_{#lpgTlJyiT>pz{1or9f??KB%J
z>uIjjr#Uzojg|cjHy7ubf4=`S$v=<(^AzL5$;Qg|&xrrMcKj2-!^ZTOxr~|V3g83}
z6EhFfaXUZ^0AM=FSnWRx{%?)x1T)LYQ;a2@=3oq{Im=i+GxG_?Vo$QLFh++l{tjT_
zIeG4~vi_;_=8mjaym?h#C+4z=->zukvlt>sTz~d5oc%PvfZzooNhxU=SvgfTb&VT0
zHSgRtxMyf&eE-p7ODk&|TRW%c&MvNQ?jAnAe*OW0LBSDkBBP?;#>6Hie@sbD`;?xM
zm;be(u;|<O;>xP(np#v{eM4(odq-#2ukN1Vk<qd7i9eIrx%q{^i%ZKZt82ua-MxL%
z0r~LgAG(+T%>O~we^T~8(Z$1{>jdKrSXlp|i|IrFqciicoV=`j>YTngtE2b%D=M$q
zcyA}>R<y8-U$-FeJ$pHHnqNY7PLlW!Y5$e7|7V1S|G%Q_KMDKqbYTIU%uI~KW99+q
z0cg~`SQ$Vb+J`hs`>~<tgpUq}uC3Um#f93>m)+OlZfzDEv9;I+k4mtV>f_{jJ(%1j
zpIY)6x7=Xu@(K;0_^tTw1iptc!~2gq(}aYR=Qy|^meEh1cN#Q+f8{*CPU?<#lFoPf
zmJtxfAAg8F1|*xAlp`BXWmK*m!NqdIHa4qtJMz$jBtzPFUv8YhEIexgdIJA&Bq_+H
za#Xedwvrs>Ui0g|0RH46LbvdD*3qZ$xq_V^=gn_)T#%Ljk{2s?kJsD)@GsqZ;22Qt
z+GWN|<|a{SS=xLB9y!j0!T0k-c}OkTC6Yb`y_%bfKZuLE`)8}`z_YO`>eqZ0MIqFO
zXx0wHX^|2M*;U11Rc&;pF;y+-sfmr>T_m<G)sAe(rnB0aUnQ%=l`o!R<ui{+YS_Sc
z8{gSQy!d(ug<}Zdl`t*?-p6q=d9i^1-qAUvIa-M);+fK<Yex>R+C`~t`x-*^!}=e!
zDbJD?3+rN8g#Vn)_boPV`N;~%mi>w|2Q}%^cpknfk`&w;w8_h_$=Ot|=#C4D6&6ju
z@Ld*~%afF30XoTReycTB=F5rygF1Ht2C_OkbPSj+!Bj@ltJPPAv4KTqBa6wj2X>{k
zsY{nXKQ$thuA#$&n1`ENkk@IYde67n=#vO`NkYQAxh5n2d3l<a#YhoFy&%t_J>X7|
z`!$vh718+cYetvC^$9VUr(#&{_G`Ug)-kn8apj>rnwdcgd-#*?cK#U2X5}i1d4Njy
z`^v9!e|JAGOMploIhG;*RbF;m+y3J?&^Kd6IGoh5R#up$0MVh#Hx~_L%kTIp{Sly_
zRxVk+jF=M~)3!$<T+xWNq6~RqoASR80BjnkXA?iCXn%HT%IpLa?qi~LRcXl+9Y>o7
zZwtxwu5;eSIO=Vams=ODA2b2YlqG8A<-YQ-v~iq}>pbgpq1W2-7;y3=`TQJgGKbFA
zO?3T9=NO(JqH4??16aWN?w)Z^b|SN;2W<ZaT<zO1c6nypT?zq{rIp(CVi3&Lh!bL1
z@eXydllwYXu-N6c#1(a9nJ|B3fQ{l0P#-_}kjc%?K1cq3YkuO+<AQru-jOojbrgCp
zbROB4A)P})Kll__@X3`F$yIvK9DJ07`i9^@qGH4e(l8O#iJ258X$|=Sx!-2|ATKye
z9s}Yw(Hx5{NJuS7-S}$lkLxDfscDKmJG_a)J+>#ZU-)BOFib!~8fl#D96-233L-BP
zTw5|eqk;nxHnsJ6l~*)KWuE;|Unk)DXM01<OS>mzof9LJ`@?)Fcjzr}VRAp=T?_mo
zfnM-E^yU~`p#S7VxL*_3!>PcRHjX>ymJ*yvtwZNU5^u<@y?F8BE|>}7suZWoL!`a0
zAxbZ7F1K^&C<*|>#2*k+a-vJipFfvfn)VF(n*K_nxTN#-4}X!<>!d`|$oGp%vU-n6
zc0nPvlcC1bjXrh2KaUFcJ!JKy1A-ts0n^w)XGHojz!~``vn8hnwRxUmg=p;#Kj?4}
zs3GTS^JfcZkZe?cEo+9QC#@OHKi@5obFx(7=XoP}BJEk22A%!f0h}2{UL^eR$SC|i
zH~0p_<F#kTm341*tEghcVTR*vnRb`t<Q0{M@6Sx9&Wvp$s?0Vp#{kal1#s+97ipQ)
zMZJ0q5CG02r8mH?^gcWk#+umJ2h$L}w@Ef@ibp@6pnYO2kelo(79%Er)~8`;RmT7h
zP={;#F~F6=J$VeM+=X(A-rH8D;`c$QIbD)EF}XK->5Y3^UcMlPSO6qiWti0r`+HEv
zpA3I&pct#s1vd3q16T1NH%CN^VJKoY=QNe2c1RlnTZn%qCJa%};LrRLczXwA0&Y+9
zqCcB7y!x`;Lc?aN=RpNBwVcBzf>`u(n`sSEnMUQEm~}3Sq_a-L2jPO`RJDG2n-T8#
zD`Q<TRyb40w}R{ecF8E&yhMTX?6#k@n87dL3=2`QLMsowJXcXfF0mj;$Dz5(I_8x)
z$+10Ht=bVKC&L6KmK=#86{EGG3cz2Vjv!<-Vm7n+>KMjDEHX!+`BJFMXsF*jK5E1R
zU~mjzquP08s@05rPMtAnLO<g1YWcb=YJDA@Y56j?_*9)$u7<38$zc(P0xEQ(Y43i&
z{8ovg8;;U|h~3<ugu2u;Zz@=i`yC<~g4lBm2oIua{iBfHO#|o4;+Nl-iFM3KL>Lcm
z?F)bMRF#QB`U<vjT3m^lG1+px)Ei~V$#)Am97`Q$Jn2gB#hj;_Q)H$gV2<V+Yhs+q
z?V<|A%VQggR5j?luvLm$$hXLjFX=;N1<HByoahISHB#!T)aA)2)Fc9-syDk<vs&dm
zNCtvyF?;FRPL%tB?`(z<vk7`N$AC5<&BuzUo=k}7`ay==8uinPs&AwZP~hp_eAUUy
z3gY_9s*W)OW9FRzWC>;#owE~t42T8quNNRz2L_siTaN(*6D5F~UWH*yGn@SrNJewQ
z!t=(QcFnQrp60R={1hr(fts|5TRwbk3xC3`aEeWYJkdEwmWXDs8rGHMGz#aZ-li4$
z<?y)0Tx@XL%I2=Ea?7}oANUueY$|$~sw$HoDqsKReR)saMuEk^XF08%p3Ik9!{M3R
zA#LekIMlP>?Qxv6sk^OgKd$m)-h892q$>oAmGT#>(V%|aCTSl7kY)nMfYnNDDZM>s
zCs7Z_N^gS;9Ro&Gtc$6SXeo#}XZi?+wORZa01JCZ=hN0~2T$Uk?dsLQ@lf6iyP++M
zL2!rdI!aYS+J*1BY>X2j6zRDk<8*cDQ*?$+imV7JbO?*sa4;iT|Jmp$$6sd%8(hQH
z1G*Y9UU=OYLahXASQ^7mGj_{VO`zMvzlMGvxNrF37|`N(vW0QVc2pomHqJgM!!YSN
z>r=#Lh(cq<!1cI^Ecj#&tEb-Vr<@AC4zXD98C<&n;zDSUXj=Zd!_~%7R}2PISBHL&
z-<0JXre#YfY^n$*sm1edi1|U*%y7{phhsogAMF#`fUrREq4Qui53hcu4^aeg+6h%N
z`aTKreF^^C(lET>bhdZI5dC)!KwE=iM&%*0wlP$QU3U<}l$^5@1{TCn>z!ISlREKj
zS2RmX{GC}d+B{5gyWny4_^~4&+oGN3U#m@r){w)=RaY-`nSCfFCk=mAm#3&Lht(!9
zVHUR0O|c|H77Am6+(WqI)Cyn!C7!=JR5Kb}8u94kl!3R<uL}<z@czISpORk%i%}Iv
z5VN@$f`!;cst!5n0GrTe7BM3<R6a|H1p}c@r5<((Ir8??r4I_d&)u%byD7t=+|}oU
zr|Qw-nl;J(#{l4n-yk*(JfVHz>(sq@tk|hlQt<RX+VeDM%0nyX#pT=Rm=i_|0e$TK
z5csg(kJK6>>%wMEM@}Sz;BET((0lgEstTqXZiIC^m!_vl7cAsUZrZD?bkyEY5|?>)
zQ?Ro#!%Jh#!EBgVIRcR$^4yjzwqAZ?7neHF9gH<@3JA8h-wx4HC+NM=s}hJtIK#*a
z$AD;GCDz_zEZJ^(?o6(aQ{EIF7y!)^+XVUrZayd-6uEi}A@4u-jB<<X^$LPufH`FF
z<ORe=bs&mCkiiSF)4J?y7*+-fLeYiN+Ot*1;g<rDPssY;o_J*RQ<d#H7yYz+jmkEk
zozMzA%bg<NbFOb-tIw{<f}1R@7f%-obs`p)5vmpnD+s$S2%efCzs-;~1R>teBS{}|
z&D`7D(eFBUWp$?h<@xkG=Wg#Y4JSYTUb`LmIG##tgx4O};c8zyWTY56d)eN$+99dK
zt<lMpqa0PLEG<uMd-4&TU7un@UT<CQCGsZ{K^+fQM?9@5R}X}~s`p;AIy8>!$8dFZ
z5AwAI?#{M52$JtLEVt%NVo0^a7&m+6OU*yXF(qo~w2Y=571ij6A3TzRYIh@@1JSj&
zkUL*G!n!G{43W7;RU+t-jLEMF5b&5+C~QtoY(2QP;HB5IK(8yP=BIZRE~gqM*|a9$
zQ#t!Io(lC6G&Yopy{+n2y26>HVxrpitGy*7$5(-RW(n<3w^t`oVGpZLY27+y?j@<6
z^>g<Thcs_iM!aM{E>%_yZ-}&1#GGyzd*t3pr&)WgS)fB}n~zEk8-rj}UXD5SvITCe
zQk&>?auosDi5JvmE_(9}mD8pxoB=E(4AhSBr;-*P7(0b@?AXZoofAaYYB61!VBmum
z(`F9(AcNTuvys*g@?@~1BQg-w;w{n4fk|Cjn}-T)+BH?$w-?UE{d#G4UF7qZhjjoZ
zFf=rbe3F>cC3emfN!VQ&q{?reo9|aBR|O58#6l7!icP&PrTmRq_z-?duv^qx>*md6
z9GyL8mSNMMBF=}h)Q{~qPHS}FA&p~d-R)qnx=}Ah`1nDiCBLMjcTEc4?N_;BtGDyw
zU{K!rq&3>o#*vP&aczc`>Cw*KZx6oJ0aJ?oUS+J=z;<y>HgaNA&jm3V{Zp(mt*!I7
z?!`dR143#-m^Uro+x=Ooc<NmKUH3D_hq0Xz^b_(!@&kI#+fi^`vKe85B0VqN?$#{5
z?%hu*v(w}5$b-JR_qL*1x%-k!PnE!Qx6e<&>Ahe-`{fY)5l#K(ia}?_J1a*6UMrVe
z1Kx*B|3~#8a65*VoY0vg1ci%{1MFa@+xQb`^(7E~((fs-1oURCphBu|pk-E)#g4Ja
zE4h>G^=)|&{CT9FtBtnS7mv!ou6h6Z`FHD|REtoRBXdn34cW7jT)3c~>c!1so=!~q
z%S+ERyE2<+{Qarh2f<H*foaG^KSa;q^14^o{4t<ak2^G&3@#^M@5n%qkWpx$t7KGx
z>vA_M_NjN239+)_Z-5o+3`#X#j*H`dZDoy_-1vY*IPVnbnat^YX^B~;arB4@t)#li
ztYe&HJh#oO80}M1`zl)^a5E~6_N5>ng4jO>xD9@e=l*ngCobR3=K~N&%D6^eMeBLb
znu*vt*yF%Y+=izL!VTt`-K;}jAPT(V|J-;kAkXI9{j23G?N7b$F+dX0qE#?C?bbTs
zAA+1fbl4u2=$NnZT1SM6(kfw8FyZ=7>`cXM&e`tyZ6VNMYOvI&tEe@(52aO4S{=4~
zVyEwLlgSwx-5e+%8JG>(oha8kpY|GBvo51l_UvOX?|7Q|$%e}83qrDA5+DEA6;HW%
zX1M2mR>5nQsrfm$*DGID>+DcvT5di$a-lJS3m<6Kk$rY-#Kgn_dl9O@irciib0JBu
zYEXSRzFGxXG0|t1mK+C*6{|g!N$Bd(l^W5TJ4dW-V&F&TIH5vRKmit~(-c`+BF^q3
zL9EWaYicWQmCSru(82?YS;tJf!p8&ts6jhmG|+YfDx^fT-XO^OJpvLY(1Oi60<FNM
zh^NxO;PgX~9@yvVON091&b#M~(UbW}x319E70@p$3)#)<_5JfH4rH)V+TGYSJSaTO
zr^AAL`$l|m706z^lHFPE@6|J*W##OH*vr3!-%s>x_fF7HgEN6k7jHHoeq#QX2WP!R
zoP@Imf=B@bIWnXL3nuBtqSCDAahunlJcFdq1m*aa_wNG5Yp=il3;>)cARszG+`@rc
z78B4*O+YU7t)mg&*z|h!WMj?*QNi%Y`LM4ai~zGPb+9OWt!X0h0{Z&(Ku~AKsgwnv
zdgE_D1-tPX88vkfqFVKIj8?x$w%xC`{&=4D2j-vo6m&!y6~aU@@wGdrYTs?q_wy-8
zO!@||bv8MGlsKgQs326cp|)nsTvr;aw)9aV_8N55P8e+#t!0*~yt94SRFBl5eW2eU
z=g&t~&3&qwezZBXCU$18-+wkNLlE6NSuSlXdC2P|7ptD|(dm_3Jy@&o0K6!D45-EY
z)NT7#YelsKf8UejTNWDJR48=A@cIpMHou!^7bn!j*`=aN<v@j*1-NeB%B$}ORenv~
zo-OrmWDdVK0}<^a_5J=b0)zP-1GveJt?J%xn@AgAG4^(sZI$(1CD=vu@GlY7-`rA`
z@1G0`PG+^ZhGEK%0o}C0s*Bm#2!dXJ*m{EwJeC-Chcq@qRg!+|NR$rO4w?(Wp9y@q
z-0=tpZgaX^SNS>-)RQ!`W|MKd|5ap*u<7QP?_Q0a_-eywT@mv8r8c{ywH_^{GgE<i
zOT;`pi~5IOiFI1WK2pzF<Z=hjoO!|FF}{nL3!#l8USN=zRQ%Cn_+G$c>-RJ8NljSv
zUdh1(`tpL_84v%VNuX<i2fGug%+_n`WVI;J@Fn5<b(MVfg1D|G;HCxFV`9SQo%t~C
zd5tz5DekBlnQ*ZS(=)g={)3n97)a$=1946jd{EFK%h&H81nZu3?>zboJEGUF<Gy7Y
zgOBJrrt6Ob(sBS)Nd$4Gcm8>U>9+7HR<&6aHQGFOZD-?ox=Uc_7rJ?0Y?1fvHbJiU
z@)bx4T7j<ex)?h;fY76$g0mdmr0SR1+swFU_?13-vUbaT!lFYc{d6g!$*9{uaOif@
z*7v%xZC3c0kWy?-lM=9QI8;B^BO|KBFV_t6t&I(;LT5Yqt2TWhWkErqe%Hw@<E|g;
z5^JondTA|qIe^?0I@8bun%PDkf_4(7&<Q4a^<pekk0CU4R_9UsDk)y?_Ha4!OGs~j
zj7S9*C}A-rYXzJ3ihaP}a@i-2C))%82?3h1+Cz?V!qEZw?x$oVhFuz~Yn0{%>Jp!!
zqGklQL?5SGC21SJ{O|*x#!*8mD5=Dob-^-MQ2t?2W2jxK2Bo1Xas9FN2M<K8ZsHu6
zi=4FE4i_M%MeU1maL9V?K}sNy%tPqb(pi0Pwwi3Wf;*S|ut^t~Vxsy|xYCN@(+v)<
zusa^QC&`hHdT%6Nk>B5hmS$2;V_%f<O}$Su5vfo~y@7IfHb1`||Kj?6g+`_IBkD=U
z?Q>$E4r$OCh}{7T(I@N>Z?rAvvsA>`$oMB_EN=@Ylzi8LJ`hKi4_D`(4x7ebV>4E6
zMap0i0a3Rnn#JKGsfaTU16yXCfhCU#9j%k-8S#quqpP(*Ke;Ypy>v~}H4Sm)DA^Mw
zC(Kw_lKoNO2^i*!js_i5f@})VQHdp*y~Wf-MwX`&PY6~cMcqjbCq81=GUz$5qL1O;
z7tyUZ_~-BKUP$u$+xpnC^6{qBV8SuLb5m??J4V~wRU;A&2`eIBS;OMng*plf8f{jM
zwIB9XDF=<)np-@5a!2I-Yr)EsGEdCC#@EW5R40hw;4@|ZQzSY0F1R>+606r%P2^jq
zUYWT*PSu;cN$)6L4|cApPW4CG+<tm`_v@Bnx}f_xsTkndVXg$!?`CN#a0GsitQqF|
znDQXeP{N;p!x=11IZWMO7rA!#vsaSw1xx))&Xq=h4-K*bxIM~N*~}X5%i03&h^k4_
zJT3pT`7(S2E<HpIAdqgL&o6{YQ$SXjA85kfZ}%#PwLBf2qL};?MG4g7Gx{@L;(+{9
z;<;<p+t~O}<5>=<&mDqvf*LNmp|P@Q82Y6$_P{uG{Eo=#&FrNcDk6?|U)F~%GRsJu
zJFvu?ty7WMHA;Bn;V}Tb>_zhbv#%-NRj%jRbcGhm5I+Jcj%x2Sk2%8t4(3j<0vt&G
zozBqrU7`8FM2S<DhaAs8zfSHjaiTn3X_l@UDj*C-qe1f{#qMVz6Uy$XKdxrzeC$ZQ
zsmLFcr`2mH!(*^?|AEpQZRhF*|08%BhMu&)<JgQJ+k`c*o9x>Ug7VP8I8yg8`pz8e
z%$leOAtzqjGGJbTEA(E2L)OVW2b(`A4vCqtcJosTDLh}}#rdGcw=0A+T{kVilB+uH
zyprd#INIUzu?MCj`yugnOhJ!pM--IOJE}*n?si;1#q+D(KqT_E$g9AjZh71QKIc$v
zEo1sxFpLJJL$)96pO()eCoVK%m{$EqY{=kt2Ze@)oNkbg2#Eb5)I~*Ws-M#+!b{hk
zN%AAWxLnMPhV(_AC;POe=?W7j-f5c`li&B4==*{MH?K60%*C3?xzs`4z5NpRb@Cl7
z19$`ay0wa(j^UsiW0IN2zaeGJunR_JXUXB?>uodgBOBV6okVlzxvaKk*h=@@X8P>E
zeYk+02z&G0$SE<UtM5dLOL0!EOLD%=%oB1^YqKih?lrdn-77Vk{Wae;QwkbN9yo!5
zmYyf_8+FGzisa}`AA%w747>7=X~7tHf1OTRKL#*UCkn;}9rMs74{6^9;^&$amnc7V
z)hoyLHy^s&nZ`(D*rG?La5aPJA|=7l+d=M^50|a_o}ZNX20aGEi1GR<u~PwKRD0LC
zX_I}Rf~d(o9npnf0@r?tPcQaT7T^8VLwFWl201##^&55z$TFZ@^l1q8zH$N<w_SlV
zcaWV!;1tJ|B6rqxWe9^Ysyg@ET3?V0LzJXuTre@cxj=Kyov4>9jpm<3p4?_<`C$(Q
zl3ED`QPGOIBAWf1bwkxn4oncwO5<QZSy3%{qY?Omw|t@c2fjP9uI5RqDL3z#>SQ$s
zKz2=nOS~R{RUc!@6Lyl|@0W{*o*1^`<A*{GiKoi)W&%UnMb8n>yc5y5z8d_i_PP!l
z*KW;58ZqJM>=*goo|%&Wv`6LZA;URU1J9l1j@9EU+lR7tWM3v6MED6?Cv88dsHNz>
zeujmX?r2B;eQ!+n&%XU3X3<jQ3zwjKExOs7YC*ei+=M}{7y017A=PVW1sgSpx0>{b
zf<Q<|a8IBMOU}d5(l4kG)pK_5K3Qq^Nv3~&RDIRFf-AnoGUdI(_GVT=pwBI$$;8`G
z$ptV2gWhuAnOP06BB87++d`D1*mL<&=MAr<S)a5#SW*`@#<KTxG?h&p(abk|t&_3v
ziD0#|v{*e9T5le6dM%reAF7`64b-BxNI*MXEShZYRUPVaNwJfBNQwB)DNyDkc2>`Q
zo7Y`bmyF<rvl0hBsM*`mTX%0|TvUfl+em#LX&(Y!?E7$qRa|kTlPNyp><wvoI;M<@
z;$A=6+5K~HB;W0cfNYA}5o!~C3dyjJhWD6Kyo38tpofe?{@CU0{z<RYM^{%p-|>jl
z=QzP`#dVAdZZI^p!gYtnq0&9G(}8UcV>R+Ow~?yrHXHK|L*n7f8&&TjvzM;*i_9&^
zGksiAxpgVm(V#YIoo-DjD<iSyHPUNP_%Ma0L5IB9LrpWRUKjmJ@=rUiVsf^zw)uk6
z*+2H{nyQ+&vgLuoy?<k;`8VG<dA?}3?|aaB0|&Wa_qL?@Vd{rvdM#{Ew<52;A2tt-
zj&7D%feSXqZpkChVyB<jK1l&r8I99z12w#+mp*=ID4*hsy_1uQ-Zi0B`)>2wP3CY0
zDs|~9G&KGQvn})e<C(Zw8hUs+d~qh^TORJkvw#>rtd)U8-t6!yVjX#?*RW7UM;`-9
zf>-M|My)w!8PS(E%z3{}l`caKlza&}SnnL}Nww}16VII>M;qlcl~HR2_pa&R6f9c7
zi|&Q_kV3#Q<{%GXuI^hb;q`)kz~8I)EE?~8#8>;`;|{j(HjOSSq#f2AcF<Y`>w&3S
ztK_c}vqQKc2ZOn7oP68Cga85;EFFs$cIA%#OEjrjLb;za_~u>#-F1m~Of}~DV9euI
zXtXHmK~4X~jiMp<;<e1iT!>0hRQuUU)lGFBI}WJT%#86qFyO=O!fA!VPieb$63V*W
z%qD_z8kRSVwLoApqRX)GNVgAYZ@rH?Eb|`=Ff227u)x%0rx&_q{LMIsLR-&ex!ws;
zrMF>X$3e7PGdE)gH<qwLjtEWXz$j;7TVZ&IaB)tHUi{HPI}$73d8AmBzdm!J;&-*l
zmHCU}R#6iJ;X#X-bN3}tNj872jdCfKbrx?NL4gGfPdjqGKWvT^)TGCswid$2H_wl+
z=@^e7n$1T>$DoyqS9SRaEb1eMC33j_r5JHe-mZ)7$woUBq848-EktA6nJ1{KWO}w1
z@niPIQL6lW&dGJmQ=x*I?7FMHU=WN4omf-WzPh7z$=AgitgQP)<acri0z7PT1o;7+
z#vkFR6a9bo81{sC3~2A=jyljhy{2q`D0*p3d|13b{&AbTYVne|^3~HN4W;*Q-AuCS
zy!mT>AA!Xg)sB0qHYv5yWr_Sh8u~k9T%C&Uc#1tr#Y&{E*<`!t$2dj@-V4gsn>q2W
zJ~lkH5dlK%0JraW;En;HW5ABmmTQT*gZmseHu(+_UN%Qlb;mB{6t6dAk>Vxer_9-_
zOB!$3x#!i%iYrY$w9Iqoi^yel@AuO?1DCQ1HLVzP{SmvxJFEt25_No0Tu@m1v2&x&
zY3JM-_Li=PvN%u>c(JfK1Btd*T83pe1h3E+^77CltvS`z4jLKr%RoXvJWN|X@kzHk
zvIFW#vdfL|Ukq2i*`PIP>*Vs<;=zeh%fw6}3hDPSS|cwoX`x+|hlq*x<L1!)q_|g-
z2?3T&=8r1s4#KWp8J~Ci`{>dOOK{-MA5UpF$(%*<>cOEG|2STJQl?yZPP*%cuIxIN
zo}d>^y)$PY(gtNhkNAB=?V`W`uD+g+>sK`s-bf5ge&P1{n&5?^c_da!>13$U$es?c
z6|R69QPVNKD9X*FYK57E23!qUNDxI}U-Z9id#et+<hACu7}}!)W*E#f&B0z5MH&%c
zLYUg0Jv;f9P%g@2uzSWMTl{M9b{y5Xn2c<<^G_>Um33z69Bw_b*|D341bT}+lU(eJ
z|2+4j9TwO|Y92vLhm;;V@DOXOipW-MMMTkjCkT{;;NE^~+AY_u3A~!v+ACgA?W0nn
zB>dJQwU};9I|hs)YxacSS$MByf_+f?qx(Jbtep%`;T|j+!(C1_|8CEdZ;N}En#zXt
zPXP(DxV@@=|M#2aLm)rkgi-lv3aKpfUS;(=bB6zezpY)fX102`nqA;Q>VYK<cYnuF
zA^_=;*!i}jZ=@@ZDSY5{qs&ufzLeFjG8Ayazjg-PQ<IX|Z!K^?t3G>;242J$1>`mA
zc*X9pGjw*A5Uw@VI$;hei14%zj3b+ZxeIF08Cj_Xf6?o_jjq>Dx{Zn4udH@-F?4-A
z(`&{E5TVYzn}=FIc#Rfc$WkBQw$~MC#x&Q|yvN@itF-i7?q~_PisJ=(Ro$|CEb0|-
za>Z6%tw@qfAcLwlPE%+aL;8gle43j_$_8!h%^Zx}E8WV<SWFH!z+qRAB4#)}BdEm+
z1E<O^`2JSKpEaJ#y3?-Y>XqRaIsb(A(d(4AcA{zlYZkA?z06}k;4h0?nQ8dyXKr|Y
z-$70fU2fw0OxLotbMAIt7;nBJlJjPdzQmFm#|y8Ad{GaP5^Qmg7N1?<aM>xfn9&iQ
z_8r@w>DRU2*oJt3I)_XON&b`D$kYiFjY{{ztpvk7w5tKFMs<)U5JoW_Y?;x>5bn3K
z=f0QFU1=M7Cxml?2gp^KnOH47>Fgsxe+)Vm@cFD3{!I>FS+fE;cx_8Z>(LOb8aL^?
zX$TyBb9>jME`g;>I$0v|bH3q~kBKQscQ5Te0xPr+y-Tsd4h&izI#5<-x>xppzvwj2
zG=GPOiY=oIog0m7sx&j?`<!UsJgbiZZ;SLN(8}}3({{Zl_xs=1lqlr6AI15HJm}DF
zjLz2kkS;J7tMe<)@PU=(#AYJoEBVxJhi2L<_?1<-XpDk$MPqi)7|!PX(!9(Sx2Nyt
zmhVZq;d`=g6kv@e(Yyj8MSSuyod-2FcGHuR<>jj-3YJ;pac05>TE;kdLP0qRXIYLd
z^E0d%asZaW8BX-HA@@`aSM#Mcx@3Z>P<c`ApDcy)J)nP*(VY8V$XKn*$BxTJa~al`
z1ycmSd+I^##XB4%es5?id<o3#<XIPTPOVXx$w;j*D44YW)y=tE&`0ReSMITOd~c{P
z?Dg<|lwPH`)zacf(}MHbb{@jHNs{DcHnC!N5T>cM?v>g!Ha5O?^k?5rez5sG{r5wv
z6HzqxRN7q5xvt#FCk}Q7^TG)g@tUL%U^0|}?5EUvexy8S?tjh9_9^_{6v07<_QkJ^
zl~j!$+Gj(XGlFAGf%0v4+BFOFy&6D&9K>lwDo+mIA3Wow+<Xl3HRgPcN>FlFOtp0I
zb2gZ~ulzCqQe>jEtx=?SFs)#C6{=>2y|-y^c=rIR)M!saJz^k6Swg}l2vWZG&b@@J
z(Mdm(x@(+cH=<X&xhX)g!=8;-O1)h7u|uvjF`4gY>;necmzeATQXpO5)-c>uGjHd4
zZnnVl?LwCH!u1jy=)%4Y`kk?YgUno#`yKwzd0jh3TesLIZ~GP{IY~?Ni6#^W44d{$
zG=^4MS&yl1y1LuGzqo@1ZSE{K?j7W9*JRYL94W@`{6e_z2F=st^-%<Y_g-otjq>(D
ziyCHAV{IL%_w^3mH2tm7+6NXDAjHj&m#4m@JX-T>d)qpe3-c&Ls2&5P4+8AUxK^zr
z?~Q7L^4E}uVbix`Wy*b?{?{zBe=^Db?>qBgvn*A3OdGfmFW=G3N91+5K)ja*QOq8;
zU&Uk9h2p=)l{?nGGUknjeDif%icdkgzO0f(vbI1&Kt$JYHHQ8qXLmgsLraE)1xWw#
z^>K#0MDY)LRdflPiMOA<_RPT;sJ`|1tiZ5aVJ0vIN)M(ZkS~H8G3!Ui0L5R7t1=@{
z`y(oG78ds?FnrL2Y#&erEbT87UlV1CMVtiz<<mbId@pNt^6cx2`+fb&+)MumOZXXh
zs|xixxg#&IVHZTG%?-*k2;!KrB|o%<2rXmJyQe*DhNRmqnZF8Pxn+z<OTq0~@;VGH
zu0le~o(9+Atr6+FQQs*iF2d##!WkCq5y9-OVzX#^nX2nVs8B=7o78jnViuoZyM5B7
zMeQ_lct7mq|2=IB8l!R({6a4f45;ERzDj3$B@5cc+z5pqR6!tHNjzme1g2sp`}*lr
zqx0*V%gl9oF&Z*;P1*lAe99Z&Z>O6T<F+yT2cCh_8<P}1ji0dC!TEX^T5v+e4Vnk!
zjz&w;-YOYq$il~7EG-3OymY#po}g9LGO&f|5UWB`B{I@FI1)A!r0M*oF{k2D8=06Y
zbe-ar-RtO}^xa+5VrQT0=Y$7&vGJn`5~Q)PO-z5qBihvATyw&fu~N6#O>!5VomRNs
ztPS<&fJF&aqsINMu;Jv!pWf@k*KxOhuq!N5?kceb4l&(Rk&$6*QD_Y5z*j)i-lFXn
zrtNTcVK>MqQ=@9~xjw-?;n^Rjnr?}}o_UrEO7}*1!ky3yxNk+WJ$4wqF2s6~zJbi<
zA{k2aTl3BqBEP_J(og8mg&0d>G)?0?Q|&(`ZRzuHQtrWBJ!?+|dF&)iGH^K2exi;0
z&2AtL{N7%#<%kQNDs;{bR^))4Zi=2vz)8B}`rPtTeNX>r>s@>;C%;lG>p(rASWy`c
zcN|_Z0^#hBS%B>v?rTfW<!mI*i?J{O2REiV)W@~hO^@?gUDc51rQf=}s^dF$O~qk_
zJ}>CczeVZ>4y$?UI`y8&!~-xc++_2H_wjm+Y@Z^M;Tuo10&2s-Fq0JIoIE)A>Cg0%
zlj{xK!F$NKOwpjUA|u660wb%3Va%Cec*GD$)dcNkTJ}Z_o-gzsdK4+NZc2_Xuv-<d
zg79~u7?OGAr9}6Xy{lfU`sQ}FHl|gKU?$JS2ud`+dx_!l<l4$eRnM4+3S~YOQ`RQ&
z(on*u_l0!QO;d7Wx|QJArxPb$*ET2TB|+6E?DddnEpUDVRj*s@`g%?k{vBK*G<e*1
zTV!3n)O|*Z?DNg-oQI}*v{bs2^V0O~6W@{`347rj_0x)M2CaZnQ1CH;baPx+a!m-0
zKTCCXoaY^*N_x*pMF0upk!P{8&ar0IOcDnyJwm#7&P6Y_Dhlc~nH$hX8>N~L<d59d
ztIweJ5HAzfSq5{o&r|sA$-=F6(^+r8EWXostZHMs%d0VwLz8Vmu*T~xA#6>0Zn2gC
zsMTBMLGi^hGfw)iqv-HG@Cin?6gkr@;xWOYBIx@i=!JpQOO3`(sRP*2C-R`XF;bVo
zH`_yASavbvR*FeUjQ9_d3{yaDbuU^~Ea!;Oxz>&W=lup*J&pw4LbY{@$r=oMjS6YH
zx_0(Sx`I@#a<^cH6fP!4>xt+!wgE^F{bs1pI9iXuNMpEP(=<lCLwwYkEgt=(V%&F{
z->uYl^PV`1_k%W-4tFRQ+Ni+gV|8pL;CTQJ3>-42!DXp6MhvyJj0q#T%8Ip=@#vlw
z0~}f)T6M8Ee@`;giDlUH9HCu$$`(O71Ca1WT4t!zd`@)!Eh2Y2hwwtauzbRqHGcR-
zio$ft^w$yz4GmDa1Ta-f^-RUr(=A_r+V?!d$`th-)*r3VA&=?SBR`sZ5)6*8$AGY!
z?NOpm2<h=S{PLgm0|$AcS60}(j;DKSw_o9kiL<M-yK|u8xWwx%$q(oxfvHVpkwRYR
z<yyE5y<dz_Sq+Y<&B1}6F*0i63-ya&6tQ$#*5X~_b|-Pk74E&Wa1k=PlAn(KnQ6yx
zT#iQ%SWx+i6LD~5D!6t;`))HY;UGrpM|EB5dfTR-+LYep?=Fed>*@JMe;0pOeO<X=
z{r9Ae8X^u%Ftee{kl(wDk5QFG(<)oFn2X6EinaA`r)rz<HmBeNxl1v9pie;$Ito5+
z_nyGqA2L<(cJK0owH=Mr{L!(@9!D+Gfm_<|I>40}ssx_9S=J4VYc``^Eql1;fcS$#
zxVp@YU(5_`SweKx`lL|ET^CdW*GcxrfHxzp7y;G6&A}=}>xeV#`Ud0nR!REP;y%(R
z3OkCYJ=%7vH7gx5Rxk64G5lKw>keyc$_&FH)VB|FgsE_{&-{h7PRto?;bL;eR&VDK
zcBa3mdsgR`<mVBz$`cic1#boDmSur6cIV>oy@aNZN+Wv0&AdvTO3Vlssa(Z`Z&(M=
zTChv52vE5KjY@Hex+DD5D0B4GgZN)Ir!4NAX^vIe>eTCHm>)<m$h4JWazKNH9N`_7
zKmDQd5!LG#%-F~g9dNl}KNG{&;K)U+RC=y%4)p4y$xO$y*7fP5-(5ab1WcI%9-e%W
ztwD>FCYlT&P})kxw!jh(?B@n>3|gL6Q@GV!XPkN$rJ?+-{*C;V2e@Y2=fbBJa`N21
z?uX7;9lFzRmFM@4Ao}5@J4&xHl|RS|A+wYB8fkgj;<I@2-P^P``XuB`n>6;u%kwlV
zbpZTeW`S=}bFh`NJ$Ye6oG|g00fmaE0-te-S;Y3vjTe-66-%P4s<~kbjc>1(BM>Ss
zL85vY>d#yM(p(L0qI4u{F$ve<pzfweRKCw(h0Sq%WD@lpwyURsm3n@<CMQad%VkVK
zn^_|^^yZwf8TXq1i~`}au2dE6&pG%8`<&aNv5=)=67P#;xffpp;Ig#DEvorEnBAx$
zEy6cTx)tc+nf!q8p?Y+$_Dw#JKgS=Xw~{(?=#ju4`=oOq^VcOLYRGD>yEi>x>2Mk|
zmfRb*Ka5w<>lU@A0O5nydSaJ<k85q83Cl6cu$3OB8h*LxV>GJq#nK&mm*AD8q7wHc
za_Sf$E5Y+CRGk)AgL&O7M)*wt$5m(P*$t^uvaYN#7>$dTZ#t?ViB8>8qg=JVR&92^
zr{%N>3UWi{Wuxw^yed0+C2$L}yIP~1Rz}9}T5DI+`>e1_$wbjE@YwR00$mcM4-Nf|
zE35wDSphWkyXidD!5Oj0WX#MevTO?<oY5HF7gW>Z2|NZEj;WQg0&~oMD?&pR6`s{*
zI2$CbZK>BMZ=U0exAugda9lim`OAr<DT@lhf7{yIIR?C@8xCf`Hf+DIV7UBrPT(xb
zzT*uug{X-Jg|643+Z<OR=f1q>x;Deiae>Fh_56onuV?kz!O_vWXAJX0Prmz^W>;JA
zy<OFRSZdTuEUd3*NN{pzayj{x@lU`x?~IL=0zJ6mxk-kWl5{4sJYSHM*{Y>%1%3us
z8qAc!FASCkCJn4n=5}bQb9*$&vMb}IL%FGf7e#~a^Jb3^Ti`w^$NaS9-WmUmc_xqG
zrm8cX$gp|f$5AEp9f7y1_6D94bO{qrVoiKqT*bK#ws`Z`@=dlsCqEcA3_V_!I?O)6
z46Ne2ryb}`)5AkA%W4lHMHy8!jkdmqOoYZc#j3e&;k6k#qC-<rU_^Ux)>k19-OR7G
z>8|eX97by~=liuIvBvi485Z2XPLz){CKA&&n&z`$9dO;``^3f6WX4q_=6b7Nhz5a?
zSE;0s3%a2o0RrVz%XLX4w&S%E@0ZkHdsQMp!pa5UYtW_BGnue&Bkt2Wh>PkIJzXEc
z^u7lT-0hhPO6}Ic%EZN{rlzl?p=)XPc0BWIZVUHuNgw^_I(dej>GfgBYeF<bCbTu2
z7Fg`fS~6}DJyv?g=>mk{m0JEHQ*_cYB1!SN;!ZT1ZH~B`cAU(SRcv_>II}z_s+A(A
zBS7WeF--a=?{Z`w_Ab<{6ah0UoPk)`X$OaXz{=OA1Qgm&*|+%Yo~w+I=xtERmy6Q~
zJp|byTFiJMa1BD*+fdv2elbf7p)fZnfH&A7{3r~aXyyWaqwla5aMCv8_9E^kmhV=7
za3pWCyDdx8a^Jx*K!H1(8b)EU2^=54P*6`O|NecF9BnziInkcYpI|$pU3S}KM_;n)
z!JEpIxYF-(>Q1XQ>G#Q1B&kNCVMM6jmpcf;@~z>$R}#29GOsPLU@9GJ*f{(ggkC-1
zEV#G3O#LM+QknB*rHK7Tf#60NEUA*-xLyaG@v@l469W+MXzI$^e7O)Io-s_#{zy4T
z(>-7&z;hT!(HskZQ`?g>1HGK^39pPFyuW)4I7ROT6Jj8`JdN~eiXrt%1HG}_lfpk(
zgK%#eIkeq9gO}gDF+D)b63`Bw<}II?hOJW%9EWED4%g{0lZ3Oh8me*-QCgpXkMb4t
zBZq>5O4@WYi~sz&PdZZ7ZVS<#&<gz&{b#Yx;2v~qAeT2Wu?z_xI2w$iK5v+4OE~8)
z%99E`hr88SJ?bkp<~hS*u{1XSxDFM#7zdR5+n6uUS@>9JKSS1VIzG)h-~hA*gsJ1r
zYjG2Ks0GB}j$tg8-hGttYF~_NiY(Sqv68fM#6k8anV1>b8*I<Ir#fkRrk;#l?%Ngi
zwtlA~(thg%imFD@7UPC@dxt7&cGoGB-KpAscigLMS2%S8K8oS}r|FYOU|vkfZ{L|g
zItTSHo!I#@?&HW9h*0U!s4yr=JlM!83Vjf!$ptn~vRA>iG(<;iK^IU=TTYGY=~*^O
zXOWYE7NzWPv)+hyHwFSQk)hrsibdBz#NH4PP#Xhx(cC#?^ar;I{e=`M>-uSL)c`i<
zSSh#KE6NsZEr2j_gGZk;q5CutA`>xuw`<y1F*CG`Zgfb|r$s*-Mss|(xvMJ_=xP_T
ze({mXDD~p3<?nU@^_PdgGe5<T;@wSVPvkBf+TCJPsPo6L!Py~nE^^5{Opu(`q3&>b
zEYzgP#(nVQ`wv*Zf+VcYh|<S+?ZGGk?I?e(l(#pY#;krcXA~zP?_wk(d&*$zA@tzv
zI}68vNf)pvxuokH<}Lq-0dXuo?@0?^6l?<qRVIaeQsm6GvBZ`-1&Up*pJDBNXhKlx
zIzS!hUK-Vg<<125C|q61FxblZf^fmEzA({Nu{V8|3dvXfdplC!QPjy2+n8Q5=~lo$
z(m+SiE;gxds57pFs6(aIs$PWWUHTB2wPf|$YQ`3_6v71EbE|G-_j;aSZgtM?{#L97
zi*b^MN}q)quGjyje@-R6<O|vGr;nS1M9nbTeHIrInQ4w5G0k-??hfSJ?jv0NQNQbI
zeoa=6&(ERcqi(-}WYIni78X*X7|}QsOxGLFs?oj&o7A$dr1wmy;`#sFS->g4*W0b_
zvc{uaMvyM`)#^zdB-Oh3VaYf5D&}V!4)5Fkl|=dH0Ghd{Lxl)Y1x5IE*LIDJ@`{jB
zvp~=B5hWklln+;`0KB!VI)L)E*nrhVSZYSFTk{<30KZ(`+)&lFhoAK6z>2lffIou~
z?KY*MVzewD$Naad>Iv2(Ru2y4C9zX)Qg1}?F<p+CwA4?&ROJKbWF&Kk6h(;>Z~ljB
zyxPE72AxB&mcMiK@@*tF4l-2Z)txAYYLu@Qy~i6SYoI2Tb+k&>Lbi)G9$*&fMt`-n
z2uKR^f?2G#Bk35RK|g1rW%h$2orv1NKZhh^;0uiitR_@&a&$RCoT#)RrV$Ijfg?9>
zKOxk#R1&pC#ZirQgfE%xY!yc3R}s~A%kQ2tS>BEGkFQsV!tdGh=1X5Fe&>gp$yxdU
zoOu^9xqSfIaSbQqNgAV}KmvWc?FFRyeEo>uMTqsdm*WIgnpPrY9OAp%Apx+z`+E?!
zWb|FeDeLbB3#VBCMKUnjsCHrxd4_r`M2S1FXNIk2f6Vvw_qAlB+KS13Z<ycmy^4NS
z9>cnR&NYdXtvin?S-h!<i>s*Ks;z49%MA^w#li7SDz1sX8&6IlfXv8|1TVxX$&P^p
zcT(V$%KDnq!>c=>N*(k!5tU@&E@8mW2o#I;g;MG%a^$?bZ@kwrV4gK<qBC2lF-Wzf
z*NnZJKb;ixY-c%qehisy8$iG%Eh&_V+~qvQy-{r)#@Wkb@Uo>0H?AC9<Ju5XCNx=g
zalr1ArlmrE7+*CMZUP<J$}aBPxhO!guaDYh;21L=1H?RAC<8yS!^`|mrISKJ4kO>B
z%5$0rl{&^hQ+D#{!8hK#3c51TL{T{gKv%*CDKJJTDs~Cq8A9*M*|+wd3d<Cx9EOAr
zOb(31Sr-pk(#m3&9$AdpVHK`!m6kyi-+5)8w$W56Ts5{=9T{8qlh|+Cf0Wv|9<~uW
zL}(<15|MEmXoDh;nJe~UEdtG2V``u*A$z8gN9cIJn^N)5(AVV(N;|IjWCr+Kf4EwF
zQM*yodV^05(?yf+JZRXCgcS{;@A#E>goaAww+F<iOyx~Zc|c!w%*J?~==^>f@ZoOV
zWys2!d<BtT?PiEn-q(!EIDe19!cDIOoIR&>isKp>E48f%iv>+L(-a4piDnzJMS&%=
z>M?U1y-lpvXu=F8Xr6<8AH!|<eHE$D(LY+o*OB~-<@@6Fug~}6>n+=41(A1XIdCq0
zg4R#5KZI2}>&VyC#VuFS^MpSH+MDt}O!Pjf%w=pb$AvTg?_WJ@%#crNhQ*Z`%&iR&
zU%rHx%pi-xps2(G?M5!suO6+sd)9Jr@PzgEUG6uC+0WN(14%ky@EBUQSZ;F7&To1;
z;Z4W;`tr6A=GM(`9$Y^1Pww-*=HwC3YBsfY^}tsp#A`E(BIrEebJSbI`(Y|Q_R7_(
zUkH;mjq<KRCp*`RD387lH~jo&C-Iso0Cts7vZ-oq;B~oc{G+RtdmVOW!*>x{;$Da>
zr0B3m*+xYkp0|cJIhUj$!~B|3ms81%B>jMxocXY0z`Ib6`F{B}q3p)OmVz~+N5gp!
z(gBCpa1DA$?g_5iM><C(sc+?H`6Kz{-oOZwT*hH2U!l$Vk*X$Z_*@N8>m8E&>dcku
zBw6Nug~EK1Ar6;1Y>CX-8{&Zgd8p`tfs^6Qj$!k^NeBL+70odP0gy(i;iiphD}&MA
z6;o>WdUKh=$fTCX7#?2qfqI>mQKQ604H%{R6hj;?)-^VTLtN+`gk_RJ=eM}-MfD<?
zx<r_B)QvH5ZxN72_v`4NW8?^m`YQfB)p~)W%wflRMB91Jh$`>r%Ihc*tCqBiwfvZ*
z!Q=Bv{l!C(&$GcMe4lq8JT5H0>5&v$dB58usdBjUL#xG`C+CJux67utC;Euf=ShA<
zhniyCG<l)(2p02vs5&!C$xvPQBE4U^sr{L(S9wfb=0N7NSK7!c%FW>EtnS5S2*dqK
z&z#4fqFx(TyXf&ZC(2HC#B&>ZiK6qTo}XaAw{ebDie3Dg7xOa9O{<<%t}S0H49=!Q
z@&+)atTbQPT{6#D@@oMqWb1k5hGwOA6S5Ho2W{bZ47YXz2uMMAudWg~>wBOb;yih<
zRWpt*>gKGOf{8FGuVAU@Z~9x&C=k8j;x?}O(KFG8^`~XnyLI@<A+>mBqq=C&gdS?^
zYg2u;d_qM5GMTw&kW={KhtO|5UFaQ(hNubD{K=osVV-xLgyQWqDvc$|xAu$``rYQf
z4?|lI{F`tv1LqQ05x#MhQT@B1`M+0~TNY5z6>`ZH^6FOC)|NyZ{Qj+Pm^rZs$^nLa
zLE{*}cT3<~u^u6zg+{?sIT=B)*nBz<Sq~G!xN#*Th>!P9?DHA^%Wn{^daMWA2!aZX
zE*B4IGB9VjE#TbSGYpP?j;C6R{mWdpl*}I^{>RrDQpE`fI0JGsOEEO_x8EG2mSSYX
zSvqZ-e#+z+(7~9EjVgv`_{e^CW5~s-|9<_yH~&AG@!zcXZ^8Sw+WEKA{r}qJ@R}Q)
zh#eSHTGR+1KgCl!sA7Ej?-z;JuScX=kp=ps5abct^f3U>gCO#5$Y=6e=}m57R>T92
z0ilfA@OJZm8E|;#6O~cN7x59Z^zIli<#P=19y^4Ai*g9w8!x+#0jFVo^%)EFJApH2
z8M(9{5GKVkjL|RhQ_aXvvhDlE8R=Ur13#k!sBbj49)UkCec~>6t!(poxeEe;-J}=)
z90T;Vbr!hy!7UrQVH;t{%H@Nb^|1cfkGk^r$CsK1NT~F~Xaj_qm}|o^;7dH7Mie*(
z@EHEfimh|$d5nVRV*oXcQRt#8PnV+53-k`b$AG$=J{>-qc3Ad0JzN8E&<>^={7(}d
zF{m<QED}urqc;!3tUWpgq#Oe%G1Rsp@JQFcyyjmw2JsEEcMM?oTaN*o5&wSUzaG#3
zpLTWPJG?DtCm7EtEZzthLhLmQ(I#lMvvpz>(H&Fx=^G6ECvV&H@f{aELPJCf!uTH@
z5-fB^K`Gmh4sNPcgSw!TJUxqBo9H0wn2d0J_We#yW_nRg!%@}#02|Sa7BDx}%eN19
z+{l-~<zycePH%T}z@_&h44i2Hms|%fdzrITq+Id88e=HqBmBP>&6m;tp5Y%I_V0c8
z4_*H6efal2{ExQ%-~8~u!4KvJMt$kWfWJ<4j7WqVVo%n?BMNaSxTUv_6{DTD%c#C2
zgUn+12)=-85OD}+M$kK%{HU!~vu?u6OQA4(XLxIst2HkZA~^iV>-@A)hq(VCZ|<*~
zrI`1KT2um^mFmj#geo(x#trxrs0lmg5kN|NDEyZ5r9LT~qal}nWkcw4x=6#1R#~Z!
z!qVwt3XFujUpc$?5L+4y6mz6Ei^Ck2;tyCD5G?XB17OAMmmto$<uLmR8}2H=X2%sB
zUn<vM^j&(Ckjn?7b2T0VGWw4JFU)Aatd}vn3{V5!-JmlN(q}jwv!Y77-Y`BcTo^7W
z-Ixwg{1Hi;34UGy5c6D0r&akJ18!yAq0{w`0bR1%*Dx#BQAC~T7N_+Xd&3m~Rn9)7
zU0sxK*ab7X4OLwie!+>-cyv|yE<3=>{}N{stMqriBPOby;lEDwU)X!^u%^0hUlbKZ
zML?t}D3LDG6e$WwM5T#z=|YquB?3xE0uiKF>C&ZlB3){vD~L#!Py(TsKtc(D6wiA1
z{r27Ze*3uhbMHC#InRB*e<5qlHOKsoF-IR)s1pr<`lglrlLmhIC(V2!>|(en&A{LO
zngD+eg!#V<>HMTYzJ=p^zvsNZ0Vs4%@D-LKIQlb~xCok*1@E330dFmU$SyTEOlDZ{
z!SVBGrnXYMR|OemtDa`f5q<OtAM4Ygtd3PYS6}pgn#CzyDmnuHpTFhGdmyZVP0Ko@
zT?6fJGf{7;68Z-yN8Oo72Y||OvHbLvV_?#=Wvahi2!;ISCrz~O?|T!uo73DJp;eQF
z!5Gg5&`PTFN3!whNE*j~qH$5rn@;>OIuly_`y+oRM?xkD?-!5hGxOdp*Vh_(-&7lZ
zcuGuM&n9(7=b^r^o>J5&0pk}xZVDzpz&}f_SVLt5CFMW$_RZ;i>mc*}F@M|-HGEl7
z+<X4+ey-ftpUzd}y-+HAmhmpWv61Qj+0ICRZPYM`^~eIc&ZC$+m&5^ks>6ND5@%S&
zAFkX{@LZ_dH^%ZNqCMtE2vu8kj)@Z8C`(Pg2LX<`{^|xLiF%b8h)XMipmQw*)I~qD
zv>ikT)8BrZg|{UUK!<B^dtWZ_LhLs`_@RB)U=Uj$6vC+>{hn+v*v$O0Scohjw^uWs
zlnT>rt~$wk!P^>jGVCVmLT|8hqKj8W0rCzw;%;?vC)j>z?AzwH=&S}PsR(^{qk(%q
z+%w$z8qrGE=B7<;LV*0G;EImZlkJu7QK3hRF1>z#8vHAqVt%ERDXY#2_-{DK{S5<u
zktXZUhnkqJOk)ca75oNi@UJ+uGgJ*H!?V2@YT7EGrdpBir7OGr3J?obX9B4~(yBhf
zo7=j)_CrLHycQj+_Yv?PzDJ*|j?t8Fn*p_q*7}gdL>>%3@k#5O{4z%GWBiugn?E-6
zkpWFy=WCj!96ViQP0Xp4dyht?&1E%*P1P(pJUxZa9AApH3iGU_PmUdAwOz8+kyLwc
zh5Yqvf8)Kfi8aH+uy<wyXO?E}ooO`--cEm#_}uMjY}<0I{&&9rf?+Ca;GwM`JbPjJ
zg#F=Wl&|+(u_1%S%nad{%}}0QXL$1IvWE|?Y+it9i|MlSBnSSmaYN5Hief~4j8q>e
zq*-$g`%3jg{iuNyR)s5P%#({8@s>Ge(`I{NLTK7ID&Pe)k(f-fC36$6W4^e7&clp|
z(7D?#wCV!GwOK3^#^&7>vLaG?y%k3;2B`9;4Nhzdlr+jCe+9<x!l9^Hc)pya=f(7w
z>~&7Vs#M>$nnozsN1&ZRo55Etos0^$?^uPog!x$08e<l1t3Q%OxG^NMCW@~!)i27k
zWVH^}inusz{G-n$%=Oh<><ua1_=a|8%`PSS7T3sd1)llad>E#X@;zTVgJJg;!7a~N
zpTep9{^m*JT*uf`h8-fu-n7wryr=t{Nc|mux_2)8r1={U_>Zdt^7SJiZ0&UKoCS(0
zOw+kALW`DVWlbjM-D$al3(MA}CopL^Iq7Cb)l#Pf+il$g!>E5W8+{z}+E1RSjR}cT
z01kuRNP}Y4wv%6naJrlXu4>|-IblP8`K!~ZyPw!Dzf}=7ha^`3Y1uQa+cr15r@oDQ
zSUB}hcu&Z#q>SqtgU(Q|*ul@k_}H7~`nIr_uG$yYtCLfBrf|Ku&oZA&rqm+kp3L*{
zornoWvr2&@S}*#Vb&R7?oG?$<A2qEHV=e6j?D8MW6(5)z+n&Gqncr1iUBhYoz;k!h
z7h`Z4YukWSro|L{!8>2UBiur38Lm<X^gpD3h+Z0UPrV>hY1mPGdCs4XF5o2gk@+Eq
z-LKtC-=`a;te|U=Z)&%=C4wC>_zz<-Nv1Q-wCg%2^;GSKOfF%Msxn)@;D2^%TeiO~
z*VCFyqy@+cuYxhn``*B)29`-rvoB*)4GYhvqTpilJ1hkrAJ52n9<43<zp4eQ6j<iV
zB``8?D22J^zEwR~4)#pv1U!{+D)W>P<B<dFsPUU^-6~2aYFGa8fF-^=SvFb_hniY8
zt*_L4paB=7nt8^~8%;+wS6%CN?Rm&-I^u@ho8004HgLFp@K>MIfPd?e`Wf#T?S?$6
z^i;6ao$zR6Yj#*HCShx7>LH0&JK>^}Rb={+sqpdK{J-iC4faFK;E=I@^l~k+dqs%}
z+x>{BnVi(T+Y3AJWFHo-R1bJGm+<z5(nap~-;Xz5$$5SHN|_Iwd({YMKWy?iLu>L;
zgO8a{lp;s-o3EOr{V!*&qm-gXsuOiSiF=+sd7_KeP&-QDWj<NqJF=!W0#P~PTQD>H
zb$dp8W<XNu+?*0vDvo#g{Dm)<kJ@ctC|9;7s`hX~qOk~@p$flI?hIeWv=^{?ZE*~T
z@Kx9+Tj)_qNhV9EX>>AU-RUbi{(tTJIIE#1I$Ej;#Px&dVpiVxE!S2t+tGQkVdt_x
zMjhfI6IHHok2b*b1tTM4-7(X@b&_QOUQ;b43CQ-?=y_@jpwoQMFD?N%=~w0P`<r&;
z?0X$^GxAkjMKxnq(V9#qJHGo(g@f=@hkgAnTW4Rc{;Qp@o3IvYI$B3=A3;bG+ek2?
zKH&`|Oi@BT*ZvUoa9_5SrdA`u>Upw}Q5x3q*^c1$*v%hm(HOn*v!9=4G_|&uX&{4J
zFO4W%_sw~1CwIF$szg()3mZ80@{6M<f7JyWZ@$Z=$*~cYmlwl?Qu75yf>RE7fVQdu
z#AGYHE5VYI;@+<)66&}(>>hFN;@rKwx~29R-9!Pk9bVWq{%dU)Id>66nJp?*meK~^
z=P`iKV#?1Abi7h+<6@8-LbbPlyY0Z`1GP)K^5l-xEF1Hk(=;nIT|oZw8z6CEsTw}T
z@{`7e?O^98O<eBbPns-SLKb;`YY%Yx6|TaA!3$hM6kp(eTsaWwgU`N~d<XPe=4$*H
znO`G%G21uqvGTXUFNch^tF7G4(I~UD3m5d}#0B2+UF1;pc+oKe`#}~lZKZ&^dOoKP
zV3mqj&k~b{wTTgmO>+klQtKj2>`WVzB96R-r!R(4eIAb1b;h~O_a(n;@YeK3nuPMk
zg#4s&K(ix*sGJbun{F9A7pbX~iz2K1ak#swte-t^?DMLl>vM*#)=ov+iQE9)zN;}G
zk=BD+v#>B6i4aA6gF%PS@M}W46`67Und$Cc&Qh{X9Ipx@XpcHqPgi7$o_pHPAGFYv
zB>adRPER8b2GTPz_2Fb5+`T#2%vrqa>S0JkGh_~XZrMyz@)Y;d(56njT$`jMpImxO
z@*@AMClqF74WpO7>1I3X1>^l9V2f;oXxwx`3zw$Q_7qWTpO8Xq17RnGUWY_0u;tiO
zFOJttUq!3n1uGc}O6PBjtBIlJb;7%E^W-(8q-@IcLA{-6wb>_lPDh$``dy-qfLL1D
zso&72U?OwcY+fRBby41P6zxaV<IURTUHPU^&Ua%He54ZxHGPX|mM5nsI~|wbYLFUK
zhGRxcgb~5QyXXNG<ZT~_wTQT<z^IA0L)JohMcs5Aj2Q!;jOfwzL-}!iuh}|pPw)`K
zNaGNpF!|!gC~w0GH<PX7yM{Sk&Q>+{R>#GKkUDeb_d%V_HK6+OPAFueWZPH1N5(>M
zY!+{rmFpGX1D@o(N0e8p|5%r*`f<2c<hG>U{A-PiFDqMXGq7J*1bSly{NC!`B|hID
z#@QoV2Ntm9A){bH<Zij25#;7UraFn4*w>|~KuLFt((jt##T7>E*%ve#@5L}$Q0jVg
z>P;4mA8Uz~=O&UrWG{rD#CRN!z57;VY2c*a<Y5{72-#+yiJ5HJ40sFM$ELH#6_{;p
z3QYQOGxpNw%PnKSj%|rv>#TTKJ#&C>6w%~-ZeF;K1d-_m6$QKkE@|tw;xlUdo1y0l
z5-}7r^?DxT4`K}EUv+O-r&kN}KRI{jXw&6u!hJLGNz-B!cv1%E$<^F(z|Nb6L!|s(
z!5An-R0-HqysAH$L$-6Vo;rdD`X|V{V#IjSTBCv^&&77_5al-Ep2M?sv2S`$_a@nM
z6+z<ec*?jVv9<G{(5y4f;6mag<_Yc$M<)H~@*BMn^(u*Zti`xab0ze0T>E<L8RiFL
zgn(Olvfw70N4!W?yRy=IC~=D@lLJzEJ&CgZd}jX=`)XgBrw>8`o{IKt@{53iQZi3b
za$&kS_$RzflxKlmU8-lhbMVV)DEi0P@MABJUc%ZY{p9}JZi`0&Y?4>MTAUBH6|VWx
zqzY8d*1RA-|4GB;ToV&+gnEZp?G$5Dtt7tQS(S6lW|*5)KZjY{)VQ!=6+}jeYO<w?
zM&kqTK=^jU!`Bc-sF6esvy}R67rpw~@&1`ZK2e3+39Pa;dIv?@Xq?uheSXFyd6=jS
zv=a2YO~jJGFeSWE)SkeYJJWGu$AgfE5gY6%c<7#)*n^Xp>Ju6_7wju?LwsnBvnX8G
z^XQjyUje}c7CJ%#F@>Z=Og-G`R=kO00&?qX)V3ttF5NIP>o;ph#l{{p({xHTPc!a5
zrdB{->}1PuzO(Gub&^bY=(ovo>H5Se;L@!3J3Z$4{Dq@)Me<IS#xB`>vn;tQ3->Ln
z4n&rPkkdKH#!Lr5_3`J19Qbn}q2}NOyeFCZ5bj!cNYV;F^{Gfo!H2L6G>JDM=KiFy
z1|l@zLv=_nsFI1C8Pg6TU2=1#hzBEGkd8i`qhK3&MAWfUeAPJiri;;qA}t$J*ny&x
zu6t}mDCsQFGi8Mg$p6Z5m7g?2E6^RP=uaBIj-NE<+E|HPTXNj30U*|+c>@S+%x!J#
z;lXp-*z9=*2_0e<#+-d0bAQ|6l|&d8cB^nr*Wr6-epKX;HhoLY+snP(C&LoXWvjK3
zKy!3&6z<Jx)2rKJAm`Cu^E%MrM0ffY#j!6#k|nfCVuLI+0WK<9^WSKC43zx>7hQ>!
zA{S=Ffy-21AJ8z=;k(C7rL{ZRV~Xr#KM0{SXVk{m9{FqJLC>zsMDS~!>iL#(kbArB
zQk2?&1f@(-2m-q~Oukl%0TJ)+-iGMQH1>pPHtR)kGM|YKar=x@UQ#Q{wC?>ZYjuIQ
zxe$|uWkGoP=pg<51Pc<y)8<G(;@j!6SB`mExDT7={9>>1ELTK}G7Yk$x+xQ=zL+w*
z_e}9l)a&GjV+y(zkCidqgTvbR&9u4vq3C3&=(Wk|2~(+(Z~9*)Rr$ZIOnw?*y!3)r
zE(UuX13$BN$QXnHg@q^$TjEuaISv+lA3uBuw=c&!j;V30*!c~xhCj9;e+apVxQVC`
zNyBTmuQPFY?RRkVHl*SuV1oM+cCm7yc{jQi!S7DTy=b|ndfRpA9f${}MyYImnF|vg
zu5g5D5ljhLh0_k-HNEOQWT>K5(FEh1#LGUn@-kHdq!Wiu)EStt)t7weamNfqLztza
z_~uoRg$`SO3Op5Nt8&lYjeStHFP!Xiw&EYx`}|g2-ute7I_TY%DHDF0BYU@5kL(~e
zI`CFN1ELW(<60mM-+}{A>zO=WTv!k$`l@~XT7I**q1j3qmdAw0!-Fz)^`wn{lD>rz
z$;V5-2V5J{Q*PD<l>hBAoq?9)Iy!harq(&hjmCp}q-7T4>AQT@KyGYZ^njPjb%y#k
z%LgAxufoFwr^nXGsbmTFiM&HL4yO#{iL6y;m4UBF6p1j`KzR?h-3krZ>gmVrtBv}d
z6Re!uVu+wO5x^(*_vil@;eD1WltS&rho*>`%7zBV-PQ3of;;@AiAgPte2Rwz?QMn9
z-D$)vM=D&h%JDibDyB^sdpCY4g+`TOnHyi&dh4jOmLBz%zod~qzIvOjDph}}F1ZDX
zT}L$7m+!x_7>n|@;v(OE)l^iGL^WG|cG$9oQw>zSM%?er;-15K1Yv4$=7?~rxL1$r
zh_h4%-9yr&BtojC=CNY}O?+AvM|Sd6pM7F#ra8d`C?L*E7l~<YeyqT~Qi=&7i_~#5
zk2;st8oNbsz%Q*EzDk_VnxJ*P$D3qaK9^XIz3=kb$?tASpwUXXcYV*+#F%r;TY5u0
zusfJQ{*<Zu(_&*g4)&M#N|l6W)H$K{Hj(opOJ>b_G(F3!(I)M%*g)<<-GdTX*a39Q
z-q*7wqR{4+mbn>RNby<o?!J3nn(5&)7%y>;l0u^QvclL#Ngv_6H|qmA2lXtFiuwA~
zGJZgC<OsmNK{T$f<&Anl)yjo2)FUv>L1`q2Xw{*}Sx?-0?_juJZwe1B9I24LWFIwF
z=}ZW<_(ofA696UNF%iVvjQ3!6B`AiG#E9A*rmcydh3Xi}Z7H?#_f;Qi@xchj6j~2_
z-b+=2Km&W%(VTz+Nv^n0ajq+gtzvh})*f&Qn+r_H7p~`;K2O&-#b$D4X2`wBtdMaw
zM^!^ywfhUkGT@5f*(mU~oIRYN1UvGRCfi|jmjml-%ZjYo+W2gG<wt$AJ56WNEf6kh
zjRKu$<t57wQ?IPp7p@s`?$t1V6=KSRCO0Z9zP@}+I<HdAXz7;Tq<S0QWy^s8*adr_
z2&KdDP%{u!MyPA5Q_L@Uyyhv^5OHaE>I*;O%gw3fW59qKk%BrQltH3lxd(b?lJanM
zXyHwOPdEC2H)a*y@s$YvM3uwGv>_u}Z{XP@Fr}eVnnr{$?(-uG@{}wGLTVsK9pR+{
zLWJj|iEen+`Gx!KZ$BS=UIkQwEOafnD=Q`oRLCukhrE7T4+WClu!y6o<zn3pbKaPA
zetLqy5O%3n=LqAtY_f>>o?R$iR{gp}x8K<s{Bm%GTiU9-nwV32h_Ad}!?2Ulne)#x
zr{@!I9g}}-ZGAC7`Q>-5jGJxiy$MFWXG4}b#GIX=BBom=752RvTDI_3*Lc!M+|DA>
zTu}%}2e0)4cXP{AvK5(DTTj_rj|$?@5u9tiDE;G02+LdzXp@Nj4mIYb!cny$J;t$@
z`|6C%$z7ny+|I+oNSIJAP<E%<0T}R1;5pV|L^E$D-^j2^{dk4K#9Y=xlDxfVjQphc
z_4@>mA=FfN|9;wwiT#0&tYARR=w~-$kX-KM(9yh}k!CcGs118_mgA^dLw>B$X+@nj
zr7zv;LhsA%YZ(n1wWvsz`ofmNT)2Ir%rc`z9e{mm>f|n9H!fr8@p?VLXaU9ZF|4a{
zD%Eor_MFd8c|{mi`b)LVja7>k^t@;@(35US$?-h@wk!W@m%rsGV6wEyQ)SjbH4>k;
z&T?&WthWk`NlmNouE(4$?~Z{Ns$Z`Q>RUDPV6QZLJjoNkDA{Rk#29z1o((9KWoSKa
z4|HH@_Q7Pa$`qDCXL#_>D<jgdn%R<OrtQ`;1f9^_D8m^RsV1f4Ut%MgD*HY5q$oco
z*1hs~%zYhg#5cFfgTUUagUD2P{^q!i&39rS!Gx0alLp8kW%L{8B%@iW3LO}UKskQ@
zT@4>?#udVTs{rGvM<1`FL?+98K~_hxQGw!`zG=#QAEVSQX)eZTKe%H%3I99}Aju->
zC(Yr-y<8Jh>7g~Cr}zl}ZDcZAqnhG+g1GUUDcG#-kFjzZ@4qHL+(&FoGlrC|p)O&^
z-&9njPMVFCXT89!IObef3>1DA^e)kp)*E(?5&9)3Sr5PpkOFV6xfzdRQfoMq=M*rH
zIfJjC{Zd#eQJD~<-L$(%3FIt~9IMyqa&>g&QkIf@@0NJ}X<`CSi8g@g@!->^Claj~
z%FC{snVG3n-aDhl%&UCfz~CY<T<OR#+kjqVp@=%E1vyLDrbsEQ5#<s~O!I!yc#`YT
zUyzGyW7t(cb4DY=Yho=FCp23aMuvFS^t`v<p5|qtHr}~@(P}!qB*p{rw)KSlj3VWo
zq9_?CptYZKlvNsT)}WnX8LJiXbwjHcp&<|VziUb<-nV2Y=_aavBeKM1O8Q}QN+-b2
zOVCjJ#ggQ#7WVO^=&#Ms7!5W?4jk(ue7Ya(PYbc-RM(E~fo0*g2yO<tPhciTz<UT`
z19zIVUVaSdA??>0rrLWo#rDi%YHy%uc)e(!smh)?Wz-vXqQBHun;3=BK1M!`Q*No<
zBB%!JNnG^Ga9>}-v-N~LJtqb<nG&u&&y%EKHxZHkx~ccLXf9%<pRG^h_!Zqp2X%&%
z)RtXOs>b1$*8O?!`)Q7k>XHWG5k?i|GXu?frcPcx8xfA>#7TlteH|Vgiovs3r1kkY
z8mW(N3dTXfa>^kbO_!6@4HO}_4Ky6joDvdRaGpSS8!8^Bq*B@KhKR^6ZZ2Hdc&&(b
zsOK1}AEWvHThy)UT5k=O!Y&a<ajWYKZ`F_Yfrd_t<m5BjyNZ8-mTw%k){jwUn#^w(
zChe$j6Dl<=rm@QfW5XMDHPc?Q8(f%j?M~_?{Cm!C)fngF#>8+n1%a})YK48dpqO};
zTP!!36f~|U>KTd}3m-&_EH_Q-ca2-HJG1oQIeNw#BaxgoxIA_4N<P!c)#@2<hLisL
zDwFrlMXq&AayWe#*+N}$lenpl3=&wk*LOr3&~Z?OR@MqEmO}^%1iu|kHy6FyM8cc6
zmqx>h?xV0%cv}odH1#Zq)5}T=FA*xyd?^>ER8@-{snupSS8~r^9bWx%D`=1B;!fL<
zk5>!K^WHyqGVcl+podZ=@RqPEgPV%H7Up)`mx*tRQ1@Kt2H4Hlm}K5H`t*t}j+oxG
zZkW9MLZHot%cFIV))%d;d{HD~fAMPznw%W3Ep-6iw)gbxE-(<*?3Ly;T}5qbtNKj1
znojx@?;4WVD0!_{r@i#skX*^S#3(#V2l6agtSCZ)-mdP|=!Qe1oG3lRr%0CNFt$8<
z@$~9okgxU(it^r140bo35P}a*nh~qQ`4vAE2SS`DpNznsdgo0JoQjr_6bLko>nTnV
zkmUEDO6>k#9M!WX5r(e19nuXtt1T1?dpchVNVMr0WuKRGuD(ZCZ`Ala$USm0y{myO
z($Aya#{*$}>}XCBr)OlLSUFtYS-dXZ2WezI^X^ga+DL|4u}fFocxKhmcx@as`B{V2
z&{ZP$abiX;?0&--wx)EnxdAu!9;H=OdL}jknt$ITl0&!Y^qNb<#l6qc9d__-A3wl=
zspL}wteI)8mS^D`wOC&)v1XXO<(zn!x$BgDMG+Yn2VJ%Sw6y1SigJ{UU3s8+qv9zd
zUD>MKR#;&Z{_*%L8%op|LMqj<6FjkB&&-R8U$}1-hq_#)629Ox^UWlz9q369?rdDh
zavo9SB|`4uX-ydmB_igMd+Hm%6+gWe6!B2%RJm1jKemF+Pc6LYPG5?wh|$y|gL*&c
zp5ZRq8EJ9I`M@(SZriUBjrbytPVQL8d+JsanSGc-YP0Ho{P2o+ScMk~<0Zxxt)&Wd
z<;C8Log3r4RahygbXtq=&Se%J#-_+OXt-s$;l2^kz4VJvC|MR`E=01>-bitaIj@PS
zv^f&ZJGPDPXLWh7E*$&X_iHh)IEK}za?of1FFQ`9JFrJ>PBtx##cC9iK|N-&W4+6r
zpyM$8+|^XS2#yf4Yxw|PjLKv2N#O=}y>O&`fB6((UZtMD|Af5&1F31Y>F^Kpx_?O~
z1yiKJLy}mt5W+Ks!VFx!F%UNN%9ba5-mG7+z5V8%PkxZa$_@IHNAL65TWU)M-=|%?
zbGQVw!OLH!8bRb059_CA5T)>OGv9tHeJ}bP`2yaf5^piw_KJ2!beuyu4I@*TpHkz@
zF#}2KJ3jQRQSC%QyL?2bXZ;u9j-Zpetp*M=F+D6^Q1x0s5ep|j#fVAFeM^~lv{fB(
zUypLa%&eWyIjX@0&3Gu+&#F9~+;4C2uIG%+w{5QV-mB@g$T)~}AEF}WC(Tixb$4{j
zB<Y}LcR!hWw7GmcBe^4niTsF&_GFKl2VF4t@&kq7H44{Eox?WgKQ;>Kv}`ZR7Gb<c
z6`!Q#*-fiGJ2!XUdn-awidfiXO6PBbR}J5FX8N%XVUp@s)f#b!gc|vs4qw(!<ifg!
ziDC1iHvy-Ps^b0f%6rRwPZnaDit;j&B><+o&_W{hK{gR0W{K0-L5T)s-<i$nH1n<P
zL`0{3%>WA8;W2X=?~VwEDfv*6ZNy{de$uc{qqOrLO9QRy#N(QtAV0Wt8#cT>5q0r3
zQ-aJsvQ{W!!wnMV$2bg7NMnl*Cf8cq8n>fgKPEV6m8PpLv@x~=xsPwYVg*e$I4AUO
zkVeA_>J!8|6<?QOwmnX+x9~xii775L@9qHZ+Z%IPsNDIPw7CeokU*H3pF0zSJ*Q@O
zylXM+ersjpsHJGNKv!#e=z6J0_e-gI{$sVlDq{}oe!PHIlAqiSx}b^~xX@8dl;|FN
zu|mMDCo``SK7_h;dzp?JD~q~#BN}Xsj=dE55T`vZr61V<ku`^NaKOn)GoGX`KvO9&
z?I@D#z!-;~Tv{3%nDY!;Y#rHjGrK~z&6Vz=G#!uo2CfxfJ;wH=Nk!dKQRmeB1q3f1
z(b;lO1qY89=s>W~tOFyYFk^1Ug5%CGBTwm;RP`kWm79B!kEc{=j(%16Y__rF9o}qX
z+(YnXW8Sx%pD_Ytikt6v6Opnzje<|t&kMOvkkJ0~ph`uAcNvk-Jb@VBVZlELuT>kG
zRK=%L#o13SbXwQPQN3~#f2f&!^8H$Rg{v;;SeKi2Gy>y{+UkfU`j}-fRw95<VSa)3
zd|wk*iCsivsQ6{hJ8FMnN&oX;A=PuN^dH$hdr(rk^6KPrq8WURq8=R!T|U@7$l`~A
zh<Hc*Ek7EfF3hUP!E}B#+0f!zZQZC4$J@sR@w{Iyt>@B(&pxcU6Pu(tSdF-1?1DU5
z3jxNX%sO{acuC!_X8dOt$M!@ZoHIh<TYT~At&zxyvQ4MR8K(@c^m8S+&6k|%2c6(4
zDT8mYp`|S(8cuY+4fD4v-}fD()+wr2jk<%_SEy`*yXf;?CGg{G5Eh$ZH(!fMlaC}r
zL>}Dc@mIWWO=Xgo-;iL`vl-(uyDx%^>PPKRhSjt1jVN0x3z&1w$keEdc`ib2OS&lq
zNE)unTzyXx9pspBX|sOD@{QZK4eTALqgbDlAkZf*hIP(pklk^R)F!*^G-b8Wu@ywU
zf@E#GXrZSp42d0p^NKSUkHEs`N;UZ&H-)1i_!E`6>zr;`XC<86Z(^dy_7~IC9-Xz%
zwyD=Y6Z=^J#hR6ZW};*{KgBV1NQ7`21=mh%X+DCfjMPwEwbD8{WS!4MFjlNW6<i)H
zo%OiK6B#u1<846COOj-GR#i?-Es_qt3fG)=z2&Km*My84?E9j5h%EC$fo@v?hsmL}
z&fH$ry2Jzpd3i6yeQnmq_Y|XEY<FF1g9^Darq=CTGf1)2j6DJS(#H+%0G-`bFq#F0
z9zHki&#cT|Z56_~f6E-RxY307EfbR|bgBxirO#70*SMQkcr~W^Slk^_Rd}m=f4>vT
z%`jOe(_A5F@(VIED=TH&JfxEz;jai9q4ID=DL3EF_9Au4C|<4#%9xKETUt%J6?kt;
z<5I6#N&2~S_NuS;7&J8TLLD(bVmjj;4(sx$Vh~0L)BNd)CXb|{ZR7m(JnfGOYUXvS
zHLpuK=h-I78boC%-jt+59Uj@U8FDMlYe`e{&(XMTXgpy7s$sd1m~@NnF|S&9C&OG1
z+t`@6Z1x7CJi+%|I3%KpR4Z+uS5Y#l(O}lHfS%1j5JAFbFrn5KyrsP>aUb(A^;sc~
z46WCVVVO~tN=?0~>k-c%j*C>A2soFt5G2S~V-<)W?{;P(rfJ~rXA0mABj%>TrbM3t
z2UDl)64>2l+#@5-^v~U!?r}4y`%SSooM2&QmLUU4ZC^lcx@HeN9rr!Sw)MTbM%d#{
zNo^tmtIqA9v<PRUJkpHZI_%YBK=hxVR^Ib9GRCV0`hiyEl9CHnIcs}YIZSKbI>;}m
zoz2mzQs;CuVJ$wQ{`j>j&zy7kE7*(zPJ%2V5vs_Kud6L4x*9c)iaNoRUlvdH73GIF
zA6??`G*fRL`cbdTiRcgQZi}hfoP(yRTd7;ud)_S-eX7x|M(TJW5<C7@wMe?n3pC3_
z=Ce?U>1-U2Xf~QRw;USWcrGyJ*TrdHsn$E}t!rvF*=>3^Hej>t)8*5T*cl}E)5m(v
z8)0TJ6t-$3_9d(t;o}Ep{7K_VLIdTJxM~a{ssJYu>JC3mM0OmGhh4^*kABO~pY%H1
z@8TSGxO`u4!Csa<HsXSn>ous?sJ>gog_s2$Ip?FmaYJX3DA$L0KsE3!B^Gwb$#zhl
z{iHEOejKl8zQ+)&ks+NPb}8R2;r;R1d)u!ARr0sdPjwBKw|4RYo@Nu+7kA`H&d<3z
zxCr>tb;)k%{(~72`Hy?_YK39-U6QAmKd3D7UEa|fRDMPdMmXO6CCK{k0oM6WSJI?%
z3~9|YHGiZASudv+ciuMgY{dyBy2?vkhSXkQE?`!ZHu<<S^_G#F#>2Sq7}C|BG*mw<
z7{`VLvc)C<A-=N@Slh45fo!%bjch<I!A}}GUU)wct^J6m&I7$Qe~nbKqKUUojQKbd
z^(|n78d=zuCSKu~1G>Gwi{pS*+y*%5p2vj1tBlB^NTPPL0Y@-=?lQHH#7Gg`Bw-b`
zCl$W>W^g@2%Ya)VH|Mhv16RiiHNt%J)dko_SCGMQXPX138=zUK7w=B%l^Pn=JmnCU
zw-U#)rg^B>JB3vfM05wsrQMIN%?P*e&NOrZszM-06-b+N%%U8!?bwnP?-4wI(&Ur^
z8wxBy{G{nF0(9BWe&2r5>>4<NaS5Y8X^5k~g@igfD*PUx-awY%0698kFk6RgmcYO*
z2=)G<HubD8i0WSl-(LaBP);fWYS5iYFliTvbP-`88(TkVlnsZ0VsK5MdLjz=1=Cv!
zpq{Lhpx|@DfU1u#0oQ&2?Hq!L=YG;$1Nv_|cA<B#b^>mxa3ncwH;a7v5KK7+#C5j5
z=l;h^M*Ug11EvWyHN3o#dM*_>HqKlsh=&B|;)4b?faR+X9Mt?HIP?j4c^8Zmpg#Rc
zb9OQUxnd9okev;Fz_JP^D(%7#PfP%HE7_{Qtb#}b&uxRMkrXyFZL)wgoGPvQpU{aq
z_6a_)0-x0&cTjoiIpE(*Spa_oK%8x%Avo?00E1nI>Yp^oyD`5k1CfDuEP!p{hga*e
zhz}fqh>%0fe?lWl`D*}%-+_wH<O85-uM-f;$TkFAW3&c9Mu0Zpf|#Ql1SrU53xryN
zK)){53ef4F&JXlYlp>h{9!zjHP|+%}!$b_8GXF_)w@jOQ5;%^}S?U1wn1Hy@cbNey
z<uv%$wO|0T{`vU+PAx*+v42Mk2+#1bi5g^_MP>%hBUUl~R{*lYe_7|C`ae6qf1(!l
zIUSiALZwB11!K5gdQwhTf{DBUaCv<J`uqp>uKc>re;eo^)DNZu3KRJh{2lzig>l0F
z5{$29)#c|If`N&JpXZ|ZqF^j#bB~@d?OrIw#SnOaDBU0tU_GmfsGl_X-^bUSvA_Wx
zw;(d(IS4kyh&c)$#-N;9UO}|dA1*5o33gYD>fABaxM<&kIoXu*daCnCIxtzckHBjf
zPxwx}&l+SkZ+`x$${ny%NImFVD__`4Dd@bN+zmaAY9xg3aQKrVs9&;z^_%e0JBI`T
zk(!dbI*vZFC3+8*cb_V&0@EJ><alHePov2$F&hA24oCpIeKPzj1@};TkSy^`{gFiT
z^+E^NgJgEYom*>PU#Hgp>8S+s<0*gn2>x%m@%!23{_$Bm_Gg~Iu<kDc!Z3yaa0{7&
zg3pQoiND|~03^$sfE+pk_{E}i-<zbMe`TCsxzrT=H!1(ywV>kv%=TB{{>C77K;uI|
z%neKzQjgXHslK_t-5#9(+UdVtJpad^DP4e6&@JjW0N6;&8u;I!^BW+ej(&C16=e=o
zK3#H+=KRqN;C}l9063JMssEXW{^AA!Hqalj>&9-K@Cg1Vj4FROiPQbpr}SL;jdTA+
zm49fh|DwwOcN|o#%=(C(Ro4QJ=OZNG#ygx@#e)=*JsaomI4Sl)oi^VVbt_C%E_Q0o
z-mRv4;!<))@b&GZ;Y7MwG?`t$E9(MPglq;lCCOKT#CTKK?N*ZD8&9}YT+BsrCr@>2
zlcy>)cLK4t#|9o}rVv2%fNpyih3;z9ipBWyJs1|RjX2_dym9S8a@@mf*1<Q;c<*sm
zvGeqxE#5E1dmQ_MoUKP!I(H7BNL02MvIvp^-VUf5C-(^mLJ0Yxn4{vrvTsB$Q0jBl
zX?jt8-!-avo)1h5#Hs<?#U6erh&*_)3L(cs8fIvSiFxD)L#@LFk3($k+hf!HZx=s#
z!LOqw$NlP3AuXo9bonLudQjJR5^r8!T3x@HveQ5%32}mQ`C~+I)vH^AN24z2=l9#*
z?C+aNDA*iTD__9o49yhIW|40>6OsWN1^SaFnK2Q_H<E(?efgF|Jpw_=rH-%`bwiwB
zOR7XX%v=_FPmumX&7TEgnt-{upj`-Lnp9xWhjbnASwR1PNxTijHq9tNI@L<*PnyM!
zeE7B|2)BqtL8xH}>SH-TU*#X)+>b2+uJcjAmn-|%b^dt-zP#24C=pzM5~2T-Mh^!b
zkZ6H#15U|*d-;ife>p(L|93Cf1wI{~3Hj^O?@<MtBH$}r41m=M=roHxb4>pYqBPB@
z07^XA5JEipm#W4GTnAaD5@cGyvQ<4y_NRLLt^*o56VMh{3@`|v%TkX3J5B}#g8xPX
zz|#2pPW-mKIb+Ba6ZkA2pjs(JsZ#yQkT~YQ?Bg{Hx`V}i1ob``1N~S}_5Xk-9*0mL
z`<?wK(5U{?9;8Vv3l89&JsV)3fU?_jWm_6_a99Osmq2dWd;+}K3$&a(gFFD<^)F)o
zpG0g=WK|*g9GDPDbR_AJW%2BPg;6$475y<8H}sGnsnf&O+hTJ~;p!lV$L!Cq#s|@+
zzc__Jfqui}Z;V!2*!JU!rlyuDv=Lwct>?}|G2wXQSMMC&!N8&z4EA(#wV?-Pb8+oz
z%x};A&Y(u4S^fEc{)x`<fBpYYB>WeB{)LZ!;p2a<1N{GiKf*%vEc^zo0g+9~NCrpm
z#Pk*nBU-1A2*4Vc!_`v0b#nuX!XdL7J*%$rzZK=duz&|jfzl+3oXyIrW*CSRs3%#J
z7tN^VtzP41ol>h<Qjs@19ovol9?<rPvN4W9M8Ic1&d-enQ4l3wU{k!=>W~JX#q^qs
z*0`qIBQ;}k(QKTTNcTw^qiG1vHQ`GcnH?t+`(iU`pyJ-n6`?-+r;VCFF5*9M-})r|
z*VUqg8=ed4gdFM1@ru`|Z^hqR<2DbA(M>RacW$iDrqNWaT|PN>Q&yuUC*f^euARk$
z3avunop)tgJoA*O3lsb`&5qN%PK4pgX}=CQ&d8C4&_F4NiQ$GMg2!H&_qXKtQwj=Y
z1md-s?3_S-u1Smsr-^*Gp2r(gfl~8;G<&(EG>X43kbHbtn^8_|2p3ro+dLzCy>;=$
zw-81)-KxT%s~ljDW@o}pd`K|dT6@w;om&WR5$hvRQ0eaMCyLz^a8xvL%zx7--g}Jq
z^SrCzJ$G7s)4)#}OKrw=_<7`Pj*Q|td_i0s89cfvAyjQ0-$!~jLZem@)s*r2oZNxe
zhO+D})cCdH@SZDouf^&4+StN_+;$rFmIL6k$OzmpCO88V0X||Uo7#6@)TSYPF3!a9
zLgLJHf!le#PfuO$xY5x*$(lmGL9^B%qd}+0((_^r3%;N(Q}eoVYio1F!T{%I|Bz=#
zUh`F+Kym`-ZOIh)>O@E}bcT;8OV@!FQ6G69z?ESOiL-a+wY_4aTpM>c5S$#<lWRSD
zW_(SS%u><~!~rOYZkIT8LzL^|?}!z4Fvf~j{pdOxbX`<a;+sl0q$Sh!%f+#pc`3@W
z>twrL*IiAcWJ$`a-SxErml7FZQ8uw3TLe3xpN_wV)~LH+^>tumNn?Y6rQw{{LYyz%
zlKr7ms?@Hfai3J7TUEUY)9$ekShGuW#cR-l&b(5!?Mua+d#+UOJq?m2`6o?Z6ms4T
zP7L=b|JDMy&L0bciMs{@Qi);DLr7LSfO^d3Or{3|{hTH_L&(HQ_^b&~Ty-@jwAnG&
z>+br)H-@7%{o;;J8^-p7)6@K7a2JF0dnYZ=#IdP5M#KkNMIJLv*r;clU?Ow_o^?eT
zG?5)x3|uG8bbzk|lvp4d&}k?U@Yn2%vwMhhtEk)ilM)J`;wX?&%$GQDl{uG}6Rf!k
zaQ!!Y465g`Il!j}9A{!Dd*KTGYbjP5qtcKnv>hisF_S7${gA4X9=SHWs1w{4)!ijP
zBsGWYy$shfHHR!ZK@VNl{ZJdyU#F9OU|Y~vXl--G!awY=Fi^qd>HNT{)mKaLU{p=Z
zvmp`EErO)?_g?>b$FgH*N{<B`xv+40ur%SKS!7}=?+v~11oL4Y>W>lda`z+<6#{U}
ztoqxoQ%e{;zSMRPA73mUi96ypmg#V?e#$cEZp!qB4}2ci->N!fNLW_v3;gLF5t`#=
z?h$D}93{k@3WjY-(o-+KR*Y3`s4Fzk+)|m~l^K3hJF?50hS6p=A>Qk#Kdj4@o!F&_
zqcoa|J#HN6s^m|9cn|2Bvqyc83*YQk7#eim-n?0?zTM*j$41?w!W@w}AlD1e3V-eZ
z+L?C*PzInPv;xwGyhIkk({-|QTEv!6DoBsMJCe1b91{gG{lkTpmD)*nPGC;{P<uJ8
z?5H~L$mz`RcwN2JJ}P%2EEPjG=c#*r_iHsryu4AL^@|CxunOIIX}uVU&L%2D;l9-H
zjwbVkVwgC|Pgr`tAa&cWg;H4rABd`_9?zok#{BkOL?MlLdTJBa(aLAa3VHk&&iaaQ
zV2nCjSmv1CRJa2)xA;k8yUHGSkG1+hQlm0Iktfno`Pr?w`xhB+#J@h3Z(V<Nf0Pp_
z$NmM*SAM6szOM3H^S3|{@>dGv{)QDR2RO^_Z4gE)evUq3OQO>h8#R`1WxwzlM)I)@
z67rq%5Fh&(`1BnM^7V_CNMJS^waM?*i9DdX?mw95pH_YFS^P8nH_p)gl@0|Z$((yp
z1(lA4ecn*^Y@ds9lamU)f*;igVHa3#J!u+#c`Rx@GbiG5(;pEO&hV;x-Sp$IRda2;
zZgu#rO)*288%h_0I-R~`^p;t@73QO}vdS*8I7tk74}181QXjX}kV|}{X|h-gZIL0!
zf26IvrEVp0L8Rr<gR14LN_4ck@6A&of7qD;ObpWk%(%T&J-Vy;pu>2`{d^!HxlZ;J
z(AfLJ3jT9osqlspZ;kN8@jr@*M<dUY{5|gdN|N88!FG?zQqDp>JCBjTMu||F@z0$Z
z3ke^o-ItHOOz!{I|8CjiW%OPVqq6+vCf?sq{C7U>CdT5y_lU}KKWd%NqT#lyI}lU*
zVu^VEhL4ROqfxZ&BA`?gtH<-lJk)8<$*xq@QXxQXJ#OSr0@Fd*<iFaTt~H1Cp8@h;
z!xE-O%*rP7;x<g{L!FV;y9bDJsgdL_agV3WAFBfMQrKepMJp>_`Zw{vK1CPkC$!=x
zkLL(;%eYFynuY{Q#A}XXwym|R9^Y;@x|(8hWQP?mqx0dQGCknfgTs7^JuvCq{QKV2
z#Gj~_8g6*E>CbYo8HoX7<8fPaiuD)~24@pw5Shn188zM28V2{a&CA`GxVV3<9oHi-
z8vD^d{ekXiyCYB0cj>8J#BZYDcM(-=P+!ECy`VQ}&GE<8-*jg3R^viKocA16oU2z4
z&1;f9^)_s`bD}hwo+=5QKJ|(A@N`If=C$Ew=UIv@WLR9eJGOM9tH|^*t6k>@wSfDu
zYiAk^>CPOv^eI;pRt^`LLHlO3fSxopngi*uh<$U&s3#Dd{)6<ek?2G+f;+Z|8bG}o
z=rkpC4Km4lD6s+LXa%7OF<{T+MaP5s&B<uj@I~qs>Nx1MAKki4qi2+#5bQQCI2-=F
zK548G9lEi5P;uGPz~+9E^0T`Jub*6dkm*&}hY+jfu0!ropu~)=-|nB^Z(W01%{F;v
z>x~}Cf~5ro`K4`Q{Xw~p-)9o8)OlCkPnlZFwDw6+qF)kx`O(m`3lyn%j(BM<28-kb
zl2kI!4mK~=ll<z7?-imBqB4q?9`rUvGoEmHVJ|P%SwWEfgBWXYlqUq>*b%r!@I_NE
zbUTN|>68Ff%t`kM&!OqanL9@pzzNzJBxK7z)uP!D9jf4*L)6wCDwo!TXbd~;ts^S!
z-<nVJOFGDMacT>)0jkDxRmal!+Vk@?!!N6=Eg*{ROGArWe?m%8zO{T6=#Rh1`7dPg
zUt;!;FiQ;=4cPdjM7UB#|F4huOPO@|7bX6oR{!s!#Nq-(D(Tb*_w5SV`q|TwRCj4s
z;5u>{Ta*wRGXA#k)=3|0;D#VlN093a@RfJPtrzAW9BN+!?eDFkjL7gc$lf-1_o2b<
zUI|@g*5JP^UOzi{TW>2}vMG@Tcen|bHr(pO+i&1IhpH-To39={O3!{~mPYC3?3*``
z1VFNNVWJ>&QV?dhBCFI1ME4t41zGT_Kq$jbu>n1cRFSNApv@h=Gc?p#xP$gYatEk(
zxy{_{Q>$2jx>Spfi0Fs6Le(jZdUihojtLXmj{AS+H(IW%1ag0fb->&~<+<BT4>Zjk
zo5ji?4+kA$^S^Rmt#7IEvJSk4%06P|P0z}skaIdd-Ni5`Z>nIo5@XbR)$(QYw%@#_
z>0x1xp&{0<MY|6j3_qf%=yhx!8Mr6G=>_U&<nSlUmYc1~ruL7p<EI45^lpS*j8xm0
zO*|E6EqLXVW$cwsqALEdXLbv#nnP@!l&;9i@AD7{5Y|Isj)^>YB<$iTDI95ih9Qq_
zmYw7}tKBYUc85|duE;YpP^d90OxEzuw)fD?i-i_=v-oCSz&3ZvpYOj|oOtzarDdnE
z={6W;I|twBAjy#3akg(@zH^|^?_Px%_o0F;_Dq88wT|V-VvPsiHp-AUUR|FYPY-{0
zm&K^?d$X4E#w{y#Qxth@`oiYS2}%R`2nG=X=*4(QNNryO!tru_YlwdG02D1`ZzA}R
z_RNFePoIC%w5EYe&>uF-fwVNEjmc~vwq%vsrf?sm8-B`<7#95_ZDla$CgCZBnJf($
z{13dG2}5a0ql!GMMs+wZo2a0TI7R1L<3}p@^`?#*>P#}nBo$R|B{02PLOyhBkwo7g
z7TYMB4Mz<P2?U(9)G0o9<#fsW7eHCr?UEPHEP{)MMls4zKcTVtk|!<c_H(P!($Fvc
z>bIr$z4;trKOESZ*9@tTQ`Q?yv@V=?d*Z{av+5aFvyGa1GT>A)V;L!0G8s@O4@y|@
zdBxfE=n3GRiC+Il*BHc|?NE2f0h1|wycvDSY9OFmf=2*$?D(k=>TNdlM|C`#FgDT)
zvdWO36!kl|)F8EQKB5#Im`eMCXt||?(`u?{v&S@KGAQ%MLFr8_RRZLFZ#vpCRBhYv
zK{@y2nNUzeN;#tStUWh9-Ui)40*6|#w&4A8izZA_eWe`)qZ<FR%h7}j*(xTR?;Z@@
zUA%w%j^5<>3YZ3V?K_o2sZ=n;`gwO#$<(^h#_*RLQ`1w52i9VI*B54w(>Yu%0j9Fk
zF_cp~Aq?(lrpeWw`y+0<Rb$T0N;dBK>!|27c%cPEoj=*p(bHMM^;5h;6-T%*yUdi|
zL;awHM;4`?!)EdaWX;>2I+1Rg6Iz>E8d@2<Lo=yjN#9%&Cm;Nzk%S505fQEDreT)2
zMMR{SE#4@Cdeg*99cJYIl-9*ewDCkjzsr+jpP>VS=fY)9n$9IQCq^FdId?G=t7nC<
z()edfkWjhgNa-l1*}T+(<YI?L_dwIA-2CbJ!c?*BaFp^n9${*9`cba0ZPHtZwi`f?
z5;Y<e13#rSr#5~MA6?KmgW!Tp10`nxc_-`J=kjl;x-m3MdgB|vEET3T^*?iIWut`p
zaT4!3`gut?Y7u}L5ORD(Pva43?XwPY1=+>MH`Hbx)*IdUa%2AMi!z9d@aeoOG`8js
zbRRIy=vMi_`(mDzJC@7$uA6~HI4+2LEVPXC1J0C}-stjq8^?;~fy=o12*oSZ?{H97
zJ0XkJ-I;d9FzXCi9;0qExa%khJ#d%*;v745d%9-uq{&mR`R%F)s+E|dN&?Prz}&5u
z{l-$A+XonhqWN)*xy4?R&a7S`hTqGcLv%+4!&jfjip{qKFP(fMv7{kx=|S5bz9!3l
zXw(j(g<YQov-eflo7zsetJgp!n1I$N_K7=I&w$A;W+vg}U~j+YPLAm7H_ziCG019U
z2n>|%#d7a^>lrVA28Y_gPn*qUfC#tZbxnE`9Nr_w4eXGtSNYLSh;cE|=_0$otjdeX
z7Pf*6Xq!*@7r-%btgc1Oy<i|wwKDN$UsC^CE*o6xeg68_k=kijS23+*0w>WQGr+Y1
zViqMsFluBY-#PHbHM!#z?~~3>IMoH*RH(JX9C!v`8=5MgA3v`g1%C==%tAS6hv`WN
zBE<T7Q6j4o!zWfM3E4;D`#6)+hpx9yES=ByQfosS!k=ut=0F2ZpEio#ZT$z8IBFqg
z>nz$Ub6KT23wzyeX>r`9GL35Xpfb<zc>~Xq<Olw<+O;Da@2Nw9`jdW-^6OG-HpeJm
z3Vk$hr{|54ToujtCQ2dBd`kmI{Jtulqr7p`<|5y17=JD%W;rA-l(gx{mLJh!cfK-4
zJ6P5>;Is0j^t;{M=Z)I}Ap8fmAyjGdJ@`4;J)BV(8WV&LanA}mM1<CmVnD_~X~j>P
zuR%!{Co5t<<cTMrHkJPz=Von@B^Ohp;5qBahw%)kg)puk`nHy4uP4R*Ku=7GuWY`L
zeIR#j_o^B~9_P6M#-ZCdyQulj`OsIv<;5%2M2~gdF_=aPlw){xSh5L~7SR-Dv%N3=
z$cZvxJ5ldro7!^Apzx~W%G?!1x^?ojU}lCy?)R0z5rGTk2MJldx=u5ddWI;%q<$OF
zoq-lbR>%LO39g}^)Z{&!G@@j>X&AjR_+Um7mVG$uJ+^TtNntjD-|5(eOHkwxcs7;$
z{1EkwLo0onZoHwUk#2pnFI?ZhqWOMoNn$#~oxbH$?=)XkKFrr_oRQ0Udy4=+K|X~;
zbZnh9c1Tr8BxqnIfYI$;Wk~x}Z4oX12;~zOKFg~Mc^@C}kRCU(@$PnUba#dOs`tZJ
zA5dR8L@P+&8ZLN0(<`F2mJZ0{-DGF+uNc3hWR5q$RVc!A8a1sdKOvgwl*^W5Hsx@x
zsZ!Pm<fZO*z$8^jd7eL2vWZe;sv~-1z^CDD@_zDP6}%C|xJ^h{YGQu69JU~fpyBh5
z{D=elP)w|R;aMW!s7|Rain6?Dv?}eLxV+(uqf)im4^W1Agqd5-A-ZFtT1{}msS3+P
zK@&{f4mr)6Q*AIK`@SS|vRJ(F+S;wYGE*Rv0%&p14@CD-ZW_b~>95qm4eD@gAKu&q
z181k+_Sz@hz-Pr+jVKru!*r_ai1x)^^V)S|qR&OMv|B1OnBPZXd0umw9Pfl_wyKc>
zU}G~ci%DW$S@U`53%fOV#dy5rR@<w(WQE4s<w*T@ovuO)Cb9R_Z=BL2@!pb7DJJ6g
zzaDMBKf$!*vmdI+K(y`h11{UZ5d9&sJqDeXeQuEFM=^fAACDDWG>^4wC#+%5*}BC0
zN6x<W-U<Nh$B+OjjRV*oH)0{6Ek3-#{@uYscvRZQQ4W0-mS!xzDG)xPc%SR(qx1JK
zu^xFe9k(>o?{}jvQ}?CO%zE#pgW%*MYJEF|I+cf=I9T1OC$pLnLK-M3U}#KGCSTQu
zfVEBdDdL-l!D|PZw?$N-5tMU0zC{n-zk8l7%BgznHBE1TiMyY)7YT#(SAfn!f?g>$
z;8nX*Q*hYvQ1<~AFVntu57bP~`pb*LoXREVpIg@Ii)=D?h<;@M^zmRuJHJ^2=h<N)
ziSLRD-P63vMKRMHmXPw|PnphTPkzSYO0S$HHrn58GL`rGBkj?N**r=>>-nr>MB5IW
zy&uo;2KmBLL6B=95n)s{QWI*!Wr3n!aWY(!x6J0)SeJ;Sefj#eivJ_0?30Sg$c!nJ
zg`tZc{Oj&3{{BM#y=Vd?AKfq5+$vDq4!cV1!CQSg4C&z7ieT=~wx?c>F~$+fZQPHC
zC5e1A-*lT+!I-HF1Pi71qHL0GF4_eSy}#2e=He$w%*RJ-2es1UJ<7|8`*(5RP{u+8
z^i^R%4TG%SxPmNH3SSrhoZ!hmE+$rDs<z}AFawRfDlBh#j&oNV6+&=nAjaaV+kyHC
z1^KyYeJZm&MXz_q1b_TnQMGu6J=EvY)XKKT3uoKr#vg+RX%IngZj&1wheBNg6YzEj
zm-Fs=)N`-Q8BM_Dd(%i6uT`Ag!_WArMqePYQ$!9HvE6%~@ea-PzE>4C)A_3{sFvx4
zjoQb>CW>Z!0@m1tv^~_9$@{qrTVgg9r8z|1a-lFqcA~RRgc*cI)i>XCO8mnI(PIWo
z=ju`S9gY^JWRUKBn)V-RuExMOq_fGIlpHC*U93M~Lrb_}+9#7tN#*V_xsK;U_cV)*
zWLwq9Y&UM!#r3kAe_~Y(n}xrgVJ6zoYie|Io(O^Ft-Y#Cd7ArJx?1iYL7w?aO%TsO
zB4@Wy0z-JinIqpudmu)7x`fuDOPh5RDYDqYL)Jt^b$3I!N2?FE{BYCDwqxsul@igH
zq-H@@34jVaNr;OVMm(T?Gx#u+suY;??e?N$g{#=QrX0gQL(${SPghHKAR8)3TzA&#
zW(oYcDQ_@CEB{(D3LcfC8(L#-P%9rQx|gLKeTT2M;eWLE-BC^b*}kYKDj<Rs0U;{A
z2_j9ZfHWf_AT>ag-jN<45T*B~fPjGX-lW&iJ0iUkihv-21Oy@p@txoN?%X@hT{ExE
zT5ru;{&7~|99B-)+2>pKr)-%E0y*sbF4s<|jQm0{<Q=T6I2q?<a^EYn%`BehCreI@
zJ6nddyIuCBzxF6wK1cH>1C%iO3nXV7HW>!qdh@~4xAu^}_Gp2zI|JH|#-4{`!`>ca
zC#9*fYNz2fG1qa^%Uo@8!IBIS<$f%N`JI`oEP7fMmDTlAcOqSSomgt>n}h9OqXx5i
zmj22c9LA{;x*BN3LfFV^Mq6^TXbG?yFjNPxAba*GVAghx#=&W{jbF5EnI2+{jMx*$
z6z)978*cWiuG)Oy$lC7@Zp~;p4f4Cb2p7ZX1>O35D8Tm^=X$0FGjXC3D#~(CdvxXQ
z4-Hzqql4U~-p6FxJXAH}7kG2*7l;EUXBu%lT%F^Y!Y~t?#BJ3zWJB~mI5*kx{JaUj
z|Chxd+Z^JYP>DYAB!OW!Wt(R@thGtvc5_83->daFlXmZmv+w0jwg>_?0D@izc8-fw
z8GfP!ZCpzM+<6LqW_i|6a9ap>?!kESp%eK$?ta-}>bJKE&8JH4Hn*UBSIcMyF3OuZ
z<J$vOPc_tW8d$Qm%?@QbYC$(+*3B;B)p7JLflDmRp<ov0WTNb4*`gL$V##+aWKct>
z#KAtgOpUV+ZiT1Ek@tEBzwz~Ah$wY;V1BI5DgXgv)2ni~lRQG@Rm=7S%Cgfjd=?>d
ztO|^aRSh%g#hr5Jn)#MTK*Ot1f~wJjkPPK&%z?&@F?)LYa=vzw7|+B^CL1AzV5tf<
zk~8!X5s@`b2+tOx-IElNJvx`&W8<Vv(7yNXk+<4>&o$zu%oR}_1J^6269an)gz42Z
zdr)eZ|F~76!>8O0uMMZFq$&mj8gj9H=eP~f3!DljTrM!<!gpY2Hft>JB#>6z&6$}$
zqhvk4plXoQeD^B$$G++?U)2RFwkjd1(6WJWW(ScIpv4MO@L(a8eH@MGMxCHPekP1!
zre8^`t(4<9JxbYGC8yly@q3YBPWhZIW~N7m4qYa)ZufSo{pSp%x9+kRjIG_L_Tt-*
zaljSgAHd~LqiZt48|{g_6RkW5GZ+o3JB2;vG&;@B*#dU#YAAAN%GsckqxPW|9M7nr
zmR!-6U*C-fES!Q_Jg9SQl?S`L7wbaz_#ws<Ox>av?{sf#oNvhJuQhX#p1yjUzm!-Z
z<Ce~WV^|Sn#AQ62JoLRX@~nC4yW+|q*0a%CP-K7aRvk?LT{2kp$H151c8S%n0j;Pe
zK(v~dRe~?f*=tEE67iT?+(lxfngD#KPIvAniPr&HkUMnFymQr#S;{G_vYjhv*Qvza
ziB*1uN^;)NUp0McYEFhpkJ7;<*!;~%Sh`GsmeG5?ayTb$y$IL~+;H<jQ9;%0mRaQ5
zYfs8@9j8VUTPH+0)dWnfUTi2&O<^8=iik|@tMmQL2Wii!+6)0a>(6OT5^iPU4!R|S
zT0(1U#_zzPUL_0f-j<)pWE|CC{byJTV?RDDUFTf&;JkSnE_-&7a1JNVFWKFaRu@Ll
zEH=TtfrL*%CHd@98zTK@*>5_5Ven#i36c`>R~JZHtq+Xdj2l}m4n~1ydKNvBcCLI<
zUUh&->2w}4l6*8Ca9T|igoWaIoGue&uw>mjSjT|OG)w$rjBMNo^&@Lb8?B{{lQoE@
z!+KI(Ec;c}B+4*miVwoBa_5OM1m)8rSvCTQ8rKRX{n{#k16!=Mn2sxtm#im3w(bZZ
zJZY1j4u7Qis2V8*v0*k~-YoaP)!^A+RBMQcBnXy1xp2^LN>RNDPv3;dmoGNFU`bzB
z0a3r9S8<L#qp`u@8cm<r$_xuA_$Nt~lRuGq5$A`XvPRAB;~<@JFcq*<&4}QvTYWO4
z0MXN7=5GF{S=VUD8%=Pc!2M$+5v&P6-O~0z3=m?m4DTH@)B$;1e_<VtCkHROSheoJ
za1?|)#d`KIg@h4UR?5Q|#3T`sWz}F`UOC*ukU*>PokOmVX=UswTkfx4nugnWa<+Zk
z(IgGcA3m`<D#4{O0P}93_9M|WPo+uG)B?9sj_)$U0xCL<O$n{40=JS4sbnUN_&()b
z{7Ete##h_EBKES9XoMZJ-tq4=s+`ypJwI87wugfY=WH0JBkCCLZB-fxyd8@V?fw#!
zoJ<$S|6y7a>$8jsX_drD;mNydlk~*+Tq$=1Z4l1+i*rT_E2}Bwsh-g=bKM)#j-~#}
zFIDfBS4B!s;^)ENzNVFx`W{;#2KzOp78`5w9dr(xj5V=j5q^TO%^u_hY4;VU8~G8f
z<ICk?OJvbK8gz=;y`|L*l6lFp^8q<h`n5M&dqR0;25vZ#W&q1vbHopc@;MD+Z>r#_
z%J-rz5zq``B`L(s*szC+Y7xxZQn)oYl`pzf<?HEQu(Y*zZO%yDnSYo+o=u*b{}XuU
z%rV8Z>k25C3G`Z8Y1J6mwBhe$uHwH;)Of+SKxofPPIMnz8ABf{k%9v+%Nnh*ziGK&
z(4%&!fjyEVl%gg*Jp^}Mklzdt$;*0_SgExTG#fUxGsUwzN~4XH1@mGoIMOYO;c<Oq
zxEC<;i9uz-gI;myW8vDiVov$40i=Kn;;fuCRT!d1ud6&LRxTp7-P@!EGYU5-mCxL&
zjc1<!GI1-!y*bJGiPqdR!FGxsapRKGgJ~$&4o41L_cWI%h>PfHl&!jwyc#lw-nmm<
zPP1eqP&}vfyi)yqTV;LN#w)dEFFlgXg|0i--|RAh+BL{wRy`g}#MG?0t&_y0EUGI8
zsivcfcKKoSN_DEwLK75kuaU>nk~nv}jyArvkV#lXqWb|h^&5#MhkVFw+oh*(&6;YP
zd<*L8j-MqQPY(ml?UB`jy?YU@LKD&&%X^e?)rQJ(f`xk)WD6iCcd$#d$!1s;%DhE8
zvrmId$OCA#!3|>PlT1U|m1G?$7g3Q&t4{n2*t9Y(X0^CfQ5CE7)?;eARuVjy12k2=
zcc~A|;ezejIDh`g>p8tjl5j=|)sFKrDK5i#^((*VAj^}3r^bf6Q@ve{X?bzJuqJ0$
z*;KlYS#=)nNE20q<T(BK0ZJQOz>yh7F5C^lGz0yb?wj8Q?kguKg68iq;1#U1{AuAK
z7o=4jE_PYS&&FS3PvenQoiFDzK6Iq=D_-=Afhy##k2scV2u1*WlVVnC?B*I^q(=l1
zr=Akn#tDy2BUaxhCZ!05ri_h_yuNi-)7^gCbY{$m+!BAO-avf7QPBzVGO8a~;Q+Q$
zr&#h{xvQd7!9*5ZLIKj>{l|9!hDYPQf!dvt#fG#?qCA3*Z=UHUN353;Ud1(YXep3`
zzazsC=7J%u0Hg<XDzp|h&S0?>o2#vSd6F>Gl(;=Vh!=@7x&)thy4e+V_4OLH5dUlN
zUD0M0{B?pX;7C(kP7i)jZeTkXS)oy=k_StDHf}GPeCv$no_*;qTWzyLctOu94|z{`
zR0AzHcdLQY2*iX~7u90_HVKSM25h^G9kZ+IzU-BKO9rH(9t*{a-F|%AM9I?+(&w-!
z<0@Q|>+&LV8*<JMRE0sOr{*u|FPx@yN$=ZghzPhCsw7m@9@DRw>c{XK#MJo>el<Uh
zY-K6(A6g<Ge?a1*F=JYUq(Qvc3r5g48<%{O+z3Jl^oBWfm(|(Xm2J}-dNljryNY*s
zdo8zS{^F;$gPt9_r{@BVyj23Fd0s5b0Sp(`H)OMJElgv4<PzdlKZLqovl$P8Z}7g3
zSCjaX(y#EH>k(u?2r5xnD3_WrwpEaeaJn2}eE@KfKT+}th-g;%v@pxw8xwqyL8Lqy
z05b>Uq&Vt%+cq?IHe#&s^F$-}#a_dfH9cIM6W#?E-n+6F45uo$)kBbpK<wUPpES7U
z$y=)*6&1kiOLo=U7M^^a>1^vE!j7*aUI+$Xg*9()W!XkB+se)LDzV<4K(4TerxH+d
zcs4X>mS~lRN29Dp((tIm3>jlwIsOKYc}=`a0|yp$$NFZ3UP)z*;n)aT6R?s86!`u8
zg|x+H?w9-MHr_@pXS_cMUuvGTjm}Bx`Z9MInegT?DKVnqW1+2M%2pkb?1>?v@W(bD
zBuN|=mt@ZX<{EQ5#1*l!IavU_?mBr4nv3gZS!GrpMW>nTCudWXU!#gkmiVC`$#jT3
zV}0}&<Gu)jB66AylIGfx&N#Y)X{&$W*Pg$an(Z!H&lMorCB^>o%<Ux(_E#j^&F*+w
z!hI|{KQQx++GI5?h9l>Q=@O<l)LoFWHq}We6nt4MLz=W_>7juxJ3Jt|dXLtx$K(t)
zDWqA(tN?<`f@E9{(*{qy>7Hwry;-B?ViAGYxub+vCOAgrbI-H&$r?IviSxJ)`t$=j
z@+VNwZp$WPqaIY#Q{SYe6ogFqmz@(<hjJXaLkv}m=%%FEMLmva_v6LAOv&gX*CS_%
z7;xmQ3*T5HJ)a0sYE*GKC+!ip9vbHHqmFP*PQMu!fc5!=CCsfaHLM^gN)Qw|Q>D6>
zYN#%$zwArN=JxnW^5nge151yBgep4h;l0M`F%3K&Tr_D#tb92cE+^CTdQ~d0X^L=a
zcm!GWduVYJWg^nEv3HC5x&~ix)I)m;1cw`l){oo<b=6&f!PuW!O5-|A$r0L_QZo2*
zbZcz*Qdn1|ya=VUBkGoqM=aaB&zQc*$|n<JwYB4)mhgthMua#Bx3O=|s@nZJ-#dF-
zIeLqCOl;gYswR~RJ>Kf25`-|wZZuanpI{`x8H0k3!t*F?vT&@&s*S?VHG%uv)8J~?
zg#C|*X1+0=SARvq{>uOSSH7|`0X-f8fTBDMD4W@hSC`{{lKdAo2VB!UPIm<m4wJN8
zL@yDTU!ZJ1Ngj4<PbStXZF6VkyilTjdgd8iais}Fx1}|+EmpB)_$in5KEus`UY7Rb
z8<X2SA}Lj*bDk=n{Qe+sLI`}5aMn4NK-rt0`6;`H$4Y~<)S@<hlG*1s`Cm~UYgMe3
zq2!I#k9RI%-gNn~18qF6!nowICgnMFcI1n;9n1|S;T6x#EH#oS&aBms7#>OT-g<Nu
zM;DQ%rePozH#gU9=5Rwu<%UpKCXL9`qHqb4Gi`Jnw7P-kH3NvsQspN{06e9TSgvzj
z?u%LDf3$`IwyG0u>l0?s<m~u+4J_V;fX?2w@HD|sZhe0mTLWlz4Bu*c&<g`)uU~b{
zzlc$5xU-YP`v!lJ_o@6MC7sBMwxm~v{&Mc`q|v&$w5~!Q{}=8Q6qoeN-Tz(<UZ`|q
zh(8kft491S;um>r=_Brq7v_NA=a;j;s-|r<Rqm0q3I3v_2K}mj<<knk|IUE%pK4-(
z01kEh4vx)VtxJB%lHb7r#BYD&>+(A|05snF`?2Ev$KF4`gY*9;IF)-GD|@Dwy?^Mg
zLoghnpafe@r5OY2xp|JXMy2a>aZyFQWeGn?KqpD3@R-wUbS6cT|HbQhM$w`~tMzAp
zqj2v3d@T|}^z{OaYLm}^8dz&`JDZFU=?OhVQxSs%L`bKPSNorm+L$NQW(n%bAkJ*t
zf~sw~h{gbUoH-9rrn(uqu1aZ~9KQp89@W_<$==+SJNO1nYOeuKdC%8_L(q@IkAMIG
z5CN>Ydx!sDU(cn_=hwU2?M@On@G?54<<d9*mltK<yXx7-gvzb;$l1M<`);eV{or4@
zO8d)u>BvC3#F!{*ZG3&LEKj1^s;dn)^oJ+94FWa&l{a}KJtE)pNGy+*;DS3lV>>xB
zeXU-w40q|q)^rVCO|-er?#yE<yxYZF@Fkvv@dNqWKg2}3pco=2&S^z9P*j5!7w`}>
z^=_=>?4C|*_@{GhXBC{{5<IWwpS!<&q9Ygry#c4gzAhsR1p3<`Xj30E_QVyn`+Tv=
z+v7=fT2o42aV^aH%XfOfd0Nv-S=##+FryWw37&b1%j$jU_^vl~DlK*9j<>^KnwfKd
zI2+!F1$9x9wI5S=7u$I&C-E1z(CqI^Fiz(^Fcs#_OT+qfc(;7ltxe~`98M1H(r~|+
z$n=bhc~Hd6j=wB=F6+;`{WXjBf09H(Ydt$PUik^teunF<hKdYpt%|0tLTq-=zkNKf
z3keBhbXXH;^LkYHWs@X!%;|Ycos2@bMa__B;uimt_-@`173GDp{8)Jw`TVgzbF<13
zZk1#3Z7&yGv{h*vXOO0}v$RgXBA{r0?_K`_8)Xl{VT7?H17}Pm2Rx#XKuHfL8UR?B
zW<Qk-=aqugmzSEQU!t+Le2VRhWHeUoyBU3vtwrs@dAd}F$nOzR5bX+eJ#`;6J@>|h
zK;k+@Ep;DbwwLz(D1EjBev(@d7D_-B*0G0yo>CGS0475Th@ivtdO}kZATayd-N2~6
zQ4|h|e)xP~TUnm;r98{_BNFa%QQQdL1TJ@)K~S^H#$_8c)l51Gw9c~RrpNgds(;z#
zX1AyfR|q%IKReT}9i7k%2E=5-xcg4mq*FG-*rLu@dSWbVi$1usr#?Qjr!&a)*{JWh
zkvA!rpaL|^xiVurXEEfN;#lawvYy*z^(CE=R#M`KR~}^8q$Tv1Z=^mWDx(?{gtS86
z1`KIEt8z{N9~bj+5xkUvpx~hzHiMTOmXH(I8gPz{-Ljq%baaCG&a{+av${t{P{G+b
z6%EuLdB=pi$=l@*@?E77s}EN*3rdx~6z;}WCj0|3p{LR~`Uf>oj|a=V*87@BWdu=L
z-D8AlcZ@9+`nXLV`uNbNsgQn1n10EEH30nJ4KRBTacYGyw6tEH9qZN6FZ<;+>J+tA
zl*N=y0jIH#ls|7nV%`dIolEgBZIrnT5TPmHR+wot8D?4?iwG1IL?f<j6P;%75Jv=%
zsp|t6WIu0lq_pFG&G+Un<;${SJHm@g?R3*`jPBM@Dr_(Hbo6khudaHLI?FTp5AE~@
zJw3yo{x0XU`@9^jwTE|ln)~_PjDof#-8!Lq*zRq2is%vv-e>+)FRjlm{?W=za|{Vo
zt+arxNgUw2U|Kw>0uZNSPQk=h6=GO;%GtyJe1QIVi2ma!X#YvV#xi~CqX;A-Sg$A&
zw10OIF<mWpLR<YAzz6s50vN?~^&gxx?*c$D#Kuy7>Z1<)t&(2hnNGL^ZU}Y3QToRI
zR)z!Mj=l<pQW-CLZOHA6RF{O2&MSyvrq5n~`RL4M@ZvsN+A{>{5XGPa^a$XAu^vBZ
z7%P=!*m`N}YNtoDiqgCQl0=(neOR3}uU%@Z7;d{^mY#Z4g){cWzBzKiI=;@aCoZM;
zEm{xZomsOT2c0c{n3Bvp)2iIR-s2)UJuEA68tcc7LoGu)x0E9&lYo9&o`nVk<#C9v
zfwua%J3gpkV$DD?D0OGa$oXardte7VXDr+ii$uJMf5iNCEdI@#*05s0nbN@E1Uf4A
z<<!vju8Dea3sq+GIlL|o(IrcUiGT%YVd?^!U02bp)7l{&-btaiz%v%<i~0IO3Vk!w
zgNgc$inqx3Q?i!<d?#jQGt}>%HI%YUT5sjdT8nEZ#_sdXjNQ?6tWlUAEPQs5y(<3I
zK#oGwO4mD*W%*qAwF$SMBy)DF8DUAvwb7kjtXD>>)p@ao0tYfp+YbCBR^Gg)S?3N&
z@;w>bd*8t&PScxxmrvPNh;es<iVRzTN4*bzslYZ-Jn^wKPodI9S@V^Ay*P1}f~i6A
zq4z;XcipY_2A)Qz(Ve*H*gy%I{!aLQ@69WgZ!NO7PvFnSJ<vAlxlQW`!7L&x!51Ug
zjlBBJTO~-^Zbk5#?Gj_^&PjLTo8tMU1smaA^I7K`j>Fd+Rg5IaxH}6(r>6T56^NaK
z)t@9JxcN>kSkK@ZYlhsbW?tfr3S(O*GP&R>PO$-uf!G@gy**ZkZ0o2YO?X(Ml51^i
zb184fU5^MPK?+}1QwN^gbJl*F>u2GFvpD{iJ0J@b0Ahe#EC*&t7oF|wRVo}t<Kzc0
zV5)GK6nwR&Ylp*eHAMv83e2jtH)lrKb}Q#p)@bR6)(O;;x~O!X+ymBU{vK`A)UO#o
z`RMroJ!!Pypk~}K)oc3?5l?*tq`HM{ncgN!=A<}u*L<8`D2(F_S6$a``0R(SgD)lL
z9%VJUDif3R2(qgQrF=&TE%s<!G{y?8lEWEMn!!4<vPWW@&ODhjdU$d7aK@y29Rk}8
zkaxWq+84a^%(YQs*6-yrhyLwN070LJGR?qjHRy4ca@5<grQL~d=W@;-?Q>GJuZ4IV
zYte=BUhK$tbbz8J4vVF;VmCX=amv-udn%aCFhTb;!`1DbMI*2Ht!Yhxp^pnv>e6|7
zVV;Se=bUco#Yi=trV?~OJ%ZE*wrs2Js1RxSHEwAQx}^~DVC2Wo#q<5w7JQ3DCp1@t
zc&Vx1-0e!G8q##+6;6pBm_O}5J$CShlukU_z5+(z5Ci>iLd}W7w^i9tX>psv`EQ1_
zwR3se>S>1;$L5H}B?DpHefEK7`@s^r5)vgodoe^BOh{m}Od()@oqie6`V!b*s&J$Z
zmMb2Cr_FV5PuWN#Wn`U$FN<H$uC}6EU!prrgUjc`wWdlPMZW5_r_(d#9tWz{D>&Y%
zQKAy;Z{j)fu<M(CNs>F$yC`vxdzvimvm$e^V}v6krc7W@_QsaqwaF4`0rBAVlmUpj
zv-CAeoyQKe>7Gk<NpGkZa_nCSO+v>|qEh*ru;La^ljx0j4->?Dd*a4owYTWjVZwBm
z2GvZvC;Qw+421_n<yPI3<I19WW3~0rWf#bLLi0>*=8u?n??6Js-zfchb&xGJH7(T*
z4dd+kPPf7>yaZU{%%8={58PEzCRt8+?oAC9f^8n%nS$$;FTgDCx^um*Q9nC&1o^hL
z?1QT*=HuZn9m;fWRVcNSdzWqP!-^E5+W};ufdqM=)EvLfDp(l-%o$;a%xPwNwb2&u
zAZl#raDlIn>XIB|RT9|Y?{!>yjXen7e(`?bBtKJcu1TO(;UReVz`Dd+iB|LJnLo;D
z|Az<JClE$6N?UK#6vyZO!A8igaR@}SlQOQ6a=fFtD0k$My`LN|+diF^zhwkMt6=$7
zk>MOTV>{qM4{GEJ{BDL7?0h^IR36Eo9cN^F*8$3I*c<EX>HO7hn<@-NR$U$;84|eb
zeqWH9z*45PN>1%`yTB)OC7q7O;)%BX?n@yThV%~^^sQ7jP{!(0nt9#$eUZ<igP^Mr
zW*fRo^;OB1p<>V0$+;;c*su9ZPKB%KhcFaQjw;b5TlL9d^k*y@aAp_}327O-)vYhM
z@~jeXx}mu4E7d)G6#^_d7eoy-cKcsGBfC#(*__>elyck=GyiS*IIL#xRinnv=?YqX
z4=(tVgqE0@k5Vc(F;?igSf-ScH%amO?OQIFFSTTYM{;OwJfC$&4bopEiotM_0RHfk
z<oP!tyE(ti4@&~Mhq()Uw|lnO*wAdlrWYAW&tAM;j|fI!o(NunF|R&}SdDV(1^z!a
z6wJ}pJ*Rz*iiYLMw8r~FsH6m;ni&J*lDJ9TccC_NEGqd;fJ?)7QCdy?lpuIJ{wACs
z)7yg#HIc(Lh=+*qxRoL_iCvf?=Ie$W<NPdZ;;LeY^^N!X<L}j&ZPEe0Kp?+!!`L;|
zno8&m+-7?sCTH}Mw792}qf_F8;xI#f4vD8%7IXdZR??;!JH7aO5Wm6nE5x?(X2=?d
z#^!40`I@NOCT9oUt+<CJnYZ?zN09i7J1(YW=ijd$Gcj*5*a8;+^725Mkp&VAt1w*M
zf^*_}m~<p2wFBs3bm8@KJzUYsvtY)+Xv8hX-JM3i$MG690Ta)db1C_Wv%kiBYgXE%
zj>g5j{9Ixe6Mbr-&4EC7>0;@0&`SE8&aH&esRsjXujI*Yh99G?mMLqCu@Oet62niW
zdE1TCL1vf&I}Lu(w>C0egU-}$FE%gKODr(@DGj9C0Z@G~+a%&^3mkyp+G_z{%0AI7
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

diff --git a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/keywords.txt b/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/keywords.txt
deleted file mode 100644
index f320104..0000000
--- a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/keywords.txt
+++ /dev/null
@@ -1,628 +0,0 @@
-#######################################
-# Syntax Coloring Map
-#######################################
-
-#######################################
-# Datatypes (KEYWORD1)
-#######################################
-
-SFE_UBLOX_GNSS	KEYWORD1
-
-ubxPacket	KEYWORD1
-
-geofenceState	KEYWORD1
-
-UBX_ESF_MEAS_sensorData_t	KEYWORD1
-UBX_ESF_RAW_sensorData_t	KEYWORD1
-UBX_ESF_STATUS_sensorStatus_t	KEYWORD1
-
-UBX_NAV_POSECEF_data_t	KEYWORD1
-UBX_NAV_STATUS_data_t	KEYWORD1
-UBX_NAV_DOP_data_t	KEYWORD1
-UBX_NAV_ATT_data_t	KEYWORD1
-UBX_NAV_PVT_data_t	KEYWORD1
-UBX_NAV_ODO_data_t	KEYWORD1
-UBX_NAV_VELECEF_data_t	KEYWORD1
-UBX_NAV_VELNED_data_t	KEYWORD1
-UBX_NAV_HPPOSECEF_data_t	KEYWORD1
-UBX_NAV_HPPOSLLH_data_t	KEYWORD1
-UBX_NAV_CLOCK_data_t	KEYWORD1
-UBX_NAV_RELPOSNED_data_t	KEYWORD1
-
-UBX_RXM_SFRBX_data_t	KEYWORD1
-UBX_RXM_RAWX_data_t	KEYWORD1
-
-UBX_TIM_TM2_data_t	KEYWORD1
-
-UBX_ESF_ALG_data_t	KEYWORD1
-UBX_ESF_INS_data_t	KEYWORD1
-UBX_ESF_MEAS_data_t	KEYWORD1
-UBX_ESF_RAW_data_t	KEYWORD1
-UBX_ESF_STATUS_data_t	KEYWORD1
-
-UBX_HNR_PVT_data_t	KEYWORD1
-UBX_HNR_ATT_data_t	KEYWORD1
-UBX_HNR_INS_data_t	KEYWORD1
-
-#######################################
-# Methods and Functions (KEYWORD2)
-#######################################
-
-setPacketCfgPayloadSize	KEYWORD2
-begin	KEYWORD2
-end	KEYWORD2
-setI2CpollingWait	KEYWORD2
-setI2CTransactionSize	KEYWORD2
-getI2CTransactionSize	KEYWORD2
-isConnected	KEYWORD2
-enableDebugging	KEYWORD2
-disableDebugging	KEYWORD2
-debugPrint	KEYWORD2
-debugPrintln	KEYWORD2
-statusString	KEYWORD2
-disableUBX7Fcheck	KEYWORD2
-
-checkUblox	KEYWORD2
-checkUbloxI2C	KEYWORD2
-checkUbloxSerial	KEYWORD2
-
-process	KEYWORD2
-processNMEA	KEYWORD2
-processRTCMframe	KEYWORD2
-processRTCM	KEYWORD2
-processUBX	KEYWORD2
-processUBXpacket	KEYWORD2
-
-calcChecksum	KEYWORD2
-sendCommand	KEYWORD2
-printPacket	KEYWORD2
-
-checkCallbacks	KEYWORD2
-
-pushRawData	KEYWORD2
-
-setFileBufferSize	KEYWORD2
-getFileBufferSize	KEYWORD2
-extractFileBufferData	KEYWORD2
-fileBufferAvailable	KEYWORD2
-getMaxFileBufferAvail	KEYWORD2
-clearFileBuffer	KEYWORD2
-clearMaxFileBufferAvail	KEYWORD2
-
-getPortSettings	KEYWORD2
-setPortOutput	KEYWORD2
-setPortInput	KEYWORD2
-
-setI2CAddress	KEYWORD2
-setSerialRate	KEYWORD2
-
-setI2COutput	KEYWORD2
-setUART1Output	KEYWORD2
-setUART2Output	KEYWORD2
-setUSBOutput	KEYWORD2
-setSPIOutput	KEYWORD2
-setNMEAOutputPort	KEYWORD2
-
-factoryReset	KEYWORD2
-hardReset	KEYWORD2
-factoryDefault	KEYWORD2
-
-saveConfiguration	KEYWORD2
-saveConfigSelective	KEYWORD2
-
-configureMessage	KEYWORD2
-enableMessage	KEYWORD2
-disableMessage	KEYWORD2
-enableNMEAMessage	KEYWORD2
-disableNMEAMessage	KEYWORD2
-enableRTCMmessage	KEYWORD2
-disableRTCMmessage	KEYWORD2
-
-getSurveyMode	KEYWORD2
-setSurveyMode	KEYWORD2
-enableSurveyMode	KEYWORD2
-disableSurveyMode	KEYWORD2
-setStaticPosition	KEYWORD2
-
-getProtocolVersionHigh	KEYWORD2
-getProtocolVersionLow	KEYWORD2
-getProtocolVersion	KEYWORD2
-
-addGeofence	KEYWORD2
-clearGeofences	KEYWORD2
-clearAntPIO	KEYWORD2
-getGeofenceState	KEYWORD2
-
-powerSaveMode	KEYWORD2
-getPowerSaveMode	KEYWORD2
-powerOff	KEYWORD2
-powerOffWithInterrupt	KEYWORD2
-
-setDynamicModel	KEYWORD2
-getDynamicModel	KEYWORD2
-
-resetOdometer	KEYWORD2
-
-enableGNSS	KEYWORD2
-
-createKey	KEYWORD2
-getVal	KEYWORD2
-getVal8	KEYWORD2
-getVal16	KEYWORD2
-getVal32	KEYWORD2
-setVal	KEYWORD2
-setVal8	KEYWORD2
-setVal16	KEYWORD2
-setVal32	KEYWORD2
-newCfgValset8	KEYWORD2
-newCfgValset16	KEYWORD2
-newCfgValset32	KEYWORD2
-addCfgValset8	KEYWORD2
-addCfgValset16	KEYWORD2
-addCfgValset32	KEYWORD2
-sendCfgValset8	KEYWORD2
-sendCfgValset16	KEYWORD2
-sendCfgValset32	KEYWORD2
-
-getNAVPOSECEF	KEYWORD2
-setAutoNAVPOSECEF	KEYWORD2
-setAutoNAVPOSECEFrate	KEYWORD2
-setAutoNAVPOSECEFcallback	KEYWORD2
-assumeAutoNAVPOSECEF	KEYWORD2
-initPacketUBXNAVPOSECEF	KEYWORD2
-flushNAVPOSECEF	KEYWORD2
-logNAVPOSECEF	KEYWORD2
-
-getNAVSTATUS	KEYWORD2
-setAutoNAVSTATUS	KEYWORD2
-setAutoNAVSTATUSrate	KEYWORD2
-setAutoNAVSTATUScallback	KEYWORD2
-assumeAutoNAVSTATUS	KEYWORD2
-initPacketUBXNAVSTATUS	KEYWORD2
-flushNAVSTATUS	KEYWORD2
-logNAVSTATUS	KEYWORD2
-
-getDOP	KEYWORD2
-setAutoDOP	KEYWORD2
-setAutoDOPrate	KEYWORD2
-setAutoDOPcallback	KEYWORD2
-assumeAutoDOP	KEYWORD2
-initPacketUBXNAVDOP	KEYWORD2
-flushDOP	KEYWORD2
-logNAVDOP	KEYWORD2
-
-getVehAtt	KEYWORD2
-getNAVATT	KEYWORD2
-setAutoNAVATT	KEYWORD2
-setAutoNAVATTrate	KEYWORD2
-setAutoNAVATTcallback	KEYWORD2
-assumeAutoNAVATT	KEYWORD2
-initPacketUBXNAVATT	KEYWORD2
-flushNAVATT	KEYWORD2
-logNAVATT	KEYWORD2
-
-getPVT	KEYWORD2
-setAutoPVT	KEYWORD2
-setAutoPVTrate	KEYWORD2
-setAutoPVTcallback	KEYWORD2
-assumeAutoPVT	KEYWORD2
-initPacketUBXNAVPVT	KEYWORD2
-flushPVT	KEYWORD2
-logNAVPVT	KEYWORD2
-
-getNAVODO	KEYWORD2
-setAutoNAVODO	KEYWORD2
-setAutoNAVODOrate	KEYWORD2
-setAutoNAVODOcallback	KEYWORD2
-assumeAutoNAVODO	KEYWORD2
-initPacketUBXNAVODO	KEYWORD2
-flushNAVODO	KEYWORD2
-logNAVODO	KEYWORD2
-
-getNAVVELECEF	KEYWORD2
-setAutoNAVVELECEF	KEYWORD2
-setAutoNAVVELECEFrate	KEYWORD2
-setAutoNAVVELECEFcallback	KEYWORD2
-assumeAutoNAVVELECEF	KEYWORD2
-initPacketUBXNAVVELECEF	KEYWORD2
-flushNAVVELECEF	KEYWORD2
-logNAVVELECEF	KEYWORD2
-
-getNAVVELNED	KEYWORD2
-setAutoNAVVELNED	KEYWORD2
-setAutoNAVVELNEDrate	KEYWORD2
-setAutoNAVVELNEDcallback	KEYWORD2
-assumeAutoNAVVELNED	KEYWORD2
-initPacketUBXNAVVELNED	KEYWORD2
-flushNAVVELNED	KEYWORD2
-logNAVVELNED	KEYWORD2
-
-getNAVHPPOSECEF	KEYWORD2
-setAutoNAVHPPOSECEF	KEYWORD2
-setAutoNAVHPPOSECEFrate	KEYWORD2
-setAutoNAVHPPOSECEFcallback	KEYWORD2
-assumeAutoNAVHPPOSECEF	KEYWORD2
-initPacketUBXNAVHPPOSECEF	KEYWORD2
-flushNAVHPPOSECEF	KEYWORD2
-logNAVHPPOSECEF	KEYWORD2
-
-getHPPOSLLH	KEYWORD2
-setAutoHPPOSLLH	KEYWORD2
-setAutoHPPOSLLHrate	KEYWORD2
-setAutoHPPOSLLHcallback	KEYWORD2
-assumeAutoHPPOSLLH	KEYWORD2
-initPacketUBXNAVHPPOSLLH	KEYWORD2
-flushHPPOSLLH	KEYWORD2
-logNAVHPPOSLLH	KEYWORD2
-
-getNAVCLOCK	KEYWORD2
-setAutoNAVCLOCK	KEYWORD2
-setAutoNAVCLOCKrate	KEYWORD2
-setAutoNAVCLOCKcallback	KEYWORD2
-assumeAutoNAVCLOCK	KEYWORD2
-initPacketUBXNAVCLOCK	KEYWORD2
-flushNAVCLOCK	KEYWORD2
-logNAVCLOCK	KEYWORD2
-
-getSurveyStatus	KEYWORD2
-initPacketUBXNAVSVIN	KEYWORD2
-
-getRELPOSNED	KEYWORD2
-setAutoRELPOSNED	KEYWORD2
-setAutoRELPOSNEDrate	KEYWORD2
-setAutoRELPOSNEDcallback	KEYWORD2
-assumeAutoRELPOSNED	KEYWORD2
-initPacketUBXNAVRELPOSNED	KEYWORD2
-flushNAVRELPOSNED	KEYWORD2
-logNAVRELPOSNED	KEYWORD2
-
-getRXMSFRBX	KEYWORD2
-setAutoRXMSFRBX	KEYWORD2
-setAutoRXMSFRBXrate	KEYWORD2
-setAutoRXMSFRBXcallback	KEYWORD2
-assumeAutoRXMSFRBX	KEYWORD2
-initPacketUBXRXMSFRBX	KEYWORD2
-flushRXMSFRBX	KEYWORD2
-logRXMSFRBX	KEYWORD2
-
-getRXMRAWX	KEYWORD2
-setAutoRXMRAWX	KEYWORD2
-setAutoRXMRAWXrate	KEYWORD2
-setAutoRXMRAWXcallback	KEYWORD2
-assumeAutoRXMRAWX	KEYWORD2
-initPacketUBXRXMRAWX	KEYWORD2
-flushRXMRAWX	KEYWORD2
-logRXMRAWX	KEYWORD2
-
-getTIMTM2	KEYWORD2
-setAutoTIMTM2	KEYWORD2
-setAutoTIMTM2rate	KEYWORD2
-setAutoTIMTM2callback	KEYWORD2
-assumeAutoTIMTM2	KEYWORD2
-initPacketUBXTIMTM2	KEYWORD2
-flushTIMTM2	KEYWORD2
-logTIMTM2	KEYWORD2
-
-getEsfAlignment	KEYWORD2
-getESFALG	KEYWORD2
-setAutoESFALG	KEYWORD2
-setAutoESFALGrate	KEYWORD2
-setAutoESFALGcallback	KEYWORD2
-assumeAutoESFALG	KEYWORD2
-initPacketUBXESFALG	KEYWORD2
-flushESFALG	KEYWORD2
-logESFALG	KEYWORD2
-
-getEsfInfo	KEYWORD2
-getESFSTATUS	KEYWORD2
-setAutoESFSTATUS	KEYWORD2
-setAutoESFSTATUSrate	KEYWORD2
-setAutoESFSTATUScallback	KEYWORD2
-assumeAutoESFSTATUS	KEYWORD2
-initPacketUBXESFSTATUS	KEYWORD2
-flushESFSTATUS	KEYWORD2
-logESFSTATUS	KEYWORD2
-
-getEsfIns	KEYWORD2
-getESFINS	KEYWORD2
-setAutoESFINS	KEYWORD2
-setAutoESFINSrate	KEYWORD2
-setAutoESFINScallback	KEYWORD2
-assumeAutoESFINS	KEYWORD2
-initPacketUBXESFINS	KEYWORD2
-flushESFINS	KEYWORD2
-logESFINS	KEYWORD2
-
-getEsfDataInfo	KEYWORD2
-getESFMEAS	KEYWORD2
-setAutoESFMEAS	KEYWORD2
-setAutoESFMEASrate	KEYWORD2
-setAutoESFMEAScallback	KEYWORD2
-assumeAutoESFMEAS	KEYWORD2
-initPacketUBXESFMEAS	KEYWORD2
-flushESFMEAS	KEYWORD2
-logESFMEAS	KEYWORD2
-
-getEsfRawDataInfo	KEYWORD2
-getESFRAW	KEYWORD2
-setAutoESFRAW	KEYWORD2
-setAutoESFRAWrate	KEYWORD2
-setAutoESFRAWcallback	KEYWORD2
-assumeAutoESFRAW	KEYWORD2
-initPacketUBXESFRAW	KEYWORD2
-flushESFRAW	KEYWORD2
-logESFRAW	KEYWORD2
-
-getHNRAtt	KEYWORD2
-getHNRATT	KEYWORD2
-setAutoHNRATT	KEYWORD2
-setAutoHNRATTrate	KEYWORD2
-setAutoHNRATTcallback	KEYWORD2
-assumeAutoHNRATT	KEYWORD2
-initPacketUBXHNRATT	KEYWORD2
-flushHNRATT	KEYWORD2
-logHNRATT	KEYWORD2
-
-getHNRDyn	KEYWORD2
-getHNRINS	KEYWORD2
-setAutoHNRINS	KEYWORD2
-setAutoHNRINSrate	KEYWORD2
-setAutoHNRINScallback	KEYWORD2
-assumeAutoHNRINS	KEYWORD2
-initPacketUBXHNRINS	KEYWORD2
-flushHNRINS	KEYWORD2
-logHNRINS	KEYWORD2
-
-getHNRPVT	KEYWORD2
-setAutoHNRPVT	KEYWORD2
-setAutoHNRPVTrate	KEYWORD2
-setAutoHNRPVTcallback	KEYWORD2
-assumeAutoHNRPVT	KEYWORD2
-initPacketUBXHNRPVT	KEYWORD2
-flushHNRPVT	KEYWORD2
-logHNRPVT	KEYWORD2
-
-setNavigationFrequency	KEYWORD2
-getNavigationFrequency	KEYWORD2
-setMeasurementRate	KEYWORD2
-getMeasurementRate	KEYWORD2
-setNavigationRate	KEYWORD2
-getNavigationRate	KEYWORD2
-
-getGeometricDOP	KEYWORD2
-getPositionDOP	KEYWORD2
-getTimeDOP	KEYWORD2
-getVerticalDOP	KEYWORD2
-getHorizontalDOP	KEYWORD2
-getNorthingDOP	KEYWORD2
-getEastingDOP	KEYWORD2
-
-getATTroll	KEYWORD2
-getATTpitch	KEYWORD2
-getATTheading	KEYWORD2
-
-getTimeOfWeek	KEYWORD2
-getYear	KEYWORD2
-getMonth	KEYWORD2
-getDay	KEYWORD2
-getHour	KEYWORD2
-getMinute	KEYWORD2
-getSecond	KEYWORD2
-getMillisecond	KEYWORD2
-getNanosecond	KEYWORD2
-getUnixEpoch	KEYWORD2
-getDateValid	KEYWORD2
-getTimeValid	KEYWORD2
-getConfirmedDate	KEYWORD2
-getConfirmedTime	KEYWORD2
-getFixType	KEYWORD2
-getGnssFixOk	KEYWORD2
-getDiffSoln	KEYWORD2
-getHeadVehValid	KEYWORD2
-getCarrierSolutionType	KEYWORD2
-getSIV	KEYWORD2
-getLongitude	KEYWORD2
-getLatitude	KEYWORD2
-getAltitude	KEYWORD2
-getAltitudeMSL	KEYWORD2
-getHorizontalAccEst	KEYWORD2
-getVerticalAccEst	KEYWORD2
-getNedNorthVel	KEYWORD2
-getNedEastVel	KEYWORD2
-getNedDownVel	KEYWORD2
-getGroundSpeed	KEYWORD2
-getHeading	KEYWORD2
-getSpeedAccEst	KEYWORD2
-getHeadingAccEst	KEYWORD2
-getPDOP	KEYWORD2
-getInvalidLlh	KEYWORD2
-getHeadVeh	KEYWORD2
-getMagDec	KEYWORD2
-getMagAcc	KEYWORD2
-getHeadVehValid	KEYWORD2
-
-getPositionAccuracy	KEYWORD2
-
-getTimeOfWeekFromHPPOSLLH	KEYWORD2
-getHighResLongitude	KEYWORD2
-getHighResLatitude	KEYWORD2
-getElipsoid	KEYWORD2
-getMeanSeaLevel	KEYWORD2
-getHighResLongitudeHp	KEYWORD2
-getHighResLatitudeHp	KEYWORD2
-getElipsoidHp	KEYWORD2
-getMeanSeaLevelHp	KEYWORD2
-getHorizontalAccuracy	KEYWORD2
-getVerticalAccuracy	KEYWORD2
-
-getSurveyInActive	KEYWORD2
-getSurveyInValid	KEYWORD2
-getSurveyInObservationTime	KEYWORD2
-getSurveyInMeanAccuracy	KEYWORD2
-
-getRelPosN	KEYWORD2
-getRelPosE	KEYWORD2
-getRelPosD	KEYWORD2
-getRelPosAccN	KEYWORD2
-getRelPosAccE	KEYWORD2
-getRelPosAccD	KEYWORD2
-
-getESFroll	KEYWORD2
-getESFpitch	KEYWORD2
-getESFyaw	KEYWORD2
-getSensorFusionMeasurement	KEYWORD2
-getRawSensorMeasurement	KEYWORD2
-getSensorFusionStatus	KEYWORD2
-
-setHNRNavigationRate	KEYWORD2
-getHNRNavigationRate	KEYWORD2
-getHNRroll	KEYWORD2
-getHNRpitch	KEYWORD2
-getHNRheading	KEYWORD2
-
-extractLong	KEYWORD2
-extractSignedLong	KEYWORD2
-extractInt	KEYWORD2
-extractSignedInt	KEYWORD2
-extractByte	KEYWORD2
-extractSignedChar	KEYWORD2
-
-#######################################
-# Constants (LITERAL1)
-#######################################
-
-SFE_UBLOX_STATUS_SUCCESS	LITERAL1
-SFE_UBLOX_STATUS_FAIL	LITERAL1
-SFE_UBLOX_STATUS_CRC_FAIL	LITERAL1
-SFE_UBLOX_STATUS_TIMEOUT	LITERAL1
-SFE_UBLOX_STATUS_COMMAND_NACK	LITERAL1
-SFE_UBLOX_STATUS_OUT_OF_RANGE	LITERAL1
-SFE_UBLOX_STATUS_INVALID_ARG	LITERAL1
-SFE_UBLOX_STATUS_INVALID_OPERATION	LITERAL1
-SFE_UBLOX_STATUS_MEM_ERR	LITERAL1
-SFE_UBLOX_STATUS_HW_ERR	LITERAL1
-SFE_UBLOX_STATUS_DATA_SENT	LITERAL1
-SFE_UBLOX_STATUS_DATA_RECEIVED	LITERAL1
-SFE_UBLOX_STATUS_I2C_COMM_FAILURE	LITERAL1
-SFE_UBLOX_STATUS_DATA_OVERWRITTEN	LITERAL1
-
-COM_TYPE_UBX	LITERAL1
-COM_TYPE_NMEA	LITERAL1
-COM_TYPE_RTCM3	LITERAL1
-
-COM_PORT_I2C	LITERAL1
-COM_PORT_UART1	LITERAL1
-COM_PORT_UART2	LITERAL1
-COM_PORT_USB	LITERAL1
-COM_PORT_SPI	LITERAL1
-
-UBX_CLASS_NAV	LITERAL1
-UBX_CLASS_RXM	LITERAL1
-UBX_CLASS_INF	LITERAL1
-UBX_CLASS_ACK	LITERAL1
-UBX_CLASS_CFG	LITERAL1
-UBX_CLASS_UPD	LITERAL1
-UBX_CLASS_MON	LITERAL1
-UBX_CLASS_AID	LITERAL1
-UBX_CLASS_TIM	LITERAL1
-UBX_CLASS_ESF	LITERAL1
-UBX_CLASS_MGA	LITERAL1
-UBX_CLASS_LOG	LITERAL1
-UBX_CLASS_SEC	LITERAL1
-UBX_CLASS_HNR	LITERAL1
-UBX_CLASS_NMEA	LITERAL1
-
-UBX_NMEA_MSB	LITERAL1
-UBX_NMEA_DTM	LITERAL1
-UBX_NMEA_GAQ	LITERAL1
-UBX_NMEA_GBQ	LITERAL1
-UBX_NMEA_GBS	LITERAL1
-UBX_NMEA_GGA	LITERAL1
-UBX_NMEA_GLL	LITERAL1
-UBX_NMEA_GLQ	LITERAL1
-UBX_NMEA_GNQ	LITERAL1
-UBX_NMEA_GNS	LITERAL1
-UBX_NMEA_GPQ	LITERAL1
-UBX_NMEA_GRS	LITERAL1
-UBX_NMEA_GSA	LITERAL1
-UBX_NMEA_GST	LITERAL1
-UBX_NMEA_GSV	LITERAL1
-UBX_NMEA_RMC	LITERAL1
-UBX_NMEA_TXT	LITERAL1
-UBX_NMEA_VLW	LITERAL1
-UBX_NMEA_VTG	LITERAL1
-UBX_NMEA_ZDA	LITERAL1
-
-UBX_NAV_ATT	LITERAL1
-UBX_NAV_CLOCK	LITERAL1
-UBX_NAV_DOP	LITERAL1
-UBX_NAV_GEOFENCE	LITERAL1
-UBX_NAV_HPPOSECEF	LITERAL1
-UBX_NAV_HPPOSLLH	LITERAL1
-UBX_NAV_ODO	LITERAL1
-UBX_NAV_POSECEF	LITERAL1
-UBX_NAV_PVT	LITERAL1
-UBX_NAV_RELPOSNED	LITERAL1
-UBX_NAV_RESETODO	LITERAL1
-UBX_NAV_STATUS	LITERAL1
-UBX_NAV_SVIN	LITERAL1
-UBX_NAV_VELECEF	LITERAL1
-UBX_NAV_VELNED	LITERAL1
-
-UBX_RXM_RAWX	LITERAL1
-UBX_RXM_SFRBX	LITERAL1
-
-UBX_TIM_TM2	LITERAL1
-
-UBX_RTCM_MSB	LITERAL1
-UBX_RTCM_1005	LITERAL1
-UBX_RTCM_1074	LITERAL1
-UBX_RTCM_1077	LITERAL1
-UBX_RTCM_1084	LITERAL1
-UBX_RTCM_1087	LITERAL1
-UBX_RTCM_1094	LITERAL1
-UBX_RTCM_1097	LITERAL1
-UBX_RTCM_1124	LITERAL1
-UBX_RTCM_1127	LITERAL1
-UBX_RTCM_1230	LITERAL1
-UBX_RTCM_4072_0	LITERAL1
-UBX_RTCM_4072_1	LITERAL1
-
-UBX_ESF_MEAS	LITERAL1
-UBX_ESF_RAW	LITERAL1
-UBX_ESF_STATUS	LITERAL1
-UBX_ESF_ALG	LITERAL1
-UBX_ESF_INS	LITERAL1
-
-VAL_CFG_SUBSEC_IOPORT	LITERAL1
-VAL_CFG_SUBSEC_MSGCONF	LITERAL1
-VAL_CFG_SUBSEC_INFMSG	LITERAL1
-VAL_CFG_SUBSEC_NAVCONF	LITERAL1
-VAL_CFG_SUBSEC_RXMCONF	LITERAL1
-VAL_CFG_SUBSEC_SENCONF	LITERAL1
-VAL_CFG_SUBSEC_RINVCONF	LITERAL1
-VAL_CFG_SUBSEC_ANTCONF	LITERAL1
-VAL_CFG_SUBSEC_LOGCONF	LITERAL1
-VAL_CFG_SUBSEC_FTSCONF	LITERAL1
-
-DYN_MODEL_PORTABLE	LITERAL1
-DYN_MODEL_STATIONARY	LITERAL1
-DYN_MODEL_PEDESTRIAN	LITERAL1
-DYN_MODEL_AUTOMOTIVE	LITERAL1
-DYN_MODEL_SEA	LITERAL1
-DYN_MODEL_AIRBORNE1g	LITERAL1
-DYN_MODEL_AIRBORNE2g	LITERAL1
-DYN_MODEL_AIRBORNE4g	LITERAL1
-DYN_MODEL_WRIST	LITERAL1
-DYN_MODEL_BIKE	LITERAL1
-DYN_MODEL_UNKNOWN	LITERAL1
-
-SFE_UBLOX_GNSS_ID_GPS	LITERAL1
-SFE_UBLOX_GNSS_ID_SBAS	LITERAL1
-SFE_UBLOX_GNSS_ID_GALILEO	LITERAL1
-SFE_UBLOX_GNSS_ID_BEIDOU	LITERAL1
-SFE_UBLOX_GNSS_ID_IMES	LITERAL1
-SFE_UBLOX_GNSS_ID_QZSS	LITERAL1
-SFE_UBLOX_GNSS_ID_GLONASS	LITERAL1
-
-DAYS_SINCE_MONTH	LITERAL1
diff --git a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/library.properties b/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/library.properties
deleted file mode 100644
index 1e27608..0000000
--- a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/library.properties
+++ /dev/null
@@ -1,9 +0,0 @@
-name=SparkFun u-blox GNSS Arduino Library
-version=2.0.5
-author=SparkFun Electronics <techsupport@sparkfun.com>
-maintainer=SparkFun Electronics <sparkfun.com>
-sentence=Library for I2C and Serial Communication with u-blox GNSS modules<br/><br/>
-paragraph=An Arduino Library to enable both I2C and Serial communication for both NMEA reception and binary UBX sending to u-blox modules. Useful for interfacing to the <a href="https://www.sparkfun.com/products/15136">SparkFun GPS-RTK2</a> ZED-F9P, <a href="https://www.sparkfun.com/products/15005">SparkFun GPS-RTK</a> NEO-M8P-2, the <a href="https://www.sparkfun.com/products/15210">SparkFun SAM-M8Q</a>, and the <a href="https://www.sparkfun.com/products/15193">SparkFun ZOE-M8Q</a>. Library also works with other u-blox based boards.<br/><br/>The ZED-F9P and NEO-M8P-2 modules are top-of-the-line modules for high accuracy GNSS and GPS location solutions including RTK. The ZED-F9P is unique in that it is capable of both rover and base station operations allowing the module to become a base station and produce RTCM 3.x correction data.<br/>
-category=Sensors
-url=https://github.com/sparkfun/SparkFun_u-blox_GNSS_Arduino_Library
-architectures=*
diff --git a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/src/SparkFun_u-blox_GNSS_Arduino_Library.cpp b/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/src/SparkFun_u-blox_GNSS_Arduino_Library.cpp
deleted file mode 100644
index 2f71233..0000000
--- a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/src/SparkFun_u-blox_GNSS_Arduino_Library.cpp
+++ /dev/null
@@ -1,10502 +0,0 @@
-/*
-	This is a library written for the u-blox ZED-F9P and NEO-M8P-2
-	SparkFun sells these at its website: www.sparkfun.com
-	Do you like this library? Help support SparkFun. Buy a board!
-	https://www.sparkfun.com/products/16481
-	https://www.sparkfun.com/products/15136
-	https://www.sparkfun.com/products/15005
-	https://www.sparkfun.com/products/15733
-	https://www.sparkfun.com/products/15193
-	https://www.sparkfun.com/products/15210
-
-  Original version by Nathan Seidle @ SparkFun Electronics, September 6th, 2018
-	v2.0 rework by Paul Clark @ SparkFun Electronics, December 31st, 2020
-
-	This library handles configuring and handling the responses
-	from a u-blox GPS module. Works with most modules from u-blox including
-	the Zed-F9P, NEO-M8P-2, NEO-M9N, ZOE-M8Q, SAM-M8Q, and many others.
-
-	https://github.com/sparkfun/SparkFun_Ublox_Arduino_Library
-
-	Development environment specifics:
-	Arduino IDE 1.8.13
-
-	SparkFun code, firmware, and software is released under the MIT License(http://opensource.org/licenses/MIT).
-	The MIT License (MIT)
-	Copyright (c) 2016 SparkFun Electronics
-	Permission is hereby granted, free of charge, to any person obtaining a copy of this software and
-	associated documentation files (the "Software"), to deal in the Software without restriction,
-	including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
-	and/or sell copies of the Software, and to permit persons to whom the Software is furnished to
-	do so, subject to the following conditions:
-
-	The above copyright notice and this permission notice shall be included in all copies or substantial
-	portions of the Software.
-
-	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT
-	NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
-	IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
-	WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
-	SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-*/
-
-#include "SparkFun_u-blox_GNSS_Arduino_Library.h"
-
-SFE_UBLOX_GNSS::SFE_UBLOX_GNSS(void)
-{
-  // Constructor
-  if (debugPin >= 0)
-  {
-    pinMode((uint8_t)debugPin, OUTPUT);
-    digitalWrite((uint8_t)debugPin, HIGH);
-  }
-}
-
-//Stop all automatic message processing. Free all used RAM
-void SFE_UBLOX_GNSS::end(void)
-{
-  //Note: payloadCfg is not deleted
-
-  //Note: payloadAuto is not deleted
-
-  if (ubxFileBuffer != NULL)  // Check if RAM has been allocated for the file buffer
-  {
-    if (_printDebug == true)
-    {
-      _debugSerial->println(F("end: the file buffer has been deleted. You will need to call setFileBufferSize before .begin to create a new one."));
-    }
-    delete[] ubxFileBuffer;
-    ubxFileBuffer = NULL; // Redundant?
-    fileBufferSize = 0; // Reset file buffer size. User will have to call setFileBufferSize again
-    fileBufferMaxAvail = 0;
-  }
-
-  if (moduleSWVersion != NULL)
-  {
-    delete[] moduleSWVersion;
-    moduleSWVersion = NULL; // Redundant?
-  }
-
-  if (currentGeofenceParams != NULL)
-  {
-    delete[] currentGeofenceParams;
-    currentGeofenceParams = NULL; // Redundant?
-  }
-  
-  if (packetUBXNAVPOSECEF != NULL)
-  {
-    if (packetUBXNAVPOSECEF->callbackData != NULL)
-    {
-      delete[] packetUBXNAVPOSECEF->callbackData;
-    }
-    delete[] packetUBXNAVPOSECEF;
-    packetUBXNAVPOSECEF = NULL; // Redundant?  
-  }
-
-  if (packetUBXNAVSTATUS != NULL)
-  {
-    if (packetUBXNAVSTATUS->callbackData != NULL)
-    {
-      delete[] packetUBXNAVSTATUS->callbackData;
-    }
-    delete[] packetUBXNAVSTATUS;
-    packetUBXNAVSTATUS = NULL; // Redundant?  
-  }
-
-  if (packetUBXNAVDOP != NULL)
-  {
-    if (packetUBXNAVDOP->callbackData != NULL)
-    {
-      delete[] packetUBXNAVDOP->callbackData;
-    }
-    delete[] packetUBXNAVDOP;
-    packetUBXNAVDOP = NULL; // Redundant?  
-  }
-
-  if (packetUBXNAVATT != NULL)
-  {
-    if (packetUBXNAVATT->callbackData != NULL)
-    {
-      delete[] packetUBXNAVATT->callbackData;
-    }
-    delete[] packetUBXNAVATT;
-    packetUBXNAVATT = NULL; // Redundant?  
-  }
-
-  if (packetUBXNAVPVT != NULL)
-  {
-    if (packetUBXNAVPVT->callbackData != NULL)
-    {
-      delete[] packetUBXNAVPVT->callbackData;
-      if (_printDebug == true)
-      {
-        _debugSerial->println(F("end: packetUBXNAVPVT->callbackData has been deleted"));
-      }
-    }
-    delete[] packetUBXNAVPVT;
-    packetUBXNAVPVT = NULL; // Redundant?  
-    if (_printDebug == true)
-    {
-      _debugSerial->println(F("end: packetUBXNAVPVT has been deleted"));
-    }
-  }
-
-  if (packetUBXNAVODO != NULL)
-  {
-    if (packetUBXNAVODO->callbackData != NULL)
-    {
-      delete[] packetUBXNAVODO->callbackData;
-    }
-    delete[] packetUBXNAVODO;
-    packetUBXNAVODO = NULL; // Redundant?  
-  }
-
-  if (packetUBXNAVVELECEF != NULL)
-  {
-    if (packetUBXNAVVELECEF->callbackData != NULL)
-    {
-      delete[] packetUBXNAVVELECEF->callbackData;
-    }
-    delete[] packetUBXNAVVELECEF;
-    packetUBXNAVVELECEF = NULL; // Redundant?  
-  }
-
-  if (packetUBXNAVVELNED != NULL)
-  {
-    if (packetUBXNAVVELNED->callbackData != NULL)
-    {
-      delete[] packetUBXNAVVELNED->callbackData;
-    }
-    delete[] packetUBXNAVVELNED;
-    packetUBXNAVVELNED = NULL; // Redundant?  
-  }
-
-  if (packetUBXNAVHPPOSECEF != NULL)
-  {
-    if (packetUBXNAVHPPOSECEF->callbackData != NULL)
-    {
-      delete[] packetUBXNAVHPPOSECEF->callbackData;
-    }
-    delete[] packetUBXNAVHPPOSECEF;
-    packetUBXNAVHPPOSECEF = NULL; // Redundant?  
-  }
-
-  if (packetUBXNAVHPPOSLLH != NULL)
-  {
-    if (packetUBXNAVHPPOSLLH->callbackData != NULL)
-    {
-      delete[] packetUBXNAVHPPOSLLH->callbackData;
-    }
-    delete[] packetUBXNAVHPPOSLLH;
-    packetUBXNAVHPPOSLLH = NULL; // Redundant?  
-  }
-
-  if (packetUBXNAVCLOCK != NULL)
-  {
-    if (packetUBXNAVCLOCK->callbackData != NULL)
-    {
-      delete[] packetUBXNAVCLOCK->callbackData;
-    }
-    delete[] packetUBXNAVCLOCK;
-    packetUBXNAVCLOCK = NULL; // Redundant?  
-  }
-
-  if (packetUBXNAVSVIN != NULL)
-  {
-    if (packetUBXNAVSVIN->callbackData != NULL)
-    {
-      delete[] packetUBXNAVSVIN->callbackData;
-    }
-    delete[] packetUBXNAVSVIN;
-    packetUBXNAVSVIN = NULL; // Redundant?  
-  }
-
-  if (packetUBXNAVRELPOSNED != NULL)
-  {
-    if (packetUBXNAVRELPOSNED->callbackData != NULL)
-    {
-      delete[] packetUBXNAVRELPOSNED->callbackData;
-    }
-    delete[] packetUBXNAVRELPOSNED;
-    packetUBXNAVRELPOSNED = NULL; // Redundant?  
-  }
-
-  if (packetUBXRXMSFRBX != NULL)
-  {
-    if (packetUBXRXMSFRBX->callbackData != NULL)
-    {
-      delete[] packetUBXRXMSFRBX->callbackData;
-    }
-    delete[] packetUBXRXMSFRBX;
-    packetUBXRXMSFRBX = NULL; // Redundant?  
-  }
-
-  if (packetUBXRXMRAWX != NULL)
-  {
-    if (packetUBXRXMRAWX->callbackData != NULL)
-    {
-      delete[] packetUBXRXMRAWX->callbackData;
-    }
-    delete[] packetUBXRXMRAWX;
-    packetUBXRXMRAWX = NULL; // Redundant?  
-  }
-
-  if (packetUBXCFGRATE != NULL)
-  {
-    if (packetUBXCFGRATE->callbackData != NULL)
-    {
-      delete[] packetUBXCFGRATE->callbackData;
-    }
-    delete[] packetUBXCFGRATE;
-    packetUBXCFGRATE = NULL; // Redundant?  
-  }
-
-  if (packetUBXTIMTM2 != NULL)
-  {
-    if (packetUBXTIMTM2->callbackData != NULL)
-    {
-      delete[] packetUBXTIMTM2->callbackData;
-    }
-    delete[] packetUBXTIMTM2;
-    packetUBXTIMTM2 = NULL; // Redundant?  
-  }
-
-  if (packetUBXESFALG != NULL)
-  {
-    if (packetUBXESFALG->callbackData != NULL)
-    {
-      delete[] packetUBXESFALG->callbackData;
-    }
-    delete[] packetUBXESFALG;
-    packetUBXESFALG = NULL; // Redundant?  
-  }
-
-  if (packetUBXESFSTATUS != NULL)
-  {
-    if (packetUBXESFSTATUS->callbackData != NULL)
-    {
-      delete[] packetUBXESFSTATUS->callbackData;
-    }
-    delete[] packetUBXESFSTATUS;
-    packetUBXESFSTATUS = NULL; // Redundant?  
-  }
-
-  if (packetUBXESFINS != NULL)
-  {
-    if (packetUBXESFINS->callbackData != NULL)
-    {
-      delete[] packetUBXESFINS->callbackData;
-    }
-    delete[] packetUBXESFINS;
-    packetUBXESFINS = NULL; // Redundant?  
-  }
-
-  if (packetUBXESFMEAS != NULL)
-  {
-    if (packetUBXESFMEAS->callbackData != NULL)
-    {
-      delete[] packetUBXESFMEAS->callbackData;
-    }
-    delete[] packetUBXESFMEAS;
-    packetUBXESFMEAS = NULL; // Redundant?  
-  }
-
-  if (packetUBXESFRAW != NULL)
-  {
-    if (packetUBXESFRAW->callbackData != NULL)
-    {
-      delete[] packetUBXESFRAW->callbackData;
-    }
-    delete[] packetUBXESFRAW;
-    packetUBXESFRAW = NULL; // Redundant?  
-  }
-
-  if (packetUBXHNRATT != NULL)
-  {
-    if (packetUBXHNRATT->callbackData != NULL)
-    {
-      delete[] packetUBXHNRATT->callbackData;
-    }
-    delete[] packetUBXHNRATT;
-    packetUBXHNRATT = NULL; // Redundant?  
-  }
-
-  if (packetUBXHNRINS != NULL)
-  {
-    if (packetUBXHNRINS->callbackData != NULL)
-    {
-      delete[] packetUBXHNRINS->callbackData;
-    }
-    delete[] packetUBXHNRINS;
-    packetUBXHNRINS = NULL; // Redundant?  
-  }
-
-  if (packetUBXHNRPVT != NULL)
-  {
-    if (packetUBXHNRPVT->callbackData != NULL)
-    {
-      delete[] packetUBXHNRPVT->callbackData;
-    }
-    delete[] packetUBXHNRPVT;
-    packetUBXHNRPVT = NULL; // Redundant?  
-  }
-
-}
-
-//Allow the user to change packetCfgPayloadSize. Handy if you want to process big messages like RAWX
-//This can be called before .begin if required / desired
-void SFE_UBLOX_GNSS::setPacketCfgPayloadSize(size_t payloadSize)
-{
-  if ((payloadSize == 0) && (payloadCfg != NULL))
-  {
-    // Zero payloadSize? Dangerous! But we'll free the memory anyway...
-    delete[] payloadCfg;
-    payloadCfg = NULL; // Redundant?
-    packetCfg.payload = payloadCfg;
-    if ((_printDebug == true) || (_printLimitedDebug == true)) // This is important. Print this if doing limited debugging
-      _debugSerial->println(F("setPacketCfgPayloadSize: Zero payloadSize!"));
-  }
-
-  else if (payloadCfg == NULL) //Memory has not yet been allocated - so use new
-  {
-    payloadCfg = new uint8_t[payloadSize];
-    packetCfg.payload = payloadCfg;
-    if (payloadCfg == NULL)
-      if ((_printDebug == true) || (_printLimitedDebug == true)) // This is important. Print this if doing limited debugging
-        _debugSerial->println(F("setPacketCfgPayloadSize: PANIC! RAM allocation failed!"));
-  }
-
-  else //Memory has already been allocated - so resize
-  {
-    uint8_t *newPayload = new uint8_t[payloadSize];
-    for (size_t i = 0; (i < payloadSize) && (i < packetCfgPayloadSize); i++) // Copy as much existing data as we can
-      newPayload[i] = payloadCfg[i];
-    delete[] payloadCfg;
-    payloadCfg = newPayload;
-    packetCfg.payload = payloadCfg;
-    if (payloadCfg == NULL)
-      if ((_printDebug == true) || (_printLimitedDebug == true)) // This is important. Print this if doing limited debugging
-        _debugSerial->println(F("setPacketCfgPayloadSize: PANIC! RAM resize failed!"));
-  }
-
-  packetCfgPayloadSize = payloadSize;
-}
-
-//Initialize the I2C port
-boolean SFE_UBLOX_GNSS::begin(TwoWire &wirePort, uint8_t deviceAddress)
-{
-  commType = COMM_TYPE_I2C;
-  _i2cPort = &wirePort; //Grab which port the user wants us to use
-
-  //We expect caller to begin their I2C port, with the speed of their choice external to the library
-  //But if they forget, we start the hardware here.
-
-  //We're moving away from the practice of starting Wire hardware in a library. This is to avoid cross platform issues.
-  //ie, there are some platforms that don't handle multiple starts to the wire hardware. Also, every time you start the wire
-  //hardware the clock speed reverts back to 100kHz regardless of previous Wire.setClocks().
-  //_i2cPort->begin();
-
-  _gpsI2Caddress = deviceAddress; //Store the I2C address from user
-
-  //New in v2.0: allocate memory for the packetCfg payload here - if required. (The user may have called setPacketCfgPayloadSize already)
-  if (packetCfgPayloadSize == 0)
-    setPacketCfgPayloadSize(MAX_PAYLOAD_SIZE);
-
-  //New in v2.0: allocate memory for the file buffer - if required. (The user should have called setFileBufferSize already)
-  createFileBuffer();
-
-  // Call isConnected up to three times - tests on the NEO-M8U show the CFG RATE poll occasionally being ignored
-  boolean connected = isConnected();
-
-  if (!connected)
-    connected = isConnected();
-
-  if (!connected)
-    connected = isConnected();
-
-  return (connected);
-}
-
-//Initialize the Serial port
-boolean SFE_UBLOX_GNSS::begin(Stream &serialPort)
-{
-  commType = COMM_TYPE_SERIAL;
-  _serialPort = &serialPort; //Grab which port the user wants us to use
-
-  //New in v2.0: allocate memory for the packetCfg payload here - if required. (The user may have called setPacketCfgPayloadSize already)
-  if (packetCfgPayloadSize == 0)
-    setPacketCfgPayloadSize(MAX_PAYLOAD_SIZE);
-
-  //New in v2.0: allocate memory for the file buffer - if required. (The user should have called setFileBufferSize already)
-  createFileBuffer();
-
-  // Call isConnected up to three times - tests on the NEO-M8U show the CFG RATE poll occasionally being ignored
-  boolean connected = isConnected();
-
-  if (!connected)
-    connected = isConnected();
-
-  if (!connected)
-    connected = isConnected();
-
-  return (connected);
-}
-
-// Allow the user to change I2C polling wait (the minimum interval between I2C data requests - to avoid pounding the bus)
-// i2cPollingWait defaults to 100ms and is adjusted automatically when setNavigationFrequency()
-// or setHNRNavigationRate() are called. But if the user is using callbacks, it might be advantageous
-// to be able to set the polling wait manually.
-void SFE_UBLOX_GNSS::setI2CpollingWait(uint8_t newPollingWait_ms)
-{
-  i2cPollingWait = newPollingWait_ms;
-}
-
-//Sets the global size for I2C transactions
-//Most platforms use 32 bytes (the default) but this allows users to increase the transaction
-//size if the platform supports it
-//Note: If the transaction size is set larger than the platforms buffer size, bad things will happen.
-void SFE_UBLOX_GNSS::setI2CTransactionSize(uint8_t transactionSize)
-{
-  i2cTransactionSize = transactionSize;
-}
-uint8_t SFE_UBLOX_GNSS::getI2CTransactionSize(void)
-{
-  return (i2cTransactionSize);
-}
-
-//Returns true if I2C device ack's
-boolean SFE_UBLOX_GNSS::isConnected(uint16_t maxWait)
-{
-  if (commType == COMM_TYPE_I2C)
-  {
-    _i2cPort->beginTransmission((uint8_t)_gpsI2Caddress);
-    if (_i2cPort->endTransmission() != 0)
-      return false; //Sensor did not ack
-  }
-
-  // Query navigation rate to see whether we get a meaningful response
-  return (getNavigationFrequencyInternal(maxWait));
-}
-
-//Enable or disable the printing of sent/response HEX values.
-//Use this in conjunction with 'Transport Logging' from the Universal Reader Assistant to see what they're doing that we're not
-void SFE_UBLOX_GNSS::enableDebugging(Stream &debugPort, boolean printLimitedDebug)
-{
-  _debugSerial = &debugPort; //Grab which port the user wants us to use for debugging
-  if (printLimitedDebug == false)
-  {
-    _printDebug = true; //Should we print the commands we send? Good for debugging
-  }
-  else
-  {
-    _printLimitedDebug = true; //Should we print limited debug messages? Good for debugging high navigation rates
-  }
-}
-void SFE_UBLOX_GNSS::disableDebugging(void)
-{
-  _printDebug = false; //Turn off extra print statements
-  _printLimitedDebug = false;
-}
-
-//Safely print messages
-void SFE_UBLOX_GNSS::debugPrint(char *message)
-{
-  if (_printDebug == true)
-  {
-    _debugSerial->print(message);
-  }
-}
-//Safely print messages
-void SFE_UBLOX_GNSS::debugPrintln(char *message)
-{
-  if (_printDebug == true)
-  {
-    _debugSerial->println(message);
-  }
-}
-
-const char *SFE_UBLOX_GNSS::statusString(sfe_ublox_status_e stat)
-{
-  switch (stat)
-  {
-  case SFE_UBLOX_STATUS_SUCCESS:
-    return "Success";
-    break;
-  case SFE_UBLOX_STATUS_FAIL:
-    return "General Failure";
-    break;
-  case SFE_UBLOX_STATUS_CRC_FAIL:
-    return "CRC Fail";
-    break;
-  case SFE_UBLOX_STATUS_TIMEOUT:
-    return "Timeout";
-    break;
-  case SFE_UBLOX_STATUS_COMMAND_NACK:
-    return "Command not acknowledged (NACK)";
-    break;
-  case SFE_UBLOX_STATUS_OUT_OF_RANGE:
-    return "Out of range";
-    break;
-  case SFE_UBLOX_STATUS_INVALID_ARG:
-    return "Invalid Arg";
-    break;
-  case SFE_UBLOX_STATUS_INVALID_OPERATION:
-    return "Invalid operation";
-    break;
-  case SFE_UBLOX_STATUS_MEM_ERR:
-    return "Memory Error";
-    break;
-  case SFE_UBLOX_STATUS_HW_ERR:
-    return "Hardware Error";
-    break;
-  case SFE_UBLOX_STATUS_DATA_SENT:
-    return "Data Sent";
-    break;
-  case SFE_UBLOX_STATUS_DATA_RECEIVED:
-    return "Data Received";
-    break;
-  case SFE_UBLOX_STATUS_I2C_COMM_FAILURE:
-    return "I2C Comm Failure";
-    break;
-  case SFE_UBLOX_STATUS_DATA_OVERWRITTEN:
-    return "Data Packet Overwritten";
-    break;
-  default:
-    return "Unknown Status";
-    break;
-  }
-  return "None";
-}
-
-// Check for the arrival of new I2C/Serial data
-
-//Allow the user to disable the "7F" check (e.g.) when logging RAWX data
-void SFE_UBLOX_GNSS::disableUBX7Fcheck(boolean disabled)
-{
-  ubx7FcheckDisabled = disabled;
-}
-
-//Called regularly to check for available bytes on the user' specified port
-boolean SFE_UBLOX_GNSS::checkUblox(uint8_t requestedClass, uint8_t requestedID)
-{
-  return checkUbloxInternal(&packetCfg, requestedClass, requestedID);
-}
-
-//PRIVATE: Called regularly to check for available bytes on the user' specified port
-boolean SFE_UBLOX_GNSS::checkUbloxInternal(ubxPacket *incomingUBX, uint8_t requestedClass, uint8_t requestedID)
-{
-  if (commType == COMM_TYPE_I2C)
-    return (checkUbloxI2C(incomingUBX, requestedClass, requestedID));
-  else if (commType == COMM_TYPE_SERIAL)
-    return (checkUbloxSerial(incomingUBX, requestedClass, requestedID));
-  return false;
-}
-
-//Polls I2C for data, passing any new bytes to process()
-//Returns true if new bytes are available
-boolean SFE_UBLOX_GNSS::checkUbloxI2C(ubxPacket *incomingUBX, uint8_t requestedClass, uint8_t requestedID)
-{
-  if (millis() - lastCheck >= i2cPollingWait)
-  {
-    //Get the number of bytes available from the module
-    uint16_t bytesAvailable = 0;
-    _i2cPort->beginTransmission(_gpsI2Caddress);
-    _i2cPort->write(0xFD);                     //0xFD (MSB) and 0xFE (LSB) are the registers that contain number of bytes available
-    if (_i2cPort->endTransmission(false) != 0) //Send a restart command. Do not release bus.
-      return (false);                          //Sensor did not ACK
-
-    _i2cPort->requestFrom((uint8_t)_gpsI2Caddress, (uint8_t)2);
-    if (_i2cPort->available())
-    {
-      uint8_t msb = _i2cPort->read();
-      uint8_t lsb = _i2cPort->read();
-      if (lsb == 0xFF)
-      {
-        //I believe this is a u-blox bug. Device should never present an 0xFF.
-        if ((_printDebug == true) || (_printLimitedDebug == true)) // This is important. Print this if doing limited debugging
-        {
-          _debugSerial->println(F("checkUbloxI2C: u-blox bug, length lsb is 0xFF"));
-        }
-        if (debugPin >= 0)
-        {
-          digitalWrite((uint8_t)debugPin, LOW);
-          delay(10);
-          digitalWrite((uint8_t)debugPin, HIGH);
-        }
-        lastCheck = millis(); //Put off checking to avoid I2C bus traffic
-        return (false);
-      }
-      bytesAvailable = (uint16_t)msb << 8 | lsb;
-    }
-
-    if (bytesAvailable == 0)
-    {
-      if (_printDebug == true)
-      {
-        _debugSerial->println(F("checkUbloxI2C: OK, zero bytes available"));
-      }
-      lastCheck = millis(); //Put off checking to avoid I2C bus traffic
-      return (false);
-    }
-
-    //Check for undocumented bit error. We found this doing logic scans.
-    //This error is rare but if we incorrectly interpret the first bit of the two 'data available' bytes as 1
-    //then we have far too many bytes to check. May be related to I2C setup time violations: https://github.com/sparkfun/SparkFun_Ublox_Arduino_Library/issues/40
-    if (bytesAvailable & ((uint16_t)1 << 15))
-    {
-      //Clear the MSbit
-      bytesAvailable &= ~((uint16_t)1 << 15);
-
-      if ((_printDebug == true) || (_printLimitedDebug == true)) // This is important. Print this if doing limited debugging
-      {
-        _debugSerial->print(F("checkUbloxI2C: Bytes available error: "));
-        _debugSerial->println(bytesAvailable);
-        if (debugPin >= 0)
-        {
-          digitalWrite((uint8_t)debugPin, LOW);
-          delay(10);
-          digitalWrite((uint8_t)debugPin, HIGH);
-        }
-      }
-    }
-
-    if (bytesAvailable > 100)
-    {
-      if (_printDebug == true)
-      {
-        _debugSerial->print(F("checkUbloxI2C: Large packet of "));
-        _debugSerial->print(bytesAvailable);
-        _debugSerial->println(F(" bytes received"));
-      }
-    }
-    else
-    {
-      if (_printDebug == true)
-      {
-        _debugSerial->print(F("checkUbloxI2C: Reading "));
-        _debugSerial->print(bytesAvailable);
-        _debugSerial->println(F(" bytes"));
-      }
-    }
-
-    while (bytesAvailable)
-    {
-      _i2cPort->beginTransmission(_gpsI2Caddress);
-      _i2cPort->write(0xFF);                     //0xFF is the register to read data from
-      if (_i2cPort->endTransmission(false) != 0) //Send a restart command. Do not release bus.
-        return (false);                          //Sensor did not ACK
-
-      //Limit to 32 bytes or whatever the buffer limit is for given platform
-      uint16_t bytesToRead = bytesAvailable;
-      if (bytesToRead > i2cTransactionSize)
-        bytesToRead = i2cTransactionSize;
-
-    TRY_AGAIN:
-
-      _i2cPort->requestFrom((uint8_t)_gpsI2Caddress, (uint8_t)bytesToRead);
-      if (_i2cPort->available())
-      {
-        for (uint16_t x = 0; x < bytesToRead; x++)
-        {
-          uint8_t incoming = _i2cPort->read(); //Grab the actual character
-
-          //Check to see if the first read is 0x7F. If it is, the module is not ready
-          //to respond. Stop, wait, and try again
-          if (x == 0)
-          {
-            if ((incoming == 0x7F) && (ubx7FcheckDisabled == false))
-            {
-              if ((_printDebug == true) || (_printLimitedDebug == true)) // This is important. Print this if doing limited debugging
-              {
-                _debugSerial->println(F("checkUbloxU2C: u-blox error, module not ready with data (7F error)"));
-              }
-              delay(5); //In logic analyzation, the module starting responding after 1.48ms
-              if (debugPin >= 0)
-              {
-                digitalWrite((uint8_t)debugPin, LOW);
-                delay(10);
-                digitalWrite((uint8_t)debugPin, HIGH);
-              }
-              goto TRY_AGAIN;
-            }
-          }
-
-          process(incoming, incomingUBX, requestedClass, requestedID); //Process this valid character
-        }
-      }
-      else
-        return (false); //Sensor did not respond
-
-      bytesAvailable -= bytesToRead;
-    }
-  }
-
-  return (true);
-
-} //end checkUbloxI2C()
-
-//Checks Serial for data, passing any new bytes to process()
-boolean SFE_UBLOX_GNSS::checkUbloxSerial(ubxPacket *incomingUBX, uint8_t requestedClass, uint8_t requestedID)
-{
-  while (_serialPort->available())
-  {
-    process(_serialPort->read(), incomingUBX, requestedClass, requestedID);
-  }
-  return (true);
-
-} //end checkUbloxSerial()
-
-//PRIVATE: Check if we have storage allocated for an incoming "automatic" message
-boolean SFE_UBLOX_GNSS::checkAutomatic(uint8_t Class, uint8_t ID)
-{
-  boolean result = false;
-  switch (Class)
-  {
-    case UBX_CLASS_NAV:
-    {
-      switch (ID)
-      {
-        case UBX_NAV_POSECEF:
-          if (packetUBXNAVPOSECEF != NULL) result = true;
-        break;
-        case UBX_NAV_STATUS:
-          if (packetUBXNAVSTATUS != NULL) result = true;
-        break;
-        case UBX_NAV_DOP:
-          if (packetUBXNAVDOP != NULL) result = true;
-        break;
-        case UBX_NAV_ATT:
-          if (packetUBXNAVATT != NULL) result = true;
-        break;
-        case UBX_NAV_PVT:
-          if (packetUBXNAVPVT != NULL) result = true;
-        break;
-        case UBX_NAV_ODO:
-          if (packetUBXNAVODO != NULL) result = true;
-        break;
-        case UBX_NAV_VELECEF:
-          if (packetUBXNAVVELECEF != NULL) result = true;
-        break;
-        case UBX_NAV_VELNED:
-          if (packetUBXNAVVELNED != NULL) result = true;
-        break;
-        case UBX_NAV_HPPOSECEF:
-          if (packetUBXNAVHPPOSECEF != NULL) result = true;
-        break;
-        case UBX_NAV_HPPOSLLH:
-          if (packetUBXNAVHPPOSLLH != NULL) result = true;
-        break;
-        case UBX_NAV_CLOCK:
-          if (packetUBXNAVCLOCK != NULL) result = true;
-        break;
-        case UBX_NAV_SVIN:
-          if (packetUBXNAVSVIN != NULL) result = true;
-        break;
-        case UBX_NAV_RELPOSNED:
-          if (packetUBXNAVRELPOSNED != NULL) result = true;
-        break;
-      }
-    }
-    break;
-    case UBX_CLASS_RXM:
-    {
-      switch (ID)
-      {
-        case UBX_RXM_SFRBX:
-          if (packetUBXRXMSFRBX != NULL) result = true;
-        break;
-        case UBX_RXM_RAWX:
-          if (packetUBXRXMRAWX != NULL) result = true;
-        break;
-      }
-    }
-    break;
-    case UBX_CLASS_CFG:
-    {
-      switch (ID)
-      {
-        case UBX_CFG_RATE:
-          if (packetUBXCFGRATE != NULL) result = true;
-        break;
-      }
-    }
-    break;
-    case UBX_CLASS_TIM:
-    {
-      switch (ID)
-      {
-        case UBX_TIM_TM2:
-          if (packetUBXTIMTM2 != NULL) result = true;
-        break;
-      }
-    }
-    break;
-    case UBX_CLASS_ESF:
-    {
-      switch (ID)
-      {
-        case UBX_ESF_ALG:
-          if (packetUBXESFALG != NULL) result = true;
-        break;
-        case UBX_ESF_INS:
-          if (packetUBXESFINS != NULL) result = true;
-        break;
-        case UBX_ESF_MEAS:
-          if (packetUBXESFMEAS != NULL) result = true;
-        break;
-        case UBX_ESF_RAW:
-          if (packetUBXESFRAW != NULL) result = true;
-        break;
-        case UBX_ESF_STATUS:
-          if (packetUBXESFSTATUS != NULL) result = true;
-        break;
-      }
-    }
-    break;
-    case UBX_CLASS_HNR:
-    {
-      switch (ID)
-      {
-        case UBX_HNR_PVT:
-          if (packetUBXHNRPVT != NULL) result = true;
-        break;
-        case UBX_HNR_ATT:
-          if (packetUBXHNRATT != NULL) result = true;
-        break;
-        case UBX_HNR_INS:
-          if (packetUBXHNRINS != NULL) result = true;
-        break;
-      }
-    }
-    break;
-  }
-  return (result);
-}
-
-//PRIVATE: Calculate how much RAM is needed to store the payload for a given automatic message
-uint16_t SFE_UBLOX_GNSS::getMaxPayloadSize(uint8_t Class, uint8_t ID)
-{
-  uint16_t maxSize = 0;
-  switch (Class)
-  {
-    case UBX_CLASS_NAV:
-    {
-      switch (ID)
-      {
-        case UBX_NAV_POSECEF:
-          maxSize = UBX_NAV_POSECEF_LEN;
-        break;
-        case UBX_NAV_STATUS:
-          maxSize = UBX_NAV_STATUS_LEN;
-        break;
-        case UBX_NAV_DOP:
-          maxSize = UBX_NAV_DOP_LEN;
-        break;
-        case UBX_NAV_ATT:
-          maxSize = UBX_NAV_ATT_LEN;
-        break;
-        case UBX_NAV_PVT:
-          maxSize = UBX_NAV_PVT_LEN;
-        break;
-        case UBX_NAV_ODO:
-          maxSize = UBX_NAV_ODO_LEN;
-        break;
-        case UBX_NAV_VELECEF:
-          maxSize = UBX_NAV_VELECEF_LEN;
-        break;
-        case UBX_NAV_VELNED:
-          maxSize = UBX_NAV_VELNED_LEN;
-        break;
-        case UBX_NAV_HPPOSECEF:
-          maxSize = UBX_NAV_HPPOSECEF_LEN;
-        break;
-        case UBX_NAV_HPPOSLLH:
-          maxSize = UBX_NAV_HPPOSLLH_LEN;
-        break;
-        case UBX_NAV_CLOCK:
-          maxSize = UBX_NAV_CLOCK_LEN;
-        break;
-        case UBX_NAV_SVIN:
-          maxSize = UBX_NAV_SVIN_LEN;
-        break;
-        case UBX_NAV_RELPOSNED:
-          maxSize = UBX_NAV_RELPOSNED_LEN_F9;
-        break;
-      }
-    }
-    break;
-    case UBX_CLASS_RXM:
-    {
-      switch (ID)
-      {
-        case UBX_RXM_SFRBX:
-          maxSize = UBX_RXM_SFRBX_MAX_LEN;
-        break;
-        case UBX_RXM_RAWX:
-          maxSize = UBX_RXM_RAWX_MAX_LEN;
-        break;
-      }
-    }
-    break;
-    case UBX_CLASS_CFG:
-    {
-      switch (ID)
-      {
-        case UBX_CFG_RATE:
-          maxSize = UBX_CFG_RATE_LEN;
-        break;
-      }
-    }
-    break;
-    case UBX_CLASS_TIM:
-    {
-      switch (ID)
-      {
-        case UBX_TIM_TM2:
-          maxSize = UBX_TIM_TM2_LEN;
-        break;
-      }
-    }
-    break;
-    case UBX_CLASS_ESF:
-    {
-      switch (ID)
-      {
-        case UBX_ESF_ALG:
-          maxSize = UBX_ESF_ALG_LEN;
-        break;
-        case UBX_ESF_INS:
-          maxSize = UBX_ESF_INS_LEN;
-        break;
-        case UBX_ESF_MEAS:
-          maxSize = UBX_ESF_MEAS_MAX_LEN;
-        break;
-        case UBX_ESF_RAW:
-          maxSize = UBX_ESF_RAW_MAX_LEN;
-        break;
-        case UBX_ESF_STATUS:
-          maxSize = UBX_ESF_STATUS_MAX_LEN;
-        break;
-      }
-    }
-    break;
-    case UBX_CLASS_HNR:
-    {
-      switch (ID)
-      {
-        case UBX_HNR_PVT:
-          maxSize = UBX_HNR_PVT_LEN;
-        break;
-        case UBX_HNR_ATT:
-          maxSize = UBX_HNR_ATT_LEN;
-        break;
-        case UBX_HNR_INS:
-          maxSize = UBX_HNR_INS_LEN;
-        break;
-      }
-    }
-    break;
-  }
-  return (maxSize);
-}
-
-//Processes NMEA and UBX binary sentences one byte at a time
-//Take a given byte and file it into the proper array
-void SFE_UBLOX_GNSS::process(uint8_t incoming, ubxPacket *incomingUBX, uint8_t requestedClass, uint8_t requestedID)
-{
-  if ((currentSentence == NONE) || (currentSentence == NMEA))
-  {
-    if (incoming == 0xB5) //UBX binary frames start with 0xB5, aka μ
-    {
-      //This is the start of a binary sentence. Reset flags.
-      //We still don't know the response class
-      ubxFrameCounter = 0;
-      currentSentence = UBX;
-      //Reset the packetBuf.counter even though we will need to reset it again when ubxFrameCounter == 2
-      packetBuf.counter = 0;
-      ignoreThisPayload = false; //We should not ignore this payload - yet
-      //Store data in packetBuf until we know if we have a requested class and ID match
-      activePacketBuffer = SFE_UBLOX_PACKET_PACKETBUF;
-    }
-    else if (incoming == '$')
-    {
-      currentSentence = NMEA;
-    }
-    else if (incoming == 0xD3) //RTCM frames start with 0xD3
-    {
-      rtcmFrameCounter = 0;
-      currentSentence = RTCM;
-    }
-    else
-    {
-      //This character is unknown or we missed the previous start of a sentence
-    }
-  }
-
-  //Depending on the sentence, pass the character to the individual processor
-  if (currentSentence == UBX)
-  {
-    //Decide what type of response this is
-    if ((ubxFrameCounter == 0) && (incoming != 0xB5))      //ISO 'μ'
-      currentSentence = NONE;                              //Something went wrong. Reset.
-    else if ((ubxFrameCounter == 1) && (incoming != 0x62)) //ASCII 'b'
-      currentSentence = NONE;                              //Something went wrong. Reset.
-    // Note to future self:
-    // There may be some duplication / redundancy in the next few lines as processUBX will also
-    // load information into packetBuf, but we'll do it here too for clarity
-    else if (ubxFrameCounter == 2) //Class
-    {
-      // Record the class in packetBuf until we know what to do with it
-      packetBuf.cls = incoming; // (Duplication)
-      rollingChecksumA = 0;     //Reset our rolling checksums here (not when we receive the 0xB5)
-      rollingChecksumB = 0;
-      packetBuf.counter = 0;                                   //Reset the packetBuf.counter (again)
-      packetBuf.valid = SFE_UBLOX_PACKET_VALIDITY_NOT_DEFINED; // Reset the packet validity (redundant?)
-      packetBuf.startingSpot = incomingUBX->startingSpot;      //Copy the startingSpot
-    }
-    else if (ubxFrameCounter == 3) //ID
-    {
-      // Record the ID in packetBuf until we know what to do with it
-      packetBuf.id = incoming; // (Duplication)
-      //We can now identify the type of response
-      //If the packet we are receiving is not an ACK then check for a class and ID match
-      if (packetBuf.cls != UBX_CLASS_ACK)
-      {
-        //This is not an ACK so check for a class and ID match
-        if ((packetBuf.cls == requestedClass) && (packetBuf.id == requestedID))
-        {
-          //This is not an ACK and we have a class and ID match
-          //So start diverting data into incomingUBX (usually packetCfg)
-          activePacketBuffer = SFE_UBLOX_PACKET_PACKETCFG;
-          incomingUBX->cls = packetBuf.cls; //Copy the class and ID into incomingUBX (usually packetCfg)
-          incomingUBX->id = packetBuf.id;
-          incomingUBX->counter = packetBuf.counter; //Copy over the .counter too
-        }
-        //This is not an ACK and we do not have a complete class and ID match
-        //So let's check if this is an "automatic" message which has its own storage defined
-        else if (checkAutomatic(packetBuf.cls, packetBuf.id))
-        {
-          //This is not the message we were expecting but it has its own storage and so we should process it anyway.
-          //We'll try to use packetAuto to buffer the message (so it can't overwrite anything in packetCfg).
-          //We need to allocate memory for the packetAuto payload (payloadAuto) - and delete it once
-          //reception is complete.
-          uint16_t maxPayload = getMaxPayloadSize(packetBuf.cls, packetBuf.id); // Calculate how much RAM we need
-          if (maxPayload == 0)
-          {
-            if ((_printDebug == true) || (_printLimitedDebug == true)) // This is important. Print this if doing limited debugging
-            {
-              _debugSerial->print(F("process: getMaxPayloadSize returned ZERO!! Class: 0x"));
-              _debugSerial->print(packetBuf.cls);
-              _debugSerial->print(F(" ID: 0x"));
-              _debugSerial->println(packetBuf.id);
-            }
-          }
-          if (payloadAuto != NULL) // Check if memory is already allocated - this should be impossible!
-          {
-            if ((_printDebug == true) || (_printLimitedDebug == true)) // This is important. Print this if doing limited debugging
-            {
-              _debugSerial->println(F("process: memory is already allocated for payloadAuto! Deleting..."));
-            }
-            delete[] payloadAuto;
-            payloadAuto = NULL; // Redundant?
-            packetAuto.payload = payloadAuto;
-          }
-          payloadAuto = new uint8_t[maxPayload]; // Allocate RAM for payloadAuto
-          packetAuto.payload = payloadAuto;
-          if (payloadAuto == NULL) // Check if the alloc failed
-          {
-            if ((_printDebug == true) || (_printLimitedDebug == true)) // This is important. Print this if doing limited debugging
-            {
-              _debugSerial->print(F("process: memory allocation failed for \"automatic\" message: Class: 0x"));
-              _debugSerial->print(packetBuf.cls, HEX);
-              _debugSerial->print(F(" ID: 0x"));
-              _debugSerial->println(packetBuf.id, HEX);
-              _debugSerial->println(F("process: \"automatic\" message could overwrite data"));
-            }
-            // The RAM allocation failed so fall back to using incomingUBX (usually packetCfg) even though we risk overwriting data
-            activePacketBuffer = SFE_UBLOX_PACKET_PACKETCFG;
-            incomingUBX->cls = packetBuf.cls; //Copy the class and ID into incomingUBX (usually packetCfg)
-            incomingUBX->id = packetBuf.id;
-            incomingUBX->counter = packetBuf.counter; //Copy over the .counter too
-          }
-          else
-          {
-            //The RAM allocation was successful so we start diverting data into packetAuto and process it
-            activePacketBuffer = SFE_UBLOX_PACKET_PACKETAUTO;
-            packetAuto.cls = packetBuf.cls; //Copy the class and ID into packetAuto
-            packetAuto.id = packetBuf.id;
-            packetAuto.counter = packetBuf.counter; //Copy over the .counter too
-            packetAuto.startingSpot = packetBuf.startingSpot; //And the starting spot? (Probably redundant)
-            if (_printDebug == true)
-            {
-              _debugSerial->print(F("process: incoming \"automatic\" message: Class: 0x"));
-              _debugSerial->print(packetBuf.cls, HEX);
-              _debugSerial->print(F(" ID: 0x"));
-              _debugSerial->println(packetBuf.id, HEX);
-            }
-          }
-        }
-        else
-        {
-          //This is not an ACK and we do not have a class and ID match
-          //so we should keep diverting data into packetBuf and ignore the payload
-          ignoreThisPayload = true;
-        }
-      }
-      else
-      {
-        // This is an ACK so it is to early to do anything with it
-        // We need to wait until we have received the length and data bytes
-        // So we should keep diverting data into packetBuf
-      }
-    }
-    else if (ubxFrameCounter == 4) //Length LSB
-    {
-      //We should save the length in packetBuf even if activePacketBuffer == SFE_UBLOX_PACKET_PACKETCFG
-      packetBuf.len = incoming; // (Duplication)
-    }
-    else if (ubxFrameCounter == 5) //Length MSB
-    {
-      //We should save the length in packetBuf even if activePacketBuffer == SFE_UBLOX_PACKET_PACKETCFG
-      packetBuf.len |= incoming << 8; // (Duplication)
-    }
-    else if (ubxFrameCounter == 6) //This should be the first byte of the payload unless .len is zero
-    {
-      if (packetBuf.len == 0) // Check if length is zero (hopefully this is impossible!)
-      {
-        if ((_printDebug == true) || (_printLimitedDebug == true)) // This is important. Print this if doing limited debugging
-        {
-          _debugSerial->print(F("process: ZERO LENGTH packet received: Class: 0x"));
-          _debugSerial->print(packetBuf.cls, HEX);
-          _debugSerial->print(F(" ID: 0x"));
-          _debugSerial->println(packetBuf.id, HEX);
-        }
-        //If length is zero (!) this will be the first byte of the checksum so record it
-        packetBuf.checksumA = incoming;
-      }
-      else
-      {
-        //The length is not zero so record this byte in the payload
-        packetBuf.payload[0] = incoming;
-      }
-    }
-    else if (ubxFrameCounter == 7) //This should be the second byte of the payload unless .len is zero or one
-    {
-      if (packetBuf.len == 0) // Check if length is zero (hopefully this is impossible!)
-      {
-        //If length is zero (!) this will be the second byte of the checksum so record it
-        packetBuf.checksumB = incoming;
-      }
-      else if (packetBuf.len == 1) // Check if length is one
-      {
-        //The length is one so this is the first byte of the checksum
-        packetBuf.checksumA = incoming;
-      }
-      else // Length is >= 2 so this must be a payload byte
-      {
-        packetBuf.payload[1] = incoming;
-      }
-      // Now that we have received two payload bytes, we can check for a matching ACK/NACK
-      if ((activePacketBuffer == SFE_UBLOX_PACKET_PACKETBUF) // If we are not already processing a data packet
-          && (packetBuf.cls == UBX_CLASS_ACK)                // and if this is an ACK/NACK
-          && (packetBuf.payload[0] == requestedClass)        // and if the class matches
-          && (packetBuf.payload[1] == requestedID))          // and if the ID matches
-      {
-        if (packetBuf.len == 2) // Check if .len is 2
-        {
-          // Then this is a matching ACK so copy it into packetAck
-          activePacketBuffer = SFE_UBLOX_PACKET_PACKETACK;
-          packetAck.cls = packetBuf.cls;
-          packetAck.id = packetBuf.id;
-          packetAck.len = packetBuf.len;
-          packetAck.counter = packetBuf.counter;
-          packetAck.payload[0] = packetBuf.payload[0];
-          packetAck.payload[1] = packetBuf.payload[1];
-        }
-        else // Length is not 2 (hopefully this is impossible!)
-        {
-          if ((_printDebug == true) || (_printLimitedDebug == true)) // This is important. Print this if doing limited debugging
-          {
-            _debugSerial->print(F("process: ACK received with .len != 2: Class: 0x"));
-            _debugSerial->print(packetBuf.payload[0], HEX);
-            _debugSerial->print(F(" ID: 0x"));
-            _debugSerial->print(packetBuf.payload[1], HEX);
-            _debugSerial->print(F(" len: "));
-            _debugSerial->println(packetBuf.len);
-          }
-        }
-      }
-    }
-
-    //Divert incoming into the correct buffer
-    if (activePacketBuffer == SFE_UBLOX_PACKET_PACKETACK)
-      processUBX(incoming, &packetAck, requestedClass, requestedID);
-    else if (activePacketBuffer == SFE_UBLOX_PACKET_PACKETCFG)
-      processUBX(incoming, incomingUBX, requestedClass, requestedID);
-    else if (activePacketBuffer == SFE_UBLOX_PACKET_PACKETBUF)
-      processUBX(incoming, &packetBuf, requestedClass, requestedID);
-    else // if (activePacketBuffer == SFE_UBLOX_PACKET_PACKETAUTO)
-      processUBX(incoming, &packetAuto, requestedClass, requestedID);
-
-    //Finally, increment the frame counter
-    ubxFrameCounter++;
-  }
-  else if (currentSentence == NMEA)
-  {
-    processNMEA(incoming); //Process each NMEA character
-  }
-  else if (currentSentence == RTCM)
-  {
-    processRTCMframe(incoming); //Deal with RTCM bytes
-  }
-}
-
-//This is the default or generic NMEA processor. We're only going to pipe the data to serial port so we can see it.
-//User could overwrite this function to pipe characters to nmea.process(c) of tinyGPS or MicroNMEA
-//Or user could pipe each character to a buffer, radio, etc.
-void SFE_UBLOX_GNSS::processNMEA(char incoming)
-{
-  //If user has assigned an output port then pipe the characters there
-  if (_nmeaOutputPort != NULL)
-    _nmeaOutputPort->write(incoming); //Echo this byte to the serial port
-}
-
-//We need to be able to identify an RTCM packet and then the length
-//so that we know when the RTCM message is completely received and we then start
-//listening for other sentences (like NMEA or UBX)
-//RTCM packet structure is very odd. I never found RTCM STANDARD 10403.2 but
-//http://d1.amobbs.com/bbs_upload782111/files_39/ourdev_635123CK0HJT.pdf is good
-//https://dspace.cvut.cz/bitstream/handle/10467/65205/F3-BP-2016-Shkalikava-Anastasiya-Prenos%20polohove%20informace%20prostrednictvim%20datove%20site.pdf?sequence=-1
-//Lead me to: https://forum.u-blox.com/index.php/4348/how-to-read-rtcm-messages-from-neo-m8p
-//RTCM 3.2 bytes look like this:
-//Byte 0: Always 0xD3
-//Byte 1: 6-bits of zero
-//Byte 2: 10-bits of length of this packet including the first two-ish header bytes, + 6.
-//byte 3 + 4 bits: Msg type 12 bits
-//Example: D3 00 7C 43 F0 ... / 0x7C = 124+6 = 130 bytes in this packet, 0x43F = Msg type 1087
-void SFE_UBLOX_GNSS::processRTCMframe(uint8_t incoming)
-{
-  if (rtcmFrameCounter == 1)
-  {
-    rtcmLen = (incoming & 0x03) << 8; //Get the last two bits of this byte. Bits 8&9 of 10-bit length
-  }
-  else if (rtcmFrameCounter == 2)
-  {
-    rtcmLen |= incoming; //Bits 0-7 of packet length
-    rtcmLen += 6;        //There are 6 additional bytes of what we presume is header, msgType, CRC, and stuff
-  }
-  /*else if (rtcmFrameCounter == 3)
-  {
-    rtcmMsgType = incoming << 4; //Message Type, MS 4 bits
-  }
-  else if (rtcmFrameCounter == 4)
-  {
-    rtcmMsgType |= (incoming >> 4); //Message Type, bits 0-7
-  }*/
-
-  rtcmFrameCounter++;
-
-  processRTCM(incoming); //Here is where we expose this byte to the user
-
-  if (rtcmFrameCounter == rtcmLen)
-  {
-    //We're done!
-    currentSentence = NONE; //Reset and start looking for next sentence type
-  }
-}
-
-//This function is called for each byte of an RTCM frame
-//Ths user can overwrite this function and process the RTCM frame as they please
-//Bytes can be piped to Serial or other interface. The consumer could be a radio or the internet (Ntrip broadcaster)
-void SFE_UBLOX_GNSS::processRTCM(uint8_t incoming)
-{
-  //Radio.sendReliable((String)incoming); //An example of passing this byte to a radio
-
-  //_debugSerial->write(incoming); //An example of passing this byte out the serial port
-
-  //Debug printing
-  //  _debugSerial->print(F(" "));
-  //  if(incoming < 0x10) _debugSerial->print(F("0"));
-  //  if(incoming < 0x10) _debugSerial->print(F("0"));
-  //  _debugSerial->print(incoming, HEX);
-  //  if(rtcmFrameCounter % 16 == 0) _debugSerial->println();
-}
-
-//Given a character, file it away into the uxb packet structure
-//Set valid to VALID or NOT_VALID once sentence is completely received and passes or fails CRC
-//The payload portion of the packet can be 100s of bytes but the max array size is packetCfgPayloadSize bytes.
-//startingSpot can be set so we only record a subset of bytes within a larger packet.
-void SFE_UBLOX_GNSS::processUBX(uint8_t incoming, ubxPacket *incomingUBX, uint8_t requestedClass, uint8_t requestedID)
-{
-    //If incomingUBX is a user-defined custom packet, then the payload size could be different to packetCfgPayloadSize.
-    //TO DO: update this to prevent an overrun when receiving an automatic message
-    //       and the incomingUBX payload size is smaller than packetCfgPayloadSize.
-  size_t maximum_payload_size;
-  if (activePacketBuffer == SFE_UBLOX_PACKET_PACKETCFG)
-    maximum_payload_size = packetCfgPayloadSize;
-  else if (activePacketBuffer == SFE_UBLOX_PACKET_PACKETAUTO)
-  {
-    // Calculate maximum payload size once Class and ID have been received
-    // (This check is probably redundant as activePacketBuffer can only be SFE_UBLOX_PACKET_PACKETAUTO
-    //  when ubxFrameCounter >= 3)
-    //if (incomingUBX->counter >= 2)
-    //{
-      maximum_payload_size = getMaxPayloadSize(incomingUBX->cls, incomingUBX->id);
-      if (maximum_payload_size == 0)
-      {
-        if ((_printDebug == true) || (_printLimitedDebug == true)) // This is important. Print this if doing limited debugging
-        {
-          _debugSerial->print(F("processUBX: getMaxPayloadSize returned ZERO!! Class: 0x"));
-          _debugSerial->print(incomingUBX->cls);
-          _debugSerial->print(F(" ID: 0x"));
-          _debugSerial->println(incomingUBX->id);
-        }
-      }
-    //}
-    //else
-    //  maximum_payload_size = 2;
-  }
-  else
-    maximum_payload_size = 2;
-
-  bool overrun = false;
-
-  //Add all incoming bytes to the rolling checksum
-  //Stop at len+4 as this is the checksum bytes to that should not be added to the rolling checksum
-  if (incomingUBX->counter < incomingUBX->len + 4)
-    addToChecksum(incoming);
-
-  if (incomingUBX->counter == 0)
-  {
-    incomingUBX->cls = incoming;
-  }
-  else if (incomingUBX->counter == 1)
-  {
-    incomingUBX->id = incoming;
-  }
-  else if (incomingUBX->counter == 2) //Len LSB
-  {
-    incomingUBX->len = incoming;
-  }
-  else if (incomingUBX->counter == 3) //Len MSB
-  {
-    incomingUBX->len |= incoming << 8;
-  }
-  else if (incomingUBX->counter == incomingUBX->len + 4) //ChecksumA
-  {
-    incomingUBX->checksumA = incoming;
-  }
-  else if (incomingUBX->counter == incomingUBX->len + 5) //ChecksumB
-  {
-    incomingUBX->checksumB = incoming;
-
-    currentSentence = NONE; //We're done! Reset the sentence to being looking for a new start char
-
-    //Validate this sentence
-    if ((incomingUBX->checksumA == rollingChecksumA) && (incomingUBX->checksumB == rollingChecksumB))
-    {
-      incomingUBX->valid = SFE_UBLOX_PACKET_VALIDITY_VALID; // Flag the packet as valid
-
-      // Let's check if the class and ID match the requestedClass and requestedID
-      // Remember - this could be a data packet or an ACK packet
-      if ((incomingUBX->cls == requestedClass) && (incomingUBX->id == requestedID))
-      {
-        incomingUBX->classAndIDmatch = SFE_UBLOX_PACKET_VALIDITY_VALID; // If we have a match, set the classAndIDmatch flag to valid
-      }
-
-      // If this is an ACK then let's check if the class and ID match the requestedClass and requestedID
-      else if ((incomingUBX->cls == UBX_CLASS_ACK) && (incomingUBX->id == UBX_ACK_ACK) && (incomingUBX->payload[0] == requestedClass) && (incomingUBX->payload[1] == requestedID))
-      {
-        incomingUBX->classAndIDmatch = SFE_UBLOX_PACKET_VALIDITY_VALID; // If we have a match, set the classAndIDmatch flag to valid
-      }
-
-      // If this is a NACK then let's check if the class and ID match the requestedClass and requestedID
-      else if ((incomingUBX->cls == UBX_CLASS_ACK) && (incomingUBX->id == UBX_ACK_NACK) && (incomingUBX->payload[0] == requestedClass) && (incomingUBX->payload[1] == requestedID))
-      {
-        incomingUBX->classAndIDmatch = SFE_UBLOX_PACKET_NOTACKNOWLEDGED; // If we have a match, set the classAndIDmatch flag to NOTACKNOWLEDGED
-        if (_printDebug == true)
-        {
-          _debugSerial->print(F("processUBX: NACK received: Requested Class: 0x"));
-          _debugSerial->print(incomingUBX->payload[0], HEX);
-          _debugSerial->print(F(" Requested ID: 0x"));
-          _debugSerial->println(incomingUBX->payload[1], HEX);
-        }
-      }
-
-      //This is not an ACK and we do not have a complete class and ID match
-      //So let's check for an "automatic" message arriving
-      else if (checkAutomatic(incomingUBX->cls, incomingUBX->id))
-      {
-        // This isn't the message we are looking for...
-        // Let's say so and leave incomingUBX->classAndIDmatch _unchanged_
-        if (_printDebug == true)
-        {
-          _debugSerial->print(F("processUBX: incoming \"automatic\" message: Class: 0x"));
-          _debugSerial->print(incomingUBX->cls, HEX);
-          _debugSerial->print(F(" ID: 0x"));
-          _debugSerial->println(incomingUBX->id, HEX);
-        }
-      }
-
-      if (_printDebug == true)
-      {
-        _debugSerial->print(F("Incoming: Size: "));
-        _debugSerial->print(incomingUBX->len);
-        _debugSerial->print(F(" Received: "));
-        printPacket(incomingUBX);
-
-        if (incomingUBX->valid == SFE_UBLOX_PACKET_VALIDITY_VALID)
-        {
-          _debugSerial->println(F("packetCfg now valid"));
-        }
-        if (packetAck.valid == SFE_UBLOX_PACKET_VALIDITY_VALID)
-        {
-          _debugSerial->println(F("packetAck now valid"));
-        }
-        if (incomingUBX->classAndIDmatch == SFE_UBLOX_PACKET_VALIDITY_VALID)
-        {
-          _debugSerial->println(F("packetCfg classAndIDmatch"));
-        }
-        if (packetAck.classAndIDmatch == SFE_UBLOX_PACKET_VALIDITY_VALID)
-        {
-          _debugSerial->println(F("packetAck classAndIDmatch"));
-        }
-      }
-
-      //We've got a valid packet, now do something with it but only if ignoreThisPayload is false
-      if (ignoreThisPayload == false)
-      {
-        processUBXpacket(incomingUBX);
-      }
-    }
-    else // Checksum failure
-    {
-      incomingUBX->valid = SFE_UBLOX_PACKET_VALIDITY_NOT_VALID;
-
-      // Let's check if the class and ID match the requestedClass and requestedID.
-      // This is potentially risky as we are saying that we saw the requested Class and ID
-      // but that the packet checksum failed. Potentially it could be the class or ID bytes
-      // that caused the checksum error!
-      if ((incomingUBX->cls == requestedClass) && (incomingUBX->id == requestedID))
-      {
-        incomingUBX->classAndIDmatch = SFE_UBLOX_PACKET_VALIDITY_NOT_VALID; // If we have a match, set the classAndIDmatch flag to not valid
-      }
-      // If this is an ACK then let's check if the class and ID match the requestedClass and requestedID
-      else if ((incomingUBX->cls == UBX_CLASS_ACK) && (incomingUBX->payload[0] == requestedClass) && (incomingUBX->payload[1] == requestedID))
-      {
-        incomingUBX->classAndIDmatch = SFE_UBLOX_PACKET_VALIDITY_NOT_VALID; // If we have a match, set the classAndIDmatch flag to not valid
-      }
-
-      if ((_printDebug == true) || (_printLimitedDebug == true)) // This is important. Print this if doing limited debugging
-      {
-        //Drive an external pin to allow for easier logic analyzation
-        if (debugPin >= 0)
-        {
-          digitalWrite((uint8_t)debugPin, LOW);
-          delay(10);
-          digitalWrite((uint8_t)debugPin, HIGH);
-        }
-
-        _debugSerial->print(F("Checksum failed:"));
-        _debugSerial->print(F(" checksumA: "));
-        _debugSerial->print(incomingUBX->checksumA);
-        _debugSerial->print(F(" checksumB: "));
-        _debugSerial->print(incomingUBX->checksumB);
-
-        _debugSerial->print(F(" rollingChecksumA: "));
-        _debugSerial->print(rollingChecksumA);
-        _debugSerial->print(F(" rollingChecksumB: "));
-        _debugSerial->print(rollingChecksumB);
-        _debugSerial->println();
-      }
-    }
-
-    // Now that the packet is complete and has been processed, we need to delete the memory
-    // allocated for packetAuto
-    if (activePacketBuffer == SFE_UBLOX_PACKET_PACKETAUTO)
-    {
-      delete[] payloadAuto;
-      payloadAuto = NULL; // Redundant?
-      packetAuto.payload = payloadAuto;
-    }
-  }
-  else //Load this byte into the payload array
-  {
-    //If an automatic packet comes in asynchronously, we need to fudge the startingSpot
-    uint16_t startingSpot = incomingUBX->startingSpot;
-    if (checkAutomatic(incomingUBX->cls, incomingUBX->id))
-      startingSpot = 0;
-    // Check if this is payload data which should be ignored
-    if (ignoreThisPayload == false)
-    {
-      //Begin recording if counter goes past startingSpot
-      if ((incomingUBX->counter - 4) >= startingSpot)
-      {
-        //Check to see if we have room for this byte
-        if (((incomingUBX->counter - 4) - startingSpot) < maximum_payload_size) //If counter = 208, starting spot = 200, we're good to record.
-        {
-          incomingUBX->payload[(incomingUBX->counter - 4) - startingSpot] = incoming; //Store this byte into payload array
-        }
-        else
-        {
-          overrun = true;
-        }
-      }
-    }
-  }
-
-  // incomingUBX->counter should never reach maximum_payload_size + class + id + len[2] + checksum[2]
-  if (overrun || ((incomingUBX->counter == maximum_payload_size + 6) && (ignoreThisPayload == false)))
-  {
-    //Something has gone very wrong
-    currentSentence = NONE; //Reset the sentence to being looking for a new start char
-    if ((_printDebug == true) || (_printLimitedDebug == true)) // This is important. Print this if doing limited debugging
-    {
-      if (overrun)
-        _debugSerial->print(F("processUBX: buffer overrun detected!"));
-      else
-        _debugSerial->print(F("processUBX: counter hit maximum_payload_size + 6!"));
-      _debugSerial->print(F(" activePacketBuffer: "));
-      _debugSerial->print(activePacketBuffer);
-      _debugSerial->print(F(" maximum_payload_size: "));
-      _debugSerial->println(maximum_payload_size);
-    }
-  }
-
-  //Increment the counter
-  incomingUBX->counter++;
-}
-
-//Once a packet has been received and validated, identify this packet's class/id and update internal flags
-void SFE_UBLOX_GNSS::processUBXpacket(ubxPacket *msg)
-{
-  switch (msg->cls)
-  {
-  case UBX_CLASS_NAV:
-    if (msg->id == UBX_NAV_POSECEF && msg->len == UBX_NAV_POSECEF_LEN)
-    {
-      //Parse various byte fields into storage - but only if we have memory allocated for it
-      if (packetUBXNAVPOSECEF != NULL)
-      {
-        packetUBXNAVPOSECEF->data.iTOW = extractLong(msg, 0);
-        packetUBXNAVPOSECEF->data.ecefX = extractSignedLong(msg, 4);
-        packetUBXNAVPOSECEF->data.ecefY = extractSignedLong(msg, 8);
-        packetUBXNAVPOSECEF->data.ecefZ = extractSignedLong(msg, 12);
-        packetUBXNAVPOSECEF->data.pAcc = extractLong(msg, 16);
-
-        //Mark all datums as fresh (not read before)
-        packetUBXNAVPOSECEF->moduleQueried.moduleQueried.all = 0xFFFFFFFF;
-
-        //Check if we need to copy the data for the callback
-        if ((packetUBXNAVPOSECEF->callbackData != NULL) // If RAM has been allocated for the copy of the data
-          && (packetUBXNAVPOSECEF->automaticFlags.flags.bits.callbackCopyValid == false)) // AND the data is stale
-        {
-          memcpy(&packetUBXNAVPOSECEF->callbackData->iTOW, &packetUBXNAVPOSECEF->data.iTOW, sizeof(UBX_NAV_POSECEF_data_t));
-          packetUBXNAVPOSECEF->automaticFlags.flags.bits.callbackCopyValid = true;
-        }
-
-        //Check if we need to copy the data into the file buffer
-        if (packetUBXNAVPOSECEF->automaticFlags.flags.bits.addToFileBuffer)
-        {
-          storePacket(msg);
-        }
-      }
-    }
-    else if (msg->id == UBX_NAV_STATUS && msg->len == UBX_NAV_STATUS_LEN)
-    {
-      //Parse various byte fields into storage - but only if we have memory allocated for it
-      if (packetUBXNAVSTATUS != NULL)
-      {
-        packetUBXNAVSTATUS->data.iTOW = extractLong(msg, 0);
-        packetUBXNAVSTATUS->data.gpsFix = extractByte(msg, 4);
-        packetUBXNAVSTATUS->data.flags.all = extractByte(msg, 5);
-        packetUBXNAVSTATUS->data.fixStat.all = extractByte(msg, 6);
-        packetUBXNAVSTATUS->data.flags2.all = extractByte(msg, 7);
-        packetUBXNAVSTATUS->data.ttff = extractLong(msg, 8);
-        packetUBXNAVSTATUS->data.msss = extractLong(msg, 12);
-
-        //Mark all datums as fresh (not read before)
-        packetUBXNAVSTATUS->moduleQueried.moduleQueried.all = 0xFFFFFFFF;
-
-        //Check if we need to copy the data for the callback
-        if ((packetUBXNAVSTATUS->callbackData != NULL) // If RAM has been allocated for the copy of the data
-          && (packetUBXNAVSTATUS->automaticFlags.flags.bits.callbackCopyValid == false)) // AND the data is stale
-        {
-          memcpy(&packetUBXNAVSTATUS->callbackData->iTOW, &packetUBXNAVSTATUS->data.iTOW, sizeof(UBX_NAV_STATUS_data_t));
-          packetUBXNAVSTATUS->automaticFlags.flags.bits.callbackCopyValid = true;
-        }
-
-        //Check if we need to copy the data into the file buffer
-        if (packetUBXNAVSTATUS->automaticFlags.flags.bits.addToFileBuffer)
-        {
-          storePacket(msg);
-        }
-      }
-    }
-    else if (msg->id == UBX_NAV_DOP && msg->len == UBX_NAV_DOP_LEN)
-    {
-      //Parse various byte fields into storage - but only if we have memory allocated for it
-      if (packetUBXNAVDOP != NULL)
-      {
-        packetUBXNAVDOP->data.iTOW = extractLong(msg, 0);
-        packetUBXNAVDOP->data.gDOP = extractInt(msg, 4);
-        packetUBXNAVDOP->data.pDOP = extractInt(msg, 6);
-        packetUBXNAVDOP->data.tDOP = extractInt(msg, 8);
-        packetUBXNAVDOP->data.vDOP = extractInt(msg, 10);
-        packetUBXNAVDOP->data.hDOP = extractInt(msg, 12);
-        packetUBXNAVDOP->data.nDOP = extractInt(msg, 14);
-        packetUBXNAVDOP->data.eDOP = extractInt(msg, 16);
-
-        //Mark all datums as fresh (not read before)
-        packetUBXNAVDOP->moduleQueried.moduleQueried.all = 0xFFFFFFFF;
-
-        //Check if we need to copy the data for the callback
-        if ((packetUBXNAVDOP->callbackData != NULL) // If RAM has been allocated for the copy of the data
-          && (packetUBXNAVDOP->automaticFlags.flags.bits.callbackCopyValid == false)) // AND the data is stale
-        {
-          memcpy(&packetUBXNAVDOP->callbackData->iTOW, &packetUBXNAVDOP->data.iTOW, sizeof(UBX_NAV_DOP_data_t));
-          packetUBXNAVDOP->automaticFlags.flags.bits.callbackCopyValid = true;
-        }
-
-        //Check if we need to copy the data into the file buffer
-        if (packetUBXNAVDOP->automaticFlags.flags.bits.addToFileBuffer)
-        {
-          storePacket(msg);
-        }
-      }
-    }
-    else if (msg->id == UBX_NAV_ATT && msg->len == UBX_NAV_ATT_LEN)
-    {
-      //Parse various byte fields into storage - but only if we have memory allocated for it
-      if (packetUBXNAVATT != NULL)
-      {
-        packetUBXNAVATT->data.iTOW = extractLong(msg, 0);
-        packetUBXNAVATT->data.version = extractByte(msg, 4);
-        packetUBXNAVATT->data.roll = extractSignedLong(msg, 8);
-        packetUBXNAVATT->data.pitch = extractSignedLong(msg, 12);
-        packetUBXNAVATT->data.heading = extractSignedLong(msg, 16);
-        packetUBXNAVATT->data.accRoll = extractLong(msg, 20);
-        packetUBXNAVATT->data.accPitch = extractLong(msg, 24);
-        packetUBXNAVATT->data.accHeading = extractLong(msg, 28);
-
-        //Mark all datums as fresh (not read before)
-        packetUBXNAVATT->moduleQueried.moduleQueried.all = 0xFFFFFFFF;
-
-        //Check if we need to copy the data for the callback
-        if ((packetUBXNAVATT->callbackData != NULL) // If RAM has been allocated for the copy of the data
-          && (packetUBXNAVATT->automaticFlags.flags.bits.callbackCopyValid == false)) // AND the data is stale
-        {
-          memcpy(&packetUBXNAVATT->callbackData->iTOW, &packetUBXNAVATT->data.iTOW, sizeof(UBX_NAV_ATT_data_t));
-          packetUBXNAVATT->automaticFlags.flags.bits.callbackCopyValid = true;
-        }
-
-        //Check if we need to copy the data into the file buffer
-        if (packetUBXNAVATT->automaticFlags.flags.bits.addToFileBuffer)
-        {
-          storePacket(msg);
-        }
-      }
-    }
-    else if (msg->id == UBX_NAV_PVT && msg->len == UBX_NAV_PVT_LEN)
-    {
-      //Parse various byte fields into storage - but only if we have memory allocated for it
-      if (packetUBXNAVPVT != NULL)
-      {
-        packetUBXNAVPVT->data.iTOW = extractLong(msg, 0);
-        packetUBXNAVPVT->data.year = extractInt(msg, 4);
-        packetUBXNAVPVT->data.month = extractByte(msg, 6);
-        packetUBXNAVPVT->data.day = extractByte(msg, 7);
-        packetUBXNAVPVT->data.hour = extractByte(msg, 8);
-        packetUBXNAVPVT->data.min = extractByte(msg, 9);
-        packetUBXNAVPVT->data.sec = extractByte(msg, 10);
-        packetUBXNAVPVT->data.valid.all = extractByte(msg, 11);
-        packetUBXNAVPVT->data.tAcc = extractLong(msg, 12);
-        packetUBXNAVPVT->data.nano = extractSignedLong(msg, 16); //Includes milliseconds
-        packetUBXNAVPVT->data.fixType = extractByte(msg, 20);
-        packetUBXNAVPVT->data.flags.all = extractByte(msg, 21);
-        packetUBXNAVPVT->data.flags2.all = extractByte(msg, 22);
-        packetUBXNAVPVT->data.numSV = extractByte(msg, 23);
-        packetUBXNAVPVT->data.lon = extractSignedLong(msg, 24);
-        packetUBXNAVPVT->data.lat = extractSignedLong(msg, 28);
-        packetUBXNAVPVT->data.height = extractSignedLong(msg, 32);
-        packetUBXNAVPVT->data.hMSL = extractSignedLong(msg, 36);
-        packetUBXNAVPVT->data.hAcc = extractLong(msg, 40);
-        packetUBXNAVPVT->data.vAcc = extractLong(msg, 44);
-        packetUBXNAVPVT->data.velN = extractSignedLong(msg, 48);
-        packetUBXNAVPVT->data.velE = extractSignedLong(msg, 52);
-        packetUBXNAVPVT->data.velD = extractSignedLong(msg, 56);
-        packetUBXNAVPVT->data.gSpeed = extractSignedLong(msg, 60);
-        packetUBXNAVPVT->data.headMot = extractSignedLong(msg, 64);
-        packetUBXNAVPVT->data.sAcc = extractLong(msg, 68);
-        packetUBXNAVPVT->data.headAcc = extractLong(msg, 72);
-        packetUBXNAVPVT->data.pDOP = extractInt(msg, 76);
-        packetUBXNAVPVT->data.flags3.all = extractByte(msg, 78);
-        packetUBXNAVPVT->data.headVeh = extractSignedLong(msg, 84);
-        packetUBXNAVPVT->data.magDec = extractSignedInt(msg, 88);
-        packetUBXNAVPVT->data.magAcc = extractInt(msg, 90);
-
-        //Mark all datums as fresh (not read before)
-        packetUBXNAVPVT->moduleQueried.moduleQueried1.all = 0xFFFFFFFF;
-        packetUBXNAVPVT->moduleQueried.moduleQueried2.all = 0xFFFFFFFF;
-
-        //Check if we need to copy the data for the callback
-        if ((packetUBXNAVPVT->callbackData != NULL) // If RAM has been allocated for the copy of the data
-          && (packetUBXNAVPVT->automaticFlags.flags.bits.callbackCopyValid == false)) // AND the data is stale
-        {
-          memcpy(&packetUBXNAVPVT->callbackData->iTOW, &packetUBXNAVPVT->data.iTOW, sizeof(UBX_NAV_PVT_data_t));
-          packetUBXNAVPVT->automaticFlags.flags.bits.callbackCopyValid = true;
-        }
-
-        //Check if we need to copy the data into the file buffer
-        if (packetUBXNAVPVT->automaticFlags.flags.bits.addToFileBuffer)
-        {
-          storePacket(msg);
-        }
-      }
-    }
-    else if (msg->id == UBX_NAV_ODO && msg->len == UBX_NAV_ODO_LEN)
-    {
-      //Parse various byte fields into storage - but only if we have memory allocated for it
-      if (packetUBXNAVODO != NULL)
-      {
-        packetUBXNAVODO->data.version = extractByte(msg, 0);
-        packetUBXNAVODO->data.iTOW = extractLong(msg, 4);
-        packetUBXNAVODO->data.distance = extractLong(msg, 8);
-        packetUBXNAVODO->data.totalDistance = extractLong(msg, 12);
-        packetUBXNAVODO->data.distanceStd = extractLong(msg, 16);
-
-        //Mark all datums as fresh (not read before)
-        packetUBXNAVODO->moduleQueried.moduleQueried.all = 0xFFFFFFFF;
-
-        //Check if we need to copy the data for the callback
-        if ((packetUBXNAVODO->callbackData != NULL) // If RAM has been allocated for the copy of the data
-          && (packetUBXNAVODO->automaticFlags.flags.bits.callbackCopyValid == false)) // AND the data is stale
-        {
-          memcpy(&packetUBXNAVODO->callbackData->version, &packetUBXNAVODO->data.version, sizeof(UBX_NAV_ODO_data_t));
-          packetUBXNAVODO->automaticFlags.flags.bits.callbackCopyValid = true;
-        }
-
-        //Check if we need to copy the data into the file buffer
-        if (packetUBXNAVODO->automaticFlags.flags.bits.addToFileBuffer)
-        {
-          storePacket(msg);
-        }
-      }
-    }
-    else if (msg->id == UBX_NAV_VELECEF && msg->len == UBX_NAV_VELECEF_LEN)
-    {
-      //Parse various byte fields into storage - but only if we have memory allocated for it
-      if (packetUBXNAVVELECEF != NULL)
-      {
-        packetUBXNAVVELECEF->data.iTOW = extractLong(msg, 0);
-        packetUBXNAVVELECEF->data.ecefVX = extractSignedLong(msg, 4);
-        packetUBXNAVVELECEF->data.ecefVY = extractSignedLong(msg, 8);
-        packetUBXNAVVELECEF->data.ecefVZ = extractSignedLong(msg, 12);
-        packetUBXNAVVELECEF->data.sAcc = extractLong(msg, 16);
-
-        //Mark all datums as fresh (not read before)
-        packetUBXNAVVELECEF->moduleQueried.moduleQueried.all = 0xFFFFFFFF;
-
-        //Check if we need to copy the data for the callback
-        if ((packetUBXNAVVELECEF->callbackData != NULL) // If RAM has been allocated for the copy of the data
-          && (packetUBXNAVVELECEF->automaticFlags.flags.bits.callbackCopyValid == false)) // AND the data is stale
-        {
-          memcpy(&packetUBXNAVVELECEF->callbackData->iTOW, &packetUBXNAVVELECEF->data.iTOW, sizeof(UBX_NAV_VELECEF_data_t));
-          packetUBXNAVVELECEF->automaticFlags.flags.bits.callbackCopyValid = true;
-        }
-
-        //Check if we need to copy the data into the file buffer
-        if (packetUBXNAVVELECEF->automaticFlags.flags.bits.addToFileBuffer)
-        {
-          storePacket(msg);
-        }
-      }
-    }
-    else if (msg->id == UBX_NAV_VELNED && msg->len == UBX_NAV_VELNED_LEN)
-    {
-      //Parse various byte fields into storage - but only if we have memory allocated for it
-      if (packetUBXNAVVELNED != NULL)
-      {
-        packetUBXNAVVELNED->data.iTOW = extractLong(msg, 0);
-        packetUBXNAVVELNED->data.velN = extractSignedLong(msg, 4);
-        packetUBXNAVVELNED->data.velE = extractSignedLong(msg, 8);
-        packetUBXNAVVELNED->data.velD = extractSignedLong(msg, 12);
-        packetUBXNAVVELNED->data.speed = extractLong(msg, 16);
-        packetUBXNAVVELNED->data.gSpeed = extractLong(msg, 20);
-        packetUBXNAVVELNED->data.heading = extractSignedLong(msg, 24);
-        packetUBXNAVVELNED->data.sAcc = extractLong(msg, 28);
-        packetUBXNAVVELNED->data.cAcc = extractLong(msg, 32);
-
-        //Mark all datums as fresh (not read before)
-        packetUBXNAVVELNED->moduleQueried.moduleQueried.all = 0xFFFFFFFF;
-
-        //Check if we need to copy the data for the callback
-        if ((packetUBXNAVVELNED->callbackData != NULL) // If RAM has been allocated for the copy of the data
-          && (packetUBXNAVVELNED->automaticFlags.flags.bits.callbackCopyValid == false)) // AND the data is stale
-        {
-          memcpy(&packetUBXNAVVELNED->callbackData->iTOW, &packetUBXNAVVELNED->data.iTOW, sizeof(UBX_NAV_VELNED_data_t));
-          packetUBXNAVVELNED->automaticFlags.flags.bits.callbackCopyValid = true;
-        }
-
-        //Check if we need to copy the data into the file buffer
-        if (packetUBXNAVVELNED->automaticFlags.flags.bits.addToFileBuffer)
-        {
-          storePacket(msg);
-        }
-      }
-    }
-    else if (msg->id == UBX_NAV_HPPOSECEF && msg->len == UBX_NAV_HPPOSECEF_LEN)
-    {
-      //Parse various byte fields into storage - but only if we have memory allocated for it
-      if (packetUBXNAVHPPOSECEF != NULL)
-      {
-        packetUBXNAVHPPOSECEF->data.version = extractByte(msg, 0);
-        packetUBXNAVHPPOSECEF->data.iTOW = extractLong(msg, 4);
-        packetUBXNAVHPPOSECEF->data.ecefX = extractSignedLong(msg, 8);
-        packetUBXNAVHPPOSECEF->data.ecefY = extractSignedLong(msg, 12);
-        packetUBXNAVHPPOSECEF->data.ecefZ = extractSignedLong(msg, 16);
-        packetUBXNAVHPPOSECEF->data.ecefXHp = extractSignedChar(msg, 20);
-        packetUBXNAVHPPOSECEF->data.ecefYHp = extractSignedChar(msg, 21);
-        packetUBXNAVHPPOSECEF->data.ecefZHp = extractSignedChar(msg, 22);
-        packetUBXNAVHPPOSECEF->data.flags.all = extractByte(msg, 23);
-        packetUBXNAVHPPOSECEF->data.pAcc = extractLong(msg, 24);
-
-        //Mark all datums as fresh (not read before)
-        packetUBXNAVHPPOSECEF->moduleQueried.moduleQueried.all = 0xFFFFFFFF;
-
-        //Check if we need to copy the data for the callback
-        if ((packetUBXNAVHPPOSECEF->callbackData != NULL) // If RAM has been allocated for the copy of the data
-          && (packetUBXNAVHPPOSECEF->automaticFlags.flags.bits.callbackCopyValid == false)) // AND the data is stale
-        {
-          memcpy(&packetUBXNAVHPPOSECEF->callbackData->version, &packetUBXNAVHPPOSECEF->data.version, sizeof(UBX_NAV_HPPOSECEF_data_t));
-          packetUBXNAVHPPOSECEF->automaticFlags.flags.bits.callbackCopyValid = true;
-        }
-
-        //Check if we need to copy the data into the file buffer
-        if (packetUBXNAVHPPOSECEF->automaticFlags.flags.bits.addToFileBuffer)
-        {
-          storePacket(msg);
-        }
-      }
-    }
-    else if (msg->id == UBX_NAV_HPPOSLLH && msg->len == UBX_NAV_HPPOSLLH_LEN)
-    {
-      //Parse various byte fields into storage - but only if we have memory allocated for it
-      if (packetUBXNAVHPPOSLLH != NULL)
-      {
-        packetUBXNAVHPPOSLLH->data.version = extractByte(msg, 0);
-        packetUBXNAVHPPOSLLH->data.flags.all = extractByte(msg, 3);
-        packetUBXNAVHPPOSLLH->data.iTOW = extractLong(msg, 4);
-        packetUBXNAVHPPOSLLH->data.lon = extractSignedLong(msg, 8);
-        packetUBXNAVHPPOSLLH->data.lat = extractSignedLong(msg, 12);
-        packetUBXNAVHPPOSLLH->data.height = extractSignedLong(msg, 16);
-        packetUBXNAVHPPOSLLH->data.hMSL = extractSignedLong(msg, 20);
-        packetUBXNAVHPPOSLLH->data.lonHp = extractSignedChar(msg, 24);
-        packetUBXNAVHPPOSLLH->data.latHp = extractSignedChar(msg, 25);
-        packetUBXNAVHPPOSLLH->data.heightHp = extractSignedChar(msg, 26);
-        packetUBXNAVHPPOSLLH->data.hMSLHp = extractSignedChar(msg, 27);
-        packetUBXNAVHPPOSLLH->data.hAcc = extractLong(msg, 28);
-        packetUBXNAVHPPOSLLH->data.vAcc = extractLong(msg, 32);
-
-        //Mark all datums as fresh (not read before)
-        packetUBXNAVHPPOSLLH->moduleQueried.moduleQueried.all = 0xFFFFFFFF;
-
-        //Check if we need to copy the data for the callback
-        if ((packetUBXNAVHPPOSLLH->callbackData != NULL) // If RAM has been allocated for the copy of the data
-          && (packetUBXNAVHPPOSLLH->automaticFlags.flags.bits.callbackCopyValid == false)) // AND the data is stale
-        {
-          memcpy(&packetUBXNAVHPPOSLLH->callbackData->version, &packetUBXNAVHPPOSLLH->data.version, sizeof(UBX_NAV_HPPOSLLH_data_t));
-          packetUBXNAVHPPOSLLH->automaticFlags.flags.bits.callbackCopyValid = true;
-        }
-
-        //Check if we need to copy the data into the file buffer
-        if (packetUBXNAVHPPOSLLH->automaticFlags.flags.bits.addToFileBuffer)
-        {
-          storePacket(msg);
-        }
-      }
-    }
-    else if (msg->id == UBX_NAV_CLOCK && msg->len == UBX_NAV_CLOCK_LEN)
-    {
-      //Parse various byte fields into storage - but only if we have memory allocated for it
-      if (packetUBXNAVCLOCK != NULL)
-      {
-        packetUBXNAVCLOCK->data.iTOW = extractLong(msg, 0);
-        packetUBXNAVCLOCK->data.clkB = extractSignedLong(msg, 4);
-        packetUBXNAVCLOCK->data.clkD = extractSignedLong(msg, 8);
-        packetUBXNAVCLOCK->data.tAcc = extractLong(msg, 12);
-        packetUBXNAVCLOCK->data.fAcc = extractLong(msg, 16);
-
-        //Mark all datums as fresh (not read before)
-        packetUBXNAVCLOCK->moduleQueried.moduleQueried.all = 0xFFFFFFFF;
-
-        //Check if we need to copy the data for the callback
-        if ((packetUBXNAVCLOCK->callbackData != NULL) // If RAM has been allocated for the copy of the data
-          && (packetUBXNAVCLOCK->automaticFlags.flags.bits.callbackCopyValid == false)) // AND the data is stale
-        {
-          memcpy(&packetUBXNAVCLOCK->callbackData->iTOW, &packetUBXNAVCLOCK->data.iTOW, sizeof(UBX_NAV_CLOCK_data_t));
-          packetUBXNAVCLOCK->automaticFlags.flags.bits.callbackCopyValid = true;
-        }
-
-        //Check if we need to copy the data into the file buffer
-        if (packetUBXNAVCLOCK->automaticFlags.flags.bits.addToFileBuffer)
-        {
-          storePacket(msg);
-        }
-      }
-    }
-    else if (msg->id == UBX_NAV_SVIN && msg->len == UBX_NAV_SVIN_LEN)
-    {
-      //Parse various byte fields into storage - but only if we have memory allocated for it
-      if (packetUBXNAVSVIN != NULL)
-      {
-        packetUBXNAVSVIN->data.version = extractByte(msg, 0);
-        packetUBXNAVSVIN->data.iTOW = extractLong(msg, 4);
-        packetUBXNAVSVIN->data.dur = extractLong(msg, 8);
-        packetUBXNAVSVIN->data.meanX = extractSignedLong(msg, 12);
-        packetUBXNAVSVIN->data.meanY = extractSignedLong(msg, 16);
-        packetUBXNAVSVIN->data.meanZ = extractSignedLong(msg, 20);
-        packetUBXNAVSVIN->data.meanXHP = extractSignedChar(msg, 24);
-        packetUBXNAVSVIN->data.meanYHP = extractSignedChar(msg, 25);
-        packetUBXNAVSVIN->data.meanZHP = extractSignedChar(msg, 26);
-        packetUBXNAVSVIN->data.meanAcc = extractLong(msg, 28);
-        packetUBXNAVSVIN->data.obs = extractLong(msg, 32);
-        packetUBXNAVSVIN->data.valid = extractSignedChar(msg, 36);
-        packetUBXNAVSVIN->data.active = extractSignedChar(msg, 37);
-
-        //Mark all datums as fresh (not read before)
-        packetUBXNAVSVIN->moduleQueried.moduleQueried.all = 0xFFFFFFFF;
-      }
-    }
-    else if (msg->id == UBX_NAV_RELPOSNED && ((msg->len == UBX_NAV_RELPOSNED_LEN) || (msg->len == UBX_NAV_RELPOSNED_LEN_F9)))
-    {
-      //Parse various byte fields into storage - but only if we have memory allocated for it
-      if (packetUBXNAVRELPOSNED != NULL)
-      {
-        //Note:
-        //  RELPOSNED on the M8 is only 40 bytes long
-        //  RELPOSNED on the F9 is 64 bytes long and contains much more information
-
-        packetUBXNAVRELPOSNED->data.version = extractByte(msg, 0);
-        packetUBXNAVRELPOSNED->data.refStationId = extractInt(msg, 2);
-        packetUBXNAVRELPOSNED->data.iTOW = extractLong(msg, 4);
-        packetUBXNAVRELPOSNED->data.relPosN = extractSignedLong(msg, 8);
-        packetUBXNAVRELPOSNED->data.relPosE = extractSignedLong(msg, 12);
-        packetUBXNAVRELPOSNED->data.relPosD = extractSignedLong(msg, 16);
-
-        if (msg->len == UBX_NAV_RELPOSNED_LEN)
-        {
-          // The M8 version does not contain relPosLength or relPosHeading
-          packetUBXNAVRELPOSNED->data.relPosLength = 0;
-          packetUBXNAVRELPOSNED->data.relPosHeading = 0;
-          packetUBXNAVRELPOSNED->data.relPosHPN = extractSignedChar(msg, 20);
-          packetUBXNAVRELPOSNED->data.relPosHPE = extractSignedChar(msg, 21);
-          packetUBXNAVRELPOSNED->data.relPosHPD = extractSignedChar(msg, 22);
-          packetUBXNAVRELPOSNED->data.relPosHPLength = 0; // The M8 version does not contain relPosHPLength
-          packetUBXNAVRELPOSNED->data.accN = extractLong(msg, 24);
-          packetUBXNAVRELPOSNED->data.accE = extractLong(msg, 28);
-          packetUBXNAVRELPOSNED->data.accD = extractLong(msg, 32);
-          // The M8 version does not contain accLength or accHeading
-          packetUBXNAVRELPOSNED->data.accLength = 0;
-          packetUBXNAVRELPOSNED->data.accHeading = 0;
-          packetUBXNAVRELPOSNED->data.flags.all = extractLong(msg, 36);
-        }
-        else
-        {
-          packetUBXNAVRELPOSNED->data.relPosLength = extractSignedLong(msg, 20);
-          packetUBXNAVRELPOSNED->data.relPosHeading = extractSignedLong(msg, 24);
-          packetUBXNAVRELPOSNED->data.relPosHPN = extractSignedChar(msg, 32);
-          packetUBXNAVRELPOSNED->data.relPosHPE = extractSignedChar(msg, 33);
-          packetUBXNAVRELPOSNED->data.relPosHPD = extractSignedChar(msg, 34);
-          packetUBXNAVRELPOSNED->data.relPosHPLength = extractSignedChar(msg, 35);
-          packetUBXNAVRELPOSNED->data.accN = extractLong(msg, 36);
-          packetUBXNAVRELPOSNED->data.accE = extractLong(msg, 40);
-          packetUBXNAVRELPOSNED->data.accD = extractLong(msg, 44);
-          packetUBXNAVRELPOSNED->data.accLength = extractLong(msg, 48);
-          packetUBXNAVRELPOSNED->data.accHeading = extractLong(msg, 52);
-          packetUBXNAVRELPOSNED->data.flags.all = extractLong(msg, 60);
-        }
-
-        //Mark all datums as fresh (not read before)
-        packetUBXNAVRELPOSNED->moduleQueried.moduleQueried.all = 0xFFFFFFFF;
-
-        //Check if we need to copy the data for the callback
-        if ((packetUBXNAVRELPOSNED->callbackData != NULL) // If RAM has been allocated for the copy of the data
-          && (packetUBXNAVRELPOSNED->automaticFlags.flags.bits.callbackCopyValid == false)) // AND the data is stale
-        {
-          memcpy(&packetUBXNAVRELPOSNED->callbackData->version, &packetUBXNAVRELPOSNED->data.version, sizeof(UBX_NAV_RELPOSNED_data_t));
-          packetUBXNAVRELPOSNED->automaticFlags.flags.bits.callbackCopyValid = true;
-        }
-
-        //Check if we need to copy the data into the file buffer
-        if (packetUBXNAVRELPOSNED->automaticFlags.flags.bits.addToFileBuffer)
-        {
-          storePacket(msg);
-        }
-      }
-    }
-    break;
-  case UBX_CLASS_RXM:
-    if (msg->id == UBX_RXM_SFRBX)
-    // Note: length is variable
-    // Note: on protocol version 17: numWords is (0..16)
-    //       on protocol version 18+: numWords is (0..10)
-    {
-      //Parse various byte fields into storage - but only if we have memory allocated for it
-      if (packetUBXRXMSFRBX != NULL)
-      {
-        packetUBXRXMSFRBX->data.gnssId = extractByte(msg, 0);
-        packetUBXRXMSFRBX->data.svId = extractByte(msg, 1);
-        packetUBXRXMSFRBX->data.freqId = extractByte(msg, 3);
-        packetUBXRXMSFRBX->data.numWords = extractByte(msg, 4);
-        packetUBXRXMSFRBX->data.chn = extractByte(msg, 5);
-        packetUBXRXMSFRBX->data.version = extractByte(msg, 6);
-
-        for (uint8_t i = 0; (i < UBX_RXM_SFRBX_MAX_WORDS) && (i < packetUBXRXMSFRBX->data.numWords)
-          && ((i * 4) < (msg->len - 8)); i++)
-        {
-          packetUBXRXMSFRBX->data.dwrd[i] = extractLong(msg, 8 + (i * 4));
-        }
-
-        //Mark all datums as fresh (not read before)
-        packetUBXRXMSFRBX->moduleQueried = true;
-
-        //Check if we need to copy the data for the callback
-        if ((packetUBXRXMSFRBX->callbackData != NULL) // If RAM has been allocated for the copy of the data
-          && (packetUBXRXMSFRBX->automaticFlags.flags.bits.callbackCopyValid == false)) // AND the data is stale
-        {
-          memcpy(&packetUBXRXMSFRBX->callbackData->gnssId, &packetUBXRXMSFRBX->data.gnssId, sizeof(UBX_RXM_SFRBX_data_t));
-          packetUBXRXMSFRBX->automaticFlags.flags.bits.callbackCopyValid = true;
-        }
-
-        //Check if we need to copy the data into the file buffer
-        if (packetUBXRXMSFRBX->automaticFlags.flags.bits.addToFileBuffer)
-        {
-          storePacket(msg);
-        }
-      }
-    }
-    else if (msg->id == UBX_RXM_RAWX)
-    // Note: length is variable
-    {
-      //Parse various byte fields into storage - but only if we have memory allocated for it
-      if (packetUBXRXMRAWX != NULL)
-      {
-        for (uint8_t i = 0; i < 8; i++)
-        {
-          packetUBXRXMRAWX->data.header.rcvTow[i] = extractByte(msg, i);
-        }
-        packetUBXRXMRAWX->data.header.week = extractInt(msg, 8);
-        packetUBXRXMRAWX->data.header.leapS = extractSignedChar(msg, 10);
-        packetUBXRXMRAWX->data.header.numMeas = extractByte(msg, 11);
-        packetUBXRXMRAWX->data.header.recStat.all = extractByte(msg, 12);
-        packetUBXRXMRAWX->data.header.version = extractByte(msg, 13);
-
-        for (uint8_t i = 0; (i < UBX_RXM_RAWX_MAX_BLOCKS) && (i < packetUBXRXMRAWX->data.header.numMeas)
-          && ((((uint16_t)i) * 32) < (msg->len - 16)); i++)
-        {
-          uint16_t offset = (((uint16_t)i) * 32) + 16;
-          for (uint8_t j = 0; j < 8; j++)
-          {
-            packetUBXRXMRAWX->data.blocks[i].prMes[j] = extractByte(msg, offset + j);
-            packetUBXRXMRAWX->data.blocks[i].cpMes[j] = extractByte(msg, offset + 8 + j);
-            if (j < 4)
-              packetUBXRXMRAWX->data.blocks[i].doMes[j] = extractByte(msg, offset + 16 + j);
-          }
-          packetUBXRXMRAWX->data.blocks[i].gnssId = extractByte(msg, offset + 20);
-          packetUBXRXMRAWX->data.blocks[i].svId = extractByte(msg, offset + 21);
-          packetUBXRXMRAWX->data.blocks[i].sigId = extractByte(msg, offset + 22);
-          packetUBXRXMRAWX->data.blocks[i].freqId = extractByte(msg, offset + 23);
-          packetUBXRXMRAWX->data.blocks[i].lockTime = extractInt(msg, offset + 24);
-          packetUBXRXMRAWX->data.blocks[i].cno = extractByte(msg, offset + 26);
-          packetUBXRXMRAWX->data.blocks[i].prStdev = extractByte(msg, offset + 27);
-          packetUBXRXMRAWX->data.blocks[i].cpStdev = extractByte(msg, offset + 28);
-          packetUBXRXMRAWX->data.blocks[i].doStdev = extractByte(msg, offset + 29);
-          packetUBXRXMRAWX->data.blocks[i].trkStat.all = extractByte(msg, offset + 30);
-        }
-
-        //Mark all datums as fresh (not read before)
-        packetUBXRXMRAWX->moduleQueried = true;
-
-        //Check if we need to copy the data for the callback
-        if ((packetUBXRXMRAWX->callbackData != NULL) // If RAM has been allocated for the copy of the data
-          && (packetUBXRXMRAWX->automaticFlags.flags.bits.callbackCopyValid == false)) // AND the data is stale
-        {
-          memcpy(&packetUBXRXMRAWX->callbackData->header.rcvTow[0], &packetUBXRXMRAWX->data.header.rcvTow[0], sizeof(UBX_RXM_RAWX_data_t));
-          packetUBXRXMRAWX->automaticFlags.flags.bits.callbackCopyValid = true;
-        }
-
-        //Check if we need to copy the data into the file buffer
-        if (packetUBXRXMRAWX->automaticFlags.flags.bits.addToFileBuffer)
-        {
-          storePacket(msg);
-        }
-      }
-    }
-    break;
-  case UBX_CLASS_CFG:
-    if (msg->id == UBX_CFG_RATE && msg->len == UBX_CFG_RATE_LEN)
-    {
-      //Parse various byte fields into storage - but only if we have memory allocated for it
-      if (packetUBXCFGRATE != NULL)
-      {
-        packetUBXCFGRATE->data.measRate = extractInt(msg, 0);
-        packetUBXCFGRATE->data.navRate = extractInt(msg, 2);
-        packetUBXCFGRATE->data.timeRef = extractInt(msg, 4);
-
-        //Mark all datums as fresh (not read before)
-        packetUBXCFGRATE->moduleQueried.moduleQueried.all = 0xFFFFFFFF;
-      }
-    }
-    break;
-  case UBX_CLASS_TIM:
-    if (msg->id == UBX_TIM_TM2 && msg->len == UBX_TIM_TM2_LEN)
-    {
-      //Parse various byte fields into storage - but only if we have memory allocated for it
-      if (packetUBXTIMTM2 != NULL)
-      {
-        packetUBXTIMTM2->data.ch = extractByte(msg, 0);
-        packetUBXTIMTM2->data.flags.all = extractByte(msg, 1);
-        packetUBXTIMTM2->data.count = extractInt(msg, 2);
-        packetUBXTIMTM2->data.wnR = extractInt(msg, 4);
-        packetUBXTIMTM2->data.wnF = extractInt(msg, 6);
-        packetUBXTIMTM2->data.towMsR = extractLong(msg, 8);
-        packetUBXTIMTM2->data.towSubMsR = extractLong(msg, 12);
-        packetUBXTIMTM2->data.towMsF = extractLong(msg, 16);
-        packetUBXTIMTM2->data.towSubMsF = extractLong(msg, 20);
-        packetUBXTIMTM2->data.accEst = extractLong(msg, 24);
-
-        //Mark all datums as fresh (not read before)
-        packetUBXTIMTM2->moduleQueried.moduleQueried.all = 0xFFFFFFFF;
-
-        //Check if we need to copy the data for the callback
-        if ((packetUBXTIMTM2->callbackData != NULL) // If RAM has been allocated for the copy of the data
-          && (packetUBXTIMTM2->automaticFlags.flags.bits.callbackCopyValid == false)) // AND the data is stale
-        {
-          memcpy(&packetUBXTIMTM2->callbackData->ch, &packetUBXTIMTM2->data.ch, sizeof(UBX_TIM_TM2_data_t));
-          packetUBXTIMTM2->automaticFlags.flags.bits.callbackCopyValid = true;
-        }
-
-        //Check if we need to copy the data into the file buffer
-        if (packetUBXTIMTM2->automaticFlags.flags.bits.addToFileBuffer)
-        {
-          storePacket(msg);
-        }
-      }
-    }
-    break;
-  case UBX_CLASS_ESF:
-    if (msg->id == UBX_ESF_ALG && msg->len == UBX_ESF_ALG_LEN)
-    {
-      //Parse various byte fields into storage - but only if we have memory allocated for it
-      if (packetUBXESFALG != NULL)
-      {
-        packetUBXESFALG->data.iTOW = extractLong(msg, 0);
-        packetUBXESFALG->data.version = extractByte(msg, 4);
-        packetUBXESFALG->data.flags.all = extractByte(msg, 5);
-        packetUBXESFALG->data.error.all = extractByte(msg, 6);
-        packetUBXESFALG->data.yaw = extractLong(msg, 8);
-        packetUBXESFALG->data.pitch = extractSignedInt(msg, 12);
-        packetUBXESFALG->data.roll = extractSignedInt(msg, 14);
-
-        //Mark all datums as fresh (not read before)
-        packetUBXESFALG->moduleQueried.moduleQueried.all = 0xFFFFFFFF;
-
-        //Check if we need to copy the data for the callback
-        if ((packetUBXESFALG->callbackData != NULL) // If RAM has been allocated for the copy of the data
-          && (packetUBXESFALG->automaticFlags.flags.bits.callbackCopyValid == false)) // AND the data is stale
-        {
-          memcpy(&packetUBXESFALG->callbackData->iTOW, &packetUBXESFALG->data.iTOW, sizeof(UBX_ESF_ALG_data_t));
-          packetUBXESFALG->automaticFlags.flags.bits.callbackCopyValid = true;
-        }
-
-        //Check if we need to copy the data into the file buffer
-        if (packetUBXESFALG->automaticFlags.flags.bits.addToFileBuffer)
-        {
-          storePacket(msg);
-        }
-      }
-    }
-    else if (msg->id == UBX_ESF_INS && msg->len == UBX_ESF_INS_LEN)
-    {
-      //Parse various byte fields into storage - but only if we have memory allocated for it
-      if (packetUBXESFINS != NULL)
-      {
-        packetUBXESFINS->data.bitfield0.all = extractLong(msg, 0);
-        packetUBXESFINS->data.iTOW = extractLong(msg, 8);
-        packetUBXESFINS->data.xAngRate = extractSignedLong(msg, 12);
-        packetUBXESFINS->data.yAngRate = extractSignedLong(msg, 16);
-        packetUBXESFINS->data.zAngRate = extractSignedLong(msg, 20);
-        packetUBXESFINS->data.xAccel = extractSignedLong(msg, 24);
-        packetUBXESFINS->data.yAccel = extractSignedLong(msg, 28);
-        packetUBXESFINS->data.zAccel = extractSignedLong(msg, 32);
-
-        //Mark all datums as fresh (not read before)
-        packetUBXESFINS->moduleQueried.moduleQueried.all = 0xFFFFFFFF;
-
-        //Check if we need to copy the data for the callback
-        if ((packetUBXESFINS->callbackData != NULL) // If RAM has been allocated for the copy of the data
-          && (packetUBXESFINS->automaticFlags.flags.bits.callbackCopyValid == false)) // AND the data is stale
-        {
-          memcpy(&packetUBXESFINS->callbackData->bitfield0.all, &packetUBXESFINS->data.bitfield0.all, sizeof(UBX_ESF_INS_data_t));
-          packetUBXESFINS->automaticFlags.flags.bits.callbackCopyValid = true;
-        }
-
-        //Check if we need to copy the data into the file buffer
-        if (packetUBXESFINS->automaticFlags.flags.bits.addToFileBuffer)
-        {
-          storePacket(msg);
-        }
-      }
-    }
-    else if (msg->id == UBX_ESF_MEAS)
-    {
-      //Parse various byte fields into storage - but only if we have memory allocated for it
-      if (packetUBXESFMEAS != NULL)
-      {
-        packetUBXESFMEAS->data.timeTag = extractLong(msg, 0);
-        packetUBXESFMEAS->data.flags.all = extractInt(msg, 4);
-        packetUBXESFMEAS->data.id = extractInt(msg, 6);
-        for (int i = 0; (i < DEF_NUM_SENS) && (i < packetUBXESFMEAS->data.flags.bits.numMeas)
-          && ((i * 4) < (msg->len - 8)); i++)
-        {
-          packetUBXESFMEAS->data.data[i].data.all = extractLong(msg, 8 + (i * 4));
-        }
-        if (msg->len > (8 + (packetUBXESFMEAS->data.flags.bits.numMeas * 4)))
-          packetUBXESFMEAS->data.calibTtag = extractLong(msg, 8 + (packetUBXESFMEAS->data.flags.bits.numMeas * 4));
-
-        //Mark all datums as fresh (not read before)
-        packetUBXESFMEAS->moduleQueried.moduleQueried.all = 0xFFFFFFFF;
-
-        //Check if we need to copy the data for the callback
-        if ((packetUBXESFMEAS->callbackData != NULL) // If RAM has been allocated for the copy of the data
-          && (packetUBXESFMEAS->automaticFlags.flags.bits.callbackCopyValid == false)) // AND the data is stale
-        {
-          memcpy(&packetUBXESFMEAS->callbackData->timeTag, &packetUBXESFMEAS->data.timeTag, sizeof(UBX_ESF_MEAS_data_t));
-          packetUBXESFMEAS->automaticFlags.flags.bits.callbackCopyValid = true;
-        }
-
-        //Check if we need to copy the data into the file buffer
-        if (packetUBXESFMEAS->automaticFlags.flags.bits.addToFileBuffer)
-        {
-          storePacket(msg);
-        }
-      }
-    }
-    else if (msg->id == UBX_ESF_RAW)
-    {
-      //Parse various byte fields into storage - but only if we have memory allocated for it
-      if (packetUBXESFRAW != NULL)
-      {
-        for (int i = 0; (i < DEF_NUM_SENS) && ((i * 8) < (msg->len - 4)); i++)
-        {
-          packetUBXESFRAW->data.data[i].data.all = extractLong(msg, 8 + (i * 8));
-          packetUBXESFRAW->data.data[i].sTag = extractLong(msg, 8 + (i * 8) + 4);
-        }
-
-        //Mark all datums as fresh (not read before)
-        packetUBXESFRAW->moduleQueried.moduleQueried.all = 0xFFFFFFFF;
-
-        //Check if we need to copy the data for the callback
-        if ((packetUBXESFRAW->callbackData != NULL) // If RAM has been allocated for the copy of the data
-          && (packetUBXESFRAW->automaticFlags.flags.bits.callbackCopyValid == false)) // AND the data is stale
-        {
-          memcpy(&packetUBXESFRAW->callbackData->data[0].data.all, &packetUBXESFRAW->data.data[0].data.all, sizeof(UBX_ESF_RAW_data_t));
-          packetUBXESFRAW->automaticFlags.flags.bits.callbackCopyValid = true;
-        }
-
-        //Check if we need to copy the data into the file buffer
-        if (packetUBXESFRAW->automaticFlags.flags.bits.addToFileBuffer)
-        {
-          storePacket(msg);
-        }
-      }
-    }
-    else if (msg->id == UBX_ESF_STATUS)
-    {
-      //Parse various byte fields into storage - but only if we have memory allocated for it
-      if (packetUBXESFSTATUS != NULL)
-      {
-        packetUBXESFSTATUS->data.iTOW = extractLong(msg, 0);
-        packetUBXESFSTATUS->data.version = extractByte(msg, 4);
-        packetUBXESFSTATUS->data.fusionMode = extractByte(msg, 12);
-        packetUBXESFSTATUS->data.numSens = extractByte(msg, 15);
-        for (int i = 0; (i < DEF_NUM_SENS) && (i < packetUBXESFSTATUS->data.numSens)
-          && ((i * 4) < (msg->len - 16)); i++)
-        {
-          packetUBXESFSTATUS->data.status[i].sensStatus1.all = extractByte(msg, 16 + (i * 4) + 0);
-          packetUBXESFSTATUS->data.status[i].sensStatus2.all = extractByte(msg, 16 + (i * 4) + 1);
-          packetUBXESFSTATUS->data.status[i].freq = extractByte(msg, 16 + (i * 4) + 2);
-          packetUBXESFSTATUS->data.status[i].faults.all = extractByte(msg, 16 + (i * 4) + 3);
-        }
-
-        //Mark all datums as fresh (not read before)
-        packetUBXESFSTATUS->moduleQueried.moduleQueried.all = 0xFFFFFFFF;
-
-        //Check if we need to copy the data for the callback
-        if ((packetUBXESFSTATUS->callbackData != NULL) // If RAM has been allocated for the copy of the data
-          && (packetUBXESFSTATUS->automaticFlags.flags.bits.callbackCopyValid == false)) // AND the data is stale
-        {
-          memcpy(&packetUBXESFSTATUS->callbackData->iTOW, &packetUBXESFSTATUS->data.iTOW, sizeof(UBX_ESF_STATUS_data_t));
-          packetUBXESFSTATUS->automaticFlags.flags.bits.callbackCopyValid = true;
-        }
-
-        //Check if we need to copy the data into the file buffer
-        if (packetUBXESFSTATUS->automaticFlags.flags.bits.addToFileBuffer)
-        {
-          storePacket(msg);
-        }
-      }
-    }
-    break;
-  case UBX_CLASS_HNR:
-    if (msg->id == UBX_HNR_PVT && msg->len == UBX_HNR_PVT_LEN)
-    {
-      //Parse various byte fields into storage - but only if we have memory allocated for it
-      if (packetUBXHNRPVT != NULL)
-      {
-        packetUBXHNRPVT->data.iTOW = extractLong(msg, 0);
-        packetUBXHNRPVT->data.year = extractInt(msg, 4);
-        packetUBXHNRPVT->data.month = extractByte(msg, 6);
-        packetUBXHNRPVT->data.day = extractByte(msg, 7);
-        packetUBXHNRPVT->data.hour = extractByte(msg, 8);
-        packetUBXHNRPVT->data.min = extractByte(msg, 9);
-        packetUBXHNRPVT->data.sec = extractByte(msg, 10);
-        packetUBXHNRPVT->data.valid.all = extractByte(msg, 11);
-        packetUBXHNRPVT->data.nano = extractSignedLong(msg, 12);
-        packetUBXHNRPVT->data.gpsFix = extractByte(msg, 16);
-        packetUBXHNRPVT->data.flags.all = extractByte(msg, 17);
-        packetUBXHNRPVT->data.lon = extractSignedLong(msg, 20);
-        packetUBXHNRPVT->data.lat = extractSignedLong(msg, 24);
-        packetUBXHNRPVT->data.height = extractSignedLong(msg, 28);
-        packetUBXHNRPVT->data.hMSL = extractSignedLong(msg, 32);
-        packetUBXHNRPVT->data.gSpeed = extractSignedLong(msg, 36);
-        packetUBXHNRPVT->data.speed = extractSignedLong(msg, 40);
-        packetUBXHNRPVT->data.headMot = extractSignedLong(msg, 44);
-        packetUBXHNRPVT->data.headVeh = extractSignedLong(msg, 48);
-        packetUBXHNRPVT->data.hAcc = extractLong(msg, 52);
-        packetUBXHNRPVT->data.vAcc = extractLong(msg, 56);
-        packetUBXHNRPVT->data.sAcc = extractLong(msg, 60);
-        packetUBXHNRPVT->data.headAcc = extractLong(msg, 64);
-
-        //Mark all datums as fresh (not read before)
-        packetUBXHNRPVT->moduleQueried.moduleQueried.all = 0xFFFFFFFF;
-
-        //Check if we need to copy the data for the callback
-        if ((packetUBXHNRPVT->callbackData != NULL) // If RAM has been allocated for the copy of the data
-          && (packetUBXHNRPVT->automaticFlags.flags.bits.callbackCopyValid == false)) // AND the data is stale
-        {
-          memcpy(&packetUBXHNRPVT->callbackData->iTOW, &packetUBXHNRPVT->data.iTOW, sizeof(UBX_HNR_PVT_data_t));
-          packetUBXHNRPVT->automaticFlags.flags.bits.callbackCopyValid = true;
-        }
-
-        //Check if we need to copy the data into the file buffer
-        if (packetUBXHNRPVT->automaticFlags.flags.bits.addToFileBuffer)
-        {
-          storePacket(msg);
-        }
-      }
-    }
-    else if (msg->id == UBX_HNR_ATT && msg->len == UBX_HNR_ATT_LEN)
-    {
-      //Parse various byte fields into storage - but only if we have memory allocated for it
-      if (packetUBXHNRATT != NULL)
-      {
-        packetUBXHNRATT->data.iTOW = extractLong(msg, 0);
-        packetUBXHNRATT->data.version = extractByte(msg, 4);
-        packetUBXHNRATT->data.roll = extractSignedLong(msg, 8);
-        packetUBXHNRATT->data.pitch = extractSignedLong(msg, 12);
-        packetUBXHNRATT->data.heading = extractSignedLong(msg, 16);
-        packetUBXHNRATT->data.accRoll = extractLong(msg, 20);
-        packetUBXHNRATT->data.accPitch = extractLong(msg, 24);
-        packetUBXHNRATT->data.accHeading = extractLong(msg, 28);
-
-        //Mark all datums as fresh (not read before)
-        packetUBXHNRATT->moduleQueried.moduleQueried.all = 0xFFFFFFFF;
-
-        //Check if we need to copy the data for the callback
-        if ((packetUBXHNRATT->callbackData != NULL) // If RAM has been allocated for the copy of the data
-          && (packetUBXHNRATT->automaticFlags.flags.bits.callbackCopyValid == false)) // AND the data is stale
-        {
-          memcpy(&packetUBXHNRATT->callbackData->iTOW, &packetUBXHNRATT->data.iTOW, sizeof(UBX_HNR_ATT_data_t));
-          packetUBXHNRATT->automaticFlags.flags.bits.callbackCopyValid = true;
-        }
-
-        //Check if we need to copy the data into the file buffer
-        if (packetUBXHNRATT->automaticFlags.flags.bits.addToFileBuffer)
-        {
-          storePacket(msg);
-        }
-      }
-    }
-    else if (msg->id == UBX_HNR_INS && msg->len == UBX_HNR_INS_LEN)
-    {
-      //Parse various byte fields into storage - but only if we have memory allocated for it
-      if (packetUBXHNRINS != NULL)
-      {
-        packetUBXHNRINS->data.bitfield0.all = extractLong(msg, 0);
-        packetUBXHNRINS->data.iTOW = extractLong(msg, 8);
-        packetUBXHNRINS->data.xAngRate = extractSignedLong(msg, 12);
-        packetUBXHNRINS->data.yAngRate = extractSignedLong(msg, 16);
-        packetUBXHNRINS->data.zAngRate = extractSignedLong(msg, 20);
-        packetUBXHNRINS->data.xAccel = extractSignedLong(msg, 24);
-        packetUBXHNRINS->data.yAccel = extractSignedLong(msg, 28);
-        packetUBXHNRINS->data.zAccel = extractSignedLong(msg, 32);
-
-        //Mark all datums as fresh (not read before)
-        packetUBXHNRINS->moduleQueried.moduleQueried.all = 0xFFFFFFFF;
-
-        //Check if we need to copy the data for the callback
-        if ((packetUBXHNRINS->callbackData != NULL) // If RAM has been allocated for the copy of the data
-          && (packetUBXHNRINS->automaticFlags.flags.bits.callbackCopyValid == false)) // AND the data is stale
-        {
-          memcpy(&packetUBXHNRINS->callbackData->bitfield0.all, &packetUBXHNRINS->data.bitfield0.all, sizeof(UBX_HNR_INS_data_t));
-          packetUBXHNRINS->automaticFlags.flags.bits.callbackCopyValid = true;
-        }
-
-        //Check if we need to copy the data into the file buffer
-        if (packetUBXHNRINS->automaticFlags.flags.bits.addToFileBuffer)
-        {
-          storePacket(msg);
-        }
-      }
-    }
-    break;
-  }
-}
-
-//Given a message, calc and store the two byte "8-Bit Fletcher" checksum over the entirety of the message
-//This is called before we send a command message
-void SFE_UBLOX_GNSS::calcChecksum(ubxPacket *msg)
-{
-  msg->checksumA = 0;
-  msg->checksumB = 0;
-
-  msg->checksumA += msg->cls;
-  msg->checksumB += msg->checksumA;
-
-  msg->checksumA += msg->id;
-  msg->checksumB += msg->checksumA;
-
-  msg->checksumA += (msg->len & 0xFF);
-  msg->checksumB += msg->checksumA;
-
-  msg->checksumA += (msg->len >> 8);
-  msg->checksumB += msg->checksumA;
-
-  for (uint16_t i = 0; i < msg->len; i++)
-  {
-    msg->checksumA += msg->payload[i];
-    msg->checksumB += msg->checksumA;
-  }
-}
-
-//Given a message and a byte, add to rolling "8-Bit Fletcher" checksum
-//This is used when receiving messages from module
-void SFE_UBLOX_GNSS::addToChecksum(uint8_t incoming)
-{
-  rollingChecksumA += incoming;
-  rollingChecksumB += rollingChecksumA;
-}
-
-//Given a packet and payload, send everything including CRC bytes via I2C port
-sfe_ublox_status_e SFE_UBLOX_GNSS::sendCommand(ubxPacket *outgoingUBX, uint16_t maxWait, boolean expectACKonly)
-{
-  sfe_ublox_status_e retVal = SFE_UBLOX_STATUS_SUCCESS;
-
-  calcChecksum(outgoingUBX); //Sets checksum A and B bytes of the packet
-
-  if (_printDebug == true)
-  {
-    _debugSerial->print(F("\nSending: "));
-    printPacket(outgoingUBX, true); // Always print payload
-  }
-
-  if (commType == COMM_TYPE_I2C)
-  {
-    retVal = sendI2cCommand(outgoingUBX, maxWait);
-    if (retVal != SFE_UBLOX_STATUS_SUCCESS)
-    {
-      if (_printDebug == true)
-      {
-        _debugSerial->println(F("Send I2C Command failed"));
-      }
-      return retVal;
-    }
-  }
-  else if (commType == COMM_TYPE_SERIAL)
-  {
-    sendSerialCommand(outgoingUBX);
-  }
-
-  if (maxWait > 0)
-  {
-    //Depending on what we just sent, either we need to look for an ACK or not
-    if ((outgoingUBX->cls == UBX_CLASS_CFG) || (expectACKonly == true))
-    {
-      if (_printDebug == true)
-      {
-        _debugSerial->println(F("sendCommand: Waiting for ACK response"));
-      }
-      retVal = waitForACKResponse(outgoingUBX, outgoingUBX->cls, outgoingUBX->id, maxWait); //Wait for Ack response
-    }
-    else
-    {
-      if (_printDebug == true)
-      {
-        _debugSerial->println(F("sendCommand: Waiting for No ACK response"));
-      }
-      retVal = waitForNoACKResponse(outgoingUBX, outgoingUBX->cls, outgoingUBX->id, maxWait); //Wait for Ack response
-    }
-  }
-  return retVal;
-}
-
-//Returns false if sensor fails to respond to I2C traffic
-sfe_ublox_status_e SFE_UBLOX_GNSS::sendI2cCommand(ubxPacket *outgoingUBX, uint16_t maxWait)
-{
-  //Point at 0xFF data register
-  _i2cPort->beginTransmission((uint8_t)_gpsI2Caddress); //There is no register to write to, we just begin writing data bytes
-  _i2cPort->write(0xFF);
-  if (_i2cPort->endTransmission(false) != 0)         //Don't release bus
-    return (SFE_UBLOX_STATUS_I2C_COMM_FAILURE); //Sensor did not ACK
-
-  //Write header bytes
-  _i2cPort->beginTransmission((uint8_t)_gpsI2Caddress); //There is no register to write to, we just begin writing data bytes
-  _i2cPort->write(UBX_SYNCH_1);                         //μ - oh ublox, you're funny. I will call you micro-blox from now on.
-  _i2cPort->write(UBX_SYNCH_2);                         //b
-  _i2cPort->write(outgoingUBX->cls);
-  _i2cPort->write(outgoingUBX->id);
-  _i2cPort->write(outgoingUBX->len & 0xFF);     //LSB
-  _i2cPort->write(outgoingUBX->len >> 8);       //MSB
-  if (_i2cPort->endTransmission(false) != 0)    //Do not release bus
-    return (SFE_UBLOX_STATUS_I2C_COMM_FAILURE); //Sensor did not ACK
-
-  //Write payload. Limit the sends into 32 byte chunks
-  //This code based on ublox: https://forum.u-blox.com/index.php/20528/how-to-use-i2c-to-get-the-nmea-frames
-  uint16_t bytesToSend = outgoingUBX->len;
-
-  //"The number of data bytes must be at least 2 to properly distinguish
-  //from the write access to set the address counter in random read accesses."
-  uint16_t startSpot = 0;
-  while (bytesToSend > 1)
-  {
-    uint8_t len = bytesToSend;
-    if (len > i2cTransactionSize)
-      len = i2cTransactionSize;
-
-    _i2cPort->beginTransmission((uint8_t)_gpsI2Caddress);
-    //_i2cPort->write(outgoingUBX->payload, len); //Write a portion of the payload to the bus
-
-    for (uint16_t x = 0; x < len; x++)
-      _i2cPort->write(outgoingUBX->payload[startSpot + x]); //Write a portion of the payload to the bus
-
-    if (_i2cPort->endTransmission(false) != 0)    //Don't release bus
-      return (SFE_UBLOX_STATUS_I2C_COMM_FAILURE); //Sensor did not ACK
-
-    //*outgoingUBX->payload += len; //Move the pointer forward
-    startSpot += len; //Move the pointer forward
-    bytesToSend -= len;
-  }
-
-  //Write checksum
-  _i2cPort->beginTransmission((uint8_t)_gpsI2Caddress);
-  if (bytesToSend == 1)
-    _i2cPort->write(outgoingUBX->payload, 1);
-  _i2cPort->write(outgoingUBX->checksumA);
-  _i2cPort->write(outgoingUBX->checksumB);
-
-  //All done transmitting bytes. Release bus.
-  if (_i2cPort->endTransmission() != 0)
-    return (SFE_UBLOX_STATUS_I2C_COMM_FAILURE); //Sensor did not ACK
-  return (SFE_UBLOX_STATUS_SUCCESS);
-}
-
-//Given a packet and payload, send everything including CRC bytesA via Serial port
-void SFE_UBLOX_GNSS::sendSerialCommand(ubxPacket *outgoingUBX)
-{
-  //Write header bytes
-  _serialPort->write(UBX_SYNCH_1); //μ - oh ublox, you're funny. I will call you micro-blox from now on.
-  _serialPort->write(UBX_SYNCH_2); //b
-  _serialPort->write(outgoingUBX->cls);
-  _serialPort->write(outgoingUBX->id);
-  _serialPort->write(outgoingUBX->len & 0xFF); //LSB
-  _serialPort->write(outgoingUBX->len >> 8);   //MSB
-
-  //Write payload.
-  for (int i = 0; i < outgoingUBX->len; i++)
-  {
-    _serialPort->write(outgoingUBX->payload[i]);
-  }
-
-  //Write checksum
-  _serialPort->write(outgoingUBX->checksumA);
-  _serialPort->write(outgoingUBX->checksumB);
-}
-
-//Pretty prints the current ubxPacket
-void SFE_UBLOX_GNSS::printPacket(ubxPacket *packet, boolean alwaysPrintPayload)
-{
-  if (_printDebug == true)
-  {
-    _debugSerial->print(F("CLS:"));
-    if (packet->cls == UBX_CLASS_NAV) //1
-      _debugSerial->print(F("NAV"));
-    else if (packet->cls == UBX_CLASS_ACK) //5
-      _debugSerial->print(F("ACK"));
-    else if (packet->cls == UBX_CLASS_CFG) //6
-      _debugSerial->print(F("CFG"));
-    else if (packet->cls == UBX_CLASS_MON) //0x0A
-      _debugSerial->print(F("MON"));
-    else
-    {
-      _debugSerial->print(F("0x"));
-      _debugSerial->print(packet->cls, HEX);
-    }
-
-    _debugSerial->print(F(" ID:"));
-    if (packet->cls == UBX_CLASS_NAV && packet->id == UBX_NAV_PVT)
-      _debugSerial->print(F("PVT"));
-    else if (packet->cls == UBX_CLASS_CFG && packet->id == UBX_CFG_RATE)
-      _debugSerial->print(F("RATE"));
-    else if (packet->cls == UBX_CLASS_CFG && packet->id == UBX_CFG_CFG)
-      _debugSerial->print(F("SAVE"));
-    else
-    {
-      _debugSerial->print(F("0x"));
-      _debugSerial->print(packet->id, HEX);
-    }
-
-    _debugSerial->print(F(" Len: 0x"));
-    _debugSerial->print(packet->len, HEX);
-
-    // Only print the payload is ignoreThisPayload is false otherwise
-    // we could be printing gibberish from beyond the end of packetBuf
-    if ((alwaysPrintPayload == true) || (ignoreThisPayload == false))
-    {
-      _debugSerial->print(F(" Payload:"));
-
-      for (int x = 0; x < packet->len; x++)
-      {
-        _debugSerial->print(F(" "));
-        _debugSerial->print(packet->payload[x], HEX);
-      }
-    }
-    else
-    {
-      _debugSerial->print(F(" Payload: IGNORED"));
-    }
-    _debugSerial->println();
-  }
-}
-
-//When messages from the class CFG are sent to the receiver, the receiver will send an "acknowledge"(UBX - ACK - ACK) or a
-//"not acknowledge"(UBX-ACK-NAK) message back to the sender, depending on whether or not the message was processed correctly.
-//Some messages from other classes also use the same acknowledgement mechanism.
-
-//When we poll or get a setting, we will receive _both_ a config packet and an ACK
-//If the poll or get request is not valid, we will receive _only_ a NACK
-
-//If we are trying to get or poll a setting, then packetCfg.len will be 0 or 1 when the packetCfg is _sent_.
-//If we poll the setting for a particular port using UBX-CFG-PRT then .len will be 1 initially
-//For all other gets or polls, .len will be 0 initially
-//(It would be possible for .len to be 2 _if_ we were using UBX-CFG-MSG to poll the settings for a particular message - but we don't use that (currently))
-
-//If the get or poll _fails_, i.e. is NACK'd, then packetCfg.len could still be 0 or 1 after the NACK is received
-//But if the get or poll is ACK'd, then packetCfg.len will have been updated by the incoming data and will always be at least 2
-
-//If we are going to set the value for a setting, then packetCfg.len will be at least 3 when the packetCfg is _sent_.
-//(UBX-CFG-MSG appears to have the shortest set length of 3 bytes)
-
-//We need to think carefully about how interleaved PVT packets affect things.
-//It is entirely possible that our packetCfg and packetAck were received successfully
-//but while we are still in the "if (checkUblox() == true)" loop a PVT packet is processed
-//or _starts_ to arrive (remember that Serial data can arrive very slowly).
-
-//Returns SFE_UBLOX_STATUS_DATA_RECEIVED if we got an ACK and a valid packetCfg (module is responding with register content)
-//Returns SFE_UBLOX_STATUS_DATA_SENT if we got an ACK and no packetCfg (no valid packetCfg needed, module absorbs new register data)
-//Returns SFE_UBLOX_STATUS_FAIL if something very bad happens (e.g. a double checksum failure)
-//Returns SFE_UBLOX_STATUS_COMMAND_NACK if the packet was not-acknowledged (NACK)
-//Returns SFE_UBLOX_STATUS_CRC_FAIL if we had a checksum failure
-//Returns SFE_UBLOX_STATUS_TIMEOUT if we timed out
-//Returns SFE_UBLOX_STATUS_DATA_OVERWRITTEN if we got an ACK and a valid packetCfg but that the packetCfg has been
-// or is currently being overwritten (remember that Serial data can arrive very slowly)
-sfe_ublox_status_e SFE_UBLOX_GNSS::waitForACKResponse(ubxPacket *outgoingUBX, uint8_t requestedClass, uint8_t requestedID, uint16_t maxTime)
-{
-  outgoingUBX->valid = SFE_UBLOX_PACKET_VALIDITY_NOT_DEFINED; //This will go VALID (or NOT_VALID) when we receive a response to the packet we sent
-  packetAck.valid = SFE_UBLOX_PACKET_VALIDITY_NOT_DEFINED;
-  packetBuf.valid = SFE_UBLOX_PACKET_VALIDITY_NOT_DEFINED;
-  packetAuto.valid = SFE_UBLOX_PACKET_VALIDITY_NOT_DEFINED;
-  outgoingUBX->classAndIDmatch = SFE_UBLOX_PACKET_VALIDITY_NOT_DEFINED; // This will go VALID (or NOT_VALID) when we receive a packet that matches the requested class and ID
-  packetAck.classAndIDmatch = SFE_UBLOX_PACKET_VALIDITY_NOT_DEFINED;
-  packetBuf.classAndIDmatch = SFE_UBLOX_PACKET_VALIDITY_NOT_DEFINED;
-  packetAuto.classAndIDmatch = SFE_UBLOX_PACKET_VALIDITY_NOT_DEFINED;
-
-  unsigned long startTime = millis();
-  while (millis() - startTime < maxTime)
-  {
-    if (checkUbloxInternal(outgoingUBX, requestedClass, requestedID) == true) //See if new data is available. Process bytes as they come in.
-    {
-      // If both the outgoingUBX->classAndIDmatch and packetAck.classAndIDmatch are VALID
-      // and outgoingUBX->valid is _still_ VALID and the class and ID _still_ match
-      // then we can be confident that the data in outgoingUBX is valid
-      if ((outgoingUBX->classAndIDmatch == SFE_UBLOX_PACKET_VALIDITY_VALID) && (packetAck.classAndIDmatch == SFE_UBLOX_PACKET_VALIDITY_VALID) && (outgoingUBX->valid == SFE_UBLOX_PACKET_VALIDITY_VALID) && (outgoingUBX->cls == requestedClass) && (outgoingUBX->id == requestedID))
-      {
-        if (_printDebug == true)
-        {
-          _debugSerial->print(F("waitForACKResponse: valid data and valid ACK received after "));
-          _debugSerial->print(millis() - startTime);
-          _debugSerial->println(F(" msec"));
-        }
-        return (SFE_UBLOX_STATUS_DATA_RECEIVED); //We received valid data and a correct ACK!
-      }
-
-      // We can be confident that the data packet (if we are going to get one) will always arrive
-      // before the matching ACK. So if we sent a config packet which only produces an ACK
-      // then outgoingUBX->classAndIDmatch will be NOT_DEFINED and the packetAck.classAndIDmatch will VALID.
-      // We should not check outgoingUBX->valid, outgoingUBX->cls or outgoingUBX->id
-      // as these may have been changed by an automatic packet.
-      else if ((outgoingUBX->classAndIDmatch == SFE_UBLOX_PACKET_VALIDITY_NOT_DEFINED) && (packetAck.classAndIDmatch == SFE_UBLOX_PACKET_VALIDITY_VALID))
-      {
-        if (_printDebug == true)
-        {
-          _debugSerial->print(F("waitForACKResponse: no data and valid ACK after "));
-          _debugSerial->print(millis() - startTime);
-          _debugSerial->println(F(" msec"));
-        }
-        return (SFE_UBLOX_STATUS_DATA_SENT); //We got an ACK but no data...
-      }
-
-      // If both the outgoingUBX->classAndIDmatch and packetAck.classAndIDmatch are VALID
-      // but the outgoingUBX->cls or ID no longer match then we can be confident that we had
-      // valid data but it has been or is currently being overwritten by an automatic packet (e.g. PVT).
-      // If (e.g.) a PVT packet is _being_ received: outgoingUBX->valid will be NOT_DEFINED
-      // If (e.g.) a PVT packet _has been_ received: outgoingUBX->valid will be VALID (or just possibly NOT_VALID)
-      // So we cannot use outgoingUBX->valid as part of this check.
-      // Note: the addition of packetBuf should make this check redundant!
-      else if ((outgoingUBX->classAndIDmatch == SFE_UBLOX_PACKET_VALIDITY_VALID) && (packetAck.classAndIDmatch == SFE_UBLOX_PACKET_VALIDITY_VALID) && ((outgoingUBX->cls != requestedClass) || (outgoingUBX->id != requestedID)))
-      {
-        if (_printDebug == true)
-        {
-          _debugSerial->print(F("waitForACKResponse: data being OVERWRITTEN after "));
-          _debugSerial->print(millis() - startTime);
-          _debugSerial->println(F(" msec"));
-        }
-        return (SFE_UBLOX_STATUS_DATA_OVERWRITTEN); // Data was valid but has been or is being overwritten
-      }
-
-      // If packetAck.classAndIDmatch is VALID but both outgoingUBX->valid and outgoingUBX->classAndIDmatch
-      // are NOT_VALID then we can be confident we have had a checksum failure on the data packet
-      else if ((packetAck.classAndIDmatch == SFE_UBLOX_PACKET_VALIDITY_VALID) && (outgoingUBX->classAndIDmatch == SFE_UBLOX_PACKET_VALIDITY_NOT_VALID) && (outgoingUBX->valid == SFE_UBLOX_PACKET_VALIDITY_NOT_VALID))
-      {
-        if (_printDebug == true)
-        {
-          _debugSerial->print(F("waitForACKResponse: CRC failed after "));
-          _debugSerial->print(millis() - startTime);
-          _debugSerial->println(F(" msec"));
-        }
-        return (SFE_UBLOX_STATUS_CRC_FAIL); //Checksum fail
-      }
-
-      // If our packet was not-acknowledged (NACK) we do not receive a data packet - we only get the NACK.
-      // So you would expect outgoingUBX->valid and outgoingUBX->classAndIDmatch to still be NOT_DEFINED
-      // But if a full PVT packet arrives afterwards outgoingUBX->valid could be VALID (or just possibly NOT_VALID)
-      // but outgoingUBX->cls and outgoingUBX->id would not match...
-      // So I think this is telling us we need a special state for packetAck.classAndIDmatch to tell us
-      // the packet was definitely NACK'd otherwise we are possibly just guessing...
-      // Note: the addition of packetBuf changes the logic of this, but we'll leave the code as is for now.
-      else if (packetAck.classAndIDmatch == SFE_UBLOX_PACKET_NOTACKNOWLEDGED)
-      {
-        if (_printDebug == true)
-        {
-          _debugSerial->print(F("waitForACKResponse: data was NOTACKNOWLEDGED (NACK) after "));
-          _debugSerial->print(millis() - startTime);
-          _debugSerial->println(F(" msec"));
-        }
-        return (SFE_UBLOX_STATUS_COMMAND_NACK); //We received a NACK!
-      }
-
-      // If the outgoingUBX->classAndIDmatch is VALID but the packetAck.classAndIDmatch is NOT_VALID
-      // then the ack probably had a checksum error. We will take a gamble and return DATA_RECEIVED.
-      // If we were playing safe, we should return FAIL instead
-      else if ((outgoingUBX->classAndIDmatch == SFE_UBLOX_PACKET_VALIDITY_VALID) && (packetAck.classAndIDmatch == SFE_UBLOX_PACKET_VALIDITY_NOT_VALID) && (outgoingUBX->valid == SFE_UBLOX_PACKET_VALIDITY_VALID) && (outgoingUBX->cls == requestedClass) && (outgoingUBX->id == requestedID))
-      {
-        if (_printDebug == true)
-        {
-          _debugSerial->print(F("waitForACKResponse: VALID data and INVALID ACK received after "));
-          _debugSerial->print(millis() - startTime);
-          _debugSerial->println(F(" msec"));
-        }
-        return (SFE_UBLOX_STATUS_DATA_RECEIVED); //We received valid data and an invalid ACK!
-      }
-
-      // If the outgoingUBX->classAndIDmatch is NOT_VALID and the packetAck.classAndIDmatch is NOT_VALID
-      // then we return a FAIL. This must be a double checksum failure?
-      else if ((outgoingUBX->classAndIDmatch == SFE_UBLOX_PACKET_VALIDITY_NOT_VALID) && (packetAck.classAndIDmatch == SFE_UBLOX_PACKET_VALIDITY_NOT_VALID))
-      {
-        if (_printDebug == true)
-        {
-          _debugSerial->print(F("waitForACKResponse: INVALID data and INVALID ACK received after "));
-          _debugSerial->print(millis() - startTime);
-          _debugSerial->println(F(" msec"));
-        }
-        return (SFE_UBLOX_STATUS_FAIL); //We received invalid data and an invalid ACK!
-      }
-
-      // If the outgoingUBX->classAndIDmatch is VALID and the packetAck.classAndIDmatch is NOT_DEFINED
-      // then the ACK has not yet been received and we should keep waiting for it
-      else if ((outgoingUBX->classAndIDmatch == SFE_UBLOX_PACKET_VALIDITY_VALID) && (packetAck.classAndIDmatch == SFE_UBLOX_PACKET_VALIDITY_NOT_DEFINED))
-      {
-        // if (_printDebug == true)
-        // {
-        //   _debugSerial->print(F("waitForACKResponse: valid data after "));
-        //   _debugSerial->print(millis() - startTime);
-        //   _debugSerial->println(F(" msec. Waiting for ACK."));
-        // }
-      }
-
-    } //checkUbloxInternal == true
-
-    delayMicroseconds(500);
-  } //while (millis() - startTime < maxTime)
-
-  // We have timed out...
-  // If the outgoingUBX->classAndIDmatch is VALID then we can take a gamble and return DATA_RECEIVED
-  // even though we did not get an ACK
-  if ((outgoingUBX->classAndIDmatch == SFE_UBLOX_PACKET_VALIDITY_VALID) && (packetAck.classAndIDmatch == SFE_UBLOX_PACKET_VALIDITY_NOT_DEFINED) && (outgoingUBX->valid == SFE_UBLOX_PACKET_VALIDITY_VALID) && (outgoingUBX->cls == requestedClass) && (outgoingUBX->id == requestedID))
-  {
-    if (_printDebug == true)
-    {
-      _debugSerial->print(F("waitForACKResponse: TIMEOUT with valid data after "));
-      _debugSerial->print(millis() - startTime);
-      _debugSerial->println(F(" msec. "));
-    }
-    return (SFE_UBLOX_STATUS_DATA_RECEIVED); //We received valid data... But no ACK!
-  }
-
-  if (_printDebug == true)
-  {
-    _debugSerial->print(F("waitForACKResponse: TIMEOUT after "));
-    _debugSerial->print(millis() - startTime);
-    _debugSerial->println(F(" msec."));
-  }
-
-  return (SFE_UBLOX_STATUS_TIMEOUT);
-}
-
-//For non-CFG queries no ACK is sent so we use this function
-//Returns SFE_UBLOX_STATUS_DATA_RECEIVED if we got a config packet full of response data that has CLS/ID match to our query packet
-//Returns SFE_UBLOX_STATUS_CRC_FAIL if we got a corrupt config packet that has CLS/ID match to our query packet
-//Returns SFE_UBLOX_STATUS_TIMEOUT if we timed out
-//Returns SFE_UBLOX_STATUS_DATA_OVERWRITTEN if we got an a valid packetCfg but that the packetCfg has been
-// or is currently being overwritten (remember that Serial data can arrive very slowly)
-sfe_ublox_status_e SFE_UBLOX_GNSS::waitForNoACKResponse(ubxPacket *outgoingUBX, uint8_t requestedClass, uint8_t requestedID, uint16_t maxTime)
-{
-  outgoingUBX->valid = SFE_UBLOX_PACKET_VALIDITY_NOT_DEFINED; //This will go VALID (or NOT_VALID) when we receive a response to the packet we sent
-  packetAck.valid = SFE_UBLOX_PACKET_VALIDITY_NOT_DEFINED;
-  packetBuf.valid = SFE_UBLOX_PACKET_VALIDITY_NOT_DEFINED;
-  packetAuto.valid = SFE_UBLOX_PACKET_VALIDITY_NOT_DEFINED;
-  outgoingUBX->classAndIDmatch = SFE_UBLOX_PACKET_VALIDITY_NOT_DEFINED; // This will go VALID (or NOT_VALID) when we receive a packet that matches the requested class and ID
-  packetAck.classAndIDmatch = SFE_UBLOX_PACKET_VALIDITY_NOT_DEFINED;
-  packetBuf.classAndIDmatch = SFE_UBLOX_PACKET_VALIDITY_NOT_DEFINED;
-  packetAuto.classAndIDmatch = SFE_UBLOX_PACKET_VALIDITY_NOT_DEFINED;
-
-  unsigned long startTime = millis();
-  while (millis() - startTime < maxTime)
-  {
-    if (checkUbloxInternal(outgoingUBX, requestedClass, requestedID) == true) //See if new data is available. Process bytes as they come in.
-    {
-
-      // If outgoingUBX->classAndIDmatch is VALID
-      // and outgoingUBX->valid is _still_ VALID and the class and ID _still_ match
-      // then we can be confident that the data in outgoingUBX is valid
-      if ((outgoingUBX->classAndIDmatch == SFE_UBLOX_PACKET_VALIDITY_VALID) && (outgoingUBX->valid == SFE_UBLOX_PACKET_VALIDITY_VALID) && (outgoingUBX->cls == requestedClass) && (outgoingUBX->id == requestedID))
-      {
-        if (_printDebug == true)
-        {
-          _debugSerial->print(F("waitForNoACKResponse: valid data with CLS/ID match after "));
-          _debugSerial->print(millis() - startTime);
-          _debugSerial->println(F(" msec"));
-        }
-        return (SFE_UBLOX_STATUS_DATA_RECEIVED); //We received valid data!
-      }
-
-      // If the outgoingUBX->classAndIDmatch is VALID
-      // but the outgoingUBX->cls or ID no longer match then we can be confident that we had
-      // valid data but it has been or is currently being overwritten by another packet (e.g. PVT).
-      // If (e.g.) a PVT packet is _being_ received: outgoingUBX->valid will be NOT_DEFINED
-      // If (e.g.) a PVT packet _has been_ received: outgoingUBX->valid will be VALID (or just possibly NOT_VALID)
-      // So we cannot use outgoingUBX->valid as part of this check.
-      // Note: the addition of packetBuf should make this check redundant!
-      else if ((outgoingUBX->classAndIDmatch == SFE_UBLOX_PACKET_VALIDITY_VALID) && ((outgoingUBX->cls != requestedClass) || (outgoingUBX->id != requestedID)))
-      {
-        if (_printDebug == true)
-        {
-          _debugSerial->print(F("waitForNoACKResponse: data being OVERWRITTEN after "));
-          _debugSerial->print(millis() - startTime);
-          _debugSerial->println(F(" msec"));
-        }
-        return (SFE_UBLOX_STATUS_DATA_OVERWRITTEN); // Data was valid but has been or is being overwritten
-      }
-
-      // If outgoingUBX->classAndIDmatch is NOT_DEFINED
-      // and outgoingUBX->valid is VALID then this must be (e.g.) a PVT packet
-      else if ((outgoingUBX->classAndIDmatch == SFE_UBLOX_PACKET_VALIDITY_NOT_DEFINED) && (outgoingUBX->valid == SFE_UBLOX_PACKET_VALIDITY_VALID))
-      {
-        // if (_printDebug == true)
-        // {
-        //   _debugSerial->print(F("waitForNoACKResponse: valid but UNWANTED data after "));
-        //   _debugSerial->print(millis() - startTime);
-        //   _debugSerial->print(F(" msec. Class: "));
-        //   _debugSerial->print(outgoingUBX->cls);
-        //   _debugSerial->print(F(" ID: "));
-        //   _debugSerial->print(outgoingUBX->id);
-        // }
-      }
-
-      // If the outgoingUBX->classAndIDmatch is NOT_VALID then we return CRC failure
-      else if (outgoingUBX->classAndIDmatch == SFE_UBLOX_PACKET_VALIDITY_NOT_VALID)
-      {
-        if (_printDebug == true)
-        {
-          _debugSerial->print(F("waitForNoACKResponse: CLS/ID match but failed CRC after "));
-          _debugSerial->print(millis() - startTime);
-          _debugSerial->println(F(" msec"));
-        }
-        return (SFE_UBLOX_STATUS_CRC_FAIL); //We received invalid data
-      }
-    }
-
-    delayMicroseconds(500);
-  }
-
-  if (_printDebug == true)
-  {
-    _debugSerial->print(F("waitForNoACKResponse: TIMEOUT after "));
-    _debugSerial->print(millis() - startTime);
-    _debugSerial->println(F(" msec. No packet received."));
-  }
-
-  return (SFE_UBLOX_STATUS_TIMEOUT);
-}
-
-// Check if any callbacks are waiting to be processed
-void SFE_UBLOX_GNSS::checkCallbacks(void)
-{
-  if (checkCallbacksReentrant == true) // Check for reentry (i.e. checkCallbacks has been called from inside a callback)
-    return;
-
-  checkCallbacksReentrant = true;
-
-  if ((packetUBXNAVPOSECEF != NULL) // If RAM has been allocated for message storage
-    && (packetUBXNAVPOSECEF->callbackData != NULL) // If RAM has been allocated for the copy of the data
-    && (packetUBXNAVPOSECEF->callbackPointer != NULL) // If the pointer to the callback has been defined
-    && (packetUBXNAVPOSECEF->automaticFlags.flags.bits.callbackCopyValid == true)) // If the copy of the data is valid
-  {
-    // if (_printDebug == true)
-    //   _debugSerial->println(F("checkCallbacks: calling callback for NAV POSECEF"));
-    packetUBXNAVPOSECEF->callbackPointer(*packetUBXNAVPOSECEF->callbackData); // Call the callback
-    packetUBXNAVPOSECEF->automaticFlags.flags.bits.callbackCopyValid = false; // Mark the data as stale
-  }
-
-  if ((packetUBXNAVSTATUS != NULL) // If RAM has been allocated for message storage
-    && (packetUBXNAVSTATUS->callbackData != NULL) // If RAM has been allocated for the copy of the data
-    && (packetUBXNAVSTATUS->callbackPointer != NULL) // If the pointer to the callback has been defined
-    && (packetUBXNAVSTATUS->automaticFlags.flags.bits.callbackCopyValid == true)) // If the copy of the data is valid
-  {
-    // if (_printDebug == true)
-    //   _debugSerial->println(F("checkCallbacks: calling callback for NAV STATUS"));
-    packetUBXNAVSTATUS->callbackPointer(*packetUBXNAVSTATUS->callbackData); // Call the callback
-    packetUBXNAVSTATUS->automaticFlags.flags.bits.callbackCopyValid = false; // Mark the data as stale
-  }
-
-  if ((packetUBXNAVDOP != NULL) // If RAM has been allocated for message storage
-    && (packetUBXNAVDOP->callbackData != NULL) // If RAM has been allocated for the copy of the data
-    && (packetUBXNAVDOP->callbackPointer != NULL) // If the pointer to the callback has been defined
-    && (packetUBXNAVDOP->automaticFlags.flags.bits.callbackCopyValid == true)) // If the copy of the data is valid
-  {
-    // if (_printDebug == true)
-    //   _debugSerial->println(F("checkCallbacks: calling callback for NAV DOP"));
-    packetUBXNAVDOP->callbackPointer(*packetUBXNAVDOP->callbackData); // Call the callback
-    packetUBXNAVDOP->automaticFlags.flags.bits.callbackCopyValid = false; // Mark the data as stale
-  }
-
-  if ((packetUBXNAVATT != NULL) // If RAM has been allocated for message storage
-    && (packetUBXNAVATT->callbackData != NULL) // If RAM has been allocated for the copy of the data
-    && (packetUBXNAVATT->callbackPointer != NULL) // If the pointer to the callback has been defined
-    && (packetUBXNAVATT->automaticFlags.flags.bits.callbackCopyValid == true)) // If the copy of the data is valid
-  {
-    // if (_printDebug == true)
-    //   _debugSerial->println(F("checkCallbacks: calling callback for NAV ATT"));
-    packetUBXNAVATT->callbackPointer(*packetUBXNAVATT->callbackData); // Call the callback
-    packetUBXNAVATT->automaticFlags.flags.bits.callbackCopyValid = false; // Mark the data as stale
-  }
-
-  if ((packetUBXNAVPVT != NULL) // If RAM has been allocated for message storage
-    && (packetUBXNAVPVT->callbackData != NULL) // If RAM has been allocated for the copy of the data
-    && (packetUBXNAVPVT->callbackPointer != NULL) // If the pointer to the callback has been defined
-    && (packetUBXNAVPVT->automaticFlags.flags.bits.callbackCopyValid == true)) // If the copy of the data is valid
-  {
-    //if (_printDebug == true)
-    //  _debugSerial->println(F("checkCallbacks: calling callback for NAV PVT"));
-    packetUBXNAVPVT->callbackPointer(*packetUBXNAVPVT->callbackData); // Call the callback
-    packetUBXNAVPVT->automaticFlags.flags.bits.callbackCopyValid = false; // Mark the data as stale
-  }
-
-  if ((packetUBXNAVODO != NULL) // If RAM has been allocated for message storage
-    && (packetUBXNAVODO->callbackData != NULL) // If RAM has been allocated for the copy of the data
-    && (packetUBXNAVODO->callbackPointer != NULL) // If the pointer to the callback has been defined
-    && (packetUBXNAVODO->automaticFlags.flags.bits.callbackCopyValid == true)) // If the copy of the data is valid
-  {
-    // if (_printDebug == true)
-    //   _debugSerial->println(F("checkCallbacks: calling callback for NAV ODO"));
-    packetUBXNAVODO->callbackPointer(*packetUBXNAVODO->callbackData); // Call the callback
-    packetUBXNAVODO->automaticFlags.flags.bits.callbackCopyValid = false; // Mark the data as stale
-  }
-
-  if ((packetUBXNAVVELECEF != NULL) // If RAM has been allocated for message storage
-    && (packetUBXNAVVELECEF->callbackData != NULL) // If RAM has been allocated for the copy of the data
-    && (packetUBXNAVVELECEF->callbackPointer != NULL) // If the pointer to the callback has been defined
-    && (packetUBXNAVVELECEF->automaticFlags.flags.bits.callbackCopyValid == true)) // If the copy of the data is valid
-  {
-    // if (_printDebug == true)
-    //   _debugSerial->println(F("checkCallbacks: calling callback for NAV VELECEF"));
-    packetUBXNAVVELECEF->callbackPointer(*packetUBXNAVVELECEF->callbackData); // Call the callback
-    packetUBXNAVVELECEF->automaticFlags.flags.bits.callbackCopyValid = false; // Mark the data as stale
-  }
-
-  if ((packetUBXNAVVELNED != NULL) // If RAM has been allocated for message storage
-    && (packetUBXNAVVELNED->callbackData != NULL) // If RAM has been allocated for the copy of the data
-    && (packetUBXNAVVELNED->callbackPointer != NULL) // If the pointer to the callback has been defined
-    && (packetUBXNAVVELNED->automaticFlags.flags.bits.callbackCopyValid == true)) // If the copy of the data is valid
-  {
-    // if (_printDebug == true)
-    //   _debugSerial->println(F("checkCallbacks: calling callback for NAV VELNED"));
-    packetUBXNAVVELNED->callbackPointer(*packetUBXNAVVELNED->callbackData); // Call the callback
-    packetUBXNAVVELNED->automaticFlags.flags.bits.callbackCopyValid = false; // Mark the data as stale
-  }
-
-  if ((packetUBXNAVHPPOSECEF != NULL) // If RAM has been allocated for message storage
-    && (packetUBXNAVHPPOSECEF->callbackData != NULL) // If RAM has been allocated for the copy of the data
-    && (packetUBXNAVHPPOSECEF->callbackPointer != NULL) // If the pointer to the callback has been defined
-    && (packetUBXNAVHPPOSECEF->automaticFlags.flags.bits.callbackCopyValid == true)) // If the copy of the data is valid
-  {
-    // if (_printDebug == true)
-    //   _debugSerial->println(F("checkCallbacks: calling callback for NAV HPPOSECEF"));
-    packetUBXNAVHPPOSECEF->callbackPointer(*packetUBXNAVHPPOSECEF->callbackData); // Call the callback
-    packetUBXNAVHPPOSECEF->automaticFlags.flags.bits.callbackCopyValid = false; // Mark the data as stale
-  }
-
-  if ((packetUBXNAVHPPOSLLH != NULL) // If RAM has been allocated for message storage
-    && (packetUBXNAVHPPOSLLH->callbackData != NULL) // If RAM has been allocated for the copy of the data
-    && (packetUBXNAVHPPOSLLH->callbackPointer != NULL) // If the pointer to the callback has been defined
-    && (packetUBXNAVHPPOSLLH->automaticFlags.flags.bits.callbackCopyValid == true)) // If the copy of the data is valid
-  {
-    // if (_printDebug == true)
-    //   _debugSerial->println(F("checkCallbacks: calling callback for NAV HPPOSLLH"));
-    packetUBXNAVHPPOSLLH->callbackPointer(*packetUBXNAVHPPOSLLH->callbackData); // Call the callback
-    packetUBXNAVHPPOSLLH->automaticFlags.flags.bits.callbackCopyValid = false; // Mark the data as stale
-  }
-
-  if ((packetUBXNAVCLOCK != NULL) // If RAM has been allocated for message storage
-    && (packetUBXNAVCLOCK->callbackData != NULL) // If RAM has been allocated for the copy of the data
-    && (packetUBXNAVCLOCK->callbackPointer != NULL) // If the pointer to the callback has been defined
-    && (packetUBXNAVCLOCK->automaticFlags.flags.bits.callbackCopyValid == true)) // If the copy of the data is valid
-  {
-    // if (_printDebug == true)
-    //   _debugSerial->println(F("checkCallbacks: calling callback for NAV CLOCK"));
-    packetUBXNAVCLOCK->callbackPointer(*packetUBXNAVCLOCK->callbackData); // Call the callback
-    packetUBXNAVCLOCK->automaticFlags.flags.bits.callbackCopyValid = false; // Mark the data as stale
-  }
-
-  if ((packetUBXNAVRELPOSNED != NULL) // If RAM has been allocated for message storage
-    && (packetUBXNAVRELPOSNED->callbackData != NULL) // If RAM has been allocated for the copy of the data
-    && (packetUBXNAVRELPOSNED->callbackPointer != NULL) // If the pointer to the callback has been defined
-    && (packetUBXNAVRELPOSNED->automaticFlags.flags.bits.callbackCopyValid == true)) // If the copy of the data is valid
-  {
-    // if (_printDebug == true)
-    //   _debugSerial->println(F("checkCallbacks: calling callback for NAV RELPOSNED"));
-    packetUBXNAVRELPOSNED->callbackPointer(*packetUBXNAVRELPOSNED->callbackData); // Call the callback
-    packetUBXNAVRELPOSNED->automaticFlags.flags.bits.callbackCopyValid = false; // Mark the data as stale
-  }
-
-  if ((packetUBXRXMSFRBX != NULL) // If RAM has been allocated for message storage
-    && (packetUBXRXMSFRBX->callbackData != NULL) // If RAM has been allocated for the copy of the data
-    && (packetUBXRXMSFRBX->callbackPointer != NULL) // If the pointer to the callback has been defined
-    && (packetUBXRXMSFRBX->automaticFlags.flags.bits.callbackCopyValid == true)) // If the copy of the data is valid
-  {
-    // if (_printDebug == true)
-    //   _debugSerial->println(F("checkCallbacks: calling callback for RXM SFRBX"));
-    packetUBXRXMSFRBX->callbackPointer(*packetUBXRXMSFRBX->callbackData); // Call the callback
-    packetUBXRXMSFRBX->automaticFlags.flags.bits.callbackCopyValid = false; // Mark the data as stale
-  }
-
-  if ((packetUBXRXMRAWX != NULL) // If RAM has been allocated for message storage
-    && (packetUBXRXMRAWX->callbackData != NULL) // If RAM has been allocated for the copy of the data
-    && (packetUBXRXMRAWX->callbackPointer != NULL) // If the pointer to the callback has been defined
-    && (packetUBXRXMRAWX->automaticFlags.flags.bits.callbackCopyValid == true)) // If the copy of the data is valid
-  {
-    // if (_printDebug == true)
-    //   _debugSerial->println(F("checkCallbacks: calling callback for RXM RAWX"));
-    packetUBXRXMRAWX->callbackPointer(*packetUBXRXMRAWX->callbackData); // Call the callback
-    packetUBXRXMRAWX->automaticFlags.flags.bits.callbackCopyValid = false; // Mark the data as stale
-  }
-
-  if ((packetUBXTIMTM2 != NULL) // If RAM has been allocated for message storage
-    && (packetUBXTIMTM2->callbackData != NULL) // If RAM has been allocated for the copy of the data
-    && (packetUBXTIMTM2->callbackPointer != NULL) // If the pointer to the callback has been defined
-    && (packetUBXTIMTM2->automaticFlags.flags.bits.callbackCopyValid == true)) // If the copy of the data is valid
-  {
-    // if (_printDebug == true)
-    //   _debugSerial->println(F("checkCallbacks: calling callback for TIM TM2"));
-    packetUBXTIMTM2->callbackPointer(*packetUBXTIMTM2->callbackData); // Call the callback
-    packetUBXTIMTM2->automaticFlags.flags.bits.callbackCopyValid = false; // Mark the data as stale
-  }
-
-  if ((packetUBXESFALG != NULL) // If RAM has been allocated for message storage
-    && (packetUBXESFALG->callbackData != NULL) // If RAM has been allocated for the copy of the data
-    && (packetUBXESFALG->callbackPointer != NULL) // If the pointer to the callback has been defined
-    && (packetUBXESFALG->automaticFlags.flags.bits.callbackCopyValid == true)) // If the copy of the data is valid
-  {
-    // if (_printDebug == true)
-    //   _debugSerial->println(F("checkCallbacks: calling callback for ESF ALG"));
-    packetUBXESFALG->callbackPointer(*packetUBXESFALG->callbackData); // Call the callback
-    packetUBXESFALG->automaticFlags.flags.bits.callbackCopyValid = false; // Mark the data as stale
-  }
-
-  if ((packetUBXESFINS != NULL) // If RAM has been allocated for message storage
-    && (packetUBXESFINS->callbackData != NULL) // If RAM has been allocated for the copy of the data
-    && (packetUBXESFINS->callbackPointer != NULL) // If the pointer to the callback has been defined
-    && (packetUBXESFINS->automaticFlags.flags.bits.callbackCopyValid == true)) // If the copy of the data is valid
-  {
-    // if (_printDebug == true)
-    //   _debugSerial->println(F("checkCallbacks: calling callback for ESF INS"));
-    packetUBXESFINS->callbackPointer(*packetUBXESFINS->callbackData); // Call the callback
-    packetUBXESFINS->automaticFlags.flags.bits.callbackCopyValid = false; // Mark the data as stale
-  }
-
-  if ((packetUBXESFMEAS != NULL) // If RAM has been allocated for message storage
-    && (packetUBXESFMEAS->callbackData != NULL) // If RAM has been allocated for the copy of the data
-    && (packetUBXESFMEAS->callbackPointer != NULL) // If the pointer to the callback has been defined
-    && (packetUBXESFMEAS->automaticFlags.flags.bits.callbackCopyValid == true)) // If the copy of the data is valid
-  {
-    // if (_printDebug == true)
-    //   _debugSerial->println(F("checkCallbacks: calling callback for ESF MEAS"));
-    packetUBXESFMEAS->callbackPointer(*packetUBXESFMEAS->callbackData); // Call the callback
-    packetUBXESFMEAS->automaticFlags.flags.bits.callbackCopyValid = false; // Mark the data as stale
-  }
-
-  if ((packetUBXESFRAW != NULL) // If RAM has been allocated for message storage
-    && (packetUBXESFRAW->callbackData != NULL) // If RAM has been allocated for the copy of the data
-    && (packetUBXESFRAW->callbackPointer != NULL) // If the pointer to the callback has been defined
-    && (packetUBXESFRAW->automaticFlags.flags.bits.callbackCopyValid == true)) // If the copy of the data is valid
-  {
-    // if (_printDebug == true)
-    //   _debugSerial->println(F("checkCallbacks: calling callback for ESF RAW"));
-    packetUBXESFRAW->callbackPointer(*packetUBXESFRAW->callbackData); // Call the callback
-    packetUBXESFRAW->automaticFlags.flags.bits.callbackCopyValid = false; // Mark the data as stale
-  }
-
-  if ((packetUBXESFSTATUS != NULL) // If RAM has been allocated for message storage
-    && (packetUBXESFSTATUS->callbackData != NULL) // If RAM has been allocated for the copy of the data
-    && (packetUBXESFSTATUS->callbackPointer != NULL) // If the pointer to the callback has been defined
-    && (packetUBXESFSTATUS->automaticFlags.flags.bits.callbackCopyValid == true)) // If the copy of the data is valid
-  {
-    // if (_printDebug == true)
-    //   _debugSerial->println(F("checkCallbacks: calling callback for ESF STATUS"));
-    packetUBXESFSTATUS->callbackPointer(*packetUBXESFSTATUS->callbackData); // Call the callback
-    packetUBXESFSTATUS->automaticFlags.flags.bits.callbackCopyValid = false; // Mark the data as stale
-  }
-
-  if ((packetUBXHNRATT != NULL) // If RAM has been allocated for message storage
-    && (packetUBXHNRATT->callbackData != NULL) // If RAM has been allocated for the copy of the data
-    && (packetUBXHNRATT->callbackPointer != NULL) // If the pointer to the callback has been defined
-    && (packetUBXHNRATT->automaticFlags.flags.bits.callbackCopyValid == true)) // If the copy of the data is valid
-  {
-    // if (_printDebug == true)
-    //   _debugSerial->println(F("checkCallbacks: calling callback for HNR ATT"));
-    packetUBXHNRATT->callbackPointer(*packetUBXHNRATT->callbackData); // Call the callback
-    packetUBXHNRATT->automaticFlags.flags.bits.callbackCopyValid = false; // Mark the data as stale
-  }
-
-  if ((packetUBXHNRINS != NULL) // If RAM has been allocated for message storage
-    && (packetUBXHNRINS->callbackData != NULL) // If RAM has been allocated for the copy of the data
-    && (packetUBXHNRINS->callbackPointer != NULL) // If the pointer to the callback has been defined
-    && (packetUBXHNRINS->automaticFlags.flags.bits.callbackCopyValid == true)) // If the copy of the data is valid
-  {
-    // if (_printDebug == true)
-    //   _debugSerial->println(F("checkCallbacks: calling callback for HNR INS"));
-    packetUBXHNRINS->callbackPointer(*packetUBXHNRINS->callbackData); // Call the callback
-    packetUBXHNRINS->automaticFlags.flags.bits.callbackCopyValid = false; // Mark the data as stale
-  }
-
-  if ((packetUBXHNRPVT != NULL) // If RAM has been allocated for message storage
-    && (packetUBXHNRPVT->callbackData != NULL) // If RAM has been allocated for the copy of the data
-    && (packetUBXHNRPVT->callbackPointer != NULL) // If the pointer to the callback has been defined
-    && (packetUBXHNRPVT->automaticFlags.flags.bits.callbackCopyValid == true)) // If the copy of the data is valid
-  {
-    // if (_printDebug == true)
-    //   _debugSerial->println(F("checkCallbacks: calling callback for HNR PVT"));
-    packetUBXHNRPVT->callbackPointer(*packetUBXHNRPVT->callbackData); // Call the callback
-    packetUBXHNRPVT->automaticFlags.flags.bits.callbackCopyValid = false; // Mark the data as stale
-  }
-
-  checkCallbacksReentrant = false;
-}
-
-// Push (e.g.) RTCM data directly to the module
-// Returns true if all numDataBytes were pushed successfully
-// Warning: this function does not check that the data is valid. It is the user's responsibility to ensure the data is valid before pushing.
-boolean SFE_UBLOX_GNSS::pushRawData(uint8_t *dataBytes, size_t numDataBytes)
-{
-  if (commType == COMM_TYPE_SERIAL)
-  {
-    // Serial: write all the bytes in one go
-    size_t bytesWritten = _serialPort->write(dataBytes, numDataBytes);
-    return (bytesWritten == numDataBytes);
-  }
-  else
-  {
-    // I2C: split the data up into packets of i2cTransactionSize
-    size_t bytesLeftToWrite = numDataBytes;
-    size_t bytesWrittenTotal = 0;
-
-    while (bytesLeftToWrite > 0)
-    {
-      size_t bytesToWrite; // Limit bytesToWrite to i2cTransactionSize
-      if (bytesLeftToWrite > i2cTransactionSize)
-        bytesToWrite = i2cTransactionSize;
-      else
-        bytesToWrite = bytesLeftToWrite;
-
-      _i2cPort->beginTransmission(_gpsI2Caddress);
-      size_t bytesWritten = _i2cPort->write(dataBytes, bytesToWrite); // Write the bytes
-
-      bytesWrittenTotal += bytesWritten; // Update the totals
-      bytesLeftToWrite -= bytesToWrite;
-      dataBytes += bytesToWrite; // Point to fresh data
-
-      if (bytesLeftToWrite > 0)
-      {
-        if (_i2cPort->endTransmission(false) != 0) //Send a restart command. Do not release bus.
-          return (false);                          //Sensor did not ACK
-      }
-      else
-      {
-        if (_i2cPort->endTransmission() != 0) //We're done. Release bus.
-          return (false);                     //Sensor did not ACK
-      }
-    }
-
-    return (bytesWrittenTotal == numDataBytes);
-  }
-}
-
-// Support for data logging
-
-//Set the file buffer size. This must be called _before_ .begin
-void SFE_UBLOX_GNSS::setFileBufferSize(uint16_t bufferSize)
-{
-  fileBufferSize = bufferSize;
-}
-
-//Return the file buffer size
-uint16_t SFE_UBLOX_GNSS::getFileBufferSize(void)
-{
-  return (fileBufferSize);
-}
-
-// Extract numBytes of data from the file buffer. Copy it to destination.
-// It is the user's responsibility to ensure destination is large enough.
-// Returns the number of bytes extracted - which may be less than numBytes.
-uint16_t SFE_UBLOX_GNSS::extractFileBufferData(uint8_t *destination, uint16_t numBytes)
-{
-  // Check how many bytes are available in the buffer
-  uint16_t bytesAvailable = fileBufferSpaceUsed();
-  if (numBytes > bytesAvailable) // Limit numBytes if required
-    numBytes = bytesAvailable;
-
-  // Start copying at fileBufferTail. Wrap-around if required.
-  uint16_t bytesBeforeWrapAround = fileBufferSize - fileBufferTail; // How much space is available 'above' Tail?
-  if (bytesBeforeWrapAround > numBytes) // Will we need to wrap-around?
-  {
-    bytesBeforeWrapAround = numBytes; // We need to wrap-around
-  }
-  memcpy(destination, &ubxFileBuffer[fileBufferTail], bytesBeforeWrapAround); // Copy the data out of the buffer
-
-  // Is there any data leftover which we need to copy from the 'bottom' of the buffer?
-  uint16_t bytesLeftToCopy = numBytes - bytesBeforeWrapAround; // Calculate if there are any bytes left to copy
-  if (bytesLeftToCopy > 0) // If there are bytes left to copy
-  {
-    memcpy(&destination[bytesBeforeWrapAround], &ubxFileBuffer[0], bytesLeftToCopy); // Copy the remaining data out of the buffer
-    fileBufferTail = bytesLeftToCopy; // Update Tail. The next byte to be read will be read from here.
-  }
-  else
-  {
-    fileBufferTail += numBytes; // Only update Tail. The next byte to be read will be read from here.
-  }
-
-  return (numBytes); // Return the number of bytes extracted
-}
-
-// Returns the number of bytes available in file buffer which are waiting to be read
-uint16_t SFE_UBLOX_GNSS::fileBufferAvailable(void)
-{
-  return (fileBufferSpaceUsed());
-}
-
-// Returns the maximum number of bytes which the file buffer contained.
-// Handy for checking the buffer is large enough to handle all the incoming data.
-uint16_t SFE_UBLOX_GNSS::getMaxFileBufferAvail(void)
-{
-  return (fileBufferMaxAvail);
-}
-
-// Clear the file buffer - discard all contents
-void SFE_UBLOX_GNSS::clearFileBuffer(void)
-{
-  if (fileBufferSize == 0) // Bail if the user has not called setFileBufferSize (probably redundant)
-    return;
-  fileBufferTail = fileBufferHead;
-}
-
-// Reset fileBufferMaxAvail
-void SFE_UBLOX_GNSS::clearMaxFileBufferAvail(void)
-{
-  fileBufferMaxAvail = 0;
-}
-
-// PRIVATE: Create the file buffer. Called by .begin
-boolean SFE_UBLOX_GNSS::createFileBuffer(void)
-{
-  if (fileBufferSize == 0) // Bail if the user has not called setFileBufferSize
-  {
-    if (_printDebug == true)
-    {
-      _debugSerial->println(F("createFileBuffer: Warning. fileBufferSize is zero. Data logging is not possible."));
-    }
-    return(false);
-  }
-
-  if (ubxFileBuffer != NULL)  // Bail if RAM has already been allocated for the file buffer
-  {                           // This will happen if you call .begin more than once - without calling .end first
-    if (_printDebug == true)
-    {
-      _debugSerial->println(F("createFileBuffer: Warning. File buffer already exists. Skipping..."));
-    }
-    return(false);
-  }
-
-  ubxFileBuffer = new uint8_t[fileBufferSize]; // Allocate RAM for the buffer
-
-  if (ubxFileBuffer == NULL) // Check if the new (alloc) was successful
-  {
-    if ((_printDebug == true) || (_printLimitedDebug == true)) // This is important. Print this if doing limited debugging
-    {
-      _debugSerial->println(F("createFileBuffer: RAM alloc failed!"));
-    }
-    return(false);
-  }
-
-  if (_printDebug == true)
-  {
-    _debugSerial->print(F("createFileBuffer: fileBufferSize is: "));
-    _debugSerial->println(fileBufferSize);
-  }
-
-  fileBufferHead = 0; // Initialize head and tail
-  fileBufferTail = 0;
-
-  return (true);
-}
-
-// PRIVATE: Check how much space is available in the buffer
-uint16_t SFE_UBLOX_GNSS::fileBufferSpaceAvailable(void)
-{
-  return (fileBufferSize - fileBufferSpaceUsed());
-}
-
-// PRIVATE: Check how much space is used in the buffer
-uint16_t SFE_UBLOX_GNSS::fileBufferSpaceUsed(void)
-{
-  if (fileBufferHead >= fileBufferTail) // Check if wrap-around has occurred
-  {
-    // Wrap-around has not occurred so do a simple subtraction
-    return (fileBufferHead - fileBufferTail);
-  }
-  else
-  {
-    // Wrap-around has occurred so do a simple subtraction but add in the fileBufferSize
-    return ((uint16_t)(((uint32_t)fileBufferHead + (uint32_t)fileBufferSize) - (uint32_t)fileBufferTail));
-  }
-}
-
-// PRIVATE: Add a UBX packet to the file buffer
-boolean SFE_UBLOX_GNSS::storePacket(ubxPacket *msg)
-{
-  // First, check that the file buffer has been created
-  if ((ubxFileBuffer == NULL) || (fileBufferSize == 0))
-  {
-    if (_printDebug == true)
-    {
-      _debugSerial->println(F("storePacket: file buffer not available!"));
-    }
-    return(false);
-  }
-
-  // Now, check if there is enough space in the buffer for all of the data
-  uint16_t totalLength = msg->len + 8; // Total length. Include sync chars, class, id, length and checksum bytes
-  if (totalLength > fileBufferSpaceAvailable())
-  {
-    if ((_printDebug == true) || (_printLimitedDebug == true)) // This is important. Print this if doing limited debugging
-    {
-      _debugSerial->println(F("storePacket: insufficient space available! Data will be lost!"));
-    }
-    return(false);
-  }
-
-  //Store the two sync chars
-  uint8_t sync_chars[] = {0xB5, 0x62};
-  writeToFileBuffer(sync_chars, 2);
-
-  //Store the Class & ID
-  writeToFileBuffer(&msg->cls, 1);
-  writeToFileBuffer(&msg->id, 1);
-
-  //Store the length. Ensure length is little-endian
-  uint8_t msg_length[2];
-  msg_length[0] = msg->len & 0xFF;
-  msg_length[1] = msg->len >> 8;
-  writeToFileBuffer(msg_length, 2);
-
-  //Store the payload
-  writeToFileBuffer(msg->payload, msg->len);
-
-  //Store the checksum
-  writeToFileBuffer(&msg->checksumA, 1);
-  writeToFileBuffer(&msg->checksumB, 1);
-
-  return (true);
-}
-
-// PRIVATE: Add theBytes to the file buffer
-boolean SFE_UBLOX_GNSS::storeFileBytes(uint8_t *theBytes, uint16_t numBytes)
-{
-  // First, check that the file buffer has been created
-  if ((ubxFileBuffer == NULL) || (fileBufferSize == 0))
-  {
-    if (_printDebug == true)
-    {
-      _debugSerial->println(F("storeFileBytes: file buffer not available!"));
-    }
-    return(false);
-  }
-
-  // Now, check if there is enough space in the buffer for all of the data
-  if (numBytes > fileBufferSpaceAvailable())
-  {
-    if ((_printDebug == true) || (_printLimitedDebug == true)) // This is important. Print this if doing limited debugging
-    {
-      _debugSerial->println(F("storeFileBytes: insufficient space available! Data will be lost!"));
-    }
-    return(false);
-  }
-
-  // There is room for all the data in the buffer so copy the data into the buffer
-  writeToFileBuffer(theBytes, numBytes);
-
-  return (true);
-}
-
-// PRIVATE: Write theBytes to the file buffer
-void SFE_UBLOX_GNSS::writeToFileBuffer(uint8_t *theBytes, uint16_t numBytes)
-{
-  // Start writing at fileBufferHead. Wrap-around if required.
-  uint16_t bytesBeforeWrapAround = fileBufferSize - fileBufferHead; // How much space is available 'above' Head?
-  if (bytesBeforeWrapAround > numBytes) // Is there enough room for all the data?
-  {
-    bytesBeforeWrapAround = numBytes; // There is enough room for all the data
-  }
-  memcpy(&ubxFileBuffer[fileBufferHead], theBytes, bytesBeforeWrapAround); // Copy the data into the buffer
-
-  // Is there any data leftover which we need to copy to the 'bottom' of the buffer?
-  uint16_t bytesLeftToCopy = numBytes - bytesBeforeWrapAround; // Calculate if there are any bytes left to copy
-  if (bytesLeftToCopy > 0) // If there are bytes left to copy
-  {
-    memcpy(&ubxFileBuffer[0], &theBytes[bytesBeforeWrapAround], bytesLeftToCopy); // Copy the remaining data into the buffer
-    fileBufferHead = bytesLeftToCopy; // Update Head. The next byte written will be written here.
-  }
-  else
-  {
-    fileBufferHead += numBytes; // Only update Head. The next byte written will be written here.
-  }
-
-  //Update fileBufferMaxAvail if required
-  uint16_t bytesInBuffer = fileBufferSpaceUsed();
-  if (bytesInBuffer > fileBufferMaxAvail)
-    fileBufferMaxAvail = bytesInBuffer;
-}
-
-//=-=-=-=-=-=-=-= Specific commands =-=-=-=-=-=-=-==-=-=-=-=-=-=-=
-//=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-==-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
-
-//Loads the payloadCfg array with the current protocol bits located the UBX-CFG-PRT register for a given port
-boolean SFE_UBLOX_GNSS::getPortSettings(uint8_t portID, uint16_t maxWait)
-{
-  packetCfg.cls = UBX_CLASS_CFG;
-  packetCfg.id = UBX_CFG_PRT;
-  packetCfg.len = 1;
-  packetCfg.startingSpot = 0;
-
-  payloadCfg[0] = portID;
-
-  return ((sendCommand(&packetCfg, maxWait)) == SFE_UBLOX_STATUS_DATA_RECEIVED); // We are expecting data and an ACK
-}
-
-//Configure a given port to output UBX, NMEA, RTCM3 or a combination thereof
-//Port 0=I2c, 1=UART1, 2=UART2, 3=USB, 4=SPI
-//Bit:0 = UBX, :1=NMEA, :5=RTCM3
-boolean SFE_UBLOX_GNSS::setPortOutput(uint8_t portID, uint8_t outStreamSettings, uint16_t maxWait)
-{
-  //Get the current config values for this port ID
-  if (getPortSettings(portID, maxWait) == false)
-    return (false); //Something went wrong. Bail.
-
-  packetCfg.cls = UBX_CLASS_CFG;
-  packetCfg.id = UBX_CFG_PRT;
-  packetCfg.len = 20;
-  packetCfg.startingSpot = 0;
-
-  //payloadCfg is now loaded with current bytes. Change only the ones we need to
-  payloadCfg[14] = outStreamSettings; //OutProtocolMask LSB - Set outStream bits
-
-  return ((sendCommand(&packetCfg, maxWait)) == SFE_UBLOX_STATUS_DATA_SENT); // We are only expecting an ACK
-}
-
-//Configure a given port to input UBX, NMEA, RTCM3 or a combination thereof
-//Port 0=I2c, 1=UART1, 2=UART2, 3=USB, 4=SPI
-//Bit:0 = UBX, :1=NMEA, :5=RTCM3
-boolean SFE_UBLOX_GNSS::setPortInput(uint8_t portID, uint8_t inStreamSettings, uint16_t maxWait)
-{
-  //Get the current config values for this port ID
-  //This will load the payloadCfg array with current port settings
-  if (getPortSettings(portID, maxWait) == false)
-    return (false); //Something went wrong. Bail.
-
-  packetCfg.cls = UBX_CLASS_CFG;
-  packetCfg.id = UBX_CFG_PRT;
-  packetCfg.len = 20;
-  packetCfg.startingSpot = 0;
-
-  //payloadCfg is now loaded with current bytes. Change only the ones we need to
-  payloadCfg[12] = inStreamSettings; //InProtocolMask LSB - Set inStream bits
-
-  return ((sendCommand(&packetCfg, maxWait)) == SFE_UBLOX_STATUS_DATA_SENT); // We are only expecting an ACK
-}
-
-//Changes the I2C address that the u-blox module responds to
-//0x42 is the default but can be changed with this command
-boolean SFE_UBLOX_GNSS::setI2CAddress(uint8_t deviceAddress, uint16_t maxWait)
-{
-  //Get the current config values for the I2C port
-  //This will load the payloadCfg array with current port settings
-  if (getPortSettings(COM_PORT_I2C, maxWait) == false)
-    return (false); //Something went wrong. Bail.
-
-  packetCfg.cls = UBX_CLASS_CFG;
-  packetCfg.id = UBX_CFG_PRT;
-  packetCfg.len = 20;
-  packetCfg.startingSpot = 0;
-
-  //payloadCfg is now loaded with current bytes. Change only the ones we need to
-  payloadCfg[4] = deviceAddress << 1; //DDC mode LSB
-
-  if (sendCommand(&packetCfg, maxWait) == SFE_UBLOX_STATUS_DATA_SENT) // We are only expecting an ACK
-  {
-    //Success! Now change our internal global.
-    _gpsI2Caddress = deviceAddress; //Store the I2C address from user
-    return (true);
-  }
-  return (false);
-}
-
-//Changes the serial baud rate of the u-blox module, can't return success/fail 'cause ACK from modem
-//is lost due to baud rate change
-void SFE_UBLOX_GNSS::setSerialRate(uint32_t baudrate, uint8_t uartPort, uint16_t maxWait)
-{
-  //Get the current config values for the UART port
-  //This will load the payloadCfg array with current port settings
-  if (getPortSettings(uartPort, maxWait) == false)
-    return; //Something went wrong. Bail.
-
-  if (_printDebug == true)
-  {
-    _debugSerial->print(F("Current baud rate: "));
-    _debugSerial->println(((uint32_t)payloadCfg[10] << 16) | ((uint32_t)payloadCfg[9] << 8) | payloadCfg[8]);
-  }
-
-  packetCfg.cls = UBX_CLASS_CFG;
-  packetCfg.id = UBX_CFG_PRT;
-  packetCfg.len = 20;
-  packetCfg.startingSpot = 0;
-
-  //payloadCfg is now loaded with current bytes. Change only the ones we need to
-  payloadCfg[8] = baudrate;
-  payloadCfg[9] = baudrate >> 8;
-  payloadCfg[10] = baudrate >> 16;
-  payloadCfg[11] = baudrate >> 24;
-
-  if (_printDebug == true)
-  {
-    _debugSerial->print(F("New baud rate:"));
-    _debugSerial->println(((uint32_t)payloadCfg[10] << 16) | ((uint32_t)payloadCfg[9] << 8) | payloadCfg[8]);
-  }
-
-  sfe_ublox_status_e retVal = sendCommand(&packetCfg, maxWait);
-  if (_printDebug == true)
-  {
-    _debugSerial->print(F("setSerialRate: sendCommand returned: "));
-    _debugSerial->println(statusString(retVal));
-  }
-}
-
-//Configure a port to output UBX, NMEA, RTCM3 or a combination thereof
-boolean SFE_UBLOX_GNSS::setI2COutput(uint8_t comSettings, uint16_t maxWait)
-{
-  return (setPortOutput(COM_PORT_I2C, comSettings, maxWait));
-}
-boolean SFE_UBLOX_GNSS::setUART1Output(uint8_t comSettings, uint16_t maxWait)
-{
-  return (setPortOutput(COM_PORT_UART1, comSettings, maxWait));
-}
-boolean SFE_UBLOX_GNSS::setUART2Output(uint8_t comSettings, uint16_t maxWait)
-{
-  return (setPortOutput(COM_PORT_UART2, comSettings, maxWait));
-}
-boolean SFE_UBLOX_GNSS::setUSBOutput(uint8_t comSettings, uint16_t maxWait)
-{
-  return (setPortOutput(COM_PORT_USB, comSettings, maxWait));
-}
-boolean SFE_UBLOX_GNSS::setSPIOutput(uint8_t comSettings, uint16_t maxWait)
-{
-  return (setPortOutput(COM_PORT_SPI, comSettings, maxWait));
-}
-
-//Want to see the NMEA messages on the Serial port? Here's how
-void SFE_UBLOX_GNSS::setNMEAOutputPort(Stream &nmeaOutputPort)
-{
-  _nmeaOutputPort = &nmeaOutputPort; //Store the port from user
-}
-
-// Reset to defaults
-
-void SFE_UBLOX_GNSS::factoryReset()
-{
-  // Copy default settings to permanent
-  // Note: this does not load the permanent configuration into the current configuration. Calling factoryDefault() will do that.
-  packetCfg.cls = UBX_CLASS_CFG;
-  packetCfg.id = UBX_CFG_CFG;
-  packetCfg.len = 13;
-  packetCfg.startingSpot = 0;
-  for (uint8_t i = 0; i < 4; i++)
-  {
-    payloadCfg[0 + i] = 0xff; // clear mask: copy default config to permanent config
-    payloadCfg[4 + i] = 0x00; // save mask: don't save current to permanent
-    payloadCfg[8 + i] = 0x00; // load mask: don't copy permanent config to current
-  }
-  payloadCfg[12] = 0xff;      // all forms of permanent memory
-  sendCommand(&packetCfg, 0); // don't expect ACK
-  hardReset();                // cause factory default config to actually be loaded and used cleanly
-}
-
-void SFE_UBLOX_GNSS::hardReset()
-{
-  // Issue hard reset
-  packetCfg.cls = UBX_CLASS_CFG;
-  packetCfg.id = UBX_CFG_RST;
-  packetCfg.len = 4;
-  packetCfg.startingSpot = 0;
-  payloadCfg[0] = 0xff;       // cold start
-  payloadCfg[1] = 0xff;       // cold start
-  payloadCfg[2] = 0;          // 0=HW reset
-  payloadCfg[3] = 0;          // reserved
-  sendCommand(&packetCfg, 0); // don't expect ACK
-}
-
-//Reset module to factory defaults
-//This still works but it is the old way of configuring ublox modules. See getVal and setVal for the new methods
-boolean SFE_UBLOX_GNSS::factoryDefault(uint16_t maxWait)
-{
-  packetCfg.cls = UBX_CLASS_CFG;
-  packetCfg.id = UBX_CFG_CFG;
-  packetCfg.len = 12;
-  packetCfg.startingSpot = 0;
-
-  //Clear packet payload
-  memset(payloadCfg, 0, packetCfg.len);
-
-  packetCfg.payload[0] = 0xFF; //Set any bit in the clearMask field to clear saved config
-  packetCfg.payload[1] = 0xFF;
-  packetCfg.payload[8] = 0xFF; //Set any bit in the loadMask field to discard current config and rebuild from lower non-volatile memory layers
-  packetCfg.payload[9] = 0xFF;
-
-  return (sendCommand(&packetCfg, maxWait) == SFE_UBLOX_STATUS_DATA_SENT); // We are only expecting an ACK
-}
-
-//Save configuration to BBR / Flash
-
-//Save current configuration to flash and BBR (battery backed RAM)
-//This still works but it is the old way of configuring ublox modules. See getVal and setVal for the new methods
-boolean SFE_UBLOX_GNSS::saveConfiguration(uint16_t maxWait)
-{
-  packetCfg.cls = UBX_CLASS_CFG;
-  packetCfg.id = UBX_CFG_CFG;
-  packetCfg.len = 12;
-  packetCfg.startingSpot = 0;
-
-  //Clear packet payload
-  memset(payloadCfg, 0, packetCfg.len);
-
-  packetCfg.payload[4] = 0xFF; //Set any bit in the saveMask field to save current config to Flash and BBR
-  packetCfg.payload[5] = 0xFF;
-
-  return (sendCommand(&packetCfg, maxWait) == SFE_UBLOX_STATUS_DATA_SENT); // We are only expecting an ACK
-}
-
-//Save the selected configuration sub-sections to flash and BBR (battery backed RAM)
-//This still works but it is the old way of configuring ublox modules. See getVal and setVal for the new methods
-boolean SFE_UBLOX_GNSS::saveConfigSelective(uint32_t configMask, uint16_t maxWait)
-{
-  packetCfg.cls = UBX_CLASS_CFG;
-  packetCfg.id = UBX_CFG_CFG;
-  packetCfg.len = 12;
-  packetCfg.startingSpot = 0;
-
-  //Clear packet payload
-  memset(payloadCfg, 0, packetCfg.len);
-
-  packetCfg.payload[4] = configMask & 0xFF; //Set the appropriate bits in the saveMask field to save current config to Flash and BBR
-  packetCfg.payload[5] = (configMask >> 8) & 0xFF;
-  packetCfg.payload[6] = (configMask >> 16) & 0xFF;
-  packetCfg.payload[7] = (configMask >> 24) & 0xFF;
-
-  return (sendCommand(&packetCfg, maxWait) == SFE_UBLOX_STATUS_DATA_SENT); // We are only expecting an ACK
-}
-
-//Configure a given message type for a given port (UART1, I2C, SPI, etc)
-boolean SFE_UBLOX_GNSS::configureMessage(uint8_t msgClass, uint8_t msgID, uint8_t portID, uint8_t sendRate, uint16_t maxWait)
-{
-  //Poll for the current settings for a given message
-  packetCfg.cls = UBX_CLASS_CFG;
-  packetCfg.id = UBX_CFG_MSG;
-  packetCfg.len = 2;
-  packetCfg.startingSpot = 0;
-
-  payloadCfg[0] = msgClass;
-  payloadCfg[1] = msgID;
-
-  //This will load the payloadCfg array with current settings of the given register
-  if (sendCommand(&packetCfg, maxWait) != SFE_UBLOX_STATUS_DATA_RECEIVED) // We are expecting data and an ACK
-    return (false);                                                       //If command send fails then bail
-
-  //Now send it back with new mods
-  packetCfg.len = 8;
-
-  //payloadCfg is now loaded with current bytes. Change only the ones we need to
-  payloadCfg[2 + portID] = sendRate; //Send rate is relative to the event a message is registered on. For example, if the rate of a navigation message is set to 2, the message is sent every 2nd navigation solution.
-
-  return ((sendCommand(&packetCfg, maxWait)) == SFE_UBLOX_STATUS_DATA_SENT); // We are only expecting an ACK
-}
-
-//Enable a given message type, default of 1 per update rate (usually 1 per second)
-boolean SFE_UBLOX_GNSS::enableMessage(uint8_t msgClass, uint8_t msgID, uint8_t portID, uint8_t rate, uint16_t maxWait)
-{
-  return (configureMessage(msgClass, msgID, portID, rate, maxWait));
-}
-//Disable a given message type on a given port
-boolean SFE_UBLOX_GNSS::disableMessage(uint8_t msgClass, uint8_t msgID, uint8_t portID, uint16_t maxWait)
-{
-  return (configureMessage(msgClass, msgID, portID, 0, maxWait));
-}
-
-boolean SFE_UBLOX_GNSS::enableNMEAMessage(uint8_t msgID, uint8_t portID, uint8_t rate, uint16_t maxWait)
-{
-  return (configureMessage(UBX_CLASS_NMEA, msgID, portID, rate, maxWait));
-}
-boolean SFE_UBLOX_GNSS::disableNMEAMessage(uint8_t msgID, uint8_t portID, uint16_t maxWait)
-{
-  return (enableNMEAMessage(msgID, portID, 0, maxWait));
-}
-
-//Given a message number turns on a message ID for output over a given portID (UART, I2C, SPI, USB, etc)
-//To disable a message, set secondsBetween messages to 0
-//Note: This function will return false if the message is already enabled
-//For base station RTK output we need to enable various sentences
-
-//NEO-M8P has four:
-//1005 = 0xF5 0x05 - Stationary RTK reference ARP
-//1077 = 0xF5 0x4D - GPS MSM7
-//1087 = 0xF5 0x57 - GLONASS MSM7
-//1230 = 0xF5 0xE6 - GLONASS code-phase biases, set to once every 10 seconds
-
-//ZED-F9P has six:
-//1005, 1074, 1084, 1094, 1124, 1230
-
-//Much of this configuration is not documented and instead discerned from u-center binary console
-boolean SFE_UBLOX_GNSS::enableRTCMmessage(uint8_t messageNumber, uint8_t portID, uint8_t sendRate, uint16_t maxWait)
-{
-  return (configureMessage(UBX_RTCM_MSB, messageNumber, portID, sendRate, maxWait));
-}
-
-//Disable a given message on a given port by setting secondsBetweenMessages to zero
-boolean SFE_UBLOX_GNSS::disableRTCMmessage(uint8_t messageNumber, uint8_t portID, uint16_t maxWait)
-{
-  return (enableRTCMmessage(messageNumber, portID, 0, maxWait));
-}
-
-//Functions used for RTK and base station setup
-
-//Get the current TimeMode3 settings - these contain survey in statuses
-boolean SFE_UBLOX_GNSS::getSurveyMode(uint16_t maxWait)
-{
-  packetCfg.cls = UBX_CLASS_CFG;
-  packetCfg.id = UBX_CFG_TMODE3;
-  packetCfg.len = 0;
-  packetCfg.startingSpot = 0;
-
-  return ((sendCommand(&packetCfg, maxWait)) == SFE_UBLOX_STATUS_DATA_RECEIVED); // We are expecting data and an ACK
-}
-
-//Control Survey-In for NEO-M8P
-boolean SFE_UBLOX_GNSS::setSurveyMode(uint8_t mode, uint16_t observationTime, float requiredAccuracy, uint16_t maxWait)
-{
-  if (getSurveyMode(maxWait) == false) //Ask module for the current TimeMode3 settings. Loads into payloadCfg.
-    return (false);
-
-  packetCfg.cls = UBX_CLASS_CFG;
-  packetCfg.id = UBX_CFG_TMODE3;
-  packetCfg.len = 40;
-  packetCfg.startingSpot = 0;
-
-  //payloadCfg should be loaded with poll response. Now modify only the bits we care about
-  payloadCfg[2] = mode; //Set mode. Survey-In and Disabled are most common. Use ECEF (not LAT/LON/ALT).
-
-  //svinMinDur is U4 (uint32_t) but we'll only use a uint16_t (waiting more than 65535 seconds seems excessive!)
-  payloadCfg[24] = observationTime & 0xFF; //svinMinDur in seconds
-  payloadCfg[25] = observationTime >> 8;   //svinMinDur in seconds
-  payloadCfg[26] = 0;                      //Truncate to 16 bits
-  payloadCfg[27] = 0;                      //Truncate to 16 bits
-
-  //svinAccLimit is U4 (uint32_t) in 0.1mm.
-  uint32_t svinAccLimit = (uint32_t)(requiredAccuracy * 10000.0); //Convert m to 0.1mm
-  payloadCfg[28] = svinAccLimit & 0xFF;                           //svinAccLimit in 0.1mm increments
-  payloadCfg[29] = svinAccLimit >> 8;
-  payloadCfg[30] = svinAccLimit >> 16;
-  payloadCfg[31] = svinAccLimit >> 24;
-
-  return ((sendCommand(&packetCfg, maxWait)) == SFE_UBLOX_STATUS_DATA_SENT); // We are only expecting an ACK
-}
-
-//Begin Survey-In for NEO-M8P
-boolean SFE_UBLOX_GNSS::enableSurveyMode(uint16_t observationTime, float requiredAccuracy, uint16_t maxWait)
-{
-  return (setSurveyMode(SVIN_MODE_ENABLE, observationTime, requiredAccuracy, maxWait));
-}
-
-//Stop Survey-In for NEO-M8P
-boolean SFE_UBLOX_GNSS::disableSurveyMode(uint16_t maxWait)
-{
-  return (setSurveyMode(SVIN_MODE_DISABLE, 0, 0, maxWait));
-}
-
-//Set the ECEF or Lat/Long coordinates of a receiver
-//This imediately puts the receiver in TIME mode (fixed) and will begin outputting RTCM sentences if enabled
-//This is helpful once an antenna's position has been established. See this tutorial: https://learn.sparkfun.com/tutorials/how-to-build-a-diy-gnss-reference-station#gather-raw-gnss-data
-// For ECEF the units are: cm, 0.1mm, cm, 0.1mm, cm, 0.1mm
-// For Lat/Lon/Alt the units are: degrees^-7, degrees^-9, degrees^-7, degrees^-9, cm, 0.1mm
-bool SFE_UBLOX_GNSS::setStaticPosition(int32_t ecefXOrLat, int8_t ecefXOrLatHP, int32_t ecefYOrLon, int8_t ecefYOrLonHP, int32_t ecefZOrAlt, int8_t ecefZOrAltHP, bool latLong, uint16_t maxWait)
-{
-  packetCfg.cls = UBX_CLASS_CFG;
-  packetCfg.id = UBX_CFG_TMODE3;
-  packetCfg.len = 0;
-  packetCfg.startingSpot = 0;
-
-  //Ask module for the current TimeMode3 settings. Loads into payloadCfg.
-  if (sendCommand(&packetCfg, maxWait) != SFE_UBLOX_STATUS_DATA_RECEIVED)
-    return (false);
-
-  packetCfg.len = 40;
-
-  //customCfg should be loaded with poll response. Now modify only the bits we care about
-  payloadCfg[2] = 2; //Set mode to fixed. Use ECEF (not LAT/LON/ALT).
-
-  if (latLong == true)
-    payloadCfg[3] = (uint8_t)(1 << 0); //Set mode to fixed. Use LAT/LON/ALT.
-
-  //Set ECEF X or Lat
-  payloadCfg[4] = (ecefXOrLat >> 8 * 0) & 0xFF; //LSB
-  payloadCfg[5] = (ecefXOrLat >> 8 * 1) & 0xFF;
-  payloadCfg[6] = (ecefXOrLat >> 8 * 2) & 0xFF;
-  payloadCfg[7] = (ecefXOrLat >> 8 * 3) & 0xFF; //MSB
-
-  //Set ECEF Y or Long
-  payloadCfg[8] = (ecefYOrLon >> 8 * 0) & 0xFF; //LSB
-  payloadCfg[9] = (ecefYOrLon >> 8 * 1) & 0xFF;
-  payloadCfg[10] = (ecefYOrLon >> 8 * 2) & 0xFF;
-  payloadCfg[11] = (ecefYOrLon >> 8 * 3) & 0xFF; //MSB
-
-  //Set ECEF Z or Altitude
-  payloadCfg[12] = (ecefZOrAlt >> 8 * 0) & 0xFF; //LSB
-  payloadCfg[13] = (ecefZOrAlt >> 8 * 1) & 0xFF;
-  payloadCfg[14] = (ecefZOrAlt >> 8 * 2) & 0xFF;
-  payloadCfg[15] = (ecefZOrAlt >> 8 * 3) & 0xFF; //MSB
-
-  //Set high precision parts
-  payloadCfg[16] = ecefXOrLatHP;
-  payloadCfg[17] = ecefYOrLonHP;
-  payloadCfg[18] = ecefZOrAltHP;
-
-  return ((sendCommand(&packetCfg, maxWait)) == SFE_UBLOX_STATUS_DATA_SENT); // We are only expecting an ACK
-}
-
-bool SFE_UBLOX_GNSS::setStaticPosition(int32_t ecefXOrLat, int32_t ecefYOrLon, int32_t ecefZOrAlt, bool latlong, uint16_t maxWait)
-{
-  return (setStaticPosition(ecefXOrLat, 0, ecefYOrLon, 0, ecefZOrAlt, 0, latlong, maxWait));
-}
-
-// Module Protocol Version
-
-//Get the current protocol version of the u-blox module we're communicating with
-//This is helpful when deciding if we should call the high-precision Lat/Long (HPPOSLLH) or the regular (POSLLH)
-uint8_t SFE_UBLOX_GNSS::getProtocolVersionHigh(uint16_t maxWait)
-{
-  if (moduleSWVersion == NULL) initModuleSWVersion(); //Check that RAM has been allocated for the SW version
-  if (moduleSWVersion == NULL) //Bail if the RAM allocation failed
-    return (false);
-
-  if (moduleSWVersion->moduleQueried == false)
-    getProtocolVersion(maxWait);
-  return (moduleSWVersion->versionHigh);
-}
-
-//Get the current protocol version of the u-blox module we're communicating with
-//This is helpful when deciding if we should call the high-precision Lat/Long (HPPOSLLH) or the regular (POSLLH)
-uint8_t SFE_UBLOX_GNSS::getProtocolVersionLow(uint16_t maxWait)
-{
-  if (moduleSWVersion == NULL) initModuleSWVersion(); //Check that RAM has been allocated for the SW version
-  if (moduleSWVersion == NULL) //Bail if the RAM allocation failed
-    return (false);
-
-  if (moduleSWVersion->moduleQueried == false)
-    getProtocolVersion(maxWait);
-  return (moduleSWVersion->versionLow);
-}
-
-//Get the current protocol version of the u-blox module we're communicating with
-//This is helpful when deciding if we should call the high-precision Lat/Long (HPPOSLLH) or the regular (POSLLH)
-boolean SFE_UBLOX_GNSS::getProtocolVersion(uint16_t maxWait)
-{
-  if (moduleSWVersion == NULL) initModuleSWVersion(); //Check that RAM has been allocated for the SW version
-  if (moduleSWVersion == NULL) //Bail if the RAM allocation failed
-    return (false);
-
-  //Send packet with only CLS and ID, length of zero. This will cause the module to respond with the contents of that CLS/ID.
-  packetCfg.cls = UBX_CLASS_MON;
-  packetCfg.id = UBX_MON_VER;
-
-  packetCfg.len = 0;
-  packetCfg.startingSpot = 40; //Start at first "extended software information" string
-
-  if (sendCommand(&packetCfg, maxWait) != SFE_UBLOX_STATUS_DATA_RECEIVED) // We are only expecting data (no ACK)
-    return (false);                                                       //If command send fails then bail
-
-  //Payload should now contain ~220 characters (depends on module type)
-
-  // if (_printDebug == true)
-  // {
-  //   _debugSerial->print(F("MON VER Payload:"));
-  //   for (int location = 0; location < packetCfg.len; location++)
-  //   {
-  //     if (location % 30 == 0)
-  //       _debugSerial->println();
-  //     _debugSerial->write(payloadCfg[location]);
-  //   }
-  //   _debugSerial->println();
-  // }
-
-  //We will step through the payload looking at each extension field of 30 bytes
-  for (uint8_t extensionNumber = 0; extensionNumber < 10; extensionNumber++)
-  {
-    //Now we need to find "PROTVER=18.00" in the incoming byte stream
-    if ((payloadCfg[(30 * extensionNumber) + 0] == 'P') && (payloadCfg[(30 * extensionNumber) + 6] == 'R'))
-    {
-      moduleSWVersion->versionHigh = (payloadCfg[(30 * extensionNumber) + 8] - '0') * 10 + (payloadCfg[(30 * extensionNumber) + 9] - '0');  //Convert '18' to 18
-      moduleSWVersion->versionLow = (payloadCfg[(30 * extensionNumber) + 11] - '0') * 10 + (payloadCfg[(30 * extensionNumber) + 12] - '0'); //Convert '00' to 00
-      moduleSWVersion->moduleQueried = true; // Mark this data as new
-
-      if (_printDebug == true)
-      {
-        _debugSerial->print(F("Protocol version: "));
-        _debugSerial->print(moduleSWVersion->versionHigh);
-        _debugSerial->print(F("."));
-        _debugSerial->println(moduleSWVersion->versionLow);
-      }
-      return (true); //Success!
-    }
-  }
-
-  return (false); //We failed
-}
-
-// PRIVATE: Allocate RAM for moduleSWVersion and initialize it
-boolean SFE_UBLOX_GNSS::initModuleSWVersion()
-{
-  moduleSWVersion = new moduleSWVersion_t; //Allocate RAM for the main struct
-  if (moduleSWVersion == NULL)
-  {
-    if ((_printDebug == true) || (_printLimitedDebug == true)) // This is important. Print this if doing limited debugging
-      _debugSerial->println(F("initModuleSWVersion: PANIC! RAM allocation failed!"));
-    return (false);
-  }
-  moduleSWVersion->versionHigh = 0;
-  moduleSWVersion->versionLow = 0;
-  moduleSWVersion->moduleQueried = false;
-  return (true);
-}
-
-// Geofences
-
-//Add a new geofence using UBX-CFG-GEOFENCE
-boolean SFE_UBLOX_GNSS::addGeofence(int32_t latitude, int32_t longitude, uint32_t radius, byte confidence, byte pinPolarity, byte pin, uint16_t maxWait)
-{
-  if (currentGeofenceParams == NULL) initGeofenceParams(); // Check if RAM has been allocated for currentGeofenceParams
-  if (currentGeofenceParams == NULL) // Abort if the RAM allocation failed
-    return (false);
-
-  if (currentGeofenceParams->numFences >= 4)
-    return (false); // Quit if we already have four geofences defined
-
-  // Store the new geofence parameters
-  currentGeofenceParams->lats[currentGeofenceParams->numFences] = latitude;
-  currentGeofenceParams->longs[currentGeofenceParams->numFences] = longitude;
-  currentGeofenceParams->rads[currentGeofenceParams->numFences] = radius;
-  currentGeofenceParams->numFences = currentGeofenceParams->numFences + 1; // Increment the number of fences
-
-  packetCfg.cls = UBX_CLASS_CFG;
-  packetCfg.id = UBX_CFG_GEOFENCE;
-  packetCfg.len = (currentGeofenceParams->numFences * 12) + 8;
-  packetCfg.startingSpot = 0;
-
-  payloadCfg[0] = 0;                               // Message version = 0x00
-  payloadCfg[1] = currentGeofenceParams->numFences; // numFences
-  payloadCfg[2] = confidence;                      // confLvl = Confidence level 0-4 (none, 68%, 95%, 99.7%, 99.99%)
-  payloadCfg[3] = 0;                               // reserved1
-  if (pin > 0)
-  {
-    payloadCfg[4] = 1; // enable PIO combined fence state
-  }
-  else
-  {
-    payloadCfg[4] = 0; // disable PIO combined fence state
-  }
-  payloadCfg[5] = pinPolarity; // PIO pin polarity (0 = low means inside, 1 = low means outside (or unknown))
-  payloadCfg[6] = pin;         // PIO pin
-  payloadCfg[7] = 0;           //reserved2
-  payloadCfg[8] = currentGeofenceParams->lats[0] & 0xFF;
-  payloadCfg[9] = currentGeofenceParams->lats[0] >> 8;
-  payloadCfg[10] = currentGeofenceParams->lats[0] >> 16;
-  payloadCfg[11] = currentGeofenceParams->lats[0] >> 24;
-  payloadCfg[12] = currentGeofenceParams->longs[0] & 0xFF;
-  payloadCfg[13] = currentGeofenceParams->longs[0] >> 8;
-  payloadCfg[14] = currentGeofenceParams->longs[0] >> 16;
-  payloadCfg[15] = currentGeofenceParams->longs[0] >> 24;
-  payloadCfg[16] = currentGeofenceParams->rads[0] & 0xFF;
-  payloadCfg[17] = currentGeofenceParams->rads[0] >> 8;
-  payloadCfg[18] = currentGeofenceParams->rads[0] >> 16;
-  payloadCfg[19] = currentGeofenceParams->rads[0] >> 24;
-  if (currentGeofenceParams->numFences >= 2)
-  {
-    payloadCfg[20] = currentGeofenceParams->lats[1] & 0xFF;
-    payloadCfg[21] = currentGeofenceParams->lats[1] >> 8;
-    payloadCfg[22] = currentGeofenceParams->lats[1] >> 16;
-    payloadCfg[23] = currentGeofenceParams->lats[1] >> 24;
-    payloadCfg[24] = currentGeofenceParams->longs[1] & 0xFF;
-    payloadCfg[25] = currentGeofenceParams->longs[1] >> 8;
-    payloadCfg[26] = currentGeofenceParams->longs[1] >> 16;
-    payloadCfg[27] = currentGeofenceParams->longs[1] >> 24;
-    payloadCfg[28] = currentGeofenceParams->rads[1] & 0xFF;
-    payloadCfg[29] = currentGeofenceParams->rads[1] >> 8;
-    payloadCfg[30] = currentGeofenceParams->rads[1] >> 16;
-    payloadCfg[31] = currentGeofenceParams->rads[1] >> 24;
-  }
-  if (currentGeofenceParams->numFences >= 3)
-  {
-    payloadCfg[32] = currentGeofenceParams->lats[2] & 0xFF;
-    payloadCfg[33] = currentGeofenceParams->lats[2] >> 8;
-    payloadCfg[34] = currentGeofenceParams->lats[2] >> 16;
-    payloadCfg[35] = currentGeofenceParams->lats[2] >> 24;
-    payloadCfg[36] = currentGeofenceParams->longs[2] & 0xFF;
-    payloadCfg[37] = currentGeofenceParams->longs[2] >> 8;
-    payloadCfg[38] = currentGeofenceParams->longs[2] >> 16;
-    payloadCfg[39] = currentGeofenceParams->longs[2] >> 24;
-    payloadCfg[40] = currentGeofenceParams->rads[2] & 0xFF;
-    payloadCfg[41] = currentGeofenceParams->rads[2] >> 8;
-    payloadCfg[42] = currentGeofenceParams->rads[2] >> 16;
-    payloadCfg[43] = currentGeofenceParams->rads[2] >> 24;
-  }
-  if (currentGeofenceParams->numFences >= 4)
-  {
-    payloadCfg[44] = currentGeofenceParams->lats[3] & 0xFF;
-    payloadCfg[45] = currentGeofenceParams->lats[3] >> 8;
-    payloadCfg[46] = currentGeofenceParams->lats[3] >> 16;
-    payloadCfg[47] = currentGeofenceParams->lats[3] >> 24;
-    payloadCfg[48] = currentGeofenceParams->longs[3] & 0xFF;
-    payloadCfg[49] = currentGeofenceParams->longs[3] >> 8;
-    payloadCfg[50] = currentGeofenceParams->longs[3] >> 16;
-    payloadCfg[51] = currentGeofenceParams->longs[3] >> 24;
-    payloadCfg[52] = currentGeofenceParams->rads[3] & 0xFF;
-    payloadCfg[53] = currentGeofenceParams->rads[3] >> 8;
-    payloadCfg[54] = currentGeofenceParams->rads[3] >> 16;
-    payloadCfg[55] = currentGeofenceParams->rads[3] >> 24;
-  }
-  return ((sendCommand(&packetCfg, maxWait)) == SFE_UBLOX_STATUS_DATA_SENT); // We are only expecting an ACK
-}
-
-//Clear all geofences using UBX-CFG-GEOFENCE
-boolean SFE_UBLOX_GNSS::clearGeofences(uint16_t maxWait)
-{
-  if (currentGeofenceParams == NULL) initGeofenceParams(); // Check if RAM has been allocated for currentGeofenceParams
-  if (currentGeofenceParams == NULL) // Abort if the RAM allocation failed
-    return (false);
-
-  packetCfg.cls = UBX_CLASS_CFG;
-  packetCfg.id = UBX_CFG_GEOFENCE;
-  packetCfg.len = 8;
-  packetCfg.startingSpot = 0;
-
-  payloadCfg[0] = 0; // Message version = 0x00
-  payloadCfg[1] = 0; // numFences
-  payloadCfg[2] = 0; // confLvl
-  payloadCfg[3] = 0; // reserved1
-  payloadCfg[4] = 0; // disable PIO combined fence state
-  payloadCfg[5] = 0; // PIO pin polarity (0 = low means inside, 1 = low means outside (or unknown))
-  payloadCfg[6] = 0; // PIO pin
-  payloadCfg[7] = 0; //reserved2
-
-  currentGeofenceParams->numFences = 0; // Zero the number of geofences currently in use
-
-  return ((sendCommand(&packetCfg, maxWait)) == SFE_UBLOX_STATUS_DATA_SENT); // We are only expecting an ACK
-}
-
-//Clear the antenna control settings using UBX-CFG-ANT
-//This function is hopefully redundant but may be needed to release
-//any PIO pins pre-allocated for antenna functions
-boolean SFE_UBLOX_GNSS::clearAntPIO(uint16_t maxWait)
-{
-  packetCfg.cls = UBX_CLASS_CFG;
-  packetCfg.id = UBX_CFG_ANT;
-  packetCfg.len = 4;
-  packetCfg.startingSpot = 0;
-
-  payloadCfg[0] = 0x10; // Antenna flag mask: set the recovery bit
-  payloadCfg[1] = 0;
-  payloadCfg[2] = 0xFF; // Antenna pin configuration: set pinSwitch and pinSCD to 31
-  payloadCfg[3] = 0xFF; // Antenna pin configuration: set pinOCD to 31, set reconfig bit
-
-  return ((sendCommand(&packetCfg, maxWait)) == SFE_UBLOX_STATUS_DATA_SENT); // We are only expecting an ACK
-}
-
-//Returns the combined geofence state using UBX-NAV-GEOFENCE
-boolean SFE_UBLOX_GNSS::getGeofenceState(geofenceState &currentGeofenceState, uint16_t maxWait)
-{
-  packetCfg.cls = UBX_CLASS_NAV;
-  packetCfg.id = UBX_NAV_GEOFENCE;
-  packetCfg.len = 0;
-  packetCfg.startingSpot = 0;
-
-  //Ask module for the geofence status. Loads into payloadCfg.
-  if (sendCommand(&packetCfg, maxWait) != SFE_UBLOX_STATUS_DATA_RECEIVED) // We are expecting data and an ACK
-    return (false);
-
-  currentGeofenceState.status = payloadCfg[5];    // Extract the status
-  currentGeofenceState.numFences = payloadCfg[6]; // Extract the number of geofences
-  currentGeofenceState.combState = payloadCfg[7]; // Extract the combined state of all geofences
-  if (currentGeofenceState.numFences > 0)
-    currentGeofenceState.states[0] = payloadCfg[8]; // Extract geofence 1 state
-  if (currentGeofenceState.numFences > 1)
-    currentGeofenceState.states[1] = payloadCfg[10]; // Extract geofence 2 state
-  if (currentGeofenceState.numFences > 2)
-    currentGeofenceState.states[2] = payloadCfg[12]; // Extract geofence 3 state
-  if (currentGeofenceState.numFences > 3)
-    currentGeofenceState.states[3] = payloadCfg[14]; // Extract geofence 4 state
-
-  return (true);
-}
-
-// PRIVATE: Allocate RAM for currentGeofenceParams and initialize it
-boolean SFE_UBLOX_GNSS::initGeofenceParams()
-{
-  currentGeofenceParams = new geofenceParams_t; //Allocate RAM for the main struct
-  if (currentGeofenceParams == NULL)
-  {
-    if ((_printDebug == true) || (_printLimitedDebug == true)) // This is important. Print this if doing limited debugging
-      _debugSerial->println(F("initGeofenceParams: PANIC! RAM allocation failed!"));
-    return (false);
-  }
-  currentGeofenceParams->numFences = 0;
-  return (true);
-}
-
-//Power Save Mode
-//Enables/Disables Low Power Mode using UBX-CFG-RXM
-boolean SFE_UBLOX_GNSS::powerSaveMode(bool power_save, uint16_t maxWait)
-{
-  // Let's begin by checking the Protocol Version as UBX_CFG_RXM is not supported on the ZED (protocol >= 27)
-  uint8_t protVer = getProtocolVersionHigh(maxWait);
-  /*
-  if (_printDebug == true)
-  {
-    _debugSerial->print(F("Protocol version is "));
-    _debugSerial->println(protVer);
-  }
-  */
-  if (protVer >= 27)
-  {
-    if ((_printDebug == true) || (_printLimitedDebug == true)) // This is important. Print this if doing limited debugging
-    {
-      _debugSerial->println(F("powerSaveMode (UBX-CFG-RXM) is not supported by this protocol version"));
-    }
-    return (false);
-  }
-
-  // Now let's change the power setting using UBX-CFG-RXM
-  packetCfg.cls = UBX_CLASS_CFG;
-  packetCfg.id = UBX_CFG_RXM;
-  packetCfg.len = 0;
-  packetCfg.startingSpot = 0;
-
-  //Ask module for the current power management settings. Loads into payloadCfg.
-  if (sendCommand(&packetCfg, maxWait) != SFE_UBLOX_STATUS_DATA_RECEIVED) // We are expecting data and an ACK
-    return (false);
-
-  if (power_save)
-  {
-    payloadCfg[1] = 1; // Power Save Mode
-  }
-  else
-  {
-    payloadCfg[1] = 0; // Continuous Mode
-  }
-
-  packetCfg.len = 2;
-  packetCfg.startingSpot = 0;
-
-  return (sendCommand(&packetCfg, maxWait) == SFE_UBLOX_STATUS_DATA_SENT); // We are only expecting an ACK
-}
-
-// Get Power Save Mode
-// Returns the current Low Power Mode using UBX-CFG-RXM
-// Returns 255 if the sendCommand fails
-uint8_t SFE_UBLOX_GNSS::getPowerSaveMode(uint16_t maxWait)
-{
-  // Let's begin by checking the Protocol Version as UBX_CFG_RXM is not supported on the ZED (protocol >= 27)
-  uint8_t protVer = getProtocolVersionHigh(maxWait);
-  /*
-  if (_printDebug == true)
-  {
-    _debugSerial->print(F("Protocol version is "));
-    _debugSerial->println(protVer);
-  }
-  */
-  if (protVer >= 27)
-  {
-    if ((_printDebug == true) || (_printLimitedDebug == true)) // This is important. Print this if doing limited debugging
-    {
-      _debugSerial->println(F("powerSaveMode (UBX-CFG-RXM) is not supported by this protocol version"));
-    }
-    return (255);
-  }
-
-  // Now let's read the power setting using UBX-CFG-RXM
-  packetCfg.cls = UBX_CLASS_CFG;
-  packetCfg.id = UBX_CFG_RXM;
-  packetCfg.len = 0;
-  packetCfg.startingSpot = 0;
-
-  //Ask module for the current power management settings. Loads into payloadCfg.
-  if (sendCommand(&packetCfg, maxWait) != SFE_UBLOX_STATUS_DATA_RECEIVED) // We are expecting data and an ACK
-    return (255);
-
-  return (payloadCfg[1]); // Return the low power mode
-}
-
-// Powers off the GPS device for a given duration to reduce power consumption.
-// NOTE: Querying the device before the duration is complete, for example by "getLatitude()" will wake it up!
-// Returns true if command has not been not acknowledged.
-// Returns false if command has not been acknowledged or maxWait = 0.
-boolean SFE_UBLOX_GNSS::powerOff(uint32_t durationInMs, uint16_t maxWait)
-{
-  // use durationInMs = 0 for infinite duration
-  if (_printDebug == true)
-  {
-    _debugSerial->print(F("Powering off for "));
-    _debugSerial->print(durationInMs);
-    _debugSerial->println(" ms");
-  }
-
-  // Power off device using UBX-RXM-PMREQ
-  packetCfg.cls = UBX_CLASS_RXM; // 0x02
-  packetCfg.id = UBX_RXM_PMREQ;  // 0x41
-  packetCfg.len = 8;
-  packetCfg.startingSpot = 0;
-
-  // duration
-  // big endian to little endian, switch byte order
-  payloadCfg[0] = (durationInMs >> (8 * 0)) & 0xff;
-  payloadCfg[1] = (durationInMs >> (8 * 1)) & 0xff;
-  payloadCfg[2] = (durationInMs >> (8 * 2)) & 0xff;
-  payloadCfg[3] = (durationInMs >> (8 * 3)) & 0xff;
-
-  payloadCfg[4] = 0x02; //Flags : set the backup bit
-  payloadCfg[5] = 0x00; //Flags
-  payloadCfg[6] = 0x00; //Flags
-  payloadCfg[7] = 0x00; //Flags
-
-  if (maxWait != 0)
-  {
-    // check for "not acknowledged" command
-    return (sendCommand(&packetCfg, maxWait) != SFE_UBLOX_STATUS_COMMAND_NACK);
-  }
-  else
-  {
-    sendCommand(&packetCfg, maxWait);
-    return false; // can't tell if command not acknowledged if maxWait = 0
-  }
-}
-
-// Powers off the GPS device for a given duration to reduce power consumption.
-// While powered off it can be woken up by creating a falling or rising voltage edge on the specified pin.
-// NOTE: The GPS seems to be sensitve to signals on the pins while powered off. Works best when Microcontroller is in deepsleep.
-// NOTE: Querying the device before the duration is complete, for example by "getLatitude()" will wake it up!
-// Returns true if command has not been not acknowledged.
-// Returns false if command has not been acknowledged or maxWait = 0.
-boolean SFE_UBLOX_GNSS::powerOffWithInterrupt(uint32_t durationInMs, uint32_t wakeupSources, boolean forceWhileUsb, uint16_t maxWait)
-{
-  // use durationInMs = 0 for infinite duration
-  if (_printDebug == true)
-  {
-    _debugSerial->print(F("Powering off for "));
-    _debugSerial->print(durationInMs);
-    _debugSerial->println(" ms");
-  }
-
-  // Power off device using UBX-RXM-PMREQ
-  packetCfg.cls = UBX_CLASS_RXM; // 0x02
-  packetCfg.id = UBX_RXM_PMREQ;  // 0x41
-  packetCfg.len = 16;
-  packetCfg.startingSpot = 0;
-
-  payloadCfg[0] = 0x00; // message version
-
-  // bytes 1-3 are reserved - and must be set to zero
-  payloadCfg[1] = 0x00;
-  payloadCfg[2] = 0x00;
-  payloadCfg[3] = 0x00;
-
-  // duration
-  // big endian to little endian, switch byte order
-  payloadCfg[4] = (durationInMs >> (8 * 0)) & 0xff;
-  payloadCfg[5] = (durationInMs >> (8 * 1)) & 0xff;
-  payloadCfg[6] = (durationInMs >> (8 * 2)) & 0xff;
-  payloadCfg[7] = (durationInMs >> (8 * 3)) & 0xff;
-
-  // flags
-
-  // disables USB interface when powering off, defaults to true
-  if (forceWhileUsb)
-  {
-    payloadCfg[8] = 0x06; // force | backup
-  }
-  else
-  {
-    payloadCfg[8] = 0x02; // backup only (leave the force bit clear - module will stay on if USB is connected)
-  }
-
-  payloadCfg[9] = 0x00;
-  payloadCfg[10] = 0x00;
-  payloadCfg[11] = 0x00;
-
-  // wakeUpSources
-
-  // wakeupPin mapping, defaults to VAL_RXM_PMREQ_WAKEUPSOURCE_EXTINT0
-
-  // Possible values are:
-  // VAL_RXM_PMREQ_WAKEUPSOURCE_UARTRX
-  // VAL_RXM_PMREQ_WAKEUPSOURCE_EXTINT0
-  // VAL_RXM_PMREQ_WAKEUPSOURCE_EXTINT1
-  // VAL_RXM_PMREQ_WAKEUPSOURCE_SPICS
-
-  payloadCfg[12] = (wakeupSources >> (8 * 0)) & 0xff;
-  payloadCfg[13] = (wakeupSources >> (8 * 1)) & 0xff;
-  payloadCfg[14] = (wakeupSources >> (8 * 2)) & 0xff;
-  payloadCfg[15] = (wakeupSources >> (8 * 3)) & 0xff;
-
-  if (maxWait != 0)
-  {
-    // check for "not acknowledged" command
-    return (sendCommand(&packetCfg, maxWait) != SFE_UBLOX_STATUS_COMMAND_NACK);
-  }
-  else
-  {
-    sendCommand(&packetCfg, maxWait);
-    return false; // can't tell if command not acknowledged if maxWait = 0
-  }
-}
-
-//Dynamic Platform Model
-
-//Change the dynamic platform model using UBX-CFG-NAV5
-//Possible values are:
-//PORTABLE,STATIONARY,PEDESTRIAN,AUTOMOTIVE,SEA,
-//AIRBORNE1g,AIRBORNE2g,AIRBORNE4g,WRIST,BIKE
-//WRIST is not supported in protocol versions less than 18
-//BIKE is supported in protocol versions 19.2
-boolean SFE_UBLOX_GNSS::setDynamicModel(dynModel newDynamicModel, uint16_t maxWait)
-{
-  packetCfg.cls = UBX_CLASS_CFG;
-  packetCfg.id = UBX_CFG_NAV5;
-  packetCfg.len = 0;
-  packetCfg.startingSpot = 0;
-
-  //Ask module for the current navigation model settings. Loads into payloadCfg.
-  if (sendCommand(&packetCfg, maxWait) != SFE_UBLOX_STATUS_DATA_RECEIVED) // We are expecting data and an ACK
-    return (false);
-
-  payloadCfg[0] = 0x01;            // mask: set only the dyn bit (0)
-  payloadCfg[1] = 0x00;            // mask
-  payloadCfg[2] = newDynamicModel; // dynModel
-
-  packetCfg.len = 36;
-  packetCfg.startingSpot = 0;
-
-  return (sendCommand(&packetCfg, maxWait) == SFE_UBLOX_STATUS_DATA_SENT); // We are only expecting an ACK
-}
-
-//Get the dynamic platform model using UBX-CFG-NAV5
-//Returns DYN_MODEL_UNKNOWN (255) if the sendCommand fails
-uint8_t SFE_UBLOX_GNSS::getDynamicModel(uint16_t maxWait)
-{
-  packetCfg.cls = UBX_CLASS_CFG;
-  packetCfg.id = UBX_CFG_NAV5;
-  packetCfg.len = 0;
-  packetCfg.startingSpot = 0;
-
-  //Ask module for the current navigation model settings. Loads into payloadCfg.
-  if (sendCommand(&packetCfg, maxWait) != SFE_UBLOX_STATUS_DATA_RECEIVED) // We are expecting data and an ACK
-    return (DYN_MODEL_UNKNOWN);
-
-  return (payloadCfg[2]); // Return the dynamic model
-}
-
-//Reset the odometer
-boolean SFE_UBLOX_GNSS::resetOdometer(uint16_t maxWait)
-{
-  packetCfg.cls = UBX_CLASS_NAV;
-  packetCfg.id = UBX_NAV_RESETODO;
-  packetCfg.len = 0;
-  packetCfg.startingSpot = 0;
-
-  // This is a special case as we are only expecting an ACK but this is not a CFG message
-  return (sendCommand(&packetCfg, maxWait, true) == SFE_UBLOX_STATUS_DATA_SENT); // We are only expecting an ACK
-}
-
-//Enable/Disable individual GNSS systems using UBX-CFG-GNSS
-boolean SFE_UBLOX_GNSS::enableGNSS(boolean enable, sfe_ublox_gnss_ids_e id, uint16_t maxWait)
-{
-  packetCfg.cls = UBX_CLASS_CFG;
-  packetCfg.id = UBX_CFG_GNSS;
-  packetCfg.len = 0;
-  packetCfg.startingSpot = 0;
-
-  if (sendCommand(&packetCfg, maxWait) != SFE_UBLOX_STATUS_DATA_RECEIVED) // We are expecting data and an ACK
-    return (false);
-
-  uint8_t numConfigBlocks = payloadCfg[3]; // Extract the numConfigBlocks
-
-  for (uint8_t block = 0; block < numConfigBlocks; block++) // Check each configuration block
-  {
-    if (payloadCfg[(block * 8) + 4] == (uint8_t)id) // Check the gnssId for this block. Do we have a match?
-    {
-      // We have a match so set/clear the enable bit in flags
-      if (enable)
-        payloadCfg[(block * 8) + 4 + 4] |= 0x01; // Set the enable bit in flags (Little Endian)
-      else
-        payloadCfg[(block * 8) + 4 + 4] &= 0xFE; // Clear the enable bit in flags (Little Endian)
-    }
-  }
-
-  return (sendCommand(&packetCfg, maxWait) == SFE_UBLOX_STATUS_DATA_SENT); // We are only expecting an ACK
-}
-
-//Check if an individual GNSS system is enabled
-boolean SFE_UBLOX_GNSS::isGNSSenabled(sfe_ublox_gnss_ids_e id, uint16_t maxWait)
-{
-  packetCfg.cls = UBX_CLASS_CFG;
-  packetCfg.id = UBX_CFG_GNSS;
-  packetCfg.len = 0;
-  packetCfg.startingSpot = 0;
-
-  if (sendCommand(&packetCfg, maxWait) != SFE_UBLOX_STATUS_DATA_RECEIVED) // We are expecting data and an ACK
-    return (false);
-
-  boolean retVal = false;
-
-  uint8_t numConfigBlocks = payloadCfg[3]; // Extract the numConfigBlocks
-
-  for (uint8_t block = 0; block < numConfigBlocks; block++) // Check each configuration block
-  {
-    if (payloadCfg[(block * 8) + 4] == (uint8_t)id) // Check the gnssId for this block. Do we have a match?
-    {
-      // We have a match so check the enable bit in flags
-      if ((payloadCfg[(block * 8) + 4 + 4] & 0x01) > 0) // Check the enable bit in flags (Little Endian)
-        retVal = true;
-    }
-  }
-
-  return (retVal);
-}
-
-//Reset ESF automatic IMU-mount alignment
-boolean SFE_UBLOX_GNSS::resetIMUalignment(uint16_t maxWait)
-{
-  packetCfg.cls = UBX_CLASS_ESF;
-  packetCfg.id = UBX_ESF_RESETALG;
-  packetCfg.len = 0;
-  packetCfg.startingSpot = 0;
-
-  // This is a special case as we are only expecting an ACK but this is not a CFG message
-  return (sendCommand(&packetCfg, maxWait, true) == SFE_UBLOX_STATUS_DATA_SENT); // We are only expecting an ACK
-}
-
-//Get the time pulse parameters using UBX_CFG_TP5
-boolean SFE_UBLOX_GNSS::getTimePulseParameters(UBX_CFG_TP5_data_t *data, uint16_t maxWait)
-{
-  if (data == NULL) // Check if the user forgot to include the data pointer
-    return (false); // Bail
-
-  packetCfg.cls = UBX_CLASS_CFG;
-  packetCfg.id = UBX_CFG_TP5;
-  packetCfg.len = 0;
-  packetCfg.startingSpot = 0;
-
-  if (sendCommand(&packetCfg, maxWait) != SFE_UBLOX_STATUS_DATA_RECEIVED) // We are expecting data and an ACK
-    return (false);
-
-  // Extract the data
-  data->tpIdx = extractByte(&packetCfg, 0);
-  data->version = extractByte(&packetCfg, 1);
-  data->antCableDelay = extractSignedInt(&packetCfg, 4);
-  data->rfGroupDelay = extractSignedInt(&packetCfg, 6);
-  data->freqPeriod = extractLong(&packetCfg, 8);
-  data->freqPeriodLock = extractLong(&packetCfg, 12);
-  data->pulseLenRatio = extractLong(&packetCfg, 16);
-  data->pulseLenRatioLock = extractLong(&packetCfg, 20);
-  data->userConfigDelay = extractSignedLong(&packetCfg, 24);
-  data->flags.all = extractLong(&packetCfg, 28);
-
-  return(true);
-}
-
-//Set the time pulse parameters using UBX_CFG_TP5
-boolean SFE_UBLOX_GNSS::setTimePulseParameters(UBX_CFG_TP5_data_t *data, uint16_t maxWait)
-{
-  if (data == NULL) // Check if the user forgot to include the data pointer
-    return (false); // Bail
-
-  packetCfg.cls = UBX_CLASS_CFG;
-  packetCfg.id = UBX_CFG_TP5;
-  packetCfg.len = UBX_CFG_TP5_LEN;
-  packetCfg.startingSpot = 0;
-
-  // Insert the data
-  payloadCfg[0] = data->tpIdx;
-  payloadCfg[1] = data->version;
-  payloadCfg[4] = data->antCableDelay & 0xFF; // Little Endian
-  payloadCfg[5] = data->antCableDelay >> 8;
-  payloadCfg[6] = data->rfGroupDelay & 0xFF; // Little Endian
-  payloadCfg[7] = data->rfGroupDelay >> 8;
-  payloadCfg[8] = data->freqPeriod & 0xFF; // Little Endian
-  payloadCfg[9] = (data->freqPeriod >> 8) & 0xFF;
-  payloadCfg[10] = (data->freqPeriod >> 16) & 0xFF;
-  payloadCfg[11] = (data->freqPeriod >> 24) & 0xFF;
-  payloadCfg[12] = data->freqPeriodLock & 0xFF; // Little Endian
-  payloadCfg[13] = (data->freqPeriodLock >> 8) & 0xFF;
-  payloadCfg[14] = (data->freqPeriodLock >> 16) & 0xFF;
-  payloadCfg[15] = (data->freqPeriodLock >> 24) & 0xFF;
-  payloadCfg[16] = data->pulseLenRatio & 0xFF; // Little Endian
-  payloadCfg[17] = (data->pulseLenRatio >> 8) & 0xFF;
-  payloadCfg[18] = (data->pulseLenRatio >> 16) & 0xFF;
-  payloadCfg[19] = (data->pulseLenRatio >> 24) & 0xFF;
-  payloadCfg[20] = data->pulseLenRatioLock & 0xFF; // Little Endian
-  payloadCfg[21] = (data->pulseLenRatioLock >> 8) & 0xFF;
-  payloadCfg[22] = (data->pulseLenRatioLock >> 16) & 0xFF;
-  payloadCfg[23] = (data->pulseLenRatioLock >> 24) & 0xFF;
-  payloadCfg[24] = data->userConfigDelay & 0xFF; // Little Endian
-  payloadCfg[25] = (data->userConfigDelay >> 8) & 0xFF;
-  payloadCfg[26] = (data->userConfigDelay >> 16) & 0xFF;
-  payloadCfg[27] = (data->userConfigDelay >> 24) & 0xFF;
-  payloadCfg[28] = data->flags.all & 0xFF; // Little Endian
-  payloadCfg[29] = (data->flags.all >> 8) & 0xFF;
-  payloadCfg[30] = (data->flags.all >> 16) & 0xFF;
-  payloadCfg[31] = (data->flags.all >> 24) & 0xFF;
-
-  return (sendCommand(&packetCfg, maxWait) == SFE_UBLOX_STATUS_DATA_SENT); // We are only expecting an ACK
-}
-
-// CONFIGURATION INTERFACE (protocol v27 and above)
-
-//Form 32-bit key from group/id/size
-uint32_t SFE_UBLOX_GNSS::createKey(uint16_t group, uint16_t id, uint8_t size)
-{
-  uint32_t key = 0;
-  key |= (uint32_t)id;
-  key |= (uint32_t)group << 16;
-  key |= (uint32_t)size << 28;
-  return (key);
-}
-
-//Given a key, load the payload with data that can then be extracted to 8, 16, or 32 bits
-//This function takes a full 32-bit key
-//Default layer is RAM
-//Configuration of modern u-blox modules is now done via getVal/setVal/delVal, ie protocol v27 and above found on ZED-F9P
-sfe_ublox_status_e SFE_UBLOX_GNSS::getVal(uint32_t key, uint8_t layer, uint16_t maxWait)
-{
-  packetCfg.cls = UBX_CLASS_CFG;
-  packetCfg.id = UBX_CFG_VALGET;
-  packetCfg.len = 4 + 4 * 1; //While multiple keys are allowed, we will send only one key at a time
-  packetCfg.startingSpot = 0;
-
-  //Clear packet payload
-  memset(payloadCfg, 0, packetCfg.len);
-
-  //VALGET uses different memory layer definitions to VALSET
-  //because it can only return the value for one layer.
-  //So we need to fiddle the layer here.
-  //And just to complicate things further, the ZED-F9P only responds
-  //correctly to layer 0 (RAM) and layer 7 (Default)!
-  uint8_t getLayer = 7;                         // 7 is the "Default Layer"
-  if ((layer & VAL_LAYER_RAM) == VAL_LAYER_RAM) // Did the user request the RAM layer?
-  {
-    getLayer = 0; // Layer 0 is RAM
-  }
-
-  payloadCfg[0] = 0;        //Message Version - set to 0
-  payloadCfg[1] = getLayer; //Layer
-
-  //Load key into outgoing payload
-  payloadCfg[4] = key >> 8 * 0; //Key LSB
-  payloadCfg[5] = key >> 8 * 1;
-  payloadCfg[6] = key >> 8 * 2;
-  payloadCfg[7] = key >> 8 * 3;
-
-  if (_printDebug == true)
-  {
-    _debugSerial->print(F("key: 0x"));
-    _debugSerial->print(key, HEX);
-    _debugSerial->println();
-  }
-
-  //Send VALGET command with this key
-
-  sfe_ublox_status_e retVal = sendCommand(&packetCfg, maxWait);
-  if (_printDebug == true)
-  {
-    _debugSerial->print(F("getVal: sendCommand returned: "));
-    _debugSerial->println(statusString(retVal));
-  }
-
-  //Verify the response is the correct length as compared to what the user called (did the module respond with 8-bits but the user called getVal32?)
-  //Response is 8 bytes plus cfg data
-  //if(packet->len > 8+1)
-
-  //The response is now sitting in payload, ready for extraction
-  return (retVal);
-}
-
-//Given a key, return its value
-//This function takes a full 32-bit key
-//Default layer is RAM
-//Configuration of modern u-blox modules is now done via getVal/setVal/delVal, ie protocol v27 and above found on ZED-F9P
-uint8_t SFE_UBLOX_GNSS::getVal8(uint32_t key, uint8_t layer, uint16_t maxWait)
-{
-  if (getVal(key, layer, maxWait) != SFE_UBLOX_STATUS_DATA_RECEIVED)
-    return (0);
-
-  return (extractByte(&packetCfg, 8));
-}
-uint16_t SFE_UBLOX_GNSS::getVal16(uint32_t key, uint8_t layer, uint16_t maxWait)
-{
-  if (getVal(key, layer, maxWait) != SFE_UBLOX_STATUS_DATA_RECEIVED)
-    return (0);
-
-  return (extractInt(&packetCfg, 8));
-}
-uint32_t SFE_UBLOX_GNSS::getVal32(uint32_t key, uint8_t layer, uint16_t maxWait)
-{
-  if (getVal(key, layer, maxWait) != SFE_UBLOX_STATUS_DATA_RECEIVED)
-    return (0);
-
-  return (extractLong(&packetCfg, 8));
-}
-
-//Given a group, ID and size, return the value of this config spot
-//The 32-bit key is put together from group/ID/size. See other getVal to send key directly.
-//Configuration of modern u-blox modules is now done via getVal/setVal/delVal, ie protocol v27 and above found on ZED-F9P
-uint8_t SFE_UBLOX_GNSS::getVal8(uint16_t group, uint16_t id, uint8_t size, uint8_t layer, uint16_t maxWait)
-{
-  uint32_t key = createKey(group, id, size);
-  return getVal8(key, layer, maxWait);
-}
-uint16_t SFE_UBLOX_GNSS::getVal16(uint16_t group, uint16_t id, uint8_t size, uint8_t layer, uint16_t maxWait)
-{
-  uint32_t key = createKey(group, id, size);
-  return getVal16(key, layer, maxWait);
-}
-uint32_t SFE_UBLOX_GNSS::getVal32(uint16_t group, uint16_t id, uint8_t size, uint8_t layer, uint16_t maxWait)
-{
-  uint32_t key = createKey(group, id, size);
-  return getVal32(key, layer, maxWait);
-}
-
-//Given a key, set a 16-bit value
-//This function takes a full 32-bit key
-//Default layer is all: RAM+BBR+Flash
-//Configuration of modern u-blox modules is now done via getVal/setVal/delVal, ie protocol v27 and above found on ZED-F9P
-uint8_t SFE_UBLOX_GNSS::setVal(uint32_t key, uint16_t value, uint8_t layer, uint16_t maxWait)
-{
-  return setVal16(key, value, layer, maxWait);
-}
-
-//Given a key, set a 16-bit value
-//This function takes a full 32-bit key
-//Default layer is all: RAM+BBR+Flash
-//Configuration of modern u-blox modules is now done via getVal/setVal/delVal, ie protocol v27 and above found on ZED-F9P
-uint8_t SFE_UBLOX_GNSS::setVal16(uint32_t key, uint16_t value, uint8_t layer, uint16_t maxWait)
-{
-  packetCfg.cls = UBX_CLASS_CFG;
-  packetCfg.id = UBX_CFG_VALSET;
-  packetCfg.len = 4 + 4 + 2; //4 byte header, 4 byte key ID, 2 bytes of value
-  packetCfg.startingSpot = 0;
-
-  //Clear packet payload
-  memset(payloadCfg, 0, packetCfg.len);
-
-  payloadCfg[0] = 0;     //Message Version - set to 0
-  payloadCfg[1] = layer; //By default we ask for the BBR layer
-
-  //Load key into outgoing payload
-  payloadCfg[4] = key >> 8 * 0; //Key LSB
-  payloadCfg[5] = key >> 8 * 1;
-  payloadCfg[6] = key >> 8 * 2;
-  payloadCfg[7] = key >> 8 * 3;
-
-  //Load user's value
-  payloadCfg[8] = value >> 8 * 0; //Value LSB
-  payloadCfg[9] = value >> 8 * 1;
-
-  //Send VALSET command with this key and value
-  return (sendCommand(&packetCfg, maxWait) == SFE_UBLOX_STATUS_DATA_SENT); // We are only expecting an ACK
-}
-
-//Given a key, set an 8-bit value
-//This function takes a full 32-bit key
-//Default layer is all: RAM+BBR+Flash
-//Configuration of modern u-blox modules is now done via getVal/setVal/delVal, ie protocol v27 and above found on ZED-F9P
-uint8_t SFE_UBLOX_GNSS::setVal8(uint32_t key, uint8_t value, uint8_t layer, uint16_t maxWait)
-{
-  packetCfg.cls = UBX_CLASS_CFG;
-  packetCfg.id = UBX_CFG_VALSET;
-  packetCfg.len = 4 + 4 + 1; //4 byte header, 4 byte key ID, 1 byte value
-  packetCfg.startingSpot = 0;
-
-  //Clear packet payload
-  memset(payloadCfg, 0, packetCfg.len);
-
-  payloadCfg[0] = 0;     //Message Version - set to 0
-  payloadCfg[1] = layer; //By default we ask for the BBR layer
-
-  //Load key into outgoing payload
-  payloadCfg[4] = key >> 8 * 0; //Key LSB
-  payloadCfg[5] = key >> 8 * 1;
-  payloadCfg[6] = key >> 8 * 2;
-  payloadCfg[7] = key >> 8 * 3;
-
-  //Load user's value
-  payloadCfg[8] = value; //Value
-
-  //Send VALSET command with this key and value
-  return (sendCommand(&packetCfg, maxWait) == SFE_UBLOX_STATUS_DATA_SENT); // We are only expecting an ACK
-}
-
-//Given a key, set a 32-bit value
-//This function takes a full 32-bit key
-//Default layer is all: RAM+BBR+Flash
-//Configuration of modern u-blox modules is now done via getVal/setVal/delVal, ie protocol v27 and above found on ZED-F9P
-uint8_t SFE_UBLOX_GNSS::setVal32(uint32_t key, uint32_t value, uint8_t layer, uint16_t maxWait)
-{
-  packetCfg.cls = UBX_CLASS_CFG;
-  packetCfg.id = UBX_CFG_VALSET;
-  packetCfg.len = 4 + 4 + 4; //4 byte header, 4 byte key ID, 4 bytes of value
-  packetCfg.startingSpot = 0;
-
-  //Clear packet payload
-  memset(payloadCfg, 0, packetCfg.len);
-
-  payloadCfg[0] = 0;     //Message Version - set to 0
-  payloadCfg[1] = layer; //By default we ask for the BBR layer
-
-  //Load key into outgoing payload
-  payloadCfg[4] = key >> 8 * 0; //Key LSB
-  payloadCfg[5] = key >> 8 * 1;
-  payloadCfg[6] = key >> 8 * 2;
-  payloadCfg[7] = key >> 8 * 3;
-
-  //Load user's value
-  payloadCfg[8] = value >> 8 * 0; //Value LSB
-  payloadCfg[9] = value >> 8 * 1;
-  payloadCfg[10] = value >> 8 * 2;
-  payloadCfg[11] = value >> 8 * 3;
-
-  //Send VALSET command with this key and value
-  return (sendCommand(&packetCfg, maxWait) == SFE_UBLOX_STATUS_DATA_SENT); // We are only expecting an ACK
-}
-
-//Start defining a new UBX-CFG-VALSET ubxPacket
-//This function takes a full 32-bit key and 32-bit value
-//Default layer is BBR
-//Configuration of modern u-blox modules is now done via getVal/setVal/delVal, ie protocol v27 and above found on ZED-F9P
-uint8_t SFE_UBLOX_GNSS::newCfgValset32(uint32_t key, uint32_t value, uint8_t layer)
-{
-  packetCfg.cls = UBX_CLASS_CFG;
-  packetCfg.id = UBX_CFG_VALSET;
-  packetCfg.len = 4 + 4 + 4; //4 byte header, 4 byte key ID, 4 bytes of value
-  packetCfg.startingSpot = 0;
-
-  //Clear all of packet payload
-  memset(payloadCfg, 0, packetCfgPayloadSize);
-
-  payloadCfg[0] = 0;     //Message Version - set to 0
-  payloadCfg[1] = layer; //By default we ask for the BBR layer
-
-  //Load key into outgoing payload
-  payloadCfg[4] = key >> 8 * 0; //Key LSB
-  payloadCfg[5] = key >> 8 * 1;
-  payloadCfg[6] = key >> 8 * 2;
-  payloadCfg[7] = key >> 8 * 3;
-
-  //Load user's value
-  payloadCfg[8] = value >> 8 * 0; //Value LSB
-  payloadCfg[9] = value >> 8 * 1;
-  payloadCfg[10] = value >> 8 * 2;
-  payloadCfg[11] = value >> 8 * 3;
-
-  //All done
-  return (true);
-}
-
-//Start defining a new UBX-CFG-VALSET ubxPacket
-//This function takes a full 32-bit key and 16-bit value
-//Default layer is BBR
-//Configuration of modern u-blox modules is now done via getVal/setVal/delVal, ie protocol v27 and above found on ZED-F9P
-uint8_t SFE_UBLOX_GNSS::newCfgValset16(uint32_t key, uint16_t value, uint8_t layer)
-{
-  packetCfg.cls = UBX_CLASS_CFG;
-  packetCfg.id = UBX_CFG_VALSET;
-  packetCfg.len = 4 + 4 + 2; //4 byte header, 4 byte key ID, 2 bytes of value
-  packetCfg.startingSpot = 0;
-
-  //Clear all of packet payload
-  memset(payloadCfg, 0, packetCfgPayloadSize);
-
-  payloadCfg[0] = 0;     //Message Version - set to 0
-  payloadCfg[1] = layer; //By default we ask for the BBR layer
-
-  //Load key into outgoing payload
-  payloadCfg[4] = key >> 8 * 0; //Key LSB
-  payloadCfg[5] = key >> 8 * 1;
-  payloadCfg[6] = key >> 8 * 2;
-  payloadCfg[7] = key >> 8 * 3;
-
-  //Load user's value
-  payloadCfg[8] = value >> 8 * 0; //Value LSB
-  payloadCfg[9] = value >> 8 * 1;
-
-  //All done
-  return (true);
-}
-
-//Start defining a new UBX-CFG-VALSET ubxPacket
-//This function takes a full 32-bit key and 8-bit value
-//Default layer is BBR
-//Configuration of modern u-blox modules is now done via getVal/setVal/delVal, ie protocol v27 and above found on ZED-F9P
-uint8_t SFE_UBLOX_GNSS::newCfgValset8(uint32_t key, uint8_t value, uint8_t layer)
-{
-  packetCfg.cls = UBX_CLASS_CFG;
-  packetCfg.id = UBX_CFG_VALSET;
-  packetCfg.len = 4 + 4 + 1; //4 byte header, 4 byte key ID, 1 byte value
-  packetCfg.startingSpot = 0;
-
-  //Clear all of packet payload
-  memset(payloadCfg, 0, packetCfgPayloadSize);
-
-  payloadCfg[0] = 0;     //Message Version - set to 0
-  payloadCfg[1] = layer; //By default we ask for the BBR layer
-
-  //Load key into outgoing payload
-  payloadCfg[4] = key >> 8 * 0; //Key LSB
-  payloadCfg[5] = key >> 8 * 1;
-  payloadCfg[6] = key >> 8 * 2;
-  payloadCfg[7] = key >> 8 * 3;
-
-  //Load user's value
-  payloadCfg[8] = value; //Value
-
-  //All done
-  return (true);
-}
-
-//Add another keyID and value to an existing UBX-CFG-VALSET ubxPacket
-//This function takes a full 32-bit key and 32-bit value
-uint8_t SFE_UBLOX_GNSS::addCfgValset32(uint32_t key, uint32_t value)
-{
-  //Load key into outgoing payload
-  payloadCfg[packetCfg.len + 0] = key >> 8 * 0; //Key LSB
-  payloadCfg[packetCfg.len + 1] = key >> 8 * 1;
-  payloadCfg[packetCfg.len + 2] = key >> 8 * 2;
-  payloadCfg[packetCfg.len + 3] = key >> 8 * 3;
-
-  //Load user's value
-  payloadCfg[packetCfg.len + 4] = value >> 8 * 0; //Value LSB
-  payloadCfg[packetCfg.len + 5] = value >> 8 * 1;
-  payloadCfg[packetCfg.len + 6] = value >> 8 * 2;
-  payloadCfg[packetCfg.len + 7] = value >> 8 * 3;
-
-  //Update packet length: 4 byte key ID, 4 bytes of value
-  packetCfg.len = packetCfg.len + 4 + 4;
-
-  //All done
-  return (true);
-}
-
-//Add another keyID and value to an existing UBX-CFG-VALSET ubxPacket
-//This function takes a full 32-bit key and 16-bit value
-uint8_t SFE_UBLOX_GNSS::addCfgValset16(uint32_t key, uint16_t value)
-{
-  //Load key into outgoing payload
-  payloadCfg[packetCfg.len + 0] = key >> 8 * 0; //Key LSB
-  payloadCfg[packetCfg.len + 1] = key >> 8 * 1;
-  payloadCfg[packetCfg.len + 2] = key >> 8 * 2;
-  payloadCfg[packetCfg.len + 3] = key >> 8 * 3;
-
-  //Load user's value
-  payloadCfg[packetCfg.len + 4] = value >> 8 * 0; //Value LSB
-  payloadCfg[packetCfg.len + 5] = value >> 8 * 1;
-
-  //Update packet length: 4 byte key ID, 2 bytes of value
-  packetCfg.len = packetCfg.len + 4 + 2;
-
-  //All done
-  return (true);
-}
-
-//Add another keyID and value to an existing UBX-CFG-VALSET ubxPacket
-//This function takes a full 32-bit key and 8-bit value
-uint8_t SFE_UBLOX_GNSS::addCfgValset8(uint32_t key, uint8_t value)
-{
-  //Load key into outgoing payload
-  payloadCfg[packetCfg.len + 0] = key >> 8 * 0; //Key LSB
-  payloadCfg[packetCfg.len + 1] = key >> 8 * 1;
-  payloadCfg[packetCfg.len + 2] = key >> 8 * 2;
-  payloadCfg[packetCfg.len + 3] = key >> 8 * 3;
-
-  //Load user's value
-  payloadCfg[packetCfg.len + 4] = value; //Value
-
-  //Update packet length: 4 byte key ID, 1 byte value
-  packetCfg.len = packetCfg.len + 4 + 1;
-
-  //All done
-  return (true);
-}
-
-//Add a final keyID and value to an existing UBX-CFG-VALSET ubxPacket and send it
-//This function takes a full 32-bit key and 32-bit value
-uint8_t SFE_UBLOX_GNSS::sendCfgValset32(uint32_t key, uint32_t value, uint16_t maxWait)
-{
-  //Load keyID and value into outgoing payload
-  addCfgValset32(key, value);
-
-  //Send VALSET command with this key and value
-  return (sendCommand(&packetCfg, maxWait) == SFE_UBLOX_STATUS_DATA_SENT); // We are only expecting an ACK
-}
-
-//Add a final keyID and value to an existing UBX-CFG-VALSET ubxPacket and send it
-//This function takes a full 32-bit key and 16-bit value
-uint8_t SFE_UBLOX_GNSS::sendCfgValset16(uint32_t key, uint16_t value, uint16_t maxWait)
-{
-  //Load keyID and value into outgoing payload
-  addCfgValset16(key, value);
-
-  //Send VALSET command with this key and value
-  return (sendCommand(&packetCfg, maxWait) == SFE_UBLOX_STATUS_DATA_SENT); // We are only expecting an ACK
-}
-
-//Add a final keyID and value to an existing UBX-CFG-VALSET ubxPacket and send it
-//This function takes a full 32-bit key and 8-bit value
-uint8_t SFE_UBLOX_GNSS::sendCfgValset8(uint32_t key, uint8_t value, uint16_t maxWait)
-{
-  //Load keyID and value into outgoing payload
-  addCfgValset8(key, value);
-
-  //Send VALSET command with this key and value
-  return (sendCommand(&packetCfg, maxWait) == SFE_UBLOX_STATUS_DATA_SENT); // We are only expecting an ACK
-}
-
-//=-=-=-=-=-=-=-= "Automatic" Messages =-=-=-=-=-=-=-==-=-=-=-=-=-=-=
-//=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-==-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
-
-
-// ***** NAV POSECEF automatic support
-
-boolean SFE_UBLOX_GNSS::getNAVPOSECEF(uint16_t maxWait)
-{
-  if (packetUBXNAVPOSECEF == NULL) initPacketUBXNAVPOSECEF(); //Check that RAM has been allocated for the POSECEF data
-  if (packetUBXNAVPOSECEF == NULL) //Bail if the RAM allocation failed
-    return (false);
-
-  if (packetUBXNAVPOSECEF->automaticFlags.flags.bits.automatic && packetUBXNAVPOSECEF->automaticFlags.flags.bits.implicitUpdate)
-  {
-    //The GPS is automatically reporting, we just check whether we got unread data
-    checkUbloxInternal(&packetCfg, UBX_CLASS_NAV, UBX_NAV_POSECEF);
-    return packetUBXNAVPOSECEF->moduleQueried.moduleQueried.bits.all;
-  }
-  else if (packetUBXNAVPOSECEF->automaticFlags.flags.bits.automatic && !packetUBXNAVPOSECEF->automaticFlags.flags.bits.implicitUpdate)
-  {
-    //Someone else has to call checkUblox for us...
-    return (false);
-  }
-  else
-  {
-    //The GPS is not automatically reporting navigation position so we have to poll explicitly
-    packetCfg.cls = UBX_CLASS_NAV;
-    packetCfg.id = UBX_NAV_POSECEF;
-    packetCfg.len = 0;
-    packetCfg.startingSpot = 0;
-
-    //The data is parsed as part of processing the response
-    sfe_ublox_status_e retVal = sendCommand(&packetCfg, maxWait);
-
-    if (retVal == SFE_UBLOX_STATUS_DATA_RECEIVED)
-      return (true);
-
-    if (retVal == SFE_UBLOX_STATUS_DATA_OVERWRITTEN)
-    {
-      return (true);
-    }
-
-    return (false);
-  }
-}
-
-//Enable or disable automatic navigation message generation by the GNSS. This changes the way getPOSECEF
-//works.
-boolean SFE_UBLOX_GNSS::setAutoNAVPOSECEF(boolean enable, uint16_t maxWait)
-{
-  return setAutoNAVPOSECEFrate(enable ? 1 : 0, true, maxWait);
-}
-
-//Enable or disable automatic navigation message generation by the GNSS. This changes the way getPOSECEF
-//works.
-boolean SFE_UBLOX_GNSS::setAutoNAVPOSECEF(boolean enable, boolean implicitUpdate, uint16_t maxWait)
-{
-  return setAutoNAVPOSECEFrate(enable ? 1 : 0, implicitUpdate, maxWait);
-}
-
-//Enable or disable automatic navigation message generation by the GNSS. This changes the way getPOSECEF
-//works.
-boolean SFE_UBLOX_GNSS::setAutoNAVPOSECEFrate(uint8_t rate, boolean implicitUpdate, uint16_t maxWait)
-{
-  if (packetUBXNAVPOSECEF == NULL) initPacketUBXNAVPOSECEF(); //Check that RAM has been allocated for the data
-  if (packetUBXNAVPOSECEF == NULL) //Only attempt this if RAM allocation was successful
-    return false;
-
-  if (rate > 127) rate = 127;
-
-  packetCfg.cls = UBX_CLASS_CFG;
-  packetCfg.id = UBX_CFG_MSG;
-  packetCfg.len = 3;
-  packetCfg.startingSpot = 0;
-  payloadCfg[0] = UBX_CLASS_NAV;
-  payloadCfg[1] = UBX_NAV_POSECEF;
-  payloadCfg[2] = rate; // rate relative to navigation freq.
-
-  boolean ok = ((sendCommand(&packetCfg, maxWait)) == SFE_UBLOX_STATUS_DATA_SENT); // We are only expecting an ACK
-  if (ok)
-  {
-    packetUBXNAVPOSECEF->automaticFlags.flags.bits.automatic = (rate > 0);
-    packetUBXNAVPOSECEF->automaticFlags.flags.bits.implicitUpdate = implicitUpdate;
-  }
-  packetUBXNAVPOSECEF->moduleQueried.moduleQueried.bits.all = false;
-  return ok;
-}
-
-//Enable automatic navigation message generation by the GNSS.
-boolean SFE_UBLOX_GNSS::setAutoNAVPOSECEFcallback(void (*callbackPointer)(UBX_NAV_POSECEF_data_t), uint16_t maxWait)
-{
-  // Enable auto messages. Set implicitUpdate to false as we expect the user to call checkUblox manually.
-  boolean result = setAutoNAVPOSECEF(true, false, maxWait);
-  if (!result)
-    return (result); // Bail if setAuto failed
-
-  if (packetUBXNAVPOSECEF->callbackData == NULL) //Check if RAM has been allocated for the callback copy
-  {
-    packetUBXNAVPOSECEF->callbackData = new UBX_NAV_POSECEF_data_t; //Allocate RAM for the main struct
-  }
-
-  if (packetUBXNAVPOSECEF->callbackData == NULL)
-  {
-    if ((_printDebug == true) || (_printLimitedDebug == true)) // This is important. Print this if doing limited debugging
-      _debugSerial->println(F("setAutoNAVPOSECEFcallback: PANIC! RAM allocation failed!"));
-    return (false);
-  }
-
-  packetUBXNAVPOSECEF->callbackPointer = callbackPointer;
-  return (true);
-}
-
-//In case no config access to the GNSS is possible and POSECEF is send cyclically already
-//set config to suitable parameters
-boolean SFE_UBLOX_GNSS::assumeAutoNAVPOSECEF(boolean enabled, boolean implicitUpdate)
-{
-  if (packetUBXNAVPOSECEF == NULL) initPacketUBXNAVPOSECEF(); //Check that RAM has been allocated for the data
-  if (packetUBXNAVPOSECEF == NULL) //Only attempt this if RAM allocation was successful
-    return false;
-
-  boolean changes = packetUBXNAVPOSECEF->automaticFlags.flags.bits.automatic != enabled || packetUBXNAVPOSECEF->automaticFlags.flags.bits.implicitUpdate != implicitUpdate;
-  if (changes)
-  {
-    packetUBXNAVPOSECEF->automaticFlags.flags.bits.automatic = enabled;
-    packetUBXNAVPOSECEF->automaticFlags.flags.bits.implicitUpdate = implicitUpdate;
-  }
-  return changes;
-}
-
-// PRIVATE: Allocate RAM for packetUBXNAVPOSECEF and initialize it
-boolean SFE_UBLOX_GNSS::initPacketUBXNAVPOSECEF()
-{
-  packetUBXNAVPOSECEF = new UBX_NAV_POSECEF_t; //Allocate RAM for the main struct
-  if (packetUBXNAVPOSECEF == NULL)
-  {
-    if ((_printDebug == true) || (_printLimitedDebug == true)) // This is important. Print this if doing limited debugging
-      _debugSerial->println(F("initPacketUBXNAVPOSECEF: PANIC! RAM allocation failed!"));
-    return (false);
-  }
-  packetUBXNAVPOSECEF->automaticFlags.flags.all = 0;
-  packetUBXNAVPOSECEF->callbackPointer = NULL;
-  packetUBXNAVPOSECEF->callbackData = NULL;
-  packetUBXNAVPOSECEF->moduleQueried.moduleQueried.all = 0;
-  return (true);
-}
-
-//Mark all the data as read/stale. This is handy to get data alignment after CRC failure
-//or if there are no helper functions and the user wants to request fresh data
-void SFE_UBLOX_GNSS::flushNAVPOSECEF()
-{
-  if (packetUBXNAVPOSECEF == NULL) return; // Bail if RAM has not been allocated (otherwise we could be writing anywhere!)
-  packetUBXNAVPOSECEF->moduleQueried.moduleQueried.all = 0; //Mark all datums as stale (read before)
-}
-
-//Log this data in file buffer
-void SFE_UBLOX_GNSS::logNAVPOSECEF(boolean enabled)
-{
-  if (packetUBXNAVPOSECEF == NULL) return; // Bail if RAM has not been allocated (otherwise we could be writing anywhere!)
-  packetUBXNAVPOSECEF->automaticFlags.flags.bits.addToFileBuffer = (uint8_t)enabled;
-}
-
-// ***** NAV STATUS automatic support
-
-boolean SFE_UBLOX_GNSS::getNAVSTATUS(uint16_t maxWait)
-{
-  if (packetUBXNAVSTATUS == NULL) initPacketUBXNAVSTATUS(); //Check that RAM has been allocated for the STATUS data
-  if (packetUBXNAVSTATUS == NULL) //Bail if the RAM allocation failed
-    return (false);
-
-  if (packetUBXNAVSTATUS->automaticFlags.flags.bits.automatic && packetUBXNAVSTATUS->automaticFlags.flags.bits.implicitUpdate)
-  {
-    //The GPS is automatically reporting, we just check whether we got unread data
-    checkUbloxInternal(&packetCfg, UBX_CLASS_NAV, UBX_NAV_STATUS);
-    return packetUBXNAVSTATUS->moduleQueried.moduleQueried.bits.all;
-  }
-  else if (packetUBXNAVSTATUS->automaticFlags.flags.bits.automatic && !packetUBXNAVSTATUS->automaticFlags.flags.bits.implicitUpdate)
-  {
-    //Someone else has to call checkUblox for us...
-    return (false);
-  }
-  else
-  {
-    //The GPS is not automatically reporting navigation position so we have to poll explicitly
-    packetCfg.cls = UBX_CLASS_NAV;
-    packetCfg.id = UBX_NAV_STATUS;
-    packetCfg.len = 0;
-    packetCfg.startingSpot = 0;
-
-    //The data is parsed as part of processing the response
-    sfe_ublox_status_e retVal = sendCommand(&packetCfg, maxWait);
-
-    if (retVal == SFE_UBLOX_STATUS_DATA_RECEIVED)
-      return (true);
-
-    if (retVal == SFE_UBLOX_STATUS_DATA_OVERWRITTEN)
-    {
-      return (true);
-    }
-
-    return (false);
-  }
-}
-
-//Enable or disable automatic navigation message generation by the GNSS. This changes the way getNAVSTATUS
-//works.
-boolean SFE_UBLOX_GNSS::setAutoNAVSTATUS(boolean enable, uint16_t maxWait)
-{
-  return setAutoNAVSTATUSrate(enable ? 1 : 0, true, maxWait);
-}
-
-//Enable or disable automatic navigation message generation by the GNSS. This changes the way getNAVSTATUS
-//works.
-boolean SFE_UBLOX_GNSS::setAutoNAVSTATUS(boolean enable, boolean implicitUpdate, uint16_t maxWait)
-{
-  return setAutoNAVSTATUSrate(enable ? 1 : 0, implicitUpdate, maxWait);
-}
-
-//Enable or disable automatic navigation message generation by the GNSS. This changes the way getNAVSTATUS
-//works.
-boolean SFE_UBLOX_GNSS::setAutoNAVSTATUSrate(uint8_t rate, boolean implicitUpdate, uint16_t maxWait)
-{
-  if (packetUBXNAVSTATUS == NULL) initPacketUBXNAVSTATUS(); //Check that RAM has been allocated for the data
-  if (packetUBXNAVSTATUS == NULL) //Only attempt this if RAM allocation was successful
-    return false;
-
-  if (rate > 127) rate = 127;
-
-  packetCfg.cls = UBX_CLASS_CFG;
-  packetCfg.id = UBX_CFG_MSG;
-  packetCfg.len = 3;
-  packetCfg.startingSpot = 0;
-  payloadCfg[0] = UBX_CLASS_NAV;
-  payloadCfg[1] = UBX_NAV_STATUS;
-  payloadCfg[2] = rate; // rate relative to navigation freq.
-
-  boolean ok = ((sendCommand(&packetCfg, maxWait)) == SFE_UBLOX_STATUS_DATA_SENT); // We are only expecting an ACK
-  if (ok)
-  {
-    packetUBXNAVSTATUS->automaticFlags.flags.bits.automatic = (rate > 0);
-    packetUBXNAVSTATUS->automaticFlags.flags.bits.implicitUpdate = implicitUpdate;
-  }
-  packetUBXNAVSTATUS->moduleQueried.moduleQueried.bits.all = false;
-  return ok;
-}
-
-//Enable automatic navigation message generation by the GNSS.
-boolean SFE_UBLOX_GNSS::setAutoNAVSTATUScallback(void (*callbackPointer)(UBX_NAV_STATUS_data_t), uint16_t maxWait)
-{
-  // Enable auto messages. Set implicitUpdate to false as we expect the user to call checkUblox manually.
-  boolean result = setAutoNAVSTATUS(true, false, maxWait);
-  if (!result)
-    return (result); // Bail if setAuto failed
-
-  if (packetUBXNAVSTATUS->callbackData == NULL) //Check if RAM has been allocated for the callback copy
-  {
-    packetUBXNAVSTATUS->callbackData = new UBX_NAV_STATUS_data_t; //Allocate RAM for the main struct
-  }
-
-  if (packetUBXNAVSTATUS->callbackData == NULL)
-  {
-    if ((_printDebug == true) || (_printLimitedDebug == true)) // This is important. Print this if doing limited debugging
-      _debugSerial->println(F("setAutoNAVSTATUScallback: PANIC! RAM allocation failed!"));
-    return (false);
-  }
-
-  packetUBXNAVSTATUS->callbackPointer = callbackPointer;
-  return (true);
-}
-
-//In case no config access to the GNSS is possible and STATUS is send cyclically already
-//set config to suitable parameters
-boolean SFE_UBLOX_GNSS::assumeAutoNAVSTATUS(boolean enabled, boolean implicitUpdate)
-{
-  if (packetUBXNAVSTATUS == NULL) initPacketUBXNAVSTATUS(); //Check that RAM has been allocated for the data
-  if (packetUBXNAVSTATUS == NULL) //Only attempt this if RAM allocation was successful
-    return false;
-
-  boolean changes = packetUBXNAVSTATUS->automaticFlags.flags.bits.automatic != enabled || packetUBXNAVSTATUS->automaticFlags.flags.bits.implicitUpdate != implicitUpdate;
-  if (changes)
-  {
-    packetUBXNAVSTATUS->automaticFlags.flags.bits.automatic = enabled;
-    packetUBXNAVSTATUS->automaticFlags.flags.bits.implicitUpdate = implicitUpdate;
-  }
-  return changes;
-}
-
-// PRIVATE: Allocate RAM for packetUBXNAVSTATUS and initialize it
-boolean SFE_UBLOX_GNSS::initPacketUBXNAVSTATUS()
-{
-  packetUBXNAVSTATUS = new UBX_NAV_STATUS_t; //Allocate RAM for the main struct
-  if (packetUBXNAVSTATUS == NULL)
-  {
-    if ((_printDebug == true) || (_printLimitedDebug == true)) // This is important. Print this if doing limited debugging
-      _debugSerial->println(F("initPacketUBXNAVSTATUS: PANIC! RAM allocation failed!"));
-    return (false);
-  }
-  packetUBXNAVSTATUS->automaticFlags.flags.all = 0;
-  packetUBXNAVSTATUS->callbackPointer = NULL;
-  packetUBXNAVSTATUS->callbackData = NULL;
-  packetUBXNAVSTATUS->moduleQueried.moduleQueried.all = 0;
-  return (true);
-}
-
-//Mark all the data as read/stale. This is handy to get data alignment after CRC failure
-//or if there are no helper functions and the user wants to request fresh data
-void SFE_UBLOX_GNSS::flushNAVSTATUS()
-{
-  if (packetUBXNAVSTATUS == NULL) return; // Bail if RAM has not been allocated (otherwise we could be writing anywhere!)
-  packetUBXNAVSTATUS->moduleQueried.moduleQueried.all = 0; //Mark all datums as stale (read before)
-}
-
-//Log this data in file buffer
-void SFE_UBLOX_GNSS::logNAVSTATUS(boolean enabled)
-{
-  if (packetUBXNAVSTATUS == NULL) return; // Bail if RAM has not been allocated (otherwise we could be writing anywhere!)
-  packetUBXNAVSTATUS->automaticFlags.flags.bits.addToFileBuffer = (uint8_t)enabled;
-}
-
-// ***** DOP automatic support
-
-boolean SFE_UBLOX_GNSS::getDOP(uint16_t maxWait)
-{
-  if (packetUBXNAVDOP == NULL) initPacketUBXNAVDOP(); //Check that RAM has been allocated for the DOP data
-  if (packetUBXNAVDOP == NULL) //Bail if the RAM allocation failed
-    return (false);
-
-  if (packetUBXNAVDOP->automaticFlags.flags.bits.automatic && packetUBXNAVDOP->automaticFlags.flags.bits.implicitUpdate)
-  {
-    //The GPS is automatically reporting, we just check whether we got unread data
-    // if (_printDebug == true)
-    // {
-    //   _debugSerial->println(F("getDOP: Autoreporting"));
-    // }
-    checkUbloxInternal(&packetCfg, UBX_CLASS_NAV, UBX_NAV_DOP);
-    return packetUBXNAVDOP->moduleQueried.moduleQueried.bits.all;
-  }
-  else if (packetUBXNAVDOP->automaticFlags.flags.bits.automatic && !packetUBXNAVDOP->automaticFlags.flags.bits.implicitUpdate)
-  {
-    //Someone else has to call checkUblox for us...
-    // if (_printDebug == true)
-    // {
-    //   _debugSerial->println(F("getDOP: Exit immediately"));
-    // }
-    return (false);
-  }
-  else
-  {
-    // if (_printDebug == true)
-    // {
-    //   _debugSerial->println(F("getDOP: Polling"));
-    // }
-
-    //The GPS is not automatically reporting navigation position so we have to poll explicitly
-    packetCfg.cls = UBX_CLASS_NAV;
-    packetCfg.id = UBX_NAV_DOP;
-    packetCfg.len = 0;
-    packetCfg.startingSpot = 0;
-
-    //The data is parsed as part of processing the response
-    sfe_ublox_status_e retVal = sendCommand(&packetCfg, maxWait);
-
-    if (retVal == SFE_UBLOX_STATUS_DATA_RECEIVED)
-      return (true);
-
-    if (retVal == SFE_UBLOX_STATUS_DATA_OVERWRITTEN)
-    {
-      // if (_printDebug == true)
-      // {
-      //   _debugSerial->println(F("getDOP: data in packetCfg was OVERWRITTEN by another message (but that's OK)"));
-      // }
-      return (true);
-    }
-
-    // if (_printDebug == true)
-    // {
-    //   _debugSerial->print(F("getDOP retVal: "));
-    //   _debugSerial->println(statusString(retVal));
-    // }
-    return (false);
-  }
-}
-
-//Enable or disable automatic navigation message generation by the GNSS. This changes the way getDOP
-//works.
-boolean SFE_UBLOX_GNSS::setAutoDOP(boolean enable, uint16_t maxWait)
-{
-  return setAutoDOPrate(enable ? 1 : 0, true, maxWait);
-}
-
-//Enable or disable automatic navigation message generation by the GNSS. This changes the way getDOP
-//works.
-boolean SFE_UBLOX_GNSS::setAutoDOP(boolean enable, boolean implicitUpdate, uint16_t maxWait)
-{
-  return setAutoDOPrate(enable ? 1 : 0, implicitUpdate, maxWait);
-}
-
-//Enable or disable automatic navigation message generation by the GNSS. This changes the way getDOP
-//works.
-boolean SFE_UBLOX_GNSS::setAutoDOPrate(uint8_t rate, boolean implicitUpdate, uint16_t maxWait)
-{
-  if (packetUBXNAVDOP == NULL) initPacketUBXNAVDOP(); //Check that RAM has been allocated for the data
-  if (packetUBXNAVDOP == NULL) //Only attempt this if RAM allocation was successful
-    return false;
-
-  packetCfg.cls = UBX_CLASS_CFG;
-  packetCfg.id = UBX_CFG_MSG;
-  packetCfg.len = 3;
-  packetCfg.startingSpot = 0;
-  payloadCfg[0] = UBX_CLASS_NAV;
-  payloadCfg[1] = UBX_NAV_DOP;
-  payloadCfg[2] = rate; // rate relative to navigation freq.
-
-  boolean ok = ((sendCommand(&packetCfg, maxWait)) == SFE_UBLOX_STATUS_DATA_SENT); // We are only expecting an ACK
-  if (ok)
-  {
-    packetUBXNAVDOP->automaticFlags.flags.bits.automatic = (rate > 0);
-    packetUBXNAVDOP->automaticFlags.flags.bits.implicitUpdate = implicitUpdate;
-  }
-  packetUBXNAVDOP->moduleQueried.moduleQueried.bits.all = false;
-  return ok;
-}
-
-//Enable automatic navigation message generation by the GNSS.
-boolean SFE_UBLOX_GNSS::setAutoDOPcallback(void (*callbackPointer)(UBX_NAV_DOP_data_t), uint16_t maxWait)
-{
-  // Enable auto messages. Set implicitUpdate to false as we expect the user to call checkUblox manually.
-  boolean result = setAutoDOP(true, false, maxWait);
-  if (!result)
-    return (result); // Bail if setAuto failed
-
-  if (packetUBXNAVDOP->callbackData == NULL) //Check if RAM has been allocated for the callback copy
-  {
-    packetUBXNAVDOP->callbackData = new UBX_NAV_DOP_data_t; //Allocate RAM for the main struct
-  }
-
-  if (packetUBXNAVDOP->callbackData == NULL)
-  {
-    if ((_printDebug == true) || (_printLimitedDebug == true)) // This is important. Print this if doing limited debugging
-      _debugSerial->println(F("setAutoDOPcallback: PANIC! RAM allocation failed!"));
-    return (false);
-  }
-
-  packetUBXNAVDOP->callbackPointer = callbackPointer;
-  return (true);
-}
-
-//In case no config access to the GNSS is possible and DOP is send cyclically already
-//set config to suitable parameters
-boolean SFE_UBLOX_GNSS::assumeAutoDOP(boolean enabled, boolean implicitUpdate)
-{
-  if (packetUBXNAVDOP == NULL) initPacketUBXNAVDOP(); //Check that RAM has been allocated for the data
-  if (packetUBXNAVDOP == NULL) //Only attempt this if RAM allocation was successful
-    return false;
-
-  boolean changes = packetUBXNAVDOP->automaticFlags.flags.bits.automatic != enabled || packetUBXNAVDOP->automaticFlags.flags.bits.implicitUpdate != implicitUpdate;
-  if (changes)
-  {
-    packetUBXNAVDOP->automaticFlags.flags.bits.automatic = enabled;
-    packetUBXNAVDOP->automaticFlags.flags.bits.implicitUpdate = implicitUpdate;
-  }
-  return changes;
-}
-
-// PRIVATE: Allocate RAM for packetUBXNAVDOP and initialize it
-boolean SFE_UBLOX_GNSS::initPacketUBXNAVDOP()
-{
-  packetUBXNAVDOP = new UBX_NAV_DOP_t; //Allocate RAM for the main struct
-  if (packetUBXNAVDOP == NULL)
-  {
-    if ((_printDebug == true) || (_printLimitedDebug == true)) // This is important. Print this if doing limited debugging
-      _debugSerial->println(F("initPacketUBXNAVDOP: PANIC! RAM allocation failed!"));
-    return (false);
-  }
-  packetUBXNAVDOP->automaticFlags.flags.all = 0;
-  packetUBXNAVDOP->callbackPointer = NULL;
-  packetUBXNAVDOP->callbackData = NULL;
-  packetUBXNAVDOP->moduleQueried.moduleQueried.all = 0;
-  return (true);
-}
-
-//Mark all the DOP data as read/stale. This is handy to get data alignment after CRC failure
-void SFE_UBLOX_GNSS::flushDOP()
-{
-  if (packetUBXNAVDOP == NULL) return; // Bail if RAM has not been allocated (otherwise we could be writing anywhere!)
-  packetUBXNAVDOP->moduleQueried.moduleQueried.all = 0; //Mark all DOPs as stale (read before)
-}
-
-//Log this data in file buffer
-void SFE_UBLOX_GNSS::logNAVDOP(boolean enabled)
-{
-  if (packetUBXNAVDOP == NULL) return; // Bail if RAM has not been allocated (otherwise we could be writing anywhere!)
-  packetUBXNAVDOP->automaticFlags.flags.bits.addToFileBuffer = (uint8_t)enabled;
-}
-
-// ***** VEH ATT automatic support
-
-boolean SFE_UBLOX_GNSS::getVehAtt(uint16_t maxWait)
-{
-  return (getNAVATT(maxWait));
-}
-
-boolean SFE_UBLOX_GNSS::getNAVATT(uint16_t maxWait)
-{
-  if (packetUBXNAVATT == NULL) initPacketUBXNAVATT(); //Check that RAM has been allocated for the ESF RAW data
-  if (packetUBXNAVATT == NULL) //Only attempt this if RAM allocation was successful
-    return false;
-
-  if (packetUBXNAVATT->automaticFlags.flags.bits.automatic && packetUBXNAVATT->automaticFlags.flags.bits.implicitUpdate)
-  {
-    //The GPS is automatically reporting, we just check whether we got unread data
-    checkUbloxInternal(&packetCfg, UBX_CLASS_NAV, UBX_NAV_ATT);
-    return packetUBXNAVATT->moduleQueried.moduleQueried.bits.all;
-  }
-  else if (packetUBXNAVATT->automaticFlags.flags.bits.automatic && !packetUBXNAVATT->automaticFlags.flags.bits.implicitUpdate)
-  {
-    //Someone else has to call checkUblox for us...
-    return (false);
-  }
-  else
-  {
-    //The GPS is not automatically reporting HNR PVT so we have to poll explicitly
-    packetCfg.cls = UBX_CLASS_NAV;
-    packetCfg.id = UBX_NAV_ATT;
-    packetCfg.len = 0;
-    packetCfg.startingSpot = 0;
-
-    //The data is parsed as part of processing the response
-    sfe_ublox_status_e retVal = sendCommand(&packetCfg, maxWait);
-
-    if (retVal == SFE_UBLOX_STATUS_DATA_RECEIVED)
-      return (true);
-
-    if (retVal == SFE_UBLOX_STATUS_DATA_OVERWRITTEN)
-    {
-      return (true);
-    }
-
-    return (false);
-  }
-
-  return (false); // Trap. We should never get here...
-}
-
-//Enable or disable automatic NAV ATT message generation by the GNSS. This changes the way getVehAtt
-//works.
-boolean SFE_UBLOX_GNSS::setAutoNAVATT(boolean enable, uint16_t maxWait)
-{
-  return setAutoNAVATTrate(enable ? 1 : 0, true, maxWait);
-}
-
-//Enable or disable automatic NAV ATT message generation by the GNSS. This changes the way getVehAtt
-//works.
-boolean SFE_UBLOX_GNSS::setAutoNAVATT(boolean enable, boolean implicitUpdate, uint16_t maxWait)
-{
-  return setAutoNAVATTrate(enable ? 1 : 0, implicitUpdate, maxWait);
-}
-
-//Enable or disable automatic NAV ATT attitude message generation by the GNSS. This changes the way getVehAtt
-//works.
-boolean SFE_UBLOX_GNSS::setAutoNAVATTrate(uint8_t rate, boolean implicitUpdate, uint16_t maxWait)
-{
-  if (packetUBXNAVATT == NULL) initPacketUBXNAVATT(); //Check that RAM has been allocated for the data
-  if (packetUBXNAVATT == NULL) //Only attempt this if RAM allocation was successful
-    return false;
-
-  if (rate > 127) rate = 127;
-
-  packetCfg.cls = UBX_CLASS_CFG;
-  packetCfg.id = UBX_CFG_MSG;
-  packetCfg.len = 3;
-  packetCfg.startingSpot = 0;
-  payloadCfg[0] = UBX_CLASS_NAV;
-  payloadCfg[1] = UBX_NAV_ATT;
-  payloadCfg[2] = rate; // rate relative to navigation freq.
-
-  boolean ok = ((sendCommand(&packetCfg, maxWait)) == SFE_UBLOX_STATUS_DATA_SENT); // We are only expecting an ACK
-  if (ok)
-  {
-    packetUBXNAVATT->automaticFlags.flags.bits.automatic = (rate > 0);
-    packetUBXNAVATT->automaticFlags.flags.bits.implicitUpdate = implicitUpdate;
-  }
-  packetUBXNAVATT->moduleQueried.moduleQueried.bits.all = false; // Mark data as stale
-  return ok;
-}
-
-//Enable automatic navigation message generation by the GNSS.
-boolean SFE_UBLOX_GNSS::setAutoNAVATTcallback(void (*callbackPointer)(UBX_NAV_ATT_data_t), uint16_t maxWait)
-{
-  // Enable auto messages. Set implicitUpdate to false as we expect the user to call checkUblox manually.
-  boolean result = setAutoNAVATT(true, false, maxWait);
-  if (!result)
-    return (result); // Bail if setAuto failed
-
-  if (packetUBXNAVATT->callbackData == NULL) //Check if RAM has been allocated for the callback copy
-  {
-    packetUBXNAVATT->callbackData = new UBX_NAV_ATT_data_t; //Allocate RAM for the main struct
-  }
-
-  if (packetUBXNAVATT->callbackData == NULL)
-  {
-    if ((_printDebug == true) || (_printLimitedDebug == true)) // This is important. Print this if doing limited debugging
-      _debugSerial->println(F("setAutoNAVATTcallback: PANIC! RAM allocation failed!"));
-    return (false);
-  }
-
-  packetUBXNAVATT->callbackPointer = callbackPointer;
-  return (true);
-}
-
-//In case no config access to the GNSS is possible and NAV ATT attitude is send cyclically already
-//set config to suitable parameters
-boolean SFE_UBLOX_GNSS::assumeAutoNAVATT(boolean enabled, boolean implicitUpdate)
-{
-  if (packetUBXNAVATT == NULL) initPacketUBXNAVATT(); //Check that RAM has been allocated for the ESF RAW data
-  if (packetUBXNAVATT == NULL) //Only attempt this if RAM allocation was successful
-    return false;
-
-  boolean changes = packetUBXNAVATT->automaticFlags.flags.bits.automatic != enabled || packetUBXNAVATT->automaticFlags.flags.bits.implicitUpdate != implicitUpdate;
-  if (changes)
-  {
-    packetUBXNAVATT->automaticFlags.flags.bits.automatic = enabled;
-    packetUBXNAVATT->automaticFlags.flags.bits.implicitUpdate = implicitUpdate;
-  }
-  return changes;
-}
-
-// PRIVATE: Allocate RAM for packetUBXNAVATT and initialize it
-boolean SFE_UBLOX_GNSS::initPacketUBXNAVATT()
-{
-  packetUBXNAVATT = new UBX_NAV_ATT_t; //Allocate RAM for the main struct
-  if (packetUBXNAVATT == NULL)
-  {
-    if ((_printDebug == true) || (_printLimitedDebug == true)) // This is important. Print this if doing limited debugging
-      _debugSerial->println(F("initPacketUBXNAVATT: PANIC! RAM allocation failed!"));
-    return (false);
-  }
-  packetUBXNAVATT->automaticFlags.flags.all = 0;
-  packetUBXNAVATT->callbackPointer = NULL;
-  packetUBXNAVATT->callbackData = NULL;
-  packetUBXNAVATT->moduleQueried.moduleQueried.all = 0;
-  return (true);
-}
-
-//Mark all the DOP data as read/stale. This is handy to get data alignment after CRC failure
-void SFE_UBLOX_GNSS::flushNAVATT()
-{
-  if (packetUBXNAVATT == NULL) return; // Bail if RAM has not been allocated (otherwise we could be writing anywhere!)
-  packetUBXNAVATT->moduleQueried.moduleQueried.all = 0; //Mark all DOPs as stale (read before)
-}
-
-//Log this data in file buffer
-void SFE_UBLOX_GNSS::logNAVATT(boolean enabled)
-{
-  if (packetUBXNAVATT == NULL) return; // Bail if RAM has not been allocated (otherwise we could be writing anywhere!)
-  packetUBXNAVATT->automaticFlags.flags.bits.addToFileBuffer = (uint8_t)enabled;
-}
-
-// ***** PVT automatic support
-
-//Get the latest Position/Velocity/Time solution and fill all global variables
-boolean SFE_UBLOX_GNSS::getPVT(uint16_t maxWait)
-{
-  if (packetUBXNAVPVT == NULL) initPacketUBXNAVPVT(); //Check that RAM has been allocated for the PVT data
-  if (packetUBXNAVPVT == NULL) //Bail if the RAM allocation failed
-    return (false);
-
-  if (packetUBXNAVPVT->automaticFlags.flags.bits.automatic && packetUBXNAVPVT->automaticFlags.flags.bits.implicitUpdate)
-  {
-    //The GPS is automatically reporting, we just check whether we got unread data
-    // if (_printDebug == true)
-    // {
-    //   _debugSerial->println(F("getPVT: Autoreporting"));
-    // }
-    checkUbloxInternal(&packetCfg, UBX_CLASS_NAV, UBX_NAV_PVT);
-    return packetUBXNAVPVT->moduleQueried.moduleQueried1.bits.all;
-  }
-  else if (packetUBXNAVPVT->automaticFlags.flags.bits.automatic && !packetUBXNAVPVT->automaticFlags.flags.bits.implicitUpdate)
-  {
-    //Someone else has to call checkUblox for us...
-    // if (_printDebug == true)
-    // {
-    //   _debugSerial->println(F("getPVT: Exit immediately"));
-    // }
-    return (false);
-  }
-  else
-  {
-    // if (_printDebug == true)
-    // {
-    //   _debugSerial->println(F("getPVT: Polling"));
-    // }
-
-    //The GPS is not automatically reporting navigation position so we have to poll explicitly
-    packetCfg.cls = UBX_CLASS_NAV;
-    packetCfg.id = UBX_NAV_PVT;
-    packetCfg.len = 0;
-    packetCfg.startingSpot = 0;
-    //packetCfg.startingSpot = 20; //Begin listening at spot 20 so we can record up to 20+packetCfgPayloadSize = 84 bytes Note:now hard-coded in processUBX
-
-    //The data is parsed as part of processing the response
-    sfe_ublox_status_e retVal = sendCommand(&packetCfg, maxWait);
-
-    if (retVal == SFE_UBLOX_STATUS_DATA_RECEIVED)
-      return (true);
-
-    if (retVal == SFE_UBLOX_STATUS_DATA_OVERWRITTEN)
-    {
-      // if (_printDebug == true)
-      // {
-      //   _debugSerial->println(F("getPVT: data in packetCfg was OVERWRITTEN by another message (but that's OK)"));
-      // }
-      return (true);
-    }
-
-    // if (_printDebug == true)
-    // {
-    //   _debugSerial->print(F("getPVT retVal: "));
-    //   _debugSerial->println(statusString(retVal));
-    // }
-    return (false);
-  }
-}
-
-//Enable or disable automatic navigation message generation by the GNSS. This changes the way getPVT
-//works.
-boolean SFE_UBLOX_GNSS::setAutoPVT(boolean enable, uint16_t maxWait)
-{
-  return setAutoPVTrate(enable ? 1 : 0, true, maxWait);
-}
-
-//Enable or disable automatic navigation message generation by the GNSS. This changes the way getPVT
-//works.
-boolean SFE_UBLOX_GNSS::setAutoPVT(boolean enable, boolean implicitUpdate, uint16_t maxWait)
-{
-  return setAutoPVTrate(enable ? 1 : 0, implicitUpdate, maxWait);
-}
-
-//Enable or disable automatic navigation message generation by the GNSS. This changes the way getPVT
-//works.
-boolean SFE_UBLOX_GNSS::setAutoPVTrate(uint8_t rate, boolean implicitUpdate, uint16_t maxWait)
-{
-  if (packetUBXNAVPVT == NULL) initPacketUBXNAVPVT(); //Check that RAM has been allocated for the PVT data
-  if (packetUBXNAVPVT == NULL) //Only attempt this if RAM allocation was successful
-    return false;
-
-  if (rate > 127) rate = 127;
-
-  packetCfg.cls = UBX_CLASS_CFG;
-  packetCfg.id = UBX_CFG_MSG;
-  packetCfg.len = 3;
-  packetCfg.startingSpot = 0;
-  payloadCfg[0] = UBX_CLASS_NAV;
-  payloadCfg[1] = UBX_NAV_PVT;
-  payloadCfg[2] = rate; // rate relative to navigation freq.
-
-  boolean ok = ((sendCommand(&packetCfg, maxWait)) == SFE_UBLOX_STATUS_DATA_SENT); // We are only expecting an ACK
-  if (ok)
-  {
-    packetUBXNAVPVT->automaticFlags.flags.bits.automatic = (rate > 0);
-    packetUBXNAVPVT->automaticFlags.flags.bits.implicitUpdate = implicitUpdate;
-  }
-  packetUBXNAVPVT->moduleQueried.moduleQueried1.bits.all = false;
-  return ok;
-}
-
-//Enable automatic navigation message generation by the GNSS. This changes the way getPVT works.
-boolean SFE_UBLOX_GNSS::setAutoPVTcallback(void (*callbackPointer)(UBX_NAV_PVT_data_t), uint16_t maxWait)
-{
-  // Enable auto messages. Set implicitUpdate to false as we expect the user to call checkUblox manually.
-  boolean result = setAutoPVT(true, false, maxWait);
-  if (!result)
-    return (result); // Bail if setAutoPVT failed
-
-  if (packetUBXNAVPVT->callbackData == NULL) //Check if RAM has been allocated for the callback copy
-  {
-    packetUBXNAVPVT->callbackData = new UBX_NAV_PVT_data_t; //Allocate RAM for the main struct
-  }
-
-  if (packetUBXNAVPVT->callbackData == NULL)
-  {
-    if ((_printDebug == true) || (_printLimitedDebug == true)) // This is important. Print this if doing limited debugging
-      _debugSerial->println(F("setAutoPVTcallback: PANIC! RAM allocation failed!"));
-    return (false);
-  }
-
-  packetUBXNAVPVT->callbackPointer = callbackPointer; // RAM has been allocated so now update the pointer
-
-  return (true);
-}
-
-//In case no config access to the GNSS is possible and PVT is send cyclically already
-//set config to suitable parameters
-boolean SFE_UBLOX_GNSS::assumeAutoPVT(boolean enabled, boolean implicitUpdate)
-{
-  if (packetUBXNAVPVT == NULL) initPacketUBXNAVPVT(); //Check that RAM has been allocated for the PVT data
-  if (packetUBXNAVPVT == NULL) //Only attempt this if RAM allocation was successful
-    return false;
-
-  boolean changes = packetUBXNAVPVT->automaticFlags.flags.bits.automatic != enabled || packetUBXNAVPVT->automaticFlags.flags.bits.implicitUpdate != implicitUpdate;
-  if (changes)
-  {
-      packetUBXNAVPVT->automaticFlags.flags.bits.automatic = enabled;
-      packetUBXNAVPVT->automaticFlags.flags.bits.implicitUpdate = implicitUpdate;
-  }
-  return changes;
-}
-
-// PRIVATE: Allocate RAM for packetUBXNAVPVT and initialize it
-boolean SFE_UBLOX_GNSS::initPacketUBXNAVPVT()
-{
-  packetUBXNAVPVT = new UBX_NAV_PVT_t; //Allocate RAM for the main struct
-  if (packetUBXNAVPVT == NULL)
-  {
-    if ((_printDebug == true) || (_printLimitedDebug == true)) // This is important. Print this if doing limited debugging
-      _debugSerial->println(F("initPacketUBXNAVPVT: PANIC! RAM allocation failed!"));
-    return (false);
-  }
-  packetUBXNAVPVT->automaticFlags.flags.all = 0;
-  packetUBXNAVPVT->callbackPointer = NULL;
-  packetUBXNAVPVT->callbackData = NULL;
-  packetUBXNAVPVT->moduleQueried.moduleQueried1.all = 0;
-  packetUBXNAVPVT->moduleQueried.moduleQueried2.all = 0;
-  return (true);
-}
-
-//Mark all the PVT data as read/stale. This is handy to get data alignment after CRC failure
-void SFE_UBLOX_GNSS::flushPVT()
-{
-  if (packetUBXNAVPVT == NULL) return; // Bail if RAM has not been allocated (otherwise we could be writing anywhere!)
-  packetUBXNAVPVT->moduleQueried.moduleQueried1.all = 0; //Mark all datums as stale (read before)
-  packetUBXNAVPVT->moduleQueried.moduleQueried2.all = 0;
-}
-
-//Log this data in file buffer
-void SFE_UBLOX_GNSS::logNAVPVT(boolean enabled)
-{
-  if (packetUBXNAVPVT == NULL) return; // Bail if RAM has not been allocated (otherwise we could be writing anywhere!)
-  packetUBXNAVPVT->automaticFlags.flags.bits.addToFileBuffer = (uint8_t)enabled;
-}
-
-// ***** NAV ODO automatic support
-
-boolean SFE_UBLOX_GNSS::getNAVODO(uint16_t maxWait)
-{
-  if (packetUBXNAVODO == NULL) initPacketUBXNAVODO(); //Check that RAM has been allocated for the ODO data
-  if (packetUBXNAVODO == NULL) //Bail if the RAM allocation failed
-    return (false);
-
-  if (packetUBXNAVODO->automaticFlags.flags.bits.automatic && packetUBXNAVODO->automaticFlags.flags.bits.implicitUpdate)
-  {
-    //The GPS is automatically reporting, we just check whether we got unread data
-    checkUbloxInternal(&packetCfg, UBX_CLASS_NAV, UBX_NAV_ODO);
-    return packetUBXNAVODO->moduleQueried.moduleQueried.bits.all;
-  }
-  else if (packetUBXNAVODO->automaticFlags.flags.bits.automatic && !packetUBXNAVODO->automaticFlags.flags.bits.implicitUpdate)
-  {
-    //Someone else has to call checkUblox for us...
-    return (false);
-  }
-  else
-  {
-    //The GPS is not automatically reporting navigation position so we have to poll explicitly
-    packetCfg.cls = UBX_CLASS_NAV;
-    packetCfg.id = UBX_NAV_ODO;
-    packetCfg.len = 0;
-    packetCfg.startingSpot = 0;
-
-    //The data is parsed as part of processing the response
-    sfe_ublox_status_e retVal = sendCommand(&packetCfg, maxWait);
-
-    if (retVal == SFE_UBLOX_STATUS_DATA_RECEIVED)
-      return (true);
-
-    if (retVal == SFE_UBLOX_STATUS_DATA_OVERWRITTEN)
-    {
-      return (true);
-    }
-
-    return (false);
-  }
-}
-
-//Enable or disable automatic navigation message generation by the GNSS. This changes the way getODO
-//works.
-boolean SFE_UBLOX_GNSS::setAutoNAVODO(boolean enable, uint16_t maxWait)
-{
-  return setAutoNAVODOrate(enable ? 1 : 0, true, maxWait);
-}
-
-//Enable or disable automatic navigation message generation by the GNSS. This changes the way getODO
-//works.
-boolean SFE_UBLOX_GNSS::setAutoNAVODO(boolean enable, boolean implicitUpdate, uint16_t maxWait)
-{
-  return setAutoNAVODOrate(enable ? 1 : 0, implicitUpdate, maxWait);
-}
-
-//Enable or disable automatic navigation message generation by the GNSS. This changes the way getODO
-//works.
-boolean SFE_UBLOX_GNSS::setAutoNAVODOrate(uint8_t rate, boolean implicitUpdate, uint16_t maxWait)
-{
-  if (packetUBXNAVODO == NULL) initPacketUBXNAVODO(); //Check that RAM has been allocated for the data
-  if (packetUBXNAVODO == NULL) //Only attempt this if RAM allocation was successful
-    return false;
-
-  if (rate > 127) rate = 127;
-
-  packetCfg.cls = UBX_CLASS_CFG;
-  packetCfg.id = UBX_CFG_MSG;
-  packetCfg.len = 3;
-  packetCfg.startingSpot = 0;
-  payloadCfg[0] = UBX_CLASS_NAV;
-  payloadCfg[1] = UBX_NAV_ODO;
-  payloadCfg[2] = rate; // rate relative to navigation freq.
-
-  boolean ok = ((sendCommand(&packetCfg, maxWait)) == SFE_UBLOX_STATUS_DATA_SENT); // We are only expecting an ACK
-  if (ok)
-  {
-    packetUBXNAVODO->automaticFlags.flags.bits.automatic = (rate > 0);
-    packetUBXNAVODO->automaticFlags.flags.bits.implicitUpdate = implicitUpdate;
-  }
-  packetUBXNAVODO->moduleQueried.moduleQueried.bits.all = false;
-  return ok;
-}
-
-//Enable automatic navigation message generation by the GNSS.
-boolean SFE_UBLOX_GNSS::setAutoNAVODOcallback(void (*callbackPointer)(UBX_NAV_ODO_data_t), uint16_t maxWait)
-{
-  // Enable auto messages. Set implicitUpdate to false as we expect the user to call checkUblox manually.
-  boolean result = setAutoNAVODO(true, false, maxWait);
-  if (!result)
-    return (result); // Bail if setAuto failed
-
-  if (packetUBXNAVODO->callbackData == NULL) //Check if RAM has been allocated for the callback copy
-  {
-    packetUBXNAVODO->callbackData = new UBX_NAV_ODO_data_t; //Allocate RAM for the main struct
-  }
-
-  if (packetUBXNAVODO->callbackData == NULL)
-  {
-    if ((_printDebug == true) || (_printLimitedDebug == true)) // This is important. Print this if doing limited debugging
-      _debugSerial->println(F("setAutoNAVODOcallback: PANIC! RAM allocation failed!"));
-    return (false);
-  }
-
-  packetUBXNAVODO->callbackPointer = callbackPointer;
-  return (true);
-}
-
-//In case no config access to the GNSS is possible and ODO is send cyclically already
-//set config to suitable parameters
-boolean SFE_UBLOX_GNSS::assumeAutoNAVODO(boolean enabled, boolean implicitUpdate)
-{
-  if (packetUBXNAVODO == NULL) initPacketUBXNAVODO(); //Check that RAM has been allocated for the data
-  if (packetUBXNAVODO == NULL) //Only attempt this if RAM allocation was successful
-    return false;
-
-  boolean changes = packetUBXNAVODO->automaticFlags.flags.bits.automatic != enabled || packetUBXNAVODO->automaticFlags.flags.bits.implicitUpdate != implicitUpdate;
-  if (changes)
-  {
-    packetUBXNAVODO->automaticFlags.flags.bits.automatic = enabled;
-    packetUBXNAVODO->automaticFlags.flags.bits.implicitUpdate = implicitUpdate;
-  }
-  return changes;
-}
-
-// PRIVATE: Allocate RAM for packetUBXNAVODO and initialize it
-boolean SFE_UBLOX_GNSS::initPacketUBXNAVODO()
-{
-  packetUBXNAVODO = new UBX_NAV_ODO_t; //Allocate RAM for the main struct
-  if (packetUBXNAVODO == NULL)
-  {
-    if ((_printDebug == true) || (_printLimitedDebug == true)) // This is important. Print this if doing limited debugging
-      _debugSerial->println(F("initPacketUBXNAVODO: PANIC! RAM allocation failed!"));
-    return (false);
-  }
-  packetUBXNAVODO->automaticFlags.flags.all = 0;
-  packetUBXNAVODO->callbackPointer = NULL;
-  packetUBXNAVODO->callbackData = NULL;
-  packetUBXNAVODO->moduleQueried.moduleQueried.all = 0;
-  return (true);
-}
-
-//Mark all the data as read/stale
-void SFE_UBLOX_GNSS::flushNAVODO()
-{
-  if (packetUBXNAVODO == NULL) return; // Bail if RAM has not been allocated (otherwise we could be writing anywhere!)
-  packetUBXNAVODO->moduleQueried.moduleQueried.all = 0; //Mark all datums as stale (read before)
-}
-
-//Log this data in file buffer
-void SFE_UBLOX_GNSS::logNAVODO(boolean enabled)
-{
-  if (packetUBXNAVODO == NULL) return; // Bail if RAM has not been allocated (otherwise we could be writing anywhere!)
-  packetUBXNAVODO->automaticFlags.flags.bits.addToFileBuffer = (uint8_t)enabled;
-}
-
-// ***** NAV VELECEF automatic support
-
-boolean SFE_UBLOX_GNSS::getNAVVELECEF(uint16_t maxWait)
-{
-  if (packetUBXNAVVELECEF == NULL) initPacketUBXNAVVELECEF(); //Check that RAM has been allocated for the VELECEF data
-  if (packetUBXNAVVELECEF == NULL) //Bail if the RAM allocation failed
-    return (false);
-
-  if (packetUBXNAVVELECEF->automaticFlags.flags.bits.automatic && packetUBXNAVVELECEF->automaticFlags.flags.bits.implicitUpdate)
-  {
-    //The GPS is automatically reporting, we just check whether we got unread data
-    checkUbloxInternal(&packetCfg, UBX_CLASS_NAV, UBX_NAV_VELECEF);
-    return packetUBXNAVVELECEF->moduleQueried.moduleQueried.bits.all;
-  }
-  else if (packetUBXNAVVELECEF->automaticFlags.flags.bits.automatic && !packetUBXNAVVELECEF->automaticFlags.flags.bits.implicitUpdate)
-  {
-    //Someone else has to call checkUblox for us...
-    return (false);
-  }
-  else
-  {
-    //The GPS is not automatically reporting navigation position so we have to poll explicitly
-    packetCfg.cls = UBX_CLASS_NAV;
-    packetCfg.id = UBX_NAV_VELECEF;
-    packetCfg.len = 0;
-    packetCfg.startingSpot = 0;
-
-    //The data is parsed as part of processing the response
-    sfe_ublox_status_e retVal = sendCommand(&packetCfg, maxWait);
-
-    if (retVal == SFE_UBLOX_STATUS_DATA_RECEIVED)
-      return (true);
-
-    if (retVal == SFE_UBLOX_STATUS_DATA_OVERWRITTEN)
-    {
-      return (true);
-    }
-
-    return (false);
-  }
-}
-
-//Enable or disable automatic navigation message generation by the GNSS. This changes the way getVELECEF
-//works.
-boolean SFE_UBLOX_GNSS::setAutoNAVVELECEF(boolean enable, uint16_t maxWait)
-{
-  return setAutoNAVVELECEFrate(enable ? 1 : 0, true, maxWait);
-}
-
-//Enable or disable automatic navigation message generation by the GNSS. This changes the way getVELECEF
-//works.
-boolean SFE_UBLOX_GNSS::setAutoNAVVELECEF(boolean enable, boolean implicitUpdate, uint16_t maxWait)
-{
-  return setAutoNAVVELECEFrate(enable ? 1 : 0, implicitUpdate, maxWait);
-}
-
-//Enable or disable automatic navigation message generation by the GNSS. This changes the way getVELECEF
-//works.
-boolean SFE_UBLOX_GNSS::setAutoNAVVELECEFrate(uint8_t rate, boolean implicitUpdate, uint16_t maxWait)
-{
-  if (packetUBXNAVVELECEF == NULL) initPacketUBXNAVVELECEF(); //Check that RAM has been allocated for the data
-  if (packetUBXNAVVELECEF == NULL) //Only attempt this if RAM allocation was successful
-    return false;
-
-  if (rate > 127) rate = 127;
-
-  packetCfg.cls = UBX_CLASS_CFG;
-  packetCfg.id = UBX_CFG_MSG;
-  packetCfg.len = 3;
-  packetCfg.startingSpot = 0;
-  payloadCfg[0] = UBX_CLASS_NAV;
-  payloadCfg[1] = UBX_NAV_VELECEF;
-  payloadCfg[2] = rate; // rate relative to navigation freq.
-
-  boolean ok = ((sendCommand(&packetCfg, maxWait)) == SFE_UBLOX_STATUS_DATA_SENT); // We are only expecting an ACK
-  if (ok)
-  {
-    packetUBXNAVVELECEF->automaticFlags.flags.bits.automatic = (rate > 0);
-    packetUBXNAVVELECEF->automaticFlags.flags.bits.implicitUpdate = implicitUpdate;
-  }
-  packetUBXNAVVELECEF->moduleQueried.moduleQueried.bits.all = false;
-  return ok;
-}
-
-//Enable automatic navigation message generation by the GNSS.
-boolean SFE_UBLOX_GNSS::setAutoNAVVELECEFcallback(void (*callbackPointer)(UBX_NAV_VELECEF_data_t), uint16_t maxWait)
-{
-  // Enable auto messages. Set implicitUpdate to false as we expect the user to call checkUblox manually.
-  boolean result = setAutoNAVVELECEF(true, false, maxWait);
-  if (!result)
-    return (result); // Bail if setAuto failed
-
-  if (packetUBXNAVVELECEF->callbackData == NULL) //Check if RAM has been allocated for the callback copy
-  {
-    packetUBXNAVVELECEF->callbackData = new UBX_NAV_VELECEF_data_t; //Allocate RAM for the main struct
-  }
-
-  if (packetUBXNAVVELECEF->callbackData == NULL)
-  {
-    if ((_printDebug == true) || (_printLimitedDebug == true)) // This is important. Print this if doing limited debugging
-      _debugSerial->println(F("setAutoNAVVELECEFcallback: PANIC! RAM allocation failed!"));
-    return (false);
-  }
-
-  packetUBXNAVVELECEF->callbackPointer = callbackPointer;
-  return (true);
-}
-
-//In case no config access to the GNSS is possible and VELECEF is send cyclically already
-//set config to suitable parameters
-boolean SFE_UBLOX_GNSS::assumeAutoNAVVELECEF(boolean enabled, boolean implicitUpdate)
-{
-  if (packetUBXNAVVELECEF == NULL) initPacketUBXNAVVELECEF(); //Check that RAM has been allocated for the data
-  if (packetUBXNAVVELECEF == NULL) //Only attempt this if RAM allocation was successful
-    return false;
-
-  boolean changes = packetUBXNAVVELECEF->automaticFlags.flags.bits.automatic != enabled || packetUBXNAVVELECEF->automaticFlags.flags.bits.implicitUpdate != implicitUpdate;
-  if (changes)
-  {
-    packetUBXNAVVELECEF->automaticFlags.flags.bits.automatic = enabled;
-    packetUBXNAVVELECEF->automaticFlags.flags.bits.implicitUpdate = implicitUpdate;
-  }
-  return changes;
-}
-
-// PRIVATE: Allocate RAM for packetUBXNAVVELECEF and initialize it
-boolean SFE_UBLOX_GNSS::initPacketUBXNAVVELECEF()
-{
-  packetUBXNAVVELECEF = new UBX_NAV_VELECEF_t; //Allocate RAM for the main struct
-  if (packetUBXNAVVELECEF == NULL)
-  {
-    if ((_printDebug == true) || (_printLimitedDebug == true)) // This is important. Print this if doing limited debugging
-      _debugSerial->println(F("initPacketUBXNAVVELECEF: PANIC! RAM allocation failed!"));
-    return (false);
-  }
-  packetUBXNAVVELECEF->automaticFlags.flags.all = 0;
-  packetUBXNAVVELECEF->callbackPointer = NULL;
-  packetUBXNAVVELECEF->callbackData = NULL;
-  packetUBXNAVVELECEF->moduleQueried.moduleQueried.all = 0;
-  return (true);
-}
-
-//Mark all the data as read/stale
-void SFE_UBLOX_GNSS::flushNAVVELECEF()
-{
-  if (packetUBXNAVVELECEF == NULL) return; // Bail if RAM has not been allocated (otherwise we could be writing anywhere!)
-  packetUBXNAVVELECEF->moduleQueried.moduleQueried.all = 0; //Mark all datums as stale (read before)
-}
-
-//Log this data in file buffer
-void SFE_UBLOX_GNSS::logNAVVELECEF(boolean enabled)
-{
-  if (packetUBXNAVVELECEF == NULL) return; // Bail if RAM has not been allocated (otherwise we could be writing anywhere!)
-  packetUBXNAVVELECEF->automaticFlags.flags.bits.addToFileBuffer = (uint8_t)enabled;
-}
-
-// ***** NAV VELNED automatic support
-
-boolean SFE_UBLOX_GNSS::getNAVVELNED(uint16_t maxWait)
-{
-  if (packetUBXNAVVELNED == NULL) initPacketUBXNAVVELNED(); //Check that RAM has been allocated for the VELNED data
-  if (packetUBXNAVVELNED == NULL) //Bail if the RAM allocation failed
-    return (false);
-
-  if (packetUBXNAVVELNED->automaticFlags.flags.bits.automatic && packetUBXNAVVELNED->automaticFlags.flags.bits.implicitUpdate)
-  {
-    //The GPS is automatically reporting, we just check whether we got unread data
-    checkUbloxInternal(&packetCfg, UBX_CLASS_NAV, UBX_NAV_VELNED);
-    return packetUBXNAVVELNED->moduleQueried.moduleQueried.bits.all;
-  }
-  else if (packetUBXNAVVELNED->automaticFlags.flags.bits.automatic && !packetUBXNAVVELNED->automaticFlags.flags.bits.implicitUpdate)
-  {
-    //Someone else has to call checkUblox for us...
-    return (false);
-  }
-  else
-  {
-    //The GPS is not automatically reporting navigation position so we have to poll explicitly
-    packetCfg.cls = UBX_CLASS_NAV;
-    packetCfg.id = UBX_NAV_VELNED;
-    packetCfg.len = 0;
-    packetCfg.startingSpot = 0;
-
-    //The data is parsed as part of processing the response
-    sfe_ublox_status_e retVal = sendCommand(&packetCfg, maxWait);
-
-    if (retVal == SFE_UBLOX_STATUS_DATA_RECEIVED)
-      return (true);
-
-    if (retVal == SFE_UBLOX_STATUS_DATA_OVERWRITTEN)
-    {
-      return (true);
-    }
-
-    return (false);
-  }
-}
-
-//Enable or disable automatic navigation message generation by the GNSS. This changes the way getVELNED
-//works.
-boolean SFE_UBLOX_GNSS::setAutoNAVVELNED(boolean enable, uint16_t maxWait)
-{
-  return setAutoNAVVELNEDrate(enable ? 1 : 0, true, maxWait);
-}
-
-//Enable or disable automatic navigation message generation by the GNSS. This changes the way getVELNED
-//works.
-boolean SFE_UBLOX_GNSS::setAutoNAVVELNED(boolean enable, boolean implicitUpdate, uint16_t maxWait)
-{
-  return setAutoNAVVELNEDrate(enable ? 1 : 0, implicitUpdate, maxWait);
-}
-
-//Enable or disable automatic navigation message generation by the GNSS. This changes the way getVELNED
-//works.
-boolean SFE_UBLOX_GNSS::setAutoNAVVELNEDrate(uint8_t rate, boolean implicitUpdate, uint16_t maxWait)
-{
-  if (packetUBXNAVVELNED == NULL) initPacketUBXNAVVELNED(); //Check that RAM has been allocated for the data
-  if (packetUBXNAVVELNED == NULL) //Only attempt this if RAM allocation was successful
-    return false;
-
-  packetCfg.cls = UBX_CLASS_CFG;
-  packetCfg.id = UBX_CFG_MSG;
-  packetCfg.len = 3;
-  packetCfg.startingSpot = 0;
-  payloadCfg[0] = UBX_CLASS_NAV;
-  payloadCfg[1] = UBX_NAV_VELNED;
-  payloadCfg[2] = rate; // rate relative to navigation freq.
-
-  boolean ok = ((sendCommand(&packetCfg, maxWait)) == SFE_UBLOX_STATUS_DATA_SENT); // We are only expecting an ACK
-  if (ok)
-  {
-    packetUBXNAVVELNED->automaticFlags.flags.bits.automatic = (rate > 0);
-    packetUBXNAVVELNED->automaticFlags.flags.bits.implicitUpdate = implicitUpdate;
-  }
-  packetUBXNAVVELNED->moduleQueried.moduleQueried.bits.all = false;
-  return ok;
-}
-
-//Enable automatic navigation message generation by the GNSS.
-boolean SFE_UBLOX_GNSS::setAutoNAVVELNEDcallback(void (*callbackPointer)(UBX_NAV_VELNED_data_t), uint16_t maxWait)
-{
-  // Enable auto messages. Set implicitUpdate to false as we expect the user to call checkUblox manually.
-  boolean result = setAutoNAVVELNED(true, false, maxWait);
-  if (!result)
-    return (result); // Bail if setAuto failed
-
-  if (packetUBXNAVVELNED->callbackData == NULL) //Check if RAM has been allocated for the callback copy
-  {
-    packetUBXNAVVELNED->callbackData = new UBX_NAV_VELNED_data_t; //Allocate RAM for the main struct
-  }
-
-  if (packetUBXNAVVELNED->callbackData == NULL)
-  {
-    if ((_printDebug == true) || (_printLimitedDebug == true)) // This is important. Print this if doing limited debugging
-      _debugSerial->println(F("setAutoNAVVELNEDcallback: PANIC! RAM allocation failed!"));
-    return (false);
-  }
-
-  packetUBXNAVVELNED->callbackPointer = callbackPointer;
-  return (true);
-}
-
-//In case no config access to the GNSS is possible and VELNED is send cyclically already
-//set config to suitable parameters
-boolean SFE_UBLOX_GNSS::assumeAutoNAVVELNED(boolean enabled, boolean implicitUpdate)
-{
-  if (packetUBXNAVVELNED == NULL) initPacketUBXNAVVELNED(); //Check that RAM has been allocated for the data
-  if (packetUBXNAVVELNED == NULL) //Only attempt this if RAM allocation was successful
-    return false;
-
-  boolean changes = packetUBXNAVVELNED->automaticFlags.flags.bits.automatic != enabled || packetUBXNAVVELNED->automaticFlags.flags.bits.implicitUpdate != implicitUpdate;
-  if (changes)
-  {
-    packetUBXNAVVELNED->automaticFlags.flags.bits.automatic = enabled;
-    packetUBXNAVVELNED->automaticFlags.flags.bits.implicitUpdate = implicitUpdate;
-  }
-  return changes;
-}
-
-// PRIVATE: Allocate RAM for packetUBXNAVVELNED and initialize it
-boolean SFE_UBLOX_GNSS::initPacketUBXNAVVELNED()
-{
-  packetUBXNAVVELNED = new UBX_NAV_VELNED_t; //Allocate RAM for the main struct
-  if (packetUBXNAVVELNED == NULL)
-  {
-    if ((_printDebug == true) || (_printLimitedDebug == true)) // This is important. Print this if doing limited debugging
-      _debugSerial->println(F("initPacketUBXNAVVELNED: PANIC! RAM allocation failed!"));
-    return (false);
-  }
-  packetUBXNAVVELNED->automaticFlags.flags.all = 0;
-  packetUBXNAVVELNED->callbackPointer = NULL;
-  packetUBXNAVVELNED->callbackData = NULL;
-  packetUBXNAVVELNED->moduleQueried.moduleQueried.all = 0;
-  return (true);
-}
-
-//Mark all the data as read/stale
-void SFE_UBLOX_GNSS::flushNAVVELNED()
-{
-  if (packetUBXNAVVELNED == NULL) return; // Bail if RAM has not been allocated (otherwise we could be writing anywhere!
-  packetUBXNAVVELNED->moduleQueried.moduleQueried.all = 0; //Mark all datums as stale (read before)
-}
-
-//Log this data in file buffer
-void SFE_UBLOX_GNSS::logNAVVELNED(boolean enabled)
-{
-  if (packetUBXNAVVELNED == NULL) return; // Bail if RAM has not been allocated (otherwise we could be writing anywhere!)
-  packetUBXNAVVELNED->automaticFlags.flags.bits.addToFileBuffer = (uint8_t)enabled;
-}
-
-// ***** NAV HPPOSECEF automatic support
-
-boolean SFE_UBLOX_GNSS::getNAVHPPOSECEF(uint16_t maxWait)
-{
-  if (packetUBXNAVHPPOSECEF == NULL) initPacketUBXNAVHPPOSECEF(); //Check that RAM has been allocated for the HPPOSECEF data
-  if (packetUBXNAVHPPOSECEF == NULL) //Bail if the RAM allocation failed
-    return (false);
-
-  if (packetUBXNAVHPPOSECEF->automaticFlags.flags.bits.automatic && packetUBXNAVHPPOSECEF->automaticFlags.flags.bits.implicitUpdate)
-  {
-    //The GPS is automatically reporting, we just check whether we got unread data
-    checkUbloxInternal(&packetCfg, UBX_CLASS_NAV, UBX_NAV_HPPOSECEF);
-    return packetUBXNAVHPPOSECEF->moduleQueried.moduleQueried.bits.all;
-  }
-  else if (packetUBXNAVHPPOSECEF->automaticFlags.flags.bits.automatic && !packetUBXNAVHPPOSECEF->automaticFlags.flags.bits.implicitUpdate)
-  {
-    //Someone else has to call checkUblox for us...
-    return (false);
-  }
-  else
-  {
-    //The GPS is not automatically reporting navigation position so we have to poll explicitly
-    packetCfg.cls = UBX_CLASS_NAV;
-    packetCfg.id = UBX_NAV_HPPOSECEF;
-    packetCfg.len = 0;
-    packetCfg.startingSpot = 0;
-
-    //The data is parsed as part of processing the response
-    sfe_ublox_status_e retVal = sendCommand(&packetCfg, maxWait);
-
-    if (retVal == SFE_UBLOX_STATUS_DATA_RECEIVED)
-      return (true);
-
-    if (retVal == SFE_UBLOX_STATUS_DATA_OVERWRITTEN)
-    {
-      return (true);
-    }
-
-    return (false);
-  }
-}
-
-//Enable or disable automatic navigation message generation by the GNSS. This changes the way getHPPOSECEF
-//works.
-boolean SFE_UBLOX_GNSS::setAutoNAVHPPOSECEF(boolean enable, uint16_t maxWait)
-{
-  return setAutoNAVHPPOSECEFrate(enable ? 1 : 0, true, maxWait);
-}
-
-//Enable or disable automatic navigation message generation by the GNSS. This changes the way getHPPOSECEF
-//works.
-boolean SFE_UBLOX_GNSS::setAutoNAVHPPOSECEF(boolean enable, boolean implicitUpdate, uint16_t maxWait)
-{
-  return setAutoNAVHPPOSECEFrate(enable ? 1 : 0, implicitUpdate, maxWait);
-}
-
-//Enable or disable automatic navigation message generation by the GNSS. This changes the way getHPPOSECEF
-//works.
-boolean SFE_UBLOX_GNSS::setAutoNAVHPPOSECEFrate(uint8_t rate, boolean implicitUpdate, uint16_t maxWait)
-{
-  if (packetUBXNAVHPPOSECEF == NULL) initPacketUBXNAVHPPOSECEF(); //Check that RAM has been allocated for the data
-  if (packetUBXNAVHPPOSECEF == NULL) //Only attempt this if RAM allocation was successful
-    return false;
-
-  if (rate > 127) rate = 127;
-
-  packetCfg.cls = UBX_CLASS_CFG;
-  packetCfg.id = UBX_CFG_MSG;
-  packetCfg.len = 3;
-  packetCfg.startingSpot = 0;
-  payloadCfg[0] = UBX_CLASS_NAV;
-  payloadCfg[1] = UBX_NAV_HPPOSECEF;
-  payloadCfg[2] = rate; // rate relative to navigation freq.
-
-  boolean ok = ((sendCommand(&packetCfg, maxWait)) == SFE_UBLOX_STATUS_DATA_SENT); // We are only expecting an ACK
-  if (ok)
-  {
-    packetUBXNAVHPPOSECEF->automaticFlags.flags.bits.automatic = (rate > 0);
-    packetUBXNAVHPPOSECEF->automaticFlags.flags.bits.implicitUpdate = implicitUpdate;
-  }
-  packetUBXNAVHPPOSECEF->moduleQueried.moduleQueried.bits.all = false;
-  return ok;
-}
-
-//Enable automatic navigation message generation by the GNSS.
-boolean SFE_UBLOX_GNSS::setAutoNAVHPPOSECEFcallback(void (*callbackPointer)(UBX_NAV_HPPOSECEF_data_t), uint16_t maxWait)
-{
-  // Enable auto messages. Set implicitUpdate to false as we expect the user to call checkUblox manually.
-  boolean result = setAutoNAVHPPOSECEF(true, false, maxWait);
-  if (!result)
-    return (result); // Bail if setAuto failed
-
-  if (packetUBXNAVHPPOSECEF->callbackData == NULL) //Check if RAM has been allocated for the callback copy
-  {
-    packetUBXNAVHPPOSECEF->callbackData = new UBX_NAV_HPPOSECEF_data_t; //Allocate RAM for the main struct
-  }
-
-  if (packetUBXNAVHPPOSECEF->callbackData == NULL)
-  {
-    if ((_printDebug == true) || (_printLimitedDebug == true)) // This is important. Print this if doing limited debugging
-      _debugSerial->println(F("setAutoNAVHPPOSECEFcallback: PANIC! RAM allocation failed!"));
-    return (false);
-  }
-
-  packetUBXNAVHPPOSECEF->callbackPointer = callbackPointer;
-  return (true);
-}
-
-//In case no config access to the GNSS is possible and HPPOSECEF is send cyclically already
-//set config to suitable parameters
-boolean SFE_UBLOX_GNSS::assumeAutoNAVHPPOSECEF(boolean enabled, boolean implicitUpdate)
-{
-  if (packetUBXNAVHPPOSECEF == NULL) initPacketUBXNAVHPPOSECEF(); //Check that RAM has been allocated for the data
-  if (packetUBXNAVHPPOSECEF == NULL) //Only attempt this if RAM allocation was successful
-    return false;
-
-  boolean changes = packetUBXNAVHPPOSECEF->automaticFlags.flags.bits.automatic != enabled || packetUBXNAVHPPOSECEF->automaticFlags.flags.bits.implicitUpdate != implicitUpdate;
-  if (changes)
-  {
-    packetUBXNAVHPPOSECEF->automaticFlags.flags.bits.automatic = enabled;
-    packetUBXNAVHPPOSECEF->automaticFlags.flags.bits.implicitUpdate = implicitUpdate;
-  }
-  return changes;
-}
-
-// PRIVATE: Allocate RAM for packetUBXNAVHPPOSECEF and initialize it
-boolean SFE_UBLOX_GNSS::initPacketUBXNAVHPPOSECEF()
-{
-  packetUBXNAVHPPOSECEF = new UBX_NAV_HPPOSECEF_t; //Allocate RAM for the main struct
-  if (packetUBXNAVHPPOSECEF == NULL)
-  {
-    if ((_printDebug == true) || (_printLimitedDebug == true)) // This is important. Print this if doing limited debugging
-      _debugSerial->println(F("initPacketUBXNAVHPPOSECEF: PANIC! RAM allocation failed!"));
-    return (false);
-  }
-  packetUBXNAVHPPOSECEF->automaticFlags.flags.all = 0;
-  packetUBXNAVHPPOSECEF->callbackPointer = NULL;
-  packetUBXNAVHPPOSECEF->callbackData = NULL;
-  packetUBXNAVHPPOSECEF->moduleQueried.moduleQueried.all = 0;
-  return (true);
-}
-
-//Mark all the data as read/stale
-void SFE_UBLOX_GNSS::flushNAVHPPOSECEF()
-{
-  if (packetUBXNAVHPPOSECEF == NULL) return; // Bail if RAM has not been allocated (otherwise we could be writing anywhere!)
-  packetUBXNAVHPPOSECEF->moduleQueried.moduleQueried.all = 0; //Mark all datums as stale (read before)
-}
-
-//Log this data in file buffer
-void SFE_UBLOX_GNSS::logNAVHPPOSECEF(boolean enabled)
-{
-  if (packetUBXNAVHPPOSECEF == NULL) return; // Bail if RAM has not been allocated (otherwise we could be writing anywhere!)
-  packetUBXNAVHPPOSECEF->automaticFlags.flags.bits.addToFileBuffer = (uint8_t)enabled;
-}
-
-// ***** NAV HPPOSLLH automatic support
-
-boolean SFE_UBLOX_GNSS::getHPPOSLLH(uint16_t maxWait)
-{
-  if (packetUBXNAVHPPOSLLH == NULL) initPacketUBXNAVHPPOSLLH(); //Check that RAM has been allocated for the HPPOSLLH data
-  if (packetUBXNAVHPPOSLLH == NULL) //Bail if the RAM allocation failed
-    return (false);
-
-  if (packetUBXNAVHPPOSLLH->automaticFlags.flags.bits.automatic && packetUBXNAVHPPOSLLH->automaticFlags.flags.bits.implicitUpdate)
-  {
-    //The GPS is automatically reporting, we just check whether we got unread data
-    // if (_printDebug == true)
-    // {
-    //   _debugSerial->println(F("getHPPOSLLH: Autoreporting"));
-    // }
-    checkUbloxInternal(&packetCfg, UBX_CLASS_NAV, UBX_NAV_HPPOSLLH);
-    return packetUBXNAVHPPOSLLH->moduleQueried.moduleQueried.bits.all;
-  }
-  else if (packetUBXNAVHPPOSLLH->automaticFlags.flags.bits.automatic && !packetUBXNAVHPPOSLLH->automaticFlags.flags.bits.implicitUpdate)
-  {
-    //Someone else has to call checkUblox for us...
-    // if (_printDebug == true)
-    // {
-    //   _debugSerial->println(F("getHPPOSLLH: Exit immediately"));
-    // }
-    return (false);
-  }
-  else
-  {
-    // if (_printDebug == true)
-    // {
-    //   _debugSerial->println(F("getHPPOSLLH: Polling"));
-    // }
-
-    //The GPS is not automatically reporting navigation position so we have to poll explicitly
-    packetCfg.cls = UBX_CLASS_NAV;
-    packetCfg.id = UBX_NAV_HPPOSLLH;
-    packetCfg.len = 0;
-    packetCfg.startingSpot = 0;
-
-    //The data is parsed as part of processing the response
-    sfe_ublox_status_e retVal = sendCommand(&packetCfg, maxWait);
-
-    if (retVal == SFE_UBLOX_STATUS_DATA_RECEIVED)
-      return (true);
-
-    if (retVal == SFE_UBLOX_STATUS_DATA_OVERWRITTEN)
-    {
-      // if (_printDebug == true)
-      // {
-      //   _debugSerial->println(F("getHPPOSLLH: data in packetCfg was OVERWRITTEN by another message (but that's OK)"));
-      // }
-      return (true);
-    }
-
-    // if (_printDebug == true)
-    // {
-    //   _debugSerial->print(F("getHPPOSLLH retVal: "));
-    //   _debugSerial->println(statusString(retVal));
-    // }
-    return (false);
-  }
-}
-
-//Enable or disable automatic navigation message generation by the GNSS. This changes the way getHPPOSLLH
-//works.
-boolean SFE_UBLOX_GNSS::setAutoHPPOSLLH(boolean enable, uint16_t maxWait)
-{
-  return setAutoHPPOSLLHrate(enable ? 1 : 0, true, maxWait);
-}
-
-//Enable or disable automatic navigation message generation by the GNSS. This changes the way getHPPOSLLH
-//works.
-boolean SFE_UBLOX_GNSS::setAutoHPPOSLLH(boolean enable, boolean implicitUpdate, uint16_t maxWait)
-{
-  return setAutoHPPOSLLHrate(enable ? 1 : 0, implicitUpdate, maxWait);
-}
-
-//Enable or disable automatic navigation message generation by the GNSS. This changes the way getHPPOSLLH
-//works.
-boolean SFE_UBLOX_GNSS::setAutoHPPOSLLHrate(uint8_t rate, boolean implicitUpdate, uint16_t maxWait)
-{
-  if (packetUBXNAVHPPOSLLH == NULL) initPacketUBXNAVHPPOSLLH(); //Check that RAM has been allocated for the data
-  if (packetUBXNAVHPPOSLLH == NULL) //Only attempt this if RAM allocation was successful
-    return false;
-
-  if (rate > 127) rate = 127;
-
-  packetCfg.cls = UBX_CLASS_CFG;
-  packetCfg.id = UBX_CFG_MSG;
-  packetCfg.len = 3;
-  packetCfg.startingSpot = 0;
-  payloadCfg[0] = UBX_CLASS_NAV;
-  payloadCfg[1] = UBX_NAV_HPPOSLLH;
-  payloadCfg[2] = rate; // rate relative to navigation freq.
-
-  boolean ok = ((sendCommand(&packetCfg, maxWait)) == SFE_UBLOX_STATUS_DATA_SENT); // We are only expecting an ACK
-  if (ok)
-  {
-    packetUBXNAVHPPOSLLH->automaticFlags.flags.bits.automatic = (rate > 0);
-    packetUBXNAVHPPOSLLH->automaticFlags.flags.bits.implicitUpdate = implicitUpdate;
-  }
-  packetUBXNAVHPPOSLLH->moduleQueried.moduleQueried.bits.all = false;
-  return ok;
-}
-
-//Enable automatic navigation message generation by the GNSS.
-boolean SFE_UBLOX_GNSS::setAutoHPPOSLLHcallback(void (*callbackPointer)(UBX_NAV_HPPOSLLH_data_t), uint16_t maxWait)
-{
-  // Enable auto messages. Set implicitUpdate to false as we expect the user to call checkUblox manually.
-  boolean result = setAutoHPPOSLLH(true, false, maxWait);
-  if (!result)
-    return (result); // Bail if setAuto failed
-
-  if (packetUBXNAVHPPOSLLH->callbackData == NULL) //Check if RAM has been allocated for the callback copy
-  {
-    packetUBXNAVHPPOSLLH->callbackData = new UBX_NAV_HPPOSLLH_data_t; //Allocate RAM for the main struct
-  }
-
-  if (packetUBXNAVHPPOSLLH->callbackData == NULL)
-  {
-    if ((_printDebug == true) || (_printLimitedDebug == true)) // This is important. Print this if doing limited debugging
-      _debugSerial->println(F("setAutoHPPOSLLHcallback: PANIC! RAM allocation failed!"));
-    return (false);
-  }
-
-  packetUBXNAVHPPOSLLH->callbackPointer = callbackPointer;
-  return (true);
-}
-
-//In case no config access to the GNSS is possible and HPPOSLLH is send cyclically already
-//set config to suitable parameters
-boolean SFE_UBLOX_GNSS::assumeAutoHPPOSLLH(boolean enabled, boolean implicitUpdate)
-{
-  if (packetUBXNAVHPPOSLLH == NULL) initPacketUBXNAVHPPOSLLH(); //Check that RAM has been allocated for the data
-  if (packetUBXNAVHPPOSLLH == NULL) //Only attempt this if RAM allocation was successful
-    return false;
-
-  boolean changes = packetUBXNAVHPPOSLLH->automaticFlags.flags.bits.automatic != enabled || packetUBXNAVHPPOSLLH->automaticFlags.flags.bits.implicitUpdate != implicitUpdate;
-  if (changes)
-  {
-    packetUBXNAVHPPOSLLH->automaticFlags.flags.bits.automatic = enabled;
-    packetUBXNAVHPPOSLLH->automaticFlags.flags.bits.implicitUpdate = implicitUpdate;
-  }
-  return changes;
-}
-
-// PRIVATE: Allocate RAM for packetUBXNAVHPPOSLLH and initialize it
-boolean SFE_UBLOX_GNSS::initPacketUBXNAVHPPOSLLH()
-{
-  packetUBXNAVHPPOSLLH = new UBX_NAV_HPPOSLLH_t; //Allocate RAM for the main struct
-  if (packetUBXNAVHPPOSLLH == NULL)
-  {
-    if ((_printDebug == true) || (_printLimitedDebug == true)) // This is important. Print this if doing limited debugging
-      _debugSerial->println(F("initPacketUBXNAVHPPOSLLH: PANIC! RAM allocation failed!"));
-    return (false);
-  }
-  packetUBXNAVHPPOSLLH->automaticFlags.flags.all = 0;
-  packetUBXNAVHPPOSLLH->callbackPointer = NULL;
-  packetUBXNAVHPPOSLLH->callbackData = NULL;
-  packetUBXNAVHPPOSLLH->moduleQueried.moduleQueried.all = 0;
-  return (true);
-}
-
-//Mark all the HPPOSLLH data as read/stale. This is handy to get data alignment after CRC failure
-void SFE_UBLOX_GNSS::flushHPPOSLLH()
-{
-  if (packetUBXNAVHPPOSLLH == NULL) return; // Bail if RAM has not been allocated (otherwise we could be writing anywhere!
-  packetUBXNAVHPPOSLLH->moduleQueried.moduleQueried.all = 0;   //Mark all datums as stale (read before)
-}
-
-//Log this data in file buffer
-void SFE_UBLOX_GNSS::logNAVHPPOSLLH(boolean enabled)
-{
-  if (packetUBXNAVHPPOSLLH == NULL) return; // Bail if RAM has not been allocated (otherwise we could be writing anywhere!)
-  packetUBXNAVHPPOSLLH->automaticFlags.flags.bits.addToFileBuffer = (uint8_t)enabled;
-}
-
-// ***** NAV CLOCK automatic support
-
-boolean SFE_UBLOX_GNSS::getNAVCLOCK(uint16_t maxWait)
-{
-  if (packetUBXNAVCLOCK == NULL) initPacketUBXNAVCLOCK(); //Check that RAM has been allocated for the CLOCK data
-  if (packetUBXNAVCLOCK == NULL) //Bail if the RAM allocation failed
-    return (false);
-
-  if (packetUBXNAVCLOCK->automaticFlags.flags.bits.automatic && packetUBXNAVCLOCK->automaticFlags.flags.bits.implicitUpdate)
-  {
-    //The GPS is automatically reporting, we just check whether we got unread data
-    checkUbloxInternal(&packetCfg, UBX_CLASS_NAV, UBX_NAV_CLOCK);
-    return packetUBXNAVCLOCK->moduleQueried.moduleQueried.bits.all;
-  }
-  else if (packetUBXNAVCLOCK->automaticFlags.flags.bits.automatic && !packetUBXNAVCLOCK->automaticFlags.flags.bits.implicitUpdate)
-  {
-    //Someone else has to call checkUblox for us...
-    return (false);
-  }
-  else
-  {
-    //The GPS is not automatically reporting CLOCK so we have to poll explicitly
-    packetCfg.cls = UBX_CLASS_NAV;
-    packetCfg.id = UBX_NAV_CLOCK;
-    packetCfg.len = 0;
-    packetCfg.startingSpot = 0;
-
-    //The data is parsed as part of processing the response
-    sfe_ublox_status_e retVal = sendCommand(&packetCfg, maxWait);
-
-    if (retVal == SFE_UBLOX_STATUS_DATA_RECEIVED)
-      return (true);
-
-    if (retVal == SFE_UBLOX_STATUS_DATA_OVERWRITTEN)
-    {
-      return (true);
-    }
-
-    return (false);
-  }
-}
-
-//Enable or disable automatic CLOCK message generation by the GNSS. This changes the way getNAVCLOCK
-//works.
-boolean SFE_UBLOX_GNSS::setAutoNAVCLOCK(boolean enable, uint16_t maxWait)
-{
-  return setAutoNAVCLOCKrate(enable ? 1 : 0, true, maxWait);
-}
-
-//Enable or disable automatic CLOCK message generation by the GNSS. This changes the way getNAVCLOCK
-//works.
-boolean SFE_UBLOX_GNSS::setAutoNAVCLOCK(boolean enable, boolean implicitUpdate, uint16_t maxWait)
-{
-  return setAutoNAVCLOCKrate(enable ? 1 : 0, implicitUpdate, maxWait);
-}
-
-//Enable or disable automatic CLOCK attitude message generation by the GNSS. This changes the way getNAVCLOCK
-//works.
-boolean SFE_UBLOX_GNSS::setAutoNAVCLOCKrate(uint8_t rate, boolean implicitUpdate, uint16_t maxWait)
-{
-  if (packetUBXNAVCLOCK == NULL) initPacketUBXNAVCLOCK(); //Check that RAM has been allocated for the data
-  if (packetUBXNAVCLOCK == NULL) //Only attempt this if RAM allocation was successful
-    return false;
-
-  if (rate > 127) rate = 127;
-
-  packetCfg.cls = UBX_CLASS_CFG;
-  packetCfg.id = UBX_CFG_MSG;
-  packetCfg.len = 3;
-  packetCfg.startingSpot = 0;
-  payloadCfg[0] = UBX_CLASS_NAV;
-  payloadCfg[1] = UBX_NAV_CLOCK;
-  payloadCfg[2] = rate; // rate relative to navigation freq.
-
-  boolean ok = ((sendCommand(&packetCfg, maxWait)) == SFE_UBLOX_STATUS_DATA_SENT); // We are only expecting an ACK
-  if (ok)
-  {
-    packetUBXNAVCLOCK->automaticFlags.flags.bits.automatic = (rate > 0);
-    packetUBXNAVCLOCK->automaticFlags.flags.bits.implicitUpdate = implicitUpdate;
-  }
-  packetUBXNAVCLOCK->moduleQueried.moduleQueried.bits.all = false; // Mark data as stale
-  return ok;
-}
-
-//Enable automatic navigation message generation by the GNSS.
-boolean SFE_UBLOX_GNSS::setAutoNAVCLOCKcallback(void (*callbackPointer)(UBX_NAV_CLOCK_data_t), uint16_t maxWait)
-{
-  // Enable auto messages. Set implicitUpdate to false as we expect the user to call checkUblox manually.
-  boolean result = setAutoNAVCLOCK(true, false, maxWait);
-  if (!result)
-    return (result); // Bail if setAuto failed
-
-  if (packetUBXNAVCLOCK->callbackData == NULL) //Check if RAM has been allocated for the callback copy
-  {
-    packetUBXNAVCLOCK->callbackData = new UBX_NAV_CLOCK_data_t; //Allocate RAM for the main struct
-  }
-
-  if (packetUBXNAVCLOCK->callbackData == NULL)
-  {
-    if ((_printDebug == true) || (_printLimitedDebug == true)) // This is important. Print this if doing limited debugging
-      _debugSerial->println(F("setAutoNAVCLOCKcallback: PANIC! RAM allocation failed!"));
-    return (false);
-  }
-
-  packetUBXNAVCLOCK->callbackPointer = callbackPointer;
-  return (true);
-}
-
-//In case no config access to the GNSS is possible and HNR attitude is send cyclically already
-//set config to suitable parameters
-boolean SFE_UBLOX_GNSS::assumeAutoNAVCLOCK(boolean enabled, boolean implicitUpdate)
-{
-  if (packetUBXNAVCLOCK == NULL) initPacketUBXNAVCLOCK(); //Check that RAM has been allocated for the CLOCK data
-  if (packetUBXNAVCLOCK == NULL) //Bail if the RAM allocation failed
-    return (false);
-
-  boolean changes = packetUBXNAVCLOCK->automaticFlags.flags.bits.automatic != enabled || packetUBXNAVCLOCK->automaticFlags.flags.bits.implicitUpdate != implicitUpdate;
-  if (changes)
-  {
-    packetUBXNAVCLOCK->automaticFlags.flags.bits.automatic = enabled;
-    packetUBXNAVCLOCK->automaticFlags.flags.bits.implicitUpdate = implicitUpdate;
-  }
-  return changes;
-}
-
-// PRIVATE: Allocate RAM for packetUBXNAVCLOCK and initialize it
-boolean SFE_UBLOX_GNSS::initPacketUBXNAVCLOCK()
-{
-  packetUBXNAVCLOCK = new UBX_NAV_CLOCK_t ; //Allocate RAM for the main struct
-  if (packetUBXNAVCLOCK == NULL)
-  {
-    if ((_printDebug == true) || (_printLimitedDebug == true)) // This is important. Print this if doing limited debugging
-      _debugSerial->println(F("initPacketUBXNAVCLOCK: PANIC! RAM allocation failed!"));
-    return (false);
-  }
-  packetUBXNAVCLOCK->automaticFlags.flags.all = 0;
-  packetUBXNAVCLOCK->callbackPointer = NULL;
-  packetUBXNAVCLOCK->callbackData = NULL;
-  packetUBXNAVCLOCK->moduleQueried.moduleQueried.all = 0;
-  return (true);
-}
-
-//Mark all the data as read/stale
-void SFE_UBLOX_GNSS::flushNAVCLOCK()
-{
-  if (packetUBXNAVCLOCK == NULL) return; // Bail if RAM has not been allocated (otherwise we could be writing anywhere!)
-  packetUBXNAVCLOCK->moduleQueried.moduleQueried.all = 0; //Mark all datums as stale (read before)
-}
-
-//Log this data in file buffer
-void SFE_UBLOX_GNSS::logNAVCLOCK(boolean enabled)
-{
-  if (packetUBXNAVCLOCK == NULL) return; // Bail if RAM has not been allocated (otherwise we could be writing anywhere!)
-  packetUBXNAVCLOCK->automaticFlags.flags.bits.addToFileBuffer = (uint8_t)enabled;
-}
-
-// ***** NAV SVIN automatic support
-
-//Reads survey in status and sets the global variables
-//for status, position valid, observation time, and mean 3D StdDev
-//Returns true if commands was successful
-boolean SFE_UBLOX_GNSS::getSurveyStatus(uint16_t maxWait)
-{
-  if (packetUBXNAVSVIN == NULL) initPacketUBXNAVSVIN(); //Check that RAM has been allocated for the SVIN data
-  if (packetUBXNAVSVIN == NULL) // Abort if the RAM allocation failed
-    return (false);
-
-  packetCfg.cls = UBX_CLASS_NAV;
-  packetCfg.id = UBX_NAV_SVIN;
-  packetCfg.len = 0;
-  packetCfg.startingSpot = 0;
-
-  //The data is parsed as part of processing the response
-  sfe_ublox_status_e retVal = sendCommand(&packetCfg, maxWait);
-
-  if (retVal == SFE_UBLOX_STATUS_DATA_RECEIVED)
-    return (true);
-
-  if (retVal == SFE_UBLOX_STATUS_DATA_OVERWRITTEN)
-  {
-    return (true);
-  }
-
-  return (false);
-}
-
-// PRIVATE: Allocate RAM for packetUBXNAVSVIN and initialize it
-boolean SFE_UBLOX_GNSS::initPacketUBXNAVSVIN()
-{
-  packetUBXNAVSVIN = new UBX_NAV_SVIN_t; //Allocate RAM for the main struct
-  if (packetUBXNAVSVIN == NULL)
-  {
-    if ((_printDebug == true) || (_printLimitedDebug == true)) // This is important. Print this if doing limited debugging
-      _debugSerial->println(F("initPacketUBXNAVSVIN: PANIC! RAM allocation failed!"));
-    return (false);
-  }
-  packetUBXNAVSVIN->automaticFlags.flags.all = 0;
-  packetUBXNAVSVIN->callbackPointer = NULL;
-  packetUBXNAVSVIN->callbackData = NULL;
-  packetUBXNAVSVIN->moduleQueried.moduleQueried.all = 0;
-  return (true);
-}
-
-// ***** NAV RELPOSNED automatic support
-
-//Relative Positioning Information in NED frame
-//Returns true if commands was successful
-//Note:
-//  RELPOSNED on the M8 is only 40 bytes long
-//  RELPOSNED on the F9 is 64 bytes long and contains much more information
-boolean SFE_UBLOX_GNSS::getRELPOSNED(uint16_t maxWait)
-{
-  if (packetUBXNAVRELPOSNED == NULL) initPacketUBXNAVRELPOSNED(); //Check that RAM has been allocated for the RELPOSNED data
-  if (packetUBXNAVRELPOSNED == NULL) //Bail if the RAM allocation failed
-    return (false);
-
-  if (packetUBXNAVRELPOSNED->automaticFlags.flags.bits.automatic && packetUBXNAVRELPOSNED->automaticFlags.flags.bits.implicitUpdate)
-  {
-    //The GPS is automatically reporting, we just check whether we got unread data
-    checkUbloxInternal(&packetCfg, UBX_CLASS_NAV, UBX_NAV_RELPOSNED);
-    return packetUBXNAVRELPOSNED->moduleQueried.moduleQueried.bits.all;
-  }
-  else if (packetUBXNAVRELPOSNED->automaticFlags.flags.bits.automatic && !packetUBXNAVRELPOSNED->automaticFlags.flags.bits.implicitUpdate)
-  {
-    //Someone else has to call checkUblox for us...
-    return (false);
-  }
-  else
-  {
-    //The GPS is not automatically reporting RELPOSNED so we have to poll explicitly
-    packetCfg.cls = UBX_CLASS_NAV;
-    packetCfg.id = UBX_NAV_RELPOSNED;
-    packetCfg.len = 0;
-    packetCfg.startingSpot = 0;
-
-    //The data is parsed as part of processing the response
-    sfe_ublox_status_e retVal = sendCommand(&packetCfg, maxWait);
-
-    if (retVal == SFE_UBLOX_STATUS_DATA_RECEIVED)
-      return (true);
-
-    if (retVal == SFE_UBLOX_STATUS_DATA_OVERWRITTEN)
-    {
-      return (true);
-    }
-
-    return (false);
-  }
-}
-
-//Enable or disable automatic RELPOSNED message generation by the GNSS. This changes the way getRELPOSNED
-//works.
-boolean SFE_UBLOX_GNSS::setAutoRELPOSNED(boolean enable, uint16_t maxWait)
-{
-  return setAutoRELPOSNEDrate(enable ? 1 : 0, true, maxWait);
-}
-
-//Enable or disable automatic RELPOSNED message generation by the GNSS. This changes the way getRELPOSNED
-//works.
-boolean SFE_UBLOX_GNSS::setAutoRELPOSNED(boolean enable, boolean implicitUpdate, uint16_t maxWait)
-{
-  return setAutoRELPOSNEDrate(enable ? 1 : 0, implicitUpdate, maxWait);
-}
-
-//Enable or disable automatic HNR attitude message generation by the GNSS. This changes the way getRELPOSNED
-//works.
-boolean SFE_UBLOX_GNSS::setAutoRELPOSNEDrate(uint8_t rate, boolean implicitUpdate, uint16_t maxWait)
-{
-  if (packetUBXNAVRELPOSNED == NULL) initPacketUBXNAVRELPOSNED(); //Check that RAM has been allocated for the data
-  if (packetUBXNAVRELPOSNED == NULL) //Only attempt this if RAM allocation was successful
-    return false;
-
-  if (rate > 127) rate = 127;
-
-  packetCfg.cls = UBX_CLASS_CFG;
-  packetCfg.id = UBX_CFG_MSG;
-  packetCfg.len = 3;
-  packetCfg.startingSpot = 0;
-  payloadCfg[0] = UBX_CLASS_NAV;
-  payloadCfg[1] = UBX_NAV_RELPOSNED;
-  payloadCfg[2] = rate; // rate relative to navigation freq.
-
-  boolean ok = ((sendCommand(&packetCfg, maxWait)) == SFE_UBLOX_STATUS_DATA_SENT); // We are only expecting an ACK
-  if (ok)
-  {
-    packetUBXNAVRELPOSNED->automaticFlags.flags.bits.automatic = (rate > 0);
-    packetUBXNAVRELPOSNED->automaticFlags.flags.bits.implicitUpdate = implicitUpdate;
-  }
-  packetUBXNAVRELPOSNED->moduleQueried.moduleQueried.bits.all = false; // Mark data as stale
-  return ok;
-}
-
-//Enable automatic navigation message generation by the GNSS.
-boolean SFE_UBLOX_GNSS::setAutoRELPOSNEDcallback(void (*callbackPointer)(UBX_NAV_RELPOSNED_data_t), uint16_t maxWait)
-{
-  // Enable auto messages. Set implicitUpdate to false as we expect the user to call checkUblox manually.
-  boolean result = setAutoRELPOSNED(true, false, maxWait);
-  if (!result)
-    return (result); // Bail if setAuto failed
-
-  if (packetUBXNAVRELPOSNED->callbackData == NULL) //Check if RAM has been allocated for the callback copy
-  {
-    packetUBXNAVRELPOSNED->callbackData = new UBX_NAV_RELPOSNED_data_t; //Allocate RAM for the main struct
-  }
-
-  if (packetUBXNAVRELPOSNED->callbackData == NULL)
-  {
-    if ((_printDebug == true) || (_printLimitedDebug == true)) // This is important. Print this if doing limited debugging
-      _debugSerial->println(F("setAutoRELPOSNEDcallback: PANIC! RAM allocation failed!"));
-    return (false);
-  }
-
-  packetUBXNAVRELPOSNED->callbackPointer = callbackPointer;
-  return (true);
-}
-
-//In case no config access to the GNSS is possible and HNR attitude is send cyclically already
-//set config to suitable parameters
-boolean SFE_UBLOX_GNSS::assumeAutoRELPOSNED(boolean enabled, boolean implicitUpdate)
-{
-  if (packetUBXNAVRELPOSNED == NULL) initPacketUBXNAVRELPOSNED(); //Check that RAM has been allocated for the RELPOSNED data
-  if (packetUBXNAVRELPOSNED == NULL) //Bail if the RAM allocation failed
-    return (false);
-
-  boolean changes = packetUBXNAVRELPOSNED->automaticFlags.flags.bits.automatic != enabled || packetUBXNAVRELPOSNED->automaticFlags.flags.bits.implicitUpdate != implicitUpdate;
-  if (changes)
-  {
-    packetUBXNAVRELPOSNED->automaticFlags.flags.bits.automatic = enabled;
-    packetUBXNAVRELPOSNED->automaticFlags.flags.bits.implicitUpdate = implicitUpdate;
-  }
-  return changes;
-}
-
-// PRIVATE: Allocate RAM for packetUBXNAVRELPOSNED and initialize it
-boolean SFE_UBLOX_GNSS::initPacketUBXNAVRELPOSNED()
-{
-  packetUBXNAVRELPOSNED = new UBX_NAV_RELPOSNED_t ; //Allocate RAM for the main struct
-  if (packetUBXNAVRELPOSNED == NULL)
-  {
-    if ((_printDebug == true) || (_printLimitedDebug == true)) // This is important. Print this if doing limited debugging
-      _debugSerial->println(F("initPacketUBXNAVRELPOSNED: PANIC! RAM allocation failed!"));
-    return (false);
-  }
-  packetUBXNAVRELPOSNED->automaticFlags.flags.all = 0;
-  packetUBXNAVRELPOSNED->callbackPointer = NULL;
-  packetUBXNAVRELPOSNED->callbackData = NULL;
-  packetUBXNAVRELPOSNED->moduleQueried.moduleQueried.all = 0;
-  return (true);
-}
-
-//Mark all the data as read/stale
-void SFE_UBLOX_GNSS::flushNAVRELPOSNED()
-{
-  if (packetUBXNAVRELPOSNED == NULL) return; // Bail if RAM has not been allocated (otherwise we could be writing anywhere!)
-  packetUBXNAVRELPOSNED->moduleQueried.moduleQueried.all = 0; //Mark all datums as stale (read before)
-}
-
-//Log this data in file buffer
-void SFE_UBLOX_GNSS::logNAVRELPOSNED(boolean enabled)
-{
-  if (packetUBXNAVRELPOSNED == NULL) return; // Bail if RAM has not been allocated (otherwise we could be writing anywhere!)
-  packetUBXNAVRELPOSNED->automaticFlags.flags.bits.addToFileBuffer = (uint8_t)enabled;
-}
-
-// ***** RXM SFRBX automatic support
-
-boolean SFE_UBLOX_GNSS::getRXMSFRBX(uint16_t maxWait)
-{
-  if (packetUBXRXMSFRBX == NULL) initPacketUBXRXMSFRBX(); //Check that RAM has been allocated for the TM2 data
-  if (packetUBXRXMSFRBX == NULL) //Bail if the RAM allocation failed
-    return (false);
-
-  if (packetUBXRXMSFRBX->automaticFlags.flags.bits.automatic && packetUBXRXMSFRBX->automaticFlags.flags.bits.implicitUpdate)
-  {
-    //The GPS is automatically reporting, we just check whether we got unread data
-    checkUbloxInternal(&packetCfg, UBX_CLASS_TIM, UBX_TIM_TM2);
-    return packetUBXRXMSFRBX->moduleQueried;
-  }
-  else if (packetUBXRXMSFRBX->automaticFlags.flags.bits.automatic && !packetUBXRXMSFRBX->automaticFlags.flags.bits.implicitUpdate)
-  {
-    //Someone else has to call checkUblox for us...
-    return (false);
-  }
-  else
-  {
-    //The GPS is not automatically reporting navigation position so we have to poll explicitly
-    packetCfg.cls = UBX_CLASS_RXM;
-    packetCfg.id = UBX_RXM_SFRBX;
-    packetCfg.len = 0;
-    packetCfg.startingSpot = 0;
-
-    //The data is parsed as part of processing the response
-    sfe_ublox_status_e retVal = sendCommand(&packetCfg, maxWait);
-
-    if (retVal == SFE_UBLOX_STATUS_DATA_RECEIVED)
-      return (true);
-
-    if (retVal == SFE_UBLOX_STATUS_DATA_OVERWRITTEN)
-    {
-      return (true);
-    }
-
-    return (false);
-  }
-}
-
-//Enable or disable automatic navigation message generation by the GNSS. This changes the way getRXMSFRBX
-//works.
-boolean SFE_UBLOX_GNSS::setAutoRXMSFRBX(boolean enable, uint16_t maxWait)
-{
-  return setAutoRXMSFRBXrate(enable ? 1 : 0, true, maxWait);
-}
-
-//Enable or disable automatic navigation message generation by the GNSS. This changes the way getRXMSFRBX
-//works.
-boolean SFE_UBLOX_GNSS::setAutoRXMSFRBX(boolean enable, boolean implicitUpdate, uint16_t maxWait)
-{
-  return setAutoRXMSFRBXrate(enable ? 1 : 0, implicitUpdate, maxWait);
-}
-
-//Enable or disable automatic navigation message generation by the GNSS. This changes the way getRXMSFRBX
-//works.
-boolean SFE_UBLOX_GNSS::setAutoRXMSFRBXrate(uint8_t rate, boolean implicitUpdate, uint16_t maxWait)
-{
-  if (packetUBXRXMSFRBX == NULL) initPacketUBXRXMSFRBX(); //Check that RAM has been allocated for the data
-  if (packetUBXRXMSFRBX == NULL) //Only attempt this if RAM allocation was successful
-    return false;
-
-  if (rate > 127) rate = 127;
-
-  packetCfg.cls = UBX_CLASS_CFG;
-  packetCfg.id = UBX_CFG_MSG;
-  packetCfg.len = 3;
-  packetCfg.startingSpot = 0;
-  payloadCfg[0] = UBX_CLASS_RXM;
-  payloadCfg[1] = UBX_RXM_SFRBX;
-  payloadCfg[2] = rate; // rate relative to navigation freq.
-
-  boolean ok = ((sendCommand(&packetCfg, maxWait)) == SFE_UBLOX_STATUS_DATA_SENT); // We are only expecting an ACK
-  if (ok)
-  {
-    packetUBXRXMSFRBX->automaticFlags.flags.bits.automatic = (rate > 0);
-    packetUBXRXMSFRBX->automaticFlags.flags.bits.implicitUpdate = implicitUpdate;
-  }
-  packetUBXRXMSFRBX->moduleQueried = false;
-  return ok;
-}
-
-//Enable automatic navigation message generation by the GNSS.
-boolean SFE_UBLOX_GNSS::setAutoRXMSFRBXcallback(void (*callbackPointer)(UBX_RXM_SFRBX_data_t), uint16_t maxWait)
-{
-  // Enable auto messages. Set implicitUpdate to false as we expect the user to call checkUblox manually.
-  boolean result = setAutoRXMSFRBX(true, false, maxWait);
-  if (!result)
-    return (result); // Bail if setAuto failed
-
-  if (packetUBXRXMSFRBX->callbackData == NULL) //Check if RAM has been allocated for the callback copy
-  {
-    packetUBXRXMSFRBX->callbackData = new UBX_RXM_SFRBX_data_t; //Allocate RAM for the main struct
-  }
-
-  if (packetUBXRXMSFRBX->callbackData == NULL)
-  {
-    if ((_printDebug == true) || (_printLimitedDebug == true)) // This is important. Print this if doing limited debugging
-      _debugSerial->println(F("setAutoRXMSFRBXcallback: PANIC! RAM allocation failed!"));
-    return (false);
-  }
-
-  packetUBXRXMSFRBX->callbackPointer = callbackPointer;
-  return (true);
-}
-
-//In case no config access to the GNSS is possible and SFRBX is send cyclically already
-//set config to suitable parameters
-boolean SFE_UBLOX_GNSS::assumeAutoRXMSFRBX(boolean enabled, boolean implicitUpdate)
-{
-  if (packetUBXRXMSFRBX == NULL) initPacketUBXRXMSFRBX(); //Check that RAM has been allocated for the data
-  if (packetUBXRXMSFRBX == NULL) //Only attempt this if RAM allocation was successful
-    return false;
-
-  boolean changes = packetUBXRXMSFRBX->automaticFlags.flags.bits.automatic != enabled || packetUBXRXMSFRBX->automaticFlags.flags.bits.implicitUpdate != implicitUpdate;
-  if (changes)
-  {
-    packetUBXRXMSFRBX->automaticFlags.flags.bits.automatic = enabled;
-    packetUBXRXMSFRBX->automaticFlags.flags.bits.implicitUpdate = implicitUpdate;
-  }
-  return changes;
-}
-
-// PRIVATE: Allocate RAM for packetUBXRXMSFRBX and initialize it
-boolean SFE_UBLOX_GNSS::initPacketUBXRXMSFRBX()
-{
-  packetUBXRXMSFRBX = new UBX_RXM_SFRBX_t; //Allocate RAM for the main struct
-  if (packetUBXRXMSFRBX == NULL)
-  {
-    if ((_printDebug == true) || (_printLimitedDebug == true)) // This is important. Print this if doing limited debugging
-      _debugSerial->println(F("initPacketUBXRXMSFRBX: PANIC! RAM allocation failed!"));
-    return (false);
-  }
-  packetUBXRXMSFRBX->automaticFlags.flags.all = 0;
-  packetUBXRXMSFRBX->callbackPointer = NULL;
-  packetUBXRXMSFRBX->callbackData = NULL;
-  packetUBXRXMSFRBX->moduleQueried = false;
-  return (true);
-}
-
-//Mark all the data as read/stale
-void SFE_UBLOX_GNSS::flushRXMSFRBX()
-{
-  if (packetUBXRXMSFRBX == NULL) return; // Bail if RAM has not been allocated (otherwise we could be writing anywhere!)
-  packetUBXRXMSFRBX->moduleQueried = false; //Mark all datums as stale (read before)
-}
-
-//Log this data in file buffer
-void SFE_UBLOX_GNSS::logRXMSFRBX(boolean enabled)
-{
-  if (packetUBXRXMSFRBX == NULL) return; // Bail if RAM has not been allocated (otherwise we could be writing anywhere!)
-  packetUBXRXMSFRBX->automaticFlags.flags.bits.addToFileBuffer = (uint8_t)enabled;
-}
-
-// ***** RXM RAWX automatic support
-
-boolean SFE_UBLOX_GNSS::getRXMRAWX(uint16_t maxWait)
-{
-  if (packetUBXRXMRAWX == NULL) initPacketUBXRXMRAWX(); //Check that RAM has been allocated for the TM2 data
-  if (packetUBXRXMRAWX == NULL) //Bail if the RAM allocation failed
-    return (false);
-
-  if (packetUBXRXMRAWX->automaticFlags.flags.bits.automatic && packetUBXRXMRAWX->automaticFlags.flags.bits.implicitUpdate)
-  {
-    //The GPS is automatically reporting, we just check whether we got unread data
-    checkUbloxInternal(&packetCfg, UBX_CLASS_TIM, UBX_TIM_TM2);
-    return packetUBXRXMRAWX->moduleQueried;
-  }
-  else if (packetUBXRXMRAWX->automaticFlags.flags.bits.automatic && !packetUBXRXMRAWX->automaticFlags.flags.bits.implicitUpdate)
-  {
-    //Someone else has to call checkUblox for us...
-    return (false);
-  }
-  else
-  {
-    //The GPS is not automatically reporting navigation position so we have to poll explicitly
-    packetCfg.cls = UBX_CLASS_RXM;
-    packetCfg.id = UBX_RXM_RAWX;
-    packetCfg.len = 0;
-    packetCfg.startingSpot = 0;
-
-    //The data is parsed as part of processing the response
-    sfe_ublox_status_e retVal = sendCommand(&packetCfg, maxWait);
-
-    if (retVal == SFE_UBLOX_STATUS_DATA_RECEIVED)
-      return (true);
-
-    if (retVal == SFE_UBLOX_STATUS_DATA_OVERWRITTEN)
-    {
-      return (true);
-    }
-
-    return (false);
-  }
-}
-
-//Enable or disable automatic navigation message generation by the GNSS. This changes the way getRXMRAWX
-//works.
-boolean SFE_UBLOX_GNSS::setAutoRXMRAWX(boolean enable, uint16_t maxWait)
-{
-  return setAutoRXMRAWXrate(enable ? 1 : 0, true, maxWait);
-}
-
-//Enable or disable automatic navigation message generation by the GNSS. This changes the way getRXMRAWX
-//works.
-boolean SFE_UBLOX_GNSS::setAutoRXMRAWX(boolean enable, boolean implicitUpdate, uint16_t maxWait)
-{
-  return setAutoRXMRAWXrate(enable ? 1 : 0, implicitUpdate, maxWait);
-}
-
-//Enable or disable automatic navigation message generation by the GNSS. This changes the way getRXMRAWX
-//works.
-boolean SFE_UBLOX_GNSS::setAutoRXMRAWXrate(uint8_t rate, boolean implicitUpdate, uint16_t maxWait)
-{
-  if (packetUBXRXMRAWX == NULL) initPacketUBXRXMRAWX(); //Check that RAM has been allocated for the data
-  if (packetUBXRXMRAWX == NULL) //Only attempt this if RAM allocation was successful
-    return false;
-
-  if (rate > 127) rate = 127;
-
-  packetCfg.cls = UBX_CLASS_CFG;
-  packetCfg.id = UBX_CFG_MSG;
-  packetCfg.len = 3;
-  packetCfg.startingSpot = 0;
-  payloadCfg[0] = UBX_CLASS_RXM;
-  payloadCfg[1] = UBX_RXM_RAWX;
-  payloadCfg[2] = rate; // rate relative to navigation freq.
-
-  boolean ok = ((sendCommand(&packetCfg, maxWait)) == SFE_UBLOX_STATUS_DATA_SENT); // We are only expecting an ACK
-  if (ok)
-  {
-    packetUBXRXMRAWX->automaticFlags.flags.bits.automatic = (rate > 0);
-    packetUBXRXMRAWX->automaticFlags.flags.bits.implicitUpdate = implicitUpdate;
-  }
-  packetUBXRXMRAWX->moduleQueried = false;
-  return ok;
-}
-
-//Enable automatic navigation message generation by the GNSS.
-boolean SFE_UBLOX_GNSS::setAutoRXMRAWXcallback(void (*callbackPointer)(UBX_RXM_RAWX_data_t), uint16_t maxWait)
-{
-  // Enable auto messages. Set implicitUpdate to false as we expect the user to call checkUblox manually.
-  boolean result = setAutoRXMRAWX(true, false, maxWait);
-  if (!result)
-    return (result); // Bail if setAuto failed
-
-  if (packetUBXRXMRAWX->callbackData == NULL) //Check if RAM has been allocated for the callback copy
-  {
-    packetUBXRXMRAWX->callbackData = new UBX_RXM_RAWX_data_t; //Allocate RAM for the main struct
-  }
-
-  if (packetUBXRXMRAWX->callbackData == NULL)
-  {
-    if ((_printDebug == true) || (_printLimitedDebug == true)) // This is important. Print this if doing limited debugging
-      _debugSerial->println(F("setAutoRXMRAWXcallback: PANIC! RAM allocation failed!"));
-    return (false);
-  }
-
-  packetUBXRXMRAWX->callbackPointer = callbackPointer;
-  return (true);
-}
-
-//In case no config access to the GNSS is possible and VELNED is send cyclically already
-//set config to suitable parameters
-boolean SFE_UBLOX_GNSS::assumeAutoRXMRAWX(boolean enabled, boolean implicitUpdate)
-{
-  if (packetUBXRXMRAWX == NULL) initPacketUBXRXMRAWX(); //Check that RAM has been allocated for the data
-  if (packetUBXRXMRAWX == NULL) //Only attempt this if RAM allocation was successful
-    return false;
-
-  boolean changes = packetUBXRXMRAWX->automaticFlags.flags.bits.automatic != enabled || packetUBXRXMRAWX->automaticFlags.flags.bits.implicitUpdate != implicitUpdate;
-  if (changes)
-  {
-    packetUBXRXMRAWX->automaticFlags.flags.bits.automatic = enabled;
-    packetUBXRXMRAWX->automaticFlags.flags.bits.implicitUpdate = implicitUpdate;
-  }
-  return changes;
-}
-
-// PRIVATE: Allocate RAM for packetUBXRXMRAWX and initialize it
-boolean SFE_UBLOX_GNSS::initPacketUBXRXMRAWX()
-{
-  packetUBXRXMRAWX = new UBX_RXM_RAWX_t; //Allocate RAM for the main struct
-  if (packetUBXRXMRAWX == NULL)
-  {
-    if ((_printDebug == true) || (_printLimitedDebug == true)) // This is important. Print this if doing limited debugging
-      _debugSerial->println(F("initPacketUBXRXMRAWX: PANIC! RAM allocation failed!"));
-    return (false);
-  }
-  packetUBXRXMRAWX->automaticFlags.flags.all = 0;
-  packetUBXRXMRAWX->callbackPointer = NULL;
-  packetUBXRXMRAWX->callbackData = NULL;
-  packetUBXRXMRAWX->moduleQueried = false;
-  return (true);
-}
-
-//Mark all the data as read/stale
-void SFE_UBLOX_GNSS::flushRXMRAWX()
-{
-  if (packetUBXRXMRAWX == NULL) return; // Bail if RAM has not been allocated (otherwise we could be writing anywhere!)
-  packetUBXRXMRAWX->moduleQueried = false; //Mark all datums as stale (read before)
-}
-
-//Log this data in file buffer
-void SFE_UBLOX_GNSS::logRXMRAWX(boolean enabled)
-{
-  if (packetUBXRXMRAWX == NULL) return; // Bail if RAM has not been allocated (otherwise we could be writing anywhere!)
-  packetUBXRXMRAWX->automaticFlags.flags.bits.addToFileBuffer = (uint8_t)enabled;
-}
-
-// ***** CFG automatic support
-
-//Get the latest CFG RATE - as used by isConnected
-boolean SFE_UBLOX_GNSS::getNavigationFrequencyInternal(uint16_t maxWait)
-{
-  if (packetUBXCFGRATE == NULL) initPacketUBXCFGRATE(); //Check that RAM has been allocated for the data
-  if (packetUBXCFGRATE == NULL) //Bail if the RAM allocation failed
-    return (false);
-
-  if (packetUBXCFGRATE->automaticFlags.flags.bits.automatic && packetUBXCFGRATE->automaticFlags.flags.bits.implicitUpdate)
-  {
-    //The GPS is automatically reporting, we just check whether we got unread data
-    checkUbloxInternal(&packetCfg, UBX_CLASS_CFG, UBX_CFG_RATE);
-    return packetUBXCFGRATE->moduleQueried.moduleQueried.bits.all;
-  }
-  else if (packetUBXCFGRATE->automaticFlags.flags.bits.automatic && !packetUBXCFGRATE->automaticFlags.flags.bits.implicitUpdate)
-  {
-    //Someone else has to call checkUblox for us...
-    return (false);
-  }
-  else
-  {
-    //The GPS is not automatically reporting navigation rate so we have to poll explicitly
-    packetCfg.cls = UBX_CLASS_CFG;
-    packetCfg.id = UBX_CFG_RATE;
-    packetCfg.len = 0;
-    packetCfg.startingSpot = 0;
-
-    //The data is parsed as part of processing the response
-    sfe_ublox_status_e retVal = sendCommand(&packetCfg, maxWait);
-
-    if (retVal == SFE_UBLOX_STATUS_DATA_RECEIVED)
-      return (true);
-
-    if (retVal == SFE_UBLOX_STATUS_DATA_OVERWRITTEN)
-    {
-      return (true);
-    }
-
-    return (false);
-  }
-}
-
-// PRIVATE: Allocate RAM for packetUBXCFGRATE and initialize it
-boolean SFE_UBLOX_GNSS::initPacketUBXCFGRATE()
-{
-  packetUBXCFGRATE = new UBX_CFG_RATE_t; //Allocate RAM for the main struct
-  if (packetUBXCFGRATE == NULL)
-  {
-    if ((_printDebug == true) || (_printLimitedDebug == true)) // This is important. Print this if doing limited debugging
-      _debugSerial->println(F("initPacketUBXCFGRATE: PANIC! RAM allocation failed!"));
-    return (false);
-  }
-  packetUBXCFGRATE->automaticFlags.flags.all = 0;
-  packetUBXCFGRATE->callbackPointer = NULL;
-  packetUBXCFGRATE->callbackData = NULL;
-  packetUBXCFGRATE->moduleQueried.moduleQueried.all = 0;
-  return (true);
-}
-
-// ***** TIM TM2 automatic support
-
-boolean SFE_UBLOX_GNSS::getTIMTM2(uint16_t maxWait)
-{
-  if (packetUBXTIMTM2 == NULL) initPacketUBXTIMTM2(); //Check that RAM has been allocated for the TM2 data
-  if (packetUBXTIMTM2 == NULL) //Bail if the RAM allocation failed
-    return (false);
-
-  if (packetUBXTIMTM2->automaticFlags.flags.bits.automatic && packetUBXTIMTM2->automaticFlags.flags.bits.implicitUpdate)
-  {
-    //The GPS is automatically reporting, we just check whether we got unread data
-    checkUbloxInternal(&packetCfg, UBX_CLASS_TIM, UBX_TIM_TM2);
-    return packetUBXTIMTM2->moduleQueried.moduleQueried.bits.all;
-  }
-  else if (packetUBXTIMTM2->automaticFlags.flags.bits.automatic && !packetUBXTIMTM2->automaticFlags.flags.bits.implicitUpdate)
-  {
-    //Someone else has to call checkUblox for us...
-    return (false);
-  }
-  else
-  {
-    //The GPS is not automatically reporting navigation position so we have to poll explicitly
-    packetCfg.cls = UBX_CLASS_TIM;
-    packetCfg.id = UBX_TIM_TM2;
-    packetCfg.len = 0;
-    packetCfg.startingSpot = 0;
-
-    //The data is parsed as part of processing the response
-    sfe_ublox_status_e retVal = sendCommand(&packetCfg, maxWait);
-
-    if (retVal == SFE_UBLOX_STATUS_DATA_RECEIVED)
-      return (true);
-
-    if (retVal == SFE_UBLOX_STATUS_DATA_OVERWRITTEN)
-    {
-      return (true);
-    }
-
-    return (false);
-  }
-}
-
-//Enable or disable automatic navigation message generation by the GNSS. This changes the way getTIMTM2
-//works.
-boolean SFE_UBLOX_GNSS::setAutoTIMTM2(boolean enable, uint16_t maxWait)
-{
-  return setAutoTIMTM2rate(enable ? 1 : 0, true, maxWait);
-}
-
-//Enable or disable automatic navigation message generation by the GNSS. This changes the way getTIMTM2
-//works.
-boolean SFE_UBLOX_GNSS::setAutoTIMTM2(boolean enable, boolean implicitUpdate, uint16_t maxWait)
-{
-  return setAutoTIMTM2rate(enable ? 1 : 0, implicitUpdate, maxWait);
-}
-
-//Enable or disable automatic navigation message generation by the GNSS. This changes the way getTIMTM2
-//works.
-boolean SFE_UBLOX_GNSS::setAutoTIMTM2rate(uint8_t rate, boolean implicitUpdate, uint16_t maxWait)
-{
-  if (packetUBXTIMTM2 == NULL) initPacketUBXTIMTM2(); //Check that RAM has been allocated for the data
-  if (packetUBXTIMTM2 == NULL) //Only attempt this if RAM allocation was successful
-    return false;
-
-  if (rate > 127) rate = 127;
-
-  packetCfg.cls = UBX_CLASS_CFG;
-  packetCfg.id = UBX_CFG_MSG;
-  packetCfg.len = 3;
-  packetCfg.startingSpot = 0;
-  payloadCfg[0] = UBX_CLASS_TIM;
-  payloadCfg[1] = UBX_TIM_TM2;
-  payloadCfg[2] = rate; // rate relative to navigation freq.
-
-  boolean ok = ((sendCommand(&packetCfg, maxWait)) == SFE_UBLOX_STATUS_DATA_SENT); // We are only expecting an ACK
-  if (ok)
-  {
-    packetUBXTIMTM2->automaticFlags.flags.bits.automatic = (rate > 0);
-    packetUBXTIMTM2->automaticFlags.flags.bits.implicitUpdate = implicitUpdate;
-  }
-  packetUBXTIMTM2->moduleQueried.moduleQueried.bits.all = false;
-  return ok;
-}
-
-//Enable automatic navigation message generation by the GNSS.
-boolean SFE_UBLOX_GNSS::setAutoTIMTM2callback(void (*callbackPointer)(UBX_TIM_TM2_data_t), uint16_t maxWait)
-{
-  // Enable auto messages. Set implicitUpdate to false as we expect the user to call checkUblox manually.
-  boolean result = setAutoTIMTM2(true, false, maxWait);
-  if (!result)
-    return (result); // Bail if setAuto failed
-
-  if (packetUBXTIMTM2->callbackData == NULL) //Check if RAM has been allocated for the callback copy
-  {
-    packetUBXTIMTM2->callbackData = new UBX_TIM_TM2_data_t; //Allocate RAM for the main struct
-  }
-
-  if (packetUBXTIMTM2->callbackData == NULL)
-  {
-    if ((_printDebug == true) || (_printLimitedDebug == true)) // This is important. Print this if doing limited debugging
-      _debugSerial->println(F("setAutoTIMTM2callback: PANIC! RAM allocation failed!"));
-    return (false);
-  }
-
-  packetUBXTIMTM2->callbackPointer = callbackPointer;
-  return (true);
-}
-
-//In case no config access to the GNSS is possible and VELNED is send cyclically already
-//set config to suitable parameters
-boolean SFE_UBLOX_GNSS::assumeAutoTIMTM2(boolean enabled, boolean implicitUpdate)
-{
-  if (packetUBXTIMTM2 == NULL) initPacketUBXTIMTM2(); //Check that RAM has been allocated for the data
-  if (packetUBXTIMTM2 == NULL) //Only attempt this if RAM allocation was successful
-    return false;
-
-  boolean changes = packetUBXTIMTM2->automaticFlags.flags.bits.automatic != enabled || packetUBXTIMTM2->automaticFlags.flags.bits.implicitUpdate != implicitUpdate;
-  if (changes)
-  {
-    packetUBXTIMTM2->automaticFlags.flags.bits.automatic = enabled;
-    packetUBXTIMTM2->automaticFlags.flags.bits.implicitUpdate = implicitUpdate;
-  }
-  return changes;
-}
-
-// PRIVATE: Allocate RAM for packetUBXTIMTM2 and initialize it
-boolean SFE_UBLOX_GNSS::initPacketUBXTIMTM2()
-{
-  packetUBXTIMTM2 = new UBX_TIM_TM2_t; //Allocate RAM for the main struct
-  if (packetUBXTIMTM2 == NULL)
-  {
-    if ((_printDebug == true) || (_printLimitedDebug == true)) // This is important. Print this if doing limited debugging
-      _debugSerial->println(F("initPacketUBXTIMTM2: PANIC! RAM allocation failed!"));
-    return (false);
-  }
-  packetUBXTIMTM2->automaticFlags.flags.all = 0;
-  packetUBXTIMTM2->callbackPointer = NULL;
-  packetUBXTIMTM2->callbackData = NULL;
-  packetUBXTIMTM2->moduleQueried.moduleQueried.all = 0;
-  return (true);
-}
-
-//Mark all the data as read/stale
-void SFE_UBLOX_GNSS::flushTIMTM2()
-{
-  if (packetUBXTIMTM2 == NULL) return; // Bail if RAM has not been allocated (otherwise we could be writing anywhere!)
-  packetUBXTIMTM2->moduleQueried.moduleQueried.all = 0; //Mark all datums as stale (read before)
-}
-
-//Log this data in file buffer
-void SFE_UBLOX_GNSS::logTIMTM2(boolean enabled)
-{
-  if (packetUBXTIMTM2 == NULL) return; // Bail if RAM has not been allocated (otherwise we could be writing anywhere!)
-  packetUBXTIMTM2->automaticFlags.flags.bits.addToFileBuffer = (uint8_t)enabled;
-}
-
-// ***** ESF ALG automatic support
-
-boolean SFE_UBLOX_GNSS::getEsfAlignment(uint16_t maxWait)
-{
-  return (getESFALG(maxWait));
-}
-
-boolean SFE_UBLOX_GNSS::getESFALG(uint16_t maxWait)
-{
-  if (packetUBXESFALG == NULL) initPacketUBXESFALG(); //Check that RAM has been allocated for the ESF alignment data
-  if (packetUBXESFALG == NULL) //Only attempt this if RAM allocation was successful
-    return false;
-
-  if (packetUBXESFALG->automaticFlags.flags.bits.automatic && packetUBXESFALG->automaticFlags.flags.bits.implicitUpdate)
-  {
-    //The GPS is automatically reporting, we just check whether we got unread data
-    // if (_printDebug == true)
-    // {
-    //   _debugSerial->println(F("getEsfAlignment: Autoreporting"));
-    // }
-    checkUbloxInternal(&packetCfg, UBX_CLASS_ESF, UBX_ESF_ALG);
-    return packetUBXESFALG->moduleQueried.moduleQueried.bits.all;
-  }
-  else if (packetUBXESFALG->automaticFlags.flags.bits.automatic && !packetUBXESFALG->automaticFlags.flags.bits.implicitUpdate)
-  {
-    //Someone else has to call checkUblox for us...
-    // if (_printDebug == true)
-    // {
-    //   _debugSerial->println(F("getEsfAlignment: Exit immediately"));
-    // }
-    return (false);
-  }
-  else
-  {
-    // if (_printDebug == true)
-    // {
-    //   _debugSerial->println(F("getEsfAlignment: Polling"));
-    // }
-
-    //The GPS is not automatically reporting HNR PVT so we have to poll explicitly
-    packetCfg.cls = UBX_CLASS_ESF;
-    packetCfg.id = UBX_ESF_ALG;
-    packetCfg.len = 0;
-    packetCfg.startingSpot = 0;
-
-    //The data is parsed as part of processing the response
-    sfe_ublox_status_e retVal = sendCommand(&packetCfg, maxWait);
-
-    if (retVal == SFE_UBLOX_STATUS_DATA_RECEIVED)
-      return (true);
-
-    if (retVal == SFE_UBLOX_STATUS_DATA_OVERWRITTEN)
-    {
-      // if (_printDebug == true)
-      // {
-      //   _debugSerial->println(F("getEsfAlignment: data in packetCfg was OVERWRITTEN by another message (but that's OK)"));
-      // }
-      return (true);
-    }
-
-    // if (_printDebug == true)
-    // {
-    //   _debugSerial->print(F("getEsfAlignment retVal: "));
-    //   _debugSerial->println(statusString(retVal));
-    // }
-    return (false);
-  }
-
-  return (false); // Trap. We should never get here...
-}
-
-//Enable or disable automatic ESF ALG message generation by the GNSS. This changes the way getEsfAlignment
-//works.
-boolean SFE_UBLOX_GNSS::setAutoESFALG(boolean enable, uint16_t maxWait)
-{
-  return setAutoESFALGrate(enable ? 1 : 0, true, maxWait);
-}
-
-//Enable or disable automatic ESF ALG message generation by the GNSS. This changes the way getEsfAlignment
-//works.
-boolean SFE_UBLOX_GNSS::setAutoESFALG(boolean enable, boolean implicitUpdate, uint16_t maxWait)
-{
-  return setAutoESFALGrate(enable ? 1 : 0, implicitUpdate, maxWait);
-}
-
-//Enable or disable automatic ESF ALG message generation by the GNSS. This changes the way getEsfAlignment
-//works.
-boolean SFE_UBLOX_GNSS::setAutoESFALGrate(uint8_t rate, boolean implicitUpdate, uint16_t maxWait)
-{
-  if (packetUBXESFALG == NULL) initPacketUBXESFALG(); //Check that RAM has been allocated for the data
-  if (packetUBXESFALG == NULL) //Only attempt this if RAM allocation was successful
-    return false;
-
-  if (rate > 127) rate = 127;
-
-  packetCfg.cls = UBX_CLASS_CFG;
-  packetCfg.id = UBX_CFG_MSG;
-  packetCfg.len = 3;
-  packetCfg.startingSpot = 0;
-  payloadCfg[0] = UBX_CLASS_ESF;
-  payloadCfg[1] = UBX_ESF_ALG;
-  payloadCfg[2] = rate; // rate relative to navigation freq.
-
-  boolean ok = ((sendCommand(&packetCfg, maxWait)) == SFE_UBLOX_STATUS_DATA_SENT); // We are only expecting an ACK
-  if (ok)
-  {
-    packetUBXESFALG->automaticFlags.flags.bits.automatic = (rate > 0);
-    packetUBXESFALG->automaticFlags.flags.bits.implicitUpdate = implicitUpdate;
-  }
-  packetUBXESFALG->moduleQueried.moduleQueried.bits.all = false; // Mark data as stale
-  return ok;
-}
-
-//Enable automatic navigation message generation by the GNSS.
-boolean SFE_UBLOX_GNSS::setAutoESFALGcallback(void (*callbackPointer)(UBX_ESF_ALG_data_t), uint16_t maxWait)
-{
-  // Enable auto messages. Set implicitUpdate to false as we expect the user to call checkUblox manually.
-  boolean result = setAutoESFALG(true, false, maxWait);
-  if (!result)
-    return (result); // Bail if setAuto failed
-
-  if (packetUBXESFALG->callbackData == NULL) //Check if RAM has been allocated for the callback copy
-  {
-    packetUBXESFALG->callbackData = new UBX_ESF_ALG_data_t; //Allocate RAM for the main struct
-  }
-
-  if (packetUBXESFALG->callbackData == NULL)
-  {
-    if ((_printDebug == true) || (_printLimitedDebug == true)) // This is important. Print this if doing limited debugging
-      _debugSerial->println(F("setAutoESFALGcallback: PANIC! RAM allocation failed!"));
-    return (false);
-  }
-
-  packetUBXESFALG->callbackPointer = callbackPointer;
-  return (true);
-}
-
-//In case no config access to the GNSS is possible and ESF ALG is send cyclically already
-//set config to suitable parameters
-boolean SFE_UBLOX_GNSS::assumeAutoESFALG(boolean enabled, boolean implicitUpdate)
-{
-  if (packetUBXESFALG == NULL) initPacketUBXESFALG(); //Check that RAM has been allocated for the ESF alignment data
-  if (packetUBXESFALG == NULL) //Only attempt this if RAM allocation was successful
-    return false;
-
-  boolean changes = packetUBXESFALG->automaticFlags.flags.bits.automatic != enabled || packetUBXESFALG->automaticFlags.flags.bits.implicitUpdate != implicitUpdate;
-  if (changes)
-  {
-    packetUBXESFALG->automaticFlags.flags.bits.automatic = enabled;
-    packetUBXESFALG->automaticFlags.flags.bits.implicitUpdate = implicitUpdate;
-  }
-  return changes;
-}
-
-// PRIVATE: Allocate RAM for packetUBXESFALG and initialize it
-boolean SFE_UBLOX_GNSS::initPacketUBXESFALG()
-{
-  packetUBXESFALG = new UBX_ESF_ALG_t; //Allocate RAM for the main struct
-  if (packetUBXESFALG == NULL)
-  {
-    if ((_printDebug == true) || (_printLimitedDebug == true)) // This is important. Print this if doing limited debugging
-      _debugSerial->println(F("initPacketUBXESFALG: PANIC! RAM allocation failed!"));
-    return (false);
-  }
-  packetUBXESFALG->automaticFlags.flags.all = 0;
-  packetUBXESFALG->callbackPointer = NULL;
-  packetUBXESFALG->callbackData = NULL;
-  packetUBXESFALG->moduleQueried.moduleQueried.all = 0;
-  return (true);
-}
-
-//Mark all the data as read/stale
-void SFE_UBLOX_GNSS::flushESFALG()
-{
-  if (packetUBXESFALG == NULL) return; // Bail if RAM has not been allocated (otherwise we could be writing anywhere!)
-  packetUBXESFALG->moduleQueried.moduleQueried.all = 0; //Mark all datums as stale (read before)
-}
-
-//Log this data in file buffer
-void SFE_UBLOX_GNSS::logESFALG(boolean enabled)
-{
-  if (packetUBXESFALG == NULL) return; // Bail if RAM has not been allocated (otherwise we could be writing anywhere!)
-  packetUBXESFALG->automaticFlags.flags.bits.addToFileBuffer = (uint8_t)enabled;
-}
-
-// ***** ESF STATUS automatic support
-
-boolean SFE_UBLOX_GNSS::getEsfInfo(uint16_t maxWait)
-{
-  return (getESFSTATUS(maxWait));
-}
-
-boolean SFE_UBLOX_GNSS::getESFSTATUS(uint16_t maxWait)
-{
-  if (packetUBXESFSTATUS == NULL) initPacketUBXESFSTATUS(); //Check that RAM has been allocated for the ESF status data
-  if (packetUBXESFSTATUS == NULL) //Only attempt this if RAM allocation was successful
-    return false;
-
-  if (packetUBXESFSTATUS->automaticFlags.flags.bits.automatic && packetUBXESFSTATUS->automaticFlags.flags.bits.implicitUpdate)
-  {
-    //The GPS is automatically reporting, we just check whether we got unread data
-    // if (_printDebug == true)
-    // {
-    //   _debugSerial->println(F("getEsfInfo: Autoreporting"));
-    // }
-    checkUbloxInternal(&packetCfg, UBX_CLASS_ESF, UBX_ESF_STATUS);
-    return packetUBXESFSTATUS->moduleQueried.moduleQueried.bits.all;
-  }
-  else if (packetUBXESFSTATUS->automaticFlags.flags.bits.automatic && !packetUBXESFSTATUS->automaticFlags.flags.bits.implicitUpdate)
-  {
-    //Someone else has to call checkUblox for us...
-    // if (_printDebug == true)
-    // {
-    //   _debugSerial->println(F("getEsfInfo: Exit immediately"));
-    // }
-    return (false);
-  }
-  else
-  {
-    // if (_printDebug == true)
-    // {
-    //   _debugSerial->println(F("getEsfInfo: Polling"));
-    // }
-
-    //The GPS is not automatically reporting HNR PVT so we have to poll explicitly
-    packetCfg.cls = UBX_CLASS_ESF;
-    packetCfg.id = UBX_ESF_STATUS;
-    packetCfg.len = 0;
-    packetCfg.startingSpot = 0;
-
-    //The data is parsed as part of processing the response
-    sfe_ublox_status_e retVal = sendCommand(&packetCfg, maxWait);
-
-    if (retVal == SFE_UBLOX_STATUS_DATA_RECEIVED)
-      return (true);
-
-    if (retVal == SFE_UBLOX_STATUS_DATA_OVERWRITTEN)
-    {
-      // if (_printDebug == true)
-      // {
-      //   _debugSerial->println(F("getEsfInfo: data in packetCfg was OVERWRITTEN by another message (but that's OK)"));
-      // }
-      return (true);
-    }
-
-    // if (_printDebug == true)
-    // {
-    //   _debugSerial->print(F("getEsfInfo retVal: "));
-    //   _debugSerial->println(statusString(retVal));
-    // }
-    return (false);
-  }
-
-  return (false); // Trap. We should never get here...
-}
-
-//Enable or disable automatic ESF STATUS message generation by the GNSS. This changes the way getESFInfo
-//works.
-boolean SFE_UBLOX_GNSS::setAutoESFSTATUS(boolean enable, uint16_t maxWait)
-{
-  return setAutoESFSTATUSrate(enable ? 1 : 0, true, maxWait);
-}
-
-//Enable or disable automatic ESF STATUS message generation by the GNSS. This changes the way getESFInfo
-//works.
-boolean SFE_UBLOX_GNSS::setAutoESFSTATUS(boolean enable, boolean implicitUpdate, uint16_t maxWait)
-{
-  return setAutoESFSTATUSrate(enable ? 1 : 0, implicitUpdate, maxWait);
-}
-
-//Enable or disable automatic ESF STATUS message generation by the GNSS. This changes the way getESFInfo
-//works.
-boolean SFE_UBLOX_GNSS::setAutoESFSTATUSrate(uint8_t rate, boolean implicitUpdate, uint16_t maxWait)
-{
-  if (packetUBXESFSTATUS == NULL) initPacketUBXESFSTATUS(); //Check that RAM has been allocated for the data
-  if (packetUBXESFSTATUS == NULL) //Only attempt this if RAM allocation was successful
-    return false;
-
-  if (rate > 127) rate = 127;
-
-  packetCfg.cls = UBX_CLASS_CFG;
-  packetCfg.id = UBX_CFG_MSG;
-  packetCfg.len = 3;
-  packetCfg.startingSpot = 0;
-  payloadCfg[0] = UBX_CLASS_ESF;
-  payloadCfg[1] = UBX_ESF_STATUS;
-  payloadCfg[2] = rate; // rate relative to navigation freq.
-
-  boolean ok = ((sendCommand(&packetCfg, maxWait)) == SFE_UBLOX_STATUS_DATA_SENT); // We are only expecting an ACK
-  if (ok)
-  {
-    packetUBXESFSTATUS->automaticFlags.flags.bits.automatic = (rate > 0);
-    packetUBXESFSTATUS->automaticFlags.flags.bits.implicitUpdate = implicitUpdate;
-  }
-  packetUBXESFSTATUS->moduleQueried.moduleQueried.bits.all = false; // Mark data as stale
-  return ok;
-}
-
-//Enable automatic navigation message generation by the GNSS.
-boolean SFE_UBLOX_GNSS::setAutoESFSTATUScallback(void (*callbackPointer)(UBX_ESF_STATUS_data_t), uint16_t maxWait)
-{
-  // Enable auto messages. Set implicitUpdate to false as we expect the user to call checkUblox manually.
-  boolean result = setAutoESFSTATUS(true, false, maxWait);
-  if (!result)
-    return (result); // Bail if setAuto failed
-
-  if (packetUBXESFSTATUS->callbackData == NULL) //Check if RAM has been allocated for the callback copy
-  {
-    packetUBXESFSTATUS->callbackData = new UBX_ESF_STATUS_data_t; //Allocate RAM for the main struct
-  }
-
-  if (packetUBXESFSTATUS->callbackData == NULL)
-  {
-    if ((_printDebug == true) || (_printLimitedDebug == true)) // This is important. Print this if doing limited debugging
-      _debugSerial->println(F("setAutoESFSTATUScallback: PANIC! RAM allocation failed!"));
-    return (false);
-  }
-
-  packetUBXESFSTATUS->callbackPointer = callbackPointer;
-  return (true);
-}
-
-//In case no config access to the GNSS is possible and ESF STATUS is send cyclically already
-//set config to suitable parameters
-boolean SFE_UBLOX_GNSS::assumeAutoESFSTATUS(boolean enabled, boolean implicitUpdate)
-{
-  if (packetUBXESFSTATUS == NULL) initPacketUBXESFSTATUS(); //Check that RAM has been allocated for the ESF status data
-  if (packetUBXESFSTATUS == NULL) //Only attempt this if RAM allocation was successful
-    return false;
-
-  boolean changes = packetUBXESFSTATUS->automaticFlags.flags.bits.automatic != enabled || packetUBXESFSTATUS->automaticFlags.flags.bits.implicitUpdate != implicitUpdate;
-  if (changes)
-  {
-    packetUBXESFSTATUS->automaticFlags.flags.bits.automatic = enabled;
-    packetUBXESFSTATUS->automaticFlags.flags.bits.implicitUpdate = implicitUpdate;
-  }
-  return changes;
-}
-
-// PRIVATE: Allocate RAM for packetUBXESFSTATUS and initialize it
-boolean SFE_UBLOX_GNSS::initPacketUBXESFSTATUS()
-{
-  packetUBXESFSTATUS = new UBX_ESF_STATUS_t; //Allocate RAM for the main struct
-
-  if (packetUBXESFSTATUS == NULL)
-  {
-    if ((_printDebug == true) || (_printLimitedDebug == true)) // This is important. Print this if doing limited debugging
-      _debugSerial->println(F("initPacketUBXESFSTATUS: PANIC! RAM allocation failed!"));
-    return (false);
-  }
-  packetUBXESFSTATUS->automaticFlags.flags.all = 0;
-  packetUBXESFSTATUS->callbackPointer = NULL;
-  packetUBXESFSTATUS->callbackData = NULL;
-  packetUBXESFSTATUS->moduleQueried.moduleQueried.all = 0;
-  return (true);
-}
-
-//Mark all the data as read/stale
-void SFE_UBLOX_GNSS::flushESFSTATUS()
-{
-  if (packetUBXESFSTATUS == NULL) return; // Bail if RAM has not been allocated (otherwise we could be writing anywhere!)
-  packetUBXESFSTATUS->moduleQueried.moduleQueried.all = 0; //Mark all datums as stale (read before)
-}
-
-//Log this data in file buffer
-void SFE_UBLOX_GNSS::logESFSTATUS(boolean enabled)
-{
-  if (packetUBXESFSTATUS == NULL) return; // Bail if RAM has not been allocated (otherwise we could be writing anywhere!)
-  packetUBXESFSTATUS->automaticFlags.flags.bits.addToFileBuffer = (uint8_t)enabled;
-}
-
-// ***** ESF INS automatic support
-
-boolean SFE_UBLOX_GNSS::getEsfIns(uint16_t maxWait)
-{
-  return (getESFINS(maxWait));
-}
-
-boolean SFE_UBLOX_GNSS::getESFINS(uint16_t maxWait)
-{
-  if (packetUBXESFINS == NULL) initPacketUBXESFINS(); //Check that RAM has been allocated for the ESF INS data
-  if (packetUBXESFINS == NULL) //Only attempt this if RAM allocation was successful
-    return false;
-
-  if (packetUBXESFINS->automaticFlags.flags.bits.automatic && packetUBXESFINS->automaticFlags.flags.bits.implicitUpdate)
-  {
-    //The GPS is automatically reporting, we just check whether we got unread data
-    // if (_printDebug == true)
-    // {
-    //   _debugSerial->println(F("getEsfIns: Autoreporting"));
-    // }
-    checkUbloxInternal(&packetCfg, UBX_CLASS_ESF, UBX_ESF_INS);
-    return packetUBXESFINS->moduleQueried.moduleQueried.bits.all;
-  }
-  else if (packetUBXESFINS->automaticFlags.flags.bits.automatic && !packetUBXESFINS->automaticFlags.flags.bits.implicitUpdate)
-  {
-    //Someone else has to call checkUblox for us...
-    // if (_printDebug == true)
-    // {
-    //   _debugSerial->println(F("getEsfIns: Exit immediately"));
-    // }
-    return (false);
-  }
-  else
-  {
-    // if (_printDebug == true)
-    // {
-    //   _debugSerial->println(F("getEsfIns: Polling"));
-    // }
-
-    //The GPS is not automatically reporting HNR PVT so we have to poll explicitly
-    packetCfg.cls = UBX_CLASS_ESF;
-    packetCfg.id = UBX_ESF_INS;
-    packetCfg.len = 0;
-    packetCfg.startingSpot = 0;
-
-    //The data is parsed as part of processing the response
-    sfe_ublox_status_e retVal = sendCommand(&packetCfg, maxWait);
-
-    if (retVal == SFE_UBLOX_STATUS_DATA_RECEIVED)
-      return (true);
-
-    if (retVal == SFE_UBLOX_STATUS_DATA_OVERWRITTEN)
-    {
-      // if (_printDebug == true)
-      // {
-      //   _debugSerial->println(F("getEsfIns: data in packetCfg was OVERWRITTEN by another message (but that's OK)"));
-      // }
-      return (true);
-    }
-
-    // if (_printDebug == true)
-    // {
-    //   _debugSerial->print(F("getEsfIns retVal: "));
-    //   _debugSerial->println(statusString(retVal));
-    // }
-    return (false);
-  }
-
-  return (false); // Trap. We should never get here...
-}
-
-//Enable or disable automatic ESF INS message generation by the GNSS. This changes the way getESFIns
-//works.
-boolean SFE_UBLOX_GNSS::setAutoESFINS(boolean enable, uint16_t maxWait)
-{
-  return setAutoESFINSrate(enable ? 1 : 0, true, maxWait);
-}
-
-//Enable or disable automatic ESF INS message generation by the GNSS. This changes the way getESFIns
-//works.
-boolean SFE_UBLOX_GNSS::setAutoESFINS(boolean enable, boolean implicitUpdate, uint16_t maxWait)
-{
-  return setAutoESFINSrate(enable ? 1 : 0, implicitUpdate, maxWait);
-}
-
-//Enable or disable automatic ESF INS message generation by the GNSS. This changes the way getESFIns
-//works.
-boolean SFE_UBLOX_GNSS::setAutoESFINSrate(uint8_t rate, boolean implicitUpdate, uint16_t maxWait)
-{
-  if (packetUBXESFINS == NULL) initPacketUBXESFINS(); //Check that RAM has been allocated for the data
-  if (packetUBXESFINS == NULL) //Only attempt this if RAM allocation was successful
-    return false;
-
-  if (rate > 127) rate = 127;
-
-  packetCfg.cls = UBX_CLASS_CFG;
-  packetCfg.id = UBX_CFG_MSG;
-  packetCfg.len = 3;
-  packetCfg.startingSpot = 0;
-  payloadCfg[0] = UBX_CLASS_ESF;
-  payloadCfg[1] = UBX_ESF_INS;
-  payloadCfg[2] = rate; // rate relative to navigation freq.
-
-  boolean ok = ((sendCommand(&packetCfg, maxWait)) == SFE_UBLOX_STATUS_DATA_SENT); // We are only expecting an ACK
-  if (ok)
-  {
-    packetUBXESFINS->automaticFlags.flags.bits.automatic = (rate > 0);
-    packetUBXESFINS->automaticFlags.flags.bits.implicitUpdate = implicitUpdate;
-  }
-  packetUBXESFINS->moduleQueried.moduleQueried.bits.all = false; // Mark data as stale
-  return ok;
-}
-
-//Enable automatic navigation message generation by the GNSS.
-boolean SFE_UBLOX_GNSS::setAutoESFINScallback(void (*callbackPointer)(UBX_ESF_INS_data_t), uint16_t maxWait)
-{
-  // Enable auto messages. Set implicitUpdate to false as we expect the user to call checkUblox manually.
-  boolean result = setAutoESFINS(true, false, maxWait);
-  if (!result)
-    return (result); // Bail if setAuto failed
-
-  if (packetUBXESFINS->callbackData == NULL) //Check if RAM has been allocated for the callback copy
-  {
-    packetUBXESFINS->callbackData = new UBX_ESF_INS_data_t; //Allocate RAM for the main struct
-  }
-
-  if (packetUBXESFINS->callbackData == NULL)
-  {
-    if ((_printDebug == true) || (_printLimitedDebug == true)) // This is important. Print this if doing limited debugging
-      _debugSerial->println(F("setAutoESFINScallback: PANIC! RAM allocation failed!"));
-    return (false);
-  }
-
-  packetUBXESFINS->callbackPointer = callbackPointer;
-  return (true);
-}
-
-//In case no config access to the GNSS is possible and ESF INS is send cyclically already
-//set config to suitable parameters
-boolean SFE_UBLOX_GNSS::assumeAutoESFINS(boolean enabled, boolean implicitUpdate)
-{
-  if (packetUBXESFINS == NULL) initPacketUBXESFINS(); //Check that RAM has been allocated for the ESF INS data
-  if (packetUBXESFINS == NULL) //Only attempt this if RAM allocation was successful
-    return false;
-
-  boolean changes = packetUBXESFINS->automaticFlags.flags.bits.automatic != enabled || packetUBXESFINS->automaticFlags.flags.bits.implicitUpdate != implicitUpdate;
-  if (changes)
-  {
-    packetUBXESFINS->automaticFlags.flags.bits.automatic = enabled;
-    packetUBXESFINS->automaticFlags.flags.bits.implicitUpdate = implicitUpdate;
-  }
-  return changes;
-}
-
-// PRIVATE: Allocate RAM for packetUBXESFINS and initialize it
-boolean SFE_UBLOX_GNSS::initPacketUBXESFINS()
-{
-  packetUBXESFINS = new UBX_ESF_INS_t; //Allocate RAM for the main struct
-  if (packetUBXESFINS == NULL)
-  {
-    if ((_printDebug == true) || (_printLimitedDebug == true)) // This is important. Print this if doing limited debugging
-      _debugSerial->println(F("initPacketUBXESFINS: PANIC! RAM allocation failed!"));
-    return (false);
-  }
-  packetUBXESFINS->automaticFlags.flags.all = 0;
-  packetUBXESFINS->callbackPointer = NULL;
-  packetUBXESFINS->callbackData = NULL;
-  packetUBXESFINS->moduleQueried.moduleQueried.all = 0;
-  return (true);
-}
-
-//Mark all the data as read/stale
-void SFE_UBLOX_GNSS::flushESFINS()
-{
-  if (packetUBXESFINS == NULL) return; // Bail if RAM has not been allocated (otherwise we could be writing anywhere!)
-  packetUBXESFINS->moduleQueried.moduleQueried.all = 0; //Mark all datums as stale (read before)
-}
-
-//Log this data in file buffer
-void SFE_UBLOX_GNSS::logESFINS(boolean enabled)
-{
-  if (packetUBXESFINS == NULL) return; // Bail if RAM has not been allocated (otherwise we could be writing anywhere!)
-  packetUBXESFINS->automaticFlags.flags.bits.addToFileBuffer = (uint8_t)enabled;
-}
-
-// ***** ESF MEAS automatic support
-
-boolean SFE_UBLOX_GNSS::getEsfDataInfo(uint16_t maxWait)
-{
-  return (getESFMEAS(maxWait));
-}
-
-boolean SFE_UBLOX_GNSS::getESFMEAS(uint16_t maxWait)
-{
-  if (packetUBXESFMEAS == NULL) initPacketUBXESFMEAS(); //Check that RAM has been allocated for the ESF MEAS data
-  if (packetUBXESFMEAS == NULL) //Only attempt this if RAM allocation was successful
-    return false;
-
-  if (packetUBXESFMEAS->automaticFlags.flags.bits.automatic && packetUBXESFMEAS->automaticFlags.flags.bits.implicitUpdate)
-  {
-    //The GPS is automatically reporting, we just check whether we got unread data
-    // if (_printDebug == true)
-    // {
-    //   _debugSerial->println(F("getEsfDataInfo: Autoreporting"));
-    // }
-    checkUbloxInternal(&packetCfg, UBX_CLASS_ESF, UBX_ESF_MEAS);
-    return packetUBXESFMEAS->moduleQueried.moduleQueried.bits.all;
-  }
-  else if (packetUBXESFMEAS->automaticFlags.flags.bits.automatic && !packetUBXESFMEAS->automaticFlags.flags.bits.implicitUpdate)
-  {
-    //Someone else has to call checkUblox for us...
-    // if (_printDebug == true)
-    // {
-    //   _debugSerial->println(F("getEsfDataInfo: Exit immediately"));
-    // }
-    return (false);
-  }
-  else
-  {
-    // if (_printDebug == true)
-    // {
-    //   _debugSerial->println(F("getEsfDataInfo: Polling"));
-    // }
-
-    //The GPS is not automatically reporting HNR PVT so we have to poll explicitly
-    packetCfg.cls = UBX_CLASS_ESF;
-    packetCfg.id = UBX_ESF_MEAS;
-    packetCfg.len = 0;
-    packetCfg.startingSpot = 0;
-
-    //The data is parsed as part of processing the response
-    sfe_ublox_status_e retVal = sendCommand(&packetCfg, maxWait);
-
-    if (retVal == SFE_UBLOX_STATUS_DATA_RECEIVED)
-      return (true);
-
-    if (retVal == SFE_UBLOX_STATUS_DATA_OVERWRITTEN)
-    {
-      // if (_printDebug == true)
-      // {
-      //   _debugSerial->println(F("getEsfDataInfo: data in packetCfg was OVERWRITTEN by another message (but that's OK)"));
-      // }
-      return (true);
-    }
-
-    // if (_printDebug == true)
-    // {
-    //   _debugSerial->print(F("getEsfDataInfo retVal: "));
-    //   _debugSerial->println(statusString(retVal));
-    // }
-    return (false);
-  }
-
-  return (false); // Trap. We should never get here...
-}
-
-//Enable or disable automatic ESF MEAS message generation by the GNSS. This changes the way getESFDataInfo
-//works.
-boolean SFE_UBLOX_GNSS::setAutoESFMEAS(boolean enable, uint16_t maxWait)
-{
-  return setAutoESFMEASrate(enable ? 1 : 0, true, maxWait);
-}
-
-//Enable or disable automatic ESF MEAS message generation by the GNSS. This changes the way getESFDataInfo
-//works.
-boolean SFE_UBLOX_GNSS::setAutoESFMEAS(boolean enable, boolean implicitUpdate, uint16_t maxWait)
-{
-  return setAutoESFMEASrate(enable ? 1 : 0, implicitUpdate, maxWait);
-}
-
-//Enable or disable automatic ESF MEAS message generation by the GNSS. This changes the way getESFDataInfo
-//works.
-boolean SFE_UBLOX_GNSS::setAutoESFMEASrate(uint8_t rate, boolean implicitUpdate, uint16_t maxWait)
-{
-  if (packetUBXESFMEAS == NULL) initPacketUBXESFMEAS(); //Check that RAM has been allocated for the data
-  if (packetUBXESFMEAS == NULL) //Only attempt this if RAM allocation was successful
-    return false;
-
-  if (rate > 127) rate = 127;
-
-  packetCfg.cls = UBX_CLASS_CFG;
-  packetCfg.id = UBX_CFG_MSG;
-  packetCfg.len = 3;
-  packetCfg.startingSpot = 0;
-  payloadCfg[0] = UBX_CLASS_ESF;
-  payloadCfg[1] = UBX_ESF_MEAS;
-  payloadCfg[2] = rate; // rate relative to navigation freq.
-
-  boolean ok = ((sendCommand(&packetCfg, maxWait)) == SFE_UBLOX_STATUS_DATA_SENT); // We are only expecting an ACK
-  if (ok)
-  {
-    packetUBXESFMEAS->automaticFlags.flags.bits.automatic = (rate > 0);
-    packetUBXESFMEAS->automaticFlags.flags.bits.implicitUpdate = implicitUpdate;
-  }
-  packetUBXESFMEAS->moduleQueried.moduleQueried.bits.all = false; // Mark data as stale
-  return ok;
-}
-
-//Enable automatic navigation message generation by the GNSS.
-boolean SFE_UBLOX_GNSS::setAutoESFMEAScallback(void (*callbackPointer)(UBX_ESF_MEAS_data_t), uint16_t maxWait)
-{
-  // Enable auto messages. Set implicitUpdate to false as we expect the user to call checkUblox manually.
-  boolean result = setAutoESFMEAS(true, false, maxWait);
-  if (!result)
-    return (result); // Bail if setAuto failed
-
-  if (packetUBXESFMEAS->callbackData == NULL) //Check if RAM has been allocated for the callback copy
-  {
-    packetUBXESFMEAS->callbackData = new UBX_ESF_MEAS_data_t; //Allocate RAM for the main struct
-  }
-
-  if (packetUBXESFMEAS->callbackData == NULL)
-  {
-    if ((_printDebug == true) || (_printLimitedDebug == true)) // This is important. Print this if doing limited debugging
-      _debugSerial->println(F("setAutoESFMEAScallback: PANIC! RAM allocation failed!"));
-    return (false);
-  }
-
-  packetUBXESFMEAS->callbackPointer = callbackPointer;
-  return (true);
-}
-
-//In case no config access to the GNSS is possible and ESF MEAS is send cyclically already
-//set config to suitable parameters
-boolean SFE_UBLOX_GNSS::assumeAutoESFMEAS(boolean enabled, boolean implicitUpdate)
-{
-  if (packetUBXESFMEAS == NULL) initPacketUBXESFMEAS(); //Check that RAM has been allocated for the ESF MEAS data
-  if (packetUBXESFMEAS == NULL) //Only attempt this if RAM allocation was successful
-    return false;
-
-  boolean changes = packetUBXESFMEAS->automaticFlags.flags.bits.automatic != enabled || packetUBXESFMEAS->automaticFlags.flags.bits.implicitUpdate != implicitUpdate;
-  if (changes)
-  {
-    packetUBXESFMEAS->automaticFlags.flags.bits.automatic = enabled;
-    packetUBXESFMEAS->automaticFlags.flags.bits.implicitUpdate = implicitUpdate;
-  }
-  return changes;
-}
-
-// PRIVATE: Allocate RAM for packetUBXESFMEAS and initialize it
-boolean SFE_UBLOX_GNSS::initPacketUBXESFMEAS()
-{
-  packetUBXESFMEAS = new UBX_ESF_MEAS_t; //Allocate RAM for the main struct
-  if (packetUBXESFMEAS == NULL)
-  {
-    if ((_printDebug == true) || (_printLimitedDebug == true)) // This is important. Print this if doing limited debugging
-      _debugSerial->println(F("initPacketUBXESFMEAS: PANIC! RAM allocation failed!"));
-    return (false);
-  }
-  packetUBXESFMEAS->automaticFlags.flags.all = 0;
-  packetUBXESFMEAS->callbackPointer = NULL;
-  packetUBXESFMEAS->callbackData = NULL;
-  packetUBXESFMEAS->moduleQueried.moduleQueried.all = 0;
-  return (true);
-}
-
-//Mark all the data as read/stale
-void SFE_UBLOX_GNSS::flushESFMEAS()
-{
-  if (packetUBXESFMEAS == NULL) return; // Bail if RAM has not been allocated (otherwise we could be writing anywhere!)
-  packetUBXESFMEAS->moduleQueried.moduleQueried.all = 0; //Mark all datums as stale (read before)
-}
-
-//Log this data in file buffer
-void SFE_UBLOX_GNSS::logESFMEAS(boolean enabled)
-{
-  if (packetUBXESFMEAS == NULL) return; // Bail if RAM has not been allocated (otherwise we could be writing anywhere!)
-  packetUBXESFMEAS->automaticFlags.flags.bits.addToFileBuffer = (uint8_t)enabled;
-}
-
-// ***** ESF RAW automatic support
-
-boolean SFE_UBLOX_GNSS::getEsfRawDataInfo(uint16_t maxWait)
-{
-  return (getESFRAW(maxWait));
-}
-
-boolean SFE_UBLOX_GNSS::getESFRAW(uint16_t maxWait)
-{
-  if (packetUBXESFRAW == NULL) initPacketUBXESFRAW(); //Check that RAM has been allocated for the ESF RAW data
-  if (packetUBXESFRAW == NULL) //Only attempt this if RAM allocation was successful
-    return false;
-
-  if (packetUBXESFRAW->automaticFlags.flags.bits.automatic && packetUBXESFRAW->automaticFlags.flags.bits.implicitUpdate)
-  {
-    //The GPS is automatically reporting, we just check whether we got unread data
-    // if (_printDebug == true)
-    // {
-    //   _debugSerial->println(F("getEsfRawDataInfo: Autoreporting"));
-    // }
-    checkUbloxInternal(&packetCfg, UBX_CLASS_ESF, UBX_ESF_RAW);
-    return packetUBXESFRAW->moduleQueried.moduleQueried.bits.all;
-  }
-  else if (packetUBXESFRAW->automaticFlags.flags.bits.automatic && !packetUBXESFRAW->automaticFlags.flags.bits.implicitUpdate)
-  {
-    //Someone else has to call checkUblox for us...
-    // if (_printDebug == true)
-    // {
-    //   _debugSerial->println(F("getEsfRawDataInfo: Exit immediately"));
-    // }
-    return (false);
-  }
-  else
-  {
-    // if (_printDebug == true)
-    // {
-    //   _debugSerial->println(F("getEsfRawDataInfo: Polling"));
-    // }
-
-    //The GPS is not automatically reporting HNR PVT so we have to poll explicitly
-    packetCfg.cls = UBX_CLASS_ESF;
-    packetCfg.id = UBX_ESF_RAW;
-    packetCfg.len = 0;
-    packetCfg.startingSpot = 0;
-
-    //The data is parsed as part of processing the response
-    sfe_ublox_status_e retVal = sendCommand(&packetCfg, maxWait);
-
-    if (retVal == SFE_UBLOX_STATUS_DATA_RECEIVED)
-      return (true);
-
-    if (retVal == SFE_UBLOX_STATUS_DATA_OVERWRITTEN)
-    {
-      // if (_printDebug == true)
-      // {
-      //   _debugSerial->println(F("getEsfRawDataInfo: data in packetCfg was OVERWRITTEN by another message (but that's OK)"));
-      // }
-      return (true);
-    }
-
-    // if (_printDebug == true)
-    // {
-    //   _debugSerial->print(F("getEsfRawDataInfo retVal: "));
-    //   _debugSerial->println(statusString(retVal));
-    // }
-    return (false);
-  }
-
-  return (false); // Trap. We should never get here...
-}
-
-//Enable or disable automatic ESF RAW message generation by the GNSS. This changes the way getESFRawDataInfo
-//works.
-boolean SFE_UBLOX_GNSS::setAutoESFRAW(boolean enable, uint16_t maxWait)
-{
-  return setAutoESFRAWrate(enable ? 1 : 0, true, maxWait);
-}
-
-//Enable or disable automatic ESF RAW message generation by the GNSS. This changes the way getESFRawDataInfo
-//works.
-boolean SFE_UBLOX_GNSS::setAutoESFRAW(boolean enable, boolean implicitUpdate, uint16_t maxWait)
-{
-  return setAutoESFRAWrate(enable ? 1 : 0, implicitUpdate, maxWait);
-}
-
-//Enable or disable automatic ESF RAW message generation by the GNSS. This changes the way getESFRawDataInfo
-//works.
-boolean SFE_UBLOX_GNSS::setAutoESFRAWrate(uint8_t rate, boolean implicitUpdate, uint16_t maxWait)
-{
-  if (packetUBXESFRAW == NULL) initPacketUBXESFRAW(); //Check that RAM has been allocated for the data
-  if (packetUBXESFRAW == NULL) //Only attempt this if RAM allocation was successful
-    return false;
-
-  if (rate > 127) rate = 127;
-
-  packetCfg.cls = UBX_CLASS_CFG;
-  packetCfg.id = UBX_CFG_MSG;
-  packetCfg.len = 3;
-  packetCfg.startingSpot = 0;
-  payloadCfg[0] = UBX_CLASS_ESF;
-  payloadCfg[1] = UBX_ESF_RAW;
-  payloadCfg[2] = rate; // rate relative to navigation freq.
-
-  boolean ok = ((sendCommand(&packetCfg, maxWait)) == SFE_UBLOX_STATUS_DATA_SENT); // We are only expecting an ACK
-  if (ok)
-  {
-    packetUBXESFRAW->automaticFlags.flags.bits.automatic = (rate > 0);
-    packetUBXESFRAW->automaticFlags.flags.bits.implicitUpdate = implicitUpdate;
-  }
-  packetUBXESFRAW->moduleQueried.moduleQueried.bits.all = false; // Mark data as stale
-  return ok;
-}
-
-//Enable automatic navigation message generation by the GNSS.
-boolean SFE_UBLOX_GNSS::setAutoESFRAWcallback(void (*callbackPointer)(UBX_ESF_RAW_data_t), uint16_t maxWait)
-{
-  // Enable auto messages. Set implicitUpdate to false as we expect the user to call checkUblox manually.
-  boolean result = setAutoESFRAW(true, false, maxWait);
-  if (!result)
-    return (result); // Bail if setAuto failed
-
-  if (packetUBXESFRAW->callbackData == NULL) //Check if RAM has been allocated for the callback copy
-  {
-    packetUBXESFRAW->callbackData = new UBX_ESF_RAW_data_t; //Allocate RAM for the main struct
-  }
-
-  if (packetUBXESFRAW->callbackData == NULL)
-  {
-    if ((_printDebug == true) || (_printLimitedDebug == true)) // This is important. Print this if doing limited debugging
-      _debugSerial->println(F("setAutoESFRAWcallback: PANIC! RAM allocation failed!"));
-    return (false);
-  }
-
-  packetUBXESFRAW->callbackPointer = callbackPointer;
-  return (true);
-}
-
-//In case no config access to the GNSS is possible and ESF RAW is send cyclically already
-//set config to suitable parameters
-boolean SFE_UBLOX_GNSS::assumeAutoESFRAW(boolean enabled, boolean implicitUpdate)
-{
-  if (packetUBXESFRAW == NULL) initPacketUBXESFRAW(); //Check that RAM has been allocated for the ESF RAW data
-  if (packetUBXESFRAW == NULL) //Only attempt this if RAM allocation was successful
-    return false;
-
-  boolean changes = packetUBXESFRAW->automaticFlags.flags.bits.automatic != enabled || packetUBXESFRAW->automaticFlags.flags.bits.implicitUpdate != implicitUpdate;
-  if (changes)
-  {
-    packetUBXESFRAW->automaticFlags.flags.bits.automatic = enabled;
-    packetUBXESFRAW->automaticFlags.flags.bits.implicitUpdate = implicitUpdate;
-  }
-  return changes;
-}
-
-// PRIVATE: Allocate RAM for packetUBXESFRAW and initialize it
-boolean SFE_UBLOX_GNSS::initPacketUBXESFRAW()
-{
-  packetUBXESFRAW = new UBX_ESF_RAW_t; //Allocate RAM for the main struct
-  if (packetUBXESFRAW == NULL)
-  {
-    if ((_printDebug == true) || (_printLimitedDebug == true)) // This is important. Print this if doing limited debugging
-      _debugSerial->println(F("initPacketUBXESFRAW: PANIC! RAM allocation failed!"));
-    return (false);
-  }
-  packetUBXESFRAW->automaticFlags.flags.all = 0;
-  packetUBXESFRAW->callbackPointer = NULL;
-  packetUBXESFRAW->callbackData = NULL;
-  packetUBXESFRAW->moduleQueried.moduleQueried.all = 0;
-  return (true);
-}
-
-//Mark all the data as read/stale
-void SFE_UBLOX_GNSS::flushESFRAW()
-{
-  if (packetUBXESFRAW == NULL) return; // Bail if RAM has not been allocated (otherwise we could be writing anywhere!)
-  packetUBXESFRAW->moduleQueried.moduleQueried.all = 0; //Mark all datums as stale (read before)
-}
-
-//Log this data in file buffer
-void SFE_UBLOX_GNSS::logESFRAW(boolean enabled)
-{
-  if (packetUBXESFRAW == NULL) return; // Bail if RAM has not been allocated (otherwise we could be writing anywhere!)
-  packetUBXESFRAW->automaticFlags.flags.bits.addToFileBuffer = (uint8_t)enabled;
-}
-
-// ***** HNR ATT automatic support
-
-boolean SFE_UBLOX_GNSS::getHNRAtt(uint16_t maxWait)
-{
-  return (getHNRATT(maxWait));
-}
-
-//Get the HNR Attitude data
-// Returns true if the get HNR attitude is successful. Data is returned in hnrAtt
-// Note: if hnrAttQueried is true, it gets set to false by this function since we assume
-//       that the user will read hnrAtt immediately after this. I.e. this function will
-//       only return true _once_ after each auto HNR Att is processed
-boolean SFE_UBLOX_GNSS::getHNRATT(uint16_t maxWait)
-{
-  if (packetUBXHNRATT == NULL) initPacketUBXHNRATT(); //Check that RAM has been allocated for the data
-  if (packetUBXHNRATT == NULL) //Bail if the RAM allocation failed
-    return (false);
-
-  if (packetUBXHNRATT->automaticFlags.flags.bits.automatic && packetUBXHNRATT->automaticFlags.flags.bits.implicitUpdate)
-  {
-    //The GPS is automatically reporting, we just check whether we got unread data
-    // if (_printDebug == true)
-    // {
-    //   _debugSerial->println(F("getHNRAtt: Autoreporting"));
-    // }
-    checkUbloxInternal(&packetCfg, UBX_CLASS_HNR, UBX_HNR_ATT);
-    return packetUBXHNRATT->moduleQueried.moduleQueried.bits.all;
-  }
-  else if (packetUBXHNRATT->automaticFlags.flags.bits.automatic && !packetUBXHNRATT->automaticFlags.flags.bits.implicitUpdate)
-  {
-    //Someone else has to call checkUblox for us...
-    // if (_printDebug == true)
-    // {
-    //   _debugSerial->println(F("getHNRAtt: Exit immediately"));
-    // }
-    return (false);
-  }
-  else
-  {
-    // if (_printDebug == true)
-    // {
-    //   _debugSerial->println(F("getHNRAtt: Polling"));
-    // }
-
-    //The GPS is not automatically reporting HNR attitude so we have to poll explicitly
-    packetCfg.cls = UBX_CLASS_HNR;
-    packetCfg.id = UBX_HNR_ATT;
-    packetCfg.len = 0;
-    packetCfg.startingSpot = 0;
-
-    //The data is parsed as part of processing the response
-    sfe_ublox_status_e retVal = sendCommand(&packetCfg, maxWait);
-
-    if (retVal == SFE_UBLOX_STATUS_DATA_RECEIVED)
-      return (true);
-
-    if (retVal == SFE_UBLOX_STATUS_DATA_OVERWRITTEN)
-    {
-      // if (_printDebug == true)
-      // {
-      //   _debugSerial->println(F("getHNRAtt: data in packetCfg was OVERWRITTEN by another message (but that's OK)"));
-      // }
-      return (true);
-    }
-
-    // if (_printDebug == true)
-    // {
-    //   _debugSerial->print(F("getHNRAtt retVal: "));
-    //   _debugSerial->println(statusString(retVal));
-    // }
-    return (false);
-  }
-
-  return (false); // Trap. We should never get here...
-}
-
-//Enable or disable automatic HNR attitude message generation by the GNSS. This changes the way getHNRAtt
-//works.
-boolean SFE_UBLOX_GNSS::setAutoHNRATT(boolean enable, uint16_t maxWait)
-{
-  return setAutoHNRATTrate(enable ? 1 : 0, true, maxWait);
-}
-
-//Enable or disable automatic HNR attitude message generation by the GNSS. This changes the way getHNRAtt
-//works.
-boolean SFE_UBLOX_GNSS::setAutoHNRATT(boolean enable, boolean implicitUpdate, uint16_t maxWait)
-{
-  return setAutoHNRATTrate(enable ? 1 : 0, implicitUpdate, maxWait);
-}
-
-//Enable or disable automatic HNR attitude message generation by the GNSS. This changes the way getHNRAtt
-//works.
-boolean SFE_UBLOX_GNSS::setAutoHNRATTrate(uint8_t rate, boolean implicitUpdate, uint16_t maxWait)
-{
-  if (packetUBXHNRATT == NULL) initPacketUBXHNRATT(); //Check that RAM has been allocated for the data
-  if (packetUBXHNRATT == NULL) //Only attempt this if RAM allocation was successful
-    return false;
-
-  if (rate > 127) rate = 127;
-
-  packetCfg.cls = UBX_CLASS_CFG;
-  packetCfg.id = UBX_CFG_MSG;
-  packetCfg.len = 3;
-  packetCfg.startingSpot = 0;
-  payloadCfg[0] = UBX_CLASS_HNR;
-  payloadCfg[1] = UBX_HNR_ATT;
-  payloadCfg[2] = rate; // rate relative to navigation freq.
-
-  boolean ok = ((sendCommand(&packetCfg, maxWait)) == SFE_UBLOX_STATUS_DATA_SENT); // We are only expecting an ACK
-  if (ok)
-  {
-    packetUBXHNRATT->automaticFlags.flags.bits.automatic = (rate > 0);
-    packetUBXHNRATT->automaticFlags.flags.bits.implicitUpdate = implicitUpdate;
-  }
-  packetUBXHNRATT->moduleQueried.moduleQueried.bits.all = false; // Mark data as stale
-  return ok;
-}
-
-//Enable automatic navigation message generation by the GNSS.
-boolean SFE_UBLOX_GNSS::setAutoHNRATTcallback(void (*callbackPointer)(UBX_HNR_ATT_data_t), uint16_t maxWait)
-{
-  // Enable auto messages. Set implicitUpdate to false as we expect the user to call checkUblox manually.
-  boolean result = setAutoHNRATT(true, false, maxWait);
-  if (!result)
-    return (result); // Bail if setAuto failed
-
-  if (packetUBXHNRATT->callbackData == NULL) //Check if RAM has been allocated for the callback copy
-  {
-    packetUBXHNRATT->callbackData = new UBX_HNR_ATT_data_t; //Allocate RAM for the main struct
-  }
-
-  if (packetUBXHNRATT->callbackData == NULL)
-  {
-    if ((_printDebug == true) || (_printLimitedDebug == true)) // This is important. Print this if doing limited debugging
-      _debugSerial->println(F("setAutoHNRAttcallback: PANIC! RAM allocation failed!"));
-    return (false);
-  }
-
-  packetUBXHNRATT->callbackPointer = callbackPointer;
-  return (true);
-}
-
-//In case no config access to the GNSS is possible and HNR attitude is send cyclically already
-//set config to suitable parameters
-boolean SFE_UBLOX_GNSS::assumeAutoHNRATT(boolean enabled, boolean implicitUpdate)
-{
-  if (packetUBXHNRATT == NULL) initPacketUBXHNRATT(); //Check that RAM has been allocated for the data
-  if (packetUBXHNRATT == NULL) //Bail if the RAM allocation failed
-    return (false);
-
-  boolean changes = packetUBXHNRATT->automaticFlags.flags.bits.automatic != enabled || packetUBXHNRATT->automaticFlags.flags.bits.implicitUpdate != implicitUpdate;
-  if (changes)
-  {
-    packetUBXHNRATT->automaticFlags.flags.bits.automatic = enabled;
-    packetUBXHNRATT->automaticFlags.flags.bits.implicitUpdate = implicitUpdate;
-  }
-  return changes;
-}
-
-// PRIVATE: Allocate RAM for packetUBXHNRATT and initialize it
-boolean SFE_UBLOX_GNSS::initPacketUBXHNRATT()
-{
-  packetUBXHNRATT = new UBX_HNR_ATT_t; //Allocate RAM for the main struct
-  if (packetUBXHNRATT == NULL)
-  {
-    if ((_printDebug == true) || (_printLimitedDebug == true)) // This is important. Print this if doing limited debugging
-      _debugSerial->println(F("initPacketUBXHNRATT: PANIC! RAM allocation failed!"));
-    return (false);
-  }
-  packetUBXHNRATT->automaticFlags.flags.all = 0;
-  packetUBXHNRATT->callbackPointer = NULL;
-  packetUBXHNRATT->callbackData = NULL;
-  packetUBXHNRATT->moduleQueried.moduleQueried.all = 0;
-  return (true);
-}
-
-//Mark all the data as read/stale
-void SFE_UBLOX_GNSS::flushHNRATT()
-{
-  if (packetUBXHNRATT == NULL) return; // Bail if RAM has not been allocated (otherwise we could be writing anywhere!)
-  packetUBXHNRATT->moduleQueried.moduleQueried.all = 0; //Mark all datums as stale (read before)
-}
-
-
-//Log this data in file buffer
-void SFE_UBLOX_GNSS::logHNRATT(boolean enabled)
-{
-  if (packetUBXHNRATT == NULL) return; // Bail if RAM has not been allocated (otherwise we could be writing anywhere!)
-  packetUBXHNRATT->automaticFlags.flags.bits.addToFileBuffer = (uint8_t)enabled;
-}
-
-// ***** HNR DYN automatic support
-
-boolean SFE_UBLOX_GNSS::getHNRDyn(uint16_t maxWait)
-{
-  return (getHNRINS(maxWait));
-}
-
-//Get the HNR vehicle dynamics data
-// Returns true if the get HNR vehicle dynamics is successful. Data is returned in hnrVehDyn
-// Note: if hnrDynQueried is true, it gets set to false by this function since we assume
-//       that the user will read hnrVehDyn immediately after this. I.e. this function will
-//       only return true _once_ after each auto HNR Dyn is processed
-boolean SFE_UBLOX_GNSS::getHNRINS(uint16_t maxWait)
-{
-  if (packetUBXHNRINS == NULL) initPacketUBXHNRINS(); //Check that RAM has been allocated for the data
-  if (packetUBXHNRINS == NULL) //Bail if the RAM allocation failed
-    return (false);
-
-  if (packetUBXHNRINS->automaticFlags.flags.bits.automatic && packetUBXHNRINS->automaticFlags.flags.bits.implicitUpdate)
-  {
-    //The GPS is automatically reporting, we just check whether we got unread data
-    // if (_printDebug == true)
-    // {
-    //   _debugSerial->println(F("getHNRDyn: Autoreporting"));
-    // }
-    checkUbloxInternal(&packetCfg, UBX_CLASS_HNR, UBX_HNR_INS);
-    return packetUBXHNRINS->moduleQueried.moduleQueried.bits.all;
-  }
-  else if (packetUBXHNRINS->automaticFlags.flags.bits.automatic && !packetUBXHNRINS->automaticFlags.flags.bits.implicitUpdate)
-  {
-    //Someone else has to call checkUblox for us...
-    // if (_printDebug == true)
-    // {
-    //   _debugSerial->println(F("getHNRDyn: Exit immediately"));
-    // }
-    return (false);
-  }
-  else
-  {
-    // if (_printDebug == true)
-    // {
-    //   _debugSerial->println(F("getHNRDyn: Polling"));
-    // }
-
-    //The GPS is not automatically reporting HNR vehicle dynamics so we have to poll explicitly
-    packetCfg.cls = UBX_CLASS_HNR;
-    packetCfg.id = UBX_HNR_INS;
-    packetCfg.len = 0;
-    packetCfg.startingSpot = 0;
-
-    //The data is parsed as part of processing the response
-    sfe_ublox_status_e retVal = sendCommand(&packetCfg, maxWait);
-
-    if (retVal == SFE_UBLOX_STATUS_DATA_RECEIVED)
-      return (true);
-
-    if (retVal == SFE_UBLOX_STATUS_DATA_OVERWRITTEN)
-    {
-      // if (_printDebug == true)
-      // {
-      //   _debugSerial->println(F("getHNRDyn: data in packetCfg was OVERWRITTEN by another message (but that's OK)"));
-      // }
-      return (true);
-    }
-
-    // if (_printDebug == true)
-    // {
-    //   _debugSerial->print(F("getHNRDyn retVal: "));
-    //   _debugSerial->println(statusString(retVal));
-    // }
-    return (false);
-  }
-
-  return (false); // Trap. We should never get here...
-}
-
-//Enable or disable automatic HNR vehicle dynamics message generation by the GNSS. This changes the way getHNRDyn
-//works.
-boolean SFE_UBLOX_GNSS::setAutoHNRINS(boolean enable, uint16_t maxWait)
-{
-  return setAutoHNRINSrate(enable ? 1 : 0, true, maxWait);
-}
-
-//Enable or disable automatic HNR vehicle dynamics message generation by the GNSS. This changes the way getHNRDyn
-//works.
-boolean SFE_UBLOX_GNSS::setAutoHNRINS(boolean enable, boolean implicitUpdate, uint16_t maxWait)
-{
-  return setAutoHNRINSrate(enable ? 1 : 0, implicitUpdate, maxWait);
-}
-
-//Enable or disable automatic HNR vehicle dynamics message generation by the GNSS. This changes the way getHNRDyn
-//works.
-boolean SFE_UBLOX_GNSS::setAutoHNRINSrate(uint8_t rate, boolean implicitUpdate, uint16_t maxWait)
-{
-  if (packetUBXHNRINS == NULL) initPacketUBXHNRINS(); //Check that RAM has been allocated for the data
-  if (packetUBXHNRINS == NULL) //Only attempt this if RAM allocation was successful
-    return false;
-
-  if (rate > 127) rate = 127;
-
-  packetCfg.cls = UBX_CLASS_CFG;
-  packetCfg.id = UBX_CFG_MSG;
-  packetCfg.len = 3;
-  packetCfg.startingSpot = 0;
-  payloadCfg[0] = UBX_CLASS_HNR;
-  payloadCfg[1] = UBX_HNR_INS;
-  payloadCfg[2] = rate; // rate relative to navigation freq.
-
-  boolean ok = ((sendCommand(&packetCfg, maxWait)) == SFE_UBLOX_STATUS_DATA_SENT); // We are only expecting an ACK
-  if (ok)
-  {
-    packetUBXHNRINS->automaticFlags.flags.bits.automatic = (rate > 0);
-    packetUBXHNRINS->automaticFlags.flags.bits.implicitUpdate = implicitUpdate;
-  }
-  packetUBXHNRINS->moduleQueried.moduleQueried.bits.all = false; // Mark data as stale
-  return ok;
-}
-
-//Enable automatic navigation message generation by the GNSS.
-boolean SFE_UBLOX_GNSS::setAutoHNRINScallback(void (*callbackPointer)(UBX_HNR_INS_data_t), uint16_t maxWait)
-{
-  // Enable auto messages. Set implicitUpdate to false as we expect the user to call checkUblox manually.
-  boolean result = setAutoHNRINS(true, false, maxWait);
-  if (!result)
-    return (result); // Bail if setAuto failed
-
-  if (packetUBXHNRINS->callbackData == NULL) //Check if RAM has been allocated for the callback copy
-  {
-    packetUBXHNRINS->callbackData = new UBX_HNR_INS_data_t; //Allocate RAM for the main struct
-  }
-
-  if (packetUBXHNRINS->callbackData == NULL)
-  {
-    if ((_printDebug == true) || (_printLimitedDebug == true)) // This is important. Print this if doing limited debugging
-      _debugSerial->println(F("setAutoHNRDyncallback: PANIC! RAM allocation failed!"));
-    return (false);
-  }
-
-  packetUBXHNRINS->callbackPointer = callbackPointer;
-  return (true);
-}
-
-//In case no config access to the GNSS is possible and HNR vehicle dynamics is send cyclically already
-//set config to suitable parameters
-boolean SFE_UBLOX_GNSS::assumeAutoHNRINS(boolean enabled, boolean implicitUpdate)
-{
-  if (packetUBXHNRINS == NULL) initPacketUBXHNRINS(); //Check that RAM has been allocated for the data
-  if (packetUBXHNRINS == NULL) //Bail if the RAM allocation failed
-    return (false);
-
-  boolean changes = packetUBXHNRINS->automaticFlags.flags.bits.automatic != enabled || packetUBXHNRINS->automaticFlags.flags.bits.implicitUpdate != implicitUpdate;
-  if (changes)
-  {
-    packetUBXHNRINS->automaticFlags.flags.bits.automatic = enabled;
-    packetUBXHNRINS->automaticFlags.flags.bits.implicitUpdate = implicitUpdate;
-  }
-  return changes;
-}
-
-// PRIVATE: Allocate RAM for packetUBXHNRINS and initialize it
-boolean SFE_UBLOX_GNSS::initPacketUBXHNRINS()
-{
-  packetUBXHNRINS = new UBX_HNR_INS_t; //Allocate RAM for the main struct
-  if (packetUBXHNRINS == NULL)
-  {
-    if ((_printDebug == true) || (_printLimitedDebug == true)) // This is important. Print this if doing limited debugging
-      _debugSerial->println(F("initPacketUBXHNRINS: PANIC! RAM allocation failed!"));
-    return (false);
-  }
-  packetUBXHNRINS->automaticFlags.flags.all = 0;
-  packetUBXHNRINS->callbackPointer = NULL;
-  packetUBXHNRINS->callbackData = NULL;
-  packetUBXHNRINS->moduleQueried.moduleQueried.all = 0;
-  return (true);
-}
-
-//Mark all the data as read/stale
-void SFE_UBLOX_GNSS::flushHNRINS()
-{
-  if (packetUBXHNRINS == NULL) return; // Bail if RAM has not been allocated (otherwise we could be writing anywhere!)
-  packetUBXHNRINS->moduleQueried.moduleQueried.all = 0; //Mark all datums as stale (read before)
-}
-
-//Log this data in file buffer
-void SFE_UBLOX_GNSS::logHNRINS(boolean enabled)
-{
-  if (packetUBXHNRINS == NULL) return; // Bail if RAM has not been allocated (otherwise we could be writing anywhere!)
-  packetUBXHNRINS->automaticFlags.flags.bits.addToFileBuffer = (uint8_t)enabled;
-}
-
-// ***** HNR PVT automatic support
-
-//Get the HNR PVT data
-// Returns true if the get HNR PVT is successful. Data is returned in hnrPVT
-// Note: if hnrPVTQueried is true, it gets set to false by this function since we assume
-//       that the user will read hnrPVT immediately after this. I.e. this function will
-//       only return true _once_ after each auto HNR PVT is processed
-boolean SFE_UBLOX_GNSS::getHNRPVT(uint16_t maxWait)
-{
-  if (packetUBXHNRPVT == NULL) initPacketUBXHNRPVT(); //Check that RAM has been allocated for the PVT data
-  if (packetUBXHNRPVT == NULL) //Only attempt this if RAM allocation was successful
-    return false;
-
-  if (packetUBXHNRPVT->automaticFlags.flags.bits.automatic && packetUBXHNRPVT->automaticFlags.flags.bits.implicitUpdate)
-  {
-    //The GPS is automatically reporting, we just check whether we got unread data
-    // if (_printDebug == true)
-    // {
-    //   _debugSerial->println(F("getHNRPVT: Autoreporting"));
-    // }
-    checkUbloxInternal(&packetCfg, UBX_CLASS_HNR, UBX_HNR_PVT);
-    return packetUBXHNRPVT->moduleQueried.moduleQueried.bits.all;
-  }
-  else if (packetUBXHNRPVT->automaticFlags.flags.bits.automatic && !packetUBXHNRPVT->automaticFlags.flags.bits.implicitUpdate)
-  {
-    //Someone else has to call checkUblox for us...
-    // if (_printDebug == true)
-    // {
-    //   _debugSerial->println(F("getHNRPVT: Exit immediately"));
-    // }
-    return (false);
-  }
-  else
-  {
-    // if (_printDebug == true)
-    // {
-    //   _debugSerial->println(F("getHNRPVT: Polling"));
-    // }
-
-    //The GPS is not automatically reporting HNR PVT so we have to poll explicitly
-    packetCfg.cls = UBX_CLASS_HNR;
-    packetCfg.id = UBX_HNR_PVT;
-    packetCfg.len = 0;
-    packetCfg.startingSpot = 0;
-
-    //The data is parsed as part of processing the response
-    sfe_ublox_status_e retVal = sendCommand(&packetCfg, maxWait);
-
-    if (retVal == SFE_UBLOX_STATUS_DATA_RECEIVED)
-      return (true);
-
-    if (retVal == SFE_UBLOX_STATUS_DATA_OVERWRITTEN)
-    {
-      // if (_printDebug == true)
-      // {
-      //   _debugSerial->println(F("getHNRPVT: data in packetCfg was OVERWRITTEN by another message (but that's OK)"));
-      // }
-      return (true);
-    }
-
-    // if (_printDebug == true)
-    // {
-    //   _debugSerial->print(F("getHNRPVT retVal: "));
-    //   _debugSerial->println(statusString(retVal));
-    // }
-    return (false);
-  }
-
-  return (false); // Trap. We should never get here...
-}
-
-//Enable or disable automatic HNR PVT message generation by the GNSS. This changes the way getHNRPVT
-//works.
-boolean SFE_UBLOX_GNSS::setAutoHNRPVT(boolean enable, uint16_t maxWait)
-{
-  return setAutoHNRPVTrate(enable ? 1 : 0, true, maxWait);
-}
-
-//Enable or disable automatic HNR PVT message generation by the GNSS. This changes the way getHNRPVT
-//works.
-boolean SFE_UBLOX_GNSS::setAutoHNRPVT(boolean enable, boolean implicitUpdate, uint16_t maxWait)
-{
-  return setAutoHNRPVTrate(enable ? 1 : 0, implicitUpdate, maxWait);
-}
-
-//Enable or disable automatic HNR PVT message generation by the GNSS. This changes the way getHNRPVT
-//works.
-boolean SFE_UBLOX_GNSS::setAutoHNRPVTrate(uint8_t rate, boolean implicitUpdate, uint16_t maxWait)
-{
-  if (packetUBXHNRPVT == NULL) initPacketUBXHNRPVT(); //Check that RAM has been allocated for the data
-  if (packetUBXHNRPVT == NULL) //Only attempt this if RAM allocation was successful
-    return false;
-
-  if (rate > 127) rate = 127;
-
-  packetCfg.cls = UBX_CLASS_CFG;
-  packetCfg.id = UBX_CFG_MSG;
-  packetCfg.len = 3;
-  packetCfg.startingSpot = 0;
-  payloadCfg[0] = UBX_CLASS_HNR;
-  payloadCfg[1] = UBX_HNR_PVT;
-  payloadCfg[2] = rate; // rate relative to navigation freq.
-
-  boolean ok = ((sendCommand(&packetCfg, maxWait)) == SFE_UBLOX_STATUS_DATA_SENT); // We are only expecting an ACK
-  if (ok)
-  {
-    packetUBXHNRPVT->automaticFlags.flags.bits.automatic = (rate > 0);
-    packetUBXHNRPVT->automaticFlags.flags.bits.implicitUpdate = implicitUpdate;
-  }
-  packetUBXHNRPVT->moduleQueried.moduleQueried.bits.all = false; // Mark data as stale
-  return ok;
-}
-
-//Enable automatic navigation message generation by the GNSS.
-boolean SFE_UBLOX_GNSS::setAutoHNRPVTcallback(void (*callbackPointer)(UBX_HNR_PVT_data_t), uint16_t maxWait)
-{
-  // Enable auto messages. Set implicitUpdate to false as we expect the user to call checkUblox manually.
-  boolean result = setAutoHNRPVT(true, false, maxWait);
-  if (!result)
-    return (result); // Bail if setAuto failed
-
-  if (packetUBXHNRPVT->callbackData == NULL) //Check if RAM has been allocated for the callback copy
-  {
-    packetUBXHNRPVT->callbackData = new UBX_HNR_PVT_data_t; //Allocate RAM for the main struct
-  }
-
-  if (packetUBXHNRPVT->callbackData == NULL)
-  {
-    if ((_printDebug == true) || (_printLimitedDebug == true)) // This is important. Print this if doing limited debugging
-      _debugSerial->println(F("setAutoHNRPVTcallback: PANIC! RAM allocation failed!"));
-    return (false);
-  }
-
-  packetUBXHNRPVT->callbackPointer = callbackPointer;
-  return (true);
-}
-
-//In case no config access to the GNSS is possible and HNR PVT is send cyclically already
-//set config to suitable parameters
-boolean SFE_UBLOX_GNSS::assumeAutoHNRPVT(boolean enabled, boolean implicitUpdate)
-{
-  if (packetUBXHNRPVT == NULL) initPacketUBXHNRPVT(); //Check that RAM has been allocated for the PVT data
-  if (packetUBXHNRPVT == NULL) //Only attempt this if RAM allocation was successful
-    return false;
-
-  boolean changes = packetUBXHNRPVT->automaticFlags.flags.bits.automatic != enabled || packetUBXHNRPVT->automaticFlags.flags.bits.implicitUpdate != implicitUpdate;
-  if (changes)
-  {
-    packetUBXHNRPVT->automaticFlags.flags.bits.automatic = enabled;
-    packetUBXHNRPVT->automaticFlags.flags.bits.implicitUpdate = implicitUpdate;
-  }
-  return changes;
-}
-
-// PRIVATE: Allocate RAM for packetUBXHNRPVT and initialize it
-boolean SFE_UBLOX_GNSS::initPacketUBXHNRPVT()
-{
-  packetUBXHNRPVT = new UBX_HNR_PVT_t; //Allocate RAM for the main struct
-  if (packetUBXHNRPVT == NULL)
-  {
-    if ((_printDebug == true) || (_printLimitedDebug == true)) // This is important. Print this if doing limited debugging
-      _debugSerial->println(F("initPacketUBXHNRPVT: PANIC! RAM allocation failed!"));
-    return (false);
-  }
-  packetUBXHNRPVT->automaticFlags.flags.all = 0;
-  packetUBXHNRPVT->callbackPointer = NULL;
-  packetUBXHNRPVT->callbackData = NULL;
-  packetUBXHNRPVT->moduleQueried.moduleQueried.all = 0;
-  return (true);
-}
-
-//Mark all the data as read/stale
-void SFE_UBLOX_GNSS::flushHNRPVT()
-{
-  if (packetUBXHNRPVT == NULL) return; // Bail if RAM has not been allocated (otherwise we could be writing anywhere!)
-  packetUBXHNRPVT->moduleQueried.moduleQueried.all = 0; //Mark all datums as stale (read before)
-}
-
-//Log this data in file buffer
-void SFE_UBLOX_GNSS::logHNRPVT(boolean enabled)
-{
-  if (packetUBXHNRPVT == NULL) return; // Bail if RAM has not been allocated (otherwise we could be writing anywhere!)
-  packetUBXHNRPVT->automaticFlags.flags.bits.addToFileBuffer = (uint8_t)enabled;
-}
-
-// ***** CFG RATE Helper Functions
-
-//Set the rate at which the module will give us an updated navigation solution
-//Expects a number that is the updates per second. For example 1 = 1Hz, 2 = 2Hz, etc.
-//Max is 40Hz(?!)
-boolean SFE_UBLOX_GNSS::setNavigationFrequency(uint8_t navFreq, uint16_t maxWait)
-{
-  //if(updateRate > 40) updateRate = 40; //Not needed: module will correct out of bounds values
-
-  //Adjust the I2C polling timeout based on update rate
-  i2cPollingWait = 1000 / (((int)navFreq) * 4); //This is the number of ms to wait between checks for new I2C data
-
-  //Query the module
-  packetCfg.cls = UBX_CLASS_CFG;
-  packetCfg.id = UBX_CFG_RATE;
-  packetCfg.len = 0;
-  packetCfg.startingSpot = 0;
-
-  //This will load the payloadCfg array with current settings of the given register
-  if (sendCommand(&packetCfg, maxWait) != SFE_UBLOX_STATUS_DATA_RECEIVED) // We are expecting data and an ACK
-    return (false);                                                       //If command send fails then bail
-
-  uint16_t measurementRate = 1000 / navFreq;
-
-  //payloadCfg is now loaded with current bytes. Change only the ones we need to
-  payloadCfg[0] = measurementRate & 0xFF; //measRate LSB
-  payloadCfg[1] = measurementRate >> 8;   //measRate MSB
-
-  return ((sendCommand(&packetCfg, maxWait)) == SFE_UBLOX_STATUS_DATA_SENT); // We are only expecting an ACK
-}
-
-//Get the rate at which the module is outputting nav solutions
-uint8_t SFE_UBLOX_GNSS::getNavigationFrequency(uint16_t maxWait)
-{
-  if (packetUBXCFGRATE == NULL) initPacketUBXCFGRATE(); //Check that RAM has been allocated for the RATE data
-  if (packetUBXCFGRATE == NULL) //Bail if the RAM allocation failed
-    return 0;
-
-  if (packetUBXCFGRATE->moduleQueried.moduleQueried.bits.measRate == false)
-    getNavigationFrequencyInternal(maxWait);
-  packetUBXCFGRATE->moduleQueried.moduleQueried.bits.measRate = false; //Since we are about to give this to user, mark this data as stale
-  packetUBXCFGRATE->moduleQueried.moduleQueried.bits.all = false;
-
-  uint16_t measurementRate = packetUBXCFGRATE->data.measRate;
-
-  measurementRate = 1000 / measurementRate; //This may return an int when it's a float, but I'd rather not return 4 bytes
-  return (measurementRate);
-}
-
-//Set the elapsed time between GNSS measurements in milliseconds, which defines the rate
-boolean SFE_UBLOX_GNSS::setMeasurementRate(uint16_t rate, uint16_t maxWait)
-{
-  //Adjust the I2C polling timeout based on update rate
-  i2cPollingWait = rate / 4; //This is the number of ms to wait between checks for new I2C data
-
-  //Query the module
-  packetCfg.cls = UBX_CLASS_CFG;
-  packetCfg.id = UBX_CFG_RATE;
-  packetCfg.len = 0;
-  packetCfg.startingSpot = 0;
-
-  //This will load the payloadCfg array with current settings of the given register
-  if (sendCommand(&packetCfg, maxWait) != SFE_UBLOX_STATUS_DATA_RECEIVED) // We are expecting data and an ACK
-    return (false);                                                       //If command send fails then bail
-
-  //payloadCfg is now loaded with current bytes. Change only the ones we need to
-  payloadCfg[0] = rate & 0xFF; //measRate LSB
-  payloadCfg[1] = rate >> 8;   //measRate MSB
-
-  return ((sendCommand(&packetCfg, maxWait)) == SFE_UBLOX_STATUS_DATA_SENT); // We are only expecting an ACK
-}
-
-//Return the elapsed time between GNSS measurements in milliseconds, which defines the rate
-uint16_t SFE_UBLOX_GNSS::getMeasurementRate(uint16_t maxWait)
-{
-  if (packetUBXCFGRATE == NULL) initPacketUBXCFGRATE(); //Check that RAM has been allocated for the RATE data
-  if (packetUBXCFGRATE == NULL) //Bail if the RAM allocation failed
-    return 0;
-
-  if (packetUBXCFGRATE->moduleQueried.moduleQueried.bits.measRate == false)
-    getNavigationFrequencyInternal(maxWait);
-  packetUBXCFGRATE->moduleQueried.moduleQueried.bits.measRate = false; //Since we are about to give this to user, mark this data as stale
-  packetUBXCFGRATE->moduleQueried.moduleQueried.bits.all = false;
-
-  return (packetUBXCFGRATE->data.measRate);
-}
-
-//Set the ratio between the number of measurements and the number of navigation solutions. Unit is cycles. Max is 127.
-boolean SFE_UBLOX_GNSS::setNavigationRate(uint16_t rate, uint16_t maxWait)
-{
-  //Query the module
-  packetCfg.cls = UBX_CLASS_CFG;
-  packetCfg.id = UBX_CFG_RATE;
-  packetCfg.len = 0;
-  packetCfg.startingSpot = 0;
-
-  //This will load the payloadCfg array with current settings of the given register
-  if (sendCommand(&packetCfg, maxWait) != SFE_UBLOX_STATUS_DATA_RECEIVED) // We are expecting data and an ACK
-    return (false);                                                       //If command send fails then bail
-
-  //payloadCfg is now loaded with current bytes. Change only the ones we need to
-  payloadCfg[2] = rate & 0xFF; //navRate LSB
-  payloadCfg[3] = rate >> 8;   //navRate MSB
-
-  return ((sendCommand(&packetCfg, maxWait)) == SFE_UBLOX_STATUS_DATA_SENT); // We are only expecting an ACK
-}
-
-//Return the ratio between the number of measurements and the number of navigation solutions. Unit is cycles
-uint16_t SFE_UBLOX_GNSS::getNavigationRate(uint16_t maxWait)
-{
-  if (packetUBXCFGRATE == NULL) initPacketUBXCFGRATE(); //Check that RAM has been allocated for the RATE data
-  if (packetUBXCFGRATE == NULL) //Bail if the RAM allocation failed
-    return 0;
-
-  if (packetUBXCFGRATE->moduleQueried.moduleQueried.bits.navRate == false)
-    getNavigationFrequencyInternal(maxWait);
-  packetUBXCFGRATE->moduleQueried.moduleQueried.bits.navRate = false; //Since we are about to give this to user, mark this data as stale
-  packetUBXCFGRATE->moduleQueried.moduleQueried.bits.all = false;
-
-  return (packetUBXCFGRATE->data.navRate);
-}
-
-// ***** DOP Helper Functions
-
-uint16_t SFE_UBLOX_GNSS::getGeometricDOP(uint16_t maxWait)
-{
-  if (packetUBXNAVDOP == NULL) initPacketUBXNAVDOP(); //Check that RAM has been allocated for the DOP data
-  if (packetUBXNAVDOP == NULL) //Bail if the RAM allocation failed
-    return 0;
-
-  if (packetUBXNAVDOP->moduleQueried.moduleQueried.bits.gDOP == false)
-    getDOP(maxWait);
-  packetUBXNAVDOP->moduleQueried.moduleQueried.bits.gDOP = false; //Since we are about to give this to user, mark this data as stale
-  packetUBXNAVDOP->moduleQueried.moduleQueried.bits.all = false;
-  return (packetUBXNAVDOP->data.gDOP);
-}
-
-uint16_t SFE_UBLOX_GNSS::getPositionDOP(uint16_t maxWait)
-{
-  if (packetUBXNAVDOP == NULL) initPacketUBXNAVDOP(); //Check that RAM has been allocated for the DOP data
-  if (packetUBXNAVDOP == NULL) //Bail if the RAM allocation failed
-    return 0;
-
-  if (packetUBXNAVDOP->moduleQueried.moduleQueried.bits.pDOP == false)
-    getDOP(maxWait);
-  packetUBXNAVDOP->moduleQueried.moduleQueried.bits.pDOP = false; //Since we are about to give this to user, mark this data as stale
-  packetUBXNAVDOP->moduleQueried.moduleQueried.bits.all = false;
-  return (packetUBXNAVDOP->data.pDOP);
-}
-
-uint16_t SFE_UBLOX_GNSS::getTimeDOP(uint16_t maxWait)
-{
-  if (packetUBXNAVDOP == NULL) initPacketUBXNAVDOP(); //Check that RAM has been allocated for the DOP data
-  if (packetUBXNAVDOP == NULL) //Bail if the RAM allocation failed
-    return 0;
-
-  if (packetUBXNAVDOP->moduleQueried.moduleQueried.bits.tDOP == false)
-    getDOP(maxWait);
-  packetUBXNAVDOP->moduleQueried.moduleQueried.bits.tDOP = false; //Since we are about to give this to user, mark this data as stale
-  packetUBXNAVDOP->moduleQueried.moduleQueried.bits.all = false;
-  return (packetUBXNAVDOP->data.tDOP);
-}
-
-uint16_t SFE_UBLOX_GNSS::getVerticalDOP(uint16_t maxWait)
-{
-  if (packetUBXNAVDOP == NULL) initPacketUBXNAVDOP(); //Check that RAM has been allocated for the DOP data
-  if (packetUBXNAVDOP == NULL) //Bail if the RAM allocation failed
-    return 0;
-
-  if (packetUBXNAVDOP->moduleQueried.moduleQueried.bits.vDOP == false)
-    getDOP(maxWait);
-  packetUBXNAVDOP->moduleQueried.moduleQueried.bits.vDOP = false; //Since we are about to give this to user, mark this data as stale
-  packetUBXNAVDOP->moduleQueried.moduleQueried.bits.all = false;
-  return (packetUBXNAVDOP->data.vDOP);
-}
-
-uint16_t SFE_UBLOX_GNSS::getHorizontalDOP(uint16_t maxWait)
-{
-  if (packetUBXNAVDOP == NULL) initPacketUBXNAVDOP(); //Check that RAM has been allocated for the DOP data
-  if (packetUBXNAVDOP == NULL) //Bail if the RAM allocation failed
-    return 0;
-
-  if (packetUBXNAVDOP->moduleQueried.moduleQueried.bits.hDOP == false)
-    getDOP(maxWait);
-  packetUBXNAVDOP->moduleQueried.moduleQueried.bits.hDOP = false; //Since we are about to give this to user, mark this data as stale
-  packetUBXNAVDOP->moduleQueried.moduleQueried.bits.all = false;
-  return (packetUBXNAVDOP->data.hDOP);
-}
-
-uint16_t SFE_UBLOX_GNSS::getNorthingDOP(uint16_t maxWait)
-{
-  if (packetUBXNAVDOP == NULL) initPacketUBXNAVDOP(); //Check that RAM has been allocated for the DOP data
-  if (packetUBXNAVDOP == NULL) //Bail if the RAM allocation failed
-    return 0;
-
-  if (packetUBXNAVDOP->moduleQueried.moduleQueried.bits.nDOP == false)
-    getDOP(maxWait);
-  packetUBXNAVDOP->moduleQueried.moduleQueried.bits.nDOP = false; //Since we are about to give this to user, mark this data as stale
-  packetUBXNAVDOP->moduleQueried.moduleQueried.bits.all = false;
-  return (packetUBXNAVDOP->data.nDOP);
-}
-
-uint16_t SFE_UBLOX_GNSS::getEastingDOP(uint16_t maxWait)
-{
-  if (packetUBXNAVDOP == NULL) initPacketUBXNAVDOP(); //Check that RAM has been allocated for the DOP data
-  if (packetUBXNAVDOP == NULL) //Bail if the RAM allocation failed
-    return 0;
-
-  if (packetUBXNAVDOP->moduleQueried.moduleQueried.bits.eDOP == false)
-    getDOP(maxWait);
-  packetUBXNAVDOP->moduleQueried.moduleQueried.bits.eDOP = false; //Since we are about to give this to user, mark this data as stale
-  packetUBXNAVDOP->moduleQueried.moduleQueried.bits.all = false;
-  return (packetUBXNAVDOP->data.eDOP);
-}
-
-// ***** ATT Helper Functions
-
-float SFE_UBLOX_GNSS::getATTroll(uint16_t maxWait) // Returned as degrees
-{
-  if (packetUBXNAVATT == NULL) initPacketUBXNAVATT(); //Check that RAM has been allocated for the NAV ATT data
-  if (packetUBXNAVATT == NULL) //Bail if the RAM allocation failed
-    return (0);
-
-  if (packetUBXNAVATT->moduleQueried.moduleQueried.bits.roll == false)
-    getNAVATT(maxWait);
-  packetUBXNAVATT->moduleQueried.moduleQueried.bits.roll = false; //Since we are about to give this to user, mark this data as stale
-  packetUBXNAVATT->moduleQueried.moduleQueried.bits.all = false;
-  return (((float)packetUBXNAVATT->data.roll) / 100000.0); // Convert to degrees
-}
-
-float SFE_UBLOX_GNSS::getATTpitch(uint16_t maxWait) // Returned as degrees
-{
-  if (packetUBXNAVATT == NULL) initPacketUBXNAVATT(); //Check that RAM has been allocated for the NAV ATT data
-  if (packetUBXNAVATT == NULL) //Bail if the RAM allocation failed
-    return (0);
-
-  if (packetUBXNAVATT->moduleQueried.moduleQueried.bits.pitch == false)
-    getNAVATT(maxWait);
-  packetUBXNAVATT->moduleQueried.moduleQueried.bits.pitch = false; //Since we are about to give this to user, mark this data as stale
-  packetUBXNAVATT->moduleQueried.moduleQueried.bits.all = false;
-  return (((float)packetUBXNAVATT->data.pitch) / 100000.0); // Convert to degrees
-}
-
-float SFE_UBLOX_GNSS::getATTheading(uint16_t maxWait) // Returned as degrees
-{
-  if (packetUBXNAVATT == NULL) initPacketUBXNAVATT(); //Check that RAM has been allocated for the NAV ATT data
-  if (packetUBXNAVATT == NULL) //Bail if the RAM allocation failed
-    return (0);
-
-  if (packetUBXNAVATT->moduleQueried.moduleQueried.bits.heading == false)
-    getNAVATT(maxWait);
-  packetUBXNAVATT->moduleQueried.moduleQueried.bits.heading = false; //Since we are about to give this to user, mark this data as stale
-  packetUBXNAVATT->moduleQueried.moduleQueried.bits.all = false;
-  return (((float)packetUBXNAVATT->data.heading) / 100000.0); // Convert to degrees
-}
-
-// ***** PVT Helper Functions
-
-uint32_t SFE_UBLOX_GNSS::getTimeOfWeek(uint16_t maxWait)
-{
-  if (packetUBXNAVPVT == NULL) initPacketUBXNAVPVT(); //Check that RAM has been allocated for the PVT data
-  if (packetUBXNAVPVT == NULL) //Bail if the RAM allocation failed
-    return 0;
-
-  if (packetUBXNAVPVT->moduleQueried.moduleQueried1.bits.iTOW == false)
-    getPVT(maxWait);
-  packetUBXNAVPVT->moduleQueried.moduleQueried1.bits.iTOW = false; //Since we are about to give this to user, mark this data as stale
-  packetUBXNAVPVT->moduleQueried.moduleQueried1.bits.all = false;
-  return (packetUBXNAVPVT->data.iTOW);
-}
-
-//Get the current year
-uint16_t SFE_UBLOX_GNSS::getYear(uint16_t maxWait)
-{
-  if (packetUBXNAVPVT == NULL) initPacketUBXNAVPVT(); //Check that RAM has been allocated for the PVT data
-  if (packetUBXNAVPVT == NULL) //Bail if the RAM allocation failed
-    return 0;
-
-  if (packetUBXNAVPVT->moduleQueried.moduleQueried1.bits.year == false)
-    getPVT(maxWait);
-  packetUBXNAVPVT->moduleQueried.moduleQueried1.bits.year = false; //Since we are about to give this to user, mark this data as stale
-  packetUBXNAVPVT->moduleQueried.moduleQueried1.bits.all = false;
-  return (packetUBXNAVPVT->data.year);
-}
-
-//Get the current month
-uint8_t SFE_UBLOX_GNSS::getMonth(uint16_t maxWait)
-{
-  if (packetUBXNAVPVT == NULL) initPacketUBXNAVPVT(); //Check that RAM has been allocated for the PVT data
-  if (packetUBXNAVPVT == NULL) //Bail if the RAM allocation failed
-    return 0;
-
-  if (packetUBXNAVPVT->moduleQueried.moduleQueried1.bits.month == false)
-    getPVT(maxWait);
-  packetUBXNAVPVT->moduleQueried.moduleQueried1.bits.month = false; //Since we are about to give this to user, mark this data as stale
-  packetUBXNAVPVT->moduleQueried.moduleQueried1.bits.all = false;
-  return (packetUBXNAVPVT->data.month);
-}
-
-//Get the current day
-uint8_t SFE_UBLOX_GNSS::getDay(uint16_t maxWait)
-{
-  if (packetUBXNAVPVT == NULL) initPacketUBXNAVPVT(); //Check that RAM has been allocated for the PVT data
-  if (packetUBXNAVPVT == NULL) //Bail if the RAM allocation failed
-    return 0;
-
-  if (packetUBXNAVPVT->moduleQueried.moduleQueried1.bits.day == false)
-    getPVT(maxWait);
-  packetUBXNAVPVT->moduleQueried.moduleQueried1.bits.day = false; //Since we are about to give this to user, mark this data as stale
-  packetUBXNAVPVT->moduleQueried.moduleQueried1.bits.all = false;
-  return (packetUBXNAVPVT->data.day);
-}
-
-//Get the current hour
-uint8_t SFE_UBLOX_GNSS::getHour(uint16_t maxWait)
-{
-  if (packetUBXNAVPVT == NULL) initPacketUBXNAVPVT(); //Check that RAM has been allocated for the PVT data
-  if (packetUBXNAVPVT == NULL) //Bail if the RAM allocation failed
-    return 0;
-
-  if (packetUBXNAVPVT->moduleQueried.moduleQueried1.bits.hour == false)
-    getPVT(maxWait);
-  packetUBXNAVPVT->moduleQueried.moduleQueried1.bits.hour = false; //Since we are about to give this to user, mark this data as stale
-  packetUBXNAVPVT->moduleQueried.moduleQueried1.bits.all = false;
-  return (packetUBXNAVPVT->data.hour);
-}
-
-//Get the current minute
-uint8_t SFE_UBLOX_GNSS::getMinute(uint16_t maxWait)
-{
-  if (packetUBXNAVPVT == NULL) initPacketUBXNAVPVT(); //Check that RAM has been allocated for the PVT data
-  if (packetUBXNAVPVT == NULL) //Bail if the RAM allocation failed
-    return 0;
-
-  if (packetUBXNAVPVT->moduleQueried.moduleQueried1.bits.min == false)
-    getPVT(maxWait);
-  packetUBXNAVPVT->moduleQueried.moduleQueried1.bits.min = false; //Since we are about to give this to user, mark this data as stale
-  packetUBXNAVPVT->moduleQueried.moduleQueried1.bits.all = false;
-  return (packetUBXNAVPVT->data.min);
-}
-
-//Get the current second
-uint8_t SFE_UBLOX_GNSS::getSecond(uint16_t maxWait)
-{
-  if (packetUBXNAVPVT == NULL) initPacketUBXNAVPVT(); //Check that RAM has been allocated for the PVT data
-  if (packetUBXNAVPVT == NULL) //Bail if the RAM allocation failed
-    return 0;
-
-  if (packetUBXNAVPVT->moduleQueried.moduleQueried1.bits.sec == false)
-    getPVT(maxWait);
-  packetUBXNAVPVT->moduleQueried.moduleQueried1.bits.sec = false; //Since we are about to give this to user, mark this data as stale
-  packetUBXNAVPVT->moduleQueried.moduleQueried1.bits.all = false;
-  return (packetUBXNAVPVT->data.sec);
-}
-
-//Get the current millisecond
-uint16_t SFE_UBLOX_GNSS::getMillisecond(uint16_t maxWait)
-{
-  if (packetUBXNAVPVT == NULL) initPacketUBXNAVPVT(); //Check that RAM has been allocated for the PVT data
-  if (packetUBXNAVPVT == NULL) //Bail if the RAM allocation failed
-    return 0;
-
-  if (packetUBXNAVPVT->moduleQueried.moduleQueried1.bits.iTOW == false)
-    getPVT(maxWait);
-  packetUBXNAVPVT->moduleQueried.moduleQueried1.bits.iTOW = false; //Since we are about to give this to user, mark this data as stale
-  packetUBXNAVPVT->moduleQueried.moduleQueried1.bits.all = false;
-  return (packetUBXNAVPVT->data.iTOW % 1000);
-}
-
-//Get the current nanoseconds - includes milliseconds
-int32_t SFE_UBLOX_GNSS::getNanosecond(uint16_t maxWait)
-{
-  if (packetUBXNAVPVT == NULL) initPacketUBXNAVPVT(); //Check that RAM has been allocated for the PVT data
-  if (packetUBXNAVPVT == NULL) //Bail if the RAM allocation failed
-    return 0;
-
-  if (packetUBXNAVPVT->moduleQueried.moduleQueried1.bits.nano == false)
-    getPVT(maxWait);
-  packetUBXNAVPVT->moduleQueried.moduleQueried1.bits.nano = false; //Since we are about to give this to user, mark this data as stale
-  packetUBXNAVPVT->moduleQueried.moduleQueried1.bits.all = false;
-  return (packetUBXNAVPVT->data.nano);
-}
-
-//Get the current Unix epoch time rounded up to the nearest second
-uint32_t SFE_UBLOX_GNSS::getUnixEpoch(uint16_t maxWait)
-{
-  if (packetUBXNAVPVT == NULL) initPacketUBXNAVPVT(); //Check that RAM has been allocated for the PVT data
-  if (packetUBXNAVPVT == NULL) //Bail if the RAM allocation failed
-    return 0;
-
-  if (packetUBXNAVPVT->moduleQueried.moduleQueried1.bits.sec == false)
-    getPVT(maxWait);
-  packetUBXNAVPVT->moduleQueried.moduleQueried1.bits.year = false;
-  packetUBXNAVPVT->moduleQueried.moduleQueried1.bits.month = false;
-  packetUBXNAVPVT->moduleQueried.moduleQueried1.bits.day = false;
-  packetUBXNAVPVT->moduleQueried.moduleQueried1.bits.hour = false;
-  packetUBXNAVPVT->moduleQueried.moduleQueried1.bits.min = false;
-  packetUBXNAVPVT->moduleQueried.moduleQueried1.bits.sec = false;
-  packetUBXNAVPVT->moduleQueried.moduleQueried1.bits.all = false;
-  // assemble time elements into time_t - credits to Thomas Roell @ https://github.com/GrumpyOldPizza
-  uint32_t t = ((((((((uint32_t)packetUBXNAVPVT->data.year - 1970) * 365) + ((((uint32_t)packetUBXNAVPVT->data.year - 1970) + 3) / 4)) + 
-                            DAYS_SINCE_MONTH[((uint32_t)packetUBXNAVPVT->data.year - 1970) & 3][(uint32_t)packetUBXNAVPVT->data.month] +
-                          ((uint32_t)packetUBXNAVPVT->data.day - 1)) * 24 +
-                        (uint32_t)packetUBXNAVPVT->data.hour) * 60 +
-                      (uint32_t)packetUBXNAVPVT->data.min) * 60 +
-                    (uint32_t)packetUBXNAVPVT->data.sec);
-  return t;
-}
-
-//Get the current Unix epoch including microseconds
-uint32_t SFE_UBLOX_GNSS::getUnixEpoch(uint32_t& microsecond, uint16_t maxWait)
-{
-  if (packetUBXNAVPVT == NULL) initPacketUBXNAVPVT(); //Check that RAM has been allocated for the PVT data
-  if (packetUBXNAVPVT == NULL) //Bail if the RAM allocation failed
-    return 0;
-
-  if (packetUBXNAVPVT->moduleQueried.moduleQueried1.bits.nano == false)
-    getPVT(maxWait);
-  packetUBXNAVPVT->moduleQueried.moduleQueried1.bits.year = false;
-  packetUBXNAVPVT->moduleQueried.moduleQueried1.bits.month = false;
-  packetUBXNAVPVT->moduleQueried.moduleQueried1.bits.day = false;
-  packetUBXNAVPVT->moduleQueried.moduleQueried1.bits.hour = false;
-  packetUBXNAVPVT->moduleQueried.moduleQueried1.bits.min = false;
-  packetUBXNAVPVT->moduleQueried.moduleQueried1.bits.sec = false;
-  packetUBXNAVPVT->moduleQueried.moduleQueried1.bits.nano = false;
-  packetUBXNAVPVT->moduleQueried.moduleQueried1.bits.all = false;
-  // assemble time elements into time_t - credits to Thomas Roell @ https://github.com/GrumpyOldPizza
-  uint32_t t = ((((((((uint32_t)packetUBXNAVPVT->data.year - 1970) * 365) + ((((uint32_t)packetUBXNAVPVT->data.year - 1970) + 3) / 4)) + 
-                            DAYS_SINCE_MONTH[((uint32_t)packetUBXNAVPVT->data.year - 1970) & 3][(uint32_t)packetUBXNAVPVT->data.month] +
-                          ((uint32_t)packetUBXNAVPVT->data.day - 1)) * 24 +
-                        (uint32_t)packetUBXNAVPVT->data.hour) * 60 +
-                      (uint32_t)packetUBXNAVPVT->data.min) * 60 +
-                    (uint32_t)packetUBXNAVPVT->data.sec);
-  int32_t us = packetUBXNAVPVT->data.nano / 1000;
-  microsecond = (uint32_t)us;
-  // adjust t if nano is negative
-  if(us < 0) {
-    microsecond = (uint32_t)(us + 1000000);
-    t--;
-  }
-  return t;
-}
-
-//Get the current date validity
-bool SFE_UBLOX_GNSS::getDateValid(uint16_t maxWait)
-{
-  if (packetUBXNAVPVT == NULL) initPacketUBXNAVPVT(); //Check that RAM has been allocated for the PVT data
-  if (packetUBXNAVPVT == NULL) //Bail if the RAM allocation failed
-    return (false);
-
-  if (packetUBXNAVPVT->moduleQueried.moduleQueried1.bits.validDate == false)
-    getPVT(maxWait);
-  packetUBXNAVPVT->moduleQueried.moduleQueried1.bits.validDate = false; //Since we are about to give this to user, mark this data as stale
-  packetUBXNAVPVT->moduleQueried.moduleQueried1.bits.all = false;
-  return ((bool)packetUBXNAVPVT->data.valid.bits.validDate);
-}
-
-//Get the current time validity
-bool SFE_UBLOX_GNSS::getTimeValid(uint16_t maxWait)
-{
-  if (packetUBXNAVPVT == NULL) initPacketUBXNAVPVT(); //Check that RAM has been allocated for the PVT data
-  if (packetUBXNAVPVT == NULL) //Bail if the RAM allocation failed
-    return (false);
-
-  if (packetUBXNAVPVT->moduleQueried.moduleQueried1.bits.validTime == false)
-    getPVT(maxWait);
-  packetUBXNAVPVT->moduleQueried.moduleQueried1.bits.validTime = false; //Since we are about to give this to user, mark this data as stale
-  packetUBXNAVPVT->moduleQueried.moduleQueried1.bits.all = false;
-  return ((bool)packetUBXNAVPVT->data.valid.bits.validTime);
-}
-
-//Get the confirmed date validity
-bool SFE_UBLOX_GNSS:: getConfirmedDate(uint16_t maxWait)
-{
-  if (packetUBXNAVPVT == NULL) initPacketUBXNAVPVT(); //Check that RAM has been allocated for the PVT data
-  if (packetUBXNAVPVT == NULL) //Bail if the RAM allocation failed
-    return (false);
-
-  if (packetUBXNAVPVT->moduleQueried.moduleQueried1.bits.confirmedDate == false)
-    getPVT(maxWait);
-  packetUBXNAVPVT->moduleQueried.moduleQueried1.bits.confirmedDate = false; //Since we are about to give this to user, mark this data as stale
-  packetUBXNAVPVT->moduleQueried.moduleQueried1.bits.all = false;
-  return ((bool)packetUBXNAVPVT->data.flags2.bits.confirmedDate);
-}
-
-//Get the confirmed time validity
-bool SFE_UBLOX_GNSS:: getConfirmedTime(uint16_t maxWait)
-{
-  if (packetUBXNAVPVT == NULL) initPacketUBXNAVPVT(); //Check that RAM has been allocated for the PVT data
-  if (packetUBXNAVPVT == NULL) //Bail if the RAM allocation failed
-    return (false);
-
-  if (packetUBXNAVPVT->moduleQueried.moduleQueried1.bits.confirmedTime == false)
-    getPVT(maxWait);
-  packetUBXNAVPVT->moduleQueried.moduleQueried1.bits.confirmedTime = false; //Since we are about to give this to user, mark this data as stale
-  packetUBXNAVPVT->moduleQueried.moduleQueried1.bits.all = false;
-  return ((bool)packetUBXNAVPVT->data.flags2.bits.confirmedTime);
-}
-
-//Get the current fix type
-//0=no fix, 1=dead reckoning, 2=2D, 3=3D, 4=GNSS, 5=Time fix
-uint8_t SFE_UBLOX_GNSS::getFixType(uint16_t maxWait)
-{
-  if (packetUBXNAVPVT == NULL) initPacketUBXNAVPVT(); //Check that RAM has been allocated for the PVT data
-  if (packetUBXNAVPVT == NULL) //Bail if the RAM allocation failed
-    return 0;
-
-  if (packetUBXNAVPVT->moduleQueried.moduleQueried1.bits.fixType == false)
-    getPVT(maxWait);
-  packetUBXNAVPVT->moduleQueried.moduleQueried1.bits.fixType = false; //Since we are about to give this to user, mark this data as stale
-  packetUBXNAVPVT->moduleQueried.moduleQueried1.bits.all = false;
-  return (packetUBXNAVPVT->data.fixType);
-}
-
-//Get whether we have a valid fix (i.e within DOP & accuracy masks)
-bool SFE_UBLOX_GNSS::getGnssFixOk(uint16_t maxWait)
-{
-  if (packetUBXNAVPVT == NULL) initPacketUBXNAVPVT(); //Check that RAM has been allocated for the PVT data
-  if (packetUBXNAVPVT == NULL) //Bail if the RAM allocation failed
-    return 0;
-
-  if (packetUBXNAVPVT->moduleQueried.moduleQueried1.bits.gnssFixOK == false)
-    getPVT(maxWait);
-  packetUBXNAVPVT->moduleQueried.moduleQueried1.bits.gnssFixOK = false; //Since we are about to give this to user, mark this data as stale
-  packetUBXNAVPVT->moduleQueried.moduleQueried1.bits.all = false;
-  return (packetUBXNAVPVT->data.flags.bits.gnssFixOK);
-}
-
-//Get whether differential corrections were applied
-bool SFE_UBLOX_GNSS::getDiffSoln(uint16_t maxWait)
-{
-  if (packetUBXNAVPVT == NULL) initPacketUBXNAVPVT(); //Check that RAM has been allocated for the PVT data
-  if (packetUBXNAVPVT == NULL) //Bail if the RAM allocation failed
-    return 0;
-
-  if (packetUBXNAVPVT->moduleQueried.moduleQueried1.bits.diffSoln == false)
-    getPVT(maxWait);
-  packetUBXNAVPVT->moduleQueried.moduleQueried1.bits.diffSoln = false; //Since we are about to give this to user, mark this data as stale
-  packetUBXNAVPVT->moduleQueried.moduleQueried1.bits.all = false;
-  return (packetUBXNAVPVT->data.flags.bits.diffSoln);
-}
-
-//Get whether head vehicle valid or not
-bool SFE_UBLOX_GNSS::getHeadVehValid(uint16_t maxWait)
-{
-  if (packetUBXNAVPVT == NULL) initPacketUBXNAVPVT(); //Check that RAM has been allocated for the PVT data
-  if (packetUBXNAVPVT == NULL) //Bail if the RAM allocation failed
-    return 0;
-
-  if (packetUBXNAVPVT->moduleQueried.moduleQueried1.bits.headVehValid == false)
-    getPVT(maxWait);
-  packetUBXNAVPVT->moduleQueried.moduleQueried1.bits.headVehValid = false; //Since we are about to give this to user, mark this data as stale
-  packetUBXNAVPVT->moduleQueried.moduleQueried1.bits.all = false;
-  return (packetUBXNAVPVT->data.flags.bits.headVehValid);
-}
-
-//Get the carrier phase range solution status
-//Useful when querying module to see if it has high-precision RTK fix
-//0=No solution, 1=Float solution, 2=Fixed solution
-uint8_t SFE_UBLOX_GNSS::getCarrierSolutionType(uint16_t maxWait)
-{
-  if (packetUBXNAVPVT == NULL) initPacketUBXNAVPVT(); //Check that RAM has been allocated for the PVT data
-  if (packetUBXNAVPVT == NULL) //Bail if the RAM allocation failed
-    return 0;
-
-  if (packetUBXNAVPVT->moduleQueried.moduleQueried1.bits.carrSoln == false)
-    getPVT(maxWait);
-  packetUBXNAVPVT->moduleQueried.moduleQueried1.bits.carrSoln = false; //Since we are about to give this to user, mark this data as stale
-  packetUBXNAVPVT->moduleQueried.moduleQueried1.bits.all = false;
-  return (packetUBXNAVPVT->data.flags.bits.carrSoln);
-}
-
-//Get the number of satellites used in fix
-uint8_t SFE_UBLOX_GNSS::getSIV(uint16_t maxWait)
-{
-  if (packetUBXNAVPVT == NULL) initPacketUBXNAVPVT(); //Check that RAM has been allocated for the PVT data
-  if (packetUBXNAVPVT == NULL) //Bail if the RAM allocation failed
-    return 0;
-
-  if (packetUBXNAVPVT->moduleQueried.moduleQueried1.bits.numSV == false)
-    getPVT(maxWait);
-  packetUBXNAVPVT->moduleQueried.moduleQueried1.bits.numSV = false; //Since we are about to give this to user, mark this data as stale
-  packetUBXNAVPVT->moduleQueried.moduleQueried1.bits.all = false;
-  return (packetUBXNAVPVT->data.numSV);
-}
-
-//Get the current longitude in degrees
-//Returns a long representing the number of degrees *10^-7
-int32_t SFE_UBLOX_GNSS::getLongitude(uint16_t maxWait)
-{
-  if (packetUBXNAVPVT == NULL) initPacketUBXNAVPVT(); //Check that RAM has been allocated for the PVT data
-  if (packetUBXNAVPVT == NULL) //Bail if the RAM allocation failed
-    return 0;
-
-  if (packetUBXNAVPVT->moduleQueried.moduleQueried1.bits.lon == false)
-    getPVT(maxWait);
-  packetUBXNAVPVT->moduleQueried.moduleQueried1.bits.lon = false; //Since we are about to give this to user, mark this data as stale
-  packetUBXNAVPVT->moduleQueried.moduleQueried1.bits.all = false;
-  return (packetUBXNAVPVT->data.lon);
-}
-
-//Get the current latitude in degrees
-//Returns a long representing the number of degrees *10^-7
-int32_t SFE_UBLOX_GNSS::getLatitude(uint16_t maxWait)
-{
-  if (packetUBXNAVPVT == NULL) initPacketUBXNAVPVT(); //Check that RAM has been allocated for the PVT data
-  if (packetUBXNAVPVT == NULL) //Bail if the RAM allocation failed
-    return 0;
-
-  if (packetUBXNAVPVT->moduleQueried.moduleQueried1.bits.lat == false)
-    getPVT(maxWait);
-  packetUBXNAVPVT->moduleQueried.moduleQueried1.bits.lat = false; //Since we are about to give this to user, mark this data as stale
-  packetUBXNAVPVT->moduleQueried.moduleQueried1.bits.all = false;
-  return (packetUBXNAVPVT->data.lat);
-}
-
-//Get the current altitude in mm according to ellipsoid model
-int32_t SFE_UBLOX_GNSS::getAltitude(uint16_t maxWait)
-{
-  if (packetUBXNAVPVT == NULL) initPacketUBXNAVPVT(); //Check that RAM has been allocated for the PVT data
-  if (packetUBXNAVPVT == NULL) //Bail if the RAM allocation failed
-    return 0;
-
-  if (packetUBXNAVPVT->moduleQueried.moduleQueried1.bits.height == false)
-    getPVT(maxWait);
-  packetUBXNAVPVT->moduleQueried.moduleQueried1.bits.height = false; //Since we are about to give this to user, mark this data as stale
-  packetUBXNAVPVT->moduleQueried.moduleQueried1.bits.all = false;
-  return (packetUBXNAVPVT->data.height);
-}
-
-//Get the current altitude in mm according to mean sea level
-//Ellipsoid model: https://www.esri.com/news/arcuser/0703/geoid1of3.html
-//Difference between Ellipsoid Model and Mean Sea Level: https://eos-gnss.com/elevation-for-beginners/
-int32_t SFE_UBLOX_GNSS::getAltitudeMSL(uint16_t maxWait)
-{
-  if (packetUBXNAVPVT == NULL) initPacketUBXNAVPVT(); //Check that RAM has been allocated for the PVT data
-  if (packetUBXNAVPVT == NULL) //Bail if the RAM allocation failed
-    return 0;
-
-  if (packetUBXNAVPVT->moduleQueried.moduleQueried1.bits.hMSL == false)
-    getPVT(maxWait);
-  packetUBXNAVPVT->moduleQueried.moduleQueried1.bits.hMSL = false; //Since we are about to give this to user, mark this data as stale
-  packetUBXNAVPVT->moduleQueried.moduleQueried1.bits.all = false;
-  return (packetUBXNAVPVT->data.hMSL);
-}
-
-int32_t SFE_UBLOX_GNSS::getHorizontalAccEst(uint16_t maxWait)
-{
-  if (packetUBXNAVPVT == NULL) initPacketUBXNAVPVT(); //Check that RAM has been allocated for the PVT data
-  if (packetUBXNAVPVT == NULL) //Bail if the RAM allocation failed
-    return 0;
-
-  if (packetUBXNAVPVT->moduleQueried.moduleQueried1.bits.hAcc == false)
-    getPVT(maxWait);
-  packetUBXNAVPVT->moduleQueried.moduleQueried1.bits.hAcc = false; //Since we are about to give this to user, mark this data as stale
-  packetUBXNAVPVT->moduleQueried.moduleQueried1.bits.all = false;
-  return (packetUBXNAVPVT->data.hAcc);
-}
-
-int32_t SFE_UBLOX_GNSS::getVerticalAccEst(uint16_t maxWait)
-{
-  if (packetUBXNAVPVT == NULL) initPacketUBXNAVPVT(); //Check that RAM has been allocated for the PVT data
-  if (packetUBXNAVPVT == NULL) //Bail if the RAM allocation failed
-    return 0;
-
-  if (packetUBXNAVPVT->moduleQueried.moduleQueried1.bits.vAcc == false)
-    getPVT(maxWait);
-  packetUBXNAVPVT->moduleQueried.moduleQueried1.bits.vAcc = false; //Since we are about to give this to user, mark this data as stale
-  packetUBXNAVPVT->moduleQueried.moduleQueried1.bits.all = false;
-  return (packetUBXNAVPVT->data.vAcc);
-}
-
-int32_t SFE_UBLOX_GNSS::getNedNorthVel(uint16_t maxWait)
-{
-  if (packetUBXNAVPVT == NULL) initPacketUBXNAVPVT(); //Check that RAM has been allocated for the PVT data
-  if (packetUBXNAVPVT == NULL) //Bail if the RAM allocation failed
-    return 0;
-
-  if (packetUBXNAVPVT->moduleQueried.moduleQueried1.bits.velN == false)
-    getPVT(maxWait);
-  packetUBXNAVPVT->moduleQueried.moduleQueried1.bits.velN = false; //Since we are about to give this to user, mark this data as stale
-  packetUBXNAVPVT->moduleQueried.moduleQueried1.bits.all = false;
-  return (packetUBXNAVPVT->data.velN);
-}
-
-int32_t SFE_UBLOX_GNSS::getNedEastVel(uint16_t maxWait)
-{
-  if (packetUBXNAVPVT == NULL) initPacketUBXNAVPVT(); //Check that RAM has been allocated for the PVT data
-  if (packetUBXNAVPVT == NULL) //Bail if the RAM allocation failed
-    return 0;
-
-  if (packetUBXNAVPVT->moduleQueried.moduleQueried1.bits.velE == false)
-    getPVT(maxWait);
-  packetUBXNAVPVT->moduleQueried.moduleQueried1.bits.velE = false; //Since we are about to give this to user, mark this data as stale
-  packetUBXNAVPVT->moduleQueried.moduleQueried1.bits.all = false;
-  return (packetUBXNAVPVT->data.velE);
-}
-
-int32_t SFE_UBLOX_GNSS::getNedDownVel(uint16_t maxWait)
-{
-  if (packetUBXNAVPVT == NULL) initPacketUBXNAVPVT(); //Check that RAM has been allocated for the PVT data
-  if (packetUBXNAVPVT == NULL) //Bail if the RAM allocation failed
-    return 0;
-
-  if (packetUBXNAVPVT->moduleQueried.moduleQueried2.bits.velD == false)
-    getPVT(maxWait);
-  packetUBXNAVPVT->moduleQueried.moduleQueried2.bits.velD = false; //Since we are about to give this to user, mark this data as stale
-  packetUBXNAVPVT->moduleQueried.moduleQueried1.bits.all = false;
-  return (packetUBXNAVPVT->data.velD);
-}
-
-//Get the ground speed in mm/s
-int32_t SFE_UBLOX_GNSS::getGroundSpeed(uint16_t maxWait)
-{
-  if (packetUBXNAVPVT == NULL) initPacketUBXNAVPVT(); //Check that RAM has been allocated for the PVT data
-  if (packetUBXNAVPVT == NULL) //Bail if the RAM allocation failed
-    return 0;
-
-  if (packetUBXNAVPVT->moduleQueried.moduleQueried2.bits.gSpeed == false)
-    getPVT(maxWait);
-  packetUBXNAVPVT->moduleQueried.moduleQueried2.bits.gSpeed = false; //Since we are about to give this to user, mark this data as stale
-  packetUBXNAVPVT->moduleQueried.moduleQueried1.bits.all = false;
-  return (packetUBXNAVPVT->data.gSpeed);
-}
-
-//Get the heading of motion (as opposed to heading of car) in degrees * 10^-5
-int32_t SFE_UBLOX_GNSS::getHeading(uint16_t maxWait)
-{
-  if (packetUBXNAVPVT == NULL) initPacketUBXNAVPVT(); //Check that RAM has been allocated for the PVT data
-  if (packetUBXNAVPVT == NULL) //Bail if the RAM allocation failed
-    return 0;
-
-  if (packetUBXNAVPVT->moduleQueried.moduleQueried2.bits.headMot == false)
-    getPVT(maxWait);
-  packetUBXNAVPVT->moduleQueried.moduleQueried2.bits.headMot = false; //Since we are about to give this to user, mark this data as stale
-  packetUBXNAVPVT->moduleQueried.moduleQueried1.bits.all = false;
-  return (packetUBXNAVPVT->data.headMot);
-}
-
-uint32_t SFE_UBLOX_GNSS::getSpeedAccEst(uint16_t maxWait)
-{
-  if (packetUBXNAVPVT == NULL) initPacketUBXNAVPVT(); //Check that RAM has been allocated for the PVT data
-  if (packetUBXNAVPVT == NULL) //Bail if the RAM allocation failed
-    return 0;
-
-  if (packetUBXNAVPVT->moduleQueried.moduleQueried2.bits.sAcc == false)
-    getPVT(maxWait);
-  packetUBXNAVPVT->moduleQueried.moduleQueried2.bits.sAcc = false; //Since we are about to give this to user, mark this data as stale
-  packetUBXNAVPVT->moduleQueried.moduleQueried1.bits.all = false;
-  return (packetUBXNAVPVT->data.sAcc);
-}
-
-uint32_t SFE_UBLOX_GNSS::getHeadingAccEst(uint16_t maxWait)
-{
-  if (packetUBXNAVPVT == NULL) initPacketUBXNAVPVT(); //Check that RAM has been allocated for the PVT data
-  if (packetUBXNAVPVT == NULL) //Bail if the RAM allocation failed
-    return 0;
-
-  if (packetUBXNAVPVT->moduleQueried.moduleQueried2.bits.headAcc == false)
-    getPVT(maxWait);
-  packetUBXNAVPVT->moduleQueried.moduleQueried2.bits.headAcc = false; //Since we are about to give this to user, mark this data as stale
-  packetUBXNAVPVT->moduleQueried.moduleQueried1.bits.all = false;
-  return (packetUBXNAVPVT->data.headAcc);
-}
-
-//Get the positional dillution of precision * 10^-2 (dimensionless)
-uint16_t SFE_UBLOX_GNSS::getPDOP(uint16_t maxWait)
-{
-  if (packetUBXNAVPVT == NULL) initPacketUBXNAVPVT(); //Check that RAM has been allocated for the PVT data
-  if (packetUBXNAVPVT == NULL) //Bail if the RAM allocation failed
-    return 0;
-
-  if (packetUBXNAVPVT->moduleQueried.moduleQueried2.bits.pDOP == false)
-    getPVT(maxWait);
-  packetUBXNAVPVT->moduleQueried.moduleQueried2.bits.pDOP = false; //Since we are about to give this to user, mark this data as stale
-  packetUBXNAVPVT->moduleQueried.moduleQueried1.bits.all = false;
-  return (packetUBXNAVPVT->data.pDOP);
-}
-
-bool SFE_UBLOX_GNSS::getInvalidLlh(uint16_t maxWait)
-{
-  if (packetUBXNAVPVT == NULL) initPacketUBXNAVPVT(); //Check that RAM has been allocated for the PVT data
-  if (packetUBXNAVPVT == NULL) //Bail if the RAM allocation failed
-    return (false);
-
-  if (packetUBXNAVPVT->moduleQueried.moduleQueried2.bits.invalidLlh == false)
-    getPVT(maxWait);
-  packetUBXNAVPVT->moduleQueried.moduleQueried2.bits.invalidLlh = false; //Since we are about to give this to user, mark this data as stale
-  packetUBXNAVPVT->moduleQueried.moduleQueried1.bits.all = false;
-  return ((bool)packetUBXNAVPVT->data.flags3.bits.invalidLlh);
-}
-
-int32_t SFE_UBLOX_GNSS::getHeadVeh(uint16_t maxWait)
-{
-  if (packetUBXNAVPVT == NULL) initPacketUBXNAVPVT(); //Check that RAM has been allocated for the PVT data
-  if (packetUBXNAVPVT == NULL) //Bail if the RAM allocation failed
-    return 0;
-
-  if (packetUBXNAVPVT->moduleQueried.moduleQueried2.bits.headVeh == false)
-    getPVT(maxWait);
-  packetUBXNAVPVT->moduleQueried.moduleQueried2.bits.headVeh = false; //Since we are about to give this to user, mark this data as stale
-  packetUBXNAVPVT->moduleQueried.moduleQueried1.bits.all = false;
-  return (packetUBXNAVPVT->data.headVeh);
-}
-
-int16_t SFE_UBLOX_GNSS::getMagDec(uint16_t maxWait)
-{
-  if (packetUBXNAVPVT == NULL) initPacketUBXNAVPVT(); //Check that RAM has been allocated for the PVT data
-  if (packetUBXNAVPVT == NULL) //Bail if the RAM allocation failed
-    return 0;
-
-  if (packetUBXNAVPVT->moduleQueried.moduleQueried2.bits.magDec == false)
-    getPVT(maxWait);
-  packetUBXNAVPVT->moduleQueried.moduleQueried2.bits.magDec = false; //Since we are about to give this to user, mark this data as stale
-  packetUBXNAVPVT->moduleQueried.moduleQueried1.bits.all = false;
-  return (packetUBXNAVPVT->data.magDec);
-}
-
-uint16_t SFE_UBLOX_GNSS::getMagAcc(uint16_t maxWait)
-{
-  if (packetUBXNAVPVT == NULL) initPacketUBXNAVPVT(); //Check that RAM has been allocated for the PVT data
-  if (packetUBXNAVPVT == NULL) //Bail if the RAM allocation failed
-    return 0;
-
-  if (packetUBXNAVPVT->moduleQueried.moduleQueried2.bits.magAcc == false)
-    getPVT(maxWait);
-  packetUBXNAVPVT->moduleQueried.moduleQueried2.bits.magAcc = false; //Since we are about to give this to user, mark this data as stale
-  packetUBXNAVPVT->moduleQueried.moduleQueried1.bits.all = false;
-  return (packetUBXNAVPVT->data.magAcc);
-}
-
-// getGeoidSeparation is currently redundant. The geoid separation seems to only be provided in NMEA GGA and GNS messages.
-int32_t SFE_UBLOX_GNSS::getGeoidSeparation(uint16_t maxWait)
-{
-  return (0);
-}
-
-// ***** HPPOSECEF Helper Functions
-
-//Get the current 3D high precision positional accuracy - a fun thing to watch
-//Returns a long representing the 3D accuracy in millimeters
-uint32_t SFE_UBLOX_GNSS::getPositionAccuracy(uint16_t maxWait)
-{
-  if (packetUBXNAVHPPOSECEF == NULL) initPacketUBXNAVHPPOSECEF(); //Check that RAM has been allocated for the HPPOSECEF data
-  if (packetUBXNAVHPPOSECEF == NULL) //Bail if the RAM allocation failed
-    return 0;
-
-  if (packetUBXNAVHPPOSECEF->moduleQueried.moduleQueried.bits.pAcc == false)
-    getNAVHPPOSECEF(maxWait);
-  packetUBXNAVHPPOSECEF->moduleQueried.moduleQueried.bits.pAcc = false; //Since we are about to give this to user, mark this data as stale
-  packetUBXNAVHPPOSECEF->moduleQueried.moduleQueried.bits.all = false;
-
-  uint32_t tempAccuracy = packetUBXNAVHPPOSECEF->data.pAcc;
-
-  if ((tempAccuracy % 10) >= 5)
-    tempAccuracy += 5; //Round fraction of mm up to next mm if .5 or above
-  tempAccuracy /= 10;  //Convert 0.1mm units to mm
-
-  return (tempAccuracy);
-}
-
-// ***** HPPOSLLH Helper Functions
-
-uint32_t SFE_UBLOX_GNSS::getTimeOfWeekFromHPPOSLLH(uint16_t maxWait)
-{
-  if (packetUBXNAVHPPOSLLH == NULL) initPacketUBXNAVHPPOSLLH(); //Check that RAM has been allocated for the HPPOSLLH data
-  if (packetUBXNAVHPPOSLLH == NULL) //Bail if the RAM allocation failed
-    return 0;
-
-  if (packetUBXNAVHPPOSLLH->moduleQueried.moduleQueried.bits.iTOW == false)
-    getHPPOSLLH(maxWait);
-  packetUBXNAVHPPOSLLH->moduleQueried.moduleQueried.bits.iTOW = false; //Since we are about to give this to user, mark this data as stale
-  packetUBXNAVHPPOSLLH->moduleQueried.moduleQueried.bits.all = false;
-  return (packetUBXNAVHPPOSLLH->data.iTOW);
-}
-
-int32_t SFE_UBLOX_GNSS::getHighResLongitude(uint16_t maxWait)
-{
-  if (packetUBXNAVHPPOSLLH == NULL) initPacketUBXNAVHPPOSLLH(); //Check that RAM has been allocated for the HPPOSLLH data
-  if (packetUBXNAVHPPOSLLH == NULL) //Bail if the RAM allocation failed
-    return 0;
-
-  if (packetUBXNAVHPPOSLLH->moduleQueried.moduleQueried.bits.lon == false)
-    getHPPOSLLH(maxWait);
-  packetUBXNAVHPPOSLLH->moduleQueried.moduleQueried.bits.lon = false; //Since we are about to give this to user, mark this data as stale
-  packetUBXNAVHPPOSLLH->moduleQueried.moduleQueried.bits.all = false;
-  return (packetUBXNAVHPPOSLLH->data.lon);
-}
-
-int32_t SFE_UBLOX_GNSS::getHighResLatitude(uint16_t maxWait)
-{
-  if (packetUBXNAVHPPOSLLH == NULL) initPacketUBXNAVHPPOSLLH(); //Check that RAM has been allocated for the HPPOSLLH data
-  if (packetUBXNAVHPPOSLLH == NULL) //Bail if the RAM allocation failed
-    return 0;
-
-  if (packetUBXNAVHPPOSLLH->moduleQueried.moduleQueried.bits.lat == false)
-    getHPPOSLLH(maxWait);
-  packetUBXNAVHPPOSLLH->moduleQueried.moduleQueried.bits.lat = false; //Since we are about to give this to user, mark this data as stale
-  packetUBXNAVHPPOSLLH->moduleQueried.moduleQueried.bits.all = false;
-  return (packetUBXNAVHPPOSLLH->data.lat);
-}
-
-int32_t SFE_UBLOX_GNSS::getElipsoid(uint16_t maxWait)
-{
-  if (packetUBXNAVHPPOSLLH == NULL) initPacketUBXNAVHPPOSLLH(); //Check that RAM has been allocated for the HPPOSLLH data
-  if (packetUBXNAVHPPOSLLH == NULL) //Bail if the RAM allocation failed
-    return 0;
-
-  if (packetUBXNAVHPPOSLLH->moduleQueried.moduleQueried.bits.height == false)
-    getHPPOSLLH(maxWait);
-  packetUBXNAVHPPOSLLH->moduleQueried.moduleQueried.bits.height = false; //Since we are about to give this to user, mark this data as stale
-  packetUBXNAVHPPOSLLH->moduleQueried.moduleQueried.bits.all = false;
-  return (packetUBXNAVHPPOSLLH->data.height);
-}
-
-int32_t SFE_UBLOX_GNSS::getMeanSeaLevel(uint16_t maxWait)
-{
-  if (packetUBXNAVHPPOSLLH == NULL) initPacketUBXNAVHPPOSLLH(); //Check that RAM has been allocated for the HPPOSLLH data
-  if (packetUBXNAVHPPOSLLH == NULL) //Bail if the RAM allocation failed
-    return 0;
-
-  if (packetUBXNAVHPPOSLLH->moduleQueried.moduleQueried.bits.hMSL == false)
-    getHPPOSLLH(maxWait);
-  packetUBXNAVHPPOSLLH->moduleQueried.moduleQueried.bits.hMSL = false; //Since we are about to give this to user, mark this data as stale
-  packetUBXNAVHPPOSLLH->moduleQueried.moduleQueried.bits.all = false;
-  return (packetUBXNAVHPPOSLLH->data.hMSL);
-}
-
-int8_t SFE_UBLOX_GNSS::getHighResLongitudeHp(uint16_t maxWait)
-{
-  if (packetUBXNAVHPPOSLLH == NULL) initPacketUBXNAVHPPOSLLH(); //Check that RAM has been allocated for the HPPOSLLH data
-  if (packetUBXNAVHPPOSLLH == NULL) //Bail if the RAM allocation failed
-    return 0;
-
-  if (packetUBXNAVHPPOSLLH->moduleQueried.moduleQueried.bits.lonHp == false)
-    getHPPOSLLH(maxWait);
-  packetUBXNAVHPPOSLLH->moduleQueried.moduleQueried.bits.lonHp = false; //Since we are about to give this to user, mark this data as stale
-  packetUBXNAVHPPOSLLH->moduleQueried.moduleQueried.bits.all = false;
-  return (packetUBXNAVHPPOSLLH->data.lonHp);
-}
-
-int8_t SFE_UBLOX_GNSS::getHighResLatitudeHp(uint16_t maxWait)
-{
-  if (packetUBXNAVHPPOSLLH == NULL) initPacketUBXNAVHPPOSLLH(); //Check that RAM has been allocated for the HPPOSLLH data
-  if (packetUBXNAVHPPOSLLH == NULL) //Bail if the RAM allocation failed
-    return 0;
-
-  if (packetUBXNAVHPPOSLLH->moduleQueried.moduleQueried.bits.latHp == false)
-    getHPPOSLLH(maxWait);
-  packetUBXNAVHPPOSLLH->moduleQueried.moduleQueried.bits.latHp = false; //Since we are about to give this to user, mark this data as stale
-  packetUBXNAVHPPOSLLH->moduleQueried.moduleQueried.bits.all = false;
-  return (packetUBXNAVHPPOSLLH->data.latHp);
-}
-
-int8_t SFE_UBLOX_GNSS::getElipsoidHp(uint16_t maxWait)
-{
-  if (packetUBXNAVHPPOSLLH == NULL) initPacketUBXNAVHPPOSLLH(); //Check that RAM has been allocated for the HPPOSLLH data
-  if (packetUBXNAVHPPOSLLH == NULL) //Bail if the RAM allocation failed
-    return 0;
-
-  if (packetUBXNAVHPPOSLLH->moduleQueried.moduleQueried.bits.heightHp == false)
-    getHPPOSLLH(maxWait);
-  packetUBXNAVHPPOSLLH->moduleQueried.moduleQueried.bits.heightHp = false; //Since we are about to give this to user, mark this data as stale
-  packetUBXNAVHPPOSLLH->moduleQueried.moduleQueried.bits.all = false;
-  return (packetUBXNAVHPPOSLLH->data.heightHp);
-}
-
-int8_t SFE_UBLOX_GNSS::getMeanSeaLevelHp(uint16_t maxWait)
-{
-  if (packetUBXNAVHPPOSLLH == NULL) initPacketUBXNAVHPPOSLLH(); //Check that RAM has been allocated for the HPPOSLLH data
-  if (packetUBXNAVHPPOSLLH == NULL) //Bail if the RAM allocation failed
-    return 0;
-
-  if (packetUBXNAVHPPOSLLH->moduleQueried.moduleQueried.bits.hMSLHp == false)
-    getHPPOSLLH(maxWait);
-  packetUBXNAVHPPOSLLH->moduleQueried.moduleQueried.bits.hMSLHp = false; //Since we are about to give this to user, mark this data as stale
-  packetUBXNAVHPPOSLLH->moduleQueried.moduleQueried.bits.all = false;
-  return (packetUBXNAVHPPOSLLH->data.hMSLHp);
-}
-
-uint32_t SFE_UBLOX_GNSS::getHorizontalAccuracy(uint16_t maxWait)
-{
-  if (packetUBXNAVHPPOSLLH == NULL) initPacketUBXNAVHPPOSLLH(); //Check that RAM has been allocated for the HPPOSLLH data
-  if (packetUBXNAVHPPOSLLH == NULL) //Bail if the RAM allocation failed
-    return 0;
-
-  if (packetUBXNAVHPPOSLLH->moduleQueried.moduleQueried.bits.hAcc == false)
-    getHPPOSLLH(maxWait);
-  packetUBXNAVHPPOSLLH->moduleQueried.moduleQueried.bits.hAcc = false; //Since we are about to give this to user, mark this data as stale
-  packetUBXNAVHPPOSLLH->moduleQueried.moduleQueried.bits.all = false;
-  return (packetUBXNAVHPPOSLLH->data.hAcc);
-}
-
-uint32_t SFE_UBLOX_GNSS::getVerticalAccuracy(uint16_t maxWait)
-{
-  if (packetUBXNAVHPPOSLLH == NULL) initPacketUBXNAVHPPOSLLH(); //Check that RAM has been allocated for the HPPOSLLH data
-  if (packetUBXNAVHPPOSLLH == NULL) //Bail if the RAM allocation failed
-    return 0;
-
-  if (packetUBXNAVHPPOSLLH->moduleQueried.moduleQueried.bits.vAcc == false)
-    getHPPOSLLH(maxWait);
-  packetUBXNAVHPPOSLLH->moduleQueried.moduleQueried.bits.vAcc = false; //Since we are about to give this to user, mark this data as stale
-  packetUBXNAVHPPOSLLH->moduleQueried.moduleQueried.bits.all = false;
-  return (packetUBXNAVHPPOSLLH->data.vAcc);
-}
-
-// ***** SVIN Helper Functions
-
-boolean SFE_UBLOX_GNSS::getSurveyInActive(uint16_t maxWait)
-{
-  if (packetUBXNAVSVIN == NULL) initPacketUBXNAVSVIN(); //Check that RAM has been allocated for the SVIN data
-  if (packetUBXNAVSVIN == NULL) //Bail if the RAM allocation failed
-    return false;
-
-  if (packetUBXNAVSVIN->moduleQueried.moduleQueried.bits.active == false)
-    getSurveyStatus(maxWait);
-  packetUBXNAVSVIN->moduleQueried.moduleQueried.bits.active = false; //Since we are about to give this to user, mark this data as stale
-  packetUBXNAVSVIN->moduleQueried.moduleQueried.bits.all = false;
-  return ((boolean)packetUBXNAVSVIN->data.active);
-}
-
-boolean SFE_UBLOX_GNSS::getSurveyInValid(uint16_t maxWait)
-{
-  if (packetUBXNAVSVIN == NULL) initPacketUBXNAVSVIN(); //Check that RAM has been allocated for the SVIN data
-  if (packetUBXNAVSVIN == NULL) //Bail if the RAM allocation failed
-    return false;
-
-  if (packetUBXNAVSVIN->moduleQueried.moduleQueried.bits.valid == false)
-    getSurveyStatus(maxWait);
-  packetUBXNAVSVIN->moduleQueried.moduleQueried.bits.valid = false; //Since we are about to give this to user, mark this data as stale
-  packetUBXNAVSVIN->moduleQueried.moduleQueried.bits.all = false;
-  return ((boolean)packetUBXNAVSVIN->data.valid);
-}
-
-uint16_t SFE_UBLOX_GNSS::getSurveyInObservationTime(uint16_t maxWait) // Truncated to 65535 seconds
-{
-  if (packetUBXNAVSVIN == NULL) initPacketUBXNAVSVIN(); //Check that RAM has been allocated for the SVIN data
-  if (packetUBXNAVSVIN == NULL) //Bail if the RAM allocation failed
-    return 0;
-
-  if (packetUBXNAVSVIN->moduleQueried.moduleQueried.bits.dur == false)
-    getSurveyStatus(maxWait);
-  packetUBXNAVSVIN->moduleQueried.moduleQueried.bits.dur = false; //Since we are about to give this to user, mark this data as stale
-  packetUBXNAVSVIN->moduleQueried.moduleQueried.bits.all = false;
-
-  //dur (Passed survey-in observation time) is U4 (uint32_t) seconds. We truncate to 16 bits
-  //(waiting more than 65535 seconds (18.2 hours) seems excessive!)
-  uint32_t tmpObsTime = packetUBXNAVSVIN->data.dur;
-  if (tmpObsTime <= 0xFFFF)
-  {
-    return((uint16_t)tmpObsTime);
-  }
-  else
-  {
-    return(0xFFFF);
-  }
-}
-
-float SFE_UBLOX_GNSS::getSurveyInMeanAccuracy(uint16_t maxWait) // Returned as m
-{
-  if (packetUBXNAVSVIN == NULL) initPacketUBXNAVSVIN(); //Check that RAM has been allocated for the SVIN data
-  if (packetUBXNAVSVIN == NULL) //Bail if the RAM allocation failed
-    return 0;
-
-  if (packetUBXNAVSVIN->moduleQueried.moduleQueried.bits.meanAcc == false)
-    getSurveyStatus(maxWait);
-  packetUBXNAVSVIN->moduleQueried.moduleQueried.bits.meanAcc = false; //Since we are about to give this to user, mark this data as stale
-  packetUBXNAVSVIN->moduleQueried.moduleQueried.bits.all = false;
-
-  // meanAcc is U4 (uint32_t) in 0.1mm. We convert this to float.
-  uint32_t tempFloat = packetUBXNAVSVIN->data.meanAcc;
-  return (((float)tempFloat) / 10000.0); //Convert 0.1mm to m
-}
-
-// ***** RELPOSNED Helper Functions and automatic support
-
-float SFE_UBLOX_GNSS::getRelPosN(uint16_t maxWait) // Returned as m
-{
-  if (packetUBXNAVRELPOSNED == NULL) initPacketUBXNAVRELPOSNED(); //Check that RAM has been allocated for the RELPOSNED data
-  if (packetUBXNAVRELPOSNED == NULL) //Bail if the RAM allocation failed
-    return 0;
-
-  if (packetUBXNAVRELPOSNED->moduleQueried.moduleQueried.bits.relPosN == false)
-    getRELPOSNED(maxWait);
-  packetUBXNAVRELPOSNED->moduleQueried.moduleQueried.bits.relPosN = false; //Since we are about to give this to user, mark this data as stale
-  packetUBXNAVRELPOSNED->moduleQueried.moduleQueried.bits.all = false;
-  return (((float)packetUBXNAVRELPOSNED->data.relPosN) / 100.0); // Convert to m
-}
-
-float SFE_UBLOX_GNSS::getRelPosE(uint16_t maxWait) // Returned as m
-{
-  if (packetUBXNAVRELPOSNED == NULL) initPacketUBXNAVRELPOSNED(); //Check that RAM has been allocated for the RELPOSNED data
-  if (packetUBXNAVRELPOSNED == NULL) //Bail if the RAM allocation failed
-    return 0;
-
-  if (packetUBXNAVRELPOSNED->moduleQueried.moduleQueried.bits.relPosE == false)
-    getRELPOSNED(maxWait);
-  packetUBXNAVRELPOSNED->moduleQueried.moduleQueried.bits.relPosE = false; //Since we are about to give this to user, mark this data as stale
-  packetUBXNAVRELPOSNED->moduleQueried.moduleQueried.bits.all = false;
-  return (((float)packetUBXNAVRELPOSNED->data.relPosE) / 100.0); // Convert to m
-}
-
-float SFE_UBLOX_GNSS::getRelPosD(uint16_t maxWait) // Returned as m
-{
-  if (packetUBXNAVRELPOSNED == NULL) initPacketUBXNAVRELPOSNED(); //Check that RAM has been allocated for the RELPOSNED data
-  if (packetUBXNAVRELPOSNED == NULL) //Bail if the RAM allocation failed
-    return 0;
-
-  if (packetUBXNAVRELPOSNED->moduleQueried.moduleQueried.bits.relPosD == false)
-    getRELPOSNED(maxWait);
-  packetUBXNAVRELPOSNED->moduleQueried.moduleQueried.bits.relPosD = false; //Since we are about to give this to user, mark this data as stale
-  packetUBXNAVRELPOSNED->moduleQueried.moduleQueried.bits.all = false;
-  return (((float)packetUBXNAVRELPOSNED->data.relPosD) / 100.0); // Convert to m
-}
-
-float SFE_UBLOX_GNSS::getRelPosAccN(uint16_t maxWait) // Returned as m
-{
-  if (packetUBXNAVRELPOSNED == NULL) initPacketUBXNAVRELPOSNED(); //Check that RAM has been allocated for the RELPOSNED data
-  if (packetUBXNAVRELPOSNED == NULL) //Bail if the RAM allocation failed
-    return 0;
-
-  if (packetUBXNAVRELPOSNED->moduleQueried.moduleQueried.bits.accN == false)
-    getRELPOSNED(maxWait);
-  packetUBXNAVRELPOSNED->moduleQueried.moduleQueried.bits.accN = false; //Since we are about to give this to user, mark this data as stale
-  packetUBXNAVRELPOSNED->moduleQueried.moduleQueried.bits.all = false;
-  return (((float)packetUBXNAVRELPOSNED->data.accN) / 10000.0); // Convert to m
-}
-
-float SFE_UBLOX_GNSS::getRelPosAccE(uint16_t maxWait) // Returned as m
-{
-  if (packetUBXNAVRELPOSNED == NULL) initPacketUBXNAVRELPOSNED(); //Check that RAM has been allocated for the RELPOSNED data
-  if (packetUBXNAVRELPOSNED == NULL) //Bail if the RAM allocation failed
-    return 0;
-
-  if (packetUBXNAVRELPOSNED->moduleQueried.moduleQueried.bits.accE == false)
-    getRELPOSNED(maxWait);
-  packetUBXNAVRELPOSNED->moduleQueried.moduleQueried.bits.accE = false; //Since we are about to give this to user, mark this data as stale
-  packetUBXNAVRELPOSNED->moduleQueried.moduleQueried.bits.all = false;
-  return (((float)packetUBXNAVRELPOSNED->data.accE) / 10000.0); // Convert to m
-}
-
-float SFE_UBLOX_GNSS::getRelPosAccD(uint16_t maxWait) // Returned as m
-{
-  if (packetUBXNAVRELPOSNED == NULL) initPacketUBXNAVRELPOSNED(); //Check that RAM has been allocated for the RELPOSNED data
-  if (packetUBXNAVRELPOSNED == NULL) //Bail if the RAM allocation failed
-    return 0;
-
-  if (packetUBXNAVRELPOSNED->moduleQueried.moduleQueried.bits.accD == false)
-    getRELPOSNED(maxWait);
-  packetUBXNAVRELPOSNED->moduleQueried.moduleQueried.bits.accD = false; //Since we are about to give this to user, mark this data as stale
-  packetUBXNAVRELPOSNED->moduleQueried.moduleQueried.bits.all = false;
-  return (((float)packetUBXNAVRELPOSNED->data.accD) / 10000.0); // Convert to m
-}
-
-// ***** ESF Helper Functions
-
-float SFE_UBLOX_GNSS::getESFroll(uint16_t maxWait) // Returned as degrees
-{
-  if (packetUBXESFALG == NULL) initPacketUBXESFALG(); //Check that RAM has been allocated for the ESF ALG data
-  if (packetUBXESFALG == NULL) //Bail if the RAM allocation failed
-    return (0);
-
-  if (packetUBXESFALG->moduleQueried.moduleQueried.bits.roll == false)
-    getESFALG(maxWait);
-  packetUBXESFALG->moduleQueried.moduleQueried.bits.roll = false; //Since we are about to give this to user, mark this data as stale
-  packetUBXESFALG->moduleQueried.moduleQueried.bits.all = false;
-  return (((float)packetUBXESFALG->data.roll) / 100.0); // Convert to degrees
-}
-
-float SFE_UBLOX_GNSS::getESFpitch(uint16_t maxWait) // Returned as degrees
-{
-  if (packetUBXESFALG == NULL) initPacketUBXESFALG(); //Check that RAM has been allocated for the ESF ALG data
-  if (packetUBXESFALG == NULL) //Bail if the RAM allocation failed
-    return (0);
-
-  if (packetUBXESFALG->moduleQueried.moduleQueried.bits.pitch == false)
-    getESFALG(maxWait);
-  packetUBXESFALG->moduleQueried.moduleQueried.bits.pitch = false; //Since we are about to give this to user, mark this data as stale
-  packetUBXESFALG->moduleQueried.moduleQueried.bits.all = false;
-  return (((float)packetUBXESFALG->data.pitch) / 100.0); // Convert to degrees
-}
-
-float SFE_UBLOX_GNSS::getESFyaw(uint16_t maxWait) // Returned as degrees
-{
-  if (packetUBXESFALG == NULL) initPacketUBXESFALG(); //Check that RAM has been allocated for the ESF ALG data
-  if (packetUBXESFALG == NULL) //Bail if the RAM allocation failed
-    return (0);
-
-  if (packetUBXESFALG->moduleQueried.moduleQueried.bits.yaw == false)
-    getESFALG(maxWait);
-  packetUBXESFALG->moduleQueried.moduleQueried.bits.yaw = false; //Since we are about to give this to user, mark this data as stale
-  packetUBXESFALG->moduleQueried.moduleQueried.bits.all = false;
-  return (((float)packetUBXESFALG->data.yaw) / 100.0); // Convert to degrees
-}
-
-boolean SFE_UBLOX_GNSS::getSensorFusionMeasurement(UBX_ESF_MEAS_sensorData_t *sensorData, uint8_t sensor, uint16_t maxWait)
-{
-  if (packetUBXESFMEAS == NULL) initPacketUBXESFMEAS(); //Check that RAM has been allocated for the ESF MEAS data
-  if (packetUBXESFMEAS == NULL) //Bail if the RAM allocation failed
-    return (false);
-
-  if (packetUBXESFMEAS->moduleQueried.moduleQueried.bits.data & ((1 << sensor) == 0))
-    getESFMEAS(maxWait);
-  packetUBXESFMEAS->moduleQueried.moduleQueried.bits.data &= ~(1 << sensor); //Since we are about to give this to user, mark this data as stale
-  packetUBXESFMEAS->moduleQueried.moduleQueried.bits.all = false;
-  sensorData->data.all = packetUBXESFMEAS->data.data[sensor].data.all;
-  return (true);
-}
-
-boolean SFE_UBLOX_GNSS::getSensorFusionMeasurement(UBX_ESF_MEAS_sensorData_t *sensorData, UBX_ESF_MEAS_data_t ubxDataStruct, uint8_t sensor)
-{
-  sensorData->data.all = ubxDataStruct.data[sensor].data.all;
-  return (true);
-}
-
-boolean SFE_UBLOX_GNSS::getRawSensorMeasurement(UBX_ESF_RAW_sensorData_t *sensorData, uint8_t sensor, uint16_t maxWait)
-{
-  if (packetUBXESFRAW == NULL) initPacketUBXESFRAW(); //Check that RAM has been allocated for the ESF RAW data
-  if (packetUBXESFRAW == NULL) //Bail if the RAM allocation failed
-    return (false);
-
-  if (packetUBXESFRAW->moduleQueried.moduleQueried.bits.data & ((1 << sensor) == 0))
-    getESFRAW(maxWait);
-  packetUBXESFRAW->moduleQueried.moduleQueried.bits.data &= ~(1 << sensor); //Since we are about to give this to user, mark this data as stale
-  packetUBXESFRAW->moduleQueried.moduleQueried.bits.all = false;
-  sensorData->data.all = packetUBXESFRAW->data.data[sensor].data.all;
-  sensorData->sTag = packetUBXESFRAW->data.data[sensor].sTag;
-  return (true);
-}
-
-boolean SFE_UBLOX_GNSS::getRawSensorMeasurement(UBX_ESF_RAW_sensorData_t *sensorData, UBX_ESF_RAW_data_t ubxDataStruct, uint8_t sensor)
-{
-  sensorData->data.all = ubxDataStruct.data[sensor].data.all;
-  sensorData->sTag = ubxDataStruct.data[sensor].sTag;
-  return (true);
-}
-
-boolean SFE_UBLOX_GNSS::getSensorFusionStatus(UBX_ESF_STATUS_sensorStatus_t *sensorStatus, uint8_t sensor, uint16_t maxWait)
-{
-  if (packetUBXESFSTATUS == NULL) initPacketUBXESFSTATUS(); //Check that RAM has been allocated for the ESF STATUS data
-  if (packetUBXESFSTATUS == NULL) //Bail if the RAM allocation failed
-    return (false);
-
-  if (packetUBXESFSTATUS->moduleQueried.moduleQueried.bits.status & ((1 << sensor) == 0))
-    getESFSTATUS(maxWait);
-  packetUBXESFSTATUS->moduleQueried.moduleQueried.bits.status &= ~(1 << sensor); //Since we are about to give this to user, mark this data as stale
-  packetUBXESFSTATUS->moduleQueried.moduleQueried.bits.all = false;
-  sensorStatus->sensStatus1.all = packetUBXESFSTATUS->data.status[sensor].sensStatus1.all;
-  sensorStatus->sensStatus2.all = packetUBXESFSTATUS->data.status[sensor].sensStatus2.all;
-  sensorStatus->freq = packetUBXESFSTATUS->data.status[sensor].freq;
-  sensorStatus->faults.all = packetUBXESFSTATUS->data.status[sensor].faults.all;
-  return (true);
-}
-
-boolean SFE_UBLOX_GNSS::getSensorFusionStatus(UBX_ESF_STATUS_sensorStatus_t *sensorStatus, UBX_ESF_STATUS_data_t ubxDataStruct, uint8_t sensor)
-{
-  sensorStatus->sensStatus1.all = ubxDataStruct.status[sensor].sensStatus1.all;
-  sensorStatus->sensStatus2.all = ubxDataStruct.status[sensor].sensStatus2.all;
-  sensorStatus->freq = ubxDataStruct.status[sensor].freq;
-  sensorStatus->faults.all = ubxDataStruct.status[sensor].faults.all;
-  return (true);
-}
-
-// ***** HNR Helper Functions
-
-// Set the High Navigation Rate
-// Returns true if the setHNRNavigationRate is successful
-boolean SFE_UBLOX_GNSS::setHNRNavigationRate(uint8_t rate, uint16_t maxWait)
-{
-  packetCfg.cls = UBX_CLASS_CFG;
-  packetCfg.id = UBX_CFG_HNR;
-  packetCfg.len = 0;
-  packetCfg.startingSpot = 0;
-
-  //Ask module for the current HNR settings. Loads into payloadCfg.
-  if (sendCommand(&packetCfg, maxWait) != SFE_UBLOX_STATUS_DATA_RECEIVED)
-    return (false);
-
-  //Load the new navigation rate into payloadCfg
-  payloadCfg[0] = rate;
-
-  //Update the navigation rate
-  sfe_ublox_status_e result = sendCommand(&packetCfg, maxWait); // We are only expecting an ACK
-
-  //Adjust the I2C polling timeout based on update rate
-  if (result == SFE_UBLOX_STATUS_DATA_SENT)
-    i2cPollingWait = 1000 / (((int)rate) * 4); //This is the number of ms to wait between checks for new I2C data
-
-  return (result == SFE_UBLOX_STATUS_DATA_SENT);
-}
-
-// Get the High Navigation Rate
-// Returns 0 if the getHNRNavigationRate fails
-uint8_t SFE_UBLOX_GNSS::getHNRNavigationRate(uint16_t maxWait)
-{
-  packetCfg.cls = UBX_CLASS_CFG;
-  packetCfg.id = UBX_CFG_HNR;
-  packetCfg.len = 0;
-  packetCfg.startingSpot = 0;
-
-  //Ask module for the current HNR settings. Loads into payloadCfg.
-  if (sendCommand(&packetCfg, maxWait) != SFE_UBLOX_STATUS_DATA_RECEIVED)
-    return (0);
-
-  //Return the navigation rate
-  return (payloadCfg[0]);
-}
-
-float SFE_UBLOX_GNSS::getHNRroll(uint16_t maxWait) // Returned as degrees
-{
-  if (packetUBXHNRATT == NULL) initPacketUBXHNRATT(); //Check that RAM has been allocated for the HNR ATT data
-  if (packetUBXHNRATT == NULL) //Bail if the RAM allocation failed
-    return (0);
-
-  if (packetUBXHNRATT->moduleQueried.moduleQueried.bits.roll == false)
-    getHNRATT(maxWait);
-  packetUBXHNRATT->moduleQueried.moduleQueried.bits.roll = false; //Since we are about to give this to user, mark this data as stale
-  packetUBXHNRATT->moduleQueried.moduleQueried.bits.all = false;
-  return (((float)packetUBXHNRATT->data.roll) / 100000.0); // Convert to degrees
-}
-
-float SFE_UBLOX_GNSS::getHNRpitch(uint16_t maxWait) // Returned as degrees
-{
-  if (packetUBXHNRATT == NULL) initPacketUBXHNRATT(); //Check that RAM has been allocated for the HNR ATT data
-  if (packetUBXHNRATT == NULL) //Bail if the RAM allocation failed
-    return (0);
-
-  if (packetUBXHNRATT->moduleQueried.moduleQueried.bits.pitch == false)
-    getHNRATT(maxWait);
-  packetUBXHNRATT->moduleQueried.moduleQueried.bits.pitch = false; //Since we are about to give this to user, mark this data as stale
-  packetUBXHNRATT->moduleQueried.moduleQueried.bits.all = false;
-  return (((float)packetUBXHNRATT->data.pitch) / 100000.0); // Convert to degrees
-}
-
-float SFE_UBLOX_GNSS::getHNRheading(uint16_t maxWait) // Returned as degrees
-{
-  if (packetUBXHNRATT == NULL) initPacketUBXHNRATT(); //Check that RAM has been allocated for the HNR ATT data
-  if (packetUBXHNRATT == NULL) //Bail if the RAM allocation failed
-    return (0);
-
-  if (packetUBXHNRATT->moduleQueried.moduleQueried.bits.heading == false)
-    getHNRATT(maxWait);
-  packetUBXHNRATT->moduleQueried.moduleQueried.bits.heading = false; //Since we are about to give this to user, mark this data as stale
-  packetUBXHNRATT->moduleQueried.moduleQueried.bits.all = false;
-  return (((float)packetUBXHNRATT->data.heading) / 100000.0); // Convert to degrees
-}
-
-// Functions to extract signed and unsigned 8/16/32-bit data from a ubxPacket
-// From v2.0: These are public. The user can call these to extract data from custom packets
-
-//Given a spot in the payload array, extract four bytes and build a long
-uint32_t SFE_UBLOX_GNSS::extractLong(ubxPacket *msg, uint8_t spotToStart)
-{
-  uint32_t val = 0;
-  val |= (uint32_t)msg->payload[spotToStart + 0] << 8 * 0;
-  val |= (uint32_t)msg->payload[spotToStart + 1] << 8 * 1;
-  val |= (uint32_t)msg->payload[spotToStart + 2] << 8 * 2;
-  val |= (uint32_t)msg->payload[spotToStart + 3] << 8 * 3;
-  return (val);
-}
-
-//Just so there is no ambiguity about whether a uint32_t will cast to a int32_t correctly...
-int32_t SFE_UBLOX_GNSS::extractSignedLong(ubxPacket *msg, uint8_t spotToStart)
-{
-  union // Use a union to convert from uint32_t to int32_t
-  {
-      uint32_t unsignedLong;
-      int32_t signedLong;
-  } unsignedSigned;
-
-  unsignedSigned.unsignedLong = extractLong(msg, spotToStart);
-  return (unsignedSigned.signedLong);
-}
-
-//Given a spot in the payload array, extract two bytes and build an int
-uint16_t SFE_UBLOX_GNSS::extractInt(ubxPacket *msg, uint8_t spotToStart)
-{
-  uint16_t val = 0;
-  val |= (uint16_t)msg->payload[spotToStart + 0] << 8 * 0;
-  val |= (uint16_t)msg->payload[spotToStart + 1] << 8 * 1;
-  return (val);
-}
-
-//Just so there is no ambiguity about whether a uint16_t will cast to a int16_t correctly...
-int16_t SFE_UBLOX_GNSS::extractSignedInt(ubxPacket *msg, int8_t spotToStart)
-{
-  union // Use a union to convert from uint16_t to int16_t
-  {
-      uint16_t unsignedInt;
-      int16_t signedInt;
-  } stSignedInt;
-
-  stSignedInt.unsignedInt = extractInt(msg, spotToStart);
-  return (stSignedInt.signedInt);
-}
-
-//Given a spot, extract a byte from the payload
-uint8_t SFE_UBLOX_GNSS::extractByte(ubxPacket *msg, uint8_t spotToStart)
-{
-  return (msg->payload[spotToStart]);
-}
-
-//Given a spot, extract a signed 8-bit value from the payload
-int8_t SFE_UBLOX_GNSS::extractSignedChar(ubxPacket *msg, uint8_t spotToStart)
-{
-  union // Use a union to convert from uint8_t to int8_t
-  {
-      uint8_t unsignedByte;
-      int8_t signedByte;
-  } stSignedByte;
-
-  stSignedByte.unsignedByte = extractByte(msg, spotToStart);
-  return (stSignedByte.signedByte);
-}
diff --git a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/src/SparkFun_u-blox_GNSS_Arduino_Library.h b/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/src/SparkFun_u-blox_GNSS_Arduino_Library.h
deleted file mode 100644
index 8e8ab2d..0000000
--- a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/src/SparkFun_u-blox_GNSS_Arduino_Library.h
+++ /dev/null
@@ -1,1240 +0,0 @@
-/*
-	This is a library written for the u-blox ZED-F9P and NEO-M8P-2
-	SparkFun sells these at its website: www.sparkfun.com
-	Do you like this library? Help support SparkFun. Buy a board!
-	https://www.sparkfun.com/products/16481
-	https://www.sparkfun.com/products/15136
-	https://www.sparkfun.com/products/15005
-	https://www.sparkfun.com/products/15733
-	https://www.sparkfun.com/products/15193
-	https://www.sparkfun.com/products/15210
-
-	Original version by Nathan Seidle @ SparkFun Electronics, September 6th, 2018
-	v2.0 rework by Paul Clark @ SparkFun Electronics, December 31st, 2020
-
-	This library handles configuring and handling the responses
-	from a u-blox GPS module. Works with most modules from u-blox including
-	the Zed-F9P, NEO-M8P-2, NEO-M9N, ZOE-M8Q, SAM-M8Q, and many others.
-
-	https://github.com/sparkfun/SparkFun_Ublox_Arduino_Library
-
-	Development environment specifics:
-	Arduino IDE 1.8.13
-
-	SparkFun code, firmware, and software is released under the MIT License(http://opensource.org/licenses/MIT).
-	The MIT License (MIT)
-	Copyright (c) 2016 SparkFun Electronics
-	Permission is hereby granted, free of charge, to any person obtaining a copy of this software and
-	associated documentation files (the "Software"), to deal in the Software without restriction,
-	including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
-	and/or sell copies of the Software, and to permit persons to whom the Software is furnished to
-	do so, subject to the following conditions:
-
-	The above copyright notice and this permission notice shall be included in all copies or substantial
-	portions of the Software.
-
-	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT
-	NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
-	IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
-	WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
-	SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-*/
-
-#ifndef SPARKFUN_UBLOX_ARDUINO_LIBRARY_H
-#define SPARKFUN_UBLOX_ARDUINO_LIBRARY_H
-
-#if (ARDUINO >= 100)
-#include "Arduino.h"
-#else
-#include "WProgram.h"
-#endif
-
-#include <Wire.h>
-
-#include "u-blox_config_keys.h"
-#include "u-blox_structs.h"
-
-//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
-
-//Define a digital pin to aid debugging
-//Leave set to -1 if not needed
-const int debugPin = -1;
-
-// Global Status Returns
-typedef enum
-{
-	SFE_UBLOX_STATUS_SUCCESS,
-	SFE_UBLOX_STATUS_FAIL,
-	SFE_UBLOX_STATUS_CRC_FAIL,
-	SFE_UBLOX_STATUS_TIMEOUT,
-	SFE_UBLOX_STATUS_COMMAND_NACK, // Indicates that the command was unrecognised, invalid or that the module is too busy to respond
-	SFE_UBLOX_STATUS_OUT_OF_RANGE,
-	SFE_UBLOX_STATUS_INVALID_ARG,
-	SFE_UBLOX_STATUS_INVALID_OPERATION,
-	SFE_UBLOX_STATUS_MEM_ERR,
-	SFE_UBLOX_STATUS_HW_ERR,
-	SFE_UBLOX_STATUS_DATA_SENT,		// This indicates that a 'set' was successful
-	SFE_UBLOX_STATUS_DATA_RECEIVED, // This indicates that a 'get' (poll) was successful
-	SFE_UBLOX_STATUS_I2C_COMM_FAILURE,
-	SFE_UBLOX_STATUS_DATA_OVERWRITTEN // This is an error - the data was valid but has been or _is being_ overwritten by another packet
-} sfe_ublox_status_e;
-
-// ubxPacket validity
-typedef enum
-{
-	SFE_UBLOX_PACKET_VALIDITY_NOT_VALID,
-	SFE_UBLOX_PACKET_VALIDITY_VALID,
-	SFE_UBLOX_PACKET_VALIDITY_NOT_DEFINED,
-	SFE_UBLOX_PACKET_NOTACKNOWLEDGED // This indicates that we received a NACK
-} sfe_ublox_packet_validity_e;
-
-// Identify which packet buffer is in use:
-// packetCfg (or a custom packet), packetAck or packetBuf
-// packetAuto is used to store expected "automatic" messages
-typedef enum
-{
-	SFE_UBLOX_PACKET_PACKETCFG,
-	SFE_UBLOX_PACKET_PACKETACK,
-	SFE_UBLOX_PACKET_PACKETBUF,
-	SFE_UBLOX_PACKET_PACKETAUTO
-} sfe_ublox_packet_buffer_e;
-
-//Registers
-const uint8_t UBX_SYNCH_1 = 0xB5;
-const uint8_t UBX_SYNCH_2 = 0x62;
-
-//The following are UBX Class IDs. Descriptions taken from ZED-F9P Interface Description Document page 32, NEO-M8P Interface Description page 145
-const uint8_t UBX_CLASS_NAV = 0x01;	 //Navigation Results Messages: Position, Speed, Time, Acceleration, Heading, DOP, SVs used
-const uint8_t UBX_CLASS_RXM = 0x02;	 //Receiver Manager Messages: Satellite Status, RTC Status
-const uint8_t UBX_CLASS_INF = 0x04;	 //Information Messages: Printf-Style Messages, with IDs such as Error, Warning, Notice
-const uint8_t UBX_CLASS_ACK = 0x05;	 //Ack/Nak Messages: Acknowledge or Reject messages to UBX-CFG input messages
-const uint8_t UBX_CLASS_CFG = 0x06;	 //Configuration Input Messages: Configure the receiver.
-const uint8_t UBX_CLASS_UPD = 0x09;	 //Firmware Update Messages: Memory/Flash erase/write, Reboot, Flash identification, etc.
-const uint8_t UBX_CLASS_MON = 0x0A;	 //Monitoring Messages: Communication Status, CPU Load, Stack Usage, Task Status
-const uint8_t UBX_CLASS_AID = 0x0B;	 //(NEO-M8P ONLY!!!) AssistNow Aiding Messages: Ephemeris, Almanac, other A-GPS data input
-const uint8_t UBX_CLASS_TIM = 0x0D;	 //Timing Messages: Time Pulse Output, Time Mark Results
-const uint8_t UBX_CLASS_ESF = 0x10;	 //(NEO-M8P ONLY!!!) External Sensor Fusion Messages: External Sensor Measurements and Status Information
-const uint8_t UBX_CLASS_MGA = 0x13;	 //Multiple GNSS Assistance Messages: Assistance data for various GNSS
-const uint8_t UBX_CLASS_LOG = 0x21;	 //Logging Messages: Log creation, deletion, info and retrieval
-const uint8_t UBX_CLASS_SEC = 0x27;	 //Security Feature Messages
-const uint8_t UBX_CLASS_HNR = 0x28;	 //(NEO-M8P ONLY!!!) High Rate Navigation Results Messages: High rate time, position speed, heading
-const uint8_t UBX_CLASS_NMEA = 0xF0; //NMEA Strings: standard NMEA strings
-
-//Class: CFG
-//The following are used for configuration. Descriptions are from the ZED-F9P Interface Description pg 33-34 and NEO-M9N Interface Description pg 47-48
-const uint8_t UBX_CFG_ANT = 0x13;		//Antenna Control Settings. Used to configure the antenna control settings
-const uint8_t UBX_CFG_BATCH = 0x93;		//Get/set data batching configuration.
-const uint8_t UBX_CFG_CFG = 0x09;		//Clear, Save, and Load Configurations. Used to save current configuration
-const uint8_t UBX_CFG_DAT = 0x06;		//Set User-defined Datum or The currently defined Datum
-const uint8_t UBX_CFG_DGNSS = 0x70;		//DGNSS configuration
-const uint8_t UBX_CFG_ESFALG = 0x56;		//ESF alignment
-const uint8_t UBX_CFG_ESFA = 0x4C;		//ESF accelerometer
-const uint8_t UBX_CFG_ESFG = 0x4D;		//ESF gyro
-const uint8_t UBX_CFG_GEOFENCE = 0x69;	//Geofencing configuration. Used to configure a geofence
-const uint8_t UBX_CFG_GNSS = 0x3E;		//GNSS system configuration
-const uint8_t UBX_CFG_HNR = 0x5C;		//High Navigation Rate
-const uint8_t UBX_CFG_INF = 0x02;		//Depending on packet length, either: poll configuration for one protocol, or information message configuration
-const uint8_t UBX_CFG_ITFM = 0x39;		//Jamming/Interference Monitor configuration
-const uint8_t UBX_CFG_LOGFILTER = 0x47; //Data Logger Configuration
-const uint8_t UBX_CFG_MSG = 0x01;		//Poll a message configuration, or Set Message Rate(s), or Set Message Rate
-const uint8_t UBX_CFG_NAV5 = 0x24;		//Navigation Engine Settings. Used to configure the navigation engine including the dynamic model.
-const uint8_t UBX_CFG_NAVX5 = 0x23;		//Navigation Engine Expert Settings
-const uint8_t UBX_CFG_NMEA = 0x17;		//Extended NMEA protocol configuration V1
-const uint8_t UBX_CFG_ODO = 0x1E;		//Odometer, Low-speed COG Engine Settings
-const uint8_t UBX_CFG_PM2 = 0x3B;		//Extended power management configuration
-const uint8_t UBX_CFG_PMS = 0x86;		//Power mode setup
-const uint8_t UBX_CFG_PRT = 0x00;		//Used to configure port specifics. Polls the configuration for one I/O Port, or Port configuration for UART ports, or Port configuration for USB port, or Port configuration for SPI port, or Port configuration for DDC port
-const uint8_t UBX_CFG_PWR = 0x57;		//Put receiver in a defined power state
-const uint8_t UBX_CFG_RATE = 0x08;		//Navigation/Measurement Rate Settings. Used to set port baud rates.
-const uint8_t UBX_CFG_RINV = 0x34;		//Contents of Remote Inventory
-const uint8_t UBX_CFG_RST = 0x04;		//Reset Receiver / Clear Backup Data Structures. Used to reset device.
-const uint8_t UBX_CFG_RXM = 0x11;		//RXM configuration
-const uint8_t UBX_CFG_SBAS = 0x16;		//SBAS configuration
-const uint8_t UBX_CFG_TMODE3 = 0x71;	//Time Mode Settings 3. Used to enable Survey In Mode
-const uint8_t UBX_CFG_TP5 = 0x31;		//Time Pulse Parameters
-const uint8_t UBX_CFG_USB = 0x1B;		//USB Configuration
-const uint8_t UBX_CFG_VALDEL = 0x8C;	//Used for config of higher version u-blox modules (ie protocol v27 and above). Deletes values corresponding to provided keys/ provided keys with a transaction
-const uint8_t UBX_CFG_VALGET = 0x8B;	//Used for config of higher version u-blox modules (ie protocol v27 and above). Configuration Items
-const uint8_t UBX_CFG_VALSET = 0x8A;	//Used for config of higher version u-blox modules (ie protocol v27 and above). Sets values corresponding to provided key-value pairs/ provided key-value pairs within a transaction.
-
-//Class: NMEA
-//The following are used to enable NMEA messages. Descriptions come from the NMEA messages overview in the ZED-F9P Interface Description
-const uint8_t UBX_NMEA_MSB = 0xF0;	//All NMEA enable commands have 0xF0 as MSB
-const uint8_t UBX_NMEA_DTM = 0x0A;	//GxDTM (datum reference)
-const uint8_t UBX_NMEA_GAQ = 0x45;	//GxGAQ (poll a standard message (if the current talker ID is GA))
-const uint8_t UBX_NMEA_GBQ = 0x44;	//GxGBQ (poll a standard message (if the current Talker ID is GB))
-const uint8_t UBX_NMEA_GBS = 0x09;	//GxGBS (GNSS satellite fault detection)
-const uint8_t UBX_NMEA_GGA = 0x00;	//GxGGA (Global positioning system fix data)
-const uint8_t UBX_NMEA_GLL = 0x01;	//GxGLL (latitude and long, whith time of position fix and status)
-const uint8_t UBX_NMEA_GLQ = 0x43;	//GxGLQ (poll a standard message (if the current Talker ID is GL))
-const uint8_t UBX_NMEA_GNQ = 0x42;	//GxGNQ (poll a standard message (if the current Talker ID is GN))
-const uint8_t UBX_NMEA_GNS = 0x0D;	//GxGNS (GNSS fix data)
-const uint8_t UBX_NMEA_GPQ = 0x040; //GxGPQ (poll a standard message (if the current Talker ID is GP))
-const uint8_t UBX_NMEA_GRS = 0x06;	//GxGRS (GNSS range residuals)
-const uint8_t UBX_NMEA_GSA = 0x02;	//GxGSA (GNSS DOP and Active satellites)
-const uint8_t UBX_NMEA_GST = 0x07;	//GxGST (GNSS Pseudo Range Error Statistics)
-const uint8_t UBX_NMEA_GSV = 0x03;	//GxGSV (GNSS satellites in view)
-const uint8_t UBX_NMEA_RMC = 0x04;	//GxRMC (Recommended minimum data)
-const uint8_t UBX_NMEA_TXT = 0x41;	//GxTXT (text transmission)
-const uint8_t UBX_NMEA_VLW = 0x0F;	//GxVLW (dual ground/water distance)
-const uint8_t UBX_NMEA_VTG = 0x05;	//GxVTG (course over ground and Ground speed)
-const uint8_t UBX_NMEA_ZDA = 0x08;	//GxZDA (Time and Date)
-
-//The following are used to configure the NMEA protocol main talker ID and GSV talker ID
-const uint8_t UBX_NMEA_MAINTALKERID_NOTOVERRIDDEN = 0x00; //main talker ID is system dependent
-const uint8_t UBX_NMEA_MAINTALKERID_GP = 0x01;			  //main talker ID is GPS
-const uint8_t UBX_NMEA_MAINTALKERID_GL = 0x02;			  //main talker ID is GLONASS
-const uint8_t UBX_NMEA_MAINTALKERID_GN = 0x03;			  //main talker ID is combined receiver
-const uint8_t UBX_NMEA_MAINTALKERID_GA = 0x04;			  //main talker ID is Galileo
-const uint8_t UBX_NMEA_MAINTALKERID_GB = 0x05;			  //main talker ID is BeiDou
-const uint8_t UBX_NMEA_GSVTALKERID_GNSS = 0x00;			  //GNSS specific Talker ID (as defined by NMEA)
-const uint8_t UBX_NMEA_GSVTALKERID_MAIN = 0x01;			  //use the main Talker ID
-
-//Class: HNR
-//The following are used to configure the HNR message rates
-const uint8_t UBX_HNR_ATT = 0x01;			  //HNR Attitude
-const uint8_t UBX_HNR_INS = 0x02;			  //HNR Vehicle Dynamics
-const uint8_t UBX_HNR_PVT = 0x00;			  //HNR PVT
-
-//Class: INF
-//The following are used to configure INF UBX messages (information messages).  Descriptions from UBX messages overview (ZED_F9P Interface Description Document page 34)
-const uint8_t UBX_INF_CLASS = 0x04;	  //All INF messages have 0x04 as the class
-const uint8_t UBX_INF_DEBUG = 0x04;	  //ASCII output with debug contents
-const uint8_t UBX_INF_ERROR = 0x00;	  //ASCII output with error contents
-const uint8_t UBX_INF_NOTICE = 0x02;  //ASCII output with informational contents
-const uint8_t UBX_INF_TEST = 0x03;	  //ASCII output with test contents
-const uint8_t UBX_INF_WARNING = 0x01; //ASCII output with warning contents
-
-//Class: LOG
-//The following are used to configure LOG UBX messages (loggings messages).  Descriptions from UBX messages overview (ZED_F9P Interface Description Document page 34)
-const uint8_t UBX_LOG_CREATE = 0x07;		   //Create Log File
-const uint8_t UBX_LOG_ERASE = 0x03;			   //Erase Logged Data
-const uint8_t UBX_LOG_FINDTIME = 0x0E;		   //Find index of a log entry based on a given time, or response to FINDTIME requested
-const uint8_t UBX_LOG_INFO = 0x08;			   //Poll for log information, or Log information
-const uint8_t UBX_LOG_RETRIEVEPOSEXTRA = 0x0F; //Odometer log entry
-const uint8_t UBX_LOG_RETRIEVEPOS = 0x0B;	   //Position fix log entry
-const uint8_t UBX_LOG_RETRIEVESTRING = 0x0D;   //Byte string log entry
-const uint8_t UBX_LOG_RETRIEVE = 0x09;		   //Request log data
-const uint8_t UBX_LOG_STRING = 0x04;		   //Store arbitrary string on on-board flash
-
-//Class: MGA
-//The following are used to configure MGA UBX messages (Multiple GNSS Assistance Messages).  Descriptions from UBX messages overview (ZED_F9P Interface Description Document page 34)
-const uint8_t UBX_MGA_ACK_DATA0 = 0x60;		 //Multiple GNSS Acknowledge message
-const uint8_t UBX_MGA_BDS_EPH = 0x03;		 //BDS Ephemeris Assistance
-const uint8_t UBX_MGA_BDS_ALM = 0x03;		 //BDS Almanac Assistance
-const uint8_t UBX_MGA_BDS_HEALTH = 0x03;	 //BDS Health Assistance
-const uint8_t UBX_MGA_BDS_UTC = 0x03;		 //BDS UTC Assistance
-const uint8_t UBX_MGA_BDS_IONO = 0x03;		 //BDS Ionospheric Assistance
-const uint8_t UBX_MGA_DBD = 0x80;			 //Either: Poll the Navigation Database, or Navigation Database Dump Entry
-const uint8_t UBX_MGA_GAL_EPH = 0x02;		 //Galileo Ephemeris Assistance
-const uint8_t UBX_MGA_GAL_ALM = 0x02;		 //Galileo Almanac Assitance
-const uint8_t UBX_MGA_GAL_TIMOFFSET = 0x02;	 //Galileo GPS time offset assistance
-const uint8_t UBX_MGA_GAL_UTC = 0x02;		 //Galileo UTC Assistance
-const uint8_t UBX_MGA_GLO_EPH = 0x06;		 //GLONASS Ephemeris Assistance
-const uint8_t UBX_MGA_GLO_ALM = 0x06;		 //GLONASS Almanac Assistance
-const uint8_t UBX_MGA_GLO_TIMEOFFSET = 0x06; //GLONASS Auxiliary Time Offset Assistance
-const uint8_t UBX_MGA_GPS_EPH = 0x00;		 //GPS Ephemeris Assistance
-const uint8_t UBX_MGA_GPS_ALM = 0x00;		 //GPS Almanac Assistance
-const uint8_t UBX_MGA_GPS_HEALTH = 0x00;	 //GPS Health Assistance
-const uint8_t UBX_MGA_GPS_UTC = 0x00;		 //GPS UTC Assistance
-const uint8_t UBX_MGA_GPS_IONO = 0x00;		 //GPS Ionosphere Assistance
-const uint8_t UBX_MGA_INI_POS_XYZ = 0x40;	 //Initial Position Assistance
-const uint8_t UBX_MGA_INI_POS_LLH = 0x40;	 //Initial Position Assitance
-const uint8_t UBX_MGA_INI_TIME_UTC = 0x40;	 //Initial Time Assistance
-const uint8_t UBX_MGA_INI_TIME_GNSS = 0x40;	 //Initial Time Assistance
-const uint8_t UBX_MGA_INI_CLKD = 0x40;		 //Initial Clock Drift Assitance
-const uint8_t UBX_MGA_INI_FREQ = 0x40;		 //Initial Frequency Assistance
-const uint8_t UBX_MGA_INI_EOP = 0x40;		 //Earth Orientation Parameters Assistance
-const uint8_t UBX_MGA_QZSS_EPH = 0x05;		 //QZSS Ephemeris Assistance
-const uint8_t UBX_MGA_QZSS_ALM = 0x05;		 //QZSS Almanac Assistance
-const uint8_t UBX_MGA_QZAA_HEALTH = 0x05;	 //QZSS Health Assistance
-
-//Class: MON
-//The following are used to configure the MON UBX messages (monitoring messages). Descriptions from UBX messages overview (ZED_F9P Interface Description Document page 35)
-const uint8_t UBX_MON_COMMS = 0x36; //Comm port information
-const uint8_t UBX_MON_GNSS = 0x28;	//Information message major GNSS selection
-const uint8_t UBX_MON_HW2 = 0x0B;	//Extended Hardware Status
-const uint8_t UBX_MON_HW3 = 0x37;	//HW I/O pin information
-const uint8_t UBX_MON_HW = 0x09;	//Hardware Status
-const uint8_t UBX_MON_IO = 0x02;	//I/O Subsystem Status
-const uint8_t UBX_MON_MSGPP = 0x06; //Message Parse and Process Status
-const uint8_t UBX_MON_PATCH = 0x27; //Output information about installed patches
-const uint8_t UBX_MON_RF = 0x38;	//RF information
-const uint8_t UBX_MON_RXBUF = 0x07; //Receiver Buffer Status
-const uint8_t UBX_MON_RXR = 0x21;	//Receiver Status Information
-const uint8_t UBX_MON_TXBUF = 0x08; //Transmitter Buffer Status. Used for query tx buffer size/state.
-const uint8_t UBX_MON_VER = 0x04;	//Receiver/Software Version. Used for obtaining Protocol Version.
-
-//Class: NAV
-//The following are used to configure the NAV UBX messages (navigation results messages). Descriptions from UBX messages overview (ZED_F9P Interface Description Document page 35-36)
-const uint8_t UBX_NAV_ATT = 0x05;		//Vehicle "Attitude" Solution
-const uint8_t UBX_NAV_CLOCK = 0x22;		//Clock Solution
-const uint8_t UBX_NAV_DOP = 0x04;		//Dilution of precision
-const uint8_t UBX_NAV_EOE = 0x61;		//End of Epoch
-const uint8_t UBX_NAV_GEOFENCE = 0x39;	//Geofencing status. Used to poll the geofence status
-const uint8_t UBX_NAV_HPPOSECEF = 0x13; //High Precision Position Solution in ECEF. Used to find our positional accuracy (high precision).
-const uint8_t UBX_NAV_HPPOSLLH = 0x14;	//High Precision Geodetic Position Solution. Used for obtaining lat/long/alt in high precision
-const uint8_t UBX_NAV_ODO = 0x09;		//Odometer Solution
-const uint8_t UBX_NAV_ORB = 0x34;		//GNSS Orbit Database Info
-const uint8_t UBX_NAV_POSECEF = 0x01;	//Position Solution in ECEF
-const uint8_t UBX_NAV_POSLLH = 0x02;	//Geodetic Position Solution
-const uint8_t UBX_NAV_PVT = 0x07;		//All the things! Position, velocity, time, PDOP, height, h/v accuracies, number of satellites. Navigation Position Velocity Time Solution.
-const uint8_t UBX_NAV_RELPOSNED = 0x3C; //Relative Positioning Information in NED frame
-const uint8_t UBX_NAV_RESETODO = 0x10;	//Reset odometer
-const uint8_t UBX_NAV_SAT = 0x35;		//Satellite Information
-const uint8_t UBX_NAV_SIG = 0x43;		//Signal Information
-const uint8_t UBX_NAV_STATUS = 0x03;	//Receiver Navigation Status
-const uint8_t UBX_NAV_SVIN = 0x3B;		//Survey-in data. Used for checking Survey In status
-const uint8_t UBX_NAV_TIMEBDS = 0x24;	//BDS Time Solution
-const uint8_t UBX_NAV_TIMEGAL = 0x25;	//Galileo Time Solution
-const uint8_t UBX_NAV_TIMEGLO = 0x23;	//GLO Time Solution
-const uint8_t UBX_NAV_TIMEGPS = 0x20;	//GPS Time Solution
-const uint8_t UBX_NAV_TIMELS = 0x26;	//Leap second event information
-const uint8_t UBX_NAV_TIMEUTC = 0x21;	//UTC Time Solution
-const uint8_t UBX_NAV_VELECEF = 0x11;	//Velocity Solution in ECEF
-const uint8_t UBX_NAV_VELNED = 0x12;	//Velocity Solution in NED
-
-//Class: RXM
-//The following are used to configure the RXM UBX messages (receiver manager messages). Descriptions from UBX messages overview (ZED_F9P Interface Description Document page 36)
-const uint8_t UBX_RXM_MEASX = 0x14; //Satellite Measurements for RRLP
-const uint8_t UBX_RXM_PMREQ = 0x41; //Requests a Power Management task (two differenent packet sizes)
-const uint8_t UBX_RXM_RAWX = 0x15;	//Multi-GNSS Raw Measurement Data
-const uint8_t UBX_RXM_RLM = 0x59;	//Galileo SAR Short-RLM report (two different packet sizes)
-const uint8_t UBX_RXM_RTCM = 0x32;	//RTCM input status
-const uint8_t UBX_RXM_SFRBX = 0x13; //Boradcast Navigation Data Subframe
-
-//Class: SEC
-//The following are used to configure the SEC UBX messages (security feature messages). Descriptions from UBX messages overview (ZED_F9P Interface Description Document page 36)
-const uint8_t UBX_SEC_UNIQID = 0x03; //Unique chip ID
-
-//Class: TIM
-//The following are used to configure the TIM UBX messages (timing messages). Descriptions from UBX messages overview (ZED_F9P Interface Description Document page 36)
-const uint8_t UBX_TIM_TM2 = 0x03;  //Time mark data
-const uint8_t UBX_TIM_TP = 0x01;   //Time Pulse Timedata
-const uint8_t UBX_TIM_VRFY = 0x06; //Sourced Time Verification
-
-//Class: UPD
-//The following are used to configure the UPD UBX messages (firmware update messages). Descriptions from UBX messages overview (ZED-F9P Interface Description Document page 36)
-const uint8_t UBX_UPD_SOS = 0x14; //Poll Backup Fil Restore Status, Create Backup File in Flash, Clear Backup File in Flash, Backup File Creation Acknowledge, System Restored from Backup
-
-//The following are used to enable RTCM messages
-const uint8_t UBX_RTCM_MSB = 0xF5;	  //All RTCM enable commands have 0xF5 as MSB
-const uint8_t UBX_RTCM_1005 = 0x05;	  //Stationary RTK reference ARP
-const uint8_t UBX_RTCM_1074 = 0x4A;	  //GPS MSM4
-const uint8_t UBX_RTCM_1077 = 0x4D;	  //GPS MSM7
-const uint8_t UBX_RTCM_1084 = 0x54;	  //GLONASS MSM4
-const uint8_t UBX_RTCM_1087 = 0x57;	  //GLONASS MSM7
-const uint8_t UBX_RTCM_1094 = 0x5E;	  //Galileo MSM4
-const uint8_t UBX_RTCM_1097 = 0x61;	  //Galileo MSM7
-const uint8_t UBX_RTCM_1124 = 0x7C;	  //BeiDou MSM4
-const uint8_t UBX_RTCM_1127 = 0x7F;	  //BeiDou MSM7
-const uint8_t UBX_RTCM_1230 = 0xE6;	  //GLONASS code-phase biases, set to once every 10 seconds
-const uint8_t UBX_RTCM_4072_0 = 0xFE; //Reference station PVT (ublox proprietary RTCM message)
-const uint8_t UBX_RTCM_4072_1 = 0xFD; //Additional reference station information (ublox proprietary RTCM message)
-
-// Class: ACK
-const uint8_t UBX_ACK_NACK = 0x00;
-const uint8_t UBX_ACK_ACK = 0x01;
-const uint8_t UBX_ACK_NONE = 0x02; //Not a real value
-
-//Class: ESF
-// The following constants are used to get External Sensor Measurements and Status
-// Information.
-const uint8_t UBX_ESF_MEAS = 0x02;
-const uint8_t UBX_ESF_RAW = 0x03;
-const uint8_t UBX_ESF_STATUS = 0x10;
-const uint8_t UBX_ESF_RESETALG = 0x13;
-const uint8_t UBX_ESF_ALG = 0x14;
-const uint8_t UBX_ESF_INS = 0x15; //36 bytes
-
-const uint8_t SVIN_MODE_DISABLE = 0x00;
-const uint8_t SVIN_MODE_ENABLE = 0x01;
-
-//The following consts are used to configure the various ports and streams for those ports. See -CFG-PRT.
-const uint8_t COM_PORT_I2C = 0;
-const uint8_t COM_PORT_UART1 = 1;
-const uint8_t COM_PORT_UART2 = 2;
-const uint8_t COM_PORT_USB = 3;
-const uint8_t COM_PORT_SPI = 4;
-
-const uint8_t COM_TYPE_UBX = (1 << 0);
-const uint8_t COM_TYPE_NMEA = (1 << 1);
-const uint8_t COM_TYPE_RTCM3 = (1 << 5);
-
-// Configuration Sub-Section mask definitions for saveConfigSelective (UBX-CFG-CFG)
-const uint32_t VAL_CFG_SUBSEC_IOPORT = 0x00000001;	 // ioPort - communications port settings (causes IO system reset!)
-const uint32_t VAL_CFG_SUBSEC_MSGCONF = 0x00000002;	 // msgConf - message configuration
-const uint32_t VAL_CFG_SUBSEC_INFMSG = 0x00000004;	 // infMsg - INF message configuration
-const uint32_t VAL_CFG_SUBSEC_NAVCONF = 0x00000008;	 // navConf - navigation configuration
-const uint32_t VAL_CFG_SUBSEC_RXMCONF = 0x00000010;	 // rxmConf - receiver manager configuration
-const uint32_t VAL_CFG_SUBSEC_SENCONF = 0x00000100;	 // senConf - sensor interface configuration (requires protocol 19+)
-const uint32_t VAL_CFG_SUBSEC_RINVCONF = 0x00000200; // rinvConf - remove inventory configuration
-const uint32_t VAL_CFG_SUBSEC_ANTCONF = 0x00000400;	 // antConf - antenna configuration
-const uint32_t VAL_CFG_SUBSEC_LOGCONF = 0x00000800;	 // logConf - logging configuration
-const uint32_t VAL_CFG_SUBSEC_FTSCONF = 0x00001000;	 // ftsConf - FTS configuration (FTS products only)
-
-// Bitfield wakeupSources for UBX_RXM_PMREQ
-const uint32_t VAL_RXM_PMREQ_WAKEUPSOURCE_UARTRX = 0x00000008;	// uartrx
-const uint32_t VAL_RXM_PMREQ_WAKEUPSOURCE_EXTINT0 = 0x00000020; // extint0
-const uint32_t VAL_RXM_PMREQ_WAKEUPSOURCE_EXTINT1 = 0x00000040; // extint1
-const uint32_t VAL_RXM_PMREQ_WAKEUPSOURCE_SPICS = 0x00000080;	// spics
-
-enum dynModel // Possible values for the dynamic platform model, which provide more accuract position output for the situation. Description extracted from ZED-F9P Integration Manual
-{
-	DYN_MODEL_PORTABLE = 0, //Applications with low acceleration, e.g. portable devices. Suitable for most situations.
-	// 1 is not defined
-	DYN_MODEL_STATIONARY = 2, //Used in timing applications (antenna must be stationary) or other stationary applications. Velocity restricted to 0 m/s. Zero dynamics assumed.
-	DYN_MODEL_PEDESTRIAN,	  //Applications with low acceleration and speed, e.g. how a pedestrian would move. Low acceleration assumed.
-	DYN_MODEL_AUTOMOTIVE,	  //Used for applications with equivalent dynamics to those of a passenger car. Low vertical acceleration assumed
-	DYN_MODEL_SEA,			  //Recommended for applications at sea, with zero vertical velocity. Zero vertical velocity assumed. Sea level assumed.
-	DYN_MODEL_AIRBORNE1g,	  //Airborne <1g acceleration. Used for applications with a higher dynamic range and greater vertical acceleration than a passenger car. No 2D position fixes supported.
-	DYN_MODEL_AIRBORNE2g,	  //Airborne <2g acceleration. Recommended for typical airborne environments. No 2D position fixes supported.
-	DYN_MODEL_AIRBORNE4g,	  //Airborne <4g acceleration. Only recommended for extremely dynamic environments. No 2D position fixes supported.
-	DYN_MODEL_WRIST,		  // Not supported in protocol versions less than 18. Only recommended for wrist worn applications. Receiver will filter out arm motion.
-	DYN_MODEL_BIKE,			  // Supported in protocol versions 19.2
-	DYN_MODEL_UNKNOWN = 255 // getDynamicModel will return 255 if sendCommand fails
-};
-
-// The GNSS identifiers - used by UBX-CFG-GNSS (0x06 0x3E) GNSS system configuration
-enum sfe_ublox_gnss_ids_e
-{
-	SFE_UBLOX_GNSS_ID_GPS,
-	SFE_UBLOX_GNSS_ID_SBAS,
-	SFE_UBLOX_GNSS_ID_GALILEO,
-	SFE_UBLOX_GNSS_ID_BEIDOU,
-	SFE_UBLOX_GNSS_ID_IMES,
-	SFE_UBLOX_GNSS_ID_QZSS,
-	SFE_UBLOX_GNSS_ID_GLONASS
-};
-
-#ifndef MAX_PAYLOAD_SIZE
-// v2.0: keep this for backwards-compatibility, but this is largely superseded by setPacketCfgPayloadSize
-#define MAX_PAYLOAD_SIZE 256 //We need ~220 bytes for getProtocolVersion on most ublox modules
-//#define MAX_PAYLOAD_SIZE 768 //Worst case: UBX_CFG_VALSET packet with 64 keyIDs each with 64 bit values
-#endif
-
-//-=-=-=-=- UBX binary specific variables
-struct ubxPacket
-{
-	uint8_t cls;
-	uint8_t id;
-	uint16_t len; //Length of the payload. Does not include cls, id, or checksum bytes
-	uint16_t counter; //Keeps track of number of overall bytes received. Some responses are larger than 255 bytes.
-	uint16_t startingSpot; //The counter value needed to go past before we begin recording into payload array
-	uint8_t *payload; // We will allocate RAM for the payload if/when needed.
-	uint8_t checksumA; //Given to us from module. Checked against the rolling calculated A/B checksums.
-	uint8_t checksumB;
-	sfe_ublox_packet_validity_e valid;			 //Goes from NOT_DEFINED to VALID or NOT_VALID when checksum is checked
-	sfe_ublox_packet_validity_e classAndIDmatch; // Goes from NOT_DEFINED to VALID or NOT_VALID when the Class and ID match the requestedClass and requestedID
-};
-
-// Struct to hold the results returned by getGeofenceState (returned by UBX-NAV-GEOFENCE)
-typedef struct
-{
-	uint8_t status;	   // Geofencing status: 0 - Geofencing not available or not reliable; 1 - Geofencing active
-	uint8_t numFences; // Number of geofences
-	uint8_t combState; // Combined (logical OR) state of all geofences: 0 - Unknown; 1 - Inside; 2 - Outside
-	uint8_t states[4]; // Geofence states: 0 - Unknown; 1 - Inside; 2 - Outside
-} geofenceState;
-
-// Struct to hold the current geofence parameters
-typedef struct
-{
-	uint8_t numFences; // Number of active geofences
-	int32_t lats[4];   // Latitudes of geofences (in degrees * 10^-7)
-	int32_t longs[4];  // Longitudes of geofences (in degrees * 10^-7)
-	uint32_t rads[4];  // Radii of geofences (in m * 10^-2)
-} geofenceParams_t;
-
-// Struct to hold the module software version
-typedef struct
-{
-	uint8_t versionLow;		 //Loaded from getProtocolVersion().
-	uint8_t versionHigh;
-	bool moduleQueried;
-} moduleSWVersion_t;
-
-const uint16_t DAYS_SINCE_MONTH[4][16] = 
-{
-    {   0,   0,  31,  60,  91, 121, 152, 182, 213, 244, 274, 305, 335, 335, 335, 335 },
-    {   0,   0,  31,  59,  90, 120, 151, 181, 212, 243, 273, 304, 334, 334, 334, 334 },
-    {   0,   0,  31,  59,  90, 120, 151, 181, 212, 243, 273, 304, 334, 334, 334, 334 },
-    {   0,   0,  31,  59,  90, 120, 151, 181, 212, 243, 273, 304, 334, 334, 334, 334 },
-};
-
-class SFE_UBLOX_GNSS
-{
-public:
-	SFE_UBLOX_GNSS(void);
-
-// A default of 250ms for maxWait seems fine for I2C but is not enough for SerialUSB.
-// If you know you are only going to be using I2C / Qwiic communication, you can
-// safely reduce defaultMaxWait to 250.
-#ifndef defaultMaxWait // Let's allow the user to define their own value if they want to
-#define defaultMaxWait 1100
-#endif
-
-	//New in v2.0: allow the payload size for packetCfg to be changed
-	void setPacketCfgPayloadSize(size_t payloadSize); // Set packetCfgPayloadSize
-
-	//By default use the default I2C address, and use Wire port
-	boolean begin(TwoWire &wirePort = Wire, uint8_t deviceAddress = 0x42); //Returns true if module is detected
-	//serialPort needs to be perviously initialized to correct baud rate
-	boolean begin(Stream &serialPort); //Returns true if module is detected
-
-	void end(void); //Stop all automatic message processing. Free all used RAM
-
-	void setI2CpollingWait(uint8_t newPollingWait_ms); // Allow the user to change the I2C polling wait if required
-
-	//Control the size of the internal I2C transaction amount
-	void setI2CTransactionSize(uint8_t bufferSize);
-	uint8_t getI2CTransactionSize(void);
-
-	//Set the max number of bytes set in a given I2C transaction
-	uint8_t i2cTransactionSize = 32; //Default to ATmega328 limit
-
-	//Returns true if device answers on _gpsI2Caddress address or via Serial
-	boolean isConnected(uint16_t maxWait = 1100);
-
-	// Enable debug messages using the chosen Serial port (Stream)
-	// Boards like the RedBoard Turbo use SerialUSB (not Serial).
-	// But other boards like the SAMD51 Thing Plus use Serial (not SerialUSB).
-	// These lines let the code compile cleanly on as many SAMD boards as possible.
-	#if defined(ARDUINO_ARCH_SAMD)	// Is this a SAMD board?
-	#if defined(USB_VID)						// Is the USB Vendor ID defined?
-	#if (USB_VID == 0x1B4F)					// Is this a SparkFun board?
-	#if !defined(ARDUINO_SAMD51_THING_PLUS) & !defined(ARDUINO_SAMD51_MICROMOD) // If it is not a SAMD51 Thing Plus or SAMD51 MicroMod
-	void enableDebugging(Stream &debugPort = SerialUSB, boolean printLimitedDebug = false); //Given a port to print to, enable debug messages. Default to all, not limited.
-	#else
-	void enableDebugging(Stream &debugPort = Serial, boolean printLimitedDebug = false); //Given a port to print to, enable debug messages. Default to all, not limited.
-	#endif
-	#else
-	void enableDebugging(Stream &debugPort = Serial, boolean printLimitedDebug = false); //Given a port to print to, enable debug messages. Default to all, not limited.
-	#endif
-	#else
-	void enableDebugging(Stream &debugPort = Serial, boolean printLimitedDebug = false); //Given a port to print to, enable debug messages. Default to all, not limited.
-	#endif
-	#else
-	void enableDebugging(Stream &debugPort = Serial, boolean printLimitedDebug = false); //Given a port to print to, enable debug messages. Default to all, not limited.
-	#endif
-
-	void disableDebugging(void); //Turn off debug statements
-	void debugPrint(char *message); //Safely print debug statements
-	void debugPrintln(char *message); //Safely print debug statements
-	const char *statusString(sfe_ublox_status_e stat); //Pretty print the return value
-
-	// Check for the arrival of new I2C/Serial data
-
-	void disableUBX7Fcheck(boolean disabled = true); // When logging RAWX data, we need to be able to disable the "7F" check in checkUbloxI2C
-
-	//Changed in V1.8.1: provides backward compatibility for the examples that call checkUblox directly
-	//Will default to using packetCfg to look for explicit autoPVT packets so they get processed correctly by processUBX
-	boolean checkUblox(uint8_t requestedClass = 0, uint8_t requestedID = 0); //Checks module with user selected commType
-
-	boolean checkUbloxI2C(ubxPacket *incomingUBX, uint8_t requestedClass, uint8_t requestedID);	   //Method for I2C polling of data, passing any new bytes to process()
-	boolean checkUbloxSerial(ubxPacket *incomingUBX, uint8_t requestedClass, uint8_t requestedID); //Method for serial polling of data, passing any new bytes to process()
-
-	// Process the incoming data
-
-	void process(uint8_t incoming, ubxPacket *incomingUBX, uint8_t requestedClass, uint8_t requestedID);	//Processes NMEA and UBX binary sentences one byte at a time
-	void processNMEA(char incoming) __attribute__((weak)); //Given a NMEA character, do something with it. User can overwrite if desired to use something like tinyGPS or MicroNMEA libraries
-	void processRTCMframe(uint8_t incoming); //Monitor the incoming bytes for start and length bytes
-	void processRTCM(uint8_t incoming) __attribute__((weak)); //Given rtcm byte, do something with it. User can overwrite if desired to pipe bytes to radio, internet, etc.
-	void processUBX(uint8_t incoming, ubxPacket *incomingUBX, uint8_t requestedClass, uint8_t requestedID); //Given a character, file it away into the uxb packet structure
-	void processUBXpacket(ubxPacket *msg); //Once a packet has been received and validated, identify this packet's class/id and update internal flags
-
-	// Send I2C/Serial commands to the module
-
-	void calcChecksum(ubxPacket *msg); //Sets the checksumA and checksumB of a given messages
-	sfe_ublox_status_e sendCommand(ubxPacket *outgoingUBX, uint16_t maxWait = defaultMaxWait, boolean expectACKonly = false); //Given a packet and payload, send everything including CRC bytes, return true if we got a response
-	sfe_ublox_status_e sendI2cCommand(ubxPacket *outgoingUBX, uint16_t maxWait = defaultMaxWait);
-	void sendSerialCommand(ubxPacket *outgoingUBX);
-
-	void printPacket(ubxPacket *packet, boolean alwaysPrintPayload = false); //Useful for debugging
-
-	// After sending a message to the module, wait for the expected response (data+ACK or just data)
-
-	sfe_ublox_status_e waitForACKResponse(ubxPacket *outgoingUBX, uint8_t requestedClass, uint8_t requestedID, uint16_t maxTime = defaultMaxWait);	 //Poll the module until a config packet and an ACK is received, or just an ACK
-	sfe_ublox_status_e waitForNoACKResponse(ubxPacket *outgoingUBX, uint8_t requestedClass, uint8_t requestedID, uint16_t maxTime = defaultMaxWait); //Poll the module until a config packet is received
-
-	// Check if any callbacks need to be called
-	void checkCallbacks(void);
-
-	// Push (e.g.) RTCM data directly to the module
-	// Warning: this function does not check that the data is valid. It is the user's responsibility to ensure the data is valid before pushing.
-	boolean pushRawData(uint8_t *dataBytes, size_t numDataBytes);
-
-	// Support for data logging
-	void setFileBufferSize(uint16_t bufferSize); // Set the size of the file buffer. This must be called _before_ .begin.
-	uint16_t getFileBufferSize(void); // Return the size of the file buffer
-	uint16_t extractFileBufferData(uint8_t *destination, uint16_t numBytes); // Extract numBytes of data from the file buffer. Copy it to destination. It is the user's responsibility to ensure destination is large enough.
-	uint16_t fileBufferAvailable(void);		// Returns the number of bytes available in file buffer which are waiting to be read
-	uint16_t getMaxFileBufferAvail(void);	// Returns the maximum number of bytes which the file buffer has contained. Handy for checking the buffer is large enough to handle all the incoming data.
-	void clearFileBuffer(void);				// Empty the file buffer - discard all contents
-	void clearMaxFileBufferAvail(void);		// Reset fileBufferMaxAvail
-
-	// Specific commands
-
-	//Port configurations
-	boolean getPortSettings(uint8_t portID, uint16_t maxWait = defaultMaxWait);					   //Returns the current protocol bits in the UBX-CFG-PRT command for a given port
-	boolean setPortOutput(uint8_t portID, uint8_t comSettings, uint16_t maxWait = defaultMaxWait); //Configure a given port to output UBX, NMEA, RTCM3 or a combination thereof
-	boolean setPortInput(uint8_t portID, uint8_t comSettings, uint16_t maxWait = defaultMaxWait);  //Configure a given port to input UBX, NMEA, RTCM3 or a combination thereof
-
-	boolean setI2CAddress(uint8_t deviceAddress, uint16_t maxTime = defaultMaxWait);										 //Changes the I2C address of the u-blox module
-	void setSerialRate(uint32_t baudrate, uint8_t uartPort = COM_PORT_UART1, uint16_t maxTime = defaultMaxWait); //Changes the serial baud rate of the u-blox module, uartPort should be COM_PORT_UART1/2
-
-	boolean setI2COutput(uint8_t comSettings, uint16_t maxWait = defaultMaxWait);				//Configure I2C port to output UBX, NMEA, RTCM3 or a combination thereof
-	boolean setUART1Output(uint8_t comSettings, uint16_t maxWait = defaultMaxWait); //Configure UART1 port to output UBX, NMEA, RTCM3 or a combination thereof
-	boolean setUART2Output(uint8_t comSettings, uint16_t maxWait = defaultMaxWait); //Configure UART2 port to output UBX, NMEA, RTCM3 or a combination thereof
-	boolean setUSBOutput(uint8_t comSettings, uint16_t maxWait = defaultMaxWait);				//Configure USB port to output UBX, NMEA, RTCM3 or a combination thereof
-	boolean setSPIOutput(uint8_t comSettings, uint16_t maxWait = defaultMaxWait);				//Configure SPI port to output UBX, NMEA, RTCM3 or a combination thereof
-	void setNMEAOutputPort(Stream &nmeaOutputPort);																 //Sets the internal variable for the port to direct NMEA characters to
-
-	//Reset to defaults
-
-	void factoryReset(); //Send factory reset sequence (i.e. load "default" configuration and perform hardReset)
-	void hardReset();	 //Perform a reset leading to a cold start (zero info start-up)
-	boolean factoryDefault(uint16_t maxWait = defaultMaxWait);							 //Reset module to factory defaults
-
-	//Save configuration to BBR / Flash
-
-	boolean saveConfiguration(uint16_t maxWait = defaultMaxWait);						 //Save current configuration to flash and BBR (battery backed RAM)
-	boolean saveConfigSelective(uint32_t configMask, uint16_t maxWait = defaultMaxWait); //Save the selected configuration sub-sections to flash and BBR (battery backed RAM)
-
-	//Functions to turn on/off message types for a given port ID (see COM_PORT_I2C, etc above)
-	boolean configureMessage(uint8_t msgClass, uint8_t msgID, uint8_t portID, uint8_t sendRate, uint16_t maxWait = defaultMaxWait);
-	boolean enableMessage(uint8_t msgClass, uint8_t msgID, uint8_t portID, uint8_t sendRate = 1, uint16_t maxWait = defaultMaxWait);
-	boolean disableMessage(uint8_t msgClass, uint8_t msgID, uint8_t portID, uint16_t maxWait = defaultMaxWait);
-	boolean enableNMEAMessage(uint8_t msgID, uint8_t portID, uint8_t sendRate = 1, uint16_t maxWait = defaultMaxWait);
-	boolean disableNMEAMessage(uint8_t msgID, uint8_t portID, uint16_t maxWait = defaultMaxWait);
-	boolean enableRTCMmessage(uint8_t messageNumber, uint8_t portID, uint8_t sendRate, uint16_t maxWait = defaultMaxWait); //Given a message number turns on a message ID for output over given PortID
-	boolean disableRTCMmessage(uint8_t messageNumber, uint8_t portID, uint16_t maxWait = defaultMaxWait); //Turn off given RTCM message from a given port
-
-	//Functions used for RTK and base station setup
-	//It is probably safe to assume that users of the RTK will be using I2C / Qwiic. So let's leave maxWait set to 250ms.
-	boolean getSurveyMode(uint16_t maxWait = 250); //Get the current TimeMode3 settings
-	boolean setSurveyMode(uint8_t mode, uint16_t observationTime, float requiredAccuracy, uint16_t maxWait = 250); //Control survey in mode
-	boolean enableSurveyMode(uint16_t observationTime, float requiredAccuracy, uint16_t maxWait = 250); //Begin Survey-In for NEO-M8P
-	boolean disableSurveyMode(uint16_t maxWait = 250); //Stop Survey-In mode
-	// Given coordinates, put receiver into static position. Set latlong to true to pass in lat/long values instead of ecef.
-	// For ECEF the units are: cm, 0.1mm, cm, 0.1mm, cm, 0.1mm
-	// For Lat/Lon/Alt the units are: degrees^-7, degrees^-9, degrees^-7, degrees^-9, cm, 0.1mm
-	bool setStaticPosition(int32_t ecefXOrLat, int8_t ecefXOrLatHP, int32_t ecefYOrLon, int8_t ecefYOrLonHP, int32_t ecefZOrAlt, int8_t ecefZOrAltHP, bool latLong = false, uint16_t maxWait = 250);
-	bool setStaticPosition(int32_t ecefXOrLat, int32_t ecefYOrLon, int32_t ecefZOrAlt, bool latLong = false, uint16_t maxWait = 250);
-
-	//Read the module's protocol version
-	uint8_t getProtocolVersionHigh(uint16_t maxWait = defaultMaxWait); //Returns the PROTVER XX.00 from UBX-MON-VER register
-	uint8_t getProtocolVersionLow(uint16_t maxWait = defaultMaxWait);	//Returns the PROTVER 00.XX from UBX-MON-VER register
-	boolean getProtocolVersion(uint16_t maxWait = defaultMaxWait);		//Queries module, loads low/high bytes
-	moduleSWVersion_t *moduleSWVersion = NULL; // Pointer to struct. RAM will be allocated for this if/when necessary
-
-	//Support for geofences
-	boolean addGeofence(int32_t latitude, int32_t longitude, uint32_t radius, byte confidence = 0, byte pinPolarity = 0, byte pin = 0, uint16_t maxWait = defaultMaxWait); // Add a new geofence
-	boolean clearGeofences(uint16_t maxWait = defaultMaxWait); //Clears all geofences
-	boolean clearAntPIO(uint16_t maxWait = defaultMaxWait); //Clears the antenna control pin settings to release the PIOs
-	boolean getGeofenceState(geofenceState &currentGeofenceState, uint16_t maxWait = defaultMaxWait); //Returns the combined geofence state
-	// Storage for the geofence parameters. RAM is allocated for this if/when required.
-	geofenceParams_t *currentGeofenceParams = NULL; // Pointer to struct. RAM will be allocated for this if/when necessary
-
-	//Power save / off
-	boolean powerSaveMode(bool power_save = true, uint16_t maxWait = defaultMaxWait);
-	uint8_t getPowerSaveMode(uint16_t maxWait = defaultMaxWait); // Returns 255 if the sendCommand fails
-	boolean powerOff(uint32_t durationInMs, uint16_t maxWait = defaultMaxWait);
-	boolean powerOffWithInterrupt(uint32_t durationInMs, uint32_t wakeupSources = VAL_RXM_PMREQ_WAKEUPSOURCE_EXTINT0, boolean forceWhileUsb = true, uint16_t maxWait = 1100);
-
-	//Change the dynamic platform model using UBX-CFG-NAV5
-	boolean setDynamicModel(dynModel newDynamicModel = DYN_MODEL_PORTABLE, uint16_t maxWait = defaultMaxWait);
-	uint8_t getDynamicModel(uint16_t maxWait = defaultMaxWait); // Get the dynamic model - returns 255 if the sendCommand fails
-
-	//Reset the odometer
-	boolean resetOdometer(uint16_t maxWait = defaultMaxWait); // Reset the odometer
-
-	//Enable/Disable individual GNSS systems using UBX-CFG-GNSS
-	//Note: you must leave at least one major GNSS enabled! If in doubt, enable GPS before disabling the others
-	//TO DO: Add support for sigCfgMask and maxTrkCh. (Need to resolve ambiguity with maxWait)
-	boolean enableGNSS(boolean enable, sfe_ublox_gnss_ids_e id, uint16_t maxWait = defaultMaxWait);
-	boolean isGNSSenabled(sfe_ublox_gnss_ids_e id, uint16_t maxWait = defaultMaxWait);
-
-	//Reset ESF automatic IMU-mount alignment
-	boolean resetIMUalignment(uint16_t maxWait = defaultMaxWait);
-
-	//Configure Time Pulse Parameters
-	boolean getTimePulseParameters(UBX_CFG_TP5_data_t *data = NULL, uint16_t maxWait = defaultMaxWait); // Get the time pulse parameters using UBX_CFG_TP5
-	boolean setTimePulseParameters(UBX_CFG_TP5_data_t *data = NULL, uint16_t maxWait = defaultMaxWait); // Set the time pulse parameters using UBX_CFG_TP5
-
-	//General configuration (used only on protocol v27 and higher - ie, ZED-F9P)
-
-	//It is probably safe to assume that users of the ZED-F9P will be using I2C / Qwiic.
-	//If they are using Serial then the higher baud rate will also help. So let's leave maxWait set to 250ms.
-	uint32_t createKey(uint16_t group, uint16_t id, uint8_t size); //Form 32-bit key from group/id/size
-	sfe_ublox_status_e getVal(uint32_t keyID, uint8_t layer = VAL_LAYER_RAM, uint16_t maxWait = 250);					 //Load payload with response
-	uint8_t getVal8(uint32_t keyID, uint8_t layer = VAL_LAYER_RAM, uint16_t maxWait = 250);								 //Returns the value at a given key location
-	uint16_t getVal16(uint32_t keyID, uint8_t layer = VAL_LAYER_RAM, uint16_t maxWait = 250);							 //Returns the value at a given key location
-	uint32_t getVal32(uint32_t keyID, uint8_t layer = VAL_LAYER_RAM, uint16_t maxWait = 250);							 //Returns the value at a given key location
-	uint8_t getVal8(uint16_t group, uint16_t id, uint8_t size, uint8_t layer = VAL_LAYER_RAM, uint16_t maxWait = 250);	 //Returns the value at a given group/id/size location
-	uint16_t getVal16(uint16_t group, uint16_t id, uint8_t size, uint8_t layer = VAL_LAYER_RAM, uint16_t maxWait = 250); //Returns the value at a given group/id/size location
-	uint32_t getVal32(uint16_t group, uint16_t id, uint8_t size, uint8_t layer = VAL_LAYER_RAM, uint16_t maxWait = 250); //Returns the value at a given group/id/size location
-	uint8_t setVal(uint32_t keyID, uint16_t value, uint8_t layer = VAL_LAYER_ALL, uint16_t maxWait = 250);				 //Sets the 16-bit value at a given group/id/size location
-	uint8_t setVal8(uint32_t keyID, uint8_t value, uint8_t layer = VAL_LAYER_ALL, uint16_t maxWait = 250);				 //Sets the 8-bit value at a given group/id/size location
-	uint8_t setVal16(uint32_t keyID, uint16_t value, uint8_t layer = VAL_LAYER_ALL, uint16_t maxWait = 250);			 //Sets the 16-bit value at a given group/id/size location
-	uint8_t setVal32(uint32_t keyID, uint32_t value, uint8_t layer = VAL_LAYER_ALL, uint16_t maxWait = 250);			 //Sets the 32-bit value at a given group/id/size location
-	uint8_t newCfgValset8(uint32_t keyID, uint8_t value, uint8_t layer = VAL_LAYER_ALL);								 //Define a new UBX-CFG-VALSET with the given KeyID and 8-bit value
-	uint8_t newCfgValset16(uint32_t keyID, uint16_t value, uint8_t layer = VAL_LAYER_ALL);								 //Define a new UBX-CFG-VALSET with the given KeyID and 16-bit value
-	uint8_t newCfgValset32(uint32_t keyID, uint32_t value, uint8_t layer = VAL_LAYER_ALL);								 //Define a new UBX-CFG-VALSET with the given KeyID and 32-bit value
-	uint8_t addCfgValset8(uint32_t keyID, uint8_t value);																 //Add a new KeyID and 8-bit value to an existing UBX-CFG-VALSET ubxPacket
-	uint8_t addCfgValset16(uint32_t keyID, uint16_t value);																 //Add a new KeyID and 16-bit value to an existing UBX-CFG-VALSET ubxPacket
-	uint8_t addCfgValset32(uint32_t keyID, uint32_t value);																 //Add a new KeyID and 32-bit value to an existing UBX-CFG-VALSET ubxPacket
-	uint8_t sendCfgValset8(uint32_t keyID, uint8_t value, uint16_t maxWait = 250);										 //Add the final KeyID and 8-bit value to an existing UBX-CFG-VALSET ubxPacket and send it
-	uint8_t sendCfgValset16(uint32_t keyID, uint16_t value, uint16_t maxWait = 250);									 //Add the final KeyID and 16-bit value to an existing UBX-CFG-VALSET ubxPacket and send it
-	uint8_t sendCfgValset32(uint32_t keyID, uint32_t value, uint16_t maxWait = 250);									 //Add the final KeyID and 32-bit value to an existing UBX-CFG-VALSET ubxPacket and send it
-
-// getPVT will only return data once in each navigation cycle. By default, that is once per second.
-// Therefore we should set defaultMaxWait to slightly longer than that.
-// If you change the navigation frequency to (e.g.) 4Hz using setNavigationFrequency(4)
-// then you should use a shorter maxWait. 300msec would be about right: getPVT(300)
-
-	// get and set functions for all of the "automatic" message processing
-
-	// Navigation (NAV)
-
-	boolean getNAVPOSECEF(uint16_t maxWait = defaultMaxWait); // NAV POSECEF
-	boolean setAutoNAVPOSECEF(boolean enabled, uint16_t maxWait = defaultMaxWait);  //Enable/disable automatic POSECEF reports at the navigation frequency
-	boolean setAutoNAVPOSECEF(boolean enabled, boolean implicitUpdate, uint16_t maxWait = defaultMaxWait); //Enable/disable automatic POSECEF reports at the navigation frequency, with implicitUpdate == false accessing stale data will not issue parsing of data in the rxbuffer of your interface, instead you have to call checkUblox when you want to perform an update
-	boolean setAutoNAVPOSECEFrate(uint8_t rate, boolean implicitUpdate = true, uint16_t maxWait = defaultMaxWait); //Set the rate for automatic POSECEF reports
-	boolean setAutoNAVPOSECEFcallback(void (*callbackPointer)(UBX_NAV_POSECEF_data_t), uint16_t maxWait = defaultMaxWait); //Enable automatic POSECEF reports at the navigation frequency. Data is accessed from the callback.
-	boolean assumeAutoNAVPOSECEF(boolean enabled, boolean implicitUpdate = true); //In case no config access to the GPS is possible and POSECEF is send cyclically already
-	void flushNAVPOSECEF(); //Mark all the data as read/stale
-	void logNAVPOSECEF(boolean enabled = true); // Log data to file buffer
-
-	boolean getNAVSTATUS(uint16_t maxWait = defaultMaxWait); // NAV STATUS
-	boolean setAutoNAVSTATUS(boolean enabled, uint16_t maxWait = defaultMaxWait);  //Enable/disable automatic STATUS reports at the navigation frequency
-	boolean setAutoNAVSTATUS(boolean enabled, boolean implicitUpdate, uint16_t maxWait = defaultMaxWait); //Enable/disable automatic STATUS reports at the navigation frequency, with implicitUpdate == false accessing stale data will not issue parsing of data in the rxbuffer of your interface, instead you have to call checkUblox when you want to perform an update
-	boolean setAutoNAVSTATUSrate(uint8_t rate, boolean implicitUpdate = true, uint16_t maxWait = defaultMaxWait); //Set the rate for automatic STATUS reports
-	boolean setAutoNAVSTATUScallback(void (*callbackPointer)(UBX_NAV_STATUS_data_t), uint16_t maxWait = defaultMaxWait); //Enable automatic STATUS reports at the navigation frequency. Data is accessed from the callback.
-	boolean assumeAutoNAVSTATUS(boolean enabled, boolean implicitUpdate = true); //In case no config access to the GPS is possible and STATUS is send cyclically already
-	void flushNAVSTATUS(); //Mark all the data as read/stale
-	void logNAVSTATUS(boolean enabled = true); // Log data to file buffer
-
-	boolean getDOP(uint16_t maxWait = defaultMaxWait); //Query module for latest dilution of precision values and load global vars:. If autoDOP is disabled, performs an explicit poll and waits, if enabled does not block. Returns true if new DOP is available.
-	boolean setAutoDOP(boolean enabled, uint16_t maxWait = defaultMaxWait);  //Enable/disable automatic DOP reports at the navigation frequency
-	boolean setAutoDOP(boolean enabled, boolean implicitUpdate, uint16_t maxWait = defaultMaxWait); //Enable/disable automatic DOP reports at the navigation frequency, with implicitUpdate == false accessing stale data will not issue parsing of data in the rxbuffer of your interface, instead you have to call checkUblox when you want to perform an update
-	boolean setAutoDOPrate(uint8_t rate, boolean implicitUpdate = true, uint16_t maxWait = defaultMaxWait); //Set the rate for automatic DOP reports
-	boolean setAutoDOPcallback(void (*callbackPointer)(UBX_NAV_DOP_data_t), uint16_t maxWait = defaultMaxWait); //Enable automatic DOP reports at the navigation frequency. Data is accessed from the callback.
-	boolean assumeAutoDOP(boolean enabled, boolean implicitUpdate = true); //In case no config access to the GPS is possible and DOP is send cyclically already
-	void flushDOP(); //Mark all the DOP data as read/stale
-	void logNAVDOP(boolean enabled = true); // Log data to file buffer
-
-	boolean getVehAtt(uint16_t maxWait = defaultMaxWait); // NAV ATT Helper
-	boolean getNAVATT(uint16_t maxWait = defaultMaxWait); // NAV ATT
-	boolean setAutoNAVATT(boolean enabled, uint16_t maxWait = defaultMaxWait);  //Enable/disable automatic vehicle attitude reports at the navigation frequency
-	boolean setAutoNAVATT(boolean enabled, boolean implicitUpdate, uint16_t maxWait = defaultMaxWait); //Enable/disable automatic vehicle attitude reports at the navigation frequency, with implicitUpdate == false accessing stale data will not issue parsing of data in the rxbuffer of your interface, instead you have to call checkUblox when you want to perform an update
-	boolean setAutoNAVATTrate(uint8_t rate, boolean implicitUpdate = true, uint16_t maxWait = defaultMaxWait); //Set the rate for automatic ATT reports
-	boolean setAutoNAVATTcallback(void (*callbackPointer)(UBX_NAV_ATT_data_t), uint16_t maxWait = defaultMaxWait); //Enable automatic ATT reports at the navigation frequency. Data is accessed from the callback.
-	boolean assumeAutoNAVATT(boolean enabled, boolean implicitUpdate = true); //In case no config access to the GPS is possible and vehicle attitude is send cyclically already
-	void flushNAVATT(); //Mark all the data as read/stale
-	void logNAVATT(boolean enabled = true); // Log data to file buffer
-
-	boolean getPVT(uint16_t maxWait = defaultMaxWait);	//Query module for latest group of datums and load global vars: lat, long, alt, speed, SIV, accuracies, etc. If autoPVT is disabled, performs an explicit poll and waits, if enabled does not block. Returns true if new PVT is available.
-	boolean setAutoPVT(boolean enabled, uint16_t maxWait = defaultMaxWait); //Enable/disable automatic PVT reports at the navigation frequency
-	boolean setAutoPVT(boolean enabled, boolean implicitUpdate, uint16_t maxWait = defaultMaxWait); //Enable/disable automatic PVT reports at the navigation frequency, with implicitUpdate == false accessing stale data will not issue parsing of data in the rxbuffer of your interface, instead you have to call checkUblox when you want to perform an update
-	boolean setAutoPVTrate(uint8_t rate, boolean implicitUpdate = true, uint16_t maxWait = defaultMaxWait); //Set the rate for automatic PVT reports
-	boolean setAutoPVTcallback(void (*callbackPointer)(UBX_NAV_PVT_data_t), uint16_t maxWait = defaultMaxWait); //Enable automatic PVT reports at the navigation frequency. Data is accessed from the callback.
-	boolean assumeAutoPVT(boolean enabled, boolean implicitUpdate = true); //In case no config access to the GPS is possible and PVT is send cyclically already
-	void flushPVT(); //Mark all the PVT data as read/stale
-	void logNAVPVT(boolean enabled = true); // Log data to file buffer
-
-	boolean getNAVODO(uint16_t maxWait = defaultMaxWait); // NAV ODO
-	boolean setAutoNAVODO(boolean enabled, uint16_t maxWait = defaultMaxWait);  //Enable/disable automatic ODO reports at the navigation frequency
-	boolean setAutoNAVODO(boolean enabled, boolean implicitUpdate, uint16_t maxWait = defaultMaxWait); //Enable/disable automatic ODO reports at the navigation frequency, with implicitUpdate == false accessing stale data will not issue parsing of data in the rxbuffer of your interface, instead you have to call checkUblox when you want to perform an update
-	boolean setAutoNAVODOrate(uint8_t rate, boolean implicitUpdate = true, uint16_t maxWait = defaultMaxWait); //Set the rate for automatic ODO reports
-	boolean setAutoNAVODOcallback(void (*callbackPointer)(UBX_NAV_ODO_data_t), uint16_t maxWait = defaultMaxWait); //Enable automatic ODO reports at the navigation frequency. Data is accessed from the callback.
-	boolean assumeAutoNAVODO(boolean enabled, boolean implicitUpdate = true); //In case no config access to the GPS is possible and ODO is send cyclically already
-	void flushNAVODO(); //Mark all the data as read/stale
-	void logNAVODO(boolean enabled = true); // Log data to file buffer
-
-	boolean getNAVVELECEF(uint16_t maxWait = defaultMaxWait); // NAV VELECEF
-	boolean setAutoNAVVELECEF(boolean enabled, uint16_t maxWait = defaultMaxWait);  //Enable/disable automatic VELECEF reports at the navigation frequency
-	boolean setAutoNAVVELECEF(boolean enabled, boolean implicitUpdate, uint16_t maxWait = defaultMaxWait); //Enable/disable automatic VELECEF reports at the navigation frequency, with implicitUpdate == false accessing stale data will not issue parsing of data in the rxbuffer of your interface, instead you have to call checkUblox when you want to perform an update
-	boolean setAutoNAVVELECEFrate(uint8_t rate, boolean implicitUpdate = true, uint16_t maxWait = defaultMaxWait); //Set the rate for automatic VELECEF reports
-	boolean setAutoNAVVELECEFcallback(void (*callbackPointer)(UBX_NAV_VELECEF_data_t), uint16_t maxWait = defaultMaxWait); //Enable automatic VELECEF reports at the navigation frequency. Data is accessed from the callback.
-	boolean assumeAutoNAVVELECEF(boolean enabled, boolean implicitUpdate = true); //In case no config access to the GPS is possible and VELECEF is send cyclically already
-	void flushNAVVELECEF(); //Mark all the data as read/stale
-	void logNAVVELECEF(boolean enabled = true); // Log data to file buffer
-
-	boolean getNAVVELNED(uint16_t maxWait = defaultMaxWait); // NAV VELNED
-	boolean setAutoNAVVELNED(boolean enabled, uint16_t maxWait = defaultMaxWait);  //Enable/disable automatic VELNED reports at the navigation frequency
-	boolean setAutoNAVVELNED(boolean enabled, boolean implicitUpdate, uint16_t maxWait = defaultMaxWait); //Enable/disable automatic VELNED reports at the navigation frequency, with implicitUpdate == false accessing stale data will not issue parsing of data in the rxbuffer of your interface, instead you have to call checkUblox when you want to perform an update
-	boolean setAutoNAVVELNEDrate(uint8_t rate, boolean implicitUpdate = true, uint16_t maxWait = defaultMaxWait); //Set the rate for automatic VELNED reports
-	boolean setAutoNAVVELNEDcallback(void (*callbackPointer)(UBX_NAV_VELNED_data_t), uint16_t maxWait = defaultMaxWait); //Enable automatic VELNED reports at the navigation frequency. Data is accessed from the callback.
-	boolean assumeAutoNAVVELNED(boolean enabled, boolean implicitUpdate = true); //In case no config access to the GPS is possible and VELNED is send cyclically already
-	void flushNAVVELNED(); //Mark all the data as read/stale
-	void logNAVVELNED(boolean enabled = true); // Log data to file buffer
-
-	boolean getNAVHPPOSECEF(uint16_t maxWait = defaultMaxWait); // NAV HPPOSECEF
-	boolean setAutoNAVHPPOSECEF(boolean enabled, uint16_t maxWait = defaultMaxWait);  //Enable/disable automatic HPPOSECEF reports at the navigation frequency
-	boolean setAutoNAVHPPOSECEF(boolean enabled, boolean implicitUpdate, uint16_t maxWait = defaultMaxWait); //Enable/disable automatic HPPOSECEF reports at the navigation frequency, with implicitUpdate == false accessing stale data will not issue parsing of data in the rxbuffer of your interface, instead you have to call checkUblox when you want to perform an update
-	boolean setAutoNAVHPPOSECEFrate(uint8_t rate, boolean implicitUpdate = true, uint16_t maxWait = defaultMaxWait); //Set the rate for automatic HPPOSECEF reports
-	boolean setAutoNAVHPPOSECEFcallback(void (*callbackPointer)(UBX_NAV_HPPOSECEF_data_t), uint16_t maxWait = defaultMaxWait); //Enable automatic HPPOSECEF reports at the navigation frequency. Data is accessed from the callback.
-	boolean assumeAutoNAVHPPOSECEF(boolean enabled, boolean implicitUpdate = true); //In case no config access to the GPS is possible and HPPOSECEF is send cyclically already
-	void flushNAVHPPOSECEF(); //Mark all the data as read/stale
-	void logNAVHPPOSECEF(boolean enabled = true); // Log data to file buffer
-
-	boolean getHPPOSLLH(uint16_t maxWait = defaultMaxWait); //Query module for latest group of datums and load global vars: lat, long, alt, speed, SIV, accuracies, etc. If autoPVT is disabled, performs an explicit poll and waits, if enabled does not block. Returns true if new HPPOSLLH is available.
-	boolean setAutoHPPOSLLH(boolean enabled, uint16_t maxWait = defaultMaxWait); //Enable/disable automatic HPPOSLLH reports at the navigation frequency
-	boolean setAutoHPPOSLLH(boolean enabled, boolean implicitUpdate, uint16_t maxWait = defaultMaxWait); //Enable/disable automatic HPPOSLLH reports at the navigation frequency, with implicitUpdate == false accessing stale data will not issue parsing of data in the rxbuffer of your interface, instead you have to call checkUblox when you want to perform an update
-	boolean setAutoHPPOSLLHrate(uint8_t rate, boolean implicitUpdate = true, uint16_t maxWait = defaultMaxWait); //Set the rate for automatic HPPOSLLH reports
-	boolean setAutoHPPOSLLHcallback(void (*callbackPointer)(UBX_NAV_HPPOSLLH_data_t), uint16_t maxWait = defaultMaxWait); //Enable automatic HPPOSLLH reports at the navigation frequency. Data is accessed from the callback.
-	boolean assumeAutoHPPOSLLH(boolean enabled, boolean implicitUpdate = true); //In case no config access to the GPS is possible and HPPOSLLH is send cyclically already
-	void flushHPPOSLLH(); //Mark all the HPPPOSLLH data as read/stale. This is handy to get data alignment after CRC failure
-	void logNAVHPPOSLLH(boolean enabled = true); // Log data to file buffer
-
-	boolean getNAVCLOCK(uint16_t maxWait = defaultMaxWait); // NAV CLOCK
-	boolean setAutoNAVCLOCK(boolean enabled, uint16_t maxWait = defaultMaxWait);  //Enable/disable automatic clock reports at the navigation frequency
-	boolean setAutoNAVCLOCK(boolean enabled, boolean implicitUpdate, uint16_t maxWait = defaultMaxWait); //Enable/disable automatic clock reports at the navigation frequency, with implicitUpdate == false accessing stale data will not issue parsing of data in the rxbuffer of your interface, instead you have to call checkUblox when you want to perform an update
-	boolean setAutoNAVCLOCKrate(uint8_t rate, boolean implicitUpdate = true, uint16_t maxWait = defaultMaxWait); //Set the rate for automatic CLOCK reports
-	boolean setAutoNAVCLOCKcallback(void (*callbackPointer)(UBX_NAV_CLOCK_data_t), uint16_t maxWait = defaultMaxWait); //Enable automatic CLOCK reports at the navigation frequency. Data is accessed from the callback.
-	boolean assumeAutoNAVCLOCK(boolean enabled, boolean implicitUpdate = true); //In case no config access to the GPS is possible and clock is send cyclically already
-	void flushNAVCLOCK(); //Mark all the data as read/stale
-	void logNAVCLOCK(boolean enabled = true); // Log data to file buffer
-
-	// Add "auto" support for NAV SVIN - to avoid needing 'global' storage
-	boolean getSurveyStatus(uint16_t maxWait); //Reads survey in status
-
-	boolean getRELPOSNED(uint16_t maxWait = defaultMaxWait); //Get Relative Positioning Information of the NED frame
-	boolean setAutoRELPOSNED(boolean enabled, uint16_t maxWait = defaultMaxWait); //Enable/disable automatic RELPOSNED reports
-	boolean setAutoRELPOSNED(boolean enabled, boolean implicitUpdate, uint16_t maxWait = defaultMaxWait); //Enable/disable automatic RELPOSNED, with implicitUpdate == false accessing stale data will not issue parsing of data in the rxbuffer of your interface, instead you have to call checkUblox when you want to perform an update
-	boolean setAutoRELPOSNEDrate(uint8_t rate, boolean implicitUpdate = true, uint16_t maxWait = defaultMaxWait); //Set the rate for automatic RELPOSNEDreports
-	boolean setAutoRELPOSNEDcallback(void (*callbackPointer)(UBX_NAV_RELPOSNED_data_t), uint16_t maxWait = defaultMaxWait); //Enable automatic RELPOSNED reports at the navigation frequency. Data is accessed from the callback.
-	boolean assumeAutoRELPOSNED(boolean enabled, boolean implicitUpdate = true); //In case no config access to the GPS is possible and RELPOSNED is send cyclically already
-	void flushNAVRELPOSNED(); //Mark all the data as read/stale
-	void logNAVRELPOSNED(boolean enabled = true); // Log data to file buffer
-
-	// Receiver Manager Messages (RXM)
-
-	boolean getRXMSFRBX(uint16_t maxWait = defaultMaxWait); // RXM SFRBX
-	boolean setAutoRXMSFRBX(boolean enabled, uint16_t maxWait = defaultMaxWait);  //Enable/disable automatic RXM SFRBX reports at the navigation frequency
-	boolean setAutoRXMSFRBX(boolean enabled, boolean implicitUpdate, uint16_t maxWait = defaultMaxWait); //Enable/disable automatic RXM SFRBX reports at the navigation frequency, with implicitUpdate == false accessing stale data will not issue parsing of data in the rxbuffer of your interface, instead you have to call checkUblox when you want to perform an update
-	boolean setAutoRXMSFRBXrate(uint8_t rate, boolean implicitUpdate = true, uint16_t maxWait = defaultMaxWait); //Set the rate for automatic SFRBX reports
-	boolean setAutoRXMSFRBXcallback(void (*callbackPointer)(UBX_RXM_SFRBX_data_t), uint16_t maxWait = defaultMaxWait); //Enable automatic SFRBX reports at the navigation frequency. Data is accessed from the callback.
-	boolean assumeAutoRXMSFRBX(boolean enabled, boolean implicitUpdate = true); //In case no config access to the GPS is possible and RXM SFRBX is send cyclically already
-	void flushRXMSFRBX(); //Mark all the data as read/stale
-	void logRXMSFRBX(boolean enabled = true); // Log data to file buffer
-
-	boolean getRXMRAWX(uint16_t maxWait = defaultMaxWait); // RXM RAWX
-	boolean setAutoRXMRAWX(boolean enabled, uint16_t maxWait = defaultMaxWait);  //Enable/disable automatic RXM RAWX reports at the navigation frequency
-	boolean setAutoRXMRAWX(boolean enabled, boolean implicitUpdate, uint16_t maxWait = defaultMaxWait); //Enable/disable automatic RXM RAWX reports at the navigation frequency, with implicitUpdate == false accessing stale data will not issue parsing of data in the rxbuffer of your interface, instead you have to call checkUblox when you want to perform an update
-	boolean setAutoRXMRAWXrate(uint8_t rate, boolean implicitUpdate = true, uint16_t maxWait = defaultMaxWait); //Set the rate for automatic RAWX reports
-	boolean setAutoRXMRAWXcallback(void (*callbackPointer)(UBX_RXM_RAWX_data_t), uint16_t maxWait = defaultMaxWait); //Enable automatic RAWX reports at the navigation frequency. Data is accessed from the callback.
-	boolean assumeAutoRXMRAWX(boolean enabled, boolean implicitUpdate = true); //In case no config access to the GPS is possible and RXM RAWX is send cyclically already
-	void flushRXMRAWX(); //Mark all the data as read/stale
-	void logRXMRAWX(boolean enabled = true); // Log data to file buffer
-
-	// Configuration (CFG)
-
-	// Add "auto" support for CFG RATE - because we use it for isConnected (to stop it being mugged by other messages)
-	boolean getNavigationFrequencyInternal(uint16_t maxWait = defaultMaxWait); //Get the number of nav solutions sent per second currently being output by module
-
-	// Timing messages (TIM)
-
-	boolean getTIMTM2(uint16_t maxWait = defaultMaxWait); // TIM TM2
-	boolean setAutoTIMTM2(boolean enabled, uint16_t maxWait = defaultMaxWait);  //Enable/disable automatic TIM TM2 reports at the navigation frequency
-	boolean setAutoTIMTM2(boolean enabled, boolean implicitUpdate, uint16_t maxWait = defaultMaxWait); //Enable/disable automatic TIM TM2 reports at the navigation frequency, with implicitUpdate == false accessing stale data will not issue parsing of data in the rxbuffer of your interface, instead you have to call checkUblox when you want to perform an update
-	boolean setAutoTIMTM2rate(uint8_t rate, boolean implicitUpdate = true, uint16_t maxWait = defaultMaxWait); //Set the rate for automatic TIM TM2 reports
-	boolean setAutoTIMTM2callback(void (*callbackPointer)(UBX_TIM_TM2_data_t), uint16_t maxWait = defaultMaxWait); //Enable automatic TM2 reports at the navigation frequency. Data is accessed from the callback.
-	boolean assumeAutoTIMTM2(boolean enabled, boolean implicitUpdate = true); //In case no config access to the GPS is possible and TIM TM2 is send cyclically already
-	void flushTIMTM2(); //Mark all the data as read/stale
-	void logTIMTM2(boolean enabled = true); // Log data to file buffer
-
-	// Sensor fusion (dead reckoning) (ESF)
-
-	boolean getEsfAlignment(uint16_t maxWait = defaultMaxWait); // ESF ALG Helper
-	boolean getESFALG(uint16_t maxWait = defaultMaxWait); // ESF ALG
-	boolean setAutoESFALG(boolean enabled, uint16_t maxWait = defaultMaxWait); //Enable/disable automatic ESF ALG reports
-	boolean setAutoESFALG(boolean enabled, boolean implicitUpdate, uint16_t maxWait = defaultMaxWait); //Enable/disable automatic ESF ALG reports, with implicitUpdate == false accessing stale data will not issue parsing of data in the rxbuffer of your interface, instead you have to call checkUblox when you want to perform an update
-	boolean setAutoESFALGrate(uint8_t rate, boolean implicitUpdate = true, uint16_t maxWait = defaultMaxWait); //Set the rate for automatic ALG reports
-	boolean setAutoESFALGcallback(void (*callbackPointer)(UBX_ESF_ALG_data_t), uint16_t maxWait = defaultMaxWait); //Enable automatic ALG reports at the navigation frequency. Data is accessed from the callback.
-	boolean assumeAutoESFALG(boolean enabled, boolean implicitUpdate = true); //In case no config access to the GPS is possible and ESF ALG is send cyclically already
-	void flushESFALG(); //Mark all the data as read/stale
-	void logESFALG(boolean enabled = true); // Log data to file buffer
-
-	boolean getEsfInfo(uint16_t maxWait = defaultMaxWait); // ESF STATUS Helper
-	boolean getESFSTATUS(uint16_t maxWait = defaultMaxWait); // ESF STATUS
-	boolean setAutoESFSTATUS(boolean enabled, uint16_t maxWait = defaultMaxWait); //Enable/disable automatic ESF STATUS reports
-	boolean setAutoESFSTATUS(boolean enabled, boolean implicitUpdate, uint16_t maxWait = defaultMaxWait); //Enable/disable automatic ESF STATUS reports, with implicitUpdate == false accessing stale data will not issue parsing of data in the rxbuffer of your interface, instead you have to call checkUblox when you want to perform an update
-	boolean setAutoESFSTATUSrate(uint8_t rate, boolean implicitUpdate = true, uint16_t maxWait = defaultMaxWait); //Set the rate for automatic STATUS reports
-	boolean setAutoESFSTATUScallback(void (*callbackPointer)(UBX_ESF_STATUS_data_t), uint16_t maxWait = defaultMaxWait); //Enable automatic STATUS reports at the navigation frequency. Data is accessed from the callback.
-	boolean assumeAutoESFSTATUS(boolean enabled, boolean implicitUpdate = true); //In case no config access to the GPS is possible and ESF STATUS is send cyclically already
-	void flushESFSTATUS(); //Mark all the data as read/stale
-	void logESFSTATUS(boolean enabled = true); // Log data to file buffer
-
-	boolean getEsfIns(uint16_t maxWait = defaultMaxWait); // ESF INS Helper
-	boolean getESFINS(uint16_t maxWait = defaultMaxWait); // ESF INS
-	boolean setAutoESFINS(boolean enabled, uint16_t maxWait = defaultMaxWait); //Enable/disable automatic ESF INS reports
-	boolean setAutoESFINS(boolean enabled, boolean implicitUpdate, uint16_t maxWait = defaultMaxWait); //Enable/disable automatic ESF INS reports, with implicitUpdate == false accessing stale data will not issue parsing of data in the rxbuffer of your interface, instead you have to call checkUblox when you want to perform an update
-	boolean setAutoESFINSrate(uint8_t rate, boolean implicitUpdate = true, uint16_t maxWait = defaultMaxWait); //Set the rate for automatic INS reports
-	boolean setAutoESFINScallback(void (*callbackPointer)(UBX_ESF_INS_data_t), uint16_t maxWait = defaultMaxWait); //Enable automatic INS reports at the navigation frequency. Data is accessed from the callback.
-	boolean assumeAutoESFINS(boolean enabled, boolean implicitUpdate = true); //In case no config access to the GPS is possible and ESF INS is send cyclically already
-	void flushESFINS(); //Mark all the data as read/stale
-	void logESFINS(boolean enabled = true); // Log data to file buffer
-
-	boolean getEsfDataInfo(uint16_t maxWait = defaultMaxWait); // ESF MEAS Helper
-	boolean getESFMEAS(uint16_t maxWait = defaultMaxWait); // ESF MEAS
-	boolean setAutoESFMEAS(boolean enabled, uint16_t maxWait = defaultMaxWait); //Enable/disable automatic ESF MEAS reports
-	boolean setAutoESFMEAS(boolean enabled, boolean implicitUpdate, uint16_t maxWait = defaultMaxWait); //Enable/disable automatic ESF MEAS reports, with implicitUpdate == false accessing stale data will not issue parsing of data in the rxbuffer of your interface, instead you have to call checkUblox when you want to perform an update
-	boolean setAutoESFMEASrate(uint8_t rate, boolean implicitUpdate = true, uint16_t maxWait = defaultMaxWait); //Set the rate for automatic MEAS reports
-	boolean setAutoESFMEAScallback(void (*callbackPointer)(UBX_ESF_MEAS_data_t), uint16_t maxWait = defaultMaxWait); //Enable automatic MEAS reports at the navigation frequency. Data is accessed from the callback.
-	boolean assumeAutoESFMEAS(boolean enabled, boolean implicitUpdate = true); //In case no config access to the GPS is possible and ESF MEAS is send cyclically already
-	void flushESFMEAS(); //Mark all the data as read/stale
-	void logESFMEAS(boolean enabled = true); // Log data to file buffer
-
-	boolean getEsfRawDataInfo(uint16_t maxWait = defaultMaxWait); // ESF RAW Helper
-	boolean getESFRAW(uint16_t maxWait = defaultMaxWait); // ESF RAW
-	boolean setAutoESFRAW(boolean enabled, uint16_t maxWait = defaultMaxWait); //Enable/disable automatic ESF RAW reports
-	boolean setAutoESFRAW(boolean enabled, boolean implicitUpdate, uint16_t maxWait = defaultMaxWait); //Enable/disable automatic ESF RAW reports, with implicitUpdate == false accessing stale data will not issue parsing of data in the rxbuffer of your interface, instead you have to call checkUblox when you want to perform an update
-	boolean setAutoESFRAWrate(uint8_t rate, boolean implicitUpdate = true, uint16_t maxWait = defaultMaxWait); //Set the rate for automatic RAW reports
-	boolean setAutoESFRAWcallback(void (*callbackPointer)(UBX_ESF_RAW_data_t), uint16_t maxWait = defaultMaxWait); //Enable automatic RAW reports at the navigation frequency. Data is accessed from the callback.
-	boolean assumeAutoESFRAW(boolean enabled, boolean implicitUpdate = true); //In case no config access to the GPS is possible and ESF RAW is send cyclically already
-	void flushESFRAW(); //Mark all the data as read/stale
-	void logESFRAW(boolean enabled = true); // Log data to file buffer
-
-	// High navigation rate (HNR)
-
-	boolean getHNRAtt(uint16_t maxWait = defaultMaxWait); // HNR ATT Helper
-	boolean getHNRATT(uint16_t maxWait = defaultMaxWait); // Returns true if the get HNR attitude is successful
-	boolean setAutoHNRATT(boolean enabled, uint16_t maxWait = defaultMaxWait); //Enable/disable automatic HNR Attitude reports at the HNR rate
-	boolean setAutoHNRATT(boolean enabled, boolean implicitUpdate, uint16_t maxWait = defaultMaxWait); //Enable/disable automatic HNR Attitude reports at the HNR rate, with implicitUpdate == false accessing stale data will not issue parsing of data in the rxbuffer of your interface, instead you have to call checkUblox when you want to perform an update
-	boolean setAutoHNRATTrate(uint8_t rate, boolean implicitUpdate = true, uint16_t maxWait = defaultMaxWait); //Set the rate for automatic ATT reports
-	boolean setAutoHNRATTcallback(void (*callbackPointer)(UBX_HNR_ATT_data_t), uint16_t maxWait = defaultMaxWait); //Enable automatic ATT reports at the navigation frequency. Data is accessed from the callback.
-	boolean assumeAutoHNRATT(boolean enabled, boolean implicitUpdate = true); //In case no config access to the GPS is possible and HNR Attitude is send cyclically already
-	void flushHNRATT(); //Mark all the data as read/stale
-	void logHNRATT(boolean enabled = true); // Log data to file buffer
-
-	boolean getHNRDyn(uint16_t maxWait = defaultMaxWait); // HNR INS Helper
-	boolean getHNRINS(uint16_t maxWait = defaultMaxWait); // Returns true if the get HNR dynamics is successful
-	boolean setAutoHNRINS(boolean enabled, uint16_t maxWait = defaultMaxWait); //Enable/disable automatic HNR dynamics reports at the HNR rate
-	boolean setAutoHNRINS(boolean enabled, boolean implicitUpdate, uint16_t maxWait = defaultMaxWait); //Enable/disable automatic HNR dynamics reports at the HNR rate, with implicitUpdate == false accessing stale data will not issue parsing of data in the rxbuffer of your interface, instead you have to call checkUblox when you want to perform an update
-	boolean setAutoHNRINSrate(uint8_t rate, boolean implicitUpdate = true, uint16_t maxWait = defaultMaxWait); //Set the rate for automatic INS reports
-	boolean setAutoHNRINScallback(void (*callbackPointer)(UBX_HNR_INS_data_t), uint16_t maxWait = defaultMaxWait); //Enable automatic INS reports at the navigation frequency. Data is accessed from the callback.
-	boolean assumeAutoHNRINS(boolean enabled, boolean implicitUpdate = true); //In case no config access to the GPS is possible and HNR dynamics is send cyclically already
-	void flushHNRINS(); //Mark all the data as read/stale
-	void logHNRINS(boolean enabled = true); // Log data to file buffer
-
-	boolean getHNRPVT(uint16_t maxWait = defaultMaxWait); // Returns true if the get HNR PVT is successful
-	boolean setAutoHNRPVT(boolean enabled, uint16_t maxWait = defaultMaxWait); //Enable/disable automatic HNR PVT reports at the HNR rate
-	boolean setAutoHNRPVT(boolean enabled, boolean implicitUpdate, uint16_t maxWait = defaultMaxWait); //Enable/disable automatic HNR PVT reports at the HNR rate, with implicitUpdate == false accessing stale data will not issue parsing of data in the rxbuffer of your interface, instead you have to call checkUblox when you want to perform an update
-	boolean setAutoHNRPVTrate(uint8_t rate, boolean implicitUpdate = true, uint16_t maxWait = defaultMaxWait); //Set the rate for automatic PVT reports
-	boolean setAutoHNRPVTcallback(void (*callbackPointer)(UBX_HNR_PVT_data_t), uint16_t maxWait = defaultMaxWait); //Enable automatic PVT reports at the navigation frequency. Data is accessed from the callback.
-	boolean assumeAutoHNRPVT(boolean enabled, boolean implicitUpdate = true); //In case no config access to the GPS is possible and HNR PVT is send cyclically already
-	void flushHNRPVT(); //Mark all the data as read/stale
-	void logHNRPVT(boolean enabled = true); // Log data to file buffer
-
-	// Helper functions for CFG RATE
-
-	boolean setNavigationFrequency(uint8_t navFreq, uint16_t maxWait = defaultMaxWait);	//Set the number of nav solutions sent per second
-	uint8_t getNavigationFrequency(uint16_t maxWait = defaultMaxWait);					//Get the number of nav solutions sent per second currently being output by module
-	boolean setMeasurementRate(uint16_t rate, uint16_t maxWait = defaultMaxWait);		//Set the elapsed time between GNSS measurements in milliseconds, which defines the rate
-	uint16_t getMeasurementRate(uint16_t maxWait = defaultMaxWait);					 	//Return the elapsed time between GNSS measurements in milliseconds
-	boolean setNavigationRate(uint16_t rate, uint16_t maxWait = defaultMaxWait);		//Set the ratio between the number of measurements and the number of navigation solutions. Unit is cycles. Max is 127
-	uint16_t getNavigationRate(uint16_t maxWait = defaultMaxWait);					 	//Return the ratio between the number of measurements and the number of navigation solutions. Unit is cycles
-
-	// Helper functions for DOP
-
-	uint16_t getGeometricDOP(uint16_t maxWait = defaultMaxWait);
-	uint16_t getPositionDOP(uint16_t maxWait = defaultMaxWait);
-	uint16_t getTimeDOP(uint16_t maxWait = defaultMaxWait);
-	uint16_t getVerticalDOP(uint16_t maxWait = defaultMaxWait);
-	uint16_t getHorizontalDOP(uint16_t maxWait = defaultMaxWait);
-	uint16_t getNorthingDOP(uint16_t maxWait = defaultMaxWait);
-	uint16_t getEastingDOP(uint16_t maxWait = defaultMaxWait);
-
-	// Helper functions for ATT
-
-	float getATTroll(uint16_t maxWait = defaultMaxWait); // Returned as degrees
-	float getATTpitch(uint16_t maxWait = defaultMaxWait); // Returned as degrees
-	float getATTheading(uint16_t maxWait = defaultMaxWait); // Returned as degrees
-
-	// Helper functions for PVT
-
-	uint32_t getTimeOfWeek(uint16_t maxWait = defaultMaxWait);
-	uint16_t getYear(uint16_t maxWait = defaultMaxWait);
-	uint8_t getMonth(uint16_t maxWait = defaultMaxWait);
-	uint8_t getDay(uint16_t maxWait = defaultMaxWait);
-	uint8_t getHour(uint16_t maxWait = defaultMaxWait);
-	uint8_t getMinute(uint16_t maxWait = defaultMaxWait);
-	uint8_t getSecond(uint16_t maxWait = defaultMaxWait);
-	uint16_t getMillisecond(uint16_t maxWait = defaultMaxWait);
-	int32_t getNanosecond(uint16_t maxWait = defaultMaxWait);
-	uint32_t getUnixEpoch(uint16_t maxWait = defaultMaxWait);
-	uint32_t getUnixEpoch(uint32_t& microsecond, uint16_t maxWait = defaultMaxWait);
-
-	bool getDateValid(uint16_t maxWait = defaultMaxWait);
-	bool getTimeValid(uint16_t maxWait = defaultMaxWait);
-	bool getConfirmedDate(uint16_t maxWait = defaultMaxWait);
-	bool getConfirmedTime(uint16_t maxWait = defaultMaxWait);
-
-	uint8_t getFixType(uint16_t maxWait = defaultMaxWait); //Returns the type of fix: 0=no, 3=3D, 4=GNSS+Deadreckoning
-
-	bool getGnssFixOk(uint16_t maxWait = defaultMaxWait); //Get whether we have a valid fix (i.e within DOP & accuracy masks)
-	bool getDiffSoln(uint16_t maxWait = defaultMaxWait); //Get whether differential corrections were applied
-	bool getHeadVehValid(uint16_t maxWait = defaultMaxWait);
-	uint8_t getCarrierSolutionType(uint16_t maxWait = defaultMaxWait); //Returns RTK solution: 0=no, 1=float solution, 2=fixed solution
-
-	uint8_t getSIV(uint16_t maxWait = defaultMaxWait); //Returns number of sats used in fix
-	int32_t getLongitude(uint16_t maxWait = defaultMaxWait); //Returns the current longitude in degrees * 10-7. Auto selects between HighPrecision and Regular depending on ability of module.
-	int32_t getLatitude(uint16_t maxWait = defaultMaxWait); //Returns the current latitude in degrees * 10^-7. Auto selects between HighPrecision and Regular depending on ability of module.
-	int32_t getAltitude(uint16_t maxWait = defaultMaxWait); //Returns the current altitude in mm above ellipsoid
-	int32_t getAltitudeMSL(uint16_t maxWait = defaultMaxWait); //Returns the current altitude in mm above mean sea level
-	int32_t getHorizontalAccEst(uint16_t maxWait = defaultMaxWait);
-	int32_t getVerticalAccEst(uint16_t maxWait = defaultMaxWait);
-	int32_t getNedNorthVel(uint16_t maxWait = defaultMaxWait);
-	int32_t getNedEastVel(uint16_t maxWait = defaultMaxWait);
-	int32_t getNedDownVel(uint16_t maxWait = defaultMaxWait);
-	int32_t getGroundSpeed(uint16_t maxWait = defaultMaxWait); //Returns speed in mm/s
-	int32_t getHeading(uint16_t maxWait = defaultMaxWait); //Returns heading in degrees * 10^-5
-	uint32_t getSpeedAccEst(uint16_t maxWait = defaultMaxWait);
-	uint32_t getHeadingAccEst(uint16_t maxWait = defaultMaxWait);
-	uint16_t getPDOP(uint16_t maxWait = defaultMaxWait); //Returns positional dillution of precision * 10^-2 (dimensionless)
-
-	bool getInvalidLlh(uint16_t maxWait = defaultMaxWait);
-
-	int32_t getHeadVeh(uint16_t maxWait = defaultMaxWait);
-	int16_t getMagDec(uint16_t maxWait = defaultMaxWait);
-	uint16_t getMagAcc(uint16_t maxWait = defaultMaxWait);
-
-	int32_t getGeoidSeparation(uint16_t maxWait = defaultMaxWait);
-
-	// Helper functions for HPPOSECEF
-
-	uint32_t getPositionAccuracy(uint16_t maxWait = 1100); //Returns the 3D accuracy of the current high-precision fix, in mm. Supported on NEO-M8P, ZED-F9P,
-
-	// Helper functions for HPPOSLLH
-
-	uint32_t getTimeOfWeekFromHPPOSLLH(uint16_t maxWait = defaultMaxWait);
-	int32_t getHighResLongitude(uint16_t maxWait = defaultMaxWait);
-	int32_t getHighResLatitude(uint16_t maxWait = defaultMaxWait);
-	int32_t getElipsoid(uint16_t maxWait = defaultMaxWait);
-	int32_t getMeanSeaLevel(uint16_t maxWait = defaultMaxWait);
-	int8_t getHighResLongitudeHp(uint16_t maxWait = defaultMaxWait);
-	int8_t getHighResLatitudeHp(uint16_t maxWait = defaultMaxWait);
-	int8_t getElipsoidHp(uint16_t maxWait = defaultMaxWait);
-	int8_t getMeanSeaLevelHp(uint16_t maxWait = defaultMaxWait);
-	uint32_t getHorizontalAccuracy(uint16_t maxWait = defaultMaxWait);
-	uint32_t getVerticalAccuracy(uint16_t maxWait = defaultMaxWait);
-
-	// Helper functions for SVIN
-
-	boolean getSurveyInActive(uint16_t maxWait = defaultMaxWait);
-	boolean getSurveyInValid(uint16_t maxWait = defaultMaxWait);
-	uint16_t getSurveyInObservationTime(uint16_t maxWait = defaultMaxWait); // Truncated to 65535 seconds
-	float getSurveyInMeanAccuracy(uint16_t maxWait = defaultMaxWait); // Returned as m
-
-	// Helper functions for RELPOSNED
-
-	float getRelPosN(uint16_t maxWait = defaultMaxWait); // Returned as m
-	float getRelPosE(uint16_t maxWait = defaultMaxWait); // Returned as m
-	float getRelPosD(uint16_t maxWait = defaultMaxWait); // Returned as m
-	float getRelPosAccN(uint16_t maxWait = defaultMaxWait); // Returned as m
-	float getRelPosAccE(uint16_t maxWait = defaultMaxWait); // Returned as m
-	float getRelPosAccD(uint16_t maxWait = defaultMaxWait); // Returned as m
-
-	// Helper functions for ESF
-
-	float getESFroll(uint16_t maxWait = defaultMaxWait); // Returned as degrees
-	float getESFpitch(uint16_t maxWait = defaultMaxWait); // Returned as degrees
-	float getESFyaw(uint16_t maxWait = defaultMaxWait); // Returned as degrees
-	boolean getSensorFusionMeasurement(UBX_ESF_MEAS_sensorData_t *sensorData, uint8_t sensor, uint16_t maxWait = defaultMaxWait);
-	boolean getSensorFusionMeasurement(UBX_ESF_MEAS_sensorData_t *sensorData, UBX_ESF_MEAS_data_t ubxDataStruct, uint8_t sensor);
-	boolean getRawSensorMeasurement(UBX_ESF_RAW_sensorData_t *sensorData, uint8_t sensor, uint16_t maxWait = defaultMaxWait);
-	boolean getRawSensorMeasurement(UBX_ESF_RAW_sensorData_t *sensorData, UBX_ESF_RAW_data_t ubxDataStruct, uint8_t sensor);
-	boolean getSensorFusionStatus(UBX_ESF_STATUS_sensorStatus_t *sensorStatus, uint8_t sensor, uint16_t maxWait = defaultMaxWait);
-	boolean getSensorFusionStatus(UBX_ESF_STATUS_sensorStatus_t *sensorStatus, UBX_ESF_STATUS_data_t ubxDataStruct, uint8_t sensor);
-
-	// Helper functions for HNR
-
-	boolean setHNRNavigationRate(uint8_t rate, uint16_t maxWait = 1100); // Returns true if the setHNRNavigationRate is successful
-	uint8_t getHNRNavigationRate(uint16_t maxWait = 1100); // Returns 0 if the getHNRNavigationRate fails
-	float getHNRroll(uint16_t maxWait = defaultMaxWait); // Returned as degrees
-	float getHNRpitch(uint16_t maxWait = defaultMaxWait); // Returned as degrees
-	float getHNRheading(uint16_t maxWait = defaultMaxWait); // Returned as degrees
-
-	// Functions to extract signed and unsigned 8/16/32-bit data from a ubxPacket
-	// From v2.0: These are public. The user can call these to extract data from custom packets
-	uint32_t extractLong(ubxPacket *msg, uint8_t spotToStart); //Combine four bytes from payload into long
-	int32_t extractSignedLong(ubxPacket *msg, uint8_t spotToStart); //Combine four bytes from payload into signed long (avoiding any ambiguity caused by casting)
-	uint16_t extractInt(ubxPacket *msg, uint8_t spotToStart); //Combine two bytes from payload into int
-	int16_t extractSignedInt(ubxPacket *msg, int8_t spotToStart);
-	uint8_t extractByte(ubxPacket *msg, uint8_t spotToStart); //Get byte from payload
-	int8_t extractSignedChar(ubxPacket *msg, uint8_t spotToStart); //Get signed 8-bit value from payload
-
-	// Pointers to storage for the "automatic" messages
-	// RAM is allocated for these if/when required.
-
-	UBX_NAV_POSECEF_t *packetUBXNAVPOSECEF = NULL; // Pointer to struct. RAM will be allocated for this if/when necessary
-	UBX_NAV_STATUS_t *packetUBXNAVSTATUS = NULL; // Pointer to struct. RAM will be allocated for this if/when necessary
-	UBX_NAV_DOP_t *packetUBXNAVDOP = NULL; // Pointer to struct. RAM will be allocated for this if/when necessary
-	UBX_NAV_ATT_t *packetUBXNAVATT = NULL; // Pointer to struct. RAM will be allocated for this if/when necessary
-	UBX_NAV_PVT_t *packetUBXNAVPVT = NULL; // Pointer to struct. RAM will be allocated for this if/when necessary
-	UBX_NAV_ODO_t *packetUBXNAVODO = NULL; // Pointer to struct. RAM will be allocated for this if/when necessary
-	UBX_NAV_VELECEF_t *packetUBXNAVVELECEF = NULL; // Pointer to struct. RAM will be allocated for this if/when necessary
-	UBX_NAV_VELNED_t *packetUBXNAVVELNED = NULL; // Pointer to struct. RAM will be allocated for this if/when necessary
-	UBX_NAV_HPPOSECEF_t *packetUBXNAVHPPOSECEF = NULL; // Pointer to struct. RAM will be allocated for this if/when necessary
-	UBX_NAV_HPPOSLLH_t *packetUBXNAVHPPOSLLH = NULL; // Pointer to struct. RAM will be allocated for this if/when necessary
-	UBX_NAV_CLOCK_t *packetUBXNAVCLOCK = NULL; // Pointer to struct. RAM will be allocated for this if/when necessary
-	UBX_NAV_SVIN_t *packetUBXNAVSVIN = NULL; // Pointer to struct. RAM will be allocated for this if/when necessary
-	UBX_NAV_RELPOSNED_t *packetUBXNAVRELPOSNED = NULL; // Pointer to struct. RAM will be allocated for this if/when necessary
-
-	UBX_RXM_SFRBX_t *packetUBXRXMSFRBX = NULL; // Pointer to struct. RAM will be allocated for this if/when necessary
-	UBX_RXM_RAWX_t *packetUBXRXMRAWX = NULL; // Pointer to struct. RAM will be allocated for this if/when necessary
-
-	UBX_CFG_RATE_t *packetUBXCFGRATE = NULL; // Pointer to struct. RAM will be allocated for this if/when necessary
-
-	UBX_TIM_TM2_t *packetUBXTIMTM2 = NULL; // Pointer to struct. RAM will be allocated for this if/when necessary
-
-	UBX_ESF_ALG_t *packetUBXESFALG = NULL; // Pointer to struct. RAM will be allocated for this if/when necessary
-	UBX_ESF_INS_t *packetUBXESFINS = NULL; // Pointer to struct. RAM will be allocated for this if/when necessary
-	UBX_ESF_MEAS_t *packetUBXESFMEAS = NULL; // Pointer to struct. RAM will be allocated for this if/when necessary
-	UBX_ESF_RAW_t *packetUBXESFRAW = NULL; // Pointer to struct. RAM will be allocated for this if/when necessary
-	UBX_ESF_STATUS_t *packetUBXESFSTATUS = NULL; // Pointer to struct. RAM will be allocated for this if/when necessary
-
-	UBX_HNR_PVT_t *packetUBXHNRPVT = NULL; // Pointer to struct. RAM will be allocated for this if/when necessary
-	UBX_HNR_ATT_t *packetUBXHNRATT = NULL; // Pointer to struct. RAM will be allocated for this if/when necessary
-	UBX_HNR_INS_t *packetUBXHNRINS = NULL; // Pointer to struct. RAM will be allocated for this if/when necessary
-
-	uint16_t rtcmFrameCounter = 0; //Tracks the type of incoming byte inside RTCM frame
-
-private:
-	//Depending on the sentence type the processor will load characters into different arrays
-	enum SentenceTypes
-	{
-		NONE = 0,
-		NMEA,
-		UBX,
-		RTCM
-	} currentSentence = NONE;
-
-	//Depending on the ubx binary response class, store binary responses into different places
-	enum classTypes
-	{
-		CLASS_NONE = 0,
-		CLASS_ACK,
-		CLASS_NOT_AN_ACK
-	} ubxFrameClass = CLASS_NONE;
-
-	enum commTypes
-	{
-		COMM_TYPE_I2C = 0,
-		COMM_TYPE_SERIAL,
-		COMM_TYPE_SPI
-	} commType = COMM_TYPE_I2C; //Controls which port we look to for incoming bytes
-
-	//Functions
-	boolean checkUbloxInternal(ubxPacket *incomingUBX, uint8_t requestedClass = 255, uint8_t requestedID = 255); //Checks module with user selected commType
-	void addToChecksum(uint8_t incoming);																		 //Given an incoming byte, adjust rollingChecksumA/B
-
-	//Return true if this "automatic" message has storage allocated for it
-	boolean checkAutomatic(uint8_t Class, uint8_t ID);
-
-	//Calculate how much RAM is needed to store the payload for a given automatic message
-	uint16_t getMaxPayloadSize(uint8_t Class, uint8_t ID);
-
-	boolean initGeofenceParams(); // Allocate RAM for currentGeofenceParams and initialize it
-	boolean initModuleSWVersion(); // Allocate RAM for moduleSWVersion and initialize it
-
-	// The initPacket functions need to be private as they don't check if memory has already been allocated.
-	// Functions like setAutoNAVPOSECEF will check that memory has not been allocated before calling initPacket.
-	boolean initPacketUBXNAVPOSECEF(); // Allocate RAM for packetUBXNAVPOSECEF and initialize it
-	boolean initPacketUBXNAVSTATUS(); // Allocate RAM for packetUBXNAVSTATUS and initialize it
-	boolean initPacketUBXNAVDOP(); // Allocate RAM for packetUBXNAVDOP and initialize it
-	boolean initPacketUBXNAVATT(); // Allocate RAM for packetUBXNAVATT and initialize it
-	boolean initPacketUBXNAVPVT(); // Allocate RAM for packetUBXNAVPVT and initialize it
-	boolean initPacketUBXNAVODO(); // Allocate RAM for packetUBXNAVODO and initialize it
-	boolean initPacketUBXNAVVELECEF(); // Allocate RAM for packetUBXNAVVELECEF and initialize it
-	boolean initPacketUBXNAVVELNED(); // Allocate RAM for packetUBXNAVVELNED and initialize it
-	boolean initPacketUBXNAVHPPOSECEF(); // Allocate RAM for packetUBXNAVHPPOSECEF and initialize it
-	boolean initPacketUBXNAVHPPOSLLH(); // Allocate RAM for packetUBXNAVHPPOSLLH and initialize it
-	boolean initPacketUBXNAVCLOCK(); // Allocate RAM for packetUBXNAVCLOCK and initialize it
-	boolean initPacketUBXNAVSVIN(); // Allocate RAM for packetUBXNAVSVIN and initialize it
-	boolean initPacketUBXNAVRELPOSNED(); // Allocate RAM for packetUBXNAVRELPOSNED and initialize it
-	boolean initPacketUBXRXMSFRBX(); // Allocate RAM for packetUBXRXMSFRBX and initialize it
-	boolean initPacketUBXRXMRAWX(); // Allocate RAM for packetUBXRXMRAWX and initialize it
-	boolean initPacketUBXCFGRATE(); // Allocate RAM for packetUBXCFGRATE and initialize it
-	boolean initPacketUBXTIMTM2(); // Allocate RAM for packetUBXTIMTM2 and initialize it
-	boolean initPacketUBXESFALG(); // Allocate RAM for packetUBXESFALG and initialize it
-	boolean initPacketUBXESFSTATUS(); // Allocate RAM for packetUBXESFSTATUS and initialize it
-	boolean initPacketUBXESFINS(); // Allocate RAM for packetUBXESFINS and initialize it
-	boolean initPacketUBXESFMEAS(); // Allocate RAM for packetUBXESFMEAS and initialize it
-	boolean initPacketUBXESFRAW(); // Allocate RAM for packetUBXESFRAW and initialize it
-	boolean initPacketUBXHNRATT(); // Allocate RAM for packetUBXHNRATT and initialize it
-	boolean initPacketUBXHNRINS(); // Allocate RAM for packetUBXHNRINS and initialize it
-	boolean initPacketUBXHNRPVT(); // Allocate RAM for packetUBXHNRPVT and initialize it
-
-	//Variables
-	TwoWire *_i2cPort;				//The generic connection to user's chosen I2C hardware
-	Stream *_serialPort;			//The generic connection to user's chosen Serial hardware
-	Stream *_nmeaOutputPort = NULL; //The user can assign an output port to print NMEA sentences if they wish
-	Stream *_debugSerial;			//The stream to send debug messages to if enabled
-
-	uint8_t _gpsI2Caddress = 0x42; //Default 7-bit unshifted address of the ublox 6/7/8/M8/F9 series
-	//This can be changed using the ublox configuration software
-
-	boolean _printDebug = false;		//Flag to print the serial commands we are sending to the Serial port for debug
-	boolean _printLimitedDebug = false; //Flag to print limited debug messages. Useful for I2C debugging or high navigation rates
-
-	boolean ubx7FcheckDisabled = false; // Flag to indicate if the "7F" check should be ignored in checkUbloxI2C
-
-	//The packet buffers
-	//These are pointed at from within the ubxPacket
-	uint8_t payloadAck[2];				  // Holds the requested ACK/NACK
-	uint8_t payloadBuf[2];				  // Temporary buffer used to screen incoming packets or dump unrequested packets
-	size_t packetCfgPayloadSize = 0; // Size for the packetCfg payload. .begin will set this to MAX_PAYLOAD_SIZE if necessary. User can change with setPacketCfgPayloadSize
-	uint8_t *payloadCfg = NULL;
-	uint8_t *payloadAuto = NULL;
-
-	//Init the packet structures and init them with pointers to the payloadAck, payloadCfg, payloadBuf and payloadAuto arrays
-	ubxPacket packetAck = {0, 0, 0, 0, 0, payloadAck, 0, 0, SFE_UBLOX_PACKET_VALIDITY_NOT_DEFINED, SFE_UBLOX_PACKET_VALIDITY_NOT_DEFINED};
-	ubxPacket packetBuf = {0, 0, 0, 0, 0, payloadBuf, 0, 0, SFE_UBLOX_PACKET_VALIDITY_NOT_DEFINED, SFE_UBLOX_PACKET_VALIDITY_NOT_DEFINED};
-	ubxPacket packetCfg = {0, 0, 0, 0, 0, payloadCfg, 0, 0, SFE_UBLOX_PACKET_VALIDITY_NOT_DEFINED, SFE_UBLOX_PACKET_VALIDITY_NOT_DEFINED};
-	ubxPacket packetAuto = {0, 0, 0, 0, 0, payloadAuto, 0, 0, SFE_UBLOX_PACKET_VALIDITY_NOT_DEFINED, SFE_UBLOX_PACKET_VALIDITY_NOT_DEFINED};
-
-	//Flag if this packet is unrequested (and so should be ignored and not copied into packetCfg or packetAck)
-	boolean ignoreThisPayload = false;
-
-	//Identify which buffer is in use
-	//Data is stored in packetBuf until the requested class and ID can be validated
-	//If a match is seen, data is diverted into packetAck or packetCfg
-	//"Automatic" messages which have RAM allocated for them are diverted into packetAuto
-	sfe_ublox_packet_buffer_e activePacketBuffer = SFE_UBLOX_PACKET_PACKETBUF;
-
-	//Limit checking of new data to every X ms
-	//If we are expecting an update every X Hz then we should check every half that amount of time
-	//Otherwise we may block ourselves from seeing new data
-	uint8_t i2cPollingWait = 100; //Default to 100ms. Adjusted when user calls setNavigationFrequency() or setHNRNavigationRate() or setMeasurementRate()
-
-	unsigned long lastCheck = 0;
-
-	uint16_t ubxFrameCounter;			  //It counts all UBX frame. [Fixed header(2bytes), CLS(1byte), ID(1byte), length(2bytes), payload(x bytes), checksums(2bytes)]
-
-	uint8_t rollingChecksumA; //Rolls forward as we receive incoming bytes. Checked against the last two A/B checksum bytes
-	uint8_t rollingChecksumB; //Rolls forward as we receive incoming bytes. Checked against the last two A/B checksum bytes
-
-	uint16_t rtcmLen = 0;
-
-	// Flag to prevent reentry into checkCallbacks
-	// Prevent badness if the user accidentally calls checkCallbacks from inside a callback
-	volatile boolean checkCallbacksReentrant = false;
-
-	// Support for data logging
-	uint8_t *ubxFileBuffer = NULL; // Pointer to the file buffer. RAM is allocated for this if required in .begin
-	uint16_t fileBufferSize = 0; // The size of the file buffer. This can be changed by calling setFileBufferSize _before_ .begin
-	uint16_t fileBufferHead; // The incoming byte is written into the file buffer at this location
-	uint16_t fileBufferTail; // The next byte to be read from the buffer will be read from this location
-	uint16_t fileBufferMaxAvail = 0; // The maximum number of bytes the file buffer has contained. Handy for checking the buffer is large enough to handle all the incoming data.
-	boolean createFileBuffer(void); // Create the file buffer. Called by .begin
-	uint16_t fileBufferSpaceAvailable(void); // Check how much space is available in the buffer
-	uint16_t fileBufferSpaceUsed(void); // Check how much space is used in the buffer
-	boolean storePacket(ubxPacket *msg); // Add a UBX packet to the file buffer
-	boolean storeFileBytes(uint8_t *theBytes, uint16_t numBytes); // Add theBytes to the file buffer
-	void writeToFileBuffer(uint8_t *theBytes, uint16_t numBytes); // Write theBytes to the file buffer
-};
-
-#endif
diff --git a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/src/u-blox_config_keys.h b/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/src/u-blox_config_keys.h
deleted file mode 100644
index 9217d46..0000000
--- a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/src/u-blox_config_keys.h
+++ /dev/null
@@ -1,839 +0,0 @@
-/*
-	This is a library written for the u-blox ZED-F9P and NEO-M8P-2
-	SparkFun sells these at its website: www.sparkfun.com
-	Do you like this library? Help support SparkFun. Buy a board!
-	https://www.sparkfun.com/products/16481
-	https://www.sparkfun.com/products/15136
-	https://www.sparkfun.com/products/15005
-	https://www.sparkfun.com/products/15733
-	https://www.sparkfun.com/products/15193
-	https://www.sparkfun.com/products/15210
-
-  Original version by Nathan Seidle @ SparkFun Electronics, September 6th, 2018
-	v2.0 rework by Paul Clark @ SparkFun Electronics, December 31st, 2020
-
-	This library handles configuring and handling the responses
-	from a u-blox GPS module. Works with most modules from u-blox including
-	the Zed-F9P, NEO-M8P-2, NEO-M9N, ZOE-M8Q, SAM-M8Q, and many others.
-
-	https://github.com/sparkfun/SparkFun_Ublox_Arduino_Library
-
-	Development environment specifics:
-	Arduino IDE 1.8.13
-
-	SparkFun code, firmware, and software is released under the MIT License(http://opensource.org/licenses/MIT).
-	The MIT License (MIT)
-	Copyright (c) 2016 SparkFun Electronics
-	Permission is hereby granted, free of charge, to any person obtaining a copy of this software and
-	associated documentation files (the "Software"), to deal in the Software without restriction,
-	including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
-	and/or sell copies of the Software, and to permit persons to whom the Software is furnished to
-	do so, subject to the following conditions:
-
-	The above copyright notice and this permission notice shall be included in all copies or substantial
-	portions of the Software.
-
-	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT
-	NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
-	IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
-	WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
-	SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-*/
-
-#ifndef __u_blox_config_keys_h__
-#define __u_blox_config_keys_h__
-
-//The following consts are used to generate KEY values for the advanced protocol functions of VELGET/SET/DEL
-const uint8_t VAL_SIZE_1 = 0x01; //One bit
-const uint8_t VAL_SIZE_8 = 0x02;	 //One byte
-const uint8_t VAL_SIZE_16 = 0x03;	 //Two bytes
-const uint8_t VAL_SIZE_32 = 0x04;	 //Four bytes
-const uint8_t VAL_SIZE_64 = 0x05;	 //Eight bytes
-
-//These are the Bitfield layers definitions for the UBX-CFG-VALSET message (not to be confused with Bitfield deviceMask in UBX-CFG-CFG)
-const uint8_t VAL_LAYER_RAM = (1 << 0);
-const uint8_t VAL_LAYER_BBR = (1 << 1);
-const uint8_t VAL_LAYER_FLASH = (1 << 2);
-const uint8_t VAL_LAYER_ALL = VAL_LAYER_RAM | VAL_LAYER_BBR | VAL_LAYER_FLASH; //Not valid with getVal()
-
-//Below are various Groups, IDs, and sizes for various settings
-//These can be used to call getVal/setVal/delVal
-//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
-const uint8_t VAL_ID_PROT_UBX = 0x01;
-const uint8_t VAL_ID_PROT_NMEA = 0x02;
-const uint8_t VAL_ID_PROT_RTCM3 = 0x04;
-
-const uint8_t VAL_GROUP_I2C = 0x51;
-const uint8_t VAL_GROUP_I2COUTPROT = 0x72;
-const uint8_t VAL_GROUP_UART1INPROT = 0x73;
-const uint8_t VAL_GROUP_UART1OUTPROT = 0x74;
-const uint8_t VAL_GROUP_UART2INPROT = 0x75;
-const uint8_t VAL_GROUP_UART2OUTPROT = 0x76;
-const uint8_t VAL_GROUP_USBINPROT = 0x77;
-const uint8_t VAL_GROUP_USBOUTPROT = 0x78;
-
-const uint8_t VAL_GROUP_UART_SIZE = VAL_SIZE_1; //All fields in UART group are currently 1 bit
-const uint8_t VAL_GROUP_I2C_SIZE = VAL_SIZE_8;	//All fields in I2C group are currently 1 byte
-
-const uint8_t VAL_ID_I2C_ADDRESS = 0x01;
-
-//Below are the key values for a given configuration setting
-
-//CFG-BDS: BeiDou system configuration
-//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
-const uint32_t UBLOX_CFG_BDS_USE_PRN_1_TO_5 = 0x10340014; // Use BeiDou geostationary satellites (PRN 1-5)
-
-//CFG-GEOFENCE: Geofencing configuration
-//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
-const uint32_t UBLOX_CFG_GEOFENCE_CONFLVL = 0x20240011;	// Required confidence level for state evaluation
-const uint32_t UBLOX_CFG_GEOFENCE_USE_PIO = 0x10240012;	// Use PIO combined fence state output
-const uint32_t UBLOX_CFG_GEOFENCE_PINPOL = 0x20240013;	// PIO pin polarity
-const uint32_t UBLOX_CFG_GEOFENCE_PIN = 0x20240014;	// PIO pin number
-const uint32_t UBLOX_CFG_GEOFENCE_USE_FENCE1 = 0x10240020;	// Use frst geofence
-const uint32_t UBLOX_CFG_GEOFENCE_FENCE1_LAT = 0x40240021;	// Latitude of the first geofence circle center
-const uint32_t UBLOX_CFG_GEOFENCE_FENCE1_LON = 0x40240022;	// Longitude of the first geofence circle center
-const uint32_t UBLOX_CFG_GEOFENCE_FENCE1_RAD = 0x40240023;	// Radius of the first geofence circle
-const uint32_t UBLOX_CFG_GEOFENCE_USE_FENCE2 = 0x10240030;	// Use second geofence
-const uint32_t UBLOX_CFG_GEOFENCE_FENCE2_LAT = 0x40240031;	// Latitude of the second geofence circle center
-const uint32_t UBLOX_CFG_GEOFENCE_FENCE2_LON = 0x40240032;	// Longitude of the second geofence circle center
-const uint32_t UBLOX_CFG_GEOFENCE_FENCE2_RAD = 0x40240033;	// Radius of the second geofence circle
-const uint32_t UBLOX_CFG_GEOFENCE_USE_FENCE3 = 0x10240040;	// Use third geofence
-const uint32_t UBLOX_CFG_GEOFENCE_FENCE3_LAT = 0x40240041;	// Latitude of the third geofence circle center
-const uint32_t UBLOX_CFG_GEOFENCE_FENCE3_LON = 0x40240042;	// Longitude of the third geofence circle center
-const uint32_t UBLOX_CFG_GEOFENCE_FENCE3_RAD = 0x40240043;	// Radius of the third geofence circle
-const uint32_t UBLOX_CFG_GEOFENCE_USE_FENCE4 = 0x10240050;	// Use fourth geofence
-const uint32_t UBLOX_CFG_GEOFENCE_FENCE4_LAT = 0x40240051;	// Latitude of the fourth geofence circle center
-const uint32_t UBLOX_CFG_GEOFENCE_FENCE4_LON = 0x40240052;	// Longitude of the fourth geofence circle center
-const uint32_t UBLOX_CFG_GEOFENCE_FENCE4_RAD = 0x40240053;	// Radius of the fourth geofence circle
-
-//CFG-HW: Hardware configuration
-//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
-const uint32_t UBLOX_CFG_HW_ANT_CFG_VOLTCTRL = 0x10a3002e;	// Active antenna voltage control flag
-const uint32_t UBLOX_CFG_HW_ANT_CFG_SHORTDET = 0x10a3002f;	// Short antenna detection flag
-const uint32_t UBLOX_CFG_HW_ANT_CFG_SHORTDET_POL = 0x10a30030;	// Short antenna detection polarity
-const uint32_t UBLOX_CFG_HW_ANT_CFG_OPENDET = 0x10a30031;	// Open antenna detection flag
-const uint32_t UBLOX_CFG_HW_ANT_CFG_OPENDET_POL = 0x10a30032;	// Open antenna detection polarity
-const uint32_t UBLOX_CFG_HW_ANT_CFG_PWRDOWN = 0x10a30033;	// Power down antenna flag
-const uint32_t UBLOX_CFG_HW_ANT_CFG_PWRDOWN_POL = 0x10a30034;	// Power down antenna logic polarity
-const uint32_t UBLOX_CFG_HW_ANT_CFG_RECOVER = 0x10a30035;	// Automatic recovery from short state flag
-const uint32_t UBLOX_CFG_HW_ANT_SUP_SWITCH_PIN = 0x20a30036;	// ANT1 PIO number
-const uint32_t UBLOX_CFG_HW_ANT_SUP_SHORT_PIN = 0x20a30037;	// ANT0 PIO number
-const uint32_t UBLOX_CFG_HW_ANT_SUP_OPEN_PIN = 0x20a30038;	// ANT2 PIO number
-const uint32_t UBLOX_CFG_HW_ANT_SUP_ENGINE = 0x20a30054;	// Antenna supervisor engine selection
-const uint32_t UBLOX_CFG_HW_ANT_SUP_SHORT_THR = 0x20a30055;	// Antenna supervisor MADC engine short detection threshold
-const uint32_t UBLOX_CFG_HW_ANT_SUP_OPEN_THR = 0x20a30056;	// Antenna supervisor MADC engine open detection threshold
-
-//CFG-I2C: Configuration of the I2C interface
-//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
-const uint32_t UBLOX_CFG_I2C_ADDRESS = 0x20510001;	// I2C slave address of the receiver (7 bits)
-const uint32_t UBLOX_CFG_I2C_EXTENDEDTIMEOUT = 0x10510002;	// Flag to disable timeouting the interface after 1.5 s
-const uint32_t UBLOX_CFG_I2C_ENABLED = 0x10510003;	// Flag to indicate if the I2C interface should be enabled
-
-//CFG-I2CINPROT: Input protocol configuration of the I2C interface
-//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
-const uint32_t UBLOX_CFG_I2CINPROT_UBX = 0x10710001;	// Flag to indicate if UBX should be an input protocol on I2C
-const uint32_t UBLOX_CFG_I2CINPROT_NMEA = 0x10710002;	// Flag to indicate if NMEA should be an input protocol on I2C
-const uint32_t UBLOX_CFG_I2CINPROT_RTCM3X = 0x10710004;	// Flag to indicate if RTCM3X should be an input protocol on I2C
-
-//CFG-I2COUTPROT: Output protocol configuration of the I2C interface
-//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
-const uint32_t UBLOX_CFG_I2COUTPROT_UBX = 0x10720001;	// Flag to indicate if UBX should be an output protocol on I2C
-const uint32_t UBLOX_CFG_I2COUTPROT_NMEA = 0x10720002;	// Flag to indicate if NMEA should be an output protocol on I2C
-const uint32_t UBLOX_CFG_I2COUTPROT_RTCM3X = 0x10720004;	// Flag to indicate if RTCM3X should be an output protocol on I2C
-
-//CFG-INFMSG: Information message configuration
-//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
-const uint32_t UBLOX_CFG_INFMSG_UBX_I2C = 0x20920001;	// Information message enable flags for the UBX protocol on the I2C interface
-const uint32_t UBLOX_CFG_INFMSG_UBX_UART1 = 0x20920002;	// Information message enable flags for the UBX protocol on the UART1 interface
-const uint32_t UBLOX_CFG_INFMSG_UBX_UART2 = 0x20920003;	// Information message enable flags for the UBX protocol on the UART2 interface
-const uint32_t UBLOX_CFG_INFMSG_UBX_USB = 0x20920004;	// Information message enable flags for the UBX protocol on the USB interface
-const uint32_t UBLOX_CFG_INFMSG_UBX_SPI = 0x20920005;	// Information message enable flags for the UBX protocol on the SPI interface
-const uint32_t UBLOX_CFG_INFMSG_NMEA_I2C = 0x20920006;	// Information message enable flags for the NMEA protocol on the I2C interface
-const uint32_t UBLOX_CFG_INFMSG_NMEA_UART1 = 0x20920007;	// Information message enable flags for the NMEA protocol on the UART1 interface
-const uint32_t UBLOX_CFG_INFMSG_NMEA_UART2 = 0x20920008;	// Information message enable flags for the NMEA protocol on the UART2 interface
-const uint32_t UBLOX_CFG_INFMSG_NMEA_USB = 0x20920009;	// Information message enable flags for the NMEA protocol on the USB interface
-const uint32_t UBLOX_CFG_INFMSG_NMEA_SPI = 0x2092000a;	// Information message enable flags for the NMEA protocol on the SPI interface
-
-//CFG-ITFM: Jamming and interference monitor configuration
-//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
-const uint32_t UBLOX_CFG_ITFM_BBTHRESHOLD = 0x20410001;	// Broadband jamming detection threshold
-const uint32_t UBLOX_CFG_ITFM_CWTHRESHOLD = 0x20410002;	// CW jamming detection threshold
-const uint32_t UBLOX_CFG_ITFM_ENABLE = 0x1041000d;	// Enable interference detection
-const uint32_t UBLOX_CFG_ITFM_ANTSETTING = 0x20410010;	// Antenna setting
-const uint32_t UBLOX_CFG_ITFM_ENABLE_AUX = 0x10410013;	// Scan auxiliary bands
-
-//CFG-LOGFILTER: Data logger configuration
-//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
-const uint32_t UBLOX_CFG_LOGFILTER_RECORD_ENA = 0x10de0002;	// Recording enabled
-const uint32_t UBLOX_CFG_LOGFILTER_ONCE_PER_WAKE_UP_ENA = 0x10de0003;	// Once per wake up
-const uint32_t UBLOX_CFG_LOGFILTER_APPLY_ALL_FILTERS = 0x10de0004;	// Apply all filter settings
-const uint32_t UBLOX_CFG_LOGFILTER_MIN_INTERVAL = 0x30de0005;	// Minimum time interval between loggedpositions
-const uint32_t UBLOX_CFG_LOGFILTER_TIME_THRS = 0x30de0006;	// Time threshold
-const uint32_t UBLOX_CFG_LOGFILTER_SPEED_THRS = 0x30de0007;	// Speed threshold
-const uint32_t UBLOX_CFG_LOGFILTER_POSITION_THRS = 0x40de0008;	// Position threshold
-
-//CFG-MOT: Motion detector configuration
-//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
-const uint32_t UBLOX_CFG_MOT_GNSSSPEED_THRS = 0x20250038;	// GNSS speed threshold below which platform is considered as stationary (a.k.a. static hold threshold)
-const uint32_t UBLOX_CFG_MOT_GNSSDIST_THRS = 0x3025003b;	// Distance above which GNSS-based stationary motion is exit (a.k.a. static hold distance threshold)
-
-// CFG-MSGOUT: Message output configuration
-//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
-// For each message and port a separate output rate (per second, per epoch) can be configured.
-const uint32_t UBLOX_CFG_MSGOUT_NMEA_ID_DTM_I2C = 0x209100a6;				//Output rate of the NMEA-GX-DTM message on port I2C
-const uint32_t UBLOX_CFG_MSGOUT_NMEA_ID_DTM_SPI = 0x209100aa;				//Output rate of the NMEA-GX-DTM message on port SPI
-const uint32_t UBLOX_CFG_MSGOUT_NMEA_ID_DTM_UART1 = 0x209100a7;			//Output rate of the NMEA-GX-DTM message on port UART1
-const uint32_t UBLOX_CFG_MSGOUT_NMEA_ID_DTM_UART2 = 0x209100a8;			//Output rate of the NMEA-GX-DTM message on port UART2
-const uint32_t UBLOX_CFG_MSGOUT_NMEA_ID_DTM_USB = 0x209100a9;				//Output rate of the NMEA-GX-DTM message on port USB
-const uint32_t UBLOX_CFG_MSGOUT_NMEA_ID_GBS_I2C = 0x209100dd;				//Output rate of the NMEA-GX-GBS message on port I2C
-const uint32_t UBLOX_CFG_MSGOUT_NMEA_ID_GBS_SPI = 0x209100e1;				//Output rate of the NMEA-GX-GBS message on port SPI
-const uint32_t UBLOX_CFG_MSGOUT_NMEA_ID_GBS_UART1 = 0x209100de;			//Output rate of the NMEA-GX-GBS message on port UART1
-const uint32_t UBLOX_CFG_MSGOUT_NMEA_ID_GBS_UART2 = 0x209100df;			//Output rate of the NMEA-GX-GBS message on port UART2
-const uint32_t UBLOX_CFG_MSGOUT_NMEA_ID_GBS_USB = 0x209100e0;				//Output rate of the NMEA-GX-GBS message on port USB
-const uint32_t UBLOX_CFG_MSGOUT_NMEA_ID_GGA_I2C = 0x209100ba;				//Output rate of the NMEA-GX-GGA message on port I2C
-const uint32_t UBLOX_CFG_MSGOUT_NMEA_ID_GGA_SPI = 0x209100be;				//Output rate of the NMEA-GX-GGA message on port SPI
-const uint32_t UBLOX_CFG_MSGOUT_NMEA_ID_GGA_UART1 = 0x209100bb;			//Output rate of the NMEA-GX-GGA message on port UART1
-const uint32_t UBLOX_CFG_MSGOUT_NMEA_ID_GGA_UART2 = 0x209100bc;			//Output rate of the NMEA-GX-GGA message on port UART2
-const uint32_t UBLOX_CFG_MSGOUT_NMEA_ID_GGA_USB = 0x209100bd;				//Output rate of the NMEA-GX-GGA message on port USB
-const uint32_t UBLOX_CFG_MSGOUT_NMEA_ID_GLL_I2C = 0x209100c9;				//Output rate of the NMEA-GX-GLL message on port I2C
-const uint32_t UBLOX_CFG_MSGOUT_NMEA_ID_GLL_SPI = 0x209100cd;				//Output rate of the NMEA-GX-GLL message on port SPI
-const uint32_t UBLOX_CFG_MSGOUT_NMEA_ID_GLL_UART1 = 0x209100ca;			//Output rate of the NMEA-GX-GLL message on port UART1
-const uint32_t UBLOX_CFG_MSGOUT_NMEA_ID_GLL_UART2 = 0x209100cb;			//Output rate of the NMEA-GX-GLL message on port UART2
-const uint32_t UBLOX_CFG_MSGOUT_NMEA_ID_GLL_USB = 0x209100cc;				//Output rate of the NMEA-GX-GLL message on port USB
-const uint32_t UBLOX_CFG_MSGOUT_NMEA_ID_GNS_I2C = 0x209100b5;				//Output rate of the NMEA-GX-GNS message on port I2C
-const uint32_t UBLOX_CFG_MSGOUT_NMEA_ID_GNS_SPI = 0x209100b9;				//Output rate of the NMEA-GX-GNS message on port SPI
-const uint32_t UBLOX_CFG_MSGOUT_NMEA_ID_GNS_UART1 = 0x209100b6;			//Output rate of the NMEA-GX-GNS message on port UART1
-const uint32_t UBLOX_CFG_MSGOUT_NMEA_ID_GNS_UART2 = 0x209100b7;			//Output rate of the NMEA-GX-GNS message on port UART2
-const uint32_t UBLOX_CFG_MSGOUT_NMEA_ID_GNS_USB = 0x209100b8;				//Output rate of the NMEA-GX-GNS message on port USB
-const uint32_t UBLOX_CFG_MSGOUT_NMEA_ID_GRS_I2C = 0x209100ce;				//Output rate of the NMEA-GX-GRS message on port I2C
-const uint32_t UBLOX_CFG_MSGOUT_NMEA_ID_GRS_SPI = 0x209100d2;				//Output rate of the NMEA-GX-GRS message on port SPI
-const uint32_t UBLOX_CFG_MSGOUT_NMEA_ID_GRS_UART1 = 0x209100cf;			//Output rate of the NMEA-GX-GRS message on port UART1
-const uint32_t UBLOX_CFG_MSGOUT_NMEA_ID_GRS_UART2 = 0x209100d0;			//Output rate of the NMEA-GX-GRS message on port UART2
-const uint32_t UBLOX_CFG_MSGOUT_NMEA_ID_GRS_USB = 0x209100d1;				//Output rate of the NMEA-GX-GRS message on port USB
-const uint32_t UBLOX_CFG_MSGOUT_NMEA_ID_GSA_I2C = 0x209100bf;				//Output rate of the NMEA-GX-GSA message on port I2C
-const uint32_t UBLOX_CFG_MSGOUT_NMEA_ID_GSA_SPI = 0x209100c3;				//Output rate of the NMEA-GX-GSA message on port SPI
-const uint32_t UBLOX_CFG_MSGOUT_NMEA_ID_GSA_UART1 = 0x209100c0;			//Output rate of the NMEA-GX-GSA message on port UART1
-const uint32_t UBLOX_CFG_MSGOUT_NMEA_ID_GSA_UART2 = 0x209100c1;			//Output rate of the NMEA-GX-GSA message on port UART2
-const uint32_t UBLOX_CFG_MSGOUT_NMEA_ID_GSA_USB = 0x209100c2;				//Output rate of the NMEA-GX-GSA message on port USB
-const uint32_t UBLOX_CFG_MSGOUT_NMEA_ID_GST_I2C = 0x209100d3;				//Output rate of the NMEA-GX-GST message on port I2C
-const uint32_t UBLOX_CFG_MSGOUT_NMEA_ID_GST_SPI = 0x209100d7;				//Output rate of the NMEA-GX-GST message on port SPI
-const uint32_t UBLOX_CFG_MSGOUT_NMEA_ID_GST_UART1 = 0x209100d4;			//Output rate of the NMEA-GX-GST message on port UART1
-const uint32_t UBLOX_CFG_MSGOUT_NMEA_ID_GST_UART2 = 0x209100d5;			//Output rate of the NMEA-GX-GST message on port UART2
-const uint32_t UBLOX_CFG_MSGOUT_NMEA_ID_GST_USB = 0x209100d6;				//Output rate of the NMEA-GX-GST message on port USB
-const uint32_t UBLOX_CFG_MSGOUT_NMEA_ID_GSV_I2C = 0x209100c4;				//Output rate of the NMEA-GX-GSV message on port I2C
-const uint32_t UBLOX_CFG_MSGOUT_NMEA_ID_GSV_SPI = 0x209100c8;				//Output rate of the NMEA-GX-GSV message on port SPI
-const uint32_t UBLOX_CFG_MSGOUT_NMEA_ID_GSV_UART1 = 0x209100c5;			//Output rate of the NMEA-GX-GSV message on port UART1
-const uint32_t UBLOX_CFG_MSGOUT_NMEA_ID_GSV_UART2 = 0x209100c6;			//Output rate of the NMEA-GX-GSV message on port UART2
-const uint32_t UBLOX_CFG_MSGOUT_NMEA_ID_GSV_USB = 0x209100c7;				//Output rate of the NMEA-GX-GSV message on port USB
-const uint32_t UBLOX_CFG_MSGOUT_NMEA_ID_RLM_I2C = 0x20910400;				//Output rate of the NMEA-GX-RLM message on port I2C
-const uint32_t UBLOX_CFG_MSGOUT_NMEA_ID_RLM_SPI = 0x20910404;				//Output rate of the NMEA-GX-RLM message on port SPI
-const uint32_t UBLOX_CFG_MSGOUT_NMEA_ID_RLM_UART1 = 0x20910401;			//Output rate of the NMEA-GX-RLM message on port UART1
-const uint32_t UBLOX_CFG_MSGOUT_NMEA_ID_RLM_UART2 = 0x20910402;			//Output rate of the NMEA-GX-RLM message on port UART2
-const uint32_t UBLOX_CFG_MSGOUT_NMEA_ID_RLM_USB = 0x20910403;				//Output rate of the NMEA-GX-RLM message on port USB
-const uint32_t UBLOX_CFG_MSGOUT_NMEA_ID_RMC_I2C = 0x209100ab;				//Output rate of the NMEA-GX-RMC message on port I2C
-const uint32_t UBLOX_CFG_MSGOUT_NMEA_ID_RMC_SPI = 0x209100af;				//Output rate of the NMEA-GX-RMC message on port SPI
-const uint32_t UBLOX_CFG_MSGOUT_NMEA_ID_RMC_UART1 = 0x209100ac;			//Output rate of the NMEA-GX-RMC message on port UART1
-const uint32_t UBLOX_CFG_MSGOUT_NMEA_ID_RMC_UART2 = 0x209100ad;			//Output rate of the NMEA-GX-RMC message on port UART2
-const uint32_t UBLOX_CFG_MSGOUT_NMEA_ID_RMC_USB = 0x209100ae;				//Output rate of the NMEA-GX-RMC message on port USB
-const uint32_t UBLOX_CFG_MSGOUT_NMEA_ID_VLW_I2C = 0x209100e7;				//Output rate of the NMEA-GX-VLW message on port I2C
-const uint32_t UBLOX_CFG_MSGOUT_NMEA_ID_VLW_SPI = 0x209100eb;				//Output rate of the NMEA-GX-VLW message on port SPI
-const uint32_t UBLOX_CFG_MSGOUT_NMEA_ID_VLW_UART1 = 0x209100e8;			//Output rate of the NMEA-GX-VLW message on port UART1
-const uint32_t UBLOX_CFG_MSGOUT_NMEA_ID_VLW_UART2 = 0x209100e9;			//Output rate of the NMEA-GX-VLW message on port UART2
-const uint32_t UBLOX_CFG_MSGOUT_NMEA_ID_VLW_USB = 0x209100ea;				//Output rate of the NMEA-GX-VLW message on port USB
-const uint32_t UBLOX_CFG_MSGOUT_NMEA_ID_VTG_I2C = 0x209100b0;				//Output rate of the NMEA-GX-VTG message on port I2C
-const uint32_t UBLOX_CFG_MSGOUT_NMEA_ID_VTG_SPI = 0x209100b4;				//Output rate of the NMEA-GX-VTG message on port SPI
-const uint32_t UBLOX_CFG_MSGOUT_NMEA_ID_VTG_UART1 = 0x209100b1;			//Output rate of the NMEA-GX-VTG message on port UART1
-const uint32_t UBLOX_CFG_MSGOUT_NMEA_ID_VTG_UART2 = 0x209100b2;			//Output rate of the NMEA-GX-VTG message on port UART2
-const uint32_t UBLOX_CFG_MSGOUT_NMEA_ID_VTG_USB = 0x209100b3;				//Output rate of the NMEA-GX-VTG message on port USB
-const uint32_t UBLOX_CFG_MSGOUT_NMEA_ID_ZDA_I2C = 0x209100d8;				//Output rate of the NMEA-GX-ZDA message on port I2C
-const uint32_t UBLOX_CFG_MSGOUT_NMEA_ID_ZDA_SPI = 0x209100dc;				//Output rate of the NMEA-GX-ZDA message on port SPI
-const uint32_t UBLOX_CFG_MSGOUT_NMEA_ID_ZDA_UART1 = 0x209100d9;			//Output rate of the NMEA-GX-ZDA message on port UART1
-const uint32_t UBLOX_CFG_MSGOUT_NMEA_ID_ZDA_UART2 = 0x209100da;			//Output rate of the NMEA-GX-ZDA message on port UART2
-const uint32_t UBLOX_CFG_MSGOUT_NMEA_ID_ZDA_USB = 0x209100db;				//Output rate of the NMEA-GX-ZDA message on port USB
-const uint32_t UBLOX_CFG_MSGOUT_PUBX_ID_POLYP_I2C = 0x209100ec;			//Output rate of the NMEA-GX-PUBX00 message on port I2C
-const uint32_t UBLOX_CFG_MSGOUT_PUBX_ID_POLYP_SPI = 0x209100f0;			//Output rate of the NMEA-GX-PUBX00 message on port SPI
-const uint32_t UBLOX_CFG_MSGOUT_PUBX_ID_POLYP_UART1 = 0x209100ed;		//Output rate of the NMEA-GX-PUBX00 message on port UART1
-const uint32_t UBLOX_CFG_MSGOUT_PUBX_ID_POLYP_UART2 = 0x209100ee;	//Output rate of the NMEA-GX-PUBX00 message on port UART2
-const uint32_t UBLOX_CFG_MSGOUT_PUBX_ID_POLYP_USB = 0x209100ef;		//Output rate of the NMEA-GX-PUBX00 message on port USB
-const uint32_t UBLOX_CFG_MSGOUT_PUBX_ID_POLYS_I2C = 0x209100f1;			//Output rate of the NMEA-GX-PUBX03 message on port I2C
-const uint32_t UBLOX_CFG_MSGOUT_PUBX_ID_POLYS_SPI = 0x209100f5;			//Output rate of the NMEA-GX-PUBX03 message on port SPI
-const uint32_t UBLOX_CFG_MSGOUT_PUBX_ID_POLYS_UART1 = 0x209100f2;		//Output rate of the NMEA-GX-PUBX03 message on port UART1
-const uint32_t UBLOX_CFG_MSGOUT_PUBX_ID_POLYS_UART2 = 0x209100f3;	//Output rate of the NMEA-GX-PUBX03 message on port UART2
-const uint32_t UBLOX_CFG_MSGOUT_PUBX_ID_POLYS_USB = 0x209100f4;		//Output rate of the NMEA-GX-PUBX03 message on port USB
-const uint32_t UBLOX_CFG_MSGOUT_PUBX_ID_POLYT_I2C = 0x209100f6;			//Output rate of the NMEA-GX-PUBX04 message on port I2C
-const uint32_t UBLOX_CFG_MSGOUT_PUBX_ID_POLYT_SPI = 0x209100fa;			//Output rate of the NMEA-GX-PUBX04 message on port SPI
-const uint32_t UBLOX_CFG_MSGOUT_PUBX_ID_POLYT_UART1 = 0x209100f7;		//Output rate of the NMEA-GX-PUBX04 message on port UART1
-const uint32_t UBLOX_CFG_MSGOUT_PUBX_ID_POLYT_UART2 = 0x209100f8;	//Output rate of the NMEA-GX-PUBX04 message on port UART2
-const uint32_t UBLOX_CFG_MSGOUT_PUBX_ID_POLYT_USB = 0x209100f9;		//Output rate of the NMEA-GX-PUBX04 message on port USB
-const uint32_t UBLOX_CFG_MSGOUT_RTCM_3X_TYPE1005_I2C = 0x209102bd;		//Output rate of the RTCM-3X-TYPE1005 message on port I2C
-const uint32_t UBLOX_CFG_MSGOUT_RTCM_3X_TYPE1005_SPI = 0x209102c1;	//Output rate of the RTCM-3X-TYPE1005 message on port SPI
-const uint32_t UBLOX_CFG_MSGOUT_RTCM_3X_TYPE1005_UART1 = 0x209102be;//Output rate of the RTCM-3X-TYPE1005 message on port UART1
-const uint32_t UBLOX_CFG_MSGOUT_RTCM_3X_TYPE1005_UART2 = 0x209102bf;//Output rate of the RTCM-3X-TYPE1005 message on port UART2
-const uint32_t UBLOX_CFG_MSGOUT_RTCM_3X_TYPE1005_USB = 0x209102c0;	//Output rate of the RTCM-3X-TYPE1005 message on port USB
-const uint32_t UBLOX_CFG_MSGOUT_RTCM_3X_TYPE1074_I2C = 0x2091035e;	//Output rate of the RTCM-3X-TYPE1074 message on port I2C
-const uint32_t UBLOX_CFG_MSGOUT_RTCM_3X_TYPE1074_SPI = 0x20910362;	//Output rate of the RTCM-3X-TYPE1074 message on port SPI
-const uint32_t UBLOX_CFG_MSGOUT_RTCM_3X_TYPE1074_UART1 = 0x2091035f;//Output rate of the RTCM-3X-TYPE1074 message on port UART1
-const uint32_t UBLOX_CFG_MSGOUT_RTCM_3X_TYPE1074_UART2 = 0x20910360;//Output rate of the RTCM-3X-TYPE1074 message on port UART2
-const uint32_t UBLOX_CFG_MSGOUT_RTCM_3X_TYPE1074_USB = 0x20910361;	//Output rate of the RTCM-3X-TYPE1074 message on port USB
-const uint32_t UBLOX_CFG_MSGOUT_RTCM_3X_TYPE1077_I2C = 0x209102cc;	//Output rate of the RTCM-3X-TYPE1077 message on port I2C
-const uint32_t UBLOX_CFG_MSGOUT_RTCM_3X_TYPE1077_SPI = 0x209102d0;	//Output rate of the RTCM-3X-TYPE1077 message on port SPI
-const uint32_t UBLOX_CFG_MSGOUT_RTCM_3X_TYPE1077_UART1 = 0x209102cd;//Output rate of the RTCM-3X-TYPE1077 message on port UART1
-const uint32_t UBLOX_CFG_MSGOUT_RTCM_3X_TYPE1077_UART2 = 0x209102ce;//Output rate of the RTCM-3X-TYPE1077 message on port UART2
-const uint32_t UBLOX_CFG_MSGOUT_RTCM_3X_TYPE1077_USB = 0x209102cf;	//Output rate of the RTCM-3X-TYPE1077 message on port USB
-const uint32_t UBLOX_CFG_MSGOUT_RTCM_3X_TYPE1084_I2C = 0x20910363;	//Output rate of the RTCM-3X-TYPE1084 message on port I2C
-const uint32_t UBLOX_CFG_MSGOUT_RTCM_3X_TYPE1084_SPI = 0x20910367;	//Output rate of the RTCM-3X-TYPE1084 message on port SPI
-const uint32_t UBLOX_CFG_MSGOUT_RTCM_3X_TYPE1084_UART1 = 0x20910364;//Output rate of the RTCM-3X-TYPE1084 message on port UART1
-const uint32_t UBLOX_CFG_MSGOUT_RTCM_3X_TYPE1084_UART2 = 0x20910365;//Output rate of the RTCM-3X-TYPE1084 message on port UART2
-const uint32_t UBLOX_CFG_MSGOUT_RTCM_3X_TYPE1084_USB = 0x20910366;	//Output rate of the RTCM-3X-TYPE1084 message on port USB
-const uint32_t UBLOX_CFG_MSGOUT_RTCM_3X_TYPE1087_I2C = 0x209102d1;	//Output rate of the RTCM-3X-TYPE1087 message on port I2C
-const uint32_t UBLOX_CFG_MSGOUT_RTCM_3X_TYPE1087_SPI = 0x209102d5;	//Output rate of the RTCM-3X-TYPE1087 message on port SPI
-const uint32_t UBLOX_CFG_MSGOUT_RTCM_3X_TYPE1087_UART1 = 0x209102d2;//Output rate of the RTCM-3X-TYPE1087 message on port UART1
-const uint32_t UBLOX_CFG_MSGOUT_RTCM_3X_TYPE1087_UART2 = 0x209102d3;//Output rate of the RTCM-3X-TYPE1087 message on port UART2
-const uint32_t UBLOX_CFG_MSGOUT_RTCM_3X_TYPE1087_USB = 0x209102d4;	//Output rate of the RTCM-3X-TYPE1087 message on port USB
-const uint32_t UBLOX_CFG_MSGOUT_RTCM_3X_TYPE1094_I2C = 0x20910368;	//Output rate of the RTCM-3X-TYPE1094 message on port I2C
-const uint32_t UBLOX_CFG_MSGOUT_RTCM_3X_TYPE1094_SPI = 0x2091036c;	//Output rate of the RTCM-3X-TYPE1094 message on port SPI
-const uint32_t UBLOX_CFG_MSGOUT_RTCM_3X_TYPE1094_UART1 = 0x20910369;//Output rate of the RTCM-3X-TYPE1094 message on port UART1
-const uint32_t UBLOX_CFG_MSGOUT_RTCM_3X_TYPE1094_UART2 = 0x2091036a;//Output rate of the RTCM-3X-TYPE1094 message on port UART2
-const uint32_t UBLOX_CFG_MSGOUT_RTCM_3X_TYPE1094_USB = 0x2091036b;	//Output rate of the RTCM-3X-TYPE1094 message on port USB
-const uint32_t UBLOX_CFG_MSGOUT_RTCM_3X_TYPE1097_I2C = 0x20910318;	//Output rate of the RTCM-3X-TYPE1097 message on port I2C
-const uint32_t UBLOX_CFG_MSGOUT_RTCM_3X_TYPE1097_SPI = 0x2091031c;	//Output rate of the RTCM-3X-TYPE1097 message on port SPI
-const uint32_t UBLOX_CFG_MSGOUT_RTCM_3X_TYPE1097_UART1 = 0x20910319;//Output rate of the RTCM-3X-TYPE1097 message on port UART1
-const uint32_t UBLOX_CFG_MSGOUT_RTCM_3X_TYPE1097_UART2 = 0x2091031a;//Output rate of the RTCM-3X-TYPE1097 message on port UART2
-const uint32_t UBLOX_CFG_MSGOUT_RTCM_3X_TYPE1097_USB = 0x2091031b;	//Output rate of the RTCM-3X-TYPE1097 message on port USB
-const uint32_t UBLOX_CFG_MSGOUT_RTCM_3X_TYPE1124_I2C = 0x2091036d;	//Output rate of the RTCM-3X-TYPE1124 message on port I2C
-const uint32_t UBLOX_CFG_MSGOUT_RTCM_3X_TYPE1124_SPI = 0x20910371;	//Output rate of the RTCM-3X-TYPE1124 message on port SPI
-const uint32_t UBLOX_CFG_MSGOUT_RTCM_3X_TYPE1124_UART1 = 0x2091036e;//Output rate of the RTCM-3X-TYPE1124 message on port UART1
-const uint32_t UBLOX_CFG_MSGOUT_RTCM_3X_TYPE1124_UART2 = 0x2091036f;//Output rate of the RTCM-3X-TYPE1124 message on port UART2
-const uint32_t UBLOX_CFG_MSGOUT_RTCM_3X_TYPE1124_USB = 0x20910370;	//Output rate of the RTCM-3X-TYPE1124 message on port USB
-const uint32_t UBLOX_CFG_MSGOUT_RTCM_3X_TYPE1127_I2C = 0x209102d6;	//Output rate of the RTCM-3X-TYPE1127 message on port I2C
-const uint32_t UBLOX_CFG_MSGOUT_RTCM_3X_TYPE1127_SPI = 0x209102da;	//Output rate of the RTCM-3X-TYPE1127 message on port SPI
-const uint32_t UBLOX_CFG_MSGOUT_RTCM_3X_TYPE1127_UART1 = 0x209102d7;//Output rate of the RTCM-3X-TYPE1127 message on port UART1
-const uint32_t UBLOX_CFG_MSGOUT_RTCM_3X_TYPE1127_UART2 = 0x209102d8;//Output rate of the RTCM-3X-TYPE1127 message on port UART2
-const uint32_t UBLOX_CFG_MSGOUT_RTCM_3X_TYPE1127_USB = 0x209102d9;	//Output rate of the RTCM-3X-TYPE1127 message on port USB
-const uint32_t UBLOX_CFG_MSGOUT_RTCM_3X_TYPE1230_I2C = 0x20910303;	//Output rate of the RTCM-3X-TYPE1230 message on port I2C
-const uint32_t UBLOX_CFG_MSGOUT_RTCM_3X_TYPE1230_SPI = 0x20910307;	//Output rate of the RTCM-3X-TYPE1230 message on port SPI
-const uint32_t UBLOX_CFG_MSGOUT_RTCM_3X_TYPE1230_UART1 = 0x20910304;//Output rate of the RTCM-3X-TYPE1230 message on port UART1
-const uint32_t UBLOX_CFG_MSGOUT_RTCM_3X_TYPE1230_UART2 = 0x20910305;//Output rate of the RTCM-3X-TYPE1230 message on port UART2
-const uint32_t UBLOX_CFG_MSGOUT_RTCM_3X_TYPE1230_USB = 0x20910306;	//Output rate of the RTCM-3X-TYPE1230 message on port USB
-const uint32_t UBLOX_CFG_MSGOUT_RTCM_3X_TYPE4072_0_I2C = 0x209102fe;//Output rate of the RTCM-3X-TYPE4072_0 message on port I2C
-const uint32_t UBLOX_CFG_MSGOUT_RTCM_3X_TYPE4072_0_SPI = 0x20910302;//Output rate of the RTCM-3X-TYPE4072_0 message on port SPI
-const uint32_t UBLOX_CFG_MSGOUT_RTCM_3X_TYPE4072_0_UART1 = 0x209102ff; //Output rate of the RTCM-3X-TYPE4072_0 message on port UART1
-const uint32_t UBLOX_CFG_MSGOUT_RTCM_3X_TYPE4072_0_UART2 = 0x20910300; //Output rate of the RTCM-3X-TYPE4072_0 message on port UART2
-const uint32_t UBLOX_CFG_MSGOUT_RTCM_3X_TYPE4072_0_USB = 0x20910301;//Output rate of the RTCM-3X-TYPE4072_0 message on port USB
-const uint32_t UBLOX_CFG_MSGOUT_RTCM_3X_TYPE4072_1_I2C = 0x20910381;//Output rate of the RTCM-3X-TYPE4072_1 message on port I2C
-const uint32_t UBLOX_CFG_MSGOUT_RTCM_3X_TYPE4072_1_SPI = 0x20910385;//Output rate of the RTCM-3X-TYPE4072_1 message on port SPI
-const uint32_t UBLOX_CFG_MSGOUT_RTCM_3X_TYPE4072_1_UART1 = 0x20910382; //Output rate of the RTCM-3X-TYPE4072_1 message on port UART1
-const uint32_t UBLOX_CFG_MSGOUT_RTCM_3X_TYPE4072_1_UART2 = 0x20910383; //Output rate of the RTCM-3X-TYPE4072_1 message on port UART2
-const uint32_t UBLOX_CFG_MSGOUT_RTCM_3X_TYPE4072_1_USB = 0x20910384;//Output rate of the RTCM-3X-TYPE4072_1 message on port USB
-const uint32_t UBLOX_CFG_MSGOUT_UBX_LOG_INFO_I2C = 0x20910259;		//Output rate of the UBX-LOG-INFO message on port I2C
-const uint32_t UBLOX_CFG_MSGOUT_UBX_LOG_INFO_SPI = 0x2091025d;			//Output rate of the UBX-LOG-INFO message on port SPI
-const uint32_t UBLOX_CFG_MSGOUT_UBX_LOG_INFO_UART1 = 0x2091025a;		//Output rate of the UBX-LOG-INFO message on port UART1
-const uint32_t UBLOX_CFG_MSGOUT_UBX_LOG_INFO_UART2 = 0x2091025b;	//Output rate of the UBX-LOG-INFO message on port UART2
-const uint32_t UBLOX_CFG_MSGOUT_UBX_LOG_INFO_USB = 0x2091025c;		//Output rate of the UBX-LOG-INFO message on port USB
-const uint32_t UBLOX_CFG_MSGOUT_UBX_MON_COMMS_I2C = 0x2091034f;			//Output rate of the UBX-MON-COMMS message on port I2C
-const uint32_t UBLOX_CFG_MSGOUT_UBX_MON_COMMS_SPI = 0x20910353;			//Output rate of the UBX-MON-COMMS message on port SPI
-const uint32_t UBLOX_CFG_MSGOUT_UBX_MON_COMMS_UART1 = 0x20910350;		//Output rate of the UBX-MON-COMMS message on port UART1
-const uint32_t UBLOX_CFG_MSGOUT_UBX_MON_COMMS_UART2 = 0x20910351;	//Output rate of the UBX-MON-COMMS message on port UART2
-const uint32_t UBLOX_CFG_MSGOUT_UBX_MON_COMMS_USB = 0x20910352;		//Output rate of the UBX-MON-COMMS message on port USB
-const uint32_t UBLOX_CFG_MSGOUT_UBX_MON_HW2_I2C = 0x209101b9;				//Output rate of the UBX-MON-HW2 message on port I2C
-const uint32_t UBLOX_CFG_MSGOUT_UBX_MON_HW2_SPI = 0x209101bd;				//Output rate of the UBX-MON-HW2 message on port SPI
-const uint32_t UBLOX_CFG_MSGOUT_UBX_MON_HW2_UART1 = 0x209101ba;			//Output rate of the UBX-MON-HW2 message on port UART1
-const uint32_t UBLOX_CFG_MSGOUT_UBX_MON_HW2_UART2 = 0x209101bb;			//Output rate of the UBX-MON-HW2 message on port UART2
-const uint32_t UBLOX_CFG_MSGOUT_UBX_MON_HW2_USB = 0x209101bc;				//Output rate of the UBX-MON-HW2 message on port USB
-const uint32_t UBLOX_CFG_MSGOUT_UBX_MON_HW3_I2C = 0x20910354;				//Output rate of the UBX-MON-HW3 message on port I2C
-const uint32_t UBLOX_CFG_MSGOUT_UBX_MON_HW3_SPI = 0x20910358;				//Output rate of the UBX-MON-HW3 message on port SPI
-const uint32_t UBLOX_CFG_MSGOUT_UBX_MON_HW3_UART1 = 0x20910355;			//Output rate of the UBX-MON-HW3 message on port UART1
-const uint32_t UBLOX_CFG_MSGOUT_UBX_MON_HW3_UART2 = 0x20910356;			//Output rate of the UBX-MON-HW3 message on port UART2
-const uint32_t UBLOX_CFG_MSGOUT_UBX_MON_HW3_USB = 0x20910357;				//Output rate of the UBX-MON-HW3 message on port USB
-const uint32_t UBLOX_CFG_MSGOUT_UBX_MON_HW_I2C = 0x209101b4;				//Output rate of the UBX-MON-HW message on port I2C
-const uint32_t UBLOX_CFG_MSGOUT_UBX_MON_HW_SPI = 0x209101b8;				//Output rate of the UBX-MON-HW message on port SPI
-const uint32_t UBLOX_CFG_MSGOUT_UBX_MON_HW_UART1 = 0x209101b5;			//Output rate of the UBX-MON-HW message on port UART1
-const uint32_t UBLOX_CFG_MSGOUT_UBX_MON_HW_UART2 = 0x209101b6;			//Output rate of the UBX-MON-HW message on port UART2
-const uint32_t UBLOX_CFG_MSGOUT_UBX_MON_HW_USB = 0x209101b7;				//Output rate of the UBX-MON-HW message on port USB
-const uint32_t UBLOX_CFG_MSGOUT_UBX_MON_IO_I2C = 0x209101a5;				//Output rate of the UBX-MON-IO message on port I2C
-const uint32_t UBLOX_CFG_MSGOUT_UBX_MON_IO_SPI = 0x209101a9;				//Output rate of the UBX-MON-IO message on port SPI
-const uint32_t UBLOX_CFG_MSGOUT_UBX_MON_IO_UART1 = 0x209101a6;			//Output rate of the UBX-MON-IO message on port UART1
-const uint32_t UBLOX_CFG_MSGOUT_UBX_MON_IO_UART2 = 0x209101a7;			//Output rate of the UBX-MON-IO message on port UART2
-const uint32_t UBLOX_CFG_MSGOUT_UBX_MON_IO_USB = 0x209101a8;				//Output rate of the UBX-MON-IO message on port USB
-const uint32_t UBLOX_CFG_MSGOUT_UBX_MON_MSGPP_I2C = 0x20910196;			//Output rate of the UBX-MON-MSGPP message on port I2C
-const uint32_t UBLOX_CFG_MSGOUT_UBX_MON_MSGPP_SPI = 0x2091019a;			//Output rate of the UBX-MON-MSGPP message on port SPI
-const uint32_t UBLOX_CFG_MSGOUT_UBX_MON_MSGPP_UART1 = 0x20910197;		//Output rate of the UBX-MON-MSGPP message on port UART1
-const uint32_t UBLOX_CFG_MSGOUT_UBX_MON_MSGPP_UART2 = 0x20910198;	//Output rate of the UBX-MON-MSGPP message on port UART2
-const uint32_t UBLOX_CFG_MSGOUT_UBX_MON_MSGPP_USB = 0x20910199;		//Output rate of the UBX-MON-MSGPP message on port USB
-const uint32_t UBLOX_CFG_MSGOUT_UBX_MON_RF_I2C = 0x20910359;				//Output rate of the UBX-MON-RF message on port I2C
-const uint32_t UBLOX_CFG_MSGOUT_UBX_MON_RF_SPI = 0x2091035d;				//Output rate of the UBX-MON-RF message on port SPI
-const uint32_t UBLOX_CFG_MSGOUT_UBX_MON_RF_UART1 = 0x2091035a;			//Output rate of the UBX-MON-RF message on port UART1
-const uint32_t UBLOX_CFG_MSGOUT_UBX_MON_RF_UART2 = 0x2091035b;			//Output rate of the UBX-MON-RF message on port UART2
-const uint32_t UBLOX_CFG_MSGOUT_UBX_MON_RF_USB = 0x2091035c;				// Output rate of the UBX-MON-RF message on port USB
-const uint32_t UBLOX_CFG_MSGOUT_UBX_MON_RXBUF_I2C = 0x209101a0;			// Output rate of the UBX-MON-RXBUF message on port I2C
-const uint32_t UBLOX_CFG_MSGOUT_UBX_MON_RXBUF_SPI = 0x209101a4;			// Output rate of the UBX-MON-RXBUF message on port SPI
-const uint32_t UBLOX_CFG_MSGOUT_UBX_MON_RXBUF_UART1 = 0x209101a1;		// Output rate of the UBX-MON-RXBUF message on port UART1
-const uint32_t UBLOX_CFG_MSGOUT_UBX_MON_RXBUF_UART2 = 0x209101a2;	// Output rate of the UBX-MON-RXBUF message on port UART2
-const uint32_t UBLOX_CFG_MSGOUT_UBX_MON_RXBUF_USB = 0x209101a3;		// Output rate of the UBX-MON-RXBUF message on port USB
-const uint32_t UBLOX_CFG_MSGOUT_UBX_MON_RXR_I2C = 0x20910187;				// Output rate of the UBX-MON-RXR message on port I2C
-const uint32_t UBLOX_CFG_MSGOUT_UBX_MON_RXR_SPI = 0x2091018b;				// Output rate of the UBX-MON-RXR message on port SPI
-const uint32_t UBLOX_CFG_MSGOUT_UBX_MON_RXR_UART1 = 0x20910188;			// Output rate of the UBX-MON-RXR message on port UART1
-const uint32_t UBLOX_CFG_MSGOUT_UBX_MON_RXR_UART2 = 0x20910189;			// Output rate of the UBX-MON-RXR message on port UART2
-const uint32_t UBLOX_CFG_MSGOUT_UBX_MON_RXR_USB = 0x2091018a;				// Output rate of the UBX-MON-RXR message on port USB
-const uint32_t UBLOX_CFG_MSGOUT_UBX_MON_SPAN_I2C = 0x2091038b;			// Output rate of the UBX-MON-SPAN message on port I2C
-const uint32_t UBLOX_CFG_MSGOUT_UBX_MON_SPAN_SPI = 0x2091038f;			// Output rate of the UBX-MON-SPAN message on port SPI
-const uint32_t UBLOX_CFG_MSGOUT_UBX_MON_SPAN_UART1 = 0x2091038c;		// Output rate of the UBX-MON-SPAN message on port UART1
-const uint32_t UBLOX_CFG_MSGOUT_UBX_MON_SPAN_UART2 = 0x2091038d;	// Output rate of the UBX-MON-SPAN message on port UART2
-const uint32_t UBLOX_CFG_MSGOUT_UBX_MON_SPAN_USB = 0x2091038e;		// Output rate of the UBX-MON-SPAN message on port USB
-const uint32_t UBLOX_CFG_MSGOUT_UBX_MON_TXBUF_I2C = 0x2091019b;			// Output rate of the UBX-MON-TXBUF message on port I2C
-const uint32_t UBLOX_CFG_MSGOUT_UBX_MON_TXBUF_SPI = 0x2091019f;			// Output rate of the UBX-MON-TXBUF message on port SPI
-const uint32_t UBLOX_CFG_MSGOUT_UBX_MON_TXBUF_UART1 = 0x2091019c;		// Output rate of the UBX-MON-TXBUF message on port UART1
-const uint32_t UBLOX_CFG_MSGOUT_UBX_MON_TXBUF_UART2 = 0x2091019d;	// Output rate of the UBX-MON-TXBUF message on port UART2
-const uint32_t UBLOX_CFG_MSGOUT_UBX_MON_TXBUF_USB = 0x2091019e;		// Output rate of the UBX-MON-TXBUF message on port USB
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_ATT_I2C = 0x2091001f;		// Output rate of the UBX_NAV_ATT message on port I2C
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_ATT_SPI = 0x20910023;		// Output rate of the UBX_NAV_ATT message on port SPI
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_ATT_UART1 = 0x20910020;		// Output rate of the UBX_NAV_ATT message on port UART1
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_ATT_UART2 = 0x20910021;		// Output rate of the UBX_NAV_ATT message on port UART2
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_ATT_USB = 0x20910022;		// Output rate of the UBX_NAV_ATT message on port USB
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_CLOCK_I2C = 0x20910065;			// Output rate of the UBX-NAV-CLOCK message on port I2C
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_CLOCK_SPI = 0x20910069;			// Output rate of the UBX-NAV-CLOCK message on port SPI
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_CLOCK_UART1 = 0x20910066;		// Output rate of the UBX-NAV-CLOCK message on port UART1
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_CLOCK_UART2 = 0x20910067;	// Output rate of the UBX-NAV-CLOCK message on port UART2
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_CLOCK_USB = 0x20910068;		// Output rate of the UBX-NAV-CLOCK message on port USB
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_DOP_I2C = 0x20910038;				// Output rate of the UBX-NAV-DOP message on port I2C
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_DOP_SPI = 0x2091003c;				// Output rate of the UBX-NAV-DOP message on port SPI
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_DOP_UART1 = 0x20910039;			// Output rate of the UBX-NAV-DOP message on port UART1
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_DOP_UART2 = 0x2091003a;			// Output rate of the UBX-NAV-DOP message on port UART2
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_DOP_USB = 0x2091003b;				// Output rate of the UBX-NAV-DOP message on port USB
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_EOE_I2C = 0x2091015f;				// Output rate of the UBX-NAV-EOE message on port I2C
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_EOE_SPI = 0x20910163;				// Output rate of the UBX-NAV-EOE message on port SPI
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_EOE_UART1 = 0x20910160;			// Output rate of the UBX-NAV-EOE message on port UART1
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_EOE_UART2 = 0x20910161;			// Output rate of the UBX-NAV-EOE message on port UART2
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_EOE_USB = 0x20910162;				// Output rate of the UBX-NAV-EOE message on port USB
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_GEOFENCE_I2C = 0x209100a1;		// Output rate of the UBX-NAV-GEOFENCE message on port I2C
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_GEOFENCE_SPI = 0x209100a5;	// Output rate of the UBX-NAV-GEOFENCE message on port SPI
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_GEOFENCE_UART1 = 0x209100a2;// Output rate of the UBX-NAV-GEOFENCE message on port UART1
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_GEOFENCE_UART2 = 0x209100a3;// Output rate of the UBX-NAV-GEOFENCE message on port UART2
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_GEOFENCE_USB = 0x209100a4;	// Output rate of the UBX-NAV-GEOFENCE message on port USB
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_HPPOSECEF_I2C = 0x2091002e;// Output rate of the UBX-NAV-HPPOSECEF message on port I2C
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_HPPOSECEF_SPI = 0x20910032;// Output rate of the UBX-NAV-HPPOSECEF message on port SPI
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_HPPOSECEF_UART1 = 0x2091002f;// Output rate of the UBX-NAV-HPPOSECEF message on port UART1
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_HPPOSECEF_UART2 = 0x20910030;// Output rate of the UBX-NAV-HPPOSECEF message on port UART2
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_HPPOSECEF_USB = 0x20910031;// Output rate of the UBX-NAV-HPPOSECEF message on port USB
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_HPPOSLLH_I2C = 0x20910033;	// Output rate of the UBX-NAV-HPPOSLLH message on port I2C
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_HPPOSLLH_SPI = 0x20910037;	// Output rate of the UBX-NAV-HPPOSLLH message on port SPI
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_HPPOSLLH_UART1 = 0x20910034;// Output rate of the UBX-NAV-HPPOSLLH message on port UART1
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_HPPOSLLH_UART2 = 0x20910035;// Output rate of the UBX-NAV-HPPOSLLH message on port UART2
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_HPPOSLLH_USB = 0x20910036;	// Output rate of the UBX-NAV-HPPOSLLH message on port USB
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_ODO_I2C = 0x2091007e;			// Output rate of the UBX-NAV-ODO message on port I2C
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_ODO_SPI = 0x20910082;				// Output rate of the UBX-NAV-ODO message on port SPI
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_ODO_UART1 = 0x2091007f;			// Output rate of the UBX-NAV-ODO message on port UART1
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_ODO_UART2 = 0x20910080;			// Output rate of the UBX-NAV-ODO message on port UART2
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_ODO_USB = 0x20910081;				// Output rate of the UBX-NAV-ODO message on port USB
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_ORB_I2C = 0x20910010;				// Output rate of the UBX-NAV-ORB message on port I2C
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_ORB_SPI = 0x20910014;				// Output rate of the UBX-NAV-ORB message on port SPI
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_ORB_UART1 = 0x20910011;			// Output rate of the UBX-NAV-ORB message on port UART1
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_ORB_UART2 = 0x20910012;			// Output rate of the UBX-NAV-ORB message on port UART2
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_ORB_USB = 0x20910013;				// Output rate of the UBX-NAV-ORB message on port USB
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_POSECEF_I2C = 0x20910024;		// Output rate of the UBX-NAV-POSECEF message on port I2C
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_POSECEF_SPI = 0x20910028;	// Output rate of the UBX-NAV-POSECEF message on port SPI
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_POSECEF_UART1 = 0x20910025;// Output rate of the UBX-NAV-POSECEF message on port UART1
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_POSECEF_UART2 = 0x20910026;// Output rate of the UBX-NAV-POSECEF message on port UART2
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_POSECEF_USB = 0x20910027;	// Output rate of the UBX-NAV-POSECEF message on port USB
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_POSLLH_I2C = 0x20910029;	// Output rate of the UBX-NAV-POSLLH message on port I2C
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_POSLLH_SPI = 0x2091002d;	// Output rate of the UBX-NAV-POSLLH message on port SPI
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_POSLLH_UART1 = 0x2091002a;	// Output rate of the UBX-NAV-POSLLH message on port UART1
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_POSLLH_UART2 = 0x2091002b;	// Output rate of the UBX-NAV-POSLLH message on port UART2
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_POSLLH_USB = 0x2091002c;	// Output rate of the UBX-NAV-POSLLH message on port USB
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_PVT_I2C = 0x20910006;			// Output rate of the UBX-NAV-PVT message on port I2C
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_PVT_SPI = 0x2091000a;				// Output rate of the UBX-NAV-PVT message on port SPI
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_PVT_UART1 = 0x20910007;			// Output rate of the UBX-NAV-PVT message on port UART1
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_PVT_UART2 = 0x20910008;			// Output rate of the UBX-NAV-PVT message on port UART2
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_PVT_USB = 0x20910009;				// Output rate of the UBX-NAV-PVT message on port USB
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_RELPOSNED_I2C = 0x2091008d;	// Output rate of the UBX-NAV-RELPOSNED message on port I2C
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_RELPOSNED_SPI = 0x20910091;// Output rate of the UBX-NAV-RELPOSNED message on port SPI
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_RELPOSNED_UART1 = 0x2091008e;// Output rate of the UBX-NAV-RELPOSNED message on port UART1
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_RELPOSNED_UART2 = 0x2091008f;// Output rate of the UBX-NAV-RELPOSNED message on port UART2
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_RELPOSNED_USB = 0x20910090;// Output rate of the UBX-NAV-RELPOSNED message on port USB
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_SAT_I2C = 0x20910015;			// Output rate of the UBX-NAV-SAT message on port I2C
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_SAT_SPI = 0x20910019;				// Output rate of the UBX-NAV-SAT message on port SPI
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_SAT_UART1 = 0x20910016;			// Output rate of the UBX-NAV-SAT message on port UART1
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_SAT_UART2 = 0x20910017;			// Output rate of the UBX-NAV-SAT message on port UART2
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_SAT_USB = 0x20910018;				// Output rate of the UBX-NAV-SAT message on port USB
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_SBAS_I2C = 0x2091006a;			// Output rate of the UBX-NAV-SBAS message on port I2C
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_SBAS_SPI = 0x2091006e;			// Output rate of the UBX-NAV-SBAS message on port SPI
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_SBAS_UART1 = 0x2091006b;		// Output rate of the UBX-NAV-SBAS message on port UART1
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_SBAS_UART2 = 0x2091006c;	// Output rate of the UBX-NAV-SBAS message on port UART2
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_SBAS_USB = 0x2091006d;		// Output rate of the UBX-NAV-SBAS message on port USB
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_SIG_I2C = 0x20910345;				// Output rate of the UBX-NAV-SIG message on port I2C
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_SIG_SPI = 0x20910349;				// Output rate of the UBX-NAV-SIG message on port SPI
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_SIG_UART1 = 0x20910346;			// Output rate of the UBX-NAV-SIG message on port UART1
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_SIG_UART2 = 0x20910347;			// Output rate of the UBX-NAV-SIG message on port UART2
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_SIG_USB = 0x20910348;				// Output rate of the UBX-NAV-SIG message on port USB
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_SLAS_I2C = 0x20910336;			// Output rate of the UBX-NAV-SLAS message on port I2C
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_SLAS_SPI = 0x2091033a;			// Output rate of the UBX-NAV-SLAS message on port SPI
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_SLAS_UART1 = 0x20910337;		// Output rate of the UBX-NAV-SLAS message on port UART1
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_SLAS_UART2 = 0x20910338;	// Output rate of the UBX-NAV-SLAS message on port UART2
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_SLAS_USB = 0x20910339;		// Output rate of the UBX-NAV-SLAS message on port USB
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_STATUS_I2C = 0x2091001a;		// Output rate of the UBX-NAV-STATUS message on port I2C
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_STATUS_SPI = 0x2091001e;	// Output rate of the UBX-NAV-STATUS message on port SPI
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_STATUS_UART1 = 0x2091001b;	// Output rate of the UBX-NAV-STATUS message on port UART1
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_STATUS_UART2 = 0x2091001c;	// Output rate of the UBX-NAV-STATUS message on port UART2
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_STATUS_USB = 0x2091001d;	// Output rate of the UBX-NAV-STATUS message on port USB
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_SVIN_I2C = 0x20910088;		// Output rate of the UBX-NAV-SVIN message on port I2C
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_SVIN_SPI = 0x2091008c;			// Output rate of the UBX-NAV-SVIN message on port SPI
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_SVIN_UART1 = 0x20910089;		// Output rate of the UBX-NAV-SVIN message on port UART1
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_SVIN_UART2 = 0x2091008a;	// Output rate of the UBX-NAV-SVIN message on port UART2
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_SVIN_USB = 0x2091008b;		// Output rate of the UBX-NAV-SVIN message on port USB
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_TIMEBDS_I2C = 0x20910051;		// Output rate of the UBX-NAV-TIMEBDS message on port I2C
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_TIMEBDS_SPI = 0x20910055;	// Output rate of the UBX-NAV-TIMEBDS message on port SPI
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_TIMEBDS_UART1 = 0x20910052;// Output rate of the UBX-NAV-TIMEBDS message on port UART1
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_TIMEBDS_UART2 = 0x20910053;// Output rate of the UBX-NAV-TIMEBDS message on port UART2
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_TIMEBDS_USB = 0x20910054;	// Output rate of the UBX-NAV-TIMEBDS message on port USB
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_TIMEGAL_I2C = 0x20910056;	// Output rate of the UBX-NAV-TIMEGAL message on port I2C
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_TIMEGAL_SPI = 0x2091005a;	// Output rate of the UBX-NAV-TIMEGAL message on port SPI
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_TIMEGAL_UART1 = 0x20910057;// Output rate of the UBX-NAV-TIMEGAL message on port UART1
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_TIMEGAL_UART2 = 0x20910058;// Output rate of the UBX-NAV-TIMEGAL message on port UART2
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_TIMEGAL_USB = 0x20910059;	// Output rate of the UBX-NAV-TIMEGAL message on port USB
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_TIMEGLO_I2C = 0x2091004c;	// Output rate of the UBX-NAV-TIMEGLO message on port I2C
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_TIMEGLO_SPI = 0x20910050;	// Output rate of the UBX-NAV-TIMEGLO message on port SPI
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_TIMEGLO_UART1 = 0x2091004d;// Output rate of the UBX-NAV-TIMEGLO message on port UART1
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_TIMEGLO_UART2 = 0x2091004e;// Output rate of the UBX-NAV-TIMEGLO message on port UART2
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_TIMEGLO_USB = 0x2091004f;	// Output rate of the UBX-NAV-TIMEGLO message on port USB
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_TIMEGPS_I2C = 0x20910047;	// Output rate of the UBX-NAV-TIMEGPS message on port I2C
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_TIMEGPS_SPI = 0x2091004b;	// Output rate of the UBX-NAV-TIMEGPS message on port SPI
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_TIMEGPS_UART1 = 0x20910048;// Output rate of the UBX-NAV-TIMEGPS message on port UART1
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_TIMEGPS_UART2 = 0x20910049;// Output rate of the UBX-NAV-TIMEGPS message on port UART2
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_TIMEGPS_USB = 0x2091004a;	// Output rate of the UBX-NAV-TIMEGPS message on port USB
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_TIMELS_I2C = 0x20910060;	// Output rate of the UBX-NAV-TIMELS message on port I2C
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_TIMELS_SPI = 0x20910064;	// Output rate of the UBX-NAV-TIMELS message on port SPI
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_TIMELS_UART1 = 0x20910061;	// Output rate of the UBX-NAV-TIMELS message on port UART1
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_TIMELS_UART2 = 0x20910062;	// Output rate of the UBX-NAV-TIMELS message on port UART2
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_TIMELS_USB = 0x20910063;	// Output rate of the UBX-NAV-TIMELS message on port USB
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_TIMEQZSS_I2C = 0x20910386;	// Output rate of the UBX-NAV-TIMEQZSSmessage on port I2C
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_TIMEQZSS_SPI = 0x2091038a;	// Output rate of the UBX-NAV-TIMEQZSSmessage on port SPI
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_TIMEQZSS_UART1 = 0x20910387;// Output rate of the UBX-NAV-TIMEQZSSmessage on port UART1
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_TIMEQZSS_UART2 = 0x20910388;// Output rate of the UBX-NAV-TIMEQZSSmessage on port UART2
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_TIMEQZSS_USB = 0x20910389;	// Output rate of the UBX-NAV-TIMEQZSSmessage on port USB
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_TIMEUTC_I2C = 0x2091005b;	// Output rate of the UBX-NAV-TIMEUTC message on port I2C
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_TIMEUTC_SPI = 0x2091005f;	// Output rate of the UBX-NAV-TIMEUTC message on port SPI
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_TIMEUTC_UART1 = 0x2091005c;// Output rate of the UBX-NAV-TIMEUTC message on port UART1
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_TIMEUTC_UART2 = 0x2091005d;// Output rate of the UBX-NAV-TIMEUTC message on port UART2
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_TIMEUTC_USB = 0x2091005e;	// Output rate of the UBX-NAV-TIMEUTC message on port USB
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_VELECEF_I2C = 0x2091003d;	// Output rate of the UBX-NAV-VELECEF message on port I2C
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_VELECEF_SPI = 0x20910041;	// Output rate of the UBX-NAV-VELECEF message on port SPI
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_VELECEF_UART1 = 0x2091003e;// Output rate of the UBX-NAV-VELECEF message on port UART1
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_VELECEF_UART2 = 0x2091003f;// Output rate of the UBX-NAV-VELECEF message on port UART2
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_VELECEF_USB = 0x20910040;	// Output rate of the UBX-NAV-VELECEF message on port USB
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_VELNED_I2C = 0x20910042;	// Output rate of the UBX-NAV-VELNED message on port I2C
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_VELNED_SPI = 0x20910046;	// Output rate of the UBX-NAV-VELNED message on port SPI
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_VELNED_UART1 = 0x20910043;	// Output rate of the UBX-NAV-VELNED message on port UART1
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_VELNED_UART2 = 0x20910044;	// Output rate of the UBX-NAV-VELNED message on port UART2
-const uint32_t UBLOX_CFG_MSGOUT_UBX_NAV_VELNED_USB = 0x20910045;	// Output rate of the UBX-NAV-VELNED message on port USB
-const uint32_t UBLOX_CFG_MSGOUT_UBX_RXM_MEASX_I2C = 0x20910204;		// Output rate of the UBX-RXM-MEASX message on port I2C
-const uint32_t UBLOX_CFG_MSGOUT_UBX_RXM_MEASX_SPI = 0x20910208;			// Output rate of the UBX-RXM-MEASX message on port SPI
-const uint32_t UBLOX_CFG_MSGOUT_UBX_RXM_MEASX_UART1 = 0x20910205;		// Output rate of the UBX-RXM-MEASX message on port UART1
-const uint32_t UBLOX_CFG_MSGOUT_UBX_RXM_MEASX_UART2 = 0x20910206;	// Output rate of the UBX-RXM-MEASX message on port UART2
-const uint32_t UBLOX_CFG_MSGOUT_UBX_RXM_MEASX_USB = 0x20910207;		// Output rate of the UBX-RXM-MEASX message on port USB
-const uint32_t UBLOX_CFG_MSGOUT_UBX_RXM_RAWX_I2C = 0x209102a4;			// Output rate of the UBX-RXM-RAWX message on port I2C
-const uint32_t UBLOX_CFG_MSGOUT_UBX_RXM_RAWX_SPI = 0x209102a8;			// Output rate of the UBX-RXM-RAWX message on port SPI
-const uint32_t UBLOX_CFG_MSGOUT_UBX_RXM_RAWX_UART1 = 0x209102a5;		// Output rate of the UBX-RXM-RAWX message on port UART1
-const uint32_t UBLOX_CFG_MSGOUT_UBX_RXM_RAWX_UART2 = 0x209102a6;	// Output rate of the UBX-RXM-RAWX message on port UART2
-const uint32_t UBLOX_CFG_MSGOUT_UBX_RXM_RAWX_USB = 0x209102a7;		// Output rate of the UBX-RXM-RAWX message on port USB
-const uint32_t UBLOX_CFG_MSGOUT_UBX_RXM_RLM_I2C = 0x2091025e;				// Output rate of the UBX-RXM-RLM message on port I2C
-const uint32_t UBLOX_CFG_MSGOUT_UBX_RXM_RLM_SPI = 0x20910262;				// Output rate of the UBX-RXM-RLM message on port SPI
-const uint32_t UBLOX_CFG_MSGOUT_UBX_RXM_RLM_UART1 = 0x2091025f;			// Output rate of the UBX-RXM-RLM message on port UART1
-const uint32_t UBLOX_CFG_MSGOUT_UBX_RXM_RLM_UART2 = 0x20910260;			// Output rate of the UBX-RXM-RLM message on port UART2
-const uint32_t UBLOX_CFG_MSGOUT_UBX_RXM_RLM_USB = 0x20910261;				// Output rate of the UBX-RXM-RLM message on port USB
-const uint32_t UBLOX_CFG_MSGOUT_UBX_RXM_RTCM_I2C = 0x20910268;			// Output rate of the UBX-RXM-RTCM message on port I2C
-const uint32_t UBLOX_CFG_MSGOUT_UBX_RXM_RTCM_SPI = 0x2091026c;			// Output rate of the UBX-RXM-RTCM message on port SPI
-const uint32_t UBLOX_CFG_MSGOUT_UBX_RXM_RTCM_UART1 = 0x20910269;			// Output rate of the UBX-RXM-RTCM message on port UART1
-const uint32_t UBLOX_CFG_MSGOUT_UBX_RXM_RTCM_UART2 = 0x2091026a;		// Output rate of the UBX-RXM-RTCM message on port UART2
-const uint32_t UBLOX_CFG_MSGOUT_UBX_RXM_RTCM_USB = 0x2091026b;		// Output rate of the UBX-RXM-RTCM message on port USB
-const uint32_t UBLOX_CFG_MSGOUT_UBX_RXM_SFRBX_I2C = 0x20910231;			// Output rate of the UBX-RXM-SFRBX message on port I2C
-const uint32_t UBLOX_CFG_MSGOUT_UBX_RXM_SFRBX_SPI = 0x20910235;			// Output rate of the UBX-RXM-SFRBX message on port SPI
-const uint32_t UBLOX_CFG_MSGOUT_UBX_RXM_SFRBX_UART1 = 0x20910232;		// Output rate of the UBX-RXM-SFRBX message on port UART1
-const uint32_t UBLOX_CFG_MSGOUT_UBX_RXM_SFRBX_UART2 = 0x20910233;	// Output rate of the UBX-RXM-SFRBX message on port UART2
-const uint32_t UBLOX_CFG_MSGOUT_UBX_RXM_SFRBX_USB = 0x20910234;		// Output rate of the UBX-RXM-SFRBX message on port USB
-const uint32_t UBLOX_CFG_MSGOUT_UBX_TIM_TM2_I2C = 0x20910178;				// Output rate of the UBX-TIM-TM2 message on port I2C
-const uint32_t UBLOX_CFG_MSGOUT_UBX_TIM_TM2_SPI = 0x2091017c;				// Output rate of the UBX-TIM-TM2 message on port SPI
-const uint32_t UBLOX_CFG_MSGOUT_UBX_TIM_TM2_UART1 = 0x20910179;			// Output rate of the UBX-TIM-TM2 message on port UART1
-const uint32_t UBLOX_CFG_MSGOUT_UBX_TIM_TM2_UART2 = 0x2091017a;			// Output rate of the UBX-TIM-TM2 message on port UART2
-const uint32_t UBLOX_CFG_MSGOUT_UBX_TIM_TM2_USB = 0x2091017b;				// Output rate of the UBX-TIM-TM2 message on port USB
-const uint32_t UBLOX_CFG_MSGOUT_UBX_TIM_TP_I2C = 0x2091017d;				// Output rate of the UBX-TIM-TP message on port I2C
-const uint32_t UBLOX_CFG_MSGOUT_UBX_TIM_TP_SPI = 0x20910181;				// Output rate of the UBX-TIM-TP message on port SPI
-const uint32_t UBLOX_CFG_MSGOUT_UBX_TIM_TP_UART1 = 0x2091017e;			// Output rate of the UBX-TIM-TP message on port UART1
-const uint32_t UBLOX_CFG_MSGOUT_UBX_TIM_TP_UART2 = 0x2091017f;			// Output rate of the UBX-TIM-TP message on port UART2
-const uint32_t UBLOX_CFG_MSGOUT_UBX_TIM_TP_USB = 0x20910180;				// Output rate of the UBX-TIM-TP message on port USB
-const uint32_t UBLOX_CFG_MSGOUT_UBX_TIM_VRFY_I2C = 0x20910092;			// Output rate of the UBX-TIM-VRFY message on port I2C
-const uint32_t UBLOX_CFG_MSGOUT_UBX_TIM_VRFY_SPI = 0x20910096;			// Output rate of the UBX-TIM-VRFY message on port SPI
-const uint32_t UBLOX_CFG_MSGOUT_UBX_TIM_VRFY_UART1 = 0x20910093;			// Output rate of the UBX-TIM-VRFY message on port UART1
-const uint32_t UBLOX_CFG_MSGOUT_UBX_TIM_VRFY_UART2 = 0x20910094;		// Output rate of the UBX-TIM-VRFY message on port UART2
-const uint32_t UBLOX_CFG_MSGOUT_UBX_TIM_VRFY_USB = 0x20910095;		// Output rate of the UBX-TIM-VRFY message on port USB
-
-//CFG-NAVHPG: High precision navigation configuration
-//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
-const uint32_t UBLOX_CFG_NAVHPG_DGNSSMODE = 0x20140011;	// Diﬀerential corrections mode
-
-//CFG-NAVSPG: Standard precision navigation configuration
-//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
-const uint32_t UBLOX_CFG_NAVSPG_FIXMODE = 0x20110011;	// Position fix mode
-const uint32_t UBLOX_CFG_NAVSPG_INIFIX3D = 0x10110013;	// Initial fix must be a 3D fix
-const uint32_t UBLOX_CFG_NAVSPG_WKNROLLOVER = 0x30110017;	// GPS week rollover number
-const uint32_t UBLOX_CFG_NAVSPG_UTCSTANDARD = 0x2011001c;	// UTC standard to be used
-const uint32_t UBLOX_CFG_NAVSPG_DYNMODEL = 0x20110021;	// Dynamic platform model
-const uint32_t UBLOX_CFG_NAVSPG_ACKAIDING = 0x10110025;	// Acknowledge assistance input messages
-const uint32_t UBLOX_CFG_NAVSPG_USE_USRDAT = 0x10110061;	// Use user geodetic datum parameters
-const uint32_t UBLOX_CFG_NAVSPG_USRDAT_MAJA = 0x50110062;	// Geodetic datum semi-major axis
-const uint32_t UBLOX_CFG_NAVSPG_USRDAT_FLAT = 0x50110063;	// Geodetic datum 1.0 flattening
-const uint32_t UBLOX_CFG_NAVSPG_USRDAT_DX = 0x40110064;	// Geodetic datum X axis shift at the origin
-const uint32_t UBLOX_CFG_NAVSPG_USRDAT_DY = 0x40110065;	// Geodetic datum Y axis shift at the origin
-const uint32_t UBLOX_CFG_NAVSPG_USRDAT_DZ = 0x40110066;	// Geodetic datum Z axis shift at the origin
-const uint32_t UBLOX_CFG_NAVSPG_USRDAT_ROTX = 0x40110067;	// arcsec Geodetic datum rotation about the X axis
-const uint32_t UBLOX_CFG_NAVSPG_USRDAT_ROTY = 0x40110068;	// arcsec Geodetic datum rotation about the Y axis
-const uint32_t UBLOX_CFG_NAVSPG_USRDAT_ROTZ = 0x40110069;	// arcsec Geodetic datum rotation about the Z axis
-const uint32_t UBLOX_CFG_NAVSPG_USRDAT_SCALE = 0x4011006a;	// ppm Geodetic datum scale factor
-const uint32_t UBLOX_CFG_NAVSPG_INFIL_MINSVS = 0x201100a1;	// Minimum number of satellites for navigation
-const uint32_t UBLOX_CFG_NAVSPG_INFIL_MAXSVS = 0x201100a2;	// Maximum number of satellites for navigation
-const uint32_t UBLOX_CFG_NAVSPG_INFIL_MINCNO = 0x201100a3;	// Minimum satellite signal level for navigation
-const uint32_t UBLOX_CFG_NAVSPG_INFIL_MINELEV = 0x201100a4;	// Minimum elevation for a GNSS satellite to be used in navigation
-const uint32_t UBLOX_CFG_NAVSPG_INFIL_NCNOTHRS = 0x201100aa;	// Number of satellites required to have C/N0 above const uint32_t UBLOX_CFG_NAVSPG-INFIL_CNOTHRS for a fix to be attempted
-const uint32_t UBLOX_CFG_NAVSPG_INFIL_CNOTHRS = 0x201100ab;	// C/N0 threshold for deciding whether to attempt a fix
-const uint32_t UBLOX_CFG_NAVSPG_OUTFIL_PDOP = 0x301100b1;	// Output filter position DOP mask (threshold)
-const uint32_t UBLOX_CFG_NAVSPG_OUTFIL_TDOP = 0x301100b2;	// Output filter time DOP mask (threshold)
-const uint32_t UBLOX_CFG_NAVSPG_OUTFIL_PACC = 0x301100b3;	// Output filter position accuracy mask (threshold)
-const uint32_t UBLOX_CFG_NAVSPG_OUTFIL_TACC = 0x301100b4;	// Output filter time accuracy mask (threshold)
-const uint32_t UBLOX_CFG_NAVSPG_OUTFIL_FACC = 0x301100b5;	// Output filter frequency accuracy mask (threshold)
-const uint32_t UBLOX_CFG_NAVSPG_CONSTR_ALT = 0x401100c1;	// Fixed altitude (mean sea level) for 2D fix mode
-const uint32_t UBLOX_CFG_NAVSPG_CONSTR_ALTVAR = 0x401100c2;	// Fixed altitude variance for 2D mode
-const uint32_t UBLOX_CFG_NAVSPG_CONSTR_DGNSSTO = 0x201100c4;	// DGNSS timeout
-
-//CFG-NMEA: NMEA protocol configuration
-//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
-const uint32_t UBLOX_CFG_NMEA_PROTVER = 0x20930001;	// NMEA protocol version
-const uint32_t UBLOX_CFG_NMEA_MAXSVS = 0x20930002;	// Maximum number of SVs to report per Talker ID
-const uint32_t UBLOX_CFG_NMEA_COMPAT = 0x10930003;	// Enable compatibility mode
-const uint32_t UBLOX_CFG_NMEA_CONSIDER = 0x10930004;	// Enable considering mode
-const uint32_t UBLOX_CFG_NMEA_LIMIT82 = 0x10930005;	// Enable strict limit to 82 characters maximum NMEA message length
-const uint32_t UBLOX_CFG_NMEA_HIGHPREC = 0x10930006;	// Enable high precision mode
-const uint32_t UBLOX_CFG_NMEA_SVNUMBERING = 0x20930007;	// Display configuration for SVs that do not have value defined in NMEA
-const uint32_t UBLOX_CFG_NMEA_FILT_GPS = 0x10930011;	// Disable reporting of GPS satellites
-const uint32_t UBLOX_CFG_NMEA_FILT_SBAS = 0x10930012;	// Disable reporting of SBAS satellites
-const uint32_t UBLOX_CFG_NMEA_FILT_GAL = 0x10930013;	// Disable reporting of Galileo satellites
-const uint32_t UBLOX_CFG_NMEA_FILT_QZSS = 0x10930015;	// Disable reporting of QZSS satellites
-const uint32_t UBLOX_CFG_NMEA_FILT_GLO = 0x10930016;	// Disable reporting of GLONASS satellites
-const uint32_t UBLOX_CFG_NMEA_FILT_BDS = 0x10930017;	// Disable reporting of BeiDou satellites
-const uint32_t UBLOX_CFG_NMEA_OUT_INVFIX = 0x10930021;	// Enable position output for failed or invalid fixes
-const uint32_t UBLOX_CFG_NMEA_OUT_MSKFIX = 0x10930022;	// Enable position output for invalid fixes
-const uint32_t UBLOX_CFG_NMEA_OUT_INVTIME = 0x10930023;	// Enable time output for invalid times
-const uint32_t UBLOX_CFG_NMEA_OUT_INVDATE = 0x10930024;	// Enable date output for invalid dates
-const uint32_t UBLOX_CFG_NMEA_OUT_ONLYGPS = 0x10930025;	// Restrict output to GPS satellites only
-const uint32_t UBLOX_CFG_NMEA_OUT_FROZENCOG = 0x10930026;	// Enable course over ground output even if it is frozen
-const uint32_t UBLOX_CFG_NMEA_MAINTALKERID = 0x20930031;	// Main Talker ID
-const uint32_t UBLOX_CFG_NMEA_GSVTALKERID = 0x20930032;	// Talker ID for GSV NMEA messages
-const uint32_t UBLOX_CFG_NMEA_BDSTALKERID = 0x30930033;	// BeiDou Talker ID
-
-//CFG-ODO: Odometer and low-speed course over ground filter
-//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
-const uint32_t UBLOX_CFG_ODO_USE_ODO = 0x10220001;	// Use odometer
-const uint32_t UBLOX_CFG_ODO_USE_COG = 0x10220002;	// Use low-speed course over ground filter
-const uint32_t UBLOX_CFG_ODO_OUTLPVEL = 0x10220003;	// Output low-pass filtered velocity
-const uint32_t UBLOX_CFG_ODO_OUTLPCOG = 0x10220004;	// Output low-pass filtered course over ground (heading)
-const uint32_t UBLOX_CFG_ODO_PROFILE = 0x20220005;	// Odometer profile configuration
-const uint32_t UBLOX_CFG_ODO_COGMAXSPEED = 0x20220021;	// Upper speed limit for low-speed course over ground filter
-const uint32_t UBLOX_CFG_ODO_COGMAXPOSACC = 0x20220022;	// Maximum acceptable position accuracy for computing low-speed filtered course over ground
-const uint32_t UBLOX_CFG_ODO_VELLPGAIN = 0x20220031;	// Velocity low-pass filter level
-const uint32_t UBLOX_CFG_ODO_COGLPGAIN = 0x20220032;	// Course over ground low-pass filter level (at speed < 8 m/s)
-
-//CFG-QZSS: QZSS system configuration
-//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
-const uint32_t UBLOX_CFG_QZSS_USE_SLAS_DGNSS = 0x10370005;	// Apply QZSS SLAS DGNSS corrections
-const uint32_t UBLOX_CFG_QZSS_USE_SLAS_TESTMODE = 0x10370006;	// Use QZSS SLAS data when it is in test mode (SLAS msg 0)
-const uint32_t UBLOX_CFG_QZSS_USE_SLAS_RAIM_UNCORR = 0x10370007;	// Raim out measurements that are not corrected by QZSS SLAS, if at least 5 measurements are corrected
-
-//CFG-RATE: Navigation and measurement rate configuration
-//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
-const uint32_t UBLOX_CFG_RATE_MEAS = 0x30210001;	// Nominal time between GNSS measurements
-const uint32_t UBLOX_CFG_RATE_NAV = 0x30210002;	// Ratio of number of measurements to number of navigation solutions
-const uint32_t UBLOX_CFG_RATE_TIMEREF = 0x20210003;	// Time system to which measurements are aligned
-
-//CFG-RINV: Remote inventory
-//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
-const uint32_t UBLOX_CFG_RINV_DUMP = 0x10c70001;	// Dump data at startup
-const uint32_t UBLOX_CFG_RINV_BINARY = 0x10c70002;	// Data is binary
-const uint32_t UBLOX_CFG_RINV_DATA_SIZE = 0x20c70003;	// Size of data
-const uint32_t UBLOX_CFG_RINV_CHUNK0 = 0x50c70004;	// Data bytes 1-8 (LSB)
-const uint32_t UBLOX_CFG_RINV_CHUNK1 = 0x50c70005;	// Data bytes 9-16
-const uint32_t UBLOX_CFG_RINV_CHUNK2 = 0x50c70006;	// Data bytes 17-240x44434241.
-const uint32_t UBLOX_CFG_RINV_CHUNK3 = 0x50c70007;	// Data bytes 25-30 (MSB)
-
-//CFG-RTCM: RTCM protocol configuration
-//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
-const uint32_t UBLOX_CFG_RTCM_DF003_OUT = 0x30090001;	// RTCM DF003 (Reference station ID) output value
-const uint32_t UBLOX_CFG_RTCM_DF003_IN = 0x30090008;	// RTCM DF003 (Reference station ID) input value
-const uint32_t UBLOX_CFG_RTCM_DF003_IN_FILTER = 0x20090009;	// RTCM input filter configuration based on RTCM DF003 (Reference station ID) value
-
-//CFG-SBAS: SBAS configuration
-//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
-const uint32_t UBLOX_CFG_SBAS_USE_TESTMODE = 0x10360002;	// Use SBAS data when it is in test mode (SBAS msg 0)
-const uint32_t UBLOX_CFG_SBAS_USE_RANGING = 0x10360003;	// Use SBAS GEOs as a ranging source (for navigation)
-const uint32_t UBLOX_CFG_SBAS_USE_DIFFCORR = 0x10360004;	// Use SBAS diﬀerential corrections
-const uint32_t UBLOX_CFG_SBAS_USE_INTEGRITY = 0x10360005;	// Use SBAS integrity information
-const uint32_t UBLOX_CFG_SBAS_PRNSCANMASK = 0x50360006;	// SBAS PRN search configuration
-
-//CFG-SIGNAL: Satellite systems (GNSS) signal configuration
-//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
-const uint32_t UBLOX_CFG_SIGNAL_GPS_ENA = 0x1031001f;	// GPS enable
-const uint32_t UBLOX_CFG_SIGNAL_GPS_L1CA_ENA = 0x10310001;	// GPS L1C/A
-const uint32_t UBLOX_CFG_SIGNAL_GPS_L2C_ENA = 0x10310003;	// GPS L2C (only on u-blox F9 platform products)
-const uint32_t UBLOX_CFG_SIGNAL_SBAS_ENA = 0x10310020;	// SBAS enable
-const uint32_t UBLOX_CFG_SIGNAL_SBAS_L1CA_ENA = 0x10310005;	// SBAS L1C/A
-const uint32_t UBLOX_CFG_SIGNAL_GAL_ENA = 0x10310021;	// Galileo enable
-const uint32_t UBLOX_CFG_SIGNAL_GAL_E1_ENA = 0x10310007;	// Galileo E1
-const uint32_t UBLOX_CFG_SIGNAL_GAL_E5B_ENA = 0x1031000a;	// Galileo E5b (only on u-blox F9 platform products)
-const uint32_t UBLOX_CFG_SIGNAL_BDS_ENA = 0x10310022;	// BeiDou Enable
-const uint32_t UBLOX_CFG_SIGNAL_BDS_B1_ENA = 0x1031000d;	// BeiDou B1I
-const uint32_t UBLOX_CFG_SIGNAL_BDS_B2_ENA = 0x1031000e;	// BeiDou B2I (only on u-blox F9 platform products)
-const uint32_t UBLOX_CFG_SIGNAL_QZSS_ENA = 0x10310024;	// QZSS enable
-const uint32_t UBLOX_CFG_SIGNAL_QZSS_L1CA_ENA = 0x10310012;	// QZSS L1C/A
-const uint32_t UBLOX_CFG_SIGNAL_QZSS_L1S_ENA = 0x10310014;	// QZSS L1S
-const uint32_t UBLOX_CFG_SIGNAL_QZSS_L2C_ENA = 0x10310015;	// QZSS L2C (only on u-blox F9 platform products)
-const uint32_t UBLOX_CFG_SIGNAL_GLO_ENA = 0x10310025;	// GLONASS enable
-const uint32_t UBLOX_CFG_SIGNAL_GLO_L1_ENA = 0x10310018;	// GLONASS L1
-const uint32_t UBLOX_CFG_SIGNAL_GLO_L2_ENA = 0x1031001a;	// GLONASS L2 (only on u-blox F9 platform products)
-
-//CFG-SPI: Configuration of the SPI interface
-//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
-const uint32_t UBLOX_CFG_SPI_MAXFF = 0x20640001;	// Number of bytes containing 0xFF to receive before switching oﬀ reception. Range: 0 (mechanism oﬀ) - 63
-const uint32_t UBLOX_CFG_SPI_CPOLARITY = 0x10640002;	// Clock polarity select: 0: Active Hight Clock, SCLK idles low, 1: Active Low Clock, SCLK idles high
-const uint32_t UBLOX_CFG_SPI_CPHASE = 0x10640003;	// Clock phase select: 0: Data captured on first edge of SCLK, 1: Data captured on second edge of SCLK
-const uint32_t UBLOX_CFG_SPI_EXTENDEDTIMEOUT = 0x10640005;	// Flag to disable timeouting the interface after 1.5s
-const uint32_t UBLOX_CFG_SPI_ENABLED = 0x10640006;	// Flag to indicate if the SPI interface should be enabled
-
-//CFG-SPIINPROT: Input protocol configuration of the SPI interface
-//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
-const uint32_t UBLOX_CFG_SPIINPROT_UBX = 0x10790001;	// Flag to indicate if UBX should be an input protocol on SPI
-const uint32_t UBLOX_CFG_SPIINPROT_NMEA = 0x10790002;	// Flag to indicate if NMEA should be an input protocol on SPI
-const uint32_t UBLOX_CFG_SPIINPROT_RTCM3X = 0x10790004;	// Flag to indicate if RTCM3X should be an input protocol on SPI
-
-//CFG-SPIOUTPROT: Output protocol configuration of the SPI interface
-//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
-const uint32_t UBLOX_CFG_SPIOUTPROT_UBX = 0x107a0001;	// Flag to indicate if UBX should be an output protocol on SPI
-const uint32_t UBLOX_CFG_SPIOUTPROT_NMEA = 0x107a0002;	// Flag to indicate if NMEA should be an output protocol on SPI
-const uint32_t UBLOX_CFG_SPIOUTPROT_RTCM3X = 0x107a0004;	// Flag to indicate if RTCM3X should be an output protocol on SPI
-
-//CFG-TMODE: Time mode configuration
-//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
-const uint32_t UBLOX_CFG_TMODE_MODE = 0x20030001;	// Receiver mode
-const uint32_t UBLOX_CFG_TMODE_POS_TYPE = 0x20030002;	// Determines whether the ARP position is given in ECEF or LAT/LON/HEIGHT?
-const uint32_t UBLOX_CFG_TMODE_ECEF_X = 0x40030003;	// ECEF X coordinate of the ARP position.
-const uint32_t UBLOX_CFG_TMODE_ECEF_Y = 0x40030004;	// ECEF Y coordinate of the ARP position.
-const uint32_t UBLOX_CFG_TMODE_ECEF_Z = 0x40030005;	// ECEF Z coordinate of the ARP position.
-const uint32_t UBLOX_CFG_TMODE_ECEF_X_HP = 0x20030006;	// High-precision ECEF X coordinate of the ARP position.
-const uint32_t UBLOX_CFG_TMODE_ECEF_Y_HP = 0x20030007;	// High-precision ECEF Y coordinate of the ARP position.
-const uint32_t UBLOX_CFG_TMODE_ECEF_Z_HP = 0x20030008;	// High-precision ECEF Z coordinate of the ARP position.
-const uint32_t UBLOX_CFG_TMODE_LAT = 0x40030009;	// Latitude of the ARP position.
-const uint32_t UBLOX_CFG_TMODE_LON = 0x4003000a;	// Longitude of the ARP position.
-const uint32_t UBLOX_CFG_TMODE_HEIGHT = 0x4003000b;	// Height of the ARP position.
-const uint32_t UBLOX_CFG_TMODE_LAT_HP = 0x2003000c;	// High-precision latitude of the ARP position
-const uint32_t UBLOX_CFG_TMODE_LON_HP = 0x2003000d;	// High-precision longitude of the ARP position.
-const uint32_t UBLOX_CFG_TMODE_HEIGHT_HP = 0x2003000e;	// High-precision height of the ARP position.
-const uint32_t UBLOX_CFG_TMODE_FIXED_POS_ACC = 0x4003000f;	// Fixed position 3D accuracy
-const uint32_t UBLOX_CFG_TMODE_SVIN_MIN_DUR = 0x40030010;	// Survey-in minimum duration
-const uint32_t UBLOX_CFG_TMODE_SVIN_ACC_LIMIT = 0x40030011;	// Survey-in position accuracy limit
-
-//CFG-TP: Timepulse configuration
-//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
-const uint32_t UBLOX_CFG_TP_PULSE_DEF = 0x20050023;	// Determines whether the time pulse is interpreted as frequency or period
-const uint32_t UBLOX_CFG_TP_PULSE_LENGTH_DEF = 0x20050030;	// Determines whether the time pulse length is interpreted as length[us] or pulse ratio[%]
-const uint32_t UBLOX_CFG_TP_FREQ_TP1 = 0x40050024;	// Time pulse frequency (TP1)
-const uint32_t UBLOX_CFG_TP_FREQ_LOCK_TP1 = 0x40050025;	// Time pulse frequency when locked to GNSS time (TP1)
-const uint32_t UBLOX_CFG_TP_LEN_TP1 = 0x40050004;	// Time pulse length (TP1)
-const uint32_t UBLOX_CFG_TP_LEN_LOCK_TP1 = 0x40050005;	// Time pulse length when locked to GNSS time (TP1)
-const uint32_t UBLOX_CFG_TP_DUTY_TP1 = 0x5005002a;	// Time pulse duty cycle (TP1)
-const uint32_t UBLOX_CFG_TP_DUTY_LOCK_TP1 = 0x5005002b;	// Time pulse duty cycle when locked to GNSS time (TP1)
-const uint32_t UBLOX_CFG_TP_USER_DELAY_TP1 = 0x40050006;	// User-configurable time pulse delay (TP1)
-const uint32_t UBLOX_CFG_TP_TP1_ENA = 0x10050007;	// Enable the first timepulse
-const uint32_t UBLOX_CFG_TP_SYNC_GNSS_TP1 = 0x10050008;	// Sync time pulse to GNSS time or local clock (TP1)
-const uint32_t UBLOX_CFG_TP_USE_LOCKED_TP1 = 0x10050009;	// Use locked parameters when possible (TP1)
-const uint32_t UBLOX_CFG_TP_ALIGN_TO_TOW_TP1 = 0x1005000a;	// Align time pulse to top of second (TP1)
-const uint32_t UBLOX_CFG_TP_POL_TP1 = 0x1005000b;	// Set time pulse polarity (TP1)
-const uint32_t UBLOX_CFG_TP_TIMEGRID_TP1 = 0x2005000c;	// Time grid to use (TP1)
-
-//CFG-TXREADY: TX ready configuration
-//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
-const uint32_t UBLOX_CFG_TXREADY_ENABLED = 0x10a20001;	// Flag to indicate if TX ready pin mechanism should be enabled
-const uint32_t UBLOX_CFG_TXREADY_POLARITY = 0x10a20002;	// The polarity of the TX ready pin: false:high- active, true:low-active
-const uint32_t UBLOX_CFG_TXREADY_PIN = 0x20a20003;	// Pin number to use for the TX ready functionality
-const uint32_t UBLOX_CFG_TXREADY_THRESHOLD = 0x30a20004;	// Amount of data that should be ready on the interface before triggering the TX ready pin
-const uint32_t UBLOX_CFG_TXREADY_INTERFACE = 0x20a20005;	// Interface where the TX ready feature should be linked to
-
-//CFG-UART1: Configuration of the UART1 interface
-//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
-const uint32_t UBLOX_CFG_UART1_BAUDRATE = 0x40520001;	// The baud rate that should be configured on the UART1
-const uint32_t UBLOX_CFG_UART1_STOPBITS = 0x20520002;	// Number of stopbits that should be used on UART1
-const uint32_t UBLOX_CFG_UART1_DATABITS = 0x20520003;	// Number of databits that should be used on UART1
-const uint32_t UBLOX_CFG_UART1_PARITY = 0x20520004;	// Parity mode that should be used on UART1
-const uint32_t UBLOX_CFG_UART1_ENABLED = 0x10520005;	// Flag to indicate if the UART1 should be enabled
-
-//CFG-UART1INPROT: Input protocol configuration of the UART1 interface
-//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
-const uint32_t UBLOX_CFG_UART1INPROT_UBX = 0x10730001;	// Flag to indicate if UBX should be an input protocol on UART1
-const uint32_t UBLOX_CFG_UART1INPROT_NMEA = 0x10730002;	// Flag to indicate if NMEA should be an input protocol on UART1
-const uint32_t UBLOX_CFG_UART1INPROT_RTCM3X = 0x10730004;	// Flag to indicate if RTCM3X should be an input protocol on UART1
-
-//CFG-UART1OUTPROT: Output protocol configuration of the UART1 interface
-//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
-const uint32_t UBLOX_CFG_UART1OUTPROT_UBX = 0x10740001;	// Flag to indicate if UBX should be an output protocol on UART1
-const uint32_t UBLOX_CFG_UART1OUTPROT_NMEA = 0x10740002;	// Flag to indicate if NMEA should be an output protocol on UART1
-const uint32_t UBLOX_CFG_UART1OUTPROT_RTCM3X = 0x10740004;	// Flag to indicate if RTCM3X should be an output protocol on UART1
-
-//CFG-UART2: Configuration of the UART2 interface
-//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
-const uint32_t UBLOX_CFG_UART2_BAUDRATE = 0x40530001;	// The baud rate that should be configured on the UART2
-const uint32_t UBLOX_CFG_UART2_STOPBITS = 0x20530002;	// Number of stopbits that should be used on UART2
-const uint32_t UBLOX_CFG_UART2_DATABITS = 0x20530003;	// Number of databits that should be used on UART2
-const uint32_t UBLOX_CFG_UART2_PARITY = 0x20530004;	// Parity mode that should be used on UART2
-const uint32_t UBLOX_CFG_UART2_ENABLED = 0x10530005;	// Flag to indicate if the UART2 should be enabled
-const uint32_t UBLOX_CFG_UART2_REMAP = 0x10530006;	// UART2 Remapping
-
-//CFG-UART2INPROT: Input protocol configuration of the UART2 interface
-//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
-const uint32_t UBLOX_CFG_UART2INPROT_UBX = 0x10750001;	// Flag to indicate if UBX should be an input protocol on UART2
-const uint32_t UBLOX_CFG_UART2INPROT_NMEA = 0x10750002;	// Flag to indicate if NMEA should be an input protocol on UART2
-const uint32_t UBLOX_CFG_UART2INPROT_RTCM3X = 0x10750004;	// Flag to indicate if RTCM3X should be an input protocol on UART2
-
-//CFG-UART2OUTPROT: Output protocol configuration of the UART2 interface
-//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
-const uint32_t UBLOX_CFG_UART2OUTPROT_UBX = 0x10760001;	// Flag to indicate if UBX should be an output protocol on UART2
-const uint32_t UBLOX_CFG_UART2OUTPROT_NMEA = 0x10760002;	// Flag to indicate if NMEA should be an output protocol on UART2
-const uint32_t UBLOX_CFG_UART2OUTPROT_RTCM3X = 0x10760004;	// Flag to indicate if RTCM3X should be an output protocol on UART2
-
-//CFG-USB: Configuration of the USB interface
-//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
-const uint32_t UBLOX_CFG_USB_ENABLED = 0x10650001;	// Flag to indicate if the USB interface should be enabled
-const uint32_t UBLOX_CFG_USB_SELFPOW = 0x10650002;	// Self-powered device
-const uint32_t UBLOX_CFG_USB_VENDOR_ID = 0x3065000a;	// Vendor ID
-const uint32_t UBLOX_CFG_USB_PRODUCT_ID = 0x3065000b;	// Vendor ID
-const uint32_t UBLOX_CFG_USB_POWER = 0x3065000c;	// Power consumption
-const uint32_t UBLOX_CFG_USB_VENDOR_STR0 = 0x5065000d;	// Vendor string characters 0-7
-const uint32_t UBLOX_CFG_USB_VENDOR_STR1 = 0x5065000e;	// Vendor string characters 8-15
-const uint32_t UBLOX_CFG_USB_VENDOR_STR2 = 0x5065000f;	// Vendor string characters 16-23
-const uint32_t UBLOX_CFG_USB_VENDOR_STR3 = 0x50650010;	// Vendor string characters 24-31
-const uint32_t UBLOX_CFG_USB_PRODUCT_STR0 = 0x50650011;	// Product string characters 0-7
-const uint32_t UBLOX_CFG_USB_PRODUCT_STR1 = 0x50650012;	// Product string characters 8-15
-const uint32_t UBLOX_CFG_USB_PRODUCT_STR2 = 0x50650013;	// Product string characters 16-23
-const uint32_t UBLOX_CFG_USB_PRODUCT_STR3 = 0x50650014;	// Product string characters 24-31
-const uint32_t UBLOX_CFG_USB_SERIAL_NO_STR0 = 0x50650015;	// Serial number string characters 0-7
-const uint32_t UBLOX_CFG_USB_SERIAL_NO_STR1 = 0x50650016;	// Serial number string characters 8-15
-const uint32_t UBLOX_CFG_USB_SERIAL_NO_STR2 = 0x50650017;	// Serial number string characters 16-23
-const uint32_t UBLOX_CFG_USB_SERIAL_NO_STR3 = 0x50650018;	// Serial number string characters 24-31
-
-//CFG-USBINPROT: Input protocol configuration of the USB interface
-//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
-const uint32_t UBLOX_CFG_USBINPROT_UBX = 0x10770001;	// Flag to indicate if UBX should be an input protocol on USB
-const uint32_t UBLOX_CFG_USBINPROT_NMEA = 0x10770002;	// Flag to indicate if NMEA should be an input protocol on USB
-const uint32_t UBLOX_CFG_USBINPROT_RTCM3X = 0x10770004;	// Flag to indicate if RTCM3X should be an input protocol on USB
-
-//CFG-USBOUTPROT: Output protocol configuration of the USB interface
-//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
-const uint32_t UBLOX_CFG_USBOUTPROT_UBX = 0x10780001;	// Flag to indicate if UBX should be an output protocol on USB
-const uint32_t UBLOX_CFG_USBOUTPROT_NMEA = 0x10780002;	// Flag to indicate if NMEA should be an output protocol on USB
-const uint32_t UBLOX_CFG_USBOUTPROT_RTCM3X = 0x10780004;	// Flag to indicate if RTCM3X should be an output protocol on USB
-
-#endif
diff --git a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/src/u-blox_structs.h b/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/src/u-blox_structs.h
deleted file mode 100644
index 50611bf..0000000
--- a/Ublox_Linux_Library/SparkFun_u-blox_GNSS_Arduino_Library/src/u-blox_structs.h
+++ /dev/null
@@ -1,1827 +0,0 @@
-/*
-	This is a library written for the u-blox ZED-F9P and NEO-M8P-2
-	SparkFun sells these at its website: www.sparkfun.com
-	Do you like this library? Help support SparkFun. Buy a board!
-	https://www.sparkfun.com/products/16481
-	https://www.sparkfun.com/products/15136
-	https://www.sparkfun.com/products/15005
-	https://www.sparkfun.com/products/15733
-	https://www.sparkfun.com/products/15193
-	https://www.sparkfun.com/products/15210
-
-  Original version by Nathan Seidle @ SparkFun Electronics, September 6th, 2018
-	v2.0 rework by Paul Clark @ SparkFun Electronics, December 31st, 2020
-
-	This library handles configuring and handling the responses
-	from a u-blox GPS module. Works with most modules from u-blox including
-	the Zed-F9P, NEO-M8P-2, NEO-M9N, ZOE-M8Q, SAM-M8Q, and many others.
-
-	https://github.com/sparkfun/SparkFun_Ublox_Arduino_Library
-
-	Development environment specifics:
-	Arduino IDE 1.8.13
-
-	SparkFun code, firmware, and software is released under the MIT License(http://opensource.org/licenses/MIT).
-	The MIT License (MIT)
-	Copyright (c) 2016 SparkFun Electronics
-	Permission is hereby granted, free of charge, to any person obtaining a copy of this software and
-	associated documentation files (the "Software"), to deal in the Software without restriction,
-	including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
-	and/or sell copies of the Software, and to permit persons to whom the Software is furnished to
-	do so, subject to the following conditions:
-
-	The above copyright notice and this permission notice shall be included in all copies or substantial
-	portions of the Software.
-
-	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT
-	NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
-	IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
-	WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
-	SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-*/
-
-#ifndef __u_blox_structs_h__
-#define __u_blox_structs_h__
-
-#include "SparkFun_u-blox_GNSS_Arduino_Library.h"
-
-#ifndef DEF_NUM_SENS
-#define DEF_NUM_SENS 7 // The maximum number of ESF sensors
-#endif
-
-//Additional flags and pointers that need to be stored with each message type
-struct ubxAutomaticFlags
-{
-  union
-  {
-    uint8_t all;
-    struct
-    {
-      uint8_t automatic : 1; // Will this message be delivered and parsed "automatically" (without polling)
-      uint8_t implicitUpdate : 1; // Is the update triggered by accessing stale data (=true) or by a call to checkUblox (=false)
-      uint8_t addToFileBuffer : 1; // Should the raw UBX data be added to the file buffer?
-      uint8_t callbackCopyValid : 1; // Is the copy of the data struct used by the callback valid/fresh?
-    } bits;
-  } flags;
-};
-
-// UBX-NAV-POSECEF (0x01 0x01): Position solution in ECEF
-const uint16_t UBX_NAV_POSECEF_LEN = 20;
-
-typedef struct
-{
-  uint32_t iTOW; // GPS time of week of the navigation epoch: ms
-  int32_t ecefX; // ECEF X coordinate: cm
-  int32_t ecefY; // ECEF Y coordinate: cm
-  int32_t ecefZ; // ECEF Z coordinate: cm
-  uint32_t pAcc; // Position Accuracy Estimate: cm
-} UBX_NAV_POSECEF_data_t;
-
-typedef struct
-{
-  union
-  {
-    uint32_t all;
-    struct
-    {
-      uint32_t all : 1;
-
-      uint32_t iTOW : 1;
-      uint32_t ecefX : 1;
-      uint32_t ecefY : 1;
-      uint32_t ecefZ : 1;
-      uint32_t pAcc : 1;
-    } bits;
-  } moduleQueried;
-} UBX_NAV_POSECEF_moduleQueried_t;
-
-typedef struct
-{
-	ubxAutomaticFlags automaticFlags;
-  UBX_NAV_POSECEF_data_t data;
-  UBX_NAV_POSECEF_moduleQueried_t moduleQueried;
-  void (*callbackPointer)(UBX_NAV_POSECEF_data_t);
-  UBX_NAV_POSECEF_data_t  *callbackData;
-} UBX_NAV_POSECEF_t;
-
-// UBX-NAV-POSLLH (0x01 0x02): Geodetic position solution
-const uint16_t UBX_NAV_POSLLH_LEN = 28;
-
-typedef struct
-{
-  uint32_t iTOW; // GPS time of week of the navigation epoch: ms
-  int32_t lon; // Longitude: Degrees * 1e-7
-  int32_t lat; // Latitude: Degrees * 1e-7
-  int32_t height; // Height above ellipsoid: mm
-  int32_t hMSL; // Height above mean sea level: mm
-  uint32_t hAcc; // Horizontal Accuracy Estimate: mm
-  uint32_t vAcc; // Vertical Accuracy Estimate: mm
-} UBX_NAV_POSLLH_data_t;
-
-typedef struct
-{
-  union
-  {
-    uint32_t all;
-    struct
-    {
-      uint32_t all : 1;
-
-      uint32_t iTOW : 1;
-      uint32_t lon : 1;
-      uint32_t lat : 1;
-      uint32_t height : 1;
-      uint32_t hMSL : 1;
-      uint32_t hAcc : 1;
-      uint32_t vAcc : 1;
-    } bits;
-  } moduleQueried;
-} UBX_NAV_POSLLH_moduleQueried_t;
-
-typedef struct
-{
-	ubxAutomaticFlags automaticFlags;
-  UBX_NAV_POSLLH_data_t data;
-  UBX_NAV_POSLLH_moduleQueried_t moduleQueried;
-  void (*callbackPointer)(UBX_NAV_POSLLH_data_t);
-  UBX_NAV_POSLLH_data_t  *callbackData;
-} UBX_NAV_POSLLH_t;
-
-// UBX-NAV-STATUS (0x01 0x03): Receiver navigation status
-const uint16_t UBX_NAV_STATUS_LEN = 16;
-
-typedef struct
-{
-  uint32_t iTOW; // GPS time of week of the navigation epoch: ms
-  uint8_t gpsFix; // GPSfix Type: 0x00 = no fix; 0x01 = dead reckoning only; 0x02 = 2D-fix; 0x03 = 3D-fix
-                  // 0x04 = GPS + dead reckoning combined; 0x05 = Time only fix; 0x06..0xff = reserved
-  union
-  {
-    uint8_t all;
-    struct
-    {
-      uint8_t gpsFixOk : 1; // 1 = position and velocity valid and within DOP and ACC Masks.
-      uint8_t diffSoln : 1; // 1 = differential corrections were applied
-      uint8_t wknSet : 1; // 1 = Week Number valid (see Time Validity section for details)
-      uint8_t towSet : 1; // 1 = Time of Week valid (see Time Validity section for details)
-    } bits;
-  } flags;
-  union
-  {
-    uint8_t all;
-    struct
-    {
-      uint8_t diffCorr : 1; // 1 = differential corrections available
-      uint8_t carrSolnValid : 1; // 1 = valid carrSoln
-      uint8_t reserved : 4;
-      uint8_t mapMatching : 2; // map matching status: 00: none
-                               // 01: valid but not used, i.e. map matching data was received, but was too old
-                               // 10: valid and used, map matching data was applied
-                               // 11: valid and used, map matching data was applied.
-    } bits;
-  } fixStat;
-  union
-  {
-    uint8_t all;
-    struct
-    {
-      uint8_t psmState : 2; // power save mode state
-                            // 0: ACQUISITION [or when psm disabled]
-                            // 1: TRACKING
-                            // 2: POWER OPTIMIZED TRACKING
-                            // 3: INACTIVE
-      uint8_t reserved1 : 1;
-      uint8_t spoofDetState : 2; // Spoofing detection state
-                                 // 0: Unknown or deactivated
-                                 // 1: No spoofing indicated
-                                 // 2: Spoofing indicated
-                                 // 3: Multiple spoofing indications
-      uint8_t reserved2 : 1;
-      uint8_t carrSoln : 2; // Carrier phase range solution status:
-                            // 0: no carrier phase range solution
-                            // 1: carrier phase range solution with floating ambiguities
-                            // 2: carrier phase range solution with fixed ambiguities
-    } bits;
-  } flags2;
-  uint32_t ttff; // Time to first fix (millisecond time tag): ms
-  uint32_t msss; // Milliseconds since Startup / Reset: ms
-} UBX_NAV_STATUS_data_t;
-
-typedef struct
-{
-  union
-  {
-    uint32_t all;
-    struct
-    {
-      uint32_t all : 1;
-
-      uint32_t iTOW : 1;
-      uint32_t gpsFix : 1;
-
-      uint32_t gpsFixOk : 1;
-      uint32_t diffSoln : 1;
-      uint32_t wknSet : 1;
-      uint32_t towSet : 1;
-
-      uint32_t diffCorr : 1;
-      uint32_t carrSolnValid : 1;
-      uint32_t mapMatching : 1;
-
-      uint32_t psmState : 1;
-      uint32_t spoofDetState : 1;
-      uint32_t carrSoln : 1;
-
-      uint32_t ttff : 1;
-      uint32_t msss : 1;
-    } bits;
-  } moduleQueried;
-} UBX_NAV_STATUS_moduleQueried_t;
-
-typedef struct
-{
-	ubxAutomaticFlags automaticFlags;
-  UBX_NAV_STATUS_data_t data;
-  UBX_NAV_STATUS_moduleQueried_t moduleQueried;
-  void (*callbackPointer)(UBX_NAV_STATUS_data_t);
-  UBX_NAV_STATUS_data_t  *callbackData;
-} UBX_NAV_STATUS_t;
-
-// UBX-NAV-DOP (0x01 0x04): Dilution of precision
-const uint16_t UBX_NAV_DOP_LEN = 18;
-
-typedef struct
-{
-  uint32_t iTOW; // GPS time of week of the navigation epoch: ms
-  uint16_t gDOP; // Geometric DOP: * 0.01
-  uint16_t pDOP; // Position DOP: * 0.01
-  uint16_t tDOP; // Time DOP: * 0.01
-  uint16_t vDOP; // Vertical DOP: * 0.01
-  uint16_t hDOP; // Horizontal DOP: * 0.01
-  uint16_t nDOP; // Northing DOP: * 0.01
-  uint16_t eDOP; // Easting DOP: * 0.01
-} UBX_NAV_DOP_data_t;
-
-typedef struct
-{
-  union
-  {
-    uint32_t all;
-    struct
-    {
-      uint32_t all : 1;
-
-      uint32_t iTOW : 1;
-      uint32_t gDOP : 1;
-      uint32_t pDOP : 1;
-      uint32_t tDOP : 1;
-      uint32_t vDOP : 1;
-      uint32_t hDOP : 1;
-      uint32_t nDOP : 1;
-      uint32_t eDOP : 1;
-    } bits;
-  } moduleQueried;
-} UBX_NAV_DOP_moduleQueried_t;
-
-typedef struct
-{
-  ubxAutomaticFlags automaticFlags;
-  UBX_NAV_DOP_data_t data;
-  UBX_NAV_DOP_moduleQueried_t moduleQueried;
-  void (*callbackPointer)(UBX_NAV_DOP_data_t);
-  UBX_NAV_DOP_data_t  *callbackData;
-} UBX_NAV_DOP_t;
-
-// UBX-NAV-ATT (0x01 0x05): Attitude solution
-const uint16_t UBX_NAV_ATT_LEN = 32;
-
-typedef struct
-{
-  uint32_t iTOW; // GPS time of week of the navigation epoch: ms
-  uint8_t version; // Message version (0x00 for this version)
-  uint8_t reserved1[3];
-  int32_t roll; // Vehicle roll: Degrees * 1e-5
-  int32_t pitch; // Vehicle pitch: Degrees * 1e-5
-  int32_t heading; // Vehicle heading: Degrees * 1e-5
-  uint32_t accRoll; // Vehicle roll accuracy (if null, roll angle is not available): Degrees * 1e-5
-  uint32_t accPitch; // Vehicle pitch accuracy (if null, roll angle is not available): Degrees * 1e-5
-  uint32_t accHeading; // Vehicle heading accuracy (if null, roll angle is not available): Degrees * 1e-5
-} UBX_NAV_ATT_data_t;
-
-typedef struct
-{
-  union
-  {
-    uint32_t all;
-    struct
-    {
-      uint32_t all : 1;
-
-      uint32_t iTOW : 1;
-      uint32_t version : 1;
-      uint32_t roll : 1;
-      uint32_t pitch : 1;
-      uint32_t heading : 1;
-      uint32_t accRoll : 1;
-      uint32_t accPitch : 1;
-      uint32_t accHeading : 1;
-    } bits;
-  } moduleQueried;
-} UBX_NAV_ATT_moduleQueried_t;
-
-typedef struct
-{
-  ubxAutomaticFlags automaticFlags;
-  UBX_NAV_ATT_data_t data;
-  UBX_NAV_ATT_moduleQueried_t moduleQueried;
-  void (*callbackPointer)(UBX_NAV_ATT_data_t);
-  UBX_NAV_ATT_data_t  *callbackData;
-} UBX_NAV_ATT_t;
-
-// UBX-NAV-PVT (0x01 0x07): Navigation position velocity time solution
-const uint16_t UBX_NAV_PVT_LEN = 92;
-
-typedef struct
-{
-  uint32_t iTOW; // GPS time of week of the navigation epoch: ms
-  uint16_t year; // Year (UTC)
-  uint8_t month; // Month, range 1..12 (UTC)
-  uint8_t day; // Day of month, range 1..31 (UTC)
-  uint8_t hour; // Hour of day, range 0..23 (UTC)
-  uint8_t min; // Minute of hour, range 0..59 (UTC)
-  uint8_t sec; // Seconds of minute, range 0..60 (UTC)
-  union
-  {
-    uint8_t all;
-    struct
-    {
-      uint8_t validDate : 1; // 1 = valid UTC Date
-      uint8_t validTime : 1; // 1 = valid UTC time of day
-      uint8_t fullyResolved : 1; // 1 = UTC time of day has been fully resolved (no seconds uncertainty).
-      uint8_t validMag : 1; // 1 = valid magnetic declination
-    } bits;
-  } valid;
-  uint32_t tAcc; // Time accuracy estimate (UTC): ns
-  int32_t nano; // Fraction of second, range -1e9 .. 1e9 (UTC): ns
-  uint8_t fixType; // GNSSfix Type:
-                      // 0: no fix
-                      // 1: dead reckoning only
-                      // 2: 2D-fix
-                      // 3: 3D-fix
-                      // 4: GNSS + dead reckoning combined
-                      // 5: time only fix
-  union
-  {
-    uint8_t all;
-    struct
-    {
-      uint8_t gnssFixOK : 1; // 1 = valid fix (i.e within DOP & accuracy masks)
-      uint8_t diffSoln : 1; // 1 = differential corrections were applied
-      uint8_t psmState : 3;
-      uint8_t headVehValid : 1; // 1 = heading of vehicle is valid, only set if the receiver is in sensor fusion mode
-      uint8_t carrSoln : 2; // Carrier phase range solution status:
-                              // 0: no carrier phase range solution
-                              // 1: carrier phase range solution with floating ambiguities
-                              // 2: carrier phase range solution with fixed ambiguities
-    } bits;
-  } flags;
-  union
-  {
-    uint8_t all;
-    struct
-    {
-      uint8_t reserved : 5;
-      uint8_t confirmedAvai : 1; // 1 = information about UTC Date and Time of Day validity confirmation is available
-      uint8_t confirmedDate : 1; // 1 = UTC Date validity could be confirmed
-      uint8_t confirmedTime : 1; // 1 = UTC Time of Day could be confirmed
-    } bits;
-  } flags2;
-  uint8_t numSV; // Number of satellites used in Nav Solution
-  int32_t lon; // Longitude: deg * 1e-7
-  int32_t lat; // Latitude: deg * 1e-7
-  int32_t height; // Height above ellipsoid: mm
-  int32_t hMSL; // Height above mean sea level: mm
-  uint32_t hAcc; // Horizontal accuracy estimate: mm
-  uint32_t vAcc; // Vertical accuracy estimate: mm
-  int32_t velN; // NED north velocity: mm/s
-  int32_t velE; // NED east velocity: mm/s
-  int32_t velD; // NED down velocity: mm/s
-  int32_t gSpeed; // Ground Speed (2-D): mm/s
-  int32_t headMot; // Heading of motion (2-D): deg * 1e-5
-  uint32_t sAcc; // Speed accuracy estimate: mm/s
-  uint32_t headAcc; // Heading accuracy estimate (both motion and vehicle): deg * 1e-5
-  uint16_t pDOP; // Position DOP * 0.01
-  union
-  {
-    uint8_t all;
-    struct
-    {
-      uint8_t invalidLlh : 1; // 1 = Invalid lon, lat, height and hMSL
-    } bits;
-  } flags3;
-  uint8_t reserved1[5];
-  int32_t headVeh; // Heading of vehicle (2-D): deg * 1e-5
-  int16_t magDec; // Magnetic declination: deg * 1e-2
-  uint16_t magAcc; // Magnetic declination accuracy: deg * 1e-2
-} UBX_NAV_PVT_data_t;
-
-typedef struct
-{
-  union
-  {
-    uint32_t all;
-    struct
-    {
-      uint32_t all : 1;
-
-      uint32_t iTOW : 1;
-      uint32_t year : 1;
-      uint32_t month : 1;
-      uint32_t day : 1;
-      uint32_t hour : 1;
-      uint32_t min : 1;
-      uint32_t sec : 1;
-
-      uint32_t validDate : 1;
-      uint32_t validTime : 1;
-      uint32_t fullyResolved : 1;
-      uint32_t validMag : 1;
-
-      uint32_t tAcc : 1;
-      uint32_t nano : 1;
-      uint32_t fixType : 1;
-      uint32_t gnssFixOK : 1;
-      uint32_t diffSoln : 1;
-      uint32_t psmState : 1;
-      uint32_t headVehValid : 1;
-      uint32_t carrSoln : 1;
-
-      uint32_t confirmedAvai : 1;
-      uint32_t confirmedDate : 1;
-      uint32_t confirmedTime : 1;
-
-      uint32_t numSV : 1;
-      uint32_t lon : 1;
-      uint32_t lat : 1;
-      uint32_t height : 1;
-      uint32_t hMSL : 1;
-      uint32_t hAcc : 1;
-      uint32_t vAcc : 1;
-      uint32_t velN : 1;
-      uint32_t velE : 1;
-    } bits;
-  }  moduleQueried1;
-  union
-  {
-    uint32_t all;
-    struct
-    {
-      uint32_t velD : 1;
-      uint32_t gSpeed : 1;
-      uint32_t headMot : 1;
-      uint32_t sAcc : 1;
-      uint32_t headAcc : 1;
-      uint32_t pDOP : 1;
-
-      uint32_t invalidLlh : 1;
-
-      uint32_t headVeh : 1;
-      uint32_t magDec : 1;
-      uint32_t magAcc : 1;
-    } bits;
-  } moduleQueried2;
-} UBX_NAV_PVT_moduleQueried_t;
-
-typedef struct
-{
-	ubxAutomaticFlags automaticFlags;
-  UBX_NAV_PVT_data_t data;
-  UBX_NAV_PVT_moduleQueried_t moduleQueried;
-  void (*callbackPointer)(UBX_NAV_PVT_data_t);
-  UBX_NAV_PVT_data_t  *callbackData;
-} UBX_NAV_PVT_t;
-
-// UBX-NAV-ODO (0x01 0x09): Odometer solution
-const uint16_t UBX_NAV_ODO_LEN = 20;
-
-typedef struct
-{
-  uint8_t version; // Message version (0x00 for this version)
-  uint8_t reserved1[3];
-  uint32_t iTOW; // GPS time of week of the navigation epoch: ms
-  uint32_t distance; // Ground distance since last reset: m
-  uint32_t totalDistance; // Total cumulative ground distance: m
-  uint32_t distanceStd; // Ground distance accuracy (1-sigma): m
-} UBX_NAV_ODO_data_t;
-
-typedef struct
-{
-  union
-  {
-    uint32_t all;
-    struct
-    {
-      uint32_t all : 1;
-
-      uint32_t version : 1;
-      uint32_t iTOW : 1;
-      uint32_t distance : 1;
-      uint32_t totalDistance : 1;
-      uint32_t distanceStd : 1;
-    } bits;
-  } moduleQueried;
-} UBX_NAV_ODO_moduleQueried_t;
-
-typedef struct
-{
-	ubxAutomaticFlags automaticFlags;
-  UBX_NAV_ODO_data_t data;
-  UBX_NAV_ODO_moduleQueried_t moduleQueried;
-  void (*callbackPointer)(UBX_NAV_ODO_data_t);
-  UBX_NAV_ODO_data_t  *callbackData;
-} UBX_NAV_ODO_t;
-
-// UBX-NAV-VELECEF (0x01 0x11): Velocity solution in ECEF
-const uint16_t UBX_NAV_VELECEF_LEN = 20;
-
-typedef struct
-{
-  uint32_t iTOW; // GPS time of week of the navigation epoch: ms
-  int32_t ecefVX; // ECEF X velocity: cm/s
-  int32_t ecefVY; // ECEF Y velocity: cm/s
-  int32_t ecefVZ; // ECEF Z velocity: cm/s
-  uint32_t sAcc; // Speed accuracy estimate: cm/s
-} UBX_NAV_VELECEF_data_t;
-
-typedef struct
-{
-  union
-  {
-    uint32_t all;
-    struct
-    {
-      uint32_t all : 1;
-
-      uint32_t iTOW : 1;
-      uint32_t ecefVX : 1;
-      uint32_t ecefVY : 1;
-      uint32_t ecefVZ : 1;
-      uint32_t sAcc : 1;
-    } bits;
-  } moduleQueried;
-} UBX_NAV_VELECEF_moduleQueried_t;
-
-typedef struct
-{
-	ubxAutomaticFlags automaticFlags;
-  UBX_NAV_VELECEF_data_t data;
-  UBX_NAV_VELECEF_moduleQueried_t moduleQueried;
-  void (*callbackPointer)(UBX_NAV_VELECEF_data_t);
-  UBX_NAV_VELECEF_data_t  *callbackData;
-} UBX_NAV_VELECEF_t;
-
-// UBX-NAV-VELNED (0x01 0x12): Velocity solution in NED frame
-const uint16_t UBX_NAV_VELNED_LEN = 36;
-
-typedef struct
-{
-  uint32_t iTOW; // GPS time of week of the navigation epoch: ms
-  int32_t velN; // North velocity component: cm/s
-  int32_t velE; // East velocity component: cm/s
-  int32_t velD; // Down velocity component: cm/s
-  uint32_t speed; // Speed (3-D): cm/s
-  uint32_t gSpeed; // Ground Speed (2-D): cm/s
-  int32_t heading; // Heading of motion 2-D: Degrees * 1e-5
-  uint32_t sAcc; // Speed accuracy estimate: cm/s
-  uint32_t cAcc; // Course/Heading accuracy estimate: Degrees * 1e-5
-} UBX_NAV_VELNED_data_t;
-
-typedef struct
-{
-  union
-  {
-    uint32_t all;
-    struct
-    {
-      uint32_t all : 1;
-
-      uint32_t iTOW : 1;
-      uint32_t velN : 1;
-      uint32_t velE : 1;
-      uint32_t velD : 1;
-      uint32_t speed : 1;
-      uint32_t gSpeed : 1;
-      uint32_t heading : 1;
-      uint32_t sAcc : 1;
-      uint32_t cAcc : 1;
-    } bits;
-  } moduleQueried;
-} UBX_NAV_VELNED_moduleQueried_t;
-
-typedef struct
-{
-	ubxAutomaticFlags automaticFlags;
-  UBX_NAV_VELNED_data_t data;
-  UBX_NAV_VELNED_moduleQueried_t moduleQueried;
-  void (*callbackPointer)(UBX_NAV_VELNED_data_t);
-  UBX_NAV_VELNED_data_t  *callbackData;
-} UBX_NAV_VELNED_t;
-
-// UBX-NAV-HPPOSECEF (0x01 0x13): High precision position solution in ECEF
-const uint16_t UBX_NAV_HPPOSECEF_LEN = 28;
-
-typedef struct
-{
-  uint8_t version; // Message version (0x00 for this version)
-  uint8_t reserved1[3];
-  uint32_t iTOW; // GPS time of week of the navigation epoch: ms
-  int32_t ecefX; // ECEF X coordinate: cm
-  int32_t ecefY; // ECEF Y coordinate: cm
-  int32_t ecefZ; // ECEF Z coordinate: cm
-  int8_t ecefXHp; // High precision component of ECEF X coordinate: mm * 0.1
-  int8_t ecefYHp; // High precision component of ECEF Y coordinate: mm * 0.1
-  int8_t ecefZHp; // High precision component of ECEF Z coordinate: mm * 0.1
-  union
-  {
-    uint8_t all;
-    struct
-    {
-      uint8_t invalidEcef : 1; // 1 = Invalid ecefX, ecefY, ecefZ, ecefXHp, ecefYHp and ecefZHp
-    } bits;
-  } flags;
-  uint32_t pAcc; // Position Accuracy Estimate: mm * 0.1
-} UBX_NAV_HPPOSECEF_data_t;
-
-typedef struct
-{
-  union
-  {
-    uint32_t all;
-    struct
-    {
-      uint32_t all : 1;
-
-      uint32_t version : 1;
-      uint32_t iTOW : 1;
-      uint32_t ecefX : 1;
-      uint32_t ecefY : 1;
-      uint32_t ecefZ : 1;
-      uint32_t ecefXHp : 1;
-      uint32_t ecefYHp : 1;
-      uint32_t ecefZHp : 1;
-
-      uint32_t invalidEcef : 1;
-
-      uint32_t pAcc : 1;
-    } bits;
-  } moduleQueried;
-} UBX_NAV_HPPOSECEF_moduleQueried_t;
-
-typedef struct
-{
-	ubxAutomaticFlags automaticFlags;
-  UBX_NAV_HPPOSECEF_data_t data;
-  UBX_NAV_HPPOSECEF_moduleQueried_t moduleQueried;
-  void (*callbackPointer)(UBX_NAV_HPPOSECEF_data_t);
-  UBX_NAV_HPPOSECEF_data_t  *callbackData;
-} UBX_NAV_HPPOSECEF_t;
-
-// UBX-NAV-HPPOSLLH (0x01 0x14): High precision geodetic position solution
-const uint16_t UBX_NAV_HPPOSLLH_LEN = 36;
-
-typedef struct
-{
-  uint8_t version; // Message version (0x00 for this version)
-  uint8_t reserved1[2];
-  union
-  {
-    uint8_t all;
-    struct
-    {
-      uint8_t invalidLlh : 1; // 1 = Invalid lon, lat, height, hMSL, lonHp, latHp, heightHp and hMSLHp
-    } bits;
-  } flags;
-  uint32_t iTOW; // GPS time of week of the navigation epoch: ms
-  int32_t lon; // Longitude: deg * 1e-7
-  int32_t lat; // Latitude: deg * 1e-7
-  int32_t height; // Height above ellipsoid: mm
-  int32_t hMSL; // Height above mean sea level: mm
-  int8_t lonHp; // High precision component of longitude: deg * 1e-9
-  int8_t latHp; // High precision component of latitude: deg * 1e-9
-  int8_t heightHp; // High precision component of height above ellipsoid: mm * 0.1
-  int8_t hMSLHp; // High precision component of height above mean sea level: mm * 0.1
-  uint32_t hAcc; // Horizontal accuracy estimate: mm * 0.1
-  uint32_t vAcc; // Vertical accuracy estimate: mm * 0.1
-} UBX_NAV_HPPOSLLH_data_t;
-
-typedef struct
-{
-  union
-  {
-    uint32_t all;
-    struct
-    {
-      uint32_t all : 1;
-
-      uint32_t version : 1;
-
-      uint32_t invalidLlh : 1;
-
-      uint32_t iTOW : 1;
-      uint32_t lon : 1;
-      uint32_t lat : 1;
-      uint32_t height : 1;
-      uint32_t hMSL : 1;
-      uint32_t lonHp : 1;
-      uint32_t latHp : 1;
-      uint32_t heightHp : 1;
-      uint32_t hMSLHp : 1;
-      uint32_t hAcc : 1;
-      uint32_t vAcc : 1;
-    } bits;
-  } moduleQueried;
-} UBX_NAV_HPPOSLLH_moduleQueried_t;
-
-typedef struct
-{
-	ubxAutomaticFlags automaticFlags;
-  UBX_NAV_HPPOSLLH_data_t data;
-  UBX_NAV_HPPOSLLH_moduleQueried_t moduleQueried;
-  void (*callbackPointer)(UBX_NAV_HPPOSLLH_data_t);
-  UBX_NAV_HPPOSLLH_data_t  *callbackData;
-} UBX_NAV_HPPOSLLH_t;
-
-// UBX-NAV-TIMEUTC (0x01 0x21): UTC time solution
-const uint16_t UBX_NAV_TIMEUTC_LEN = 20;
-
-typedef struct
-{
-  uint32_t iTOW; // GPS time of week of the navigation epoch: ms
-  uint32_t tAcc; // Time accuracy estimate (UTC): ns
-  int32_t nano; // Fraction of second, range -1e9 .. 1e9 (UTC): ns
-  uint16_t year; // Year (UTC)
-  uint8_t month; // Month, range 1..12 (UTC)
-  uint8_t day; // Day of month, range 1..31 (UTC)
-  uint8_t hour; // Hour of day, range 0..23 (UTC)
-  uint8_t min; // Minute of hour, range 0..59 (UTC)
-  uint8_t sec; // Seconds of minute, range 0..60 (UTC)
-  union
-  {
-    uint8_t all;
-    struct
-    {
-      uint8_t validTOW : 1; // 1 = Valid Time of Week
-      uint8_t validWKN : 1; // 1 = Valid Week Number
-      uint8_t validUTC : 1; // 1 = Valid UTC Time
-      uint8_t reserved : 1;
-      uint8_t utcStandard : 4; // UTC standard identifier
-    } bits;
-  } valid;
-} UBX_NAV_TIMEUTC_data_t;
-
-typedef struct
-{
-  union
-  {
-    uint32_t all;
-    struct
-    {
-      uint32_t all : 1;
-
-      uint32_t iTOW : 1;
-      uint32_t tAcc : 1;
-      uint32_t nano : 1;
-      uint32_t year : 1;
-      uint32_t month : 1;
-      uint32_t day : 1;
-      uint32_t hour : 1;
-      uint32_t min : 1;
-      uint32_t sec : 1;
-
-      uint32_t validTOW : 1;
-      uint32_t validWKN : 1;
-      uint32_t validUTC : 1;
-      uint32_t utcStandard : 1;
-    } bits;
-  }  moduleQueried;
-} UBX_NAV_TIMEUTC_moduleQueried_t;
-
-typedef struct
-{
-	ubxAutomaticFlags automaticFlags;
-  UBX_NAV_TIMEUTC_data_t data;
-  UBX_NAV_TIMEUTC_moduleQueried_t moduleQueried;
-  void (*callbackPointer)(UBX_NAV_TIMEUTC_data_t);
-  UBX_NAV_TIMEUTC_data_t  *callbackData;
-} UBX_NAV_TIMEUTC_t;
-
-// UBX-NAV-CLOCK (0x01 0x22): Clock solution
-const uint16_t UBX_NAV_CLOCK_LEN = 20;
-
-typedef struct
-{
-  uint32_t iTOW; // GPS time of week of the navigation epoch: ms
-  int32_t clkB; // Clock bias: ns
-  int32_t clkD; // Clock drift: ns/s
-  uint32_t tAcc; // Time accuracy estimate: ns
-  uint32_t fAcc; // Frequency accuracy estimate: ps/s
-} UBX_NAV_CLOCK_data_t;
-
-typedef struct
-{
-  union
-  {
-    uint32_t all;
-    struct
-    {
-      uint32_t all : 1;
-
-      uint32_t iTOW : 1;
-      uint32_t clkB : 1;
-      uint32_t clkD : 1;
-      uint32_t tAcc : 1;
-      uint32_t fAcc : 1;
-    } bits;
-  } moduleQueried;
-} UBX_NAV_CLOCK_moduleQueried_t;
-
-typedef struct
-{
-	ubxAutomaticFlags automaticFlags;
-  UBX_NAV_CLOCK_data_t data;
-  UBX_NAV_CLOCK_moduleQueried_t moduleQueried;
-  void (*callbackPointer)(UBX_NAV_CLOCK_data_t);
-  UBX_NAV_CLOCK_data_t  *callbackData;
-} UBX_NAV_CLOCK_t;
-
-// UBX-NAV-SVIN (0x01 0x3B): Survey-in data
-const uint16_t UBX_NAV_SVIN_LEN = 40;
-
-typedef struct
-{
-  uint8_t version; // Message version (0x00 for this version)
-  uint8_t reserved1[3];
-  uint32_t iTOW; // GPS time of week of the navigation epoch: ms
-  uint32_t dur; // Passed survey-in observation time: s
-  int32_t meanX; // Current survey-in mean position ECEF X coordinate: cm
-  int32_t meanY; // Current survey-in mean position ECEF Y coordinate: cm
-  int32_t meanZ; // Current survey-in mean position ECEF Z coordinate: cm
-  int8_t meanXHP; // Current high-precision survey-in mean position ECEF X coordinate: mm * 0.1
-  int8_t meanYHP; // Current high-precision survey-in mean position ECEF Y coordinate: mm * 0.1
-  int8_t meanZHP; // Current high-precision survey-in mean position ECEF Z coordinate: mm * 0.1
-  uint8_t reserved2;
-  uint32_t meanAcc; // Current survey-in mean position accuracy: mm * 0.1
-  uint32_t obs; // Number of position observations used during survey-in
-  int8_t valid; // Survey-in position validity flag, 1 = valid, otherwise 0
-  int8_t active; // Survey-in in progress flag, 1 = in-progress, otherwise 0
-  uint8_t reserved3[2];
-} UBX_NAV_SVIN_data_t;
-
-typedef struct
-{
-  union
-  {
-    uint32_t all;
-    struct
-    {
-      uint32_t all : 1;
-
-      uint32_t version : 1;
-      uint32_t iTOW : 1;
-      uint32_t dur : 1;
-      uint32_t meanX : 1;
-      uint32_t meanY : 1;
-      uint32_t meanZ : 1;
-      uint32_t meanXHP : 1;
-      uint32_t meanYHP : 1;
-      uint32_t meanZHP : 1;
-      uint32_t meanAcc : 1;
-      uint32_t obs : 1;
-      uint32_t valid : 1;
-      uint32_t active : 1;
-    } bits;
-  } moduleQueried;
-} UBX_NAV_SVIN_moduleQueried_t;
-
-typedef struct
-{
-	ubxAutomaticFlags automaticFlags;
-  UBX_NAV_SVIN_data_t data;
-  UBX_NAV_SVIN_moduleQueried_t moduleQueried;
-  void (*callbackPointer)(UBX_NAV_SVIN_data_t);
-  UBX_NAV_SVIN_data_t  *callbackData;
-} UBX_NAV_SVIN_t;
-
-// UBX-NAV-RELPOSNED (0x01 0x3C): Relative positioning information in NED frame
-// Note:
-//  RELPOSNED on the M8 is only 40 bytes long
-//  RELPOSNED on the F9 is 64 bytes long and contains much more information
-const uint16_t UBX_NAV_RELPOSNED_LEN = 40;
-const uint16_t UBX_NAV_RELPOSNED_LEN_F9 = 64;
-
-typedef struct
-{
-  uint8_t version; // Message version (0x00 for this version)
-  uint8_t reserved0;
-  uint16_t refStationId; // Reference Station ID
-  uint32_t iTOW; // GPS time of week of the navigation epoch: ms
-  int32_t relPosN; // North component of relative position vector: cm
-  int32_t relPosE; // East component of relative position vector: cm
-  int32_t relPosD; // Down component of relative position vector: cm
-  int32_t relPosLength; // Length of the relative position vector: cm
-  int32_t relPosHeading; // Heading of the relative position vector: Degrees * 1e-5
-  uint8_t reserved1[4];
-  int8_t relPosHPN; // High-precision North component of relative position vector: mm * 0.1
-  int8_t relPosHPE; // High-precision East component of relative position vector: mm * 0.1
-  int8_t relPosHPD; // High-precision Down component of relative position vector: mm * 0.1
-  int8_t relPosHPLength; // High-precision component of the length of the relative position vector: mm * 0.1
-  uint32_t accN; // Accuracy of relative position North component: mm * 0.1
-  uint32_t accE; // Accuracy of relative position East component: mm * 0.1
-  uint32_t accD; // Accuracy of relative position Down component: mm * 0.1
-  uint32_t accLength; // Accuracy of length of the relative position vector: mm * 0.1
-  uint32_t accHeading; // Accuracy of heading of the relative position vector: Degrees * 1e-5
-  uint8_t reserved2[4];
-  union
-  {
-    uint32_t all;
-    struct
-    {
-      uint32_t gnssFixOK : 1; // A valid fix (i.e within DOP & accuracy masks)
-      uint32_t diffSoln : 1; // 1 if differential corrections were applied
-      uint32_t relPosValid : 1; // 1 if relative position components and accuracies are valid
-      uint32_t carrSoln : 2; // Carrier phase range solution status:
-                              // 0 = no carrier phase range solution
-                              // 1 = carrier phase range solution with floating ambiguities
-                              // 2 = carrier phase range solution with fixed ambiguities
-      uint32_t isMoving : 1; // 1 if the receiver is operating in moving baseline mode
-      uint32_t refPosMiss : 1; // 1 if extrapolated reference position was used to compute moving baseline solution this epoch
-      uint32_t refObsMiss : 1; // 1 if extrapolated reference observations were used to compute moving baseline solution this epoch
-      uint32_t relPosHeadingValid : 1; // 1 if relPosHeading is valid
-      uint32_t relPosNormalized : 1; // 1 if the components of the relative position vector (including the high-precision parts) are normalized
-    } bits;
-  } flags;
-} UBX_NAV_RELPOSNED_data_t;
-
-typedef struct
-{
-  union
-  {
-    uint32_t all;
-    struct
-    {
-      uint32_t all : 1;
-
-      uint32_t version : 1;
-      uint32_t refStationId : 1;
-      uint32_t iTOW : 1;
-      uint32_t relPosN : 1;
-      uint32_t relPosE : 1;
-      uint32_t relPosD : 1;
-      uint32_t relPosLength : 1;
-      uint32_t relPosHeading : 1;
-      uint32_t relPosHPN : 1;
-      uint32_t relPosHPE : 1;
-      uint32_t relPosHPD : 1;
-      uint32_t relPosHPLength : 1;
-      uint32_t accN : 1;
-      uint32_t accE : 1;
-      uint32_t accD : 1;
-      uint32_t accLength : 1;
-      uint32_t accHeading : 1;
-
-      uint32_t gnssFixOK : 1;
-      uint32_t diffSoln : 1;
-      uint32_t relPosValid : 1;
-      uint32_t carrSoln : 1;
-      uint32_t isMoving : 1;
-      uint32_t refPosMiss : 1;
-      uint32_t refObsMiss : 1;
-      uint32_t relPosHeadingValid : 1;
-      uint32_t relPosNormalized : 1;
-    } bits;
-  } moduleQueried;
-} UBX_NAV_RELPOSNED_moduleQueried_t;
-
-typedef struct
-{
-	ubxAutomaticFlags automaticFlags;
-  UBX_NAV_RELPOSNED_data_t data;
-  UBX_NAV_RELPOSNED_moduleQueried_t moduleQueried;
-  void (*callbackPointer)(UBX_NAV_RELPOSNED_data_t);
-  UBX_NAV_RELPOSNED_data_t  *callbackData;
-} UBX_NAV_RELPOSNED_t;
-
-// RXM-specific structs
-
-// UBX-RXM-SFRBX (0x02 0x13): Broadcast navigation data subframe
-// Note: length is variable
-// Note: on protocol version 17: numWords is (0..16)
-//       on protocol version 18+: numWords is (0..10)
-const uint8_t UBX_RXM_SFRBX_MAX_WORDS = 16;
-const uint16_t UBX_RXM_SFRBX_MAX_LEN = 8 + (4 * UBX_RXM_SFRBX_MAX_WORDS);
-
-typedef struct
-{
-  uint8_t gnssId; // GNSS identifier
-  uint8_t svId; // Satellite identifier
-  uint8_t reserved1;
-  uint8_t freqId; // GLONASS frequency slot
-  uint8_t numWords; // The number of data words contained in this message (0..16)
-  uint8_t chn; // The tracking channel number the message was received on
-  uint8_t version; // Message version (0x01 for this version)
-  uint8_t reserved2;
-  uint32_t dwrd[UBX_RXM_SFRBX_MAX_WORDS]; // The data words
-} UBX_RXM_SFRBX_data_t;
-
-typedef struct
-{
-	ubxAutomaticFlags automaticFlags;
-  UBX_RXM_SFRBX_data_t data;
-  boolean moduleQueried;
-  void (*callbackPointer)(UBX_RXM_SFRBX_data_t);
-  UBX_RXM_SFRBX_data_t  *callbackData;
-} UBX_RXM_SFRBX_t;
-
-// UBX-RXM-RAWX (0x02 0x15): Multi-GNSS raw measurement data
-// Note: length is variable
-const uint8_t UBX_RXM_RAWX_MAX_BLOCKS = 64; // GUESS! TO DO: find the correct value for this
-const uint16_t UBX_RXM_RAWX_MAX_LEN = 16 + (32 * UBX_RXM_RAWX_MAX_BLOCKS);
-
-typedef struct
-{
-  uint8_t rcvTow[8]; // Measurement time of week in receiver local time [64-bit float]
-  uint16_t week; // GPS week number
-  int8_t leapS; // GPS leap seconds
-  uint8_t numMeas; // Number of measurements to follow
-  union
-  {
-    uint8_t all;
-    struct
-    {
-      uint8_t leapSec : 1; // Leap seconds have been determined
-      uint8_t clkReset : 1; // Clock reset applied
-    } bits;
-  } recStat;
-  uint8_t version; // Message version (0x01 for this version)
-  uint8_t reserved1[2];
-} UBX_RXM_RAWX_header_t;
-
-typedef struct
-{
-  uint8_t prMes[8]; // Pseudorange measurement: m [64-bit float]
-  uint8_t cpMes[8]; // Carrier phase measurement: cycles [64-bit float]
-  uint8_t doMes[4]; // Doppler measurement: Hz [32-bit float]
-  uint8_t gnssId; // GNSS identifier
-  uint8_t svId; // Satellite identifier
-  uint8_t sigId; // New signal identifier
-  uint8_t freqId; // GLONASS frequency slot
-  uint16_t lockTime; // Carrier phase locktime counter: ms
-  uint8_t cno; // Carrier-to-noise density ratio: dB-Hz
-  uint8_t prStdev; // Estimated pseudorange measurement standard deviation: m * 0.01 * 2^n [4-bit]
-  uint8_t cpStdev; // Estimated carrier phase measurement standard deviation: cycles * 0.004 [4-bit]
-  uint8_t doStdev; // Estimated Doppler measurement standard deviation: Hz * 0.002 * 2^n [4-bit]
-  union
-  {
-    uint8_t all;
-    struct
-    {
-      uint8_t prValid : 1; // Pseudorange valid
-      uint8_t cpValid : 1; // Carrier phase valid
-      uint8_t halfCyc : 1; // Half cycle valid
-      uint8_t subHalfCyc : 1; // Half cycle subtracted from phase
-    } bits;
-  } trkStat;
-  uint8_t reserved2;
-} UBX_RXM_RAWX_block_t;
-
-typedef struct
-{
-  UBX_RXM_RAWX_header_t header;
-  UBX_RXM_RAWX_block_t blocks[UBX_RXM_RAWX_MAX_BLOCKS];
-} UBX_RXM_RAWX_data_t;
-
-typedef struct
-{
-	ubxAutomaticFlags automaticFlags;
-  UBX_RXM_RAWX_data_t data;
-  boolean moduleQueried;
-  void (*callbackPointer)(UBX_RXM_RAWX_data_t);
-  UBX_RXM_RAWX_data_t  *callbackData;
-} UBX_RXM_RAWX_t;
-
-// CFG-specific structs
-
-// UBX-CFG-RATE (0x06 0x08): Navigation/measurement rate settings
-const uint16_t UBX_CFG_RATE_LEN = 6;
-
-typedef struct
-{
-  uint16_t measRate; // The elapsed time between GNSS measurements, which defines the rate: ms
-  uint16_t navRate; // The ratio between the number of measurements and the number of navigation solutions: cycles
-  uint16_t timeRef; // The time system to which measurements are aligned: 0: UTC; 1: GPS; 2: GLONASS; 3: BeiDou; 4: Galileo
-} UBX_CFG_RATE_data_t;
-
-typedef struct
-{
-  union
-  {
-    uint32_t all;
-    struct
-    {
-      uint32_t all : 1;
-
-      uint32_t measRate : 1;
-      uint32_t navRate : 1;
-      uint32_t timeRef : 1;
-    } bits;
-  } moduleQueried;
-} UBX_CFG_RATE_moduleQueried_t;
-
-typedef struct
-{
-	ubxAutomaticFlags automaticFlags;
-  UBX_CFG_RATE_data_t data;
-  UBX_CFG_RATE_moduleQueried_t moduleQueried;
-  void (*callbackPointer)(UBX_CFG_RATE_data_t);
-  UBX_CFG_RATE_data_t  *callbackData;
-} UBX_CFG_RATE_t;
-
-// TIM-specific structs
-
-// UBX-TIM-TM2 (0x0D 0x03): Time mark data
-const uint16_t UBX_TIM_TM2_LEN = 28;
-
-typedef struct
-{
-  uint8_t ch; // Channel (i.e. EXTINT) upon which the pulse was measured
-  union
-  {
-    uint8_t all;
-    struct
-    {
-      uint8_t mode : 1; // 0=single; 1=running
-      uint8_t run : 1; // 0=armed; 1=stopped
-      uint8_t newFallingEdge : 1; // New falling edge detected
-      uint8_t timeBase : 2; // 0=Time base is Receiver time; 1=Time base is GNSS time; 2=Time base is UTC
-      uint8_t utc : 1; // 0=UTC not available; 1=UTC available
-      uint8_t time : 1; // 0=Time is not valid; 1=Time is valid (Valid GNSS fix)
-      uint8_t newRisingEdge : 1; // New rising edge detected
-    } bits;
-  } flags;
-  uint16_t count; // Rising edge counter
-  uint16_t wnR; // Week number of last rising edge
-  uint16_t wnF; // Week number of last falling edge
-  uint32_t towMsR; // TOW of rising edge: ms
-  uint32_t towSubMsR; // Millisecond fraction of tow of rising edge: ns
-  uint32_t towMsF; // TOW of falling edge: ms
-  uint32_t towSubMsF; // Millisecond fraction of tow of falling edge: ns
-  uint32_t accEst; // Accuracy estimate: ns
-} UBX_TIM_TM2_data_t;
-
-typedef struct
-{
-  union
-  {
-    uint32_t all;
-    struct
-    {
-      uint32_t all : 1;
-
-      uint32_t ch : 1;
-      uint32_t mode : 1;
-      uint32_t run : 1;
-      uint32_t newFallingEdge : 1;
-      uint32_t timeBase : 1;
-      uint32_t utc : 1;
-      uint32_t time : 1;
-      uint32_t newRisingEdge : 1;
-
-      uint32_t count : 1;
-      uint32_t wnR : 1;
-      uint32_t wnF : 1;
-      uint32_t towMsR : 1;
-      uint32_t towSubMsR : 1;
-      uint32_t towMsF : 1;
-      uint32_t towSubMsF : 1;
-      uint32_t accEst : 1;
-    } bits;
-  } moduleQueried;
-} UBX_TIM_TM2_moduleQueried_t;
-
-typedef struct
-{
-	ubxAutomaticFlags automaticFlags;
-  UBX_TIM_TM2_data_t data;
-  UBX_TIM_TM2_moduleQueried_t moduleQueried;
-  void (*callbackPointer)(UBX_TIM_TM2_data_t);
-  UBX_TIM_TM2_data_t  *callbackData;
-} UBX_TIM_TM2_t;
-
-// ESF-specific structs
-
-// UBX-ESF-ALG (0x10 0x14): IMU alignment information
-const uint16_t UBX_ESF_ALG_LEN = 16;
-
-typedef struct
-{
-  uint32_t iTOW; // GPS time of week of the HNR epoch: ms
-  uint8_t version; // Message version (0x01 for this version)
-  union
-  {
-    uint8_t all;
-    struct
-    {
-      uint8_t autoMntAlgOn : 1; // Automatic IMU-mount alignment on/off bit
-      uint8_t status : 3; // Status of the IMU-mount alignment
-                          //   0: user-defined/fixed angles are used
-                          //   1: IMU-mount roll/pitch angles alignment is ongoing
-                          //   2: IMU-mount roll/pitch/yaw angles alignment is ongoing
-                          //   3: coarse IMU-mount alignment are used
-                          //   4: fine IMU-mount alignment are used
-    } bits;
-  } flags;
-  union
-  {
-    uint8_t all;
-    struct
-    {
-      uint8_t tiltAlgError : 1; // IMU-mount tilt (roll and/or pitch) alignment error (0: no error, 1: error)
-      uint8_t yawAlgError : 1; // IMU-mount yaw alignment error (0: no error, 1: error)
-      uint8_t angleError : 1; // IMU-mount misalignment Euler angle singularity error (0: no error, 1: error)
-    } bits;
-  } error;
-  uint8_t reserved1;
-  uint32_t yaw; // IMU-mount yaw angle [0, 360]: Degrees * 1e-2
-  int16_t pitch; // IMU-mount pitch angle [-90, 90]: Degrees * 1e-2
-  int16_t roll; // IMU-mount roll angle [-180, 180]: Degrees * 1e-2
-} UBX_ESF_ALG_data_t;
-
-typedef struct
-{
-  union
-  {
-    uint32_t all;
-    struct
-    {
-      uint32_t all : 1;
-
-      uint32_t iTOW : 1;
-      uint32_t version : 1;
-
-      uint32_t autoMntAlgOn : 1;
-      uint32_t status : 1;
-
-      uint32_t tiltAlgError : 1;
-      uint32_t yawAlgError : 1;
-      uint32_t angleError : 1;
-
-      uint32_t yaw : 1;
-      uint32_t pitch : 1;
-      uint32_t roll : 1;
-    } bits;
-  } moduleQueried;
-} UBX_ESF_ALG_moduleQueried_t;
-
-typedef struct
-{
-	ubxAutomaticFlags automaticFlags;
-  UBX_ESF_ALG_data_t data;
-  UBX_ESF_ALG_moduleQueried_t moduleQueried;
-  void (*callbackPointer)(UBX_ESF_ALG_data_t);
-  UBX_ESF_ALG_data_t  *callbackData;
-} UBX_ESF_ALG_t;
-
-// UBX-ESF-INS (0x10 0x15): Vehicle dynamics information
-const uint16_t UBX_ESF_INS_LEN = 36;
-
-typedef struct
-{
-  union
-  {
-    uint32_t all;
-    struct
-    {
-      uint32_t version : 8; // Message version (0x01 for this version)
-      uint32_t xAngRateValid : 1; // Compensated x-axis angular rate data validity flag (0: not valid, 1: valid)
-      uint32_t yAngRateValid : 1; // Compensated y-axis angular rate data validity flag (0: not valid, 1: valid)
-      uint32_t zAngRateValid : 1; // Compensated z-axis angular rate data validity flag (0: not valid, 1: valid)
-      uint32_t xAccelValid : 1; // Compensated x-axis acceleration data validity flag (0: not valid, 1: valid)
-      uint32_t yAccelValid : 1; // Compensated y-axis acceleration data validity flag (0: not valid, 1: valid)
-      uint32_t zAccelValid : 1; // Compensated z-axis acceleration data validity flag (0: not valid, 1: valid)
-    } bits;
-  } bitfield0;
-  uint8_t reserved1[4];
-  uint32_t iTOW; // GPS time of week of the HNR epoch: ms
-  int32_t xAngRate; // Compensated x-axis angular rate: Degrees/s * 1e-3
-  int32_t yAngRate; // Compensated y-axis angular rate: Degrees/s * 1e-3
-  int32_t zAngRate; // Compensated z-axis angular rate: Degrees/s * 1e-3
-  int32_t xAccel; // Compensated x-axis acceleration (gravity-free): m/s^2 * 1e-2
-  int32_t yAccel; // Compensated y-axis acceleration (gravity-free): m/s^2 * 1e-2
-  int32_t zAccel; // Compensated z-axis acceleration (gravity-free): m/s^2 * 1e-2
-} UBX_ESF_INS_data_t;
-
-typedef struct
-{
-  union
-  {
-    uint32_t all;
-    struct
-    {
-      uint32_t all : 1;
-
-      uint32_t version : 1;
-      uint32_t xAngRateValid : 1;
-      uint32_t yAngRateValid : 1;
-      uint32_t zAngRateValid : 1;
-      uint32_t xAccelValid : 1;
-      uint32_t yAccelValid : 1;
-      uint32_t zAccelValid : 1;
-
-      uint32_t iTOW : 1;
-      uint32_t xAngRate : 1;
-      uint32_t yAngRate : 1;
-      uint32_t zAngRate : 1;
-      uint32_t xAccel : 1;
-      uint32_t yAccel : 1;
-      uint32_t zAccel : 1;
-    } bits;
-  } moduleQueried;
-} UBX_ESF_INS_moduleQueried_t;
-
-typedef struct
-{
-	ubxAutomaticFlags automaticFlags;
-  UBX_ESF_INS_data_t data;
-  UBX_ESF_INS_moduleQueried_t moduleQueried;
-  void (*callbackPointer)(UBX_ESF_INS_data_t);
-  UBX_ESF_INS_data_t  *callbackData;
-} UBX_ESF_INS_t;
-
-// UBX-ESF-MEAS (0x10 0x02): External sensor fusion measurements
-// Note: length is variable
-const uint16_t UBX_ESF_MEAS_MAX_LEN = 8 + (4 * DEF_NUM_SENS) + 4;
-
-typedef struct
-{
-  union
-  {
-    uint32_t all;
-    struct
-    {
-      uint32_t dataField : 24; // Data
-      uint32_t dataType : 6; // Type of data (0 = no data; 1..63 = data type)
-    } bits;
-  } data;
-} UBX_ESF_MEAS_sensorData_t;
-
-typedef struct
-{
-  uint32_t timeTag; // Time tag of measurement generated by external sensor
-  union
-  {
-    uint16_t all;
-    struct
-    {
-      uint16_t timeMarkSent : 2; // Time mark signal was supplied just prior to sending this message:
-                                 //   0 = none, 1 = on Ext0, 2 = on Ext1
-      uint16_t timeMarkEdge : 1; // Trigger on rising (0) or falling (1) edge of time mark signal
-      uint16_t calibTtagValid : 1; // Calibration time tag available. Always set to zero.
-      uint16_t reserved : 7;
-      uint16_t numMeas : 5;  // Number of measurements contained in this message (optional, can be obtained from message size)
-    } bits;
-  } flags;
-  uint16_t id; // Identification number of data provider
-  UBX_ESF_MEAS_sensorData_t data[DEF_NUM_SENS];
-  uint32_t calibTtag; // OPTIONAL: Receiver local time calibrated: ms
-} UBX_ESF_MEAS_data_t;
-
-typedef struct
-{
-  union
-  {
-    uint32_t all;
-    struct
-    {
-      uint32_t all : 1;
-
-      uint32_t timeMarkSent : 1;
-      uint32_t timeMarkEdge : 1;
-      uint32_t calibTtagValid : 1;
-      uint32_t numMeas : 1;
-
-      uint32_t id : 1;
-
-      uint32_t data : DEF_NUM_SENS;
-
-      uint32_t calibTtag : 1;
-    } bits;
-  } moduleQueried;
-} UBX_ESF_MEAS_moduleQueried_t;
-
-typedef struct
-{
-	ubxAutomaticFlags automaticFlags;
-  UBX_ESF_MEAS_data_t data;
-  UBX_ESF_MEAS_moduleQueried_t moduleQueried;
-  void (*callbackPointer)(UBX_ESF_MEAS_data_t);
-  UBX_ESF_MEAS_data_t  *callbackData;
-} UBX_ESF_MEAS_t;
-
-// UBX-ESF-RAW (0x10 0x03): Raw sensor measurements
-// Note: length is variable
-const uint16_t UBX_ESF_RAW_MAX_LEN = 4 + (8 * DEF_NUM_SENS);
-
-typedef struct
-{
-  union
-  {
-    uint32_t all;
-    struct
-    {
-      uint32_t dataField : 24; // Data
-      uint32_t dataType : 8; // Type of data (0 = no data; 1..255 = data type)
-    } bits;
-  } data;
-  uint32_t sTag; // Sensor time tag
-} UBX_ESF_RAW_sensorData_t;
-
-typedef struct
-{
-  uint8_t reserved1[4];
-  UBX_ESF_RAW_sensorData_t data[DEF_NUM_SENS];
-} UBX_ESF_RAW_data_t;
-
-typedef struct
-{
-  union
-  {
-    uint32_t all;
-    struct
-    {
-      uint32_t all : 1;
-
-      uint32_t data : DEF_NUM_SENS;
-    } bits;
-  } moduleQueried;
-} UBX_ESF_RAW_moduleQueried_t;
-
-typedef struct
-{
-	ubxAutomaticFlags automaticFlags;
-  UBX_ESF_RAW_data_t data;
-  UBX_ESF_RAW_moduleQueried_t moduleQueried;
-  void (*callbackPointer)(UBX_ESF_RAW_data_t);
-  UBX_ESF_RAW_data_t  *callbackData;
-} UBX_ESF_RAW_t;
-
-// UBX-ESF-STATUS (0x10 0x10): External sensor fusion status
-// Note: length is variable
-const uint16_t UBX_ESF_STATUS_MAX_LEN = 16 + (4 * DEF_NUM_SENS);
-
-typedef struct
-{
-  union
-  {
-    uint8_t all;
-    struct
-    {
-      uint8_t type : 6; // Sensor data type
-      uint8_t used : 1; // If set, sensor data is used for the current sensor fusion solution
-      uint8_t ready : 1; // If set, sensor is set up (configuration is available or not required) but not used for computing the current sensor fusion solution.
-    } bits;
-  } sensStatus1;
-  union
-  {
-    uint8_t all;
-    struct
-    {
-      uint8_t calibStatus : 2; // 00: Sensor is not calibrated
-                               // 01: Sensor is calibrating
-                               // 10/11: Sensor is calibrated
-      uint8_t timeStatus : 2; // 00: No data
-                              // 01: Reception of the first byte used to tag the measurement
-                              // 10: Event input used to tag the measurement
-                              // 11: Time tag provided with the data
-    } bits;
-  } sensStatus2;
-  uint8_t freq; // Observation frequency: Hz
-  union
-  {
-    uint8_t all;
-    struct
-    {
-      uint8_t badMeas : 1; // Bad measurements detected
-      uint8_t badTTag : 1; // Bad measurement time-tags detected
-      uint8_t missingMeas : 1; // Missing or time-misaligned measurements detected
-      uint8_t noisyMeas : 1; // High measurement noise-level detected
-    } bits;
-  } faults;
-} UBX_ESF_STATUS_sensorStatus_t;
-
-typedef struct
-{
-  uint32_t iTOW; // GPS time of week of the HNR epoch: ms
-  uint8_t version; // Message version (0x02 for this version)
-  uint8_t reserved1[7];
-  uint8_t fusionMode; // Fusion mode:
-                      //  0: Initialization mode: receiver is initializing some unknown values required for doing sensor fusion
-                      //  1: Fusion mode: GNSS and sensor data are used for navigation solution computation
-                      //  2: Suspended fusion mode: sensor fusion is temporarily disabled due to e.g. invalid sensor data or detected ferry
-                      //  3: Disabled fusion mode: sensor fusion is permanently disabled until receiver reset due e.g. to sensor error
-  uint8_t reserved2[2];
-  uint8_t numSens; // Number of sensors
-  UBX_ESF_STATUS_sensorStatus_t status[DEF_NUM_SENS];
-} UBX_ESF_STATUS_data_t;
-
-typedef struct
-{
-  union
-  {
-    uint32_t all;
-    struct
-    {
-      uint32_t all : 1;
-
-      uint32_t iTOW : 1;
-      uint32_t version : 1;
-      uint32_t fusionMode : 1;
-      uint32_t numSens : 1;
-
-      uint32_t status : DEF_NUM_SENS;
-    } bits;
-  } moduleQueried;
-} UBX_ESF_STATUS_moduleQueried_t;
-
-typedef struct
-{
-	ubxAutomaticFlags automaticFlags;
-  UBX_ESF_STATUS_data_t data;
-  UBX_ESF_STATUS_moduleQueried_t moduleQueried;
-  void (*callbackPointer)(UBX_ESF_STATUS_data_t);
-  UBX_ESF_STATUS_data_t  *callbackData;
-} UBX_ESF_STATUS_t;
-
-// HNR-specific structs
-
-// UBX-HNR-PVT (0x28 0x00): High rate output of PVT solution
-const uint16_t UBX_HNR_PVT_LEN = 72;
-
-typedef struct
-{
-  uint32_t iTOW; // GPS time of week of the HNR epoch: ms
-  uint16_t year; // Year (UTC)
-  uint8_t month; // Month, range 1..12 (UTC)
-  uint8_t day; // Day of month, range 1..31 (UTC)
-  uint8_t hour; // Hour of day, range 0..23 (UTC)
-  uint8_t min; // Minute of hour, range 0..59 (UTC)
-  uint8_t sec; // Seconds of minute, range 0..60 (UTC)
-  union
-  {
-    uint8_t all;
-    struct
-    {
-      uint8_t validDate : 1; // 1 = Valid UTC Date
-      uint8_t validTime : 1; // 1 = Valid UTC Time of Day
-      uint8_t fullyResolved : 1; // 1 = UTC Time of Day has been fully resolved
-    } bits;
-  } valid;
-  int32_t nano; // Fraction of second (UTC): ns
-  uint8_t gpsFix; // GPSfix Type, range 0..5
-                    // 0x00 = No Fix
-                    // 0x01 = Dead Reckoning only
-                    // 0x02 = 2D-Fix
-                    // 0x03 = 3D-Fix
-                    // 0x04 = GPS + dead reckoning combined
-                    // 0x05 = Time only fix
-                    // 0x06..0xff: reserved
-  union
-  {
-    uint8_t all;
-    struct
-    {
-      uint8_t gpsFixOK : 1; // >1 = Fix within limits (e.g. DOP & accuracy)
-      uint8_t diffSoln : 1; // 1 = DGPS used
-      uint8_t WKNSET : 1; // 1 = Valid GPS week number
-      uint8_t TOWSET : 1; // 1 = Valid GPS time of week (iTOW & fTOW)
-      uint8_t headVehValid : 1; // 1= Heading of vehicle is valid
-    } bits;
-  } flags;
-  uint8_t reserved1[2];
-  int32_t lon; // Longitude: Degrees * 1e-7
-  int32_t lat; // Latitude: Degrees * 1e-7
-  int32_t height; // Height above ellipsoid: mm
-  int32_t hMSL; // Height above MSL: mm
-  int32_t gSpeed; // Ground Speed (2-D): mm/s
-  int32_t speed; // Speed (3-D): mm/s
-  int32_t headMot; // Heading of motion (2-D): Degrees * 1e-5
-  int32_t headVeh; // Heading of vehicle (2-D): Degrees * 1e-5
-  uint32_t hAcc; // Horizontal accuracy: mm
-  uint32_t vAcc; // Vertical accuracy: mm
-  uint32_t sAcc; // Speed accuracy: mm/s
-  uint32_t headAcc; // Heading accuracy: Degrees * 1e-5
-  uint8_t reserved2[4];
-} UBX_HNR_PVT_data_t;
-
-typedef struct
-{
-  union
-  {
-    uint32_t all;
-    struct
-    {
-      uint32_t all : 1;
-
-      uint32_t iTOW : 1;
-      uint32_t year : 1;
-      uint32_t month : 1;
-      uint32_t day : 1;
-      uint32_t hour : 1;
-      uint32_t min : 1;
-      uint32_t sec : 1;
-
-      uint32_t validDate : 1;
-      uint32_t validTime : 1;
-      uint32_t fullyResolved : 1;
-
-      uint32_t nano : 1;
-      uint32_t gpsFix : 1;
-
-      uint32_t gpsFixOK : 1;
-      uint32_t diffSoln : 1;
-      uint32_t WKNSET : 1;
-      uint32_t TOWSET : 1;
-      uint32_t headVehValid : 1;
-
-      uint32_t lon : 1;
-      uint32_t lat : 1;
-      uint32_t height : 1;
-      uint32_t hMSL : 1;
-      uint32_t gSpeed : 1;
-      uint32_t speed : 1;
-      uint32_t headMot : 1;
-      uint32_t headVeh : 1;
-      uint32_t hAcc : 1;
-      uint32_t vAcc : 1;
-      uint32_t sAcc : 1;
-      uint32_t headAcc : 1;
-    } bits;
-  } moduleQueried;
-} UBX_HNR_PVT_moduleQueried_t;
-
-typedef struct
-{
-	ubxAutomaticFlags automaticFlags;
-  UBX_HNR_PVT_data_t data;
-  UBX_HNR_PVT_moduleQueried_t moduleQueried;
-  void (*callbackPointer)(UBX_HNR_PVT_data_t);
-  UBX_HNR_PVT_data_t  *callbackData;
-} UBX_HNR_PVT_t;
-
-// UBX-HNR-ATT (0x28 0x01): Attitude solution
-const uint16_t UBX_HNR_ATT_LEN = 32;
-
-typedef struct
-{
-  uint32_t iTOW; // GPS time of week of the navigation epoch: ms
-  uint8_t version;
-  uint8_t reserved1[3];
-  int32_t roll; // Vehicle roll: Degrees * 1e-5
-  int32_t pitch; // Vehicle pitch: Degrees * 1e-5
-  int32_t heading; // Vehicle heading: Degrees * 1e-5
-  uint32_t accRoll; // Vehicle roll accuracy: Degrees * 1e-5
-  uint32_t accPitch; // Vehicle pitch accuracy: Degrees * 1e-5
-  uint32_t accHeading; // Vehicle heading accuracy: Degrees * 1e-5
-} UBX_HNR_ATT_data_t;
-
-typedef struct
-{
-  union
-  {
-    uint32_t all;
-    struct
-    {
-      uint32_t all : 1;
-
-      uint32_t iTOW : 1;
-      uint32_t version : 1;
-      uint32_t roll : 1;
-      uint32_t pitch : 1;
-      uint32_t heading : 1;
-      uint32_t accRoll : 1;
-      uint32_t accPitch : 1;
-      uint32_t accHeading : 1;
-    } bits;
-  } moduleQueried;
-} UBX_HNR_ATT_moduleQueried_t;
-
-typedef struct
-{
-	ubxAutomaticFlags automaticFlags;
-  UBX_HNR_ATT_data_t data;
-  UBX_HNR_ATT_moduleQueried_t moduleQueried;
-  void (*callbackPointer)(UBX_HNR_ATT_data_t);
-  UBX_HNR_ATT_data_t  *callbackData;
-} UBX_HNR_ATT_t;
-
-// UBX-HNR-INS (0x28 0x02): Vehicle dynamics information
-const uint16_t UBX_HNR_INS_LEN = 36;
-
-typedef struct
-{
-  union
-  {
-    uint32_t all;
-    struct
-    {
-      uint32_t version : 8; // Message version (0x00 for this version)
-      uint32_t xAngRateValid : 1; // Compensated x-axis angular rate data validity flag (0: not valid, 1: valid)
-      uint32_t yAngRateValid : 1; // Compensated y-axis angular rate data validity flag (0: not valid, 1: valid)
-      uint32_t zAngRateValid : 1; // Compensated z-axis angular rate data validity flag (0: not valid, 1: valid)
-      uint32_t xAccelValid : 1; // Compensated x-axis acceleration data validity flag (0: not valid, 1: valid)
-      uint32_t yAccelValid : 1; // Compensated y-axis acceleration data validity flag (0: not valid, 1: valid)
-      uint32_t zAccelValid : 1; // Compensated z-axis acceleration data validity flag (0: not valid, 1: valid)
-    } bits;
-  } bitfield0;
-  uint8_t reserved1[4];
-  uint32_t iTOW; // GPS time of week of the HNR epoch: ms
-  int32_t xAngRate; // Compensated x-axis angular rate: Degrees/s * 1e-3
-  int32_t yAngRate; // Compensated y-axis angular rate: Degrees/s * 1e-3
-  int32_t zAngRate; // Compensated z-axis angular rate: Degrees/s * 1e-3
-  int32_t xAccel; // Compensated x-axis acceleration (with gravity): m/s^2 * 1e-2
-  int32_t yAccel; // Compensated y-axis acceleration (with gravity): m/s^2 * 1e-2
-  int32_t zAccel; // Compensated z-axis acceleration (with gravity): m/s^2 * 1e-2
-} UBX_HNR_INS_data_t;
-
-typedef struct
-{
-  union
-  {
-    uint32_t all;
-    struct
-    {
-      uint32_t all : 1;
-
-      uint32_t version : 1;
-      uint32_t xAngRateValid : 1;
-      uint32_t yAngRateValid : 1;
-      uint32_t zAngRateValid : 1;
-      uint32_t xAccelValid : 1;
-      uint32_t yAccelValid : 1;
-      uint32_t zAccelValid : 1;
-
-      uint32_t iTOW : 1;
-      uint32_t xAngRate : 1;
-      uint32_t yAngRate : 1;
-      uint32_t zAngRate : 1;
-      uint32_t xAccel : 1;
-      uint32_t yAccel : 1;
-      uint32_t zAccel : 1;
-    } bits;
-  } moduleQueried;
-} UBX_HNR_INS_moduleQueried_t;
-
-typedef struct
-{
-	ubxAutomaticFlags automaticFlags;
-  UBX_HNR_INS_data_t data;
-  UBX_HNR_INS_moduleQueried_t moduleQueried;
-  void (*callbackPointer)(UBX_HNR_INS_data_t);
-  UBX_HNR_INS_data_t  *callbackData;
-} UBX_HNR_INS_t;
-
-// UBX-CFG-TP5 (0x06 0x31): Time pulse parameters
-const uint16_t UBX_CFG_TP5_LEN = 32;
-
-typedef struct
-{
-  uint8_t tpIdx; // Time pulse selection (0 = TIMEPULSE, 1 = TIMEPULSE2)
-  uint8_t version; // Message version (0x01 for this version)
-  uint8_t reserved1[2];
-  int16_t antCableDelay; // Antenna cable delay: ns
-  int16_t rfGroupDelay; // RF group delay: ns
-  uint32_t freqPeriod; // Frequency or period time, depending on setting of bit 'isFreq': Hz_or_us
-  uint32_t freqPeriodLock; // Frequency or period time when locked to GNSS time, only used if 'lockedOtherSet' is set: Hz_or_us
-  uint32_t pulseLenRatio; // Pulse length or duty cycle, depending on 'isLength': us_or_2^-32
-  uint32_t pulseLenRatioLock; // Pulse length or duty cycle when locked to GNSS time, only used if 'lockedOtherSet' is set: us_or_2^-32
-  int32_t userConfigDelay; // User-configurable time pulse delay: ns
-  union
-  {
-    uint32_t all;
-    struct
-    {
-      uint32_t active : 1; // If set enable time pulse; if pin assigned to another function, other function takes precedence.
-      uint32_t lockGnssFreq : 1; // If set, synchronize time pulse to GNSS as soon as GNSS time is valid. If not set, or before GNSS time is valid, use local clock.
-      uint32_t lockedOtherSet : 1; // If set the receiver switches between the timepulse settings given by 'freqPeriodLocked' & 'pulseLenLocked' and those given by 'freqPeriod' & 'pulseLen'.
-      uint32_t isFreq : 1; // If set 'freqPeriodLock' and 'freqPeriod' are interpreted as frequency, otherwise interpreted as period.
-      uint32_t isLength : 1; // If set 'pulseLenRatioLock' and 'pulseLenRatio' interpreted as pulse length, otherwise interpreted as duty cycle.
-      uint32_t alignToTow : 1; // Align pulse to top of second (period time must be integer fraction of 1s). Also set 'lockGnssFreq' to use this feature.
-      uint32_t polarity : 1; // Pulse polarity: 0: falling edge at top of second; 1: rising edge at top of second
-      uint32_t gridUtcGnss : 4; // Timegrid to use: 0: UTC; 1: GPS; 2: GLONASS; 3: BeiDou; 4: Galileo
-      uint32_t syncMode : 3; // Sync Manager lock mode to use:
-                             // 0: switch to 'freqPeriodLock' and 'pulseLenRatioLock' as soon as Sync Manager has an accurate time, never switch back to 'freqPeriod' and 'pulseLenRatio'
-                             // 1: switch to 'freqPeriodLock' and 'pulseLenRatioLock' as soon as Sync Manager has an accurate time, and switch back to 'freqPeriod' and 'pulseLenRatio' as soon as time gets inaccurate
-    } bits;
-  } flags;
-} UBX_CFG_TP5_data_t;
-
-#endif
diff --git a/Ublox_Linux_Library/android_build/Android.mk b/Ublox_Linux_Library/android_build/Android.mk
deleted file mode 100644
index caac7b2..0000000
--- a/Ublox_Linux_Library/android_build/Android.mk
+++ /dev/null
@@ -1,48 +0,0 @@
-LOCAL_PATH := $(call my-dir)
-
-################################################################
-############# Build ublox shared library #######################
-################################################################
-include $(CLEAR_VARS)
-LOCAL_C_INCLUDES := ../inc \
-					../SparkFun_u-blox_GNSS_Arduino_Library/src
-LOCAL_SRC_FILES  := ../SparkFun_u-blox_GNSS_Arduino_Library/src/SparkFun_u-blox_GNSS_Arduino_Library.cpp \
-					../src/Print.cpp \
-					../src/Utils.cpp
-LOCAL_MODULE     :=  ublox
-LOCAL_CFLAGS := -std=gnu++11 -DANDROID
-LOCAL_CFLAGS += -fPIE
-LOCAL_ARM_MODE := arm
-LOCAL_ARM_NEON := true
-
-include $(BUILD_SHARED_LIBRARY)
-
-#################################################################
-################ ublox_f9p_test #################################
-#################################################################
-include $(CLEAR_VARS)
-LOCAL_MODULE := ublox_f9p_test
-LOCAL_C_INCLUDES := ../inc \
-					../SparkFun_u-blox_GNSS_Arduino_Library/src
-LOCAL_SRC_FILES:= ../linux_examples/ublox_f9p_test.cpp
-LOCAL_LDFLAGS := -L./libs/$(TARGET_ARCH_ABI) -fPIE -pie
-LOCAL_SHARED_LIBRARIES := ublox
-LOCAL_CXXFLAGS += -fPIE
-LOCAL_ARM_MODE := arm
-LOCAL_ARM_NEON := true
-include $(BUILD_EXECUTABLE)
-
-#################################################################
-################ ublox_f9p i2c test #############################
-#################################################################
-include $(CLEAR_VARS)
-LOCAL_MODULE := ublox_f9p_i2c_test
-LOCAL_C_INCLUDES := ../inc \
-					../SparkFun_u-blox_GNSS_Arduino_Library/src
-LOCAL_SRC_FILES:= ../linux_examples/ublox_f9p_i2c_test.cpp
-LOCAL_LDFLAGS := -L./libs/$(TARGET_ARCH_ABI) -fPIE -pie
-LOCAL_SHARED_LIBRARIES := ublox
-LOCAL_CXXFLAGS += -fPIE
-LOCAL_ARM_MODE := arm
-LOCAL_ARM_NEON := true
-include $(BUILD_EXECUTABLE)
\ No newline at end of file
diff --git a/Ublox_Linux_Library/android_build/Application.mk b/Ublox_Linux_Library/android_build/Application.mk
deleted file mode 100644
index 258b935..0000000
--- a/Ublox_Linux_Library/android_build/Application.mk
+++ /dev/null
@@ -1,14 +0,0 @@
-# Application make file to enable STL 
-APP_BUILD_SCRIPT := $(call my-dir)/Android.mk
-APP_PROJECT_PATH := $(call my-dir)
-
-# Disable run time type info
-#APP_CPPFLAGS += -fno-rtti
-APP_CPPFLAGS += -O0
-APP_OPTIM := release
-NDK_TOOLCHAIN_VERSION=4.9
-
-# Use GNU our STL
-APP_STL := gnustl_shared
-APP_ABI := armeabi-v7a
-APP_PLATFORM := android-123
diff --git a/Ublox_Linux_Library/linux_build/CMakeLists.txt b/Ublox_Linux_Library/linux_build/CMakeLists.txt
deleted file mode 100644
index 9701edc..0000000
--- a/Ublox_Linux_Library/linux_build/CMakeLists.txt
+++ /dev/null
@@ -1,71 +0,0 @@
-project (ublox_linux)
-cmake_minimum_required(VERSION 2.8)
-
-set(
-    CMAKE_RUNTIME_OUTPUT_DIRECTORY
-    ${CMAKE_HOME_DIRECTORY}/bin
-    )
-
-set(
-    CMAKE_LIBRARY_OUTPUT_DIRECTORY
-    ${CMAKE_HOME_DIRECTORY}/lib
-    )
-
-add_definitions(
-    -std=c++11 -Wno-deprecated -fconcepts -Wall -DLINUX_PLATFORM
-    )
-
-link_directories(
-    /usr/local/lib
-    /usr/lib
-    ${CMAKE_HOME_DIRECTORY}/lib
-    )
-
-include_directories(
-    ${CMAKE_HOME_DIRECTORY}/../inc
-    #${CMAKE_HOME_DIRECTORY}/../SparkFun_Ublox_Arduino_Library/src
-    ${CMAKE_HOME_DIRECTORY}/../SparkFun_u-blox_GNSS_Arduino_Library/src
-    )
-
-set(
-    ublox_parser_src
-    ../SparkFun_u-blox_GNSS_Arduino_Library/src/SparkFun_u-blox_GNSS_Arduino_Library.cpp
-    ../src/Print.cpp
-    ../src/Utils.cpp
-    )
-
-add_library(
-    ublox_linux SHARED ${ublox_parser_src}
-    )
-
-#
-# Ublox f9p Test
-#
-
-set(
-    ublox_f9p_test_src
-    ../linux_examples/ublox_f9p_test.cpp
-    )
-
-add_executable(
-    ublox_f9p_test ${ublox_f9p_test_src}
-    )
-
-target_link_libraries(ublox_f9p_test ublox_linux util)
-
-
-
-#
-# Ublox f9p i2c Test
-#
-
-set(
-    ublox_f9p_i2c_test_src
-    ../linux_examples/ublox_f9p_i2c_test.cpp
-    )
-
-add_executable(
-    ublox_f9p_i2c_test ${ublox_f9p_i2c_test_src}
-    )
-
-target_link_libraries(ublox_f9p_i2c_test ublox_linux util)
\ No newline at end of file
diff --git a/Ublox_Linux_Library/linux_examples/ublox_f9p_i2c_test.cpp b/Ublox_Linux_Library/linux_examples/ublox_f9p_i2c_test.cpp
deleted file mode 100755
index 7044569..0000000
--- a/Ublox_Linux_Library/linux_examples/ublox_f9p_i2c_test.cpp
+++ /dev/null
@@ -1,101 +0,0 @@
-/*
-Copyright (c) 2020 Balamurugan Kandan
-
-Permission is hereby granted, free of charge, to any person obtaining a copy
-of this software and associated documentation files (the "Software"), to deal
-in the Software without restriction, including without limitation the rights
-to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-copies of the Software, and to permit persons to whom the Software is
-furnished to do so, subject to the following conditions:
-
-The above copyright notice and this permission notice shall be included in all
-copies or substantial portions of the Software.
-
-THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
-SOFTWARE.
-*/
-
-#include "SparkFun_u-blox_GNSS_Arduino_Library.h"
-SFE_UBLOX_GNSS myGPS;
-
-#include <string>
-
-int main(int argc, char** argv)
-{
-    printf("Starting uBlox ZED-F9P\n");
-
-    std::string  port = "/dev/ublox_i2c";
-    int address = 0x42;
-
-    if(argc == 1) {
-        printf("\nStarting with default port and address.\n"); 
-        return 0;
-    } else if (argc == 3) {
-
-            port = argv[1];
-            address = std::stoi(argv[2], 0, 16);
-       
-    } else if(argc >= 4) {
-        printf ("\nShould give the port and address as input arguments. Currently giving more arguments...\n");
-        return 0;
-    } 
-
-
-    printf("Looking for GPS on port %s at address 0x%02X\n", port.c_str(), address);
-
-    TwoWire wireCom(address);
-    wireCom.init(port.c_str());
-
-
-    if (!(wireCom.available())) {
-      printf("Failed to init i2c,  Please connect ublox GNSS module and try again... \n");
-      return 0;
-    }
-
-    myGPS.begin(wireCom);
-    myGPS.setNavigationFrequency(8); //Set output to 8 times a second
-    myGPS.saveConfiguration(); //Save the current settings to flash and BBR
-    
-    printf ("\n--------------------------------------------------------\n");
-    while(true) {
-        if (myGPS.getPVT()) {
-          printf ("%02d/%02d/%02d %02d:%02d:%02d %d:%d\n", myGPS.getDay(), myGPS.getMonth(), myGPS.getYear(), 
-                                                           myGPS.getHour(), myGPS.getMinute(), myGPS.getSecond(), 
-                                                           myGPS.getMillisecond(), myGPS.getNanosecond());
-          printf("Latitude                : %2.8f (deg)\n", myGPS.getLatitude() * 1e-7);
-          printf("Longitude               : %2.8f (deg)\n", myGPS.getLongitude() * 1e-7);
-          printf("Altitude                : %d (mm)\n", myGPS.getAltitude());
-          printf("Altitude MSL            : %d (mm)\n", myGPS.getAltitudeMSL());
-          printf("SIV                     : %d\n", myGPS.getSIV());
-          printf("PDOP                    : %f\n", myGPS.getPDOP() * 1e-2); 
-          printf("Fix type                : %d\n", myGPS.getFixType());
-          printf("Ground Speed            : %d\n", myGPS.getGroundSpeed());
-          printf("VelN                    : %08d (mm/s)\n", myGPS.getNedNorthVel());
-          printf("VelE                    : %08d (mm/s)\n", myGPS.getNedEastVel());
-          printf("VelD                    : %08d (mm/s)\n", myGPS.getNedDownVel());
-          printf("VAcc                    : %08d (mm)\n", myGPS.getVerticalAccEst());
-          printf("HAcc                    : %08d (mm)\n", myGPS.getHorizontalAccEst());
-          printf("SpeedAccEst             : %08d (mm/s)\n", myGPS.getSpeedAccEst());
-          printf("HeadAccEst              : %08d (degrees * 10^-5)\n", myGPS.getHeadingAccEst());
-          printf("HeadVehValid            : %s\n", myGPS.getHeadVehValid() ? "true" : "false");
-          printf("HeadVeh                 : %08d (degrees * 10^-5)\n", myGPS.getHeadVeh());
-          printf("MagDec                  : %08d (degrees * 10^-2)\n", myGPS.getMagDec());
-          printf("MagAcc                  : %08d (degrees * 10^-2)\n", myGPS.getMagAcc());
-          int solnType = myGPS.getCarrierSolutionType();
-          if (solnType == 0) printf ("### No RTK Fix yet ###\n");
-          else if (solnType == 1) printf ("&&& DGNSS/Float &&&\n");
-          else if (solnType == 2) printf ("*** DGNSS/Fix ***\n");
-          printf ("\n--------------------------------------------------------\n");
-          usleep(50);
-        }
-
-        usleep(25);
-    }
-
-    return 1;
-}
diff --git a/Ublox_Linux_Library/linux_examples/ublox_f9p_test.cpp b/Ublox_Linux_Library/linux_examples/ublox_f9p_test.cpp
deleted file mode 100644
index a1bb75f..0000000
--- a/Ublox_Linux_Library/linux_examples/ublox_f9p_test.cpp
+++ /dev/null
@@ -1,87 +0,0 @@
-/*
-Copyright (c) 2020 Balamurugan Kandan
-
-Permission is hereby granted, free of charge, to any person obtaining a copy
-of this software and associated documentation files (the "Software"), to deal
-in the Software without restriction, including without limitation the rights
-to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
-copies of the Software, and to permit persons to whom the Software is
-furnished to do so, subject to the following conditions:
-
-The above copyright notice and this permission notice shall be included in all
-copies or substantial portions of the Software.
-
-THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
-SOFTWARE.
-*/
-
-#include "SparkFun_u-blox_GNSS_Arduino_Library.h"
-SFE_UBLOX_GNSS myGPS;
-
-int main(int argc, char** argv)
-{
-    if(argc == 1) {
-        printf("\nublox_f9p_test <ublox_com> <pseudo_com> (ublox_f9p_test '/dev/ttyACM0')"); 
-        return 0;
-    } else if (argc == 2) {
-        for(int counter=0;counter<argc;counter++) 
-            printf("\nargv[%d]: %s",counter,argv[counter]);        
-    } else if(argc >= 3) {
-        printf ("\nMore number of arguments...");
-        return 0;
-    } 
-
-    Stream seriComm(argv[1]);
-    seriComm.begin(38400);
-    if (!seriComm.isConnected()) {
-        printf ("Ublox is not connected. Please connect ublox GNSS module and try again...\n");
-        return 0;
-    }
-
-    myGPS.begin(seriComm);
-    myGPS.setNavigationFrequency(8); //Set output to 8 times a second
-    myGPS.saveConfiguration(); //Save the current settings to flash and BBR
-    
-    printf ("\n--------------------------------------------------------\n");
-    while(true) {
-        if (myGPS.getPVT()) {
-          printf ("%02d/%02d/%02d %02d:%02d:%02d %d:%d\n", myGPS.getDay(), myGPS.getMonth(), myGPS.getYear(), 
-                                                           myGPS.getHour(), myGPS.getMinute(), myGPS.getSecond(), 
-                                                           myGPS.getMillisecond(), myGPS.getNanosecond());
-          printf("Latitude                : %2.8f (deg)\n", myGPS.getLatitude() * 1e-7);
-          printf("Longitude               : %2.8f (deg)\n", myGPS.getLongitude() * 1e-7);
-          printf("Altitude                : %d (mm)\n", myGPS.getAltitude());
-          printf("Altitude MSL            : %d (mm)\n", myGPS.getAltitudeMSL());
-          printf("SIV                     : %d\n", myGPS.getSIV());
-          printf("PDOP                    : %f\n", myGPS.getPDOP() * 1e-2); 
-          printf("Fix type                : %d\n", myGPS.getFixType());
-          printf("Ground Speed            : %d\n", myGPS.getGroundSpeed());
-          printf("VelN                    : %08d (mm/s)\n", myGPS.getNedNorthVel());
-          printf("VelE                    : %08d (mm/s)\n", myGPS.getNedEastVel());
-          printf("VelD                    : %08d (mm/s)\n", myGPS.getNedDownVel());
-          printf("VAcc                    : %08d (mm)\n", myGPS.getVerticalAccEst());
-          printf("HAcc                    : %08d (mm)\n", myGPS.getHorizontalAccEst());
-          printf("SpeedAccEst             : %08d (mm/s)\n", myGPS.getSpeedAccEst());
-          printf("HeadAccEst              : %08d (degrees * 10^-5)\n", myGPS.getHeadingAccEst());
-          printf("HeadVehValid            : %s\n", myGPS.getHeadVehValid() ? "true" : "false");
-          printf("HeadVeh                 : %08d (degrees * 10^-5)\n", myGPS.getHeadVeh());
-          printf("MagDec                  : %08d (degrees * 10^-2)\n", myGPS.getMagDec());
-          printf("MagAcc                  : %08d (degrees * 10^-2)\n", myGPS.getMagAcc());
-          int solnType = myGPS.getCarrierSolutionType();
-          if (solnType == 0) printf ("### No RTK Fix yet ###\n");
-          else if (solnType == 1) printf ("&&& DGNSS/Float &&&\n");
-          else if (solnType == 2) printf ("*** DGNSS/Fix ***\n");
-          printf ("\n--------------------------------------------------------\n");
-          usleep(50);
-        }
-
-        usleep(25);
-    }
-
-    return 1;
-}
diff --git a/ekf_nav_ins/inc/ekfNavINS.h b/ekf_nav_ins/inc/ekfNavINS.h
index ddfe482..760bd8d 100644
--- a/ekf_nav_ins/inc/ekfNavINS.h
+++ b/ekf_nav_ins/inc/ekfNavINS.h
@@ -32,6 +32,34 @@ Original Author: Adhika Lie
 #include <mutex>
 #include <shared_mutex>
 
+
+static const double DEG_TO_RAD = 0.017453292519943295769236907684886;
+static const double EARTH_RADIUS_IN_METERS = 6372797.560856;
+static const double RAD_TO_DEG = (double)180/(double)3.14159265359;
+
+#if 0
+double ArcInRadians(const Position& from, const Position& to) {
+    double latitudeArc  = (from.lat - to.lat) * DEG_TO_RAD;
+    double longitudeArc = (from.lon - to.lon) * DEG_TO_RAD;
+    double latitudeH = sin(latitudeArc * 0.5);
+    latitudeH *= latitudeH;
+    double lontitudeH = sin(longitudeArc * 0.5);
+    lontitudeH *= lontitudeH;
+    double tmp = cos(from.lat*DEG_TO_RAD) * cos(to.lat*DEG_TO_RAD);
+    return 2.0 * asin(sqrt(latitudeH + tmp*lontitudeH));
+}
+
+/** @brief Computes the distance, in meters, between two WGS-84 positions.
+  *
+  * The result is equal to <code>EARTH_RADIUS_IN_METERS*ArcInRadians(from,to)</code>
+  *
+  * @sa ArcInRadians
+  */
+double DistanceInMeters(const Position& from, const Position& to) {
+    return EARTH_RADIUS_IN_METERS*ArcInRadians(from, to);
+}
+#endif
+
 constexpr float SIG_W_A = 0.05f;
 // Std dev of gyro output noise (rad/s)
 constexpr float SIG_W_G = 0.00175f;
@@ -63,6 +91,7 @@ constexpr double ECC2 = 0.0066943799901;
 // earth semi-major axis radius (m)
 constexpr double EARTH_RADIUS = 6378137.0;
 
+
 class gpsCoordinate {
     public:
         double lat;
diff --git a/ekf_nav_ins/src/ekfNavINS.cpp b/ekf_nav_ins/src/ekfNavINS.cpp
index 9fe7e20..d53f6e5 100644
--- a/ekf_nav_ins/src/ekfNavINS.cpp
+++ b/ekf_nav_ins/src/ekfNavINS.cpp
@@ -186,6 +186,7 @@ std::tuple<float,float,float> ekfNavINS::getPitchRollYaw(float ax, float ay, flo
   Bxc = hx*cosf(theta) + (hy*sinf(phi) + hz*cosf(phi))*sinf(theta);
   Byc = hy*cosf(phi) - hz*sinf(phi);
   // finding initial heading
+//  printf("\npitch:%f,roll:%f,yaw:%f\n",theta,phi,psi);
   psi = -atan2f(Byc,Bxc);
   return (std::make_tuple(theta,phi,psi));
 }
diff --git a/ekf_test/CMakeLists.txt b/ekf_test/CMakeLists.txt
deleted file mode 100644
index 8822e9e..0000000
--- a/ekf_test/CMakeLists.txt
+++ /dev/null
@@ -1,17 +0,0 @@
-project (ekf_test)
-cmake_minimum_required(VERSION 2.8)
-
-add_definitions(
-    -std=c++17 -O3 -Wno-deprecated -v -ftime-report
-    )
-
-set(
-    ekf_test_src
-    src/ekf_test.cpp
-    )
-
-add_executable(
-    ekf_test ${ekf_test_src} 
-    )
-
-target_link_libraries(ekf_test robotcontrol ekf_nav_ins ublox_linux Boost::system util)
diff --git a/ekf_test/src/ekf_test.cpp b/ekf_test/src/ekf_test.cpp
deleted file mode 100644
index 789847a..0000000
--- a/ekf_test/src/ekf_test.cpp
+++ /dev/null
@@ -1,146 +0,0 @@
-#include <stdio.h>
-#include <signal.h>
-#include <getopt.h>
-#include <time.h>
-#include <rc/mpu.h>
-#include <rc/time.h>
-
-#include "ekfNavINS.h"
-#include "SparkFun_u-blox_GNSS_Arduino_Library.h"
-
-#include <iostream>
-#include <fstream>
-#include <string>
-#include <iomanip>
-#include <tuple>
-
-using namespace std;
-
-#define I2C_BUS 2
-
-static int running = 0;
-
-SFE_UBLOX_GNSS gps;
-
-// interrupt handler to catch ctrl-c
-static void __signal_handler(__attribute__ ((unused)) int dummy)
-{
-	running=0;
-	return;
-}
-
-// file pointer
-fstream fout;
-inline void open_file(std::string file_name) {
-    fout.open(file_name, ios::out | ios::app);
-    fout << std::fixed <<"time" << "," << "latitude" << "," << "longitude" << "," 
-    								   << "roll" << "," << "pitch" << "," << "yaw" << "," 
-    								   << "filtered_latitude" << "," << "filtered_longitude" << ","
-    								   << "filtered_roll" << "," << "filtered_pitch" << "," << "filtered_yaw" << std::endl;
-}
-
-inline void update_file(long int time, double latitude, double longitude,
-						float roll, float pitch, float yaw, 
-						double filtered_latitude, double filtered_longitude,
-						float filtered_roll, float filtered_pitch, float filtered_yaw) {
-	fout << time << "," << std::setprecision(7) << latitude << "," << std::setprecision(7) << longitude 
-				 << "," << roll << "," << pitch << "," << yaw
-				 << "," << std::setprecision(7) << filtered_latitude << "," << std::setprecision(7) << filtered_longitude 
-				 << "," << filtered_roll << "," << filtered_pitch << "," << filtered_yaw << std::endl;
-}
-
-inline void close_file() {
-	fout.close();
-}
-
-int main(int argc, char *argv[])
-{
-	// MPU9560
-	rc_mpu_data_t data; //struct to hold new data
-	// Ublox GPS
-	Stream serialComm("/dev/ttyACM0");
-    gps.begin(serialComm);
-    // EKF
-    ekfNavINS ekf;
-
-    float ax, ay, az, hx, hy, hz, pitch, roll, yaw;
-
-	// parse arguments
-	opterr = 0;
-
-	// set signal handler so the loop can exit cleanly
-	signal(SIGINT, __signal_handler);
-	running = 1;
-
-	// use defaults for now, except also enable magnetometer.
-	rc_mpu_config_t conf = rc_mpu_default_config();
-	conf.i2c_bus = I2C_BUS;
-	conf.enable_magnetometer = 1; // Enable magnetometer
-	conf.show_warnings = 1; // Enable warnings
-
-	if(rc_mpu_initialize(&data, conf)){
-		fprintf(stderr,"rc_mpu_initialize_failed\n");
-		return -1;
-	}
-
-	open_file(std::string("./gnss.csv"));
-
-	//now just wait, print_data will run
-	while (running) {
-		// read sensor data
-		if(rc_mpu_read_accel(&data)<0){
-			printf("read accel data failed\n");
-		}
-		if(rc_mpu_read_gyro(&data)<0){
-			printf("read gyro data failed\n");
-		}
-		if(rc_mpu_read_mag(&data)){
-			printf("read mag data failed\n");
-		}
-
-		// update the filter
-		if (gps.getPVT()) {
-			ax = data.accel[0];
-			ay = -1*data.accel[1];
-			az = data.accel[2];
-			hx = data.mag[0]; 
-			hy = data.mag[1]; 
-			hz = data.mag[2];
-			std::tie(pitch,roll,yaw) = ekf.getPitchRollYaw(ax, ay, az, hx, hy, hz);
-			ekf.ekf_update(time(NULL) /*,gps.getTimeOfWeek()*/, gps.getNedNorthVel()*1e-3, gps.getNedEastVel()*1e-3, gps.getNedDownVel()*1e-3,
-				gps.getLatitude()*1e-7*DEG_TO_RAD, gps.getLongitude()*1e-7*DEG_TO_RAD, (gps.getAltitude()*1e-3),
-				data.gyro[0]*DEG_TO_RAD, -1*data.gyro[1]*DEG_TO_RAD, data.gyro[2]*DEG_TO_RAD,
-				ax, ay, az, hx, hy, hz);
-
-			update_file(time(NULL), 
-						gps.getLatitude()*1e-7, gps.getLongitude()*1e-7,
-						roll, pitch, yaw,
-						ekf.getLatitude_rad()*RAD_TO_DEG, ekf.getLongitude_rad()*RAD_TO_DEG,
-						ekf.getRoll_rad(), ekf.getPitch_rad(), ekf.getHeading_rad());
-
-			printf("------------------------- %ld -------------------------- \n", gps.getTimeOfWeek());
-			printf("Latitude  : %2.7f %2.7f\n", gps.getLatitude()*1e-7, ekf.getLatitude_rad()*RAD_TO_DEG);
-			printf("Longitute : %2.7f %2.7f\n", gps.getLongitude()*1e-7, ekf.getLongitude_rad()*RAD_TO_DEG);
-			printf("Altitude  : %2.3f %2.3f\n", gps.getAltitude()*1e-3, ekf.getAltitude_m());
-			printf("Speed (N) : %2.3f %2.3f\n", gps.getNedNorthVel()*1e-3, ekf.getVelNorth_ms());
-			printf("Speed (E) : %2.3f %2.3f\n", gps.getNedEastVel()*1e-3, ekf.getVelEast_ms());
-			printf("Speed (D) : %2.3f %2.3f\n", gps.getNedDownVel()*1e-3, ekf.getVelDown_ms());
-			printf("Roll 	  : %2.3f %2.3f\n", roll, ekf.getRoll_rad());
-			printf("Pitch     : %2.3f %2.3f\n", pitch, ekf.getPitch_rad());
-			printf("Yaw       : %2.3f %2.3f\n", yaw, ekf.getHeading_rad());
-			/*printf("Gyro X    : %f  %f\n", data.gyro[0]*DEG_TO_RAD, ekf.getGyroBiasX_rads());
-			printf("Gyro Y    : %f  %f\n", data.gyro[1]*DEG_TO_RAD, ekf.getGyroBiasY_rads());
-			printf("Gyro Z    : %f  %f\n", data.gyro[2]*DEG_TO_RAD, ekf.getGyroBiasZ_rads());
-			printf("Accel X   : %f  %f\n", data.accel[0], ekf.getAccelBiasX_mss());
-			printf("Accel Y   : %f  %f\n", data.accel[1], ekf.getAccelBiasY_mss());
-			printf("Accel Z   : %f  %f\n", data.accel[2], ekf.getAccelBiasZ_mss());*/
-			printf("-----------------------------------------------------------------\n");
-		}
-		rc_usleep(100000);
-	}
-	printf("\n");
-	close_file();
-	rc_mpu_power_off();
-	return 0;
-}
-
diff --git a/python_utils/plot_coords.py b/python_utils/plot_coords.py
index 149fb67..5f76d9f 100755
--- a/python_utils/plot_coords.py
+++ b/python_utils/plot_coords.py
@@ -1,5 +1,13 @@
 #!/usr/bin/python
 
+# -Refactor the code to remove reduentent part. 
+# -Compiled for Linux with C++14 standard
+#Copyright (c) 2021 Balamurugan Kandan.
+#MIT License; See LICENSE.md for complete details
+#Author: 2021 Balamurugan Kandan
+
+
+
 import numpy as np
 import pandas as pd
 import matplotlib.pyplot as plt
diff --git a/python_utils/test_data/gnss.csv b/python_utils/test_data/gnss.csv
deleted file mode 100644
index 4421dad..0000000
--- a/python_utils/test_data/gnss.csv
+++ /dev/null
@@ -1,1444 +0,0 @@
-time,latitude,longitude,roll,pitch,yaw,filtered_latitude,filtered_longitude,filtered_roll,filtered_pitch,filtered_yaw
-1615570112,52.1324433,-2.3275946,0.1365605,0.0691891,-2.2407906,52.1324432,-2.3275947,0.1365605,0.0691891,-2.2407906
-1615570112,52.1324434,-2.3275946,0.1340892,0.0682131,-2.7572372,52.1324433,-2.3275946,0.1365605,0.0691891,-2.2407908
-1615570112,52.1324435,-2.3275945,0.1338566,0.0696771,-1.8723956,52.1324434,-2.3275946,0.1365605,0.0691891,-2.2407908
-1615570113,52.1324436,-2.3275944,0.1333118,0.0638218,-2.8005414,52.1324435,-2.3275945,0.1365605,0.0691890,-2.2407899
-1615570113,52.1324438,-2.3275946,0.1333507,0.0682131,-2.2868481,52.1324435,-2.3275945,0.1365601,0.0691889,-2.2407899
-1615570114,52.1324438,-2.3275944,0.1346022,0.0704092,-2.0697327,52.1324436,-2.3275945,0.1365605,0.0691894,-2.2407949
-1615570114,52.1324439,-2.3275944,0.1304020,0.0687011,-2.7398136,52.1324436,-2.3275945,0.1365602,0.0691891,-2.2407928
-1615570114,52.1324440,-2.3275944,0.1321335,0.0696771,-2.1701632,52.1324437,-2.3275945,0.1365608,0.0691894,-2.2407928
-1615570115,52.1324441,-2.3275943,0.1365288,0.0657733,-2.4712753,52.1324437,-2.3275945,0.1365601,0.0691892,-2.2407937
-1615570115,52.1324442,-2.3275943,0.1331273,0.0706532,-2.6613951,52.1324438,-2.3275944,0.1365608,0.0691899,-2.2407990
-1615570115,52.1324443,-2.3275944,0.1326057,0.0674811,-1.8899647,52.1324438,-2.3275944,0.1365613,0.0691895,-2.2407901
-1615570116,52.1324444,-2.3275944,0.1264791,0.0701652,3.1318076,52.1324439,-2.3275944,0.1365615,0.0691903,-2.2407994
-1615570116,52.1324445,-2.3275944,0.1355641,0.0679691,-1.8491921,52.1324439,-2.3275944,0.1365612,0.0691909,-2.2408094
-1615570117,52.1324446,-2.3275945,0.1327933,0.0606510,-2.5310159,52.1324440,-2.3275944,0.1365626,0.0691904,-2.2407939
-1615570117,52.1324447,-2.3275944,0.1355942,0.0711413,-2.4990492,52.1324440,-2.3275944,0.1365621,0.0691898,-2.2407889
-1615570117,52.1324448,-2.3275945,0.1382569,0.0662612,-2.0044122,52.1324441,-2.3275944,0.1365614,0.0691908,-2.2408068
-1615570118,52.1324449,-2.3275946,0.1298948,0.0669931,-2.0588455,52.1324441,-2.3275944,0.1365623,0.0691888,-2.2407749
-1615570118,52.1324450,-2.3275947,0.1330935,0.0669931,-2.3462670,52.1324442,-2.3275944,0.1365608,0.0691881,-2.2407751
-1615570118,52.1324451,-2.3275947,0.1313581,0.0655293,-2.6412582,52.1324442,-2.3275945,0.1365594,0.0691874,-2.2407753
-1615570119,52.1324452,-2.3275949,0.1338188,0.0655293,-2.5469532,52.1324443,-2.3275945,0.1365581,0.0691851,-2.2407539
-1615570119,52.1324454,-2.3275949,0.1340870,0.0679691,-2.4326451,52.1324443,-2.3275945,0.1365589,0.0691860,-2.2407606
-1615570120,52.1324455,-2.3275950,0.1340542,0.0643096,-2.5627654,52.1324444,-2.3275945,0.1365601,0.0691882,-2.2407823
-1615570120,52.1324456,-2.3275952,0.1326035,0.0672371,-2.1893497,52.1324444,-2.3275946,0.1365599,0.0691861,-2.2407551
-1615570120,52.1324458,-2.3275953,0.1320795,0.0635778,-2.8578076,52.1324445,-2.3275946,0.1365604,0.0691875,-2.2407701
-1615570121,52.1324459,-2.3275953,0.1343286,0.0674811,-1.8786298,52.1324445,-2.3275946,0.1365589,0.0691869,-2.2407722
-1615570121,52.1324460,-2.3275955,0.1325862,0.0652854,-2.2686071,52.1324446,-2.3275946,0.1365579,0.0691839,-2.2407401
-1615570121,52.1324462,-2.3275956,0.1325695,0.0633339,-2.6468408,52.1324447,-2.3275947,0.1365585,0.0691859,-2.2407620
-1615570122,52.1324463,-2.3275957,0.1347990,0.0650414,-2.0563416,52.1324447,-2.3275947,0.1365557,0.0691849,-2.2407672
-1615570122,52.1324465,-2.3275959,0.1357946,0.0662612,-2.1452272,52.1324448,-2.3275948,0.1365564,0.0691860,-2.2407761
-1615570123,52.1324466,-2.3275958,0.1333689,0.0701652,-2.6254356,52.1324448,-2.3275948,0.1365563,0.0691848,-2.2407622
-1615570123,52.1324467,-2.3275959,0.1318523,0.0657733,-2.0507545,52.1324449,-2.3275948,0.1365558,0.0691843,-2.2407594
-1615570123,52.1324469,-2.3275959,0.1311037,0.0645536,-2.3500288,52.1324450,-2.3275949,0.1365593,0.0691846,-2.2407398
-1615570124,52.1324470,-2.3275959,0.1284189,0.0669931,-2.6694312,52.1324450,-2.3275949,0.1365579,0.0691827,-2.2407250
-1615570124,52.1324472,-2.3275960,0.1338659,0.0706532,-2.4068012,52.1324451,-2.3275949,0.1365607,0.0691845,-2.2407293
-1615570124,52.1324473,-2.3275962,0.1365244,0.0652854,-2.1654580,52.1324452,-2.3275950,0.1365622,0.0691838,-2.2407105
-1615570125,52.1324474,-2.3275962,0.1277002,0.0691891,-1.9626653,52.1324452,-2.3275950,0.1365632,0.0691823,-2.2406857
-1615570125,52.1324476,-2.3275963,0.1298758,0.0647975,-2.0059075,52.1324453,-2.3275950,0.1365657,0.0691833,-2.2406816
-1615570126,52.1324477,-2.3275963,0.1311121,0.0655293,-2.3602629,52.1324453,-2.3275951,0.1365695,0.0691821,-2.2406418
-1615570126,52.1324479,-2.3275965,0.1311185,0.0662612,-2.2893839,52.1324454,-2.3275951,0.1365712,0.0691872,-2.2406964
-1615570126,52.1324480,-2.3275965,0.1311163,0.0660173,-1.4433578,52.1324455,-2.3275951,0.1365660,0.0691862,-2.2407167
-1615570127,52.1324481,-2.3275966,0.1333288,0.0657733,-1.9112874,52.1324455,-2.3275952,0.1365599,0.0691838,-2.2407253
-1615570127,52.1324483,-2.3275967,0.1345726,0.0672371,-1.8623101,52.1324456,-2.3275952,0.1365628,0.0691811,-2.2406716
-1615570127,52.1324484,-2.3275967,0.1343286,0.0674811,-2.4235797,52.1324457,-2.3275953,0.1365639,0.0691829,-2.2406874
-1615570128,52.1324485,-2.3275968,0.1316020,0.0652854,-2.0769830,52.1324457,-2.3275953,0.1365611,0.0691831,-2.2407084
-1615570128,52.1324486,-2.3275969,0.1299143,0.0691891,-2.0812764,52.1324458,-2.3275953,0.1365628,0.0691837,-2.2407043
-1615570129,52.1324488,-2.3275969,0.1328218,0.0640657,-1.7022964,52.1324459,-2.3275954,0.1365666,0.0691847,-2.2406936
-1615570129,52.1324489,-2.3275969,0.1345380,0.0633339,-2.1313219,52.1324459,-2.3275954,0.1365654,0.0691853,-2.2407084
-1615570129,52.1324490,-2.3275970,0.1335880,0.0672371,-2.0986137,52.1324460,-2.3275954,0.1365639,0.0691882,-2.2407560
-1615570130,52.1324491,-2.3275969,0.1293985,0.0665052,-2.7453120,52.1324461,-2.3275955,0.1365593,0.0691834,-2.2407234
-1615570130,52.1324492,-2.3275969,0.1328518,0.0674811,-2.6649857,52.1324461,-2.3275955,0.1365587,0.0691807,-2.2406933
-1615570130,52.1324493,-2.3275969,0.1328811,0.0706532,-2.4315560,52.1324462,-2.3275955,0.1365585,0.0691806,-2.2406933
-1615570131,52.1324494,-2.3275969,0.1321135,0.0674811,-2.1128454,52.1324463,-2.3275955,0.1365587,0.0691835,-2.2407291
-1615570131,52.1324496,-2.3275969,0.1338636,0.0704092,-2.3470364,52.1324463,-2.3275956,0.1365612,0.0691854,-2.2407370
-1615570132,52.1324496,-2.3275969,0.1328260,0.0645536,-2.1646590,52.1324464,-2.3275956,0.1365649,0.0691853,-2.2407122
-1615570132,52.1324498,-2.3275969,0.1335642,0.0645536,-2.0166535,52.1324464,-2.3275956,0.1365663,0.0691801,-2.2406361
-1615570132,52.1324498,-2.3275970,0.1301344,0.0662612,-2.8263724,52.1324465,-2.3275956,0.1365653,0.0691756,-2.2405841
-1615570133,52.1324499,-2.3275970,0.1316257,0.0679691,-2.1179304,52.1324466,-2.3275957,0.1365698,0.0691789,-2.2405980
-1615570133,52.1324500,-2.3275969,0.1294028,0.0669931,-2.0297194,52.1324466,-2.3275957,0.1365741,0.0691789,-2.2405689
-1615570133,52.1324502,-2.3275969,0.1303740,0.0655293,-2.4296386,52.1324467,-2.3275957,0.1365787,0.0691828,-2.2405903
-1615570134,52.1324503,-2.3275968,0.1328540,0.0677251,-2.5316756,52.1324467,-2.3275957,0.1365821,0.0691789,-2.2405171
-1615570134,52.1324503,-2.3275967,0.1328811,0.0706532,-2.1892042,52.1324468,-2.3275957,0.1365800,0.0691820,-2.2405705
-1615570135,52.1324504,-2.3275967,0.1310975,0.0638218,-1.4268085,52.1324469,-2.3275958,0.1365715,0.0691755,-2.2405417
-1615570135,52.1324506,-2.3275966,0.1350970,0.0706532,-2.3131793,52.1324469,-2.3275958,0.1365804,0.0691705,-2.2404203
-1615570135,52.1324507,-2.3275966,0.1348255,0.0679691,-2.1541965,52.1324470,-2.3275958,0.1365826,0.0691705,-2.2404053
-1615570136,52.1324508,-2.3275966,0.1313645,0.0662612,-2.3496885,52.1324470,-2.3275958,0.1365801,0.0691730,-2.2404544
-1615570136,52.1324509,-2.3275966,0.1271933,0.0674811,-2.6104813,52.1324471,-2.3275958,0.1365725,0.0691645,-2.2403932
-1615570136,52.1324510,-2.3275966,0.1284231,0.0674811,-2.4143517,52.1324472,-2.3275958,0.1365778,0.0691673,-2.2403953
-1615570137,52.1324512,-2.3275965,0.1310955,0.0635778,-2.6334715,52.1324472,-2.3275958,0.1365764,0.0691670,-2.2403998
-1615570137,52.1324513,-2.3275965,0.1350923,0.0701652,-2.1102154,52.1324473,-2.3275958,0.1365840,0.0691680,-2.2403646
-1615570138,52.1324515,-2.3275964,0.1296509,0.0672371,-2.3421731,52.1324473,-2.3275958,0.1365885,0.0691727,-2.2403955
-1615570138,52.1324516,-2.3275964,0.1348555,0.0711413,-2.8645546,52.1324474,-2.3275959,0.1365885,0.0691689,-2.2403462
-1615570138,52.1324517,-2.3275963,0.1318502,0.0655293,-2.4888752,52.1324475,-2.3275959,0.1365973,0.0691631,-2.2402143
-1615570139,52.1324519,-2.3275964,0.1318631,0.0669931,-2.4119592,52.1324475,-2.3275959,0.1365965,0.0691651,-2.2402453
-1615570139,52.1324520,-2.3275962,0.1328302,0.0650414,-2.3279402,52.1324476,-2.3275959,0.1365904,0.0691620,-2.2402446
-1615570139,52.1324521,-2.3275962,0.1311228,0.0667492,-2.1999719,52.1324476,-2.3275959,0.1365876,0.0691636,-2.2402833
-1615570140,52.1324522,-2.3275961,0.1348034,0.0655293,-2.3662961,52.1324477,-2.3275959,0.1365810,0.0691719,-2.2404332
-1615570140,52.1324524,-2.3275960,0.1338297,0.0667492,-2.5057240,52.1324478,-2.3275959,0.1365814,0.0691801,-2.2405369
-1615570141,52.1324525,-2.3275959,0.1348187,0.0672371,-2.1167111,52.1324478,-2.3275959,0.1365833,0.0691796,-2.2405186
-1615570141,52.1324526,-2.3275958,0.1313863,0.0687011,-3.0249515,52.1324479,-2.3275959,0.1365817,0.0691743,-2.2404604
-1615570141,52.1324528,-2.3275958,0.1289368,0.0699211,-3.0053842,52.1324479,-2.3275959,0.1365799,0.0691745,-2.2404747
-1615570142,52.1324529,-2.3275957,0.1333224,0.0650414,-2.5427642,52.1324480,-2.3275959,0.1365734,0.0691689,-2.2404439
-1615570142,52.1324530,-2.3275957,0.1345380,0.0633339,-2.5885124,52.1324481,-2.3275959,0.1365735,0.0691697,-2.2404542
-1615570142,52.1324531,-2.3275956,0.1323574,0.0672371,-1.6751237,52.1324481,-2.3275959,0.1365670,0.0691728,-2.2405360
-1615570143,52.1324532,-2.3275956,0.1316214,0.0674811,-1.9684552,52.1324482,-2.3275959,0.1365631,0.0691683,-2.2405033
-1615570143,52.1324533,-2.3275955,0.1303636,0.0643096,-2.4149766,52.1324482,-2.3275959,0.1365715,0.0691731,-2.2405105
-1615570144,52.1324534,-2.3275954,0.1323596,0.0674811,-2.5633664,52.1324483,-2.3275959,0.1365729,0.0691802,-2.2405932
-1615570144,52.1324535,-2.3275953,0.1343354,0.0682131,-2.0951362,52.1324484,-2.3275959,0.1365771,0.0691803,-2.2405672
-1615570144,52.1324536,-2.3275951,0.1299210,0.0699211,-2.2883799,52.1324484,-2.3275958,0.1365724,0.0691773,-2.2405591
-1615570145,52.1324537,-2.3275951,0.1360915,0.0716294,-2.3243790,52.1324485,-2.3275958,0.1365678,0.0691659,-2.2404423
-1615570145,52.1324539,-2.3275950,0.1313581,0.0655293,-1.4779078,52.1324485,-2.3275958,0.1365682,0.0691686,-2.2404737
-1615570145,52.1324540,-2.3275949,0.1318631,0.0669931,-2.2876916,52.1324486,-2.3275958,0.1365707,0.0691650,-2.2404118
-1615570146,52.1324541,-2.3275949,0.1306637,0.0704092,-2.2942529,52.1324487,-2.3275958,0.1365713,0.0691698,-2.2404702
-1615570146,52.1324541,-2.3275948,0.1326013,0.0669931,-2.1643457,52.1324487,-2.3275958,0.1365696,0.0691756,-2.2405548
-1615570147,52.1324542,-2.3275947,0.1320754,0.0630900,-1.9254153,52.1324488,-2.3275958,0.1365615,0.0691818,-2.2406867
-1615570147,52.1324543,-2.3275947,0.1328562,0.0679691,-2.9302478,52.1324488,-2.3275958,0.1365620,0.0691815,-2.2406797
-1615570147,52.1324544,-2.3275945,0.1370168,0.0652854,-2.0170598,52.1324489,-2.3275958,0.1365707,0.0691799,-2.2406027
-1615570148,52.1324545,-2.3275944,0.1331068,0.0684571,-1.7620080,52.1324490,-2.3275957,0.1365697,0.0691859,-2.2406864
-1615570148,52.1324546,-2.3275944,0.1350452,0.0650414,-2.3920588,52.1324490,-2.3275957,0.1365621,0.0691763,-2.2406125
-1615570148,52.1324546,-2.3275943,0.1323934,0.0711413,-2.5726929,52.1324491,-2.3275957,0.1365662,0.0691855,-2.2407041
-1615570149,52.1324547,-2.3275943,0.1333441,0.0674811,-2.2675862,52.1324491,-2.3275957,0.1365536,0.0691866,-2.2407997
-1615570149,52.1324547,-2.3275941,0.1345704,0.0669931,-2.3421917,52.1324492,-2.3275957,0.1365537,0.0691827,-2.2407498
-1615570150,52.1324547,-2.3275939,0.1316257,0.0679691,-2.2523510,52.1324492,-2.3275957,0.1365589,0.0691754,-2.2406220
-1615570150,52.1324548,-2.3275939,0.1328053,0.0621144,-2.3802977,52.1324493,-2.3275957,0.1365515,0.0691786,-2.2407107
-1615570150,52.1324548,-2.3275938,0.1328905,0.0716294,-2.5453339,52.1324493,-2.3275956,0.1365574,0.0691774,-2.2406569
-1615570151,52.1324548,-2.3275937,0.1308598,0.0647975,-1.8173083,52.1324494,-2.3275956,0.1365710,0.0691786,-2.2405849
-1615570151,52.1324548,-2.3275937,0.1306525,0.0691891,-2.4269395,52.1324495,-2.3275956,0.1365795,0.0691928,-2.2407112
-1615570151,52.1324548,-2.3275936,0.1368021,0.0687011,-2.1099958,52.1324495,-2.3275956,0.1365712,0.0691953,-2.2407975
-1615570152,52.1324547,-2.3275935,0.1343025,0.0645536,-2.8171000,52.1324495,-2.3275956,0.1365738,0.0691858,-2.2406580
-1615570152,52.1324547,-2.3275933,0.1315895,0.0638218,-2.1470723,52.1324496,-2.3275955,0.1365750,0.0691886,-2.2406871
-1615570153,52.1324547,-2.3275932,0.1306285,0.0665052,-2.0586441,52.1324496,-2.3275955,0.1365837,0.0691952,-2.2407146
-1615570153,52.1324547,-2.3275932,0.1303846,0.0667492,-1.9961468,52.1324497,-2.3275955,0.1365867,0.0691968,-2.2407172
-1615570153,52.1324547,-2.3275930,0.1355396,0.0652854,-2.3752279,52.1324497,-2.3275955,0.1365903,0.0691940,-2.2406564
-1615570154,52.1324547,-2.3275929,0.1338543,0.0694331,-1.9694464,52.1324498,-2.3275955,0.1365804,0.0691827,-2.2405767
-1615570154,52.1324547,-2.3275929,0.1338543,0.0694331,-2.5141602,52.1324498,-2.3275954,0.1365856,0.0691772,-2.2404714
-1615570154,52.1324546,-2.3275928,0.1304042,0.0689451,-2.0157888,52.1324499,-2.3275954,0.1365867,0.0691719,-2.2403963
-1615570155,52.1324546,-2.3275927,0.1328453,0.0667492,-2.1834416,52.1324499,-2.3275954,0.1365846,0.0691770,-2.2404761
-1615570155,52.1324546,-2.3275926,0.1323981,0.0716294,-2.6166158,52.1324499,-2.3275954,0.1365944,0.0691799,-2.2404490
-1615570156,52.1324546,-2.3275926,0.1369910,0.0623583,-1.7140676,52.1324500,-2.3275953,0.1366026,0.0691796,-2.2403924
-1615570156,52.1324545,-2.3275924,0.1323509,0.0665052,-1.9572725,52.1324500,-2.3275953,0.1365927,0.0691749,-2.2403955
-1615570156,52.1324545,-2.3275923,0.1326350,0.0706532,-2.5905612,52.1324501,-2.3275953,0.1365941,0.0691680,-2.2402978
-1615570157,52.1324544,-2.3275921,0.1294333,0.0704092,-2.4004693,52.1324501,-2.3275953,0.1366079,0.0691781,-2.2403390
-1615570157,52.1324544,-2.3275919,0.1335814,0.0665052,-2.5066123,52.1324501,-2.3275952,0.1365988,0.0691848,-2.2404842
-1615570157,52.1324544,-2.3275919,0.1338039,0.0638218,-2.3639362,52.1324502,-2.3275952,0.1366012,0.0691773,-2.2403717
-1615570158,52.1324543,-2.3275917,0.1330870,0.0662612,-2.2830789,52.1324502,-2.3275952,0.1365860,0.0691666,-2.2403338
-1615570158,52.1324543,-2.3275916,0.1331250,0.0704092,-2.5217464,52.1324502,-2.3275952,0.1365881,0.0691734,-2.2404070
-1615570159,52.1324543,-2.3275915,0.1323552,0.0669931,-2.1908271,52.1324503,-2.3275951,0.1365891,0.0691686,-2.2403381
-1615570159,52.1324543,-2.3275914,0.1323381,0.0650414,-2.3816442,52.1324503,-2.3275951,0.1365844,0.0691653,-2.2403259
-1615570159,52.1324542,-2.3275912,0.1340758,0.0667492,-2.2649431,52.1324503,-2.3275951,0.1365912,0.0691661,-2.2402930
-1615570160,52.1324542,-2.3275911,0.1333620,0.0694331,-3.0157323,52.1324504,-2.3275950,0.1365929,0.0691740,-2.2403824
-1615570160,52.1324542,-2.3275909,0.1313775,0.0677251,-2.0350714,52.1324504,-2.3275950,0.1366013,0.0691684,-2.2402570
-1615570160,52.1324541,-2.3275908,0.1318740,0.0682131,-2.0407996,52.1324504,-2.3275950,0.1365983,0.0691724,-2.2403271
-1615570161,52.1324540,-2.3275906,0.1303889,0.0672371,-2.8254428,52.1324505,-2.3275949,0.1366123,0.0691794,-2.2403266
-1615570161,52.1324539,-2.3275906,0.1289480,0.0711413,-2.2397137,52.1324505,-2.3275949,0.1366322,0.0691775,-2.2401731
-1615570162,52.1324539,-2.3275904,0.1298758,0.0647975,-2.2217121,52.1324505,-2.3275949,0.1366412,0.0691777,-2.2401171
-1615570162,52.1324538,-2.3275903,0.1338232,0.0660173,-2.6996467,52.1324505,-2.3275948,0.1366357,0.0691745,-2.2401116
-1615570162,52.1324536,-2.3275902,0.1358013,0.0669931,-2.2160804,52.1324505,-2.3275948,0.1366305,0.0691826,-2.2402496
-1615570163,52.1324536,-2.3275901,0.1318609,0.0667492,-2.3649721,52.1324506,-2.3275948,0.1366356,0.0691751,-2.2401204
-1615570163,52.1324535,-2.3275900,0.1306503,0.0689451,-2.1441526,52.1324506,-2.3275947,0.1366301,0.0691736,-2.2401361
-1615570163,52.1324534,-2.3275899,0.1330741,0.0647975,-2.0008790,52.1324506,-2.3275947,0.1366231,0.0691750,-2.2401998
-1615570164,52.1324533,-2.3275897,0.1333015,0.0626022,-2.1749415,52.1324506,-2.3275947,0.1366233,0.0691721,-2.2401609
-1615570164,52.1324532,-2.3275894,0.1326101,0.0679691,-2.4070923,52.1324507,-2.3275946,0.1366082,0.0691742,-2.2402864
-1615570165,52.1324532,-2.3275893,0.1372786,0.0669931,-2.2870653,52.1324507,-2.3275946,0.1366021,0.0691707,-2.2402806
-1615570165,52.1324532,-2.3275890,0.1358357,0.0706532,-2.2221096,52.1324507,-2.3275946,0.1365910,0.0691719,-2.2403686
-1615570165,52.1324530,-2.3275890,0.1313930,0.0694331,-1.9523715,52.1324507,-2.3275945,0.1365978,0.0691779,-2.2404010
-1615570166,52.1324529,-2.3275888,0.1316459,0.0701652,-2.2655714,52.1324507,-2.3275945,0.1365957,0.0691832,-2.2404821
-1615570166,52.1324529,-2.3275885,0.1338188,0.0655293,-2.3220558,52.1324507,-2.3275944,0.1365958,0.0691841,-2.2404928
-1615570166,52.1324528,-2.3275883,0.1301365,0.0665052,-2.3778412,52.1324508,-2.3275944,0.1365939,0.0691736,-2.2403710
-1615570167,52.1324528,-2.3275881,0.1301302,0.0657733,-1.8334335,52.1324508,-2.3275944,0.1365916,0.0691600,-2.2402117
-1615570167,52.1324527,-2.3275879,0.1363378,0.0716294,-2.2457335,52.1324508,-2.3275943,0.1366021,0.0691586,-2.2401257
-1615570168,52.1324527,-2.3275877,0.1355506,0.0665052,-1.9171042,52.1324508,-2.3275943,0.1366012,0.0691429,-2.2399302
-1615570168,52.1324526,-2.3275875,0.1333530,0.0684571,-2.3090680,52.1324508,-2.3275942,0.1365967,0.0691405,-2.2399271
-1615570168,52.1324526,-2.3275873,0.1323729,0.0689451,-2.4165301,52.1324508,-2.3275942,0.1366141,0.0691486,-2.2399187
-1615570169,52.1324525,-2.3275871,0.1343354,0.0682131,-2.0109262,52.1324508,-2.3275941,0.1366080,0.0691427,-2.2398827
-1615570169,52.1324525,-2.3275868,0.1313775,0.0677251,-1.9127351,52.1324508,-2.3275941,0.1366089,0.0691470,-2.2399325
-1615570169,52.1324525,-2.3275866,0.1355332,0.0645536,-2.5088451,52.1324508,-2.3275940,0.1366064,0.0691584,-2.2400939
-1615570170,52.1324525,-2.3275864,0.1301516,0.0682131,-2.7318234,52.1324509,-2.3275940,0.1366200,0.0691503,-2.2399030
-1615570170,52.1324524,-2.3275863,0.1350282,0.0630900,-2.5715742,52.1324509,-2.3275939,0.1366134,0.0691486,-2.2399235
-1615570171,52.1324525,-2.3275861,0.1343653,0.0713854,-2.2604742,52.1324509,-2.3275939,0.1366290,0.0691430,-2.2397504
-1615570171,52.1324525,-2.3275859,0.1325948,0.0662612,-1.9844140,52.1324509,-2.3275938,0.1366251,0.0691456,-2.2398090
-1615570171,52.1324525,-2.3275857,0.1321201,0.0682131,-2.3210015,52.1324509,-2.3275938,0.1366341,0.0691598,-2.2399333
-1615570172,52.1324524,-2.3275855,0.1335749,0.0657733,-2.5355263,52.1324509,-2.3275937,0.1366300,0.0691649,-2.2400243
-1615570172,52.1324524,-2.3275853,0.1338275,0.0665052,-2.2476704,52.1324509,-2.3275937,0.1366325,0.0691643,-2.2400005
-1615570172,52.1324525,-2.3275851,0.1311536,0.0701652,-2.2183847,52.1324509,-2.3275936,0.1366384,0.0691867,-2.2402487
-1615570173,52.1324525,-2.3275850,0.1321070,0.0667492,-2.2982335,52.1324509,-2.3275936,0.1366445,0.0691952,-2.2403183
-1615570173,52.1324525,-2.3275849,0.1350240,0.0626022,-2.2136791,52.1324509,-2.3275935,0.1366521,0.0692036,-2.2403758
-1615570174,52.1324525,-2.3275847,0.1291740,0.0689451,-2.2968860,52.1324510,-2.3275935,0.1366475,0.0692001,-2.2403610
-1615570174,52.1324526,-2.3275846,0.1313731,0.0672371,-2.3246839,52.1324510,-2.3275934,0.1366615,0.0691974,-2.2402360
-1615570174,52.1324525,-2.3275846,0.1286712,0.0677251,-2.9724810,52.1324510,-2.3275934,0.1366508,0.0692000,-2.2403383
-1615570175,52.1324526,-2.3275846,0.1311292,0.0674811,-2.4919851,52.1324510,-2.3275933,0.1366453,0.0691973,-2.2403393
-1615570175,52.1324527,-2.3275845,0.1345529,0.0650414,-2.0921221,52.1324510,-2.3275933,0.1366437,0.0691862,-2.2402084
-1615570175,52.1324527,-2.3275846,0.1311228,0.0667492,-2.1829970,52.1324510,-2.3275932,0.1366371,0.0691959,-2.2403746
-1615570176,52.1324527,-2.3275845,0.1340825,0.0674811,-2.7984738,52.1324510,-2.3275932,0.1366420,0.0692005,-2.2404022
-1615570176,52.1324528,-2.3275844,0.1286798,0.0687011,-2.4209366,52.1324510,-2.3275931,0.1366531,0.0691968,-2.2402830
-1615570177,52.1324528,-2.3275843,0.1363142,0.0691891,-1.6483883,52.1324510,-2.3275931,0.1366552,0.0692002,-2.2403123
-1615570177,52.1324529,-2.3275842,0.1367952,0.0679691,-2.4058571,52.1324510,-2.3275930,0.1366505,0.0692064,-2.2404227
-1615570177,52.1324529,-2.3275841,0.1363166,0.0694331,-2.3605881,52.1324511,-2.3275930,0.1366508,0.0692070,-2.2404282
-1615570178,52.1324529,-2.3275839,0.1313581,0.0655293,-2.0211000,52.1324511,-2.3275929,0.1366450,0.0692175,-2.2405999
-1615570178,52.1324531,-2.3275837,0.1355204,0.0630900,-2.1710260,52.1324511,-2.3275929,0.1366468,0.0692118,-2.2405152
-1615570178,52.1324532,-2.3275836,0.1333375,0.0667492,-2.5156808,52.1324511,-2.3275928,0.1366471,0.0692046,-2.2404218
-1615570179,52.1324533,-2.3275835,0.1308986,0.0691891,-2.2075405,52.1324511,-2.3275928,0.1366374,0.0692023,-2.2404544
-1615570179,52.1324533,-2.3275834,0.1289390,0.0701652,-2.4062722,52.1324511,-2.3275927,0.1366402,0.0691901,-2.2402811
-1615570180,52.1324534,-2.3275833,0.1320962,0.0655293,-2.3578486,52.1324511,-2.3275927,0.1366377,0.0691728,-2.2400746
-1615570180,52.1324535,-2.3275833,0.1330914,0.0667492,-2.4887967,52.1324511,-2.3275926,0.1366339,0.0691752,-2.2401304
-1615570180,52.1324535,-2.3275832,0.1325799,0.0645536,-2.0185785,52.1324511,-2.3275925,0.1366519,0.0691828,-2.2401121
-1615570181,52.1324535,-2.3275831,0.1338566,0.0696771,-2.2975347,52.1324512,-2.3275925,0.1366354,0.0691990,-2.2404253
-1615570181,52.1324535,-2.3275831,0.1313863,0.0687011,-2.2631330,52.1324512,-2.3275924,0.1366560,0.0691999,-2.2403028
-1615570181,52.1324536,-2.3275830,0.1335902,0.0674811,-2.1770658,52.1324512,-2.3275924,0.1366751,0.0692003,-2.2401848
-1615570182,52.1324536,-2.3275830,0.1333309,0.0660173,-2.3493211,52.1324512,-2.3275923,0.1366666,0.0691848,-2.2400422
-1615570182,52.1324536,-2.3275830,0.1321246,0.0687011,-2.5082340,52.1324512,-2.3275923,0.1366498,0.0691905,-2.2402236
-1615570183,52.1324537,-2.3275828,0.1308598,0.0647975,-2.6083040,52.1324512,-2.3275922,0.1366417,0.0691870,-2.2402306
-1615570183,52.1324537,-2.3275827,0.1311037,0.0645536,-2.2972150,52.1324512,-2.3275922,0.1366372,0.0691827,-2.2402050
-1615570183,52.1324538,-2.3275826,0.1281150,0.0599194,-2.3047895,52.1324513,-2.3275921,0.1366264,0.0691802,-2.2402425
-1615570184,52.1324539,-2.3275825,0.1382524,0.0657733,-2.4432697,52.1324513,-2.3275921,0.1366338,0.0691745,-2.2401218
-1615570184,52.1324539,-2.3275824,0.1328323,0.0652854,-2.2512569,52.1324513,-2.3275920,0.1366214,0.0691952,-2.2404659
-1615570184,52.1324539,-2.3275823,0.1328366,0.0657733,-2.1699266,52.1324513,-2.3275920,0.1366068,0.0691884,-2.2404742
-1615570185,52.1324540,-2.3275822,0.1318875,0.0696771,-2.1599135,52.1324513,-2.3275919,0.1366196,0.0691959,-2.2404864
-1615570185,52.1324541,-2.3275820,0.1340758,0.0667492,-2.4239812,52.1324513,-2.3275919,0.1366110,0.0691767,-2.2402978
-1615570186,52.1324541,-2.3275819,0.1321005,0.0660173,-2.4149854,52.1324513,-2.3275918,0.1366119,0.0691852,-2.2403998
-1615570186,52.1324542,-2.3275817,0.1313645,0.0662612,-2.0389190,52.1324513,-2.3275918,0.1366227,0.0691927,-2.2404261
-1615570186,52.1324542,-2.3275815,0.1303846,0.0667492,-1.9688252,52.1324514,-2.3275917,0.1366258,0.0692029,-2.2405362
-1615570187,52.1324542,-2.3275813,0.1338341,0.0672371,-2.6255960,52.1324514,-2.3275917,0.1366410,0.0692168,-2.2406156
-1615570187,52.1324543,-2.3275813,0.1357968,0.0665052,-2.1048677,52.1324514,-2.3275916,0.1366519,0.0692357,-2.2407856
-1615570187,52.1324543,-2.3275812,0.1318674,0.0674811,-1.7796772,52.1324514,-2.3275916,0.1366605,0.0692462,-2.2408643
-1615570188,52.1324543,-2.3275812,0.1343198,0.0665052,-2.2412047,52.1324514,-2.3275915,0.1366632,0.0692544,-2.2409518
-1615570188,52.1324543,-2.3275811,0.1301538,0.0684571,-2.4969780,52.1324514,-2.3275915,0.1366761,0.0692534,-2.2408566
-1615570189,52.1324544,-2.3275811,0.1318588,0.0665052,-2.3383005,52.1324514,-2.3275914,0.1366909,0.0692419,-2.2406135
-1615570189,52.1324543,-2.3275810,0.1308661,0.0655293,-2.0703378,52.1324515,-2.3275914,0.1366984,0.0692543,-2.2407231
-1615570189,52.1324544,-2.3275809,0.1333375,0.0667492,-2.8387351,52.1324515,-2.3275913,0.1366796,0.0692673,-2.2410102
-1615570190,52.1324545,-2.3275808,0.1343286,0.0674811,-2.3503270,52.1324515,-2.3275913,0.1366872,0.0692771,-2.2410865
-1615570190,52.1324545,-2.3275808,0.1333331,0.0662612,-2.2559257,52.1324515,-2.3275912,0.1366795,0.0692798,-2.2411699
-1615570190,52.1324546,-2.3275807,0.1313841,0.0684571,-2.5324993,52.1324515,-2.3275912,0.1366769,0.0692642,-2.2409887
-1615570191,52.1324546,-2.3275806,0.1313602,0.0657733,-2.1866543,52.1324515,-2.3275911,0.1366552,0.0692656,-2.2411454
-1615570191,52.1324547,-2.3275806,0.1326079,0.0677251,-2.1945779,52.1324515,-2.3275911,0.1366599,0.0692507,-2.2409246
-1615570192,52.1324547,-2.3275807,0.1337874,0.0618705,-2.2473733,52.1324516,-2.3275910,0.1366618,0.0692381,-2.2407520
-1615570192,52.1324548,-2.3275806,0.1360386,0.0660173,-2.4784210,52.1324516,-2.3275910,0.1366585,0.0692443,-2.2408528
-1615570192,52.1324548,-2.3275806,0.1313930,0.0694331,-1.5640712,52.1324516,-2.3275909,0.1366745,0.0692427,-2.2407293
-1615570193,52.1324549,-2.3275808,0.1316257,0.0679691,-2.1582682,52.1324516,-2.3275909,0.1366624,0.0692335,-2.2406893
-1615570193,52.1324550,-2.3275809,0.1306180,0.0652854,-2.4556203,52.1324516,-2.3275908,0.1366591,0.0692330,-2.2407043
-1615570193,52.1324551,-2.3275810,0.1318418,0.0645536,-2.1739211,52.1324516,-2.3275908,0.1366628,0.0692454,-2.2408390
-1615570194,52.1324553,-2.3275811,0.1301344,0.0662612,-2.1698589,52.1324517,-2.3275908,0.1366683,0.0692433,-2.2407765
-1615570194,52.1324554,-2.3275813,0.1350808,0.0689451,-2.2851436,52.1324517,-2.3275907,0.1366850,0.0692204,-2.2403769
-1615570195,52.1324555,-2.3275813,0.1343176,0.0662612,-2.1598876,52.1324517,-2.3275907,0.1366740,0.0692220,-2.2404683
-1615570195,52.1324556,-2.3275814,0.1282166,0.0718735,-2.4704435,52.1324517,-2.3275906,0.1366768,0.0692248,-2.2404852
-1615570195,52.1324557,-2.3275816,0.1313731,0.0672371,-2.6784453,52.1324517,-2.3275906,0.1367023,0.0692411,-2.2405298
-1615570196,52.1324558,-2.3275818,0.1335621,0.0643096,-2.5641968,52.1324517,-2.3275905,0.1367007,0.0692454,-2.2405949
-1615570196,52.1324558,-2.3275819,0.1323729,0.0689451,-2.4532020,52.1324518,-2.3275905,0.1366942,0.0692504,-2.2407000
-1615570196,52.1324560,-2.3275820,0.1306180,0.0652854,-2.0331974,52.1324518,-2.3275905,0.1367145,0.0692659,-2.2407672
-1615570197,52.1324561,-2.3275820,0.1313753,0.0674811,-2.7194386,52.1324518,-2.3275904,0.1367055,0.0692608,-2.2407608
-1615570197,52.1324562,-2.3275822,0.1311058,0.0647975,-2.1955631,52.1324518,-2.3275904,0.1367013,0.0692622,-2.2408049
-1615570198,52.1324562,-2.3275823,0.1296340,0.0652854,-2.5116186,52.1324518,-2.3275904,0.1366809,0.0692530,-2.2408197
-1615570198,52.1324563,-2.3275824,0.1316170,0.0669931,-2.1880031,52.1324519,-2.3275903,0.1366806,0.0692693,-2.2410293
-1615570198,52.1324564,-2.3275826,0.1328585,0.0682131,-1.8102790,52.1324519,-2.3275903,0.1366843,0.0692549,-2.2408216
-1615570199,52.1324563,-2.3275826,0.1320941,0.0652854,-1.9279186,52.1324519,-2.3275903,0.1366927,0.0692908,-2.2412262
-1615570199,52.1324564,-2.3275826,0.1281771,0.0674811,-1.8788208,52.1324519,-2.3275902,0.1366758,0.0692833,-2.2412386
-1615570199,52.1324564,-2.3275827,0.1298863,0.0660173,-2.2142694,52.1324519,-2.3275902,0.1366723,0.0692753,-2.2411594
-1615570200,52.1324564,-2.3275827,0.1323402,0.0652854,-2.3680644,52.1324520,-2.3275902,0.1366628,0.0692884,-2.2413878
-1615570200,52.1324564,-2.3275828,0.1333441,0.0674811,-2.1416981,52.1324520,-2.3275901,0.1366585,0.0692735,-2.2412245
-1615570201,52.1324564,-2.3275829,0.1342878,0.0628461,-1.4787588,52.1324520,-2.3275901,0.1366605,0.0692953,-2.2414918
-1615570201,52.1324564,-2.3275830,0.1284360,0.0689451,3.1156123,52.1324520,-2.3275901,0.1366543,0.0692983,-2.2415693
-1615570201,52.1324565,-2.3275831,0.1301451,0.0674811,-2.6404147,52.1324520,-2.3275900,0.1366426,0.0693070,-2.2417562
-1615570202,52.1324565,-2.3275831,0.1333353,0.0665052,-1.9200867,52.1324520,-2.3275900,0.1366279,0.0693166,-2.2419729
-1615570202,52.1324565,-2.3275833,0.1345572,0.0655293,-2.4814672,52.1324521,-2.3275900,0.1366126,0.0693010,-2.2418718
-1615570202,52.1324565,-2.3275834,0.1338408,0.0679691,-2.0950692,52.1324521,-2.3275900,0.1366350,0.0693054,-2.2417841
-1615570203,52.1324565,-2.3275833,0.1318481,0.0652854,-1.6532971,52.1324521,-2.3275899,0.1366369,0.0693031,-2.2417419
-1615570203,52.1324566,-2.3275834,0.1318631,0.0669931,-2.2908843,52.1324521,-2.3275899,0.1366214,0.0693125,-2.2419620
-1615570204,52.1324565,-2.3275836,0.1337854,0.0616266,-2.2467303,52.1324521,-2.3275899,0.1366036,0.0693051,-2.2419829
-1615570204,52.1324566,-2.3275836,0.1333441,0.0674811,-2.2654483,52.1324522,-2.3275899,0.1366060,0.0693052,-2.2419684
-1615570204,52.1324566,-2.3275836,0.1301693,0.0701652,-2.4788494,52.1324522,-2.3275898,0.1366236,0.0692959,-2.2417355
-1615570205,52.1324566,-2.3275837,0.1320857,0.0643096,-1.9615943,52.1324522,-2.3275898,0.1366213,0.0693079,-2.2419043
-1615570205,52.1324567,-2.3275836,0.1303595,0.0638218,3.0139654,52.1324522,-2.3275898,0.1366010,0.0693100,-2.2420611
-1615570205,52.1324567,-2.3275835,0.1355204,0.0630900,-2.3336208,52.1324522,-2.3275897,0.1366089,0.0693201,-2.2421403
-1615570206,52.1324568,-2.3275834,0.1306200,0.0655293,-2.4698887,52.1324522,-2.3275897,0.1366214,0.0693451,-2.2423797
-1615570206,52.1324568,-2.3275834,0.1338297,0.0667492,-2.2689328,52.1324523,-2.3275897,0.1366103,0.0693528,-2.2425506
-1615570207,52.1324568,-2.3275833,0.1313710,0.0669931,-2.8692055,52.1324523,-2.3275897,0.1365873,0.0693494,-2.2426543
-1615570207,52.1324568,-2.3275835,0.1316235,0.0677251,-2.3238697,52.1324523,-2.3275896,0.1365913,0.0693394,-2.2425003
-1615570207,52.1324568,-2.3275835,0.1333309,0.0660173,-2.2724562,52.1324523,-2.3275896,0.1365978,0.0693523,-2.2426243
-1615570208,52.1324567,-2.3275835,0.1323707,0.0687011,-2.0868592,52.1324523,-2.3275896,0.1365993,0.0693294,-2.2423205
-1615570208,52.1324568,-2.3275836,0.1301494,0.0679691,-2.3781524,52.1324524,-2.3275896,0.1366159,0.0693198,-2.2420909
-1615570208,52.1324567,-2.3275838,0.1328155,0.0633339,-1.5882745,52.1324524,-2.3275896,0.1366253,0.0692938,-2.2416980
-1615570209,52.1324567,-2.3275838,0.1325799,0.0645536,-2.5377560,52.1324524,-2.3275895,0.1366279,0.0692737,-2.2414231
-1615570209,52.1324568,-2.3275839,0.1365536,0.0684571,-2.3686609,52.1324524,-2.3275895,0.1366158,0.0692883,-2.2416878
-1615570210,52.1324568,-2.3275839,0.1316235,0.0677251,-2.3299279,52.1324524,-2.3275895,0.1365879,0.0693224,-2.2423048
-1615570210,52.1324568,-2.3275840,0.1330935,0.0669931,-2.2977495,52.1324524,-2.3275895,0.1365724,0.0693278,-2.2424738
-1615570210,52.1324568,-2.3275840,0.1291421,0.0652854,-2.6600530,52.1324525,-2.3275894,0.1365784,0.0693369,-2.2425520
-1615570211,52.1324568,-2.3275842,0.1350946,0.0704092,-1.7540790,52.1324525,-2.3275894,0.1365960,0.0693254,-2.2422915
-1615570211,52.1324569,-2.3275842,0.1338124,0.0647975,-2.1093497,52.1324525,-2.3275894,0.1366107,0.0693529,-2.2425487
-1615570211,52.1324570,-2.3275843,0.1323381,0.0650414,-2.1402543,52.1324525,-2.3275894,0.1366012,0.0693872,-2.2430491
-1615570212,52.1324570,-2.3275844,0.1326213,0.0691891,-2.5511227,52.1324525,-2.3275894,0.1365807,0.0693644,-2.2428882
-1615570212,52.1324570,-2.3275845,0.1311358,0.0682131,-2.2543743,52.1324525,-2.3275894,0.1366040,0.0693409,-2.2424383
-1615570213,52.1324571,-2.3275846,0.1340915,0.0684571,-2.5072351,52.1324526,-2.3275893,0.1365483,0.0693477,-2.2428842
-1615570213,52.1324572,-2.3275847,0.1367448,0.0623583,-1.7807058,52.1324526,-2.3275893,0.1365664,0.0693436,-2.2427149
-1615570213,52.1324572,-2.3275848,0.1318588,0.0665052,-2.8461485,52.1324526,-2.3275893,0.1365575,0.0693638,-2.2430296
-1615570214,52.1324572,-2.3275849,0.1338341,0.0672371,-2.4392536,52.1324526,-2.3275893,0.1365685,0.0693737,-2.2430854
-1615570214,52.1324572,-2.3275850,0.1316257,0.0679691,-2.2942030,52.1324526,-2.3275893,0.1365514,0.0693719,-2.2431743
-1615570214,52.1324573,-2.3275851,0.1333202,0.0647975,-2.3524060,52.1324526,-2.3275893,0.1365334,0.0693377,-2.2428510
-1615570215,52.1324573,-2.3275852,0.1328176,0.0635778,-2.3557246,52.1324527,-2.3275892,0.1365180,0.0693366,-2.2429368
-1615570215,52.1324573,-2.3275853,0.1328431,0.0665052,-2.4654365,52.1324527,-2.3275892,0.1365422,0.0693573,-2.2430458
-1615570216,52.1324574,-2.3275854,0.1355462,0.0660173,-1.8300527,52.1324527,-2.3275892,0.1365638,0.0693739,-2.2431192
-1615570216,52.1324574,-2.3275854,0.1311336,0.0679691,-1.8636492,52.1324527,-2.3275892,0.1365425,0.0693467,-2.2429080
-1615570216,52.1324574,-2.3275855,0.1299165,0.0694331,-2.5343645,52.1324527,-2.3275892,0.1365058,0.0693560,-2.2432632
-1615570217,52.1324574,-2.3275856,0.1323487,0.0662612,-2.5803475,52.1324527,-2.3275892,0.1364894,0.0693414,-2.2431822
-1615570217,52.1324575,-2.3275857,0.1358453,0.0716294,-2.4607196,52.1324528,-2.3275892,0.1364744,0.0693378,-2.2432327
-1615570217,52.1324575,-2.3275859,0.1331136,0.0691891,-2.3807130,52.1324528,-2.3275891,0.1364688,0.0693536,-2.2434707
-1615570218,52.1324576,-2.3275861,0.1331068,0.0684571,-2.1032009,52.1324528,-2.3275891,0.1364740,0.0693700,-2.2436471
-1615570218,52.1324576,-2.3275861,0.1303998,0.0684571,-1.9752029,52.1324528,-2.3275891,0.1364908,0.0693799,-2.2436662
-1615570219,52.1324577,-2.3275861,0.1350561,0.0662612,-2.2550347,52.1324528,-2.3275891,0.1364800,0.0693909,-2.2438765
-1615570219,52.1324577,-2.3275862,0.1340758,0.0667492,-1.3892667,52.1324528,-2.3275891,0.1364864,0.0693897,-2.2438204
-1615570219,52.1324578,-2.3275863,0.1340376,0.0623583,-2.1711519,52.1324529,-2.3275891,0.1364962,0.0694039,-2.2439382
-1615570220,52.1324578,-2.3275864,0.1328344,0.0655293,-2.3652000,52.1324529,-2.3275891,0.1364656,0.0693947,-2.2440181
-1615570220,52.1324579,-2.3275865,0.1328743,0.0699211,-2.3456264,52.1324529,-2.3275891,0.1364763,0.0693929,-2.2439263
-1615570220,52.1324580,-2.3275866,0.1340937,0.0687011,-2.5344665,52.1324529,-2.3275891,0.1364540,0.0693799,-2.2439027
-1615570221,52.1324580,-2.3275867,0.1335946,0.0679691,-2.4674587,52.1324529,-2.3275891,0.1364449,0.0693797,-2.2439587
-1615570221,52.1324581,-2.3275866,0.1335969,0.0682131,-2.2929771,52.1324529,-2.3275890,0.1364371,0.0693744,-2.2439411
-1615570222,52.1324581,-2.3275866,0.1338659,0.0706532,-2.6802871,52.1324530,-2.3275890,0.1364429,0.0693906,-2.2441108
-1615570222,52.1324583,-2.3275867,0.1318035,0.0599194,-2.1151710,52.1324530,-2.3275890,0.1364264,0.0694076,-2.2444344
-1615570222,52.1324583,-2.3275867,0.1352956,0.0655293,-2.2244890,52.1324530,-2.3275890,0.1364158,0.0693967,-2.2443643
-1615570223,52.1324583,-2.3275868,0.1298842,0.0657733,-2.5973349,52.1324530,-2.3275890,0.1364354,0.0693601,-2.2437682
-1615570223,52.1324584,-2.3275869,0.1293964,0.0662612,-2.7956066,52.1324530,-2.3275890,0.1364433,0.0693584,-2.2436953
-1615570223,52.1324584,-2.3275871,0.1321048,0.0665052,-2.2914295,52.1324531,-2.3275890,0.1364288,0.0693807,-2.2440758
-1615570224,52.1324585,-2.3275872,0.1325991,0.0667492,-2.4679234,52.1324531,-2.3275890,0.1364247,0.0693454,-2.2436495
-1615570224,52.1324585,-2.3275873,0.1330699,0.0643096,-2.2262337,52.1324531,-2.3275890,0.1364333,0.0693505,-2.2436588
-1615570225,52.1324586,-2.3275874,0.1313624,0.0660173,-2.7503817,52.1324531,-2.3275890,0.1364467,0.0693674,-2.2437892
-1615570225,52.1324586,-2.3275876,0.1279248,0.0667492,-2.8183186,52.1324531,-2.3275890,0.1364619,0.0693356,-2.2432828
-1615570225,52.1324586,-2.3275877,0.1330827,0.0657733,-2.4318881,52.1324531,-2.3275890,0.1364662,0.0693319,-2.2432089
-1615570226,52.1324587,-2.3275877,0.1313710,0.0669931,-2.1235209,52.1324532,-2.3275890,0.1364737,0.0693282,-2.2431128
-1615570226,52.1324588,-2.3275879,0.1333552,0.0687011,-2.0740891,52.1324532,-2.3275890,0.1364618,0.0692837,-2.2426188
-1615570226,52.1324588,-2.3275880,0.1333160,0.0643096,-2.0375166,52.1324532,-2.3275890,0.1364463,0.0692773,-2.2426369
-1615570227,52.1324589,-2.3275880,0.1330935,0.0669931,-2.1179461,52.1324532,-2.3275890,0.1364493,0.0692888,-2.2427645
-1615570227,52.1324589,-2.3275880,0.1338521,0.0691891,-2.7987201,52.1324532,-2.3275890,0.1364151,0.0692692,-2.2427349
-1615570228,52.1324590,-2.3275882,0.1325905,0.0657733,-2.4269123,52.1324533,-2.3275890,0.1364197,0.0692560,-2.2425351
-1615570228,52.1324590,-2.3275883,0.1333876,0.0721175,-2.1853187,52.1324533,-2.3275890,0.1364060,0.0692734,-2.2428470
-1615570228,52.1324591,-2.3275884,0.1347969,0.0647975,-2.2975640,52.1324533,-2.3275890,0.1363862,0.0692754,-2.2430000
-1615570229,52.1324592,-2.3275884,0.1306285,0.0665052,-2.3398316,52.1324533,-2.3275890,0.1363870,0.0692785,-2.2430351
-1615570229,52.1324594,-2.3275884,0.1311424,0.0689451,-2.2676022,52.1324533,-2.3275889,0.1363997,0.0692646,-2.2427740
-1615570229,52.1324594,-2.3275883,0.1333309,0.0660173,-2.7396483,52.1324533,-2.3275889,0.1363949,0.0692817,-2.2430246
-1615570230,52.1324594,-2.3275885,0.1318852,0.0694331,-2.6909285,52.1324534,-2.3275889,0.1363803,0.0692932,-2.2432666
-1615570230,52.1324595,-2.3275885,0.1323685,0.0684571,-2.5161014,52.1324534,-2.3275889,0.1364026,0.0692572,-2.2426608
-1615570231,52.1324596,-2.3275885,0.1330827,0.0657733,-2.1751575,52.1324534,-2.3275889,0.1363886,0.0692372,-2.2424948
-1615570231,52.1324596,-2.3275887,0.1326258,0.0696771,-2.2430964,52.1324534,-2.3275889,0.1363855,0.0692095,-2.2421598
-1615570231,52.1324597,-2.3275888,0.1328540,0.0677251,-2.0616441,52.1324534,-2.3275889,0.1363461,0.0692122,-2.2424481
-1615570232,52.1324599,-2.3275888,0.1333463,0.0677251,-2.4517143,52.1324535,-2.3275889,0.1363411,0.0692310,-2.2427211
-1615570232,52.1324600,-2.3275889,0.1335684,0.0650414,-1.7105603,52.1324535,-2.3275889,0.1364031,0.0692640,-2.2427447
-1615570232,52.1324600,-2.3275890,0.1333552,0.0687011,-2.5806451,52.1324535,-2.3275889,0.1364350,0.0692552,-2.2424266
-1615570233,52.1324601,-2.3275891,0.1330892,0.0665052,-2.3380773,52.1324535,-2.3275889,0.1364117,0.0692192,-2.2421145
-1615570233,52.1324601,-2.3275892,0.1350539,0.0660173,-2.3158622,52.1324535,-2.3275889,0.1364186,0.0692163,-2.2420330
-1615570234,52.1324602,-2.3275892,0.1303535,0.0630900,-1.9863197,52.1324536,-2.3275889,0.1364473,0.0691941,-2.2415626
-1615570234,52.1324603,-2.3275893,0.1338167,0.0652854,-1.8673408,52.1324536,-2.3275889,0.1364601,0.0691756,-2.2412434
-1615570234,52.1324604,-2.3275895,0.1336082,0.0694331,-2.1393948,52.1324536,-2.3275889,0.1365054,0.0691504,-2.2406273
-1615570235,52.1324606,-2.3275895,0.1291525,0.0665052,-2.8617196,52.1324536,-2.3275889,0.1365375,0.0691581,-2.2405186
-1615570235,52.1324607,-2.3275897,0.1338475,0.0687011,-2.4351029,52.1324537,-2.3275889,0.1365403,0.0691665,-2.2406092
-1615570235,52.1324608,-2.3275898,0.1350517,0.0657733,-2.2187335,52.1324537,-2.3275890,0.1364978,0.0691506,-2.2406788
-1615570236,52.1324610,-2.3275898,0.1348187,0.0672371,-1.9825875,52.1324537,-2.3275890,0.1365083,0.0691613,-2.2407486
-1615570236,52.1324610,-2.3275899,0.1335836,0.0667492,-2.1700604,52.1324537,-2.3275890,0.1364966,0.0691573,-2.2407732
-1615570237,52.1324612,-2.3275899,0.1291504,0.0662612,-1.8709248,52.1324537,-2.3275890,0.1364654,0.0691696,-2.2411327
-1615570237,52.1324613,-2.3275901,0.1318439,0.0647975,-2.1578612,52.1324538,-2.3275890,0.1364693,0.0691795,-2.2412338
-1615570237,52.1324614,-2.3275900,0.1325948,0.0662612,-2.1949804,52.1324538,-2.3275890,0.1365095,0.0691550,-2.2406607
-1615570238,52.1324616,-2.3275903,0.1294113,0.0679691,-2.1424787,52.1324538,-2.3275890,0.1364930,0.0691549,-2.2407658
-1615570238,52.1324617,-2.3275904,0.1320899,0.0647975,-2.3477659,52.1324538,-2.3275890,0.1364933,0.0691291,-2.2404332
-1615570238,52.1324618,-2.3275905,0.1291441,0.0655293,-2.1189046,52.1324539,-2.3275890,0.1364985,0.0691280,-2.2403851
-1615570239,52.1324619,-2.3275906,0.1320632,0.0616266,-2.1993330,52.1324539,-2.3275890,0.1365286,0.0691235,-2.2401321
-1615570239,52.1324621,-2.3275908,0.1330827,0.0657733,-2.3691382,52.1324539,-2.3275890,0.1365339,0.0691319,-2.2402062
-1615570240,52.1324623,-2.3275908,0.1318785,0.0687011,-2.6221287,52.1324539,-2.3275890,0.1365410,0.0690916,-2.2396436
-1615570240,52.1324624,-2.3275909,0.1296299,0.0647975,-2.0527639,52.1324540,-2.3275890,0.1365411,0.0690763,-2.2394462
-1615570240,52.1324624,-2.3275910,0.1363027,0.0679691,-2.4082704,52.1324540,-2.3275890,0.1365443,0.0690683,-2.2393236
-1615570241,52.1324625,-2.3275911,0.1340803,0.0672371,-2.1582947,52.1324540,-2.3275890,0.1365589,0.0690895,-2.2395008
-1615570241,52.1324627,-2.3275913,0.1343286,0.0674811,-2.3369367,52.1324540,-2.3275890,0.1365746,0.0690592,-2.2390108
-1615570241,52.1324627,-2.3275913,0.1328474,0.0669931,-2.1919184,52.1324541,-2.3275890,0.1366098,0.0690906,-2.2391865
-1615570242,52.1324628,-2.3275913,0.1345748,0.0674811,-2.0547817,52.1324541,-2.3275890,0.1366026,0.0690577,-2.2388110
-1615570242,52.1324630,-2.3275913,0.1335770,0.0660173,3.1227989,52.1324541,-2.3275890,0.1365939,0.0690528,-2.2388039
-1615570243,52.1324630,-2.3275914,0.1328302,0.0650414,-2.6326632,52.1324541,-2.3275890,0.1366398,0.0690417,-2.2383647
-1615570243,52.1324631,-2.3275914,0.1330957,0.0672371,-2.1703658,52.1324542,-2.3275891,0.1366473,0.0690196,-2.2380331
-1615570243,52.1324632,-2.3275914,0.1303678,0.0647975,-2.5406733,52.1324542,-2.3275891,0.1366298,0.0690144,-2.2380795
-1615570244,52.1324633,-2.3275914,0.1335749,0.0657733,-2.8111417,52.1324542,-2.3275891,0.1366099,0.0690351,-2.2384729
-1615570244,52.1324634,-2.3275914,0.1338145,0.0650414,-1.6873610,52.1324542,-2.3275891,0.1366348,0.0690564,-2.2385862
-1615570244,52.1324634,-2.3275914,0.1345770,0.0677251,-2.3927081,52.1324543,-2.3275891,0.1366499,0.0690440,-2.2383304
-1615570245,52.1324635,-2.3275913,0.1338232,0.0660173,-1.9919409,52.1324543,-2.3275891,0.1366712,0.0690544,-2.2383268
-1615570245,52.1324636,-2.3275912,0.1330784,0.0652854,-2.4736111,52.1324543,-2.3275891,0.1366948,0.0690700,-2.2383728
-1615570246,52.1324637,-2.3275912,0.1318718,0.0679691,-2.4593029,52.1324543,-2.3275891,0.1366710,0.0690943,-2.2388387
-1615570246,52.1324637,-2.3275912,0.1313666,0.0665052,-2.0195782,52.1324544,-2.3275891,0.1367012,0.0690994,-2.2387090
-1615570246,52.1324637,-2.3275912,0.1308703,0.0660173,-2.0813401,52.1324544,-2.3275891,0.1366829,0.0690949,-2.2387695
-1615570247,52.1324639,-2.3275913,0.1309143,0.0708973,-2.6203997,52.1324544,-2.3275891,0.1366427,0.0691180,-2.2393250
-1615570247,52.1324639,-2.3275912,0.1293985,0.0665052,-2.3742430,52.1324544,-2.3275891,0.1366220,0.0690913,-2.2391162
-1615570247,52.1324640,-2.3275912,0.1298948,0.0669931,-2.2680912,52.1324545,-2.3275891,0.1366349,0.0691003,-2.2391486
-1615570248,52.1324641,-2.3275911,0.1298863,0.0660173,-2.3172717,52.1324545,-2.3275891,0.1366081,0.0690876,-2.2391591
-1615570248,52.1324642,-2.3275911,0.1346022,0.0704092,2.5933774,52.1324545,-2.3275891,0.1366163,0.0691067,-2.2393503
-1615570249,52.1324642,-2.3275911,0.1308536,0.0640657,-2.1946912,52.1324545,-2.3275891,0.1366119,0.0690970,-2.2392540
-1615570249,52.1324643,-2.3275910,0.1325905,0.0657733,-2.3713048,52.1324546,-2.3275891,0.1365683,0.0691057,-2.2396474
-1615570249,52.1324643,-2.3275910,0.1335579,0.0638218,-2.4825187,52.1324546,-2.3275892,0.1365839,0.0690996,-2.2394674
-1615570250,52.1324644,-2.3275910,0.1340417,0.0628461,-2.4643645,52.1324546,-2.3275892,0.1365647,0.0691143,-2.2397814
-1615570250,52.1324644,-2.3275910,0.1320754,0.0630900,-2.2792120,52.1324547,-2.3275892,0.1365641,0.0691390,-2.2401023
-1615570250,52.1324645,-2.3275910,0.1335792,0.0662612,-2.0057530,52.1324547,-2.3275892,0.1365710,0.0691371,-2.2400324
-1615570251,52.1324646,-2.3275910,0.1323662,0.0682131,-2.3833389,52.1324547,-2.3275892,0.1365546,0.0691504,-2.2403090
-1615570251,52.1324646,-2.3275910,0.1348077,0.0660173,-1.9387301,52.1324547,-2.3275892,0.1365122,0.0691688,-2.2408187
-1615570252,52.1324646,-2.3275910,0.1288961,0.0652854,-2.0830896,52.1324548,-2.3275892,0.1364861,0.0691336,-2.2405362
-1615570252,52.1324647,-2.3275910,0.1350539,0.0660173,-1.9342046,52.1324548,-2.3275892,0.1364629,0.0691030,-2.2402916
-1615570252,52.1324647,-2.3275911,0.1333353,0.0665052,-2.1627121,52.1324548,-2.3275892,0.1363859,0.0691173,-2.2409742
-1615570253,52.1324647,-2.3275911,0.1330741,0.0647975,-2.5763791,52.1324548,-2.3275892,0.1363845,0.0691022,-2.2407882
-1615570253,52.1324648,-2.3275911,0.1321048,0.0665052,-2.3899012,52.1324549,-2.3275892,0.1363930,0.0691134,-2.2408786
-1615570253,52.1324648,-2.3275910,0.1318376,0.0640657,-2.2225955,52.1324549,-2.3275892,0.1364021,0.0691330,-2.2410715
-1615570254,52.1324648,-2.3275910,0.1328607,0.0684571,-2.3984621,52.1324549,-2.3275892,0.1363736,0.0691359,-2.2412932
-1615570254,52.1324648,-2.3275910,0.1328652,0.0689451,-1.9563936,52.1324549,-2.3275892,0.1363774,0.0691446,-2.2413802
-1615570255,52.1324649,-2.3275910,0.1294135,0.0682131,-2.5705581,52.1324550,-2.3275892,0.1364168,0.0691458,-2.2411404
-1615570255,52.1324649,-2.3275911,0.1314020,0.0704092,-2.3679249,52.1324550,-2.3275892,0.1364066,0.0691386,-2.2411134
-1615570255,52.1324649,-2.3275910,0.1313710,0.0669931,-2.4954081,52.1324550,-2.3275892,0.1364372,0.0691420,-2.2409601
-1615570256,52.1324650,-2.3275909,0.1316170,0.0669931,-1.7332793,52.1324550,-2.3275892,0.1364537,0.0691366,-2.2407830
-1615570256,52.1324650,-2.3275910,0.1333597,0.0691891,-2.4215493,52.1324551,-2.3275892,0.1364724,0.0691737,-2.2411399
-1615570256,52.1324651,-2.3275910,0.1328835,0.0708973,-2.6004331,52.1324551,-2.3275892,0.1364886,0.0691693,-2.2409790
-1615570257,52.1324651,-2.3275910,0.1353247,0.0687011,-1.8641306,52.1324551,-2.3275892,0.1364831,0.0692046,-2.2414665
-1615570257,52.1324652,-2.3275909,0.1316368,0.0691891,-2.3866622,52.1324551,-2.3275892,0.1364631,0.0692028,-2.2415731
-1615570258,52.1324652,-2.3275909,0.1335663,0.0647975,-2.4202509,52.1324552,-2.3275893,0.1365116,0.0691562,-2.2406616
-1615570258,52.1324653,-2.3275909,0.1308767,0.0667492,-2.3703718,52.1324552,-2.3275893,0.1365295,0.0691096,-2.2399471
-1615570258,52.1324653,-2.3275909,0.1316041,0.0655293,-2.8568416,52.1324552,-2.3275893,0.1365439,0.0691132,-2.2399013
-1615570259,52.1324653,-2.3275908,0.1309075,0.0701652,-2.4167390,52.1324553,-2.3275893,0.1365715,0.0691257,-2.2398820
-1615570259,52.1324653,-2.3275909,0.1318397,0.0643096,-2.3646824,52.1324553,-2.3275893,0.1365539,0.0691237,-2.2399702
-1615570259,52.1324654,-2.3275910,0.1313539,0.0650414,-2.2687340,52.1324553,-2.3275893,0.1365848,0.0691334,-2.2398946
-1615570260,52.1324655,-2.3275910,0.1353362,0.0699211,-2.5221190,52.1324553,-2.3275893,0.1365670,0.0691314,-2.2399836
-1615570260,52.1324655,-2.3275910,0.1328562,0.0679691,-2.7100596,52.1324554,-2.3275893,0.1365562,0.0690758,-2.2393403
-1615570261,52.1324655,-2.3275910,0.1308832,0.0674811,-1.8078831,52.1324554,-2.3275893,0.1365940,0.0690652,-2.2389598
-1615570261,52.1324655,-2.3275911,0.1326079,0.0677251,-3.1128917,52.1324554,-2.3275893,0.1366003,0.0691040,-2.2394171
-1615570261,52.1324654,-2.3275912,0.1308767,0.0667492,-2.7947206,52.1324554,-2.3275893,0.1366348,0.0690937,-2.2390618
-1615570262,52.1324655,-2.3275912,0.1291278,0.0635778,-1.8176768,52.1324555,-2.3275893,0.1366319,0.0691050,-2.2392251
-1615570262,52.1324655,-2.3275912,0.1331113,0.0689451,-2.3221021,52.1324555,-2.3275893,0.1366150,0.0690795,-2.2390084
-1615570262,52.1324654,-2.3275912,0.1299143,0.0691891,-3.0630550,52.1324555,-2.3275893,0.1366357,0.0690989,-2.2391229
-1615570263,52.1324654,-2.3275913,0.1291718,0.0687011,-2.0641611,52.1324555,-2.3275893,0.1366309,0.0690756,-2.2388549
-1615570263,52.1324654,-2.3275914,0.1333056,0.0630900,-2.3660834,52.1324556,-2.3275893,0.1366326,0.0690858,-2.2389746
-1615570264,52.1324654,-2.3275914,0.1338188,0.0655293,-2.4290774,52.1324556,-2.3275893,0.1366561,0.0691075,-2.2391009
-1615570264,52.1324654,-2.3275915,0.1313645,0.0662612,-2.4000692,52.1324556,-2.3275893,0.1366361,0.0691241,-2.2394428
-1615570264,52.1324654,-2.3275915,0.1343154,0.0660173,-2.1441722,52.1324556,-2.3275893,0.1366388,0.0691054,-2.2391853
-1615570265,52.1324653,-2.3275915,0.1350539,0.0660173,-1.7251676,52.1324556,-2.3275893,0.1365937,0.0691174,-2.2396305
-1615570265,52.1324653,-2.3275916,0.1328518,0.0674811,-1.6225353,52.1324557,-2.3275893,0.1365899,0.0691208,-2.2396998
-1615570265,52.1324653,-2.3275917,0.1294245,0.0694331,-2.7243690,52.1324557,-2.3275894,0.1366075,0.0691063,-2.2393999
-1615570266,52.1324653,-2.3275917,0.1308454,0.0630900,-2.0125787,52.1324557,-2.3275894,0.1365976,0.0690669,-2.2389581
-1615570266,52.1324653,-2.3275917,0.1328431,0.0665052,-2.0536323,52.1324557,-2.3275894,0.1365776,0.0690402,-2.2387440
-1615570267,52.1324653,-2.3275917,0.1335579,0.0638218,-2.3147879,52.1324558,-2.3275894,0.1366345,0.0690538,-2.2385509
-1615570267,52.1324653,-2.3275918,0.1308746,0.0665052,-2.3070066,52.1324558,-2.3275894,0.1366269,0.0690603,-2.2386832
-1615570267,52.1324653,-2.3275918,0.1313581,0.0655293,-2.0659959,52.1324558,-2.3275894,0.1366346,0.0691138,-2.2393198
-1615570268,52.1324653,-2.3275919,0.1328629,0.0687011,-2.3965812,52.1324558,-2.3275894,0.1366408,0.0691177,-2.2393301
-1615570268,52.1324652,-2.3275919,0.1343198,0.0665052,-2.2367747,52.1324559,-2.3275894,0.1366409,0.0691159,-2.2393067
-1615570268,52.1324652,-2.3275918,0.1328260,0.0645536,-1.9227111,52.1324559,-2.3275894,0.1366789,0.0690966,-2.2388134
-1615570269,52.1324651,-2.3275915,0.1367619,0.0643096,-2.4453321,52.1324559,-2.3275894,0.1367246,0.0691028,-2.2385991
-1615570269,52.1324650,-2.3275911,0.1375272,0.0672371,-2.2947049,52.1324559,-2.3275894,0.1367452,0.0690822,-2.2382014
-1615570270,52.1324649,-2.3275907,0.1345748,0.0674811,-1.7375684,52.1324559,-2.3275894,0.1367446,0.0691015,-2.2384529
-1615570270,52.1324648,-2.3275903,0.1350517,0.0657733,-2.1722901,52.1324560,-2.3275894,0.1367433,0.0690730,-2.2380960
-1615570270,52.1324647,-2.3275899,0.1308640,0.0652854,-2.6115921,52.1324560,-2.3275894,0.1367751,0.0691069,-2.2383261
-1615570271,52.1324646,-2.3275896,0.1328238,0.0643096,-2.1745753,52.1324560,-2.3275894,0.1367585,0.0690658,-2.2379055
-1615570271,52.1324646,-2.3275892,0.1321268,0.0689451,-2.2592955,52.1324560,-2.3275894,0.1367726,0.0690802,-2.2379992
-1615570271,52.1324646,-2.3275889,0.1345704,0.0669931,-1.7537675,52.1324560,-2.3275894,0.1367391,0.0691245,-2.2387824
-1615570272,52.1324646,-2.3275886,0.1333758,0.0708973,-2.1024752,52.1324561,-2.3275894,0.1367478,0.0691561,-2.2391303
-1615570272,52.1324647,-2.3275883,0.1343421,0.0689451,-2.5262628,52.1324561,-2.3275894,0.1367643,0.0691603,-2.2390785
-1615570273,52.1324645,-2.3275880,0.1330595,0.0630900,-2.0946226,52.1324561,-2.3275894,0.1367964,0.0691637,-2.2389145
-1615570273,52.1324646,-2.3275877,0.1306821,0.0723616,-2.7686234,52.1324561,-2.3275894,0.1367773,0.0691967,-2.2394605
-1615570273,52.1324646,-2.3275874,0.1362760,0.0650414,-2.3519251,52.1324561,-2.3275894,0.1367922,0.0691883,-2.2392569
-1615570274,52.1324646,-2.3275870,0.1281624,0.0657733,-2.1650743,52.1324562,-2.3275894,0.1367798,0.0691665,-2.2390573
-1615570274,52.1324646,-2.3275867,0.1264493,0.0667492,-1.9266732,52.1324562,-2.3275894,0.1367654,0.0691726,-2.2392282
-1615570274,52.1324647,-2.3275864,0.1321005,0.0660173,-2.7401512,52.1324562,-2.3275894,0.1367756,0.0691980,-2.2394876
-1615570275,52.1324647,-2.3275861,0.1330784,0.0652854,-2.1707222,52.1324562,-2.3275894,0.1367672,0.0691649,-2.2391181
-1615570275,52.1324647,-2.3275859,0.1313710,0.0669931,-2.4151559,52.1324562,-2.3275894,0.1367729,0.0691837,-2.2393219
-1615570276,52.1324648,-2.3275856,0.1303804,0.0662612,-2.3235333,52.1324563,-2.3275894,0.1367844,0.0692043,-2.2395115
-1615570276,52.1324648,-2.3275854,0.1303375,0.0611388,-2.5269580,52.1324563,-2.3275894,0.1367644,0.0691745,-2.2392597
-1615570276,52.1324648,-2.3275851,0.1313753,0.0674811,-2.5896647,52.1324563,-2.3275893,0.1366674,0.0691431,-2.2394817
-1615570277,52.1324649,-2.3275850,0.1345594,0.0657733,-2.0028915,52.1324563,-2.3275893,0.1366804,0.0691656,-2.2396865
-1615570277,52.1324650,-2.3275848,0.1318566,0.0662612,-2.5515172,52.1324563,-2.3275893,0.1366361,0.0691136,-2.2393055
-1615570277,52.1324650,-2.3275845,0.1311491,0.0696771,-2.0609202,52.1324564,-2.3275893,0.1366500,0.0690924,-2.2389433
-1615570278,52.1324651,-2.3275843,0.1335814,0.0665052,-2.1789522,52.1324564,-2.3275893,0.1366669,0.0690857,-2.2387488
-1615570278,52.1324651,-2.3275843,0.1320899,0.0647975,-2.7209640,52.1324564,-2.3275893,0.1367075,0.0690845,-2.2384725
-1615570279,52.1324651,-2.3275841,0.1289237,0.0684571,-1.8639487,52.1324564,-2.3275893,0.1366971,0.0690657,-2.2382979
-1615570279,52.1324652,-2.3275840,0.1343264,0.0672371,-1.8611042,52.1324564,-2.3275893,0.1367084,0.0690421,-2.2379224
-1615570279,52.1324652,-2.3275839,0.1362870,0.0662612,-2.2376661,52.1324565,-2.3275893,0.1367197,0.0690994,-2.2385833
-1615570280,52.1324653,-2.3275837,0.1342674,0.0604072,-2.3174658,52.1324565,-2.3275892,0.1367210,0.0691119,-2.2387362
-1615570280,52.1324654,-2.3275835,0.1347969,0.0647975,-2.2370455,52.1324565,-2.3275892,0.1367350,0.0691379,-2.2389793
-1615570280,52.1324653,-2.3275835,0.1363166,0.0694331,-2.7088974,52.1324565,-2.3275892,0.1367733,0.0691401,-2.2387600
-1615570281,52.1324654,-2.3275833,0.1335836,0.0667492,-1.8420702,52.1324565,-2.3275892,0.1367755,0.0691416,-2.2387657
-1615570281,52.1324654,-2.3275833,0.1316391,0.0694331,-1.9362042,52.1324566,-2.3275892,0.1368003,0.0691073,-2.2381673
-1615570282,52.1324655,-2.3275832,0.1308919,0.0684571,-2.4376340,52.1324566,-2.3275892,0.1368323,0.0691119,-2.2380195
-1615570282,52.1324655,-2.3275830,0.1316257,0.0679691,-2.1244843,52.1324566,-2.3275892,0.1368510,0.0690970,-2.2377083
-1615570282,52.1324656,-2.3275829,0.1348461,0.0701652,-2.1470313,52.1324566,-2.3275892,0.1368353,0.0690850,-2.2376559
-1615570283,52.1324657,-2.3275827,0.1355462,0.0660173,-2.2131679,52.1324566,-2.3275891,0.1368051,0.0690931,-2.2379537
-1615570283,52.1324658,-2.3275825,0.1345704,0.0669931,-2.2235661,52.1324567,-2.3275891,0.1367583,0.0691034,-2.2383876
-1615570283,52.1324658,-2.3275824,0.1316302,0.0684571,-2.4705930,52.1324567,-2.3275891,0.1367157,0.0691106,-2.2387540
-1615570284,52.1324660,-2.3275822,0.1360520,0.0674811,-2.4176018,52.1324567,-2.3275891,0.1366967,0.0691751,-2.2397029
-1615570284,52.1324660,-2.3275821,0.1335770,0.0660173,-2.6881850,52.1324567,-2.3275891,0.1366974,0.0691488,-2.2393618
-1615570285,52.1324661,-2.3275819,0.1306076,0.0640657,-2.1685584,52.1324567,-2.3275891,0.1366444,0.0691069,-2.2391646
-1615570285,52.1324662,-2.3275818,0.1355484,0.0662612,-2.4502797,52.1324568,-2.3275890,0.1366431,0.0690756,-2.2387724
-1615570285,52.1324663,-2.3275817,0.1325862,0.0652854,-2.1169538,52.1324568,-2.3275890,0.1366471,0.0691052,-2.2391248
-1615570286,52.1324664,-2.3275815,0.1341028,0.0696771,-2.0842819,52.1324568,-2.3275890,0.1366489,0.0691168,-2.2392628
-1615570286,52.1324665,-2.3275815,0.1379779,0.0626022,-2.4989414,52.1324568,-2.3275890,0.1366537,0.0691568,-2.2397447
-1615570286,52.1324665,-2.3275813,0.1323574,0.0672371,-2.1934865,52.1324568,-2.3275890,0.1366627,0.0691167,-2.2391732
-1615570287,52.1324666,-2.3275811,0.1382480,0.0652854,-1.8080033,52.1324569,-2.3275890,0.1366390,0.0691167,-2.2393250
-1615570287,52.1324668,-2.3275810,0.1308810,0.0672371,-2.6483846,52.1324569,-2.3275889,0.1365944,0.0691076,-2.2394958
-1615570288,52.1324669,-2.3275809,0.1353156,0.0677251,-1.9924023,52.1324569,-2.3275889,0.1366023,0.0691579,-2.2400904
-1615570288,52.1324669,-2.3275808,0.1320962,0.0655293,-2.4653835,52.1324569,-2.3275889,0.1366411,0.0691464,-2.2396922
-1615570288,52.1324671,-2.3275806,0.1298596,0.0628461,-2.3388114,52.1324569,-2.3275889,0.1365637,0.0691557,-2.2403100
-1615570289,52.1324671,-2.3275805,0.1331091,0.0687011,-2.7562652,52.1324570,-2.3275889,0.1365591,0.0691314,-2.2400289
-1615570289,52.1324673,-2.3275804,0.1321070,0.0667492,-2.1284261,52.1324570,-2.3275889,0.1365684,0.0691615,-2.2403550
-1615570289,52.1324673,-2.3275802,0.1333035,0.0628461,-2.2907310,52.1324570,-2.3275888,0.1365697,0.0691686,-2.2404366
-1615570290,52.1324673,-2.3275801,0.1304290,0.0716294,-2.4574327,52.1324570,-2.3275888,0.1365849,0.0691812,-2.2405002
-1615570290,52.1324674,-2.3275799,0.1316192,0.0672371,-2.1302624,52.1324571,-2.3275888,0.1366202,0.0691936,-2.2404320
-1615570291,52.1324675,-2.3275798,0.1301582,0.0689451,-2.2681944,52.1324571,-2.3275888,0.1366080,0.0692074,-2.2406862
-1615570291,52.1324675,-2.3275796,0.1321201,0.0682131,-2.5681078,52.1324571,-2.3275888,0.1365946,0.0692476,-2.2412879
-1615570291,52.1324675,-2.3275794,0.1345704,0.0669931,-2.3620965,52.1324571,-2.3275887,0.1366079,0.0692535,-2.2412784
-1615570292,52.1324676,-2.3275793,0.1345572,0.0655293,-2.2195425,52.1324571,-2.3275887,0.1365928,0.0692648,-2.2415204
-1615570292,52.1324677,-2.3275791,0.1306055,0.0638218,-2.3370123,52.1324572,-2.3275887,0.1366129,0.0692501,-2.2412033
-1615570292,52.1324678,-2.3275789,0.1350302,0.0633339,-2.4292965,52.1324572,-2.3275887,0.1365668,0.0692704,-2.2417598
-1615570293,52.1324679,-2.3275788,0.1301538,0.0684571,-2.6368399,52.1324572,-2.3275887,0.1366139,0.0692650,-2.2413862
-1615570293,52.1324680,-2.3275787,0.1365444,0.0674811,-2.0285053,52.1324572,-2.3275886,0.1365526,0.0692402,-2.2414639
-1615570294,52.1324681,-2.3275786,0.1345637,0.0662612,-2.3198557,52.1324573,-2.3275886,0.1365803,0.0692961,-2.2420015
-1615570294,52.1324682,-2.3275785,0.1369704,0.0599194,-2.3276792,52.1324573,-2.3275886,0.1365559,0.0692880,-2.2420552
-1615570294,52.1324683,-2.3275784,0.1318481,0.0652854,-2.0619502,52.1324573,-2.3275886,0.1366334,0.0692639,-2.2412469
-1615570295,52.1324683,-2.3275783,0.1338498,0.0689451,-2.1367955,52.1324573,-2.3275886,0.1366642,0.0692489,-2.2408569
-1615570295,52.1324684,-2.3275782,0.1320733,0.0628461,-2.2343736,52.1324573,-2.3275885,0.1366440,0.0693019,-2.2416649
-1615570295,52.1324685,-2.3275782,0.1318439,0.0647975,-2.3678992,52.1324574,-2.3275885,0.1366405,0.0692922,-2.2415638
-1615570296,52.1324686,-2.3275782,0.1347969,0.0647975,-2.1207471,52.1324574,-2.3275885,0.1366709,0.0692276,-2.2405410
-1615570296,52.1324687,-2.3275781,0.1308767,0.0667492,-2.1015084,52.1324574,-2.3275885,0.1366219,0.0692264,-2.2408412
-1615570297,52.1324689,-2.3275780,0.1328431,0.0665052,-2.3720725,52.1324574,-2.3275885,0.1366180,0.0692477,-2.2411385
-1615570297,52.1324689,-2.3275779,0.1338253,0.0662612,-1.9711852,52.1324575,-2.3275884,0.1366643,0.0692276,-2.2405844
-1615570297,52.1324690,-2.3275779,0.1335496,0.0628461,-2.1766129,52.1324575,-2.3275884,0.1366277,0.0692687,-2.2413459
-1615570298,52.1324691,-2.3275779,0.1333375,0.0667492,-2.2735252,52.1324575,-2.3275884,0.1366540,0.0692738,-2.2412415
-1615570298,52.1324692,-2.3275779,0.1320962,0.0655293,-2.6351345,52.1324575,-2.3275884,0.1366695,0.0692431,-2.2407491
-1615570298,52.1324692,-2.3275779,0.1352870,0.0645536,-2.1129072,52.1324576,-2.3275884,0.1367159,0.0692370,-2.2403727
-1615570299,52.1324692,-2.3275778,0.1340500,0.0638218,-2.3888884,52.1324576,-2.3275883,0.1367146,0.0692468,-2.2405057
-1615570299,52.1324693,-2.3275779,0.1323640,0.0679691,-2.3834631,52.1324576,-2.3275883,0.1366844,0.0692591,-2.2408571
-1615570300,52.1324693,-2.3275779,0.1313952,0.0696771,-2.1644325,52.1324576,-2.3275883,0.1366876,0.0692875,-2.2411997
-1615570300,52.1324694,-2.3275779,0.1301116,0.0635778,-2.6462705,52.1324576,-2.3275883,0.1366601,0.0693179,-2.2417660
-1615570300,52.1324694,-2.3275779,0.1313775,0.0677251,-1.9777179,52.1324577,-2.3275882,0.1366766,0.0693500,-2.2420695
-1615570301,52.1324695,-2.3275778,0.1325884,0.0655293,-2.5498376,52.1324577,-2.3275882,0.1366407,0.0693242,-2.2419705
-1615570301,52.1324695,-2.3275779,0.1357858,0.0652854,-2.4378467,52.1324577,-2.3275882,0.1365991,0.0693538,-2.2426167
-1615570301,52.1324696,-2.3275779,0.1347947,0.0645536,-2.4806340,52.1324577,-2.3275882,0.1365713,0.0693556,-2.2428188
-1615570302,52.1324696,-2.3275779,0.1343606,0.0708973,-2.7848685,52.1324578,-2.3275882,0.1365319,0.0693525,-2.2430336
-1615570302,52.1324697,-2.3275778,0.1343399,0.0687011,-2.3828306,52.1324578,-2.3275881,0.1365058,0.0693168,-2.2427435
-1615570303,52.1324698,-2.3275779,0.1306180,0.0652854,-2.1109781,52.1324578,-2.3275881,0.1364931,0.0693760,-2.2435837
-1615570303,52.1324697,-2.3275778,0.1301716,0.0704092,-2.4373930,52.1324578,-2.3275881,0.1364881,0.0693797,-2.2436626
-1615570303,52.1324698,-2.3275778,0.1340376,0.0623583,-1.7337061,52.1324579,-2.3275881,0.1365120,0.0693837,-2.2435606
-1615570304,52.1324699,-2.3275778,0.1333552,0.0687011,-2.3134038,52.1324579,-2.3275881,0.1365114,0.0693388,-2.2429893
-1615570304,52.1324699,-2.3275778,0.1340915,0.0684571,-2.1578665,52.1324579,-2.3275880,0.1365032,0.0693255,-2.2428730
-1615570304,52.1324699,-2.3275778,0.1353133,0.0674811,-1.6195058,52.1324579,-2.3275880,0.1365081,0.0693258,-2.2428446
-1615570305,52.1324698,-2.3275778,0.1360475,0.0669931,-2.0681198,52.1324579,-2.3275880,0.1365414,0.0693068,-2.2423863
-1615570305,52.1324698,-2.3275779,0.1309030,0.0696771,-2.0102599,52.1324580,-2.3275880,0.1365007,0.0693148,-2.2427516
-1615570306,52.1324699,-2.3275779,0.1333463,0.0677251,-2.1158423,52.1324580,-2.3275880,0.1364836,0.0693233,-2.2429707
-1615570306,52.1324699,-2.3275779,0.1313581,0.0655293,-2.1661634,52.1324580,-2.3275879,0.1365093,0.0693215,-2.2427812
-1615570306,52.1324699,-2.3275779,0.1281835,0.0682131,-1.9195298,52.1324580,-2.3275879,0.1364883,0.0693158,-2.2428441
-1615570307,52.1324700,-2.3275779,0.1310793,0.0616266,-1.9714652,52.1324581,-2.3275879,0.1364697,0.0692831,-2.2425447
-1615570307,52.1324700,-2.3275778,0.1318785,0.0687011,-2.1114175,52.1324581,-2.3275879,0.1364594,0.0693018,-2.2428505
-1615570307,52.1324700,-2.3275778,0.1281666,0.0662612,-2.3521926,52.1324581,-2.3275879,0.1364186,0.0693245,-2.2434053
-1615570308,52.1324700,-2.3275777,0.1323317,0.0643096,-2.0727162,52.1324581,-2.3275879,0.1363718,0.0693327,-2.2438111
-1615570308,52.1324700,-2.3275777,0.1286502,0.0652854,-2.3185463,52.1324582,-2.3275878,0.1363461,0.0693697,-2.2444520
-1615570309,52.1324700,-2.3275777,0.1345637,0.0662612,-1.8801963,52.1324582,-2.3275878,0.1362720,0.0693814,-2.2450805
-1615570309,52.1324701,-2.3275776,0.1330678,0.0640657,-2.0101182,52.1324582,-2.3275878,0.1362706,0.0694107,-2.2454667
-1615570309,52.1324701,-2.3275776,0.1336151,0.0701652,-2.0309832,52.1324582,-2.3275878,0.1362673,0.0693853,-2.2451618
-1615570310,52.1324701,-2.3275775,0.1352913,0.0650414,-2.3534067,52.1324582,-2.3275878,0.1362482,0.0693866,-2.2453012
-1615570310,52.1324701,-2.3275774,0.1328453,0.0667492,-1.9914298,52.1324583,-2.3275877,0.1362813,0.0694128,-2.2454247
-1615570310,52.1324701,-2.3275774,0.1326035,0.0672371,-2.2946153,52.1324583,-2.3275877,0.1363263,0.0693963,-2.2449226
-1615570311,52.1324701,-2.3275773,0.1321113,0.0672371,-2.5512769,52.1324583,-2.3275877,0.1363300,0.0693959,-2.2448936
-1615570311,52.1324701,-2.3275773,0.1301116,0.0635778,-2.1825340,52.1324583,-2.3275877,0.1363269,0.0694002,-2.2449684
-1615570312,52.1324701,-2.3275771,0.1286461,0.0647975,-1.9545983,52.1324584,-2.3275877,0.1362923,0.0694171,-2.2454085
-1615570312,52.1324700,-2.3275772,0.1318875,0.0696771,-2.3498471,52.1324584,-2.3275876,0.1363258,0.0694270,-2.2453187
-1615570312,52.1324701,-2.3275771,0.1335880,0.0672371,-1.9718094,52.1324584,-2.3275876,0.1363271,0.0694208,-2.2452314
-1615570313,52.1324701,-2.3275770,0.1338430,0.0682131,-2.4819238,52.1324584,-2.3275876,0.1363251,0.0694204,-2.2452388
-1615570313,52.1324701,-2.3275769,0.1293757,0.0638218,-2.3633728,52.1324584,-2.3275876,0.1362805,0.0694311,-2.2456639
-1615570313,52.1324701,-2.3275768,0.1338167,0.0652854,-2.2454412,52.1324585,-2.3275876,0.1362955,0.0694472,-2.2457743
-1615570314,52.1324702,-2.3275767,0.1328518,0.0674811,-2.4608231,52.1324585,-2.3275875,0.1362967,0.0694257,-2.2454908
-1615570314,52.1324702,-2.3275767,0.1328094,0.0626022,-1.7610680,52.1324585,-2.3275875,0.1362796,0.0694327,-2.2456901
-1615570315,52.1324702,-2.3275767,0.1338521,0.0691891,-2.1267664,52.1324585,-2.3275875,0.1362501,0.0694107,-2.2455978
-1615570315,52.1324702,-2.3275766,0.1296466,0.0667492,-2.0934820,52.1324586,-2.3275875,0.1362480,0.0693950,-2.2454095
-1615570315,52.1324702,-2.3275765,0.1345838,0.0684571,-2.2806411,52.1324586,-2.3275875,0.1362802,0.0694044,-2.2453232
-1615570316,52.1324701,-2.3275765,0.1328281,0.0647975,-2.4502125,52.1324586,-2.3275874,0.1362728,0.0693462,-2.2446237
-1615570316,52.1324702,-2.3275764,0.1318523,0.0657733,-2.2827225,52.1324586,-2.3275874,0.1362599,0.0693920,-2.2452958
-1615570316,52.1324702,-2.3275764,0.1323509,0.0665052,-2.1410873,52.1324586,-2.3275874,0.1362517,0.0693695,-2.2450585
-1615570317,52.1324702,-2.3275763,0.1296176,0.0633339,-2.2482839,52.1324587,-2.3275874,0.1362696,0.0693185,-2.2442870
-1615570317,52.1324702,-2.3275762,0.1352785,0.0635778,-2.6403680,52.1324587,-2.3275874,0.1362254,0.0692600,-2.2438202
-1615570318,52.1324702,-2.3275761,0.1338145,0.0650414,-2.7616181,52.1324587,-2.3275873,0.1362086,0.0692486,-2.2437830
-1615570318,52.1324703,-2.3275761,0.1303678,0.0647975,-2.2853835,52.1324587,-2.3275873,0.1361914,0.0692149,-2.2434602
-1615570318,52.1324703,-2.3275761,0.1348323,0.0687011,-2.1682115,52.1324587,-2.3275873,0.1362139,0.0691945,-2.2430520
-1615570319,52.1324703,-2.3275761,0.1306637,0.0704092,-2.5321016,52.1324588,-2.3275873,0.1361667,0.0691951,-2.2433650
-1615570319,52.1324702,-2.3275760,0.1353270,0.0689451,-2.4160972,52.1324588,-2.3275873,0.1361327,0.0691909,-2.2435308
-1615570319,52.1324702,-2.3275760,0.1298800,0.0652854,-2.1305592,52.1324588,-2.3275872,0.1361948,0.0692180,-2.2434771
-1615570320,52.1324701,-2.3275759,0.1316436,0.0699211,-2.9133475,52.1324588,-2.3275872,0.1361995,0.0692319,-2.2436261
-1615570320,52.1324700,-2.3275759,0.1338319,0.0669931,-2.2587917,52.1324588,-2.3275872,0.1361750,0.0692442,-2.2439435
-1615570321,52.1324700,-2.3275758,0.1333485,0.0679691,-2.5657308,52.1324589,-2.3275872,0.1361809,0.0692202,-2.2435961
-1615570321,52.1324700,-2.3275758,0.1323509,0.0665052,-2.3628054,52.1324589,-2.3275872,0.1361703,0.0692402,-2.2439215
-1615570321,52.1324700,-2.3275757,0.1291784,0.0694331,-2.2075510,52.1324589,-2.3275871,0.1361880,0.0692162,-2.2434986
-1615570322,52.1324699,-2.3275756,0.1380152,0.0667492,-1.9004579,52.1324589,-2.3275871,0.1361450,0.0691884,-2.2434194
-1615570322,52.1324699,-2.3275755,0.1316504,0.0706532,-3.0492504,52.1324589,-2.3275871,0.1362027,0.0691969,-2.2431550
-1615570322,52.1324699,-2.3275755,0.1306525,0.0691891,-2.6109300,52.1324590,-2.3275871,0.1361917,0.0691767,-2.2429669
-1615570323,52.1324698,-2.3275754,0.1333181,0.0645536,-1.7983775,52.1324590,-2.3275870,0.1362075,0.0691695,-2.2427721
-1615570323,52.1324698,-2.3275753,0.1279312,0.0674811,-2.4931002,52.1324590,-2.3275870,0.1362022,0.0691756,-2.2428839
-1615570324,52.1324697,-2.3275753,0.1333485,0.0679691,-2.0310311,52.1324590,-2.3275870,0.1362018,0.0692114,-2.2433469
-1615570324,52.1324697,-2.3275752,0.1348121,0.0665052,-1.9647678,52.1324590,-2.3275870,0.1362571,0.0692067,-2.2429287
-1615570324,52.1324696,-2.3275752,0.1355289,0.0640657,-2.2509637,52.1324591,-2.3275870,0.1362534,0.0692308,-2.2432628
-1615570325,52.1324695,-2.3275752,0.1326057,0.0674811,-2.3010876,52.1324591,-2.3275869,0.1362914,0.0692742,-2.2435760
-1615570325,52.1324694,-2.3275751,0.1298948,0.0669931,-1.9695313,52.1324591,-2.3275869,0.1363563,0.0692970,-2.2434487
-1615570325,52.1324693,-2.3275751,0.1355778,0.0694331,-2.5672255,52.1324591,-2.3275869,0.1363646,0.0692696,-2.2430444
-1615570326,52.1324693,-2.3275751,0.1318460,0.0650414,-2.1717052,52.1324591,-2.3275869,0.1363765,0.0693039,-2.2434072
-1615570326,52.1324691,-2.3275750,0.1266952,0.0667492,-2.2957413,52.1324591,-2.3275869,0.1363187,0.0693411,-2.2442575
-1615570327,52.1324691,-2.3275750,0.1370624,0.0701652,-2.7207887,52.1324592,-2.3275868,0.1362913,0.0693443,-2.2444749
-1615570327,52.1324689,-2.3275750,0.1277522,0.0748025,-1.9319230,52.1324592,-2.3275868,0.1362603,0.0693625,-2.2449090
-1615570327,52.1324689,-2.3275750,0.1336197,0.0706532,-2.2554622,52.1324592,-2.3275868,0.1362677,0.0693398,-2.2445700
-1615570328,52.1324688,-2.3275750,0.1320941,0.0652854,-2.1967349,52.1324592,-2.3275868,0.1362443,0.0692828,-2.2439892
-1615570328,52.1324688,-2.3275750,0.1345906,0.0691891,-1.9048971,52.1324592,-2.3275868,0.1362588,0.0693162,-2.2443242
-1615570328,52.1324687,-2.3275749,0.1341051,0.0699211,-2.3659360,52.1324592,-2.3275867,0.1362619,0.0693965,-2.2453353
-1615570329,52.1324687,-2.3275749,0.1350627,0.0669931,-2.3948364,52.1324593,-2.3275867,0.1363072,0.0694297,-2.2454691
-1615570329,52.1324687,-2.3275750,0.1360565,0.0679691,-2.1675272,52.1324593,-2.3275867,0.1363188,0.0694060,-2.2450910
-1615570330,52.1324686,-2.3275749,0.1345277,0.0621144,-2.1922071,52.1324593,-2.3275867,0.1363124,0.0693971,-2.2450173
-1615570330,52.1324685,-2.3275750,0.1267142,0.0689451,-1.8646595,52.1324593,-2.3275867,0.1363203,0.0693632,-2.2445314
-1615570330,52.1324685,-2.3275750,0.1313907,0.0691891,-2.6071687,52.1324593,-2.3275866,0.1363350,0.0693786,-2.2446346
-1615570331,52.1324684,-2.3275751,0.1286734,0.0679691,-2.3617179,52.1324593,-2.3275866,0.1363812,0.0693922,-2.2445107
-1615570331,52.1324683,-2.3275751,0.1313666,0.0665052,-2.3616402,52.1324594,-2.3275866,0.1363574,0.0693344,-2.2439229
-1615570331,52.1324683,-2.3275752,0.1335946,0.0679691,-2.0577683,52.1324594,-2.3275866,0.1363467,0.0693608,-2.2443314
-1615570332,52.1324682,-2.3275753,0.1313797,0.0679691,-3.0006931,52.1324594,-2.3275866,0.1363657,0.0693758,-2.2444005
-1615570332,52.1324682,-2.3275753,0.1333441,0.0674811,-2.2776144,52.1324594,-2.3275865,0.1363938,0.0693438,-2.2438092
-1615570333,52.1324681,-2.3275755,0.1333507,0.0682131,-2.2123322,52.1324594,-2.3275865,0.1364091,0.0693042,-2.2432024
-1615570333,52.1324681,-2.3275755,0.1294179,0.0687011,-2.7577929,52.1324594,-2.3275865,0.1363438,0.0693134,-2.2437418
-1615570333,52.1324680,-2.3275756,0.1328453,0.0667492,-2.4837232,52.1324594,-2.3275865,0.1364019,0.0693398,-2.2437050
-1615570334,52.1324679,-2.3275756,0.1286691,0.0674811,-2.6596556,52.1324595,-2.3275865,0.1364006,0.0693174,-2.2434278
-1615570334,52.1324679,-2.3275757,0.1294289,0.0699211,-2.9168828,52.1324595,-2.3275864,0.1364261,0.0692789,-2.2427685
-1615570334,52.1324678,-2.3275757,0.1328135,0.0630900,-1.9865223,52.1324595,-2.3275864,0.1364601,0.0692929,-2.2427287
-1615570335,52.1324678,-2.3275757,0.1343220,0.0667492,-2.0829649,52.1324595,-2.3275864,0.1364781,0.0692948,-2.2426374
-1615570335,52.1324678,-2.3275757,0.1338060,0.0640657,-1.9504961,52.1324595,-2.3275864,0.1364528,0.0692842,-2.2426653
-1615570336,52.1324677,-2.3275757,0.1308875,0.0679691,-2.4257436,52.1324595,-2.3275864,0.1365007,0.0693304,-2.2429483
-1615570336,52.1324677,-2.3275757,0.1365332,0.0662612,-2.0938878,52.1324595,-2.3275864,0.1365285,0.0693538,-2.2430694
-1615570336,52.1324677,-2.3275757,0.1343309,0.0677251,-2.2207036,52.1324596,-2.3275863,0.1365099,0.0693582,-2.2432451
-1615570337,52.1324677,-2.3275757,0.1309030,0.0696771,-2.3508115,52.1324596,-2.3275863,0.1364516,0.0693229,-2.2431679
-1615570337,52.1324678,-2.3275757,0.1306264,0.0662612,-2.1599619,52.1324596,-2.3275863,0.1364453,0.0693384,-2.2434072
-1615570337,52.1324677,-2.3275756,0.1343220,0.0667492,-2.1596103,52.1324596,-2.3275863,0.1364187,0.0693142,-2.2432685
-1615570338,52.1324678,-2.3275757,0.1342983,0.0640657,-2.3407800,52.1324596,-2.3275863,0.1364781,0.0693053,-2.2427721
-1615570338,52.1324677,-2.3275756,0.1308619,0.0650414,-2.1651154,52.1324596,-2.3275863,0.1365082,0.0693201,-2.2427678
-1615570339,52.1324676,-2.3275756,0.1375340,0.0679691,-2.0283644,52.1324596,-2.3275862,0.1365220,0.0693321,-2.2428329
-1615570339,52.1324676,-2.3275756,0.1331068,0.0684571,-2.2979805,52.1324597,-2.3275862,0.1365308,0.0693465,-2.2429600
-1615570339,52.1324675,-2.3275755,0.1345486,0.0645536,-1.8210869,52.1324597,-2.3275862,0.1365351,0.0693348,-2.2427835
-1615570340,52.1324675,-2.3275755,0.1308897,0.0682131,-2.5382457,52.1324597,-2.3275862,0.1365733,0.0693348,-2.2425377
-1615570340,52.1324675,-2.3275755,0.1303911,0.0674811,-2.1228197,52.1324597,-2.3275862,0.1365496,0.0693132,-2.2424130
-1615570340,52.1324675,-2.3275755,0.1330554,0.0626022,-2.2888234,52.1324597,-2.3275861,0.1365759,0.0693175,-2.2422981
-1615570341,52.1324675,-2.3275755,0.1345507,0.0647975,-1.7124883,52.1324597,-2.3275861,0.1366063,0.0693325,-2.2422945
-1615570341,52.1324675,-2.3275754,0.1308682,0.0657733,-2.0179863,52.1324597,-2.3275861,0.1366194,0.0693195,-2.2420442
-1615570342,52.1324676,-2.3275754,0.1320920,0.0650414,-1.9183528,52.1324597,-2.3275861,0.1365676,0.0692587,-2.2416003
-1615570342,52.1324675,-2.3275753,0.1323707,0.0687011,-1.9061329,52.1324598,-2.3275861,0.1365429,0.0693234,-2.2425866
-1615570342,52.1324675,-2.3275753,0.1326123,0.0682131,-2.3140512,52.1324598,-2.3275861,0.1365935,0.0693269,-2.2423062
-1615570343,52.1324675,-2.3275752,0.1335836,0.0667492,-2.0958834,52.1324598,-2.3275860,0.1365787,0.0692844,-2.2418573
-1615570343,52.1324675,-2.3275752,0.1326123,0.0682131,-2.0322247,52.1324598,-2.3275860,0.1365577,0.0692499,-2.2415509
-1615570343,52.1324674,-2.3275752,0.1308640,0.0652854,-2.6011572,52.1324598,-2.3275860,0.1365447,0.0692834,-2.2420630
-1615570344,52.1324674,-2.3275752,0.1328835,0.0708973,-2.6404953,52.1324598,-2.3275860,0.1364760,0.0692465,-2.2420344
-1615570344,52.1324673,-2.3275753,0.1321048,0.0665052,-2.6147130,52.1324598,-2.3275860,0.1364747,0.0692680,-2.2423182
-1615570345,52.1324673,-2.3275754,0.1293697,0.0630900,-2.5230708,52.1324598,-2.3275860,0.1364528,0.0693109,-2.2430091
-1615570345,52.1324672,-2.3275755,0.1333245,0.0652854,-2.6156542,52.1324599,-2.3275859,0.1364797,0.0693347,-2.2431407
-1615570345,52.1324671,-2.3275755,0.1321313,0.0694331,-2.1037726,52.1324599,-2.3275859,0.1365186,0.0693444,-2.2430143
-1615570346,52.1324670,-2.3275756,0.1345726,0.0672371,-2.3611586,52.1324599,-2.3275859,0.1364761,0.0693894,-2.2438633
-1615570346,52.1324669,-2.3275755,0.1286669,0.0672371,-2.4810526,52.1324599,-2.3275859,0.1364617,0.0693914,-2.2439821
-1615570346,52.1324669,-2.3275757,0.1301408,0.0669931,-2.4766908,52.1324599,-2.3275859,0.1364510,0.0693593,-2.2436402
-1615570347,52.1324668,-2.3275757,0.1311491,0.0696771,-2.0371709,52.1324599,-2.3275859,0.1364278,0.0693608,-2.2438090
-1615570347,52.1324668,-2.3275757,0.1301472,0.0677251,-2.4894361,52.1324599,-2.3275858,0.1364008,0.0693318,-2.2436109
-1615570348,52.1324667,-2.3275757,0.1340671,0.0657733,-2.3303399,52.1324599,-2.3275858,0.1364338,0.0693417,-2.2435255
-1615570348,52.1324666,-2.3275759,0.1331159,0.0694331,-2.3800442,52.1324599,-2.3275858,0.1363695,0.0693373,-2.2438834
-1615570348,52.1324664,-2.3275759,0.1299012,0.0677251,-1.9390200,52.1324600,-2.3275858,0.1363998,0.0693110,-2.2433505
-1615570349,52.1324664,-2.3275760,0.1316279,0.0682131,-1.9577050,52.1324600,-2.3275858,0.1363302,0.0693091,-2.2437754
-1615570349,52.1324663,-2.3275761,0.1338253,0.0662612,-2.4901252,52.1324600,-2.3275858,0.1363032,0.0692700,-2.2434483
-1615570349,52.1324662,-2.3275761,0.1333309,0.0660173,-2.3597574,52.1324600,-2.3275857,0.1362423,0.0692706,-2.2438486
-1615570350,52.1324660,-2.3275763,0.1313602,0.0657733,-1.9859364,52.1324600,-2.3275857,0.1362350,0.0692530,-2.2436700
-1615570350,52.1324659,-2.3275763,0.1360127,0.0630900,-2.1371479,52.1324600,-2.3275857,0.1362834,0.0692654,-2.2435167
-1615570351,52.1324658,-2.3275764,0.1325841,0.0650414,-2.0412004,52.1324600,-2.3275857,0.1362512,0.0692186,-2.2431238
-1615570351,52.1324657,-2.3275764,0.1323574,0.0672371,-2.4322820,52.1324600,-2.3275857,0.1362690,0.0691805,-2.2425182
-1615570351,52.1324656,-2.3275765,0.1313539,0.0650414,-3.0974119,52.1324600,-2.3275857,0.1363706,0.0692741,-2.2430642
-1615570352,52.1324655,-2.3275765,0.1340458,0.0633339,-2.5477800,52.1324600,-2.3275857,0.1363269,0.0691978,-2.2423670
-1615570352,52.1324653,-2.3275766,0.1328453,0.0667492,-2.5209467,52.1324600,-2.3275856,0.1363954,0.0691842,-2.2417493
-1615570352,52.1324652,-2.3275767,0.1355332,0.0645536,-1.9639038,52.1324601,-2.3275856,0.1364047,0.0691715,-2.2415264
-1615570353,52.1324651,-2.3275768,0.1345861,0.0687011,-1.7754654,52.1324601,-2.3275856,0.1363542,0.0691615,-2.2417250
-1615570353,52.1324650,-2.3275768,0.1333530,0.0684571,-2.3198874,52.1324601,-2.3275856,0.1363169,0.0691152,-2.2413712
-1615570354,52.1324649,-2.3275769,0.1323797,0.0696771,-2.2179098,52.1324601,-2.3275856,0.1362615,0.0691059,-2.2416098
-1615570354,52.1324648,-2.3275770,0.1325799,0.0645536,-2.2476561,52.1324601,-2.3275856,0.1363032,0.0690925,-2.2411671
-1615570354,52.1324647,-2.3275771,0.1303998,0.0684571,-2.2709434,52.1324601,-2.3275856,0.1363502,0.0690947,-2.2408917
-1615570355,52.1324646,-2.3275772,0.1315937,0.0643096,-1.7357007,52.1324601,-2.3275855,0.1363610,0.0690377,-2.2400901
-1615570355,52.1324644,-2.3275773,0.1345465,0.0643096,-2.0635545,52.1324601,-2.3275855,0.1363824,0.0690225,-2.2397556
-1615570355,52.1324644,-2.3275774,0.1318523,0.0657733,-2.4779720,52.1324601,-2.3275855,0.1363818,0.0690332,-2.2398982
-1615570356,52.1324642,-2.3275774,0.1338232,0.0660173,-2.1868949,52.1324601,-2.3275855,0.1363280,0.0690246,-2.2401350
-1615570356,52.1324641,-2.3275775,0.1357793,0.0645536,-2.0096836,52.1324601,-2.3275855,0.1363402,0.0691184,-2.2412612
-1615570357,52.1324640,-2.3275775,0.1345704,0.0669931,-2.5183001,52.1324601,-2.3275855,0.1363375,0.0691081,-2.2411458
-1615570357,52.1324639,-2.3275776,0.1333224,0.0650414,-2.9351447,52.1324601,-2.3275855,0.1363578,0.0691187,-2.2411518
-1615570357,52.1324638,-2.3275778,0.1338659,0.0706532,-2.3423088,52.1324601,-2.3275855,0.1362872,0.0691418,-2.2419050
-1615570358,52.1324637,-2.3275778,0.1340915,0.0684571,-2.3538857,52.1324601,-2.3275854,0.1362860,0.0691750,-2.2423384
-1615570358,52.1324636,-2.3275778,0.1345594,0.0657733,-1.7668958,52.1324602,-2.3275854,0.1362827,0.0691972,-2.2426445
-1615570358,52.1324634,-2.3275779,0.1367839,0.0667492,-1.7109326,52.1324602,-2.3275854,0.1362483,0.0691448,-2.2421937
-1615570359,52.1324633,-2.3275780,0.1291278,0.0635778,-2.8262377,52.1324602,-2.3275854,0.1362381,0.0691569,-2.2424150
-1615570359,52.1324632,-2.3275781,0.1318875,0.0696771,-1.8935549,52.1324602,-2.3275854,0.1362275,0.0691708,-2.2426629
-1615570360,52.1324630,-2.3275783,0.1286440,0.0645536,-2.8976543,52.1324602,-2.3275854,0.1362430,0.0691738,-2.2426012
-1615570360,52.1324629,-2.3275784,0.1318740,0.0682131,-2.9970758,52.1324602,-2.3275854,0.1362882,0.0691792,-2.2423780
-1615570360,52.1324629,-2.3275784,0.1323707,0.0687011,-2.1466143,52.1324602,-2.3275854,0.1362956,0.0691860,-2.2424183
-1615570361,52.1324628,-2.3275786,0.1313841,0.0684571,-2.0935385,52.1324602,-2.3275854,0.1363402,0.0691850,-2.2421167
-1615570361,52.1324627,-2.3275786,0.1313518,0.0647975,-2.2516460,52.1324602,-2.3275854,0.1362986,0.0691798,-2.2423182
-1615570361,52.1324625,-2.3275787,0.1279462,0.0691891,-2.9711332,52.1324602,-2.3275853,0.1363037,0.0691363,-2.2417264
-1615570362,52.1324625,-2.3275787,0.1293964,0.0662612,-2.1516714,52.1324602,-2.3275853,0.1362474,0.0691831,-2.2426925
-1615570362,52.1324623,-2.3275788,0.1306328,0.0669931,-2.5491140,52.1324602,-2.3275853,0.1361628,0.0691301,-2.2425573
-1615570363,52.1324622,-2.3275789,0.1367728,0.0655293,-1.8556105,52.1324602,-2.3275853,0.1361684,0.0690550,-2.2415538
-1615570363,52.1324621,-2.3275790,0.1338363,0.0674811,-2.1308289,52.1324602,-2.3275853,0.1361199,0.0690792,-2.2421801
-1615570363,52.1324619,-2.3275790,0.1330678,0.0640657,-2.2009227,52.1324602,-2.3275853,0.1361222,0.0690888,-2.2422895
-1615570364,52.1324617,-2.3275791,0.1345681,0.0667492,-2.2490530,52.1324602,-2.3275853,0.1360563,0.0690850,-2.2426679
-1615570364,52.1324617,-2.3275791,0.1321027,0.0662612,-1.9010357,52.1324602,-2.3275853,0.1360862,0.0690588,-2.2421355
-1615570364,52.1324615,-2.3275791,0.1338019,0.0635778,-2.1937969,52.1324602,-2.3275853,0.1360704,0.0689943,-2.2414064
-1615570365,52.1324613,-2.3275791,0.1375159,0.0660173,-2.8507013,52.1324602,-2.3275853,0.1360688,0.0690009,-2.2415020
-1615570365,52.1324612,-2.3275792,0.1296403,0.0660173,-2.3990877,52.1324602,-2.3275852,0.1360927,0.0690107,-2.2414730
-1615570366,52.1324610,-2.3275792,0.1328720,0.0696771,-2.6605737,52.1324602,-2.3275852,0.1360874,0.0690332,-2.2417972
-1615570366,52.1324609,-2.3275793,0.1306569,0.0696771,-2.4243860,52.1324602,-2.3275852,0.1360773,0.0690141,-2.2416162
-1615570366,52.1324608,-2.3275794,0.1333597,0.0691891,-2.7115121,52.1324602,-2.3275852,0.1360593,0.0689991,-2.2415397
-1615570367,52.1324606,-2.3275795,0.1343331,0.0679691,-2.4501910,52.1324602,-2.3275852,0.1360924,0.0689501,-2.2406926
-1615570367,52.1324605,-2.3275796,0.1316481,0.0704092,-2.3514161,52.1324602,-2.3275852,0.1360375,0.0689477,-2.2410183
-1615570367,52.1324604,-2.3275796,0.1323574,0.0672371,-2.1276917,52.1324602,-2.3275852,0.1360308,0.0689867,-2.2415655
-1615570368,52.1324602,-2.3275797,0.1347926,0.0643096,-2.3924212,52.1324602,-2.3275852,0.1361032,0.0689872,-2.2411017
-1615570368,52.1324602,-2.3275797,0.1320962,0.0655293,-2.7317104,52.1324602,-2.3275852,0.1361189,0.0689713,-2.2407951
-1615570369,52.1324601,-2.3275798,0.1338210,0.0657733,-2.6152835,52.1324602,-2.3275852,0.1361108,0.0689120,-2.2400835
-1615570369,52.1324600,-2.3275798,0.1323596,0.0674811,-2.4022288,52.1324602,-2.3275852,0.1360965,0.0689002,-2.2400246
-1615570369,52.1324599,-2.3275798,0.1331136,0.0691891,-2.7502046,52.1324602,-2.3275852,0.1359904,0.0688981,-2.2406857
-1615570370,52.1324598,-2.3275799,0.1340607,0.0650414,-2.3028157,52.1324602,-2.3275851,0.1359842,0.0689251,-2.2410738
-1615570370,52.1324598,-2.3275800,0.1323402,0.0652854,-2.3481240,52.1324602,-2.3275851,0.1358688,0.0688668,-2.2410703
-1615570370,52.1324597,-2.3275800,0.1313476,0.0643096,-2.4136736,52.1324602,-2.3275851,0.1358820,0.0688012,-2.2401350
-1615570371,52.1324597,-2.3275801,0.1296530,0.0674811,-2.3383844,52.1324602,-2.3275851,0.1359229,0.0687947,-2.2397852
-1615570371,52.1324596,-2.3275801,0.1362588,0.0630900,-2.3244216,52.1324602,-2.3275851,0.1358949,0.0688004,-2.2400417
-1615570372,52.1324596,-2.3275801,0.1324194,0.0738261,-2.3345714,52.1324602,-2.3275851,0.1358372,0.0688170,-2.2406313
-1615570372,52.1324595,-2.3275802,0.1316041,0.0655293,-2.8569267,52.1324602,-2.3275851,0.1358810,0.0688199,-2.2403841
-1615570372,52.1324595,-2.3275802,0.1355462,0.0660173,-2.3006623,52.1324602,-2.3275851,0.1359701,0.0688274,-2.2399013
-1615570373,52.1324594,-2.3275803,0.1328409,0.0662612,-2.3470140,52.1324602,-2.3275851,0.1360183,0.0688749,-2.2402015
-1615570373,52.1324594,-2.3275803,0.1389585,0.0621144,-1.7324423,52.1324602,-2.3275851,0.1359976,0.0688265,-2.2397113
-1615570373,52.1324593,-2.3275804,0.1355528,0.0667492,-2.6866074,52.1324602,-2.3275851,0.1360698,0.0688333,-2.2393308
-1615570374,52.1324592,-2.3275804,0.1338521,0.0691891,-1.8146435,52.1324602,-2.3275851,0.1360844,0.0688234,-2.2391071
-1615570374,52.1324592,-2.3275805,0.1318830,0.0691891,-2.6579671,52.1324602,-2.3275851,0.1360879,0.0688080,-2.2388864
-1615570375,52.1324591,-2.3275806,0.1341005,0.0694331,-2.2009563,52.1324602,-2.3275851,0.1361006,0.0688281,-2.2390633
-1615570375,52.1324591,-2.3275805,0.1333331,0.0662612,-2.2528372,52.1324602,-2.3275851,0.1361261,0.0688672,-2.2394011
-1615570375,52.1324591,-2.3275806,0.1318523,0.0657733,-2.3936851,52.1324602,-2.3275850,0.1360892,0.0689295,-2.2404442
-1615570376,52.1324590,-2.3275807,0.1257158,0.0672371,-2.5528100,52.1324602,-2.3275850,0.1361494,0.0688952,-2.2396111
-1615570376,52.1324589,-2.3275807,0.1362982,0.0674811,-2.1093411,52.1324602,-2.3275850,0.1361869,0.0688720,-2.2390685
-1615570376,52.1324589,-2.3275808,0.1340937,0.0687011,-1.9954798,52.1324602,-2.3275850,0.1361816,0.0689153,-2.2396607
-1615570377,52.1324588,-2.3275808,0.1367469,0.0626022,-2.2340071,52.1324602,-2.3275850,0.1362021,0.0688582,-2.2387929
-1615570377,52.1324587,-2.3275809,0.1308986,0.0691891,-2.4572215,52.1324602,-2.3275850,0.1361839,0.0688386,-2.2386580
-1615570378,52.1324586,-2.3275809,0.1284338,0.0687011,-2.3083661,52.1324602,-2.3275850,0.1361610,0.0688064,-2.2383924
-1615570378,52.1324585,-2.3275810,0.1348277,0.0682131,-2.2690704,52.1324602,-2.3275850,0.1361657,0.0688288,-2.2386503
-1615570378,52.1324584,-2.3275810,0.1340892,0.0682131,-1.8667881,52.1324602,-2.3275850,0.1362316,0.0688137,-2.2380280
-1615570379,52.1324583,-2.3275810,0.1323317,0.0643096,-2.2217901,52.1324602,-2.3275850,0.1362884,0.0687624,-2.2369990
-1615570379,52.1324582,-2.3275811,0.1353022,0.0662612,-2.3071194,52.1324602,-2.3275850,0.1362296,0.0686999,-2.2365756
-1615570379,52.1324581,-2.3275811,0.1355418,0.0655293,-2.0588036,52.1324602,-2.3275850,0.1362122,0.0686762,-2.2363830
-1615570380,52.1324581,-2.3275811,0.1326013,0.0669931,-2.4417562,52.1324602,-2.3275850,0.1362458,0.0686717,-2.2361064
-1615570380,52.1324579,-2.3275812,0.1340960,0.0689451,-1.9598488,52.1324602,-2.3275850,0.1362192,0.0686876,-2.2364836
-1615570381,52.1324578,-2.3275812,0.1277046,0.0696771,2.9840274,52.1324602,-2.3275850,0.1362548,0.0686747,-2.2360852
-1615570381,52.1324577,-2.3275813,0.1279228,0.0665052,-2.2383056,52.1324602,-2.3275850,0.1362972,0.0686101,-2.2349772
-1615570381,52.1324576,-2.3275814,0.1313998,0.0701652,-2.3742962,52.1324602,-2.3275850,0.1363402,0.0685637,-2.2341006
-1615570382,52.1324575,-2.3275814,0.1331091,0.0687011,-1.6395470,52.1324602,-2.3275850,0.1363886,0.0686063,-2.2343357
-1615570382,52.1324575,-2.3275815,0.1311058,0.0647975,-2.6219020,52.1324602,-2.3275849,0.1363993,0.0686020,-2.2342100
-1615570382,52.1324575,-2.3275816,0.1352785,0.0635778,-2.5969284,52.1324602,-2.3275849,0.1364717,0.0686155,-2.2339153
-1615570383,52.1324574,-2.3275816,0.1308919,0.0684571,-2.3201339,52.1324601,-2.3275849,0.1364666,0.0686133,-2.2339203
-1615570383,52.1324574,-2.3275817,0.1271666,0.0643096,-2.3477762,52.1324601,-2.3275849,0.1365073,0.0686109,-2.2336254
-1615570384,52.1324573,-2.3275818,0.1355375,0.0650414,-1.7101616,52.1324601,-2.3275849,0.1364173,0.0686090,-2.2341833
-1615570384,52.1324573,-2.3275818,0.1345906,0.0691891,-2.4019914,52.1324601,-2.3275849,0.1364552,0.0686986,-2.2350905
-1615570384,52.1324573,-2.3275819,0.1341028,0.0696771,-2.7137170,52.1324601,-2.3275849,0.1364016,0.0686844,-2.2352555
-1615570385,52.1324573,-2.3275819,0.1335537,0.0633339,-2.0123019,52.1324601,-2.3275849,0.1363657,0.0686139,-2.2345810
-1615570385,52.1324572,-2.3275819,0.1336036,0.0689451,-2.3834946,52.1324601,-2.3275849,0.1363756,0.0686024,-2.2343686
-1615570385,52.1324572,-2.3275820,0.1323552,0.0669931,-2.6988750,52.1324601,-2.3275849,0.1363864,0.0685866,-2.2340956
-1615570386,52.1324571,-2.3275821,0.1316041,0.0655293,-2.0798178,52.1324601,-2.3275849,0.1364078,0.0685807,-2.2338803
-1615570386,52.1324572,-2.3275822,0.1360212,0.0640657,-2.2578771,52.1324601,-2.3275849,0.1364287,0.0686225,-2.2342834
-1615570387,52.1324571,-2.3275823,0.1347841,0.0633339,3.0699391,52.1324601,-2.3275849,0.1363792,0.0685982,-2.2342908
-1615570387,52.1324571,-2.3275823,0.1279419,0.0687011,-2.5724108,52.1324601,-2.3275849,0.1363459,0.0685718,-2.2341661
-1615570387,52.1324571,-2.3275824,0.1377803,0.0679691,-2.4047632,52.1324601,-2.3275849,0.1363417,0.0686224,-2.2348452
-1615570388,52.1324571,-2.3275824,0.1350717,0.0679691,-2.1935883,52.1324601,-2.3275849,0.1363247,0.0686373,-2.2351472
-1615570388,52.1324571,-2.3275825,0.1325884,0.0655293,-2.2631228,52.1324601,-2.3275849,0.1363259,0.0686414,-2.2351923
-1615570388,52.1324570,-2.3275825,0.1348210,0.0674811,-2.4544110,52.1324601,-2.3275849,0.1362926,0.0686492,-2.2355092
-1615570389,52.1324570,-2.3275825,0.1335858,0.0669931,-2.2960005,52.1324601,-2.3275849,0.1362547,0.0686419,-2.2356610
-1615570389,52.1324570,-2.3275826,0.1350517,0.0657733,-2.6951132,52.1324601,-2.3275849,0.1363069,0.0686286,-2.2351508
-1615570390,52.1324569,-2.3275826,0.1325799,0.0645536,-2.2222047,52.1324601,-2.3275849,0.1362815,0.0686343,-2.2353883
-1615570390,52.1324569,-2.3275827,0.1370392,0.0677251,-2.0714130,52.1324601,-2.3275849,0.1363142,0.0686499,-2.2353773
-1615570390,52.1324568,-2.3275826,0.1328176,0.0635778,-2.1877217,52.1324601,-2.3275849,0.1363165,0.0686035,-2.2347646
-1615570391,52.1324568,-2.3275827,0.1368161,0.0701652,-1.8772072,52.1324601,-2.3275849,0.1362340,0.0685601,-2.2347407
-1615570391,52.1324568,-2.3275827,0.1341262,0.0721175,-2.4828844,52.1324601,-2.3275849,0.1361230,0.0685618,-2.2354827
-1615570391,52.1324569,-2.3275828,0.1296466,0.0667492,-2.4347801,52.1324601,-2.3275849,0.1360991,0.0685054,-2.2349107
-1615570392,52.1324570,-2.3275830,0.1301177,0.0643096,-2.4069734,52.1324601,-2.3275849,0.1361159,0.0685119,-2.2348850
-1615570392,52.1324572,-2.3275831,0.1313731,0.0672371,-2.6072857,52.1324600,-2.3275848,0.1361025,0.0685583,-2.2355714
-1615570393,52.1324573,-2.3275833,0.1367929,0.0677251,-2.2974710,52.1324600,-2.3275848,0.1361079,0.0685683,-2.2356663
-1615570393,52.1324575,-2.3275834,0.1340564,0.0645536,-1.6492054,52.1324600,-2.3275848,0.1361696,0.0684945,-2.2343113
-1615570393,52.1324576,-2.3275835,0.1338124,0.0647975,-2.3400059,52.1324600,-2.3275848,0.1362210,0.0684761,-2.2337399
-1615570394,52.1324577,-2.3275837,0.1305994,0.0630900,-2.1021266,52.1324600,-2.3275848,0.1361914,0.0685113,-2.2343869
-1615570394,52.1324579,-2.3275839,0.1342961,0.0638218,-2.4129033,52.1324600,-2.3275848,0.1362068,0.0685010,-2.2341540
-1615570394,52.1324581,-2.3275840,0.1347905,0.0640657,-1.8583299,52.1324600,-2.3275848,0.1361804,0.0684412,-2.2335529
-1615570395,52.1324582,-2.3275841,0.1323729,0.0689451,-2.0904377,52.1324600,-2.3275848,0.1362092,0.0684184,-2.2330706
-1615570395,52.1324584,-2.3275843,0.1348055,0.0657733,-2.4051428,52.1324600,-2.3275848,0.1361727,0.0683907,-2.2329507
-1615570396,52.1324586,-2.3275845,0.1347862,0.0635778,-2.3810840,52.1324600,-2.3275848,0.1362082,0.0684570,-2.2335773
-1615570396,52.1324588,-2.3275846,0.1353000,0.0660173,-2.9613385,52.1324600,-2.3275848,0.1361755,0.0684351,-2.2335060
-1615570396,52.1324589,-2.3275848,0.1338341,0.0672371,3.1022437,52.1324600,-2.3275848,0.1361243,0.0684713,-2.2343066
-1615570397,52.1324591,-2.3275849,0.1355663,0.0682131,-2.4244213,52.1324600,-2.3275848,0.1361403,0.0684823,-2.2343452
-1615570397,52.1324592,-2.3275851,0.1296278,0.0645536,-2.4244072,52.1324600,-2.3275848,0.1361779,0.0685162,-2.2345381
-1615570397,52.1324593,-2.3275852,0.1326350,0.0706532,-2.0198374,52.1324600,-2.3275848,0.1361442,0.0684749,-2.2342238
-1615570398,52.1324595,-2.3275853,0.1330657,0.0638218,-2.0032010,52.1324600,-2.3275848,0.1361703,0.0685245,-2.2346950
-1615570398,52.1324596,-2.3275854,0.1301429,0.0672371,-2.4293997,52.1324600,-2.3275848,0.1362358,0.0685309,-2.2343524
-1615570399,52.1324597,-2.3275855,0.1311206,0.0665052,-2.2283180,52.1324600,-2.3275848,0.1361708,0.0684468,-2.2336888
-1615570399,52.1324599,-2.3275856,0.1286564,0.0660173,-2.3317220,52.1324600,-2.3275848,0.1360800,0.0684768,-2.2346668
-1615570399,52.1324600,-2.3275855,0.1326013,0.0669931,-2.2824244,52.1324600,-2.3275848,0.1361062,0.0685265,-2.2351382
-1615570400,52.1324601,-2.3275856,0.1321113,0.0672371,-2.2077353,52.1324600,-2.3275848,0.1360898,0.0685495,-2.2355428
-1615570400,52.1324601,-2.3275857,0.1345704,0.0669931,-1.7587185,52.1324600,-2.3275848,0.1361111,0.0685620,-2.2355661
-1615570400,52.1324602,-2.3275858,0.1294179,0.0687011,-2.5893979,52.1324600,-2.3275848,0.1361714,0.0685811,-2.2354207
-1615570401,52.1324603,-2.3275858,0.1323531,0.0667492,-2.7349763,52.1324600,-2.3275848,0.1361153,0.0685159,-2.2349436
-1615570401,52.1324604,-2.3275859,0.1321268,0.0689451,-2.0768211,52.1324600,-2.3275848,0.1360964,0.0684785,-2.2345824
-1615570402,52.1324605,-2.3275859,0.1308724,0.0662612,-2.3156841,52.1324600,-2.3275848,0.1361046,0.0684657,-2.2343633
-1615570402,52.1324606,-2.3275860,0.1303783,0.0660173,-2.2003865,52.1324600,-2.3275849,0.1361490,0.0685211,-2.2347915
-1615570402,52.1324606,-2.3275861,0.1323381,0.0650414,-2.3758271,52.1324600,-2.3275849,0.1361156,0.0685226,-2.2350276
-1615570403,52.1324607,-2.3275862,0.1335836,0.0667492,-2.3794680,52.1324600,-2.3275849,0.1361465,0.0684583,-2.2339962
-1615570403,52.1324608,-2.3275862,0.1325884,0.0655293,-2.2674794,52.1324600,-2.3275849,0.1361423,0.0684515,-2.2339358
-1615570403,52.1324608,-2.3275862,0.1276644,0.0650414,-1.9445413,52.1324600,-2.3275849,0.1361812,0.0684116,-2.2331662
-1615570404,52.1324609,-2.3275862,0.1298926,0.0667492,-2.4935174,52.1324600,-2.3275849,0.1361372,0.0684586,-2.2340608
-1615570404,52.1324608,-2.3275862,0.1281835,0.0682131,-2.3670752,52.1324600,-2.3275849,0.1361736,0.0684540,-2.2337639
-1615570405,52.1324608,-2.3275862,0.1345815,0.0682131,-2.4239447,52.1324600,-2.3275849,0.1361625,0.0684890,-2.2342880
-1615570405,52.1324607,-2.3275862,0.1347883,0.0638218,-2.7754126,52.1324600,-2.3275849,0.1361534,0.0685512,-2.2351503
-1615570405,52.1324608,-2.3275860,0.1350409,0.0645536,-1.9545654,52.1324600,-2.3275849,0.1361516,0.0686056,-2.2358656
-1615570406,52.1324607,-2.3275861,0.1311559,0.0704092,-2.1323237,52.1324600,-2.3275849,0.1360652,0.0686185,-2.2365940
-1615570406,52.1324607,-2.3275860,0.1308703,0.0660173,-2.6259010,52.1324600,-2.3275849,0.1361429,0.0686280,-2.2362115
-1615570406,52.1324607,-2.3275860,0.1318763,0.0684571,-2.2138846,52.1324600,-2.3275849,0.1361233,0.0685678,-2.2355611
-1615570407,52.1324607,-2.3275858,0.1333397,0.0669931,-2.7558677,52.1324600,-2.3275849,0.1360919,0.0685700,-2.2357931
-1615570407,52.1324608,-2.3275858,0.1338408,0.0679691,-1.7420198,52.1324600,-2.3275849,0.1361255,0.0686155,-2.2361634
-1615570408,52.1324608,-2.3275858,0.1316257,0.0679691,-2.2250025,52.1324600,-2.3275849,0.1361676,0.0686490,-2.2363219
-1615570408,52.1324609,-2.3275858,0.1335475,0.0626022,-2.2730923,52.1324600,-2.3275849,0.1361471,0.0686273,-2.2361746
-1615570408,52.1324610,-2.3275858,0.1331091,0.0687011,3.0883436,52.1324600,-2.3275849,0.1360957,0.0686432,-2.2367139
-1615570409,52.1324610,-2.3275857,0.1308703,0.0660173,-2.3744657,52.1324600,-2.3275849,0.1361463,0.0687013,-2.2371361
-1615570409,52.1324611,-2.3275858,0.1347905,0.0640657,-2.0279298,52.1324600,-2.3275849,0.1360824,0.0686496,-2.2368832
-1615570409,52.1324612,-2.3275857,0.1333441,0.0674811,-1.6602544,52.1324600,-2.3275849,0.1360288,0.0686747,-2.2375560
-1615570410,52.1324612,-2.3275857,0.1367884,0.0672371,-1.9310278,52.1324600,-2.3275849,0.1360414,0.0686921,-2.2376995
-1615570410,52.1324613,-2.3275857,0.1333397,0.0669931,-2.1088128,52.1324600,-2.3275849,0.1361338,0.0687032,-2.2372417
-1615570411,52.1324614,-2.3275857,0.1355824,0.0699211,-2.1838555,52.1324600,-2.3275849,0.1361432,0.0686974,-2.2371058
-1615570411,52.1324615,-2.3275857,0.1311228,0.0667492,-1.7669272,52.1324600,-2.3275849,0.1361374,0.0686722,-2.2368197
-1615570411,52.1324615,-2.3275857,0.1329022,0.0728498,-2.3134530,52.1324600,-2.3275849,0.1361518,0.0687051,-2.2371507
-1615570412,52.1324616,-2.3275857,0.1390403,0.0708973,-2.3243966,52.1324600,-2.3275849,0.1361624,0.0686573,-2.2364640
-1615570412,52.1324617,-2.3275857,0.1293860,0.0650414,-2.6060684,52.1324600,-2.3275849,0.1362042,0.0686335,-2.2358873
-1615570412,52.1324617,-2.3275857,0.1313731,0.0672371,-2.2064004,52.1324600,-2.3275849,0.1361656,0.0685665,-2.2352736
-1615570413,52.1324617,-2.3275857,0.1325414,0.0599194,-2.0700970,52.1324601,-2.3275849,0.1361659,0.0685632,-2.2352288
-1615570413,52.1324618,-2.3275857,0.1338341,0.0672371,-2.5361719,52.1324601,-2.3275849,0.1361975,0.0685715,-2.2351308
-1615570414,52.1324619,-2.3275857,0.1316302,0.0684571,-1.9613743,52.1324601,-2.3275849,0.1362400,0.0685579,-2.2346792
-1615570414,52.1324619,-2.3275858,0.1291675,0.0682131,-3.0803576,52.1324601,-2.3275849,0.1361609,0.0685164,-2.2346570
-1615570414,52.1324620,-2.3275858,0.1328073,0.0623583,-2.9101863,52.1324601,-2.3275849,0.1361862,0.0685279,-2.2346416
-1615570415,52.1324620,-2.3275859,0.1328366,0.0657733,-2.4619384,52.1324601,-2.3275849,0.1362239,0.0685229,-2.2343321
-1615570415,52.1324621,-2.3275860,0.1335924,0.0677251,-2.3716815,52.1324601,-2.3275849,0.1362803,0.0685108,-2.2338107
-1615570415,52.1324621,-2.3275860,0.1304109,0.0696771,-2.8323138,52.1324601,-2.3275849,0.1363307,0.0684869,-2.2331762
-1615570416,52.1324622,-2.3275861,0.1340585,0.0647975,-3.0093904,52.1324601,-2.3275849,0.1363587,0.0684741,-2.2328291
-1615570416,52.1324622,-2.3275861,0.1340585,0.0647975,-2.5489359,52.1324601,-2.3275849,0.1363117,0.0684521,-2.2328506
-1615570417,52.1324623,-2.3275861,0.1296639,0.0687011,-2.6305990,52.1324601,-2.3275849,0.1362418,0.0684157,-2.2328353
-1615570417,52.1324623,-2.3275862,0.1296445,0.0665052,-2.4434578,52.1324601,-2.3275849,0.1361860,0.0684317,-2.2334030
-1615570417,52.1324622,-2.3275862,0.1347990,0.0650414,3.1334164,52.1324601,-2.3275849,0.1361427,0.0684436,-2.2338381
-1615570418,52.1324623,-2.3275862,0.1345616,0.0660173,-2.0629029,52.1324601,-2.3275849,0.1361830,0.0684672,-2.2338820
-1615570418,52.1324624,-2.3275863,0.1331204,0.0699211,-2.0481644,52.1324601,-2.3275849,0.1361790,0.0684196,-2.2332926
-1615570418,52.1324625,-2.3275864,0.1343490,0.0696771,-2.3741479,52.1324601,-2.3275849,0.1361228,0.0683619,-2.2329123
-1615570419,52.1324625,-2.3275865,0.1313797,0.0679691,-1.7643505,52.1324601,-2.3275849,0.1361333,0.0684279,-2.2336977
-1615570419,52.1324625,-2.3275866,0.1333202,0.0647975,-2.2240708,52.1324601,-2.3275849,0.1361352,0.0684430,-2.2338796
-1615570420,52.1324625,-2.3275865,0.1343154,0.0660173,-2.6236510,52.1324601,-2.3275849,0.1362509,0.0683787,-2.2322979
-1615570420,52.1324625,-2.3275866,0.1296197,0.0635778,-2.3695338,52.1324601,-2.3275849,0.1362196,0.0683484,-2.2321103
-1615570420,52.1324626,-2.3275866,0.1328540,0.0677251,-2.2435501,52.1324601,-2.3275849,0.1363174,0.0683737,-2.2318022
-1615570421,52.1324626,-2.3275865,0.1328114,0.0628461,-1.8560872,52.1324601,-2.3275849,0.1364019,0.0684337,-2.2320273
-1615570421,52.1324626,-2.3275865,0.1291421,0.0652854,-2.3285379,52.1324601,-2.3275849,0.1364094,0.0684994,-2.2328253
-1615570421,52.1324626,-2.3275864,0.1313731,0.0672371,-2.3018451,52.1324601,-2.3275849,0.1364796,0.0684934,-2.2322936
-1615570422,52.1324627,-2.3275865,0.1353000,0.0660173,-1.9786221,52.1324601,-2.3275849,0.1365204,0.0685278,-2.2324717
-1615570422,52.1324627,-2.3275865,0.1321005,0.0660173,-2.1089597,52.1324601,-2.3275849,0.1364740,0.0684464,-2.2317252
-1615570423,52.1324628,-2.3275866,0.1348255,0.0679691,-2.0904222,52.1324601,-2.3275849,0.1364468,0.0685104,-2.2327251
-1615570423,52.1324628,-2.3275866,0.1323487,0.0662612,-2.4085598,52.1324601,-2.3275849,0.1364654,0.0684632,-2.2319975
-1615570423,52.1324628,-2.3275866,0.1315793,0.0626022,-2.2085567,52.1324601,-2.3275849,0.1364352,0.0684512,-2.2320375
-1615570424,52.1324628,-2.3275867,0.1304109,0.0696771,-2.3648775,52.1324601,-2.3275849,0.1364495,0.0684364,-2.2317553
-1615570424,52.1324628,-2.3275867,0.1331068,0.0684571,-1.8769444,52.1324601,-2.3275849,0.1364456,0.0683852,-2.2311215
-1615570424,52.1324628,-2.3275867,0.1355289,0.0640657,-2.5151043,52.1324601,-2.3275849,0.1363879,0.0683652,-2.2312374
-1615570425,52.1324629,-2.3275867,0.1325884,0.0655293,-1.8512415,52.1324601,-2.3275849,0.1364650,0.0684105,-2.2313209
-1615570425,52.1324629,-2.3275869,0.1352743,0.0630900,-1.7542108,52.1324601,-2.3275849,0.1364859,0.0683924,-2.2309542
-1615570426,52.1324628,-2.3275869,0.1315916,0.0640657,-1.6689184,52.1324601,-2.3275849,0.1363854,0.0683887,-2.2315567
-1615570426,52.1324629,-2.3275870,0.1355332,0.0645536,-1.8708088,52.1324602,-2.3275850,0.1363760,0.0683096,-2.2305977
-1615570426,52.1324628,-2.3275872,0.1326258,0.0696771,-1.8435656,52.1324602,-2.3275850,0.1364295,0.0682777,-2.2298393
-1615570427,52.1324628,-2.3275872,0.1296705,0.0694331,-2.7835121,52.1324602,-2.3275850,0.1364476,0.0681671,-2.2282958
-1615570427,52.1324628,-2.3275873,0.1355755,0.0691891,-2.5860572,52.1324602,-2.3275850,0.1364553,0.0681951,-2.2286077
-1615570427,52.1324628,-2.3275875,0.1328176,0.0635778,-2.2874157,52.1324602,-2.3275850,0.1364924,0.0682631,-2.2292438
-1615570428,52.1324627,-2.3275875,0.1325862,0.0652854,-2.1400571,52.1324602,-2.3275850,0.1365601,0.0682350,-2.2284431
-1615570428,52.1324627,-2.3275876,0.1318852,0.0694331,-1.9155363,52.1324602,-2.3275850,0.1365235,0.0681555,-2.2276566
-1615570429,52.1324626,-2.3275877,0.1303678,0.0647975,-2.1786258,52.1324602,-2.3275850,0.1365289,0.0681409,-2.2274337
-1615570429,52.1324626,-2.3275878,0.1360364,0.0657733,-2.0288725,52.1324602,-2.3275850,0.1364583,0.0681200,-2.2276216
-1615570429,52.1324626,-2.3275878,0.1331113,0.0689451,-3.0243468,52.1324602,-2.3275850,0.1364921,0.0681243,-2.2274575
-1615570430,52.1324625,-2.3275878,0.1323865,0.0704092,-2.2663689,52.1324602,-2.3275850,0.1364642,0.0680179,-2.2262664
-1615570430,52.1324625,-2.3275879,0.1357902,0.0657733,-1.9290656,52.1324602,-2.3275850,0.1364164,0.0680011,-2.2263596
-1615570430,52.1324625,-2.3275879,0.1318397,0.0643096,-2.1538577,52.1324602,-2.3275850,0.1363604,0.0679687,-2.2263052
-1615570431,52.1324624,-2.3275879,0.1338253,0.0662612,-2.1757026,52.1324602,-2.3275850,0.1364391,0.0680286,-2.2265680
-1615570431,52.1324624,-2.3275880,0.1338475,0.0687011,-2.2115982,52.1324602,-2.3275850,0.1363985,0.0680192,-2.2267096
-1615570432,52.1324624,-2.3275880,0.1281793,0.0677251,-2.7058954,52.1324602,-2.3275850,0.1364183,0.0680753,-2.2273057
-1615570432,52.1324623,-2.3275879,0.1336174,0.0704092,-1.9911058,52.1324602,-2.3275850,0.1364073,0.0680266,-2.2267485
-1615570432,52.1324623,-2.3275880,0.1355462,0.0660173,-2.3819175,52.1324602,-2.3275850,0.1363721,0.0679656,-2.2261896
-1615570433,52.1324622,-2.3275880,0.1325884,0.0655293,-2.7525797,52.1324602,-2.3275850,0.1363643,0.0679978,-2.2266564
-1615570433,52.1324622,-2.3275879,0.1352913,0.0650414,-2.7253206,52.1324602,-2.3275850,0.1363968,0.0679832,-2.2262554
-1615570433,52.1324621,-2.3275880,0.1338232,0.0660173,-2.5259721,52.1324602,-2.3275850,0.1363898,0.0679437,-2.2257910
-1615570434,52.1324621,-2.3275881,0.1335642,0.0645536,-2.4008141,52.1324602,-2.3275850,0.1363673,0.0678915,-2.2252624
-1615570434,52.1324620,-2.3275880,0.1328366,0.0657733,-2.6210966,52.1324602,-2.3275850,0.1363049,0.0678571,-2.2252240
-1615570435,52.1324620,-2.3275880,0.1311249,0.0669931,-2.6133523,52.1324602,-2.3275850,0.1363057,0.0679189,-2.2260187
-1615570435,52.1324620,-2.3275880,0.1338297,0.0667492,-1.5847788,52.1324602,-2.3275850,0.1362547,0.0679547,-2.2268131
-1615570435,52.1324619,-2.3275880,0.1313581,0.0655293,-2.4436495,52.1324602,-2.3275850,0.1363615,0.0679751,-2.2263825
-1615570436,52.1324619,-2.3275880,0.1296617,0.0684571,-2.1131244,52.1324602,-2.3275850,0.1363227,0.0680226,-2.2272496
-1615570436,52.1324618,-2.3275880,0.1347820,0.0630900,-2.0552115,52.1324602,-2.3275850,0.1363482,0.0680003,-2.2267950
-1615570436,52.1324618,-2.3275880,0.1286585,0.0662612,-1.8915085,52.1324602,-2.3275850,0.1363762,0.0680754,-2.2275832
-1615570437,52.1324617,-2.3275880,0.1328607,0.0684571,-2.3978341,52.1324602,-2.3275850,0.1363664,0.0680749,-2.2276409
-1615570437,52.1324617,-2.3275882,0.1328155,0.0633339,-2.1848347,52.1324602,-2.3275850,0.1364165,0.0680785,-2.2273617
-1615570438,52.1324617,-2.3275881,0.1328518,0.0674811,-2.2950606,52.1324602,-2.3275851,0.1364047,0.0680314,-2.2268298
-1615570438,52.1324615,-2.3275882,0.1326035,0.0672371,-2.0509214,52.1324602,-2.3275851,0.1363757,0.0679522,-2.2259963
-1615570438,52.1324615,-2.3275882,0.1309121,0.0706532,-2.2319708,52.1324602,-2.3275851,0.1362957,0.0678827,-2.2256169
-1615570439,52.1324614,-2.3275883,0.1306180,0.0652854,-2.2726040,52.1324602,-2.3275851,0.1362522,0.0678129,-2.2249961
-1615570439,52.1324613,-2.3275883,0.1301156,0.0640657,-2.2700813,52.1324602,-2.3275851,0.1363236,0.0678609,-2.2251525
-1615570439,52.1324612,-2.3275884,0.1286105,0.0604072,-2.3031225,52.1324602,-2.3275851,0.1363664,0.0679681,-2.2262607
-1615570440,52.1324612,-2.3275884,0.1340892,0.0682131,-2.2725759,52.1324602,-2.3275851,0.1363735,0.0680571,-2.2273648
-1615570440,52.1324611,-2.3275884,0.1323423,0.0655293,-2.0585735,52.1324602,-2.3275851,0.1363233,0.0680855,-2.2280593
-1615570441,52.1324610,-2.3275884,0.1340521,0.0640657,-1.7626523,52.1324602,-2.3275851,0.1362803,0.0681490,-2.2291594
-1615570441,52.1324610,-2.3275883,0.1323234,0.0633339,-2.3124039,52.1324602,-2.3275851,0.1361980,0.0680999,-2.2290592
-1615570441,52.1324609,-2.3275884,0.1301538,0.0684571,-2.8537283,52.1324602,-2.3275851,0.1361935,0.0681444,-2.2296648
-1615570442,52.1324608,-2.3275884,0.1316020,0.0652854,-2.1005280,52.1324602,-2.3275851,0.1361459,0.0681600,-2.2301769
-1615570442,52.1324607,-2.3275884,0.1323214,0.0630900,-2.3013554,52.1324602,-2.3275851,0.1361820,0.0681892,-2.2303202
-1615570442,52.1324607,-2.3275884,0.1389801,0.0645536,-2.0581541,52.1324602,-2.3275851,0.1361093,0.0680147,-2.2285323
-1615570443,52.1324605,-2.3275884,0.1335706,0.0652854,-2.4944370,52.1324602,-2.3275851,0.1361024,0.0679739,-2.2280498
-1615570443,52.1324605,-2.3275884,0.1335642,0.0645536,-2.6133595,52.1324602,-2.3275851,0.1360643,0.0680307,-2.2290354
-1615570444,52.1324605,-2.3275883,0.1325927,0.0660173,-2.0667739,52.1324602,-2.3275851,0.1360471,0.0680774,-2.2297540
-1615570444,52.1324604,-2.3275883,0.1365288,0.0657733,-2.2862098,52.1324602,-2.3275851,0.1360444,0.0681009,-2.2300758
-1615570444,52.1324603,-2.3275883,0.1338430,0.0682131,-2.1820855,52.1324602,-2.3275851,0.1360236,0.0681217,-2.2304811
-1615570445,52.1324602,-2.3275883,0.1283920,0.0638218,-2.2920008,52.1324602,-2.3275851,0.1359540,0.0681089,-2.2307701
-1615570445,52.1324601,-2.3275882,0.1328238,0.0643096,-2.0113826,52.1324602,-2.3275851,0.1357874,0.0680977,-2.2317133
-1615570445,52.1324600,-2.3275881,0.1336174,0.0704092,-2.2461987,52.1324602,-2.3275851,0.1357435,0.0681525,-2.2327156
-1615570446,52.1324599,-2.3275881,0.1303762,0.0657733,-2.0937438,52.1324602,-2.3275851,0.1357811,0.0682070,-2.2331781
-1615570446,52.1324598,-2.3275881,0.1335579,0.0638218,-2.1306126,52.1324602,-2.3275851,0.1358021,0.0681823,-2.2327192
-1615570447,52.1324597,-2.3275880,0.1348012,0.0652854,-2.0352621,52.1324602,-2.3275851,0.1357270,0.0681512,-2.2328062
-1615570447,52.1324596,-2.3275880,0.1330595,0.0630900,-2.0995438,52.1324602,-2.3275851,0.1356566,0.0680444,-2.2318754
-1615570447,52.1324595,-2.3275880,0.1321246,0.0687011,-2.5845401,52.1324602,-2.3275851,0.1356603,0.0680834,-2.2323604
-1615570448,52.1324594,-2.3275880,0.1311292,0.0674811,-2.3341999,52.1324602,-2.3275851,0.1355982,0.0680645,-2.2325208
-1615570448,52.1324593,-2.3275880,0.1328323,0.0652854,-1.8706625,52.1324602,-2.3275852,0.1356521,0.0681046,-2.2326910
-1615570448,52.1324592,-2.3275880,0.1321048,0.0665052,-2.4330015,52.1324602,-2.3275852,0.1356764,0.0681635,-2.2333002
-1615570449,52.1324591,-2.3275880,0.1362631,0.0635778,-1.8790787,52.1324602,-2.3275852,0.1357576,0.0681675,-2.2328188
-1615570449,52.1324590,-2.3275880,0.1320815,0.0638218,-2.3468075,52.1324602,-2.3275852,0.1358103,0.0681851,-2.2327039
-1615570450,52.1324589,-2.3275880,0.1325927,0.0660173,-2.0865550,52.1324602,-2.3275852,0.1357809,0.0682148,-2.2332819
-1615570450,52.1324588,-2.3275879,0.1335991,0.0684571,-2.2075806,52.1324602,-2.3275852,0.1357457,0.0682287,-2.2336936
-1615570450,52.1324587,-2.3275879,0.1293819,0.0645536,-2.5171340,52.1324602,-2.3275852,0.1358888,0.0682535,-2.2330801
-1615570451,52.1324586,-2.3275878,0.1286712,0.0677251,-1.8546016,52.1324602,-2.3275852,0.1358623,0.0682980,-2.2338328
-1615570451,52.1324584,-2.3275879,0.1308853,0.0677251,-2.3845801,52.1324602,-2.3275852,0.1356759,0.0682757,-2.2347617
-1615570451,52.1324583,-2.3275879,0.1311336,0.0679691,-2.5679588,52.1324602,-2.3275852,0.1355906,0.0681607,-2.2338216
-1615570452,52.1324582,-2.3275878,0.1323531,0.0667492,-2.2851322,52.1324602,-2.3275852,0.1355350,0.0681659,-2.2342539
-1615570452,52.1324582,-2.3275878,0.1316106,0.0662612,-2.2437170,52.1324602,-2.3275852,0.1355304,0.0681582,-2.2341840
-1615570453,52.1324580,-2.3275879,0.1323466,0.0660173,-2.2577016,52.1324602,-2.3275852,0.1356452,0.0681606,-2.2334621
-1615570453,52.1324579,-2.3275879,0.1308853,0.0677251,-2.2543666,52.1324602,-2.3275852,0.1356013,0.0681274,-2.2333157
-1615570453,52.1324578,-2.3275878,0.1338210,0.0657733,-2.5033102,52.1324602,-2.3275852,0.1355264,0.0680766,-2.2331448
-1615570454,52.1324576,-2.3275877,0.1340847,0.0677251,-2.0024767,52.1324602,-2.3275852,0.1355842,0.0680622,-2.2325766
-1615570454,52.1324576,-2.3275878,0.1313313,0.0623583,-2.1979070,52.1324602,-2.3275852,0.1355819,0.0680581,-2.2325382
-1615570454,52.1324575,-2.3275877,0.1338297,0.0667492,-2.3697984,52.1324602,-2.3275852,0.1355332,0.0680179,-2.2323327
-1615570455,52.1324573,-2.3275877,0.1306728,0.0713854,-2.4739087,52.1324602,-2.3275852,0.1354778,0.0680206,-2.2327321
-1615570455,52.1324573,-2.3275876,0.1306014,0.0633339,-2.5528586,52.1324602,-2.3275852,0.1354387,0.0679803,-2.2324624
-1615570456,52.1324571,-2.3275877,0.1298758,0.0647975,-2.1763880,52.1324602,-2.3275852,0.1354862,0.0680417,-2.2329533
-1615570456,52.1324569,-2.3275877,0.1320693,0.0623583,-1.7580448,52.1324602,-2.3275852,0.1355010,0.0681187,-2.2338631
-1615570456,52.1324568,-2.3275877,0.1335880,0.0672371,-1.9465080,52.1324602,-2.3275852,0.1354335,0.0681177,-2.2342937
-1615570457,52.1324567,-2.3275876,0.1325884,0.0655293,-2.8683221,52.1324602,-2.3275852,0.1353948,0.0681167,-2.2345364
-1615570457,52.1324565,-2.3275876,0.1326035,0.0672371,-2.2179096,52.1324602,-2.3275852,0.1354946,0.0682049,-2.2350328
-1615570457,52.1324564,-2.3275876,0.1291784,0.0694331,-2.9532218,52.1324602,-2.3275852,0.1354784,0.0682190,-2.2353244
-1615570458,52.1324563,-2.3275874,0.1355183,0.0628461,-1.4137582,52.1324602,-2.3275852,0.1354943,0.0682059,-2.2350478
-1615570458,52.1324562,-2.3275875,0.1311121,0.0655293,-1.9320821,52.1324602,-2.3275852,0.1355967,0.0682552,-2.2350199
-1615570459,52.1324560,-2.3275875,0.1294135,0.0682131,-1.9496809,52.1324602,-2.3275852,0.1356340,0.0682341,-2.2344995
-1615570459,52.1324559,-2.3275873,0.1308536,0.0640657,-1.9206078,52.1324602,-2.3275852,0.1354947,0.0681863,-2.2347903
-1615570459,52.1324558,-2.3275873,0.1301035,0.0626022,-1.4350337,52.1324602,-2.3275852,0.1354887,0.0682689,-2.2359092
-1615570460,52.1324557,-2.3275872,0.1311037,0.0645536,-2.6218474,52.1324601,-2.3275852,0.1355005,0.0682601,-2.2357168
-1615570460,52.1324555,-2.3275872,0.1304064,0.0691891,-2.2732043,52.1324601,-2.3275852,0.1355042,0.0682147,-2.2350993
-1615570460,52.1324554,-2.3275870,0.1323797,0.0696771,-2.2410378,52.1324601,-2.3275852,0.1355765,0.0683264,-2.2360835
-1615570461,52.1324553,-2.3275870,0.1330935,0.0669931,-2.1876240,52.1324601,-2.3275852,0.1355765,0.0682396,-2.2349505
-1615570461,52.1324552,-2.3275869,0.1303783,0.0660173,-1.9746729,52.1324601,-2.3275852,0.1355869,0.0682076,-2.2344637
-1615570462,52.1324551,-2.3275869,0.1330848,0.0660173,-2.4962287,52.1324601,-2.3275852,0.1356356,0.0681522,-2.2334218
-1615570462,52.1324549,-2.3275868,0.1335946,0.0679691,-2.7942710,52.1324601,-2.3275853,0.1355794,0.0680947,-2.2330394
-1615570462,52.1324548,-2.3275867,0.1308853,0.0677251,-2.0821924,52.1324601,-2.3275853,0.1355325,0.0680257,-2.2324457
-1615570463,52.1324547,-2.3275866,0.1328114,0.0628461,-2.1958156,52.1324601,-2.3275853,0.1356035,0.0680173,-2.2318697
-1615570463,52.1324545,-2.3275865,0.1330892,0.0665052,-2.3613896,52.1324601,-2.3275853,0.1356351,0.0680663,-2.2323027
-1615570463,52.1324544,-2.3275864,0.1301260,0.0652854,-2.3194246,52.1324601,-2.3275853,0.1357473,0.0681506,-2.2326665
-1615570464,52.1324543,-2.3275864,0.1303804,0.0662612,-2.2808895,52.1324601,-2.3275853,0.1358314,0.0681864,-2.2325811
-1615570464,52.1324542,-2.3275862,0.1335600,0.0640657,-2.2042003,52.1324601,-2.3275853,0.1358868,0.0682020,-2.2324226
-1615570465,52.1324541,-2.3275861,0.1283723,0.0613827,0.5645774,52.1324601,-2.3275853,0.1359617,0.0682205,-2.2321732
-1615570465,52.1324539,-2.3275860,0.1333224,0.0650414,-1.9769731,52.1324601,-2.3275853,0.1358830,0.0682575,-2.2331696
-1615570465,52.1324539,-2.3275859,0.1323729,0.0689451,-2.0523272,52.1324601,-2.3275853,0.1358720,0.0682883,-2.2336411
-1615570466,52.1324537,-2.3275858,0.1303783,0.0660173,-2.6875553,52.1324601,-2.3275853,0.1359428,0.0682821,-2.2330990
-1615570466,52.1324536,-2.3275856,0.1350387,0.0643096,-1.9148824,52.1324600,-2.3275853,0.1359212,0.0682866,-2.2332983
-1615570466,52.1324535,-2.3275855,0.1340915,0.0684571,-2.1928811,52.1324600,-2.3275853,0.1359786,0.0683377,-2.2335868
-1615570467,52.1324534,-2.3275854,0.1333441,0.0674811,-2.3967884,52.1324600,-2.3275853,0.1359350,0.0683356,-2.2338452
-1615570467,52.1324532,-2.3275853,0.1328431,0.0665052,-2.2726593,52.1324600,-2.3275853,0.1359713,0.0684068,-2.2345328
-1615570468,52.1324531,-2.3275853,0.1306307,0.0667492,-2.6969166,52.1324600,-2.3275853,0.1359124,0.0684413,-2.2353652
-1615570468,52.1324530,-2.3275851,0.1330827,0.0657733,-1.8779807,52.1324600,-2.3275853,0.1358787,0.0684392,-2.2355573
-1615570468,52.1324529,-2.3275850,0.1335946,0.0679691,-2.7123020,52.1324600,-2.3275853,0.1358935,0.0683724,-2.2345924
-1615570469,52.1324528,-2.3275849,0.1328238,0.0643096,-1.9081851,52.1324600,-2.3275853,0.1358710,0.0684089,-2.2352140
-1615570469,52.1324528,-2.3275848,0.1306503,0.0689451,-2.5293393,52.1324600,-2.3275853,0.1359051,0.0684327,-2.2353001
-1615570469,52.1324527,-2.3275848,0.1335836,0.0667492,-1.8641447,52.1324600,-2.3275853,0.1359090,0.0684563,-2.2355816
-1615570470,52.1324526,-2.3275846,0.1299210,0.0699211,-2.4336414,52.1324600,-2.3275853,0.1358380,0.0684402,-2.2358367
-1615570470,52.1324525,-2.3275845,0.1369994,0.0633339,-2.2035477,52.1324600,-2.3275853,0.1358705,0.0683547,-2.2345123
-1615570471,52.1324524,-2.3275845,0.1315978,0.0647975,-1.8910627,52.1324600,-2.3275853,0.1359725,0.0683928,-2.2343407
-1615570471,52.1324524,-2.3275844,0.1353362,0.0699211,-2.3032260,52.1324600,-2.3275853,0.1358962,0.0683694,-2.2345343
-1615570471,52.1324523,-2.3275844,0.1350605,0.0667492,-2.4691954,52.1324599,-2.3275853,0.1359204,0.0683490,-2.2341123
-1615570472,52.1324523,-2.3275842,0.1347926,0.0643096,-2.1677761,52.1324599,-2.3275853,0.1358736,0.0683432,-2.2343421
-1615570472,52.1324523,-2.3275841,0.1316459,0.0701652,-2.3753963,52.1324599,-2.3275853,0.1358922,0.0683774,-2.2346652
-1615570472,52.1324522,-2.3275840,0.1328281,0.0647975,-2.3573513,52.1324599,-2.3275853,0.1358247,0.0683299,-2.2344892
-1615570473,52.1324522,-2.3275839,0.1301323,0.0660173,-2.1959898,52.1324599,-2.3275853,0.1357638,0.0684000,-2.2357988
-1615570473,52.1324522,-2.3275838,0.1323255,0.0635778,-1.9118017,52.1324599,-2.3275852,0.1357419,0.0683747,-2.2356136
-1615570474,52.1324522,-2.3275837,0.1296382,0.0657733,-2.3127978,52.1324599,-2.3275852,0.1356964,0.0683632,-2.2357624
-1615570474,52.1324521,-2.3275837,0.1358240,0.0694331,-2.4566095,52.1324599,-2.3275852,0.1357522,0.0683550,-2.2352898
-1615570474,52.1324521,-2.3275836,0.1301386,0.0667492,-1.9018946,52.1324599,-2.3275852,0.1357455,0.0683817,-2.2356815
-1615570475,52.1324521,-2.3275836,0.1330914,0.0667492,-1.8989319,52.1324599,-2.3275852,0.1357286,0.0683340,-2.2351708
-1615570475,52.1324522,-2.3275836,0.1335706,0.0652854,-2.2028074,52.1324599,-2.3275852,0.1357589,0.0683629,-2.2353482
-1615570475,52.1324522,-2.3275836,0.1335749,0.0657733,-1.5749267,52.1324599,-2.3275852,0.1357073,0.0684656,-2.2370236
-1615570476,52.1324522,-2.3275836,0.1330595,0.0630900,-2.3210139,52.1324598,-2.3275852,0.1357737,0.0684722,-2.2366748
-1615570476,52.1324523,-2.3275836,0.1306350,0.0672371,-2.3110061,52.1324598,-2.3275852,0.1358516,0.0684732,-2.2361794
-1615570477,52.1324523,-2.3275836,0.1350036,0.0601633,-2.2785947,52.1324598,-2.3275852,0.1358818,0.0685471,-2.2369421
-1615570477,52.1324523,-2.3275837,0.1306180,0.0652854,-2.2263150,52.1324598,-2.3275852,0.1359278,0.0685235,-2.2363358
-1615570477,52.1324524,-2.3275836,0.1311121,0.0655293,-2.4569035,52.1324598,-2.3275852,0.1358988,0.0685858,-2.2373340
-1615570478,52.1324524,-2.3275836,0.1343198,0.0665052,-1.4418619,52.1324598,-2.3275852,0.1358963,0.0685929,-2.2374427
-1615570478,52.1324525,-2.3275836,0.1345748,0.0674811,-1.9413086,52.1324598,-2.3275852,0.1358887,0.0685925,-2.2374871
-1615570478,52.1324525,-2.3275837,0.1318785,0.0687011,-2.3154197,52.1324598,-2.3275852,0.1358338,0.0686472,-2.2385559
-1615570479,52.1324526,-2.3275838,0.1311271,0.0672371,-1.9978822,52.1324598,-2.3275852,0.1359509,0.0687197,-2.2387333
-1615570479,52.1324527,-2.3275837,0.1318481,0.0652854,-2.3897657,52.1324598,-2.3275852,0.1359532,0.0686768,-2.2381625
-1615570480,52.1324528,-2.3275836,0.1284360,0.0689451,-1.8203248,52.1324598,-2.3275852,0.1359738,0.0687180,-2.2385621
-1615570480,52.1324527,-2.3275837,0.1326013,0.0669931,-2.7142279,52.1324598,-2.3275852,0.1360260,0.0688018,-2.2393079
-1615570480,52.1324528,-2.3275837,0.1323552,0.0669931,-2.0138340,52.1324598,-2.3275852,0.1361509,0.0688554,-2.2391891
-1615570481,52.1324529,-2.3275838,0.1316041,0.0655293,-1.6642183,52.1324598,-2.3275852,0.1360499,0.0688212,-2.2394035
-1615570481,52.1324530,-2.3275838,0.1298800,0.0652854,-1.9155313,52.1324597,-2.3275852,0.1360470,0.0688585,-2.2399046
-1615570481,52.1324530,-2.3275839,0.1311292,0.0674811,-2.5122862,52.1324597,-2.3275852,0.1360887,0.0688541,-2.2395778
-1615570482,52.1324531,-2.3275840,0.1279186,0.0660173,-2.4779809,52.1324597,-2.3275852,0.1361437,0.0689116,-2.2399635
-1615570482,52.1324532,-2.3275840,0.1360364,0.0657733,-2.2758620,52.1324597,-2.3275852,0.1361917,0.0688511,-2.2388697
-1615570483,52.1324533,-2.3275841,0.1330805,0.0655293,-2.3205926,52.1324597,-2.3275852,0.1362775,0.0689271,-2.2392938
-1615570483,52.1324534,-2.3275841,0.1298905,0.0665052,-2.4541075,52.1324597,-2.3275852,0.1362917,0.0689206,-2.2391183
-1615570483,52.1324535,-2.3275841,0.1348077,0.0660173,-2.3268569,52.1324597,-2.3275852,0.1362777,0.0689150,-2.2391374
-1615570484,52.1324536,-2.3275842,0.1303868,0.0669931,-2.8615060,52.1324597,-2.3275852,0.1362823,0.0688749,-2.2385907
-1615570484,52.1324537,-2.3275843,0.1335621,0.0643096,-2.3961892,52.1324597,-2.3275852,0.1362332,0.0688990,-2.2392199
-1615570484,52.1324538,-2.3275844,0.1308661,0.0655293,-2.6388078,52.1324597,-2.3275852,0.1362447,0.0689041,-2.2392101
-1615570485,52.1324539,-2.3275845,0.1345793,0.0679691,-2.2098279,52.1324597,-2.3275852,0.1361398,0.0687763,-2.2382400
-1615570485,52.1324540,-2.3275845,0.1304199,0.0706532,-2.8722663,52.1324597,-2.3275852,0.1360711,0.0687947,-2.2389245
-1615570486,52.1324541,-2.3275846,0.1367490,0.0628461,-2.0337114,52.1324597,-2.3275852,0.1360775,0.0689124,-2.2404060
-1615570486,52.1324542,-2.3275847,0.1333419,0.0672371,-1.9969568,52.1324597,-2.3275852,0.1359718,0.0688028,-2.2396743
-1615570486,52.1324542,-2.3275848,0.1294113,0.0679691,-2.4432254,52.1324597,-2.3275852,0.1359816,0.0686813,-2.2380352
-1615570487,52.1324543,-2.3275849,0.1335684,0.0650414,-2.1027117,52.1324597,-2.3275852,0.1359432,0.0686749,-2.2382021
-1615570487,52.1324544,-2.3275850,0.1293657,0.0626022,-2.2060983,52.1324596,-2.3275852,0.1359077,0.0686415,-2.2380009
-1615570487,52.1324545,-2.3275850,0.1365422,0.0672371,-2.1634536,52.1324596,-2.3275852,0.1359738,0.0686413,-2.2375665
-1615570488,52.1324545,-2.3275852,0.1311446,0.0691891,-2.5771160,52.1324596,-2.3275852,0.1359759,0.0686128,-2.2371831
-1615570488,52.1324546,-2.3275853,0.1320815,0.0638218,-2.1251383,52.1324596,-2.3275852,0.1359863,0.0686393,-2.2374597
-1615570489,52.1324547,-2.3275853,0.1294006,0.0667492,-2.2644584,52.1324596,-2.3275852,0.1359524,0.0686280,-2.2375348
-1615570489,52.1324548,-2.3275853,0.1340825,0.0674811,-2.3752930,52.1324596,-2.3275852,0.1359036,0.0686805,-2.2385342
-1615570489,52.1324549,-2.3275854,0.1306264,0.0662612,-2.5515363,52.1324596,-2.3275852,0.1358797,0.0686876,-2.2387819
-1615570490,52.1324550,-2.3275855,0.1335792,0.0662612,-2.3993695,52.1324596,-2.3275852,0.1358506,0.0687616,-2.2399316
-1615570490,52.1324550,-2.3275856,0.1328197,0.0638218,-2.3116817,52.1324596,-2.3275852,0.1359632,0.0688088,-2.2398119
-1615570490,52.1324551,-2.3275856,0.1313775,0.0677251,-1.8863583,52.1324596,-2.3275852,0.1359353,0.0687868,-2.2397072
-1615570491,52.1324551,-2.3275856,0.1308789,0.0669931,-2.4281788,52.1324596,-2.3275852,0.1359518,0.0688027,-2.2398052
-1615570491,52.1324552,-2.3275856,0.1303740,0.0655293,-2.1238017,52.1324596,-2.3275852,0.1360048,0.0688760,-2.2404108
-1615570492,52.1324553,-2.3275856,0.1350517,0.0657733,-2.8263659,52.1324596,-2.3275852,0.1359444,0.0688536,-2.2405131
-1615570492,52.1324554,-2.3275857,0.1311292,0.0674811,-2.1614394,52.1324596,-2.3275852,0.1359461,0.0689026,-2.2411373
-1615570492,52.1324554,-2.3275856,0.1316214,0.0674811,-2.6110532,52.1324596,-2.3275852,0.1360058,0.0688874,-2.2405517
-1615570493,52.1324555,-2.3275855,0.1345550,0.0652854,-2.3907371,52.1324596,-2.3275852,0.1360029,0.0689854,-2.2418396
-1615570493,52.1324555,-2.3275856,0.1301386,0.0667492,-2.3075070,52.1324596,-2.3275852,0.1359533,0.0689473,-2.2416677
-1615570493,52.1324556,-2.3275856,0.1333160,0.0643096,-2.7931347,52.1324596,-2.3275852,0.1359530,0.0688986,-2.2410398
-1615570494,52.1324556,-2.3275857,0.1345929,0.0694331,-2.3030567,52.1324596,-2.3275852,0.1360008,0.0689048,-2.2408092
-1615570494,52.1324556,-2.3275856,0.1341144,0.0708973,-2.9934220,52.1324596,-2.3275852,0.1359670,0.0689813,-2.2420189
-1615570495,52.1324556,-2.3275857,0.1365422,0.0672371,-2.4178839,52.1324596,-2.3275852,0.1359326,0.0689537,-2.2418861
-1615570495,52.1324556,-2.3275857,0.1328562,0.0679691,-2.5960088,52.1324596,-2.3275852,0.1358850,0.0689665,-2.2423601
-1615570495,52.1324557,-2.3275857,0.1323574,0.0672371,-2.4731522,52.1324596,-2.3275852,0.1359360,0.0689294,-2.2415488
-1615570496,52.1324556,-2.3275858,0.1321335,0.0696771,-2.1068847,52.1324595,-2.3275852,0.1359454,0.0689306,-2.2415023
-1615570496,52.1324556,-2.3275859,0.1323423,0.0655293,-2.5721624,52.1324595,-2.3275852,0.1359335,0.0689760,-2.2421682
-1615570496,52.1324556,-2.3275859,0.1326123,0.0682131,-1.9290054,52.1324595,-2.3275852,0.1357939,0.0689648,-2.2429309
-1615570497,52.1324556,-2.3275858,0.1318335,0.0635778,-2.4400594,52.1324595,-2.3275852,0.1358106,0.0689206,-2.2422483
-1615570497,52.1324555,-2.3275859,0.1345422,0.0638218,-2.2653944,52.1324595,-2.3275852,0.1358304,0.0689247,-2.2421739
-1615570498,52.1324556,-2.3275858,0.1328387,0.0660173,-2.3746631,52.1324595,-2.3275852,0.1358504,0.0689893,-2.2428808
-1615570498,52.1324555,-2.3275859,0.1308577,0.0645536,-1.9913163,52.1324595,-2.3275852,0.1358728,0.0689974,-2.2428393
-1615570498,52.1324555,-2.3275860,0.1345486,0.0645536,-2.8841429,52.1324595,-2.3275852,0.1358720,0.0690874,-2.2440107
-1615570499,52.1324555,-2.3275860,0.1303678,0.0647975,-1.8857791,52.1324595,-2.3275852,0.1358626,0.0691369,-2.2447135
-1615570499,52.1324554,-2.3275861,0.1370530,0.0691891,-2.1623850,52.1324595,-2.3275852,0.1359067,0.0691003,-2.2439525
-1615570499,52.1324554,-2.3275862,0.1325841,0.0650414,-2.3459558,52.1324595,-2.3275852,0.1358939,0.0690725,-2.2436755
-1615570500,52.1324554,-2.3275862,0.1328540,0.0677251,-2.0915880,52.1324595,-2.3275852,0.1360438,0.0690221,-2.2420497
-1615570500,52.1324553,-2.3275862,0.1318875,0.0696771,-2.3757725,52.1324595,-2.3275852,0.1360945,0.0689107,-2.2402804
-1615570501,52.1324552,-2.3275862,0.1340982,0.0691891,-2.3134665,52.1324595,-2.3275852,0.1359978,0.0688326,-2.2398977
-1615570501,52.1324551,-2.3275862,0.1345036,0.0591878,-2.4820700,52.1324595,-2.3275852,0.1360792,0.0687461,-2.2382493
-1615570501,52.1324551,-2.3275861,0.1316279,0.0682131,-2.3294213,52.1324595,-2.3275852,0.1361078,0.0687274,-2.2378223
-1615570502,52.1324551,-2.3275861,0.1333353,0.0665052,-1.7690291,52.1324595,-2.3275852,0.1361722,0.0687289,-2.2374225
-1615570502,52.1324550,-2.3275860,0.1318397,0.0643096,-2.9942658,52.1324595,-2.3275852,0.1361929,0.0687754,-2.2378888
-1615570502,52.1324550,-2.3275859,0.1360657,0.0689451,-2.8694303,52.1324595,-2.3275852,0.1362031,0.0687256,-2.2371788
-1615570503,52.1324549,-2.3275858,0.1315895,0.0638218,-1.9060351,52.1324595,-2.3275852,0.1362652,0.0687843,-2.2375352
-1615570503,52.1324549,-2.3275857,0.1313731,0.0672371,-2.3334947,52.1324595,-2.3275852,0.1363326,0.0687253,-2.2363358
-1615570504,52.1324548,-2.3275857,0.1335537,0.0633339,-2.2950675,52.1324595,-2.3275852,0.1362644,0.0688205,-2.2380073
-1615570504,52.1324548,-2.3275856,0.1355353,0.0647975,-2.4632154,52.1324595,-2.3275852,0.1361895,0.0687712,-2.2378559
-1615570504,52.1324547,-2.3275855,0.1296552,0.0677251,-2.1465788,52.1324595,-2.3275852,0.1362403,0.0687524,-2.2372832
-1615570505,52.1324547,-2.3275854,0.1360452,0.0667492,-1.9862156,52.1324594,-2.3275852,0.1361999,0.0688235,-2.2384634
-1615570505,52.1324547,-2.3275853,0.1318481,0.0652854,-2.2739162,52.1324594,-2.3275852,0.1360474,0.0688516,-2.2398176
-1615570505,52.1324547,-2.3275852,0.1345115,0.0601633,-2.9261887,52.1324594,-2.3275852,0.1360393,0.0687863,-2.2390249
-1615570506,52.1324547,-2.3275851,0.1304086,0.0694331,-2.5686493,52.1324594,-2.3275852,0.1360150,0.0687258,-2.2383990
-1615570506,52.1324546,-2.3275849,0.1318830,0.0691891,-1.8556346,52.1324594,-2.3275852,0.1359182,0.0687217,-2.2389765
-1615570507,52.1324546,-2.3275848,0.1335858,0.0669931,-2.2655451,52.1324594,-2.3275852,0.1358442,0.0687147,-2.2393675
-1615570507,52.1324546,-2.3275848,0.1316302,0.0684571,-2.5535512,52.1324594,-2.3275852,0.1358481,0.0687403,-2.2396741
-1615570507,52.1324545,-2.3275846,0.1308963,0.0689451,-2.2627358,52.1324594,-2.3275852,0.1358381,0.0687779,-2.2402282
-1615570508,52.1324545,-2.3275845,0.1333309,0.0660173,-1.9964566,52.1324594,-2.3275852,0.1358529,0.0688523,-2.2410965
-1615570508,52.1324544,-2.3275844,0.1313539,0.0650414,-1.8780228,52.1324594,-2.3275852,0.1359046,0.0687228,-2.2390807
-1615570508,52.1324544,-2.3275844,0.1340607,0.0650414,-1.9414864,52.1324594,-2.3275852,0.1359616,0.0688551,-2.2404244
-1615570509,52.1324544,-2.3275843,0.1326013,0.0669931,-2.8181148,52.1324594,-2.3275852,0.1359194,0.0688378,-2.2404747
-1615570509,52.1324543,-2.3275842,0.1321246,0.0687011,-2.1483245,52.1324594,-2.3275852,0.1358114,0.0688305,-2.2410829
-1615570510,52.1324543,-2.3275841,0.1340693,0.0660173,-2.3738544,52.1324594,-2.3275852,0.1358505,0.0687390,-2.2396410
-1615570510,52.1324543,-2.3275841,0.1345572,0.0655293,-2.1769347,52.1324594,-2.3275852,0.1358423,0.0688004,-2.2404909
-1615570510,52.1324543,-2.3275840,0.1321268,0.0689451,-2.5122156,52.1324594,-2.3275852,0.1357993,0.0688188,-2.2410100
-1615570511,52.1324542,-2.3275839,0.1309008,0.0694331,-1.8093923,52.1324594,-2.3275852,0.1357499,0.0688157,-2.2412920
-1615570511,52.1324543,-2.3275839,0.1330979,0.0674811,-2.2149835,52.1324594,-2.3275852,0.1356260,0.0688102,-2.2420292
-1615570511,52.1324543,-2.3275838,0.1353133,0.0674811,-2.3259330,52.1324594,-2.3275852,0.1356654,0.0688136,-2.2418163
-1615570512,52.1324544,-2.3275837,0.1316214,0.0674811,-2.5677860,52.1324594,-2.3275852,0.1356234,0.0687635,-2.2414391
-1615570512,52.1324543,-2.3275836,0.1320836,0.0640657,-2.3388414,52.1324594,-2.3275852,0.1355932,0.0688707,-2.2430320
-1615570513,52.1324543,-2.3275836,0.1335858,0.0669931,-1.8816278,52.1324594,-2.3275852,0.1356372,0.0688721,-2.2427623
-1615570513,52.1324544,-2.3275835,0.1320941,0.0652854,-2.8806937,52.1324593,-2.3275852,0.1355226,0.0688726,-2.2435184
-1615570513,52.1324544,-2.3275835,0.1309075,0.0701652,-2.4525349,52.1324593,-2.3275852,0.1354723,0.0689051,-2.2442708
-1615570514,52.1324544,-2.3275834,0.1316413,0.0696771,-1.8201683,52.1324593,-2.3275852,0.1355115,0.0689116,-2.2440987
-1615570514,52.1324545,-2.3275834,0.1360520,0.0674811,-2.4447033,52.1324593,-2.3275852,0.1355069,0.0689742,-2.2449431
-1615570514,52.1324545,-2.3275833,0.1357793,0.0645536,-2.3593512,52.1324593,-2.3275852,0.1354945,0.0690376,-2.2458496
-1615570515,52.1324545,-2.3275833,0.1335770,0.0660173,-2.7879827,52.1324593,-2.3275852,0.1355129,0.0690675,-2.2461181
-1615570515,52.1324546,-2.3275833,0.1306222,0.0657733,-2.5823798,52.1324593,-2.3275852,0.1355235,0.0690192,-2.2454212
-1615570516,52.1324547,-2.3275832,0.1325473,0.0606510,-1.8377521,52.1324593,-2.3275852,0.1354804,0.0690508,-2.2461145
-1615570516,52.1324547,-2.3275832,0.1318566,0.0662612,-1.9898698,52.1324593,-2.3275852,0.1356611,0.0691517,-2.2462471
-1615570516,52.1324548,-2.3275831,0.1311446,0.0691891,-2.4630773,52.1324593,-2.3275852,0.1356152,0.0691627,-2.2466879
-1615570517,52.1324548,-2.3275831,0.1308598,0.0647975,-3.0069885,52.1324593,-2.3275852,0.1356613,0.0692838,-2.2479596
-1615570517,52.1324549,-2.3275830,0.1358080,0.0677251,-2.5720916,52.1324593,-2.3275852,0.1356450,0.0692038,-2.2470284
-1615570517,52.1324551,-2.3275829,0.1343331,0.0679691,-2.3669548,52.1324593,-2.3275852,0.1355895,0.0692384,-2.2478390
-1615570518,52.1324551,-2.3275828,0.1321113,0.0672371,-2.1111465,52.1324593,-2.3275852,0.1356821,0.0691837,-2.2465253
-1615570518,52.1324553,-2.3275827,0.1308598,0.0647975,-1.8710835,52.1324593,-2.3275852,0.1355807,0.0692016,-2.2474191
-1615570519,52.1324553,-2.3275826,0.1303740,0.0655293,-2.3082304,52.1324593,-2.3275852,0.1355298,0.0691845,-2.2475290
-1615570519,52.1324554,-2.3275825,0.1318875,0.0696771,-2.4765768,52.1324593,-2.3275852,0.1355634,0.0692156,-2.2477140
-1615570519,52.1324555,-2.3275823,0.1288982,0.0655293,-2.3679528,52.1324593,-2.3275852,0.1355093,0.0692275,-2.2482209
-1615570520,52.1324556,-2.3275822,0.1311121,0.0655293,-2.4830968,52.1324593,-2.3275852,0.1355177,0.0692679,-2.2486916
-1615570520,52.1324557,-2.3275821,0.1318566,0.0662612,-2.2783818,52.1324593,-2.3275852,0.1355854,0.0692856,-2.2484803
-1615570520,52.1324558,-2.3275820,0.1331113,0.0689451,-2.5817971,52.1324593,-2.3275852,0.1355740,0.0692801,-2.2484827
-1615570521,52.1324559,-2.3275819,0.1348300,0.0684571,-2.1769419,52.1324593,-2.3275852,0.1354994,0.0692157,-2.2481332
-1615570521,52.1324559,-2.3275819,0.1318213,0.0621144,-1.5355632,52.1324593,-2.3275852,0.1354964,0.0692394,-2.2484608
-1615570522,52.1324561,-2.3275817,0.1328366,0.0657733,-2.1105373,52.1324593,-2.3275852,0.1355199,0.0692173,-2.2480199
-1615570522,52.1324561,-2.3275816,0.1335579,0.0638218,-2.5146108,52.1324593,-2.3275852,0.1354017,0.0691568,-2.2480054
-1615570522,52.1324562,-2.3275815,0.1323797,0.0696771,-2.4155900,52.1324593,-2.3275851,0.1355084,0.0692230,-2.2481689
-1615570523,52.1324562,-2.3275814,0.1261831,0.0643096,-1.6209687,52.1324592,-2.3275851,0.1354641,0.0692245,-2.2484787
-1615570523,52.1324563,-2.3275814,0.1306307,0.0667492,-3.0322208,52.1324592,-2.3275851,0.1355606,0.0693180,-2.2490637
-1615570523,52.1324564,-2.3275812,0.1328562,0.0679691,-2.5320504,52.1324592,-2.3275851,0.1354537,0.0692741,-2.2491920
-1615570524,52.1324565,-2.3275812,0.1328562,0.0679691,-1.8313860,52.1324592,-2.3275851,0.1355071,0.0692574,-2.2486243
-1615570524,52.1324565,-2.3275812,0.1315834,0.0630900,-2.0521412,52.1324592,-2.3275851,0.1355156,0.0692173,-2.2480476
-1615570525,52.1324566,-2.3275811,0.1338275,0.0665052,-1.9704711,52.1324592,-2.3275851,0.1355867,0.0692732,-2.2483108
-1615570525,52.1324566,-2.3275811,0.1313581,0.0655293,-2.0837941,52.1324592,-2.3275851,0.1356307,0.0693279,-2.2487340
-1615570525,52.1324567,-2.3275809,0.1333419,0.0672371,-1.6713624,52.1324592,-2.3275851,0.1355468,0.0693145,-2.2491059
-1615570526,52.1324568,-2.3275808,0.1350808,0.0689451,-2.2889214,52.1324592,-2.3275851,0.1354755,0.0691997,-2.2480800
-1615570526,52.1324569,-2.3275808,0.1293778,0.0640657,-2.2389719,52.1324592,-2.3275851,0.1353603,0.0692345,-2.2492859
-1615570526,52.1324569,-2.3275806,0.1313456,0.0640657,-2.6516366,52.1324592,-2.3275851,0.1353210,0.0691667,-2.2486598
-1615570527,52.1324570,-2.3275806,0.1340915,0.0684571,-2.0876467,52.1324592,-2.3275851,0.1352997,0.0691853,-2.2490416
-1615570527,52.1324571,-2.3275805,0.1308598,0.0647975,-2.1792865,52.1324592,-2.3275851,0.1352508,0.0691077,-2.2483506
-1615570528,52.1324572,-2.3275804,0.1289087,0.0667492,-2.4634213,52.1324592,-2.3275851,0.1352467,0.0691044,-2.2483337
-1615570528,52.1324573,-2.3275803,0.1345770,0.0677251,-2.0968058,52.1324592,-2.3275851,0.1352813,0.0692006,-2.2493615
-1615570528,52.1324573,-2.3275802,0.1323173,0.0626022,-1.7926027,52.1324592,-2.3275851,0.1352963,0.0692637,-2.2500868
-1615570529,52.1324575,-2.3275802,0.1316106,0.0662612,-2.1408317,52.1324592,-2.3275851,0.1352922,0.0693249,-2.2509103
-1615570529,52.1324575,-2.3275801,0.1308682,0.0657733,-2.0456309,52.1324592,-2.3275851,0.1352528,0.0693041,-2.2508972
-1615570529,52.1324576,-2.3275799,0.1363027,0.0679691,-1.8647910,52.1324592,-2.3275851,0.1352976,0.0691961,-2.2491965
-1615570530,52.1324577,-2.3275799,0.1298863,0.0660173,-2.2407613,52.1324592,-2.3275851,0.1353218,0.0691567,-2.2485242
-1615570530,52.1324577,-2.3275798,0.1316020,0.0652854,-2.3566670,52.1324592,-2.3275851,0.1352057,0.0691270,-2.2488976
-1615570531,52.1324579,-2.3275796,0.1348055,0.0657733,-2.3831801,52.1324592,-2.3275851,0.1352583,0.0691506,-2.2488604
-1615570531,52.1324579,-2.3275796,0.1323297,0.0640657,-1.8347315,52.1324592,-2.3275851,0.1352326,0.0691544,-2.2490788
-1615570531,52.1324579,-2.3275795,0.1326258,0.0696771,-2.1522980,52.1324592,-2.3275851,0.1351640,0.0691557,-2.2495458
-1615570532,52.1324580,-2.3275794,0.1330513,0.0621144,-1.9871281,52.1324592,-2.3275850,0.1351355,0.0691382,-2.2495041
-1615570532,52.1324581,-2.3275793,0.1318897,0.0699211,-2.1829164,52.1324592,-2.3275850,0.1351900,0.0690394,-2.2478549
-1615570532,52.1324582,-2.3275793,0.1296382,0.0657733,-2.3824244,52.1324592,-2.3275850,0.1351651,0.0690401,-2.2480280
-1615570533,52.1324583,-2.3275792,0.1346045,0.0706532,-2.6400146,52.1324592,-2.3275850,0.1350928,0.0690063,-2.2480607
-1615570533,52.1324583,-2.3275792,0.1303555,0.0633339,-2.6070452,52.1324592,-2.3275850,0.1350779,0.0690647,-2.2489228
-1615570534,52.1324584,-2.3275791,0.1343176,0.0662612,-2.1344392,52.1324592,-2.3275850,0.1351186,0.0689407,-2.2470326
-1615570534,52.1324585,-2.3275791,0.1333331,0.0662612,-2.2503066,52.1324592,-2.3275850,0.1350909,0.0690024,-2.2480221
-1615570534,52.1324585,-2.3275791,0.1342898,0.0630900,-1.9983476,52.1324592,-2.3275850,0.1350303,0.0688865,-2.2469029
-1615570535,52.1324586,-2.3275790,0.1350561,0.0662612,-1.8463309,52.1324592,-2.3275850,0.1350371,0.0687869,-2.2455518
-1615570535,52.1324587,-2.3275790,0.1272148,0.0699211,-2.5622585,52.1324592,-2.3275850,0.1350957,0.0687714,-2.2449629
-1615570535,52.1324588,-2.3275789,0.1299368,0.0716294,-2.6180453,52.1324592,-2.3275850,0.1350857,0.0687254,-2.2444251
-1615570536,52.1324589,-2.3275789,0.1335814,0.0665052,-2.8766856,52.1324592,-2.3275850,0.1349949,0.0687172,-2.2449164
-1615570536,52.1324590,-2.3275789,0.1328094,0.0626022,-2.0780578,52.1324592,-2.3275850,0.1350880,0.0686570,-2.2435122
-1615570537,52.1324591,-2.3275789,0.1298758,0.0647975,-2.3825567,52.1324592,-2.3275850,0.1351135,0.0687662,-2.2447758
-1615570537,52.1324592,-2.3275788,0.1303762,0.0657733,-1.8264526,52.1324592,-2.3275850,0.1350062,0.0687083,-2.2447243
-1615570537,52.1324593,-2.3275788,0.1325927,0.0660173,-2.3711743,52.1324592,-2.3275850,0.1350304,0.0687549,-2.2451756
-1615570538,52.1324594,-2.3275787,0.1353133,0.0674811,-2.3247061,52.1324592,-2.3275850,0.1350376,0.0687032,-2.2444501
-1615570538,52.1324595,-2.3275787,0.1367929,0.0677251,-2.5285008,52.1324592,-2.3275850,0.1349766,0.0686349,-2.2439556
-1615570538,52.1324596,-2.3275787,0.1343068,0.0650414,-2.3092275,52.1324592,-2.3275849,0.1350722,0.0686510,-2.2435369
-1615570539,52.1324597,-2.3275786,0.1320941,0.0652854,-1.9936249,52.1324592,-2.3275849,0.1350779,0.0685366,-2.2419977
-1615570539,52.1324597,-2.3275786,0.1301494,0.0679691,-2.5723004,52.1324592,-2.3275849,0.1351006,0.0686073,-2.2427754
-1615570540,52.1324598,-2.3275785,0.1340715,0.0662612,-2.3334901,52.1324592,-2.3275849,0.1352689,0.0687108,-2.2430246
-1615570540,52.1324598,-2.3275784,0.1318418,0.0645536,-2.1007037,52.1324592,-2.3275849,0.1352298,0.0687183,-2.2433791
-1615570540,52.1324599,-2.3275783,0.1325778,0.0643096,-2.1906095,52.1324592,-2.3275849,0.1351736,0.0686616,-2.2430062
-1615570541,52.1324598,-2.3275782,0.1367728,0.0655293,-2.4727681,52.1324592,-2.3275849,0.1352230,0.0686186,-2.2421174
-1615570541,52.1324599,-2.3275781,0.1304131,0.0699211,-2.8351521,52.1324592,-2.3275849,0.1352587,0.0686342,-2.2420883
-1615570541,52.1324599,-2.3275781,0.1338210,0.0657733,-2.3219538,52.1324592,-2.3275849,0.1352626,0.0686475,-2.2422366
-1615570542,52.1324600,-2.3275780,0.1335969,0.0682131,-2.4799695,52.1324592,-2.3275849,0.1353283,0.0687595,-2.2432692
-1615570542,52.1324600,-2.3275780,0.1318481,0.0652854,-2.3690073,52.1324592,-2.3275849,0.1354063,0.0687665,-2.2428498
-1615570543,52.1324601,-2.3275779,0.1338363,0.0674811,-2.5566010,52.1324592,-2.3275849,0.1353591,0.0687718,-2.2432280
-1615570543,52.1324602,-2.3275779,0.1350324,0.0635778,-2.2724714,52.1324592,-2.3275849,0.1352736,0.0686990,-2.2428386
-1615570543,52.1324603,-2.3275779,0.1330892,0.0665052,-2.3613896,52.1324592,-2.3275849,0.1351653,0.0686722,-2.2431989
-1615570544,52.1324603,-2.3275777,0.1316106,0.0662612,-2.7850676,52.1324592,-2.3275849,0.1351265,0.0686939,-2.2437384
-1615570544,52.1324604,-2.3275777,0.1340892,0.0682131,-2.2863500,52.1324592,-2.3275849,0.1351444,0.0686307,-2.2427924
-1615570544,52.1324604,-2.3275776,0.1328629,0.0687011,-2.3215554,52.1324592,-2.3275849,0.1352077,0.0685635,-2.2414951
-1615570545,52.1324605,-2.3275777,0.1316020,0.0652854,-2.2110577,52.1324592,-2.3275848,0.1351735,0.0686184,-2.2424395
-1615570545,52.1324605,-2.3275776,0.1357520,0.0613827,-1.7422807,52.1324592,-2.3275848,0.1352490,0.0686388,-2.2422104
-1615570546,52.1324606,-2.3275776,0.1330699,0.0643096,-2.1204810,52.1324592,-2.3275848,0.1352007,0.0687356,-2.2437949
-1615570546,52.1324606,-2.3275775,0.1326236,0.0694331,-2.3359027,52.1324592,-2.3275848,0.1351937,0.0687950,-2.2446184
-1615570546,52.1324607,-2.3275774,0.1311674,0.0716294,-2.6513073,52.1324592,-2.3275848,0.1351657,0.0687531,-2.2442532
-1615570547,52.1324607,-2.3275773,0.1355528,0.0667492,-2.6130548,52.1324592,-2.3275848,0.1351637,0.0687222,-2.2438626
-1615570547,52.1324607,-2.3275773,0.1296340,0.0652854,-2.6426001,52.1324592,-2.3275848,0.1351560,0.0687850,-2.2447360
-1615570547,52.1324607,-2.3275773,0.1318696,0.0677251,-2.4113479,52.1324592,-2.3275848,0.1349799,0.0688156,-2.2462947
-1615570548,52.1324607,-2.3275772,0.1330784,0.0652854,-2.9715419,52.1324592,-2.3275848,0.1348890,0.0687443,-2.2459576
-1615570548,52.1324607,-2.3275772,0.1333245,0.0652854,-2.3167253,52.1324592,-2.3275848,0.1348899,0.0687883,-2.2465298
-1615570549,52.1324607,-2.3275772,0.1348368,0.0691891,-2.2030764,52.1324592,-2.3275848,0.1348211,0.0687270,-2.2461774
-1615570549,52.1324607,-2.3275773,0.1325948,0.0662612,-2.1118178,52.1324592,-2.3275848,0.1348631,0.0687197,-2.2458043
-1615570549,52.1324607,-2.3275772,0.1333507,0.0682131,-1.9949918,52.1324592,-2.3275848,0.1347687,0.0687850,-2.2472863
-1615570550,52.1324607,-2.3275772,0.1328431,0.0665052,-2.1137233,52.1324592,-2.3275848,0.1347931,0.0687830,-2.2470989
-1615570550,52.1324607,-2.3275772,0.1298616,0.0630900,-2.4419188,52.1324592,-2.3275848,0.1348066,0.0687919,-2.2471273
-1615570550,52.1324607,-2.3275772,0.1288961,0.0652854,-2.6046848,52.1324592,-2.3275848,0.1348619,0.0687637,-2.2463918
-1615570551,52.1324607,-2.3275772,0.1340803,0.0672371,-1.6825398,52.1324592,-2.3275847,0.1349434,0.0688177,-2.2465634
-1615570551,52.1324607,-2.3275771,0.1335496,0.0628461,-2.1039586,52.1324592,-2.3275847,0.1348971,0.0688516,-2.2473133
-1615570552,52.1324607,-2.3275770,0.1330892,0.0665052,-2.4457147,52.1324592,-2.3275847,0.1349644,0.0688087,-2.2463071
-1615570552,52.1324607,-2.3275771,0.1331046,0.0682131,-2.5426245,52.1324592,-2.3275847,0.1349024,0.0688559,-2.2473354
-1615570552,52.1324606,-2.3275771,0.1357771,0.0643096,-2.3483400,52.1324592,-2.3275847,0.1348525,0.0688354,-2.2473955
-1615570553,52.1324607,-2.3275770,0.1303911,0.0674811,-2.1892912,52.1324592,-2.3275847,0.1347610,0.0688312,-2.2479429
-1615570553,52.1324606,-2.3275770,0.1315813,0.0628461,-2.4180646,52.1324592,-2.3275847,0.1348760,0.0689378,-2.2485859
-1615570553,52.1324606,-2.3275770,0.1298926,0.0667492,-2.6622591,52.1324592,-2.3275847,0.1347724,0.0689156,-2.2489774
-1615570554,52.1324606,-2.3275769,0.1367861,0.0669931,-2.4062097,52.1324592,-2.3275847,0.1346878,0.0689168,-2.2495522
-1615570554,52.1324605,-2.3275769,0.1316192,0.0672371,-2.3098316,52.1324592,-2.3275847,0.1346483,0.0689564,-2.2503328
-1615570555,52.1324605,-2.3275769,0.1267317,0.0708973,-2.5952926,52.1324592,-2.3275847,0.1346236,0.0690039,-2.2511225
-1615570555,52.1324604,-2.3275770,0.1311079,0.0650414,-2.4491818,52.1324592,-2.3275847,0.1346923,0.0689754,-2.2502935
-1615570555,52.1324604,-2.3275769,0.1343399,0.0687011,-2.1377258,52.1324592,-2.3275847,0.1347154,0.0689799,-2.2502000
-1615570556,52.1324603,-2.3275769,0.1353044,0.0665052,-1.9881240,52.1324592,-2.3275847,0.1346690,0.0690642,-2.2516150
-1615570556,52.1324603,-2.3275768,0.1323774,0.0694331,-2.3280444,52.1324592,-2.3275847,0.1346134,0.0690131,-2.2513094
-1615570556,52.1324604,-2.3275770,0.1352891,0.0647975,-2.1810527,52.1324592,-2.3275846,0.1346184,0.0690587,-2.2518764
-1615570557,52.1324603,-2.3275769,0.1338408,0.0679691,-2.1296144,52.1324592,-2.3275846,0.1346746,0.0691699,-2.2529674
-1615570557,52.1324603,-2.3275769,0.1315937,0.0643096,-2.8343706,52.1324592,-2.3275846,0.1346920,0.0692156,-2.2534533
-1615570558,52.1324603,-2.3275769,0.1303846,0.0667492,-1.7309088,52.1324592,-2.3275846,0.1346737,0.0690958,-2.2520003
-1615570558,52.1324603,-2.3275769,0.1335727,0.0655293,-3.0852427,52.1324592,-2.3275846,0.1347560,0.0692042,-2.2528806
-1615570558,52.1324603,-2.3275770,0.1340458,0.0633339,-2.2808509,52.1324592,-2.3275846,0.1348381,0.0692259,-2.2526245
-1615570559,52.1324602,-2.3275769,0.1298477,0.0613827,-1.8963104,52.1324592,-2.3275846,0.1347147,0.0690856,-2.2515969
-1615570559,52.1324602,-2.3275769,0.1294028,0.0669931,-2.5561225,52.1324593,-2.3275846,0.1347177,0.0690516,-2.2511294
-1615570559,52.1324603,-2.3275769,0.1350473,0.0652854,-2.0858836,52.1324593,-2.3275846,0.1347289,0.0690885,-2.2515407
-1615570560,52.1324603,-2.3275768,0.1355595,0.0674811,-2.5182450,52.1324593,-2.3275846,0.1345877,0.0690912,-2.2525091
-1615570560,52.1324602,-2.3275768,0.1345704,0.0669931,-2.4443257,52.1324593,-2.3275846,0.1346058,0.0690652,-2.2520468
-1615570561,52.1324603,-2.3275767,0.1350605,0.0667492,-2.2473087,52.1324593,-2.3275846,0.1346033,0.0690366,-2.2516870
-1615570561,52.1324602,-2.3275768,0.1353456,0.0708973,-2.4442496,52.1324593,-2.3275846,0.1345410,0.0689397,-2.2508230
-1615570561,52.1324603,-2.3275767,0.1340500,0.0638218,-2.0602889,52.1324593,-2.3275846,0.1346002,0.0689187,-2.2501545
-1615570562,52.1324603,-2.3275767,0.1288961,0.0652854,-1.4339433,52.1324593,-2.3275846,0.1344916,0.0689784,-2.2516601
-1615570562,52.1324603,-2.3275767,0.1338081,0.0643096,-1.7501307,52.1324593,-2.3275845,0.1345406,0.0689832,-2.2513995
-1615570562,52.1324602,-2.3275766,0.1311249,0.0669931,-2.3039227,52.1324593,-2.3275845,0.1345790,0.0690138,-2.2515490
-1615570563,52.1324602,-2.3275766,0.1362914,0.0667492,-2.2195415,52.1324593,-2.3275845,0.1344929,0.0689786,-2.2516541
-1615570563,52.1324602,-2.3275766,0.1291762,0.0691891,-2.3085623,52.1324593,-2.3275845,0.1344866,0.0689127,-2.2508256
-1615570564,52.1324602,-2.3275766,0.1326146,0.0684571,-1.8363402,52.1324593,-2.3275845,0.1343397,0.0689176,-2.2518649
-1615570564,52.1324601,-2.3275766,0.1320878,0.0645536,-2.1674478,52.1324593,-2.3275845,0.1343410,0.0689627,-2.2524529
-1615570564,52.1324601,-2.3275766,0.1311079,0.0650414,-2.8103924,52.1324593,-2.3275845,0.1342296,0.0689090,-2.2524824
-1615570565,52.1324600,-2.3275766,0.1323466,0.0660173,-2.2870951,52.1324593,-2.3275845,0.1343055,0.0689109,-2.2520030
-1615570565,52.1324601,-2.3275765,0.1303415,0.0616266,-2.0176902,52.1324593,-2.3275845,0.1342971,0.0689786,-2.2529542
-1615570565,52.1324600,-2.3275765,0.1304131,0.0699211,-2.4871831,52.1324593,-2.3275845,0.1344374,0.0689959,-2.2522521
-1615570566,52.1324600,-2.3275764,0.1343309,0.0677251,-2.3514688,52.1324593,-2.3275845,0.1343625,0.0690369,-2.2532899
-1615570566,52.1324599,-2.3275763,0.1336243,0.0711413,-2.3556807,52.1324593,-2.3275845,0.1343895,0.0690460,-2.2532308
-1615570567,52.1324598,-2.3275763,0.1318763,0.0684571,-1.9873306,52.1324593,-2.3275845,0.1342599,0.0689026,-2.2521956
-1615570567,52.1324598,-2.3275762,0.1330957,0.0672371,-2.3711271,52.1324593,-2.3275845,0.1341938,0.0689607,-2.2534046
-1615570567,52.1324598,-2.3275761,0.1311314,0.0677251,-2.0171347,52.1324593,-2.3275845,0.1341662,0.0690192,-2.2543621
-1615570568,52.1324598,-2.3275759,0.1346332,0.0735820,-2.2963178,52.1324593,-2.3275844,0.1341216,0.0690765,-2.2554166
-1615570568,52.1324598,-2.3275758,0.1335770,0.0660173,-2.4525948,52.1324593,-2.3275844,0.1340236,0.0690702,-2.2559860
-1615570568,52.1324598,-2.3275757,0.1330699,0.0643096,-2.6847277,52.1324593,-2.3275844,0.1339802,0.0690874,-2.2565031
-1615570569,52.1324598,-2.3275756,0.1325991,0.0667492,-2.1387668,52.1324593,-2.3275844,0.1339765,0.0691713,-2.2576406
-1615570569,52.1324597,-2.3275755,0.1360939,0.0718735,-2.4216661,52.1324593,-2.3275844,0.1339603,0.0692003,-2.2581317
-1615570570,52.1324598,-2.3275754,0.1303494,0.0626022,-1.8463112,52.1324593,-2.3275844,0.1340388,0.0693198,-2.2591934
-1615570570,52.1324598,-2.3275753,0.1347883,0.0638218,-1.8021291,52.1324593,-2.3275844,0.1341159,0.0693911,-2.2596250
-1615570570,52.1324598,-2.3275752,0.1340500,0.0638218,-2.2013113,52.1324593,-2.3275844,0.1340829,0.0692940,-2.2585602
-1615570571,52.1324597,-2.3275751,0.1313998,0.0701652,-2.3660445,52.1324593,-2.3275844,0.1341015,0.0693040,-2.2585690
-1615570571,52.1324598,-2.3275750,0.1298697,0.0640657,-1.8730360,52.1324593,-2.3275844,0.1340489,0.0693737,-2.2598400
-1615570571,52.1324597,-2.3275749,0.1279207,0.0662612,-2.5562739,52.1324593,-2.3275844,0.1341024,0.0692948,-2.2584414
-1615570572,52.1324598,-2.3275747,0.1293737,0.0635778,-2.0080740,52.1324593,-2.3275844,0.1340379,0.0693244,-2.2592607
-1615570572,52.1324598,-2.3275746,0.1358058,0.0674811,-2.3261333,52.1324593,-2.3275844,0.1339656,0.0693330,-2.2598567
-1615570573,52.1324597,-2.3275745,0.1372900,0.0682131,-2.2502375,52.1324593,-2.3275844,0.1340116,0.0693918,-2.2603278
-1615570573,52.1324597,-2.3275745,0.1291359,0.0645536,-2.4625628,52.1324593,-2.3275843,0.1339118,0.0694402,-2.2616334
-1615570573,52.1324597,-2.3275745,0.1338521,0.0691891,-2.5505276,52.1324593,-2.3275843,0.1338326,0.0693879,-2.2614663
-1615570574,52.1324597,-2.3275744,0.1350452,0.0650414,-1.7490774,52.1324593,-2.3275843,0.1339442,0.0693589,-2.2603390
-1615570574,52.1324596,-2.3275743,0.1320857,0.0643096,-2.0532362,52.1324593,-2.3275843,0.1339072,0.0694003,-2.2611339
-1615570574,52.1324597,-2.3275743,0.1340715,0.0662612,-1.9018523,52.1324593,-2.3275843,0.1338306,0.0694077,-2.2617416
-1615570575,52.1324597,-2.3275743,0.1311206,0.0665052,-2.3325448,52.1324593,-2.3275843,0.1337871,0.0692623,-2.2601020
-1615570575,52.1324597,-2.3275741,0.1340937,0.0687011,-2.3210087,52.1324593,-2.3275843,0.1337563,0.0692613,-2.2602937
-1615570576,52.1324597,-2.3275740,0.1313731,0.0672371,-2.0668650,52.1324593,-2.3275843,0.1338605,0.0692819,-2.2598722
-1615570576,52.1324597,-2.3275739,0.1316192,0.0672371,-2.5036817,52.1324593,-2.3275843,0.1338287,0.0692842,-2.2601161
-1615570576,52.1324597,-2.3275738,0.1340479,0.0635778,-2.1186614,52.1324593,-2.3275843,0.1338039,0.0693294,-2.2608805
-1615570577,52.1324598,-2.3275737,0.1350430,0.0647975,-1.8386446,52.1324593,-2.3275843,0.1337710,0.0693537,-2.2614226
-1615570577,52.1324598,-2.3275737,0.1303494,0.0626022,-1.7097831,52.1324593,-2.3275843,0.1337313,0.0694055,-2.2623761
-1615570577,52.1324598,-2.3275735,0.1350649,0.0672371,-1.7393059,52.1324593,-2.3275842,0.1337055,0.0693837,-2.2622576
-1615570578,52.1324598,-2.3275735,0.1306200,0.0655293,-2.2877839,52.1324593,-2.3275842,0.1337889,0.0695615,-2.2640624
-1615570578,52.1324598,-2.3275734,0.1316504,0.0706532,-2.1035528,52.1324593,-2.3275842,0.1338833,0.0695342,-2.2630725
-1615570579,52.1324599,-2.3275733,0.1328474,0.0669931,-1.8384191,52.1324593,-2.3275842,0.1337978,0.0695728,-2.2641528
-1615570579,52.1324599,-2.3275732,0.1347905,0.0640657,-2.7515657,52.1324593,-2.3275842,0.1338004,0.0695777,-2.2642014
-1615570579,52.1324599,-2.3275730,0.1326236,0.0694331,-2.2250819,52.1324593,-2.3275842,0.1337818,0.0695615,-2.2641103
-1615570580,52.1324600,-2.3275730,0.1306328,0.0669931,-2.1554985,52.1324593,-2.3275842,0.1338217,0.0695589,-2.2638097
-1615570580,52.1324600,-2.3275729,0.1313797,0.0679691,-2.3388119,52.1324593,-2.3275842,0.1338473,0.0695072,-2.2629545
-1615570580,52.1324600,-2.3275729,0.1308897,0.0682131,-2.4785066,52.1324593,-2.3275842,0.1337595,0.0695376,-2.2639427
-1615570581,52.1324600,-2.3275727,0.1338039,0.0638218,-2.9401042,52.1324593,-2.3275842,0.1337849,0.0695045,-2.2633338
-1615570581,52.1324600,-2.3275726,0.1331091,0.0687011,-2.6719728,52.1324593,-2.3275842,0.1338088,0.0695308,-2.2635238
-1615570582,52.1324601,-2.3275725,0.1348323,0.0687011,-2.2035470,52.1324593,-2.3275841,0.1337459,0.0695127,-2.2637019
-1615570582,52.1324601,-2.3275725,0.1350583,0.0665052,-2.5195720,52.1324593,-2.3275841,0.1338235,0.0695025,-2.2630498
-1615570582,52.1324602,-2.3275724,0.1279104,0.0650414,-2.5454307,52.1324593,-2.3275841,0.1339115,0.0694316,-2.2615252
-1615570583,52.1324602,-2.3275723,0.1320878,0.0645536,-2.2358806,52.1324593,-2.3275841,0.1338033,0.0694340,-2.2622771
-1615570583,52.1324602,-2.3275721,0.1315999,0.0650414,-2.3755360,52.1324593,-2.3275841,0.1338143,0.0695129,-2.2632513
-1615570583,52.1324602,-2.3275719,0.1355732,0.0689451,-2.5460048,52.1324593,-2.3275841,0.1339280,0.0694645,-2.2618532
-1615570584,52.1324602,-2.3275717,0.1335946,0.0679691,-2.2892487,52.1324593,-2.3275841,0.1340473,0.0695571,-2.2622848
-1615570584,52.1324602,-2.3275716,0.1355484,0.0662612,-2.5558357,52.1324593,-2.3275841,0.1340156,0.0694652,-2.2612805
-1615570585,52.1324603,-2.3275715,0.1340803,0.0672371,-2.5936875,52.1324593,-2.3275841,0.1340815,0.0694853,-2.2611091
-1615570585,52.1324603,-2.3275714,0.1330616,0.0633339,-1.8565360,52.1324593,-2.3275841,0.1340698,0.0695468,-2.2619994
-1615570585,52.1324604,-2.3275713,0.1306592,0.0699211,-2.2130003,52.1324593,-2.3275840,0.1340845,0.0695744,-2.2622669
-1615570586,52.1324605,-2.3275711,0.1345815,0.0682131,-2.1936576,52.1324593,-2.3275840,0.1340571,0.0696087,-2.2629004
-1615570586,52.1324605,-2.3275710,0.1306222,0.0657733,-2.3903980,52.1324593,-2.3275840,0.1340203,0.0695907,-2.2629070
-1615570586,52.1324606,-2.3275708,0.1333620,0.0694331,-2.4501903,52.1324593,-2.3275840,0.1339085,0.0695506,-2.2631187
-1615570587,52.1324607,-2.3275708,0.1368068,0.0691891,-2.1241794,52.1324593,-2.3275840,0.1339209,0.0696421,-2.2642474
-1615570587,52.1324608,-2.3275708,0.1335727,0.0655293,-2.0663180,52.1324593,-2.3275840,0.1339066,0.0697142,-2.2652962
-1615570588,52.1324609,-2.3275706,0.1325905,0.0657733,-1.9953833,52.1324593,-2.3275840,0.1337333,0.0696824,-2.2660263
-1615570588,52.1324610,-2.3275705,0.1331002,0.0677251,-2.0763330,52.1324593,-2.3275840,0.1337407,0.0697039,-2.2662621
-1615570588,52.1324610,-2.3275704,0.1315978,0.0647975,-1.7527286,52.1324593,-2.3275840,0.1338265,0.0697183,-2.2658818
-1615570589,52.1324611,-2.3275705,0.1286221,0.0618705,-2.6437974,52.1324593,-2.3275840,0.1338394,0.0696272,-2.2645898
-1615570589,52.1324612,-2.3275705,0.1279228,0.0665052,-2.0824223,52.1324593,-2.3275839,0.1337873,0.0696160,-2.2647886
-1615570589,52.1324612,-2.3275705,0.1333309,0.0660173,-2.2016358,52.1324593,-2.3275839,0.1339495,0.0696682,-2.2644014
-1615570590,52.1324613,-2.3275705,0.1301323,0.0660173,-2.6047103,52.1324593,-2.3275839,0.1338949,0.0696296,-2.2642531
-1615570590,52.1324614,-2.3275705,0.1316148,0.0667492,-2.6133413,52.1324593,-2.3275839,0.1338561,0.0696186,-2.2643650
-1615570591,52.1324614,-2.3275704,0.1315773,0.0623583,-1.7503821,52.1324593,-2.3275839,0.1338337,0.0697233,-2.2659011
-1615570591,52.1324615,-2.3275703,0.1333331,0.0662612,-2.2116182,52.1324593,-2.3275839,0.1337555,0.0696700,-2.2657144
-1615570591,52.1324616,-2.3275704,0.1298596,0.0628461,-2.6153913,52.1324593,-2.3275839,0.1337920,0.0696659,-2.2654169
-1615570592,52.1324617,-2.3275704,0.1328453,0.0667492,-2.1271675,52.1324593,-2.3275839,0.1337424,0.0696975,-2.2661667
-1615570592,52.1324618,-2.3275704,0.1293964,0.0662612,-1.6812534,52.1324593,-2.3275839,0.1337926,0.0697663,-2.2667437
-1615570592,52.1324618,-2.3275704,0.1331002,0.0677251,-2.0576217,52.1324593,-2.3275838,0.1338074,0.0697404,-2.2663021
-1615570593,52.1324619,-2.3275703,0.1318397,0.0643096,-1.6137547,52.1324593,-2.3275838,0.1338679,0.0697317,-2.2657850
-1615570593,52.1324619,-2.3275704,0.1331002,0.0677251,-2.2839975,52.1324593,-2.3275838,0.1340911,0.0697095,-2.2640114
-1615570594,52.1324620,-2.3275704,0.1355506,0.0665052,-2.7904947,52.1324593,-2.3275838,0.1341068,0.0696604,-2.2632608
-1615570594,52.1324620,-2.3275705,0.1330979,0.0674811,-1.9824632,52.1324593,-2.3275838,0.1340656,0.0696565,-2.2634811
-1615570594,52.1324621,-2.3275704,0.1298926,0.0667492,-2.1777709,52.1324593,-2.3275838,0.1341368,0.0696779,-2.2632923
-1615570595,52.1324622,-2.3275704,0.1294311,0.0701652,-2.0837102,52.1324593,-2.3275838,0.1341468,0.0697432,-2.2640872
-1615570595,52.1324622,-2.3275704,0.1328260,0.0645536,-2.3189130,52.1324593,-2.3275838,0.1340856,0.0697643,-2.2647700
-1615570595,52.1324623,-2.3275703,0.1323402,0.0652854,-2.3304901,52.1324593,-2.3275838,0.1341990,0.0697632,-2.2640061
-1615570596,52.1324624,-2.3275702,0.1335770,0.0660173,-2.4189343,52.1324593,-2.3275838,0.1342633,0.0698680,-2.2649596
-1615570596,52.1324625,-2.3275702,0.1318418,0.0645536,-1.9454368,52.1324593,-2.3275837,0.1342017,0.0699628,-2.2666132
-1615570597,52.1324626,-2.3275701,0.1343376,0.0684571,-2.0589147,52.1324593,-2.3275837,0.1341112,0.0700064,-2.2677858
-1615570597,52.1324627,-2.3275700,0.1333202,0.0647975,3.1282485,52.1324593,-2.3275837,0.1342039,0.0701078,-2.2685065
-1615570597,52.1324628,-2.3275700,0.1318740,0.0682131,-2.2566855,52.1324593,-2.3275837,0.1342051,0.0701705,-2.2693229
-1615570598,52.1324628,-2.3275699,0.1306393,0.0677251,-2.4088340,52.1324593,-2.3275837,0.1342336,0.0700892,-2.2680659
-1615570598,52.1324629,-2.3275698,0.1321427,0.0706532,-1.9865242,52.1324594,-2.3275837,0.1341417,0.0700467,-2.2681143
-1615570598,52.1324630,-2.3275699,0.1311121,0.0655293,-2.6798515,52.1324594,-2.3275837,0.1341326,0.0700052,-2.2676291
-1615570599,52.1324631,-2.3275697,0.1288879,0.0643096,-1.8271896,52.1324594,-2.3275837,0.1341574,0.0699932,-2.2673066
-1615570599,52.1324631,-2.3275698,0.1323729,0.0689451,-2.4629917,52.1324594,-2.3275837,0.1341897,0.0700068,-2.2672722
-1615570600,52.1324631,-2.3275697,0.1347990,0.0650414,-1.9820452,52.1324594,-2.3275836,0.1342079,0.0700397,-2.2675855
-1615570600,52.1324633,-2.3275697,0.1316148,0.0667492,-1.9751660,52.1324594,-2.3275836,0.1341189,0.0699473,-2.2669568
-1615570600,52.1324633,-2.3275696,0.1331296,0.0708973,-2.5961866,52.1324594,-2.3275836,0.1341595,0.0700376,-2.2678764
-1615570601,52.1324634,-2.3275697,0.1330784,0.0652854,-2.0727663,52.1324594,-2.3275836,0.1341139,0.0700479,-2.2683132
-1615570601,52.1324636,-2.3275697,0.1360298,0.0650414,-2.5482049,52.1324594,-2.3275836,0.1340637,0.0700215,-2.2682979
-1615570601,52.1324637,-2.3275696,0.1340715,0.0662612,-2.5470729,52.1324594,-2.3275836,0.1339908,0.0700120,-2.2686543
-1615570602,52.1324637,-2.3275697,0.1335836,0.0667492,-1.7910739,52.1324594,-2.3275836,0.1340855,0.0700556,-2.2686028
-1615570602,52.1324638,-2.3275696,0.1347717,0.0618705,-2.0753384,52.1324594,-2.3275836,0.1341790,0.0700479,-2.2678835
-1615570603,52.1324638,-2.3275696,0.1345861,0.0687011,-2.6488955,52.1324594,-2.3275836,0.1340956,0.0698739,-2.2661452
-1615570603,52.1324639,-2.3275697,0.1333507,0.0682131,-2.5598829,52.1324594,-2.3275836,0.1340388,0.0698732,-2.2665117
-1615570603,52.1324640,-2.3275697,0.1318718,0.0679691,-2.8323843,52.1324594,-2.3275835,0.1341397,0.0698364,-2.2653584
-1615570604,52.1324641,-2.3275698,0.1385822,0.0743143,-1.4495599,52.1324594,-2.3275835,0.1340940,0.0699021,-2.2665262
-1615570604,52.1324641,-2.3275698,0.1284231,0.0674811,-2.2610435,52.1324594,-2.3275835,0.1341824,0.0698416,-2.2651455
-1615570604,52.1324641,-2.3275699,0.1380039,0.0655293,-2.6367083,52.1324594,-2.3275835,0.1342833,0.0698045,-2.2639909
-1615570605,52.1324642,-2.3275699,0.1318785,0.0687011,-2.3520255,52.1324594,-2.3275835,0.1343187,0.0697876,-2.2635341
-1615570605,52.1324642,-2.3275699,0.1325948,0.0662612,-2.2762818,52.1324594,-2.3275835,0.1342967,0.0698329,-2.2642753
-1615570606,52.1324643,-2.3275700,0.1343133,0.0657733,-2.6786003,52.1324594,-2.3275835,0.1342724,0.0699809,-2.2663801
-1615570606,52.1324643,-2.3275700,0.1310833,0.0621144,-2.7642074,52.1324594,-2.3275835,0.1343861,0.0698756,-2.2642474
-1615570606,52.1324644,-2.3275701,0.1308598,0.0647975,-2.1288314,52.1324594,-2.3275835,0.1343846,0.0698754,-2.2642558
-1615570607,52.1324644,-2.3275701,0.1340736,0.0665052,-1.3201053,52.1324594,-2.3275835,0.1344418,0.0700160,-2.2657218
-1615570607,52.1324644,-2.3275702,0.1360520,0.0674811,-2.0231819,52.1324594,-2.3275834,0.1345934,0.0700406,-2.2650478
-1615570607,52.1324645,-2.3275702,0.1323317,0.0643096,-2.6655786,52.1324594,-2.3275834,0.1344567,0.0699810,-2.2651656
-1615570608,52.1324646,-2.3275702,0.1264310,0.0645536,-2.7001107,52.1324594,-2.3275834,0.1344345,0.0699508,-2.2649164
-1615570608,52.1324647,-2.3275702,0.1333309,0.0660173,-2.4116313,52.1324594,-2.3275834,0.1345066,0.0699562,-2.2645128
-1615570609,52.1324647,-2.3275703,0.1340564,0.0645536,-2.1301365,52.1324594,-2.3275834,0.1345187,0.0700521,-2.2656891
-1615570609,52.1324648,-2.3275703,0.1281502,0.0643096,2.9635267,52.1324595,-2.3275834,0.1344469,0.0700313,-2.2658892
-1615570609,52.1324648,-2.3275704,0.1330892,0.0665052,-2.3964286,52.1324595,-2.3275834,0.1345259,0.0699907,-2.2648375
-1615570610,52.1324649,-2.3275704,0.1318192,0.0618705,-2.2743518,52.1324595,-2.3275834,0.1344380,0.0699012,-2.2642424
-1615570610,52.1324649,-2.3275703,0.1328540,0.0677251,-1.7819622,52.1324595,-2.3275834,0.1343620,0.0698593,-2.2641935
-1615570610,52.1324650,-2.3275704,0.1365422,0.0672371,-1.9658616,52.1324595,-2.3275834,0.1343525,0.0697770,-2.2631748
-1615570611,52.1324650,-2.3275704,0.1318173,0.0616266,-2.2874830,52.1324595,-2.3275833,0.1344093,0.0697700,-2.2627077
-1615570611,52.1324651,-2.3275705,0.1335663,0.0647975,-3.0377705,52.1324595,-2.3275833,0.1343834,0.0697348,-2.2624164
-1615570612,52.1324652,-2.3275704,0.1328176,0.0635778,-2.7343910,52.1324595,-2.3275833,0.1343748,0.0696284,-2.2610743
-1615570612,52.1324652,-2.3275705,0.1318718,0.0679691,-2.1254652,52.1324595,-2.3275833,0.1343821,0.0694948,-2.2592678
-1615570612,52.1324652,-2.3275706,0.1350539,0.0660173,-1.8970237,52.1324595,-2.3275833,0.1344157,0.0695052,-2.2591832
-1615570613,52.1324652,-2.3275705,0.1353022,0.0662612,-2.0437431,52.1324595,-2.3275833,0.1344472,0.0694467,-2.2582057
-1615570613,52.1324652,-2.3275706,0.1301239,0.0650414,-2.2951853,52.1324595,-2.3275833,0.1345093,0.0694373,-2.2576733
-1615570613,52.1324653,-2.3275707,0.1330957,0.0672371,-1.9734851,52.1324595,-2.3275833,0.1345274,0.0693550,-2.2564707
-1615570614,52.1324653,-2.3275707,0.1320857,0.0643096,-2.5195475,52.1324595,-2.3275833,0.1344390,0.0693219,-2.2566185
-1615570614,52.1324653,-2.3275707,0.1313863,0.0687011,-2.3779752,52.1324595,-2.3275833,0.1343951,0.0692616,-2.2561145
-1615570615,52.1324654,-2.3275708,0.1331002,0.0677251,-2.0746722,52.1324595,-2.3275832,0.1343625,0.0692529,-2.2562151
-1615570615,52.1324655,-2.3275709,0.1348121,0.0665052,-2.7282436,52.1324595,-2.3275832,0.1342898,0.0692928,-2.2572222
-1615570615,52.1324656,-2.3275709,0.1310734,0.0608949,-1.4097311,52.1324595,-2.3275832,0.1342473,0.0693454,-2.2581975
-1615570616,52.1324656,-2.3275709,0.1347676,0.0613827,-2.0601583,52.1324595,-2.3275832,0.1341721,0.0693160,-2.2583082
-1615570616,52.1324657,-2.3275709,0.1326168,0.0687011,-2.6406331,52.1324595,-2.3275832,0.1341717,0.0692723,-2.2577338
-1615570616,52.1324657,-2.3275710,0.1301365,0.0665052,-2.5374360,52.1324595,-2.3275832,0.1340850,0.0692517,-2.2580357
-1615570617,52.1324658,-2.3275712,0.1340915,0.0684571,-2.2118821,52.1324595,-2.3275832,0.1340515,0.0692668,-2.2584577
-1615570617,52.1324659,-2.3275712,0.1367884,0.0672371,-2.3172624,52.1324595,-2.3275832,0.1339949,0.0692992,-2.2592626
-1615570618,52.1324659,-2.3275713,0.1350830,0.0691891,-2.3717825,52.1324596,-2.3275832,0.1339019,0.0694217,-2.2615042
-1615570618,52.1324659,-2.3275714,0.1308598,0.0647975,-2.2787364,52.1324596,-2.3275832,0.1338586,0.0694378,-2.2620046
-1615570618,52.1324660,-2.3275714,0.1323444,0.0657733,-1.7622247,52.1324596,-2.3275832,0.1339022,0.0695476,-2.2631702
-1615570619,52.1324660,-2.3275715,0.1380129,0.0665052,-2.2059512,52.1324596,-2.3275831,0.1338067,0.0694233,-2.2621567
-1615570619,52.1324660,-2.3275716,0.1326146,0.0684571,-2.5288763,52.1324596,-2.3275831,0.1338840,0.0694545,-2.2620568
-1615570619,52.1324661,-2.3275717,0.1363142,0.0691891,-3.0612185,52.1324596,-2.3275831,0.1338690,0.0693136,-2.2602892
-1615570620,52.1324661,-2.3275718,0.1320857,0.0643096,-2.0917425,52.1324596,-2.3275831,0.1337597,0.0691450,-2.2587774
-1615570620,52.1324662,-2.3275718,0.1330473,0.0616266,-1.7158206,52.1324596,-2.3275831,0.1337942,0.0691760,-2.2589593
-1615570621,52.1324662,-2.3275719,0.1288982,0.0655293,-2.3673155,52.1324596,-2.3275831,0.1338441,0.0691630,-2.2584546
-1615570621,52.1324662,-2.3275721,0.1345838,0.0684571,-2.0572321,52.1324596,-2.3275831,0.1338652,0.0691699,-2.2584057
-1615570621,52.1324663,-2.3275722,0.1323552,0.0669931,-2.3407595,52.1324596,-2.3275831,0.1338371,0.0691018,-2.2576883
-1615570622,52.1324663,-2.3275723,0.1330892,0.0665052,-2.1201034,52.1324596,-2.3275831,0.1337109,0.0689806,-2.2569172
-1615570622,52.1324663,-2.3275724,0.1313863,0.0687011,-2.4791651,52.1324596,-2.3275831,0.1335160,0.0689685,-2.2580600
-1615570622,52.1324664,-2.3275726,0.1340915,0.0684571,-2.2928784,52.1324596,-2.3275831,0.1334934,0.0689587,-2.2580795
-1615570623,52.1324664,-2.3275728,0.1328474,0.0669931,-1.9662967,52.1324596,-2.3275831,0.1335229,0.0689924,-2.2583318
-1615570623,52.1324664,-2.3275728,0.1301386,0.0667492,-1.8595753,52.1324596,-2.3275831,0.1336126,0.0689751,-2.2575011
-1615570624,52.1324664,-2.3275730,0.1271850,0.0665052,-2.6870742,52.1324596,-2.3275830,0.1336583,0.0689812,-2.2572773
-1615570624,52.1324665,-2.3275731,0.1330805,0.0655293,-2.2479203,52.1324596,-2.3275830,0.1336722,0.0689173,-2.2563310
-1615570624,52.1324665,-2.3275733,0.1326236,0.0694331,-2.4533653,52.1324596,-2.3275830,0.1335857,0.0689736,-2.2576618
-1615570625,52.1324666,-2.3275733,0.1299300,0.0708973,-2.3175476,52.1324596,-2.3275830,0.1335556,0.0689534,-2.2575932
-1615570625,52.1324666,-2.3275734,0.1303911,0.0674811,-2.6542315,52.1324596,-2.3275830,0.1334768,0.0688946,-2.2573352
-1615570625,52.1324667,-2.3275734,0.1363119,0.0689451,-2.2703190,52.1324597,-2.3275830,0.1334604,0.0688987,-2.2575002
-1615570626,52.1324667,-2.3275735,0.1345659,0.0665052,-2.6839128,52.1324597,-2.3275830,0.1334918,0.0688844,-2.2570987
-1615570626,52.1324668,-2.3275736,0.1313688,0.0667492,-2.0195193,52.1324597,-2.3275830,0.1334562,0.0688261,-2.2565579
-1615570627,52.1324668,-2.3275738,0.1318920,0.0701652,-2.7671757,52.1324597,-2.3275830,0.1333967,0.0687039,-2.2553205
-1615570627,52.1324669,-2.3275739,0.1335880,0.0672371,-2.6901762,52.1324597,-2.3275830,0.1334753,0.0687361,-2.2552242
-1615570627,52.1324669,-2.3275741,0.1325862,0.0652854,-2.2607639,52.1324597,-2.3275830,0.1336072,0.0686217,-2.2528076
-1615570628,52.1324669,-2.3275743,0.1303720,0.0652854,-2.6819420,52.1324597,-2.3275830,0.1335531,0.0685783,-2.2525899
-1615570628,52.1324670,-2.3275745,0.1330892,0.0665052,-1.9637125,52.1324597,-2.3275830,0.1334887,0.0685807,-2.2530556
-1615570628,52.1324670,-2.3275747,0.1299056,0.0682131,-2.1357732,52.1324597,-2.3275830,0.1334089,0.0685867,-2.2536716
-1615570629,52.1324671,-2.3275749,0.1327973,0.0611388,-2.2517796,52.1324597,-2.3275829,0.1334420,0.0686707,-2.2545767
-1615570629,52.1324671,-2.3275750,0.1316041,0.0655293,-2.6737821,52.1324597,-2.3275829,0.1334737,0.0686974,-2.2547202
-1615570630,52.1324671,-2.3275752,0.1338498,0.0689451,-2.9090455,52.1324597,-2.3275829,0.1335394,0.0686401,-2.2535117
-1615570630,52.1324671,-2.3275754,0.1333224,0.0650414,-1.9458743,52.1324597,-2.3275829,0.1335503,0.0685463,-2.2521832
-1615570630,52.1324671,-2.3275756,0.1298821,0.0655293,-2.4661312,52.1324597,-2.3275829,0.1334108,0.0684941,-2.2524211
-1615570631,52.1324671,-2.3275757,0.1318830,0.0691891,-2.0277305,52.1324597,-2.3275829,0.1334514,0.0684827,-2.2519946
-1615570631,52.1324672,-2.3275759,0.1345444,0.0640657,-1.9678926,52.1324597,-2.3275829,0.1334124,0.0684152,-2.2513509
-1615570631,52.1324672,-2.3275761,0.1377734,0.0672371,-1.8580317,52.1324597,-2.3275829,0.1333607,0.0684459,-2.2521122
-1615570632,52.1324672,-2.3275764,0.1311228,0.0667492,-2.2317073,52.1324597,-2.3275829,0.1333119,0.0685061,-2.2532513
-1615570632,52.1324672,-2.3275765,0.1296530,0.0674811,-2.7891517,52.1324598,-2.3275829,0.1333257,0.0685481,-2.2537212
-1615570633,52.1324672,-2.3275766,0.1308640,0.0652854,-2.2938862,52.1324598,-2.3275829,0.1332711,0.0684839,-2.2532265
-1615570633,52.1324671,-2.3275768,0.1296136,0.0628461,-2.0767961,52.1324598,-2.3275829,0.1332555,0.0684844,-2.2533395
-1615570633,52.1324672,-2.3275769,0.1296403,0.0660173,-2.0126896,52.1324598,-2.3275829,0.1333028,0.0684873,-2.2530580
-1615570634,52.1324671,-2.3275771,0.1288982,0.0655293,-1.8037853,52.1324598,-2.3275829,0.1333352,0.0684487,-2.2523217
-1615570634,52.1324671,-2.3275772,0.1333160,0.0643096,-2.3063059,52.1324598,-2.3275829,0.1332735,0.0684152,-2.2522876
-1615570634,52.1324671,-2.3275774,0.1330763,0.0650414,-2.2572868,52.1324598,-2.3275829,0.1333710,0.0684125,-2.2515922
-1615570635,52.1324670,-2.3275776,0.1316192,0.0672371,-2.3030865,52.1324598,-2.3275829,0.1333888,0.0683942,-2.2512269
-1615570635,52.1324671,-2.3275777,0.1338385,0.0677251,-1.9793324,52.1324598,-2.3275829,0.1334074,0.0683516,-2.2505295
-1615570636,52.1324670,-2.3275778,0.1343068,0.0650414,-1.8231755,52.1324598,-2.3275829,0.1333494,0.0683646,-2.2510939
-1615570636,52.1324670,-2.3275780,0.1271829,0.0662612,-2.6136196,52.1324598,-2.3275829,0.1334510,0.0682805,-2.2492800
-1615570636,52.1324671,-2.3275781,0.1293985,0.0665052,-2.4955680,52.1324598,-2.3275829,0.1333847,0.0681348,-2.2477670
-1615570637,52.1324671,-2.3275783,0.1350430,0.0647975,-1.9198349,52.1324598,-2.3275829,0.1332024,0.0681111,-2.2486796
-1615570637,52.1324671,-2.3275784,0.1333441,0.0674811,-2.4538808,52.1324598,-2.3275829,0.1331591,0.0681037,-2.2488737
-1615570637,52.1324671,-2.3275786,0.1321335,0.0696771,-2.1327047,52.1324598,-2.3275828,0.1330811,0.0680983,-2.2493300
-1615570638,52.1324670,-2.3275787,0.1294135,0.0682131,-2.3579712,52.1324598,-2.3275828,0.1331072,0.0681321,-2.2496090
-1615570638,52.1324670,-2.3275788,0.1336036,0.0689451,-2.2115293,52.1324598,-2.3275828,0.1330482,0.0679968,-2.2481802
-1615570639,52.1324669,-2.3275790,0.1318460,0.0650414,2.7738366,52.1324598,-2.3275828,0.1329193,0.0679970,-2.2490582
-1615570639,52.1324669,-2.3275791,0.1325820,0.0647975,-1.7520183,52.1324598,-2.3275828,0.1328131,0.0680283,-2.2502065
-1615570639,52.1324669,-2.3275792,0.1306243,0.0660173,-2.1263247,52.1324598,-2.3275828,0.1327304,0.0680214,-2.2506762
-1615570640,52.1324668,-2.3275793,0.1367839,0.0667492,-1.8106701,52.1324599,-2.3275828,0.1327139,0.0680712,-2.2514653
-1615570640,52.1324668,-2.3275794,0.1326057,0.0674811,-2.8107977,52.1324599,-2.3275828,0.1328988,0.0680370,-2.2497425
-1615570640,52.1324668,-2.3275796,0.1286319,0.0630900,-2.1071932,52.1324599,-2.3275828,0.1328910,0.0680689,-2.2502277
-1615570641,52.1324668,-2.3275795,0.1311358,0.0682131,-1.8793947,52.1324599,-2.3275828,0.1329177,0.0681235,-2.2507856
-1615570641,52.1324668,-2.3275795,0.1293985,0.0665052,-2.4525433,52.1324599,-2.3275828,0.1330809,0.0681649,-2.2502384
-1615570642,52.1324668,-2.3275795,0.1321637,0.0728498,-2.2114418,52.1324599,-2.3275828,0.1331138,0.0681469,-2.2497721
-1615570642,52.1324668,-2.3275796,0.1316391,0.0694331,-2.3935974,52.1324599,-2.3275828,0.1331965,0.0681727,-2.2495606
-1615570642,52.1324668,-2.3275797,0.1311249,0.0669931,-2.1449718,52.1324599,-2.3275828,0.1332232,0.0682483,-2.2503984
-1615570643,52.1324668,-2.3275796,0.1328697,0.0694331,2.8834794,52.1324599,-2.3275828,0.1332802,0.0682997,-2.2507055
-1615570643,52.1324668,-2.3275796,0.1306637,0.0704092,-2.5670528,52.1324599,-2.3275828,0.1332223,0.0682879,-2.2509387
-1615570643,52.1324668,-2.3275797,0.1288920,0.0647975,-2.3123095,52.1324599,-2.3275828,0.1332328,0.0682590,-2.2504783
-1615570644,52.1324668,-2.3275798,0.1301582,0.0689451,-2.4573936,52.1324599,-2.3275828,0.1331991,0.0681836,-2.2496898
-1615570644,52.1324668,-2.3275799,0.1338408,0.0679691,-2.2905378,52.1324599,-2.3275828,0.1331930,0.0681623,-2.2494435
-1615570645,52.1324668,-2.3275800,0.1350561,0.0662612,-2.9579754,52.1324599,-2.3275828,0.1330883,0.0682243,-2.2509899
-1615570645,52.1324668,-2.3275801,0.1336014,0.0687011,-2.5758243,52.1324599,-2.3275828,0.1330577,0.0682456,-2.2514851
-1615570645,52.1324668,-2.3275802,0.1335516,0.0630900,-2.4065878,52.1324599,-2.3275828,0.1329074,0.0682895,-2.2530985
-1615570646,52.1324668,-2.3275803,0.1343154,0.0660173,-2.3233752,52.1324599,-2.3275828,0.1328466,0.0682892,-2.2535076
-1615570646,52.1324668,-2.3275805,0.1338232,0.0660173,-2.0352995,52.1324599,-2.3275828,0.1329555,0.0682686,-2.2524889
-1615570646,52.1324668,-2.3275806,0.1358080,0.0677251,-2.5024683,52.1324599,-2.3275828,0.1328607,0.0682208,-2.2524860
-1615570647,52.1324668,-2.3275808,0.1325841,0.0650414,-1.9727017,52.1324599,-2.3275828,0.1328791,0.0682691,-2.2530155
-1615570647,52.1324668,-2.3275808,0.1328562,0.0679691,-2.2366095,52.1324600,-2.3275828,0.1328396,0.0683294,-2.2540994
-1615570648,52.1324668,-2.3275810,0.1340982,0.0691891,-2.2253194,52.1324600,-2.3275828,0.1329630,0.0683797,-2.2539420
-1615570648,52.1324668,-2.3275812,0.1355573,0.0672371,-2.4093719,52.1324600,-2.3275828,0.1328467,0.0683797,-2.2547312
-1615570648,52.1324668,-2.3275813,0.1281401,0.0630900,-2.8726730,52.1324600,-2.3275828,0.1328860,0.0683799,-2.2544670
-1615570649,52.1324668,-2.3275814,0.1296403,0.0660173,-2.6027622,52.1324600,-2.3275828,0.1329012,0.0683980,-2.2546096
-1615570649,52.1324668,-2.3275816,0.1333643,0.0696771,-2.0763683,52.1324600,-2.3275828,0.1329397,0.0684022,-2.2544038
-1615570649,52.1324667,-2.3275815,0.1348461,0.0701652,-1.9237834,52.1324600,-2.3275828,0.1328824,0.0684071,-2.2548599
-1615570650,52.1324666,-2.3275817,0.1348077,0.0660173,-2.6337347,52.1324600,-2.3275828,0.1329592,0.0684646,-2.2551150
-1615570650,52.1324666,-2.3275818,0.1291218,0.0628461,-1.7691268,52.1324600,-2.3275828,0.1329065,0.0683828,-2.2543678
-1615570651,52.1324666,-2.3275819,0.1315834,0.0630900,-2.2323666,52.1324600,-2.3275828,0.1328917,0.0684216,-2.2549918
-1615570651,52.1324665,-2.3275820,0.1306035,0.0635778,-2.6970859,52.1324600,-2.3275828,0.1330707,0.0684967,-2.2547936
-1615570651,52.1324664,-2.3275820,0.1326304,0.0701652,-2.3787694,52.1324600,-2.3275828,0.1330630,0.0685039,-2.2549424
-1615570652,52.1324664,-2.3275822,0.1338566,0.0696771,-1.9717491,52.1324600,-2.3275828,0.1330709,0.0683764,-2.2531691
-1615570652,52.1324663,-2.3275822,0.1369868,0.0618705,-1.7429751,52.1324600,-2.3275828,0.1329656,0.0683462,-2.2534761
-1615570652,52.1324663,-2.3275823,0.1318718,0.0679691,-2.5279684,52.1324600,-2.3275828,0.1329812,0.0684067,-2.2541871
diff --git a/python_utils/test_data/raw_vs_ekf.png b/python_utils/test_data/raw_vs_ekf.png
deleted file mode 100644
index a8c9e680efece852dd913ebe425cc6d0e5d726bb..0000000000000000000000000000000000000000
GIT binary patch
literal 0
HcmV?d00001

literal 331991
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%0A`#;@P_P<*cm@+IS
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
z%0D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
C0NG#w

